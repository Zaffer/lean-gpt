{"path": "Mathlib/CategoryTheory/Shift/Opposite.lean", "imports": ["Mathlib/CategoryTheory/Shift/Basic.lean", "Mathlib/CategoryTheory/Preadditive/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.HasShift.mkShiftCoreOp", "code": "noncomputable def mkShiftCoreOp : ShiftMkCore C\u1d52\u1d56 A where\n  F n := (shiftFunctor C n).op\n  zero := (NatIso.op (shiftFunctorZero C A)).symm\n  add a b := (NatIso.op (shiftFunctorAdd C a b)).symm\n  assoc_hom_app m\u2081 m\u2082 m\u2083 X :=\n    Quiver.Hom.unop_inj ((shiftFunctorAdd_assoc_inv_app m\u2081 m\u2082 m\u2083 X.unop).trans\n      (by simp [shiftFunctorAdd']))\n  zero_add_hom_app n X :=\n    Quiver.Hom.unop_inj ((shiftFunctorAdd_zero_add_inv_app n X.unop).trans (by simp))\n  add_zero_hom_app n X :=\n    Quiver.Hom.unop_inj ((shiftFunctorAdd_add_zero_inv_app n X.unop).trans (by simp))", "start": [33, 1], "end": [45, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OppositeShift", "code": "@[nolint unusedArguments]\ndef OppositeShift (A : Type*) [AddMonoid A] [HasShift C A] := C\u1d52\u1d56", "start": [49, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.oppositeShiftFunctorZero_inv_app", "code": "lemma oppositeShiftFunctorZero_inv_app (X : OppositeShift C A) :\n    (shiftFunctorZero (OppositeShift C A) A).inv.app X =\n      ((shiftFunctorZero C A).hom.app X.unop).op := rfl", "start": [74, 1], "end": [76, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.oppositeShiftFunctorZero_hom_app", "code": "lemma oppositeShiftFunctorZero_hom_app (X : OppositeShift C A) :\n    (shiftFunctorZero (OppositeShift C A) A).hom.app X =\n      ((shiftFunctorZero C A).inv.app X.unop).op := by\n  rw [\u2190 cancel_mono ((shiftFunctorZero (OppositeShift C A) A).inv.app X),\n    Iso.hom_inv_id_app, oppositeShiftFunctorZero_inv_app, \u2190 op_comp,\n    Iso.hom_inv_id_app, op_id]\n  rfl", "start": [78, 1], "end": [84, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.oppositeShiftFunctorAdd_inv_app", "code": "lemma oppositeShiftFunctorAdd_inv_app :\n    (shiftFunctorAdd (OppositeShift C A) a b).inv.app X =\n      ((shiftFunctorAdd C a b).hom.app X.unop).op := rfl", "start": [89, 1], "end": [91, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.oppositeShiftFunctorAdd_hom_app", "code": "lemma oppositeShiftFunctorAdd_hom_app :\n    (shiftFunctorAdd (OppositeShift C A) a b).hom.app X =\n      ((shiftFunctorAdd C a b).inv.app X.unop).op := by\n  rw [\u2190 cancel_mono ((shiftFunctorAdd (OppositeShift C A) a b).inv.app X),\n    Iso.hom_inv_id_app, oppositeShiftFunctorAdd_inv_app, \u2190 op_comp,\n    Iso.hom_inv_id_app, op_id]\n  rfl", "start": [93, 1], "end": [99, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.oppositeShiftFunctorAdd'_inv_app", "code": "lemma oppositeShiftFunctorAdd'_inv_app :\n    (shiftFunctorAdd' (OppositeShift C A) a b c h).inv.app X =\n      ((shiftFunctorAdd' C a b c h).hom.app X.unop).op := by\n  subst h\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, oppositeShiftFunctorAdd_inv_app]", "start": [101, 1], "end": [105, 83], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.oppositeShiftFunctorAdd'_hom_app", "code": "lemma oppositeShiftFunctorAdd'_hom_app :\n    (shiftFunctorAdd' (OppositeShift C A) a b c h).hom.app X =\n      ((shiftFunctorAdd' C a b c h).inv.app X.unop).op := by\n  subst h\n  simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, oppositeShiftFunctorAdd_hom_app]", "start": [107, 1], "end": [111, 83], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Shift/Pullback.lean", "imports": ["Mathlib/CategoryTheory/Shift/Basic.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.PullbackShift", "code": "@[nolint unusedArguments]\ndef PullbackShift (_ : A \u2192+ B) [HasShift C B] := C", "start": [24, 1], "end": [27, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pullbackShiftIso", "code": "noncomputable def pullbackShiftIso (a : A) (b : B) (h : b = \u03c6 a) :\n    shiftFunctor (PullbackShift C \u03c6) a \u2245 shiftFunctor C b := eqToIso (by subst h; rfl)", "start": [53, 1], "end": [56, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pullbackShiftFunctorZero_inv_app", "code": "lemma pullbackShiftFunctorZero_inv_app :\n    (shiftFunctorZero _ A).inv.app X =\n      (shiftFunctorZero C B).inv.app X \u226b (pullbackShiftIso C \u03c6 0 0 (by simp)).inv.app X := by\n  change (shiftFunctorZero C B).inv.app X \u226b _ = _\n  dsimp [Discrete.eqToHom]\n  congr 2\n  apply eqToHom_map", "start": [62, 1], "end": [68, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.pullbackShiftFunctorZero_hom_app", "code": "lemma pullbackShiftFunctorZero_hom_app :\n    (shiftFunctorZero _ A).hom.app X =\n      (pullbackShiftIso C \u03c6 0 0 (by simp)).hom.app X \u226b (shiftFunctorZero C B).hom.app X := by\n  rw [\u2190 cancel_epi ((shiftFunctorZero _ A).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorZero_inv_app, assoc, Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app]\n  rfl", "start": [70, 1], "end": [75, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.pullbackShiftFunctorAdd'_inv_app", "code": "lemma pullbackShiftFunctorAdd'_inv_app :\n    (shiftFunctorAdd' _ a\u2081 a\u2082 a\u2083 h).inv.app X =\n      (shiftFunctor (PullbackShift C \u03c6) a\u2082).map ((pullbackShiftIso C \u03c6 a\u2081 b\u2081 h\u2081).hom.app X) \u226b\n        (pullbackShiftIso C \u03c6 a\u2082 b\u2082 h\u2082).hom.app _ \u226b\n        (shiftFunctorAdd' C b\u2081 b\u2082 b\u2083 (by rw [h\u2081, h\u2082, h\u2083, \u2190 h, \u03c6.map_add])).inv.app X \u226b\n        (pullbackShiftIso C \u03c6 a\u2083 b\u2083 h\u2083).inv.app X := by\n  subst h\u2081 h\u2082 h\n  obtain rfl : b\u2083 = \u03c6 a\u2081 + \u03c6 a\u2082 := by rw [h\u2083, \u03c6.map_add]\n  erw [Functor.map_id, id_comp, id_comp, shiftFunctorAdd'_eq_shiftFunctorAdd,\n    shiftFunctorAdd'_eq_shiftFunctorAdd]\n  change _ \u226b _ = _\n  congr 1\n  dsimp [Discrete.eqToHom]\n  congr 2\n  apply eqToHom_map", "start": [77, 1], "end": [91, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.pullbackShiftFunctorAdd'_hom_app", "code": "lemma pullbackShiftFunctorAdd'_hom_app :\n    (shiftFunctorAdd' _ a\u2081 a\u2082 a\u2083 h).hom.app X =\n      (pullbackShiftIso C \u03c6 a\u2083 b\u2083 h\u2083).hom.app X \u226b\n      (shiftFunctorAdd' C b\u2081 b\u2082 b\u2083 (by rw [h\u2081, h\u2082, h\u2083, \u2190 h, \u03c6.map_add])).hom.app X \u226b\n      (pullbackShiftIso C \u03c6 a\u2082 b\u2082 h\u2082).inv.app _ \u226b\n      (shiftFunctor (PullbackShift C \u03c6) a\u2082).map ((pullbackShiftIso C \u03c6 a\u2081 b\u2081 h\u2081).inv.app X) := by\n  rw [\u2190 cancel_epi ((shiftFunctorAdd' _ a\u2081 a\u2082 a\u2083 h).inv.app X), Iso.inv_hom_id_app,\n    pullbackShiftFunctorAdd'_inv_app \u03c6 X a\u2081 a\u2082 a\u2083 h b\u2081 b\u2082 b\u2083 h\u2081 h\u2082 h\u2083, assoc, assoc, assoc,\n    Iso.inv_hom_id_app_assoc, Iso.inv_hom_id_app_assoc, Iso.hom_inv_id_app_assoc,\n    \u2190 Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n  rfl", "start": [93, 1], "end": [103, 6], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Triangulated/Triangulated.lean", "imports": ["Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Triangulated.Octahedron", "code": "structure Octahedron\n  {X\u2081 X\u2082 X\u2083 Z\u2081\u2082 Z\u2082\u2083 Z\u2081\u2083 : C}\n  {u\u2081\u2082 : X\u2081 \u27f6 X\u2082} {u\u2082\u2083 : X\u2082 \u27f6 X\u2083} {u\u2081\u2083 : X\u2081 \u27f6 X\u2083} (comm : u\u2081\u2082 \u226b u\u2082\u2083 = u\u2081\u2083)\n  {v\u2081\u2082 : X\u2082 \u27f6 Z\u2081\u2082} {w\u2081\u2082 : Z\u2081\u2082 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2082 : Triangle.mk u\u2081\u2082 v\u2081\u2082 w\u2081\u2082 \u2208 distTriang C)\n  {v\u2082\u2083 : X\u2083 \u27f6 Z\u2082\u2083} {w\u2082\u2083 : Z\u2082\u2083 \u27f6 X\u2082\u27e6(1 : \u2124)\u27e7} (h\u2082\u2083 : Triangle.mk u\u2082\u2083 v\u2082\u2083 w\u2082\u2083 \u2208 distTriang C)\n  {v\u2081\u2083 : X\u2083 \u27f6 Z\u2081\u2083} {w\u2081\u2083 : Z\u2081\u2083 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2083 : Triangle.mk u\u2081\u2083 v\u2081\u2083 w\u2081\u2083 \u2208 distTriang C)\n where\n  m\u2081 : Z\u2081\u2082 \u27f6 Z\u2081\u2083\n  m\u2083 : Z\u2081\u2083 \u27f6 Z\u2082\u2083\n  comm\u2081 : v\u2081\u2082 \u226b m\u2081 = u\u2082\u2083 \u226b v\u2081\u2083\n  comm\u2082 : m\u2081 \u226b w\u2081\u2083 = w\u2081\u2082\n  comm\u2083 : v\u2081\u2083 \u226b m\u2083 = v\u2082\u2083\n  comm\u2084 : w\u2081\u2083 \u226b u\u2081\u2082\u27e61\u27e7' = m\u2083 \u226b w\u2082\u2083\n  mem : Triangle.mk m\u2081 m\u2083 (w\u2082\u2083 \u226b v\u2081\u2082\u27e61\u27e7') \u2208 distTriang C", "start": [36, 1], "end": [51, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Triangulated.Octahedron.triangle", "code": "@[simps!]\ndef triangle : Triangle C :=\n  Triangle.mk h.m\u2081 h.m\u2083 (w\u2082\u2083 \u226b v\u2081\u2082\u27e61\u27e7')", "start": [73, 1], "end": [76, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Triangulated.Octahedron.triangleMorphism\u2081", "code": "@[simps]\ndef triangleMorphism\u2081 : Triangle.mk u\u2081\u2082 v\u2081\u2082 w\u2081\u2082 \u27f6 Triangle.mk u\u2081\u2083 v\u2081\u2083 w\u2081\u2083\n    where\n  hom\u2081 := \ud835\udfd9 X\u2081\n  hom\u2082 := u\u2082\u2083\n  hom\u2083 := h.m\u2081\n  comm\u2081 := by\n    dsimp\n    rw [id_comp, comm]\n  comm\u2082 := h.comm\u2081\n  comm\u2083 := by\n    dsimp\n    simpa only [Functor.map_id, comp_id] using h.comm\u2082.symm", "start": [79, 1], "end": [92, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Triangulated.Octahedron.triangleMorphism\u2082", "code": "@[simps]\ndef triangleMorphism\u2082 : Triangle.mk u\u2081\u2083 v\u2081\u2083 w\u2081\u2083 \u27f6 Triangle.mk u\u2082\u2083 v\u2082\u2083 w\u2082\u2083\n    where\n  hom\u2081 := u\u2081\u2082\n  hom\u2082 := \ud835\udfd9 X\u2083\n  hom\u2083 := h.m\u2083\n  comm\u2081 := by\n    dsimp\n    rw [comp_id, comm]\n  comm\u2082 := by\n    dsimp\n    rw [id_comp, h.comm\u2083]\n  comm\u2083 := h.comm\u2084", "start": [95, 1], "end": [108, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsTriangulated", "code": "class IsTriangulated : Prop where\n  \n  octahedron_axiom :\n    \u2200 {X\u2081 X\u2082 X\u2083 Z\u2081\u2082 Z\u2082\u2083 Z\u2081\u2083 : C}\n      {u\u2081\u2082 : X\u2081 \u27f6 X\u2082} {u\u2082\u2083 : X\u2082 \u27f6 X\u2083} {u\u2081\u2083 : X\u2081 \u27f6 X\u2083} (comm : u\u2081\u2082 \u226b u\u2082\u2083 = u\u2081\u2083)\n      {v\u2081\u2082 : X\u2082 \u27f6 Z\u2081\u2082} {w\u2081\u2082 : Z\u2081\u2082 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2082 : Triangle.mk u\u2081\u2082 v\u2081\u2082 w\u2081\u2082 \u2208 distTriang C)\n      {v\u2082\u2083 : X\u2083 \u27f6 Z\u2082\u2083} {w\u2082\u2083 : Z\u2082\u2083 \u27f6 X\u2082\u27e6(1 : \u2124)\u27e7} (h\u2082\u2083 : Triangle.mk u\u2082\u2083 v\u2082\u2083 w\u2082\u2083 \u2208 distTriang C)\n      {v\u2081\u2083 : X\u2083 \u27f6 Z\u2081\u2083} {w\u2081\u2083 : Z\u2081\u2083 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2083 : Triangle.mk u\u2081\u2083 v\u2081\u2083 w\u2081\u2083 \u2208 distTriang C),\n      Nonempty (Octahedron comm h\u2081\u2082 h\u2082\u2083 h\u2081\u2083)", "start": [120, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Triangulated.someOctahedron'", "code": "def someOctahedron' [IsTriangulated C] : Octahedron comm h\u2081\u2082 h\u2082\u2083 h\u2081\u2083 :=\n  (IsTriangulated.octahedron_axiom comm h\u2081\u2082 h\u2082\u2083 h\u2081\u2083).some", "start": [144, 1], "end": [146, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Triangulated.someOctahedron", "code": "def someOctahedron [IsTriangulated C]\n    {X\u2081 X\u2082 X\u2083 Z\u2081\u2082 Z\u2082\u2083 Z\u2081\u2083 : C}\n    {u\u2081\u2082 : X\u2081 \u27f6 X\u2082} {u\u2082\u2083 : X\u2082 \u27f6 X\u2083} {u\u2081\u2083 : X\u2081 \u27f6 X\u2083} (comm : u\u2081\u2082 \u226b u\u2082\u2083 = u\u2081\u2083)\n    {v\u2081\u2082 : X\u2082 \u27f6 Z\u2081\u2082} {w\u2081\u2082 : Z\u2081\u2082 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2082 : Triangle.mk u\u2081\u2082 v\u2081\u2082 w\u2081\u2082 \u2208 distTriang C)\n    {v\u2082\u2083 : X\u2083 \u27f6 Z\u2082\u2083} {w\u2082\u2083 : Z\u2082\u2083 \u27f6 X\u2082\u27e6(1 : \u2124)\u27e7} (h\u2082\u2083 : Triangle.mk u\u2082\u2083 v\u2082\u2083 w\u2082\u2083 \u2208 distTriang C)\n    {v\u2081\u2083 : X\u2083 \u27f6 Z\u2081\u2083} {w\u2081\u2083 : Z\u2081\u2083 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7} (h\u2081\u2083 : Triangle.mk u\u2081\u2083 v\u2081\u2083 w\u2081\u2083 \u2208 distTriang C) :\n    Octahedron comm h\u2081\u2082 h\u2082\u2083 h\u2081\u2083 :=\n  someOctahedron' _", "start": [148, 1], "end": [156, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Extensive.lean", "imports": ["Mathlib/CategoryTheory/Limits/FunctorCategory.lean", "Mathlib/CategoryTheory/Limits/Shapes/StrictInitial.lean", "Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/Types.lean"], "premises": [{"full_name": "CategoryTheory.NatTrans.Equifibered", "code": "def NatTrans.Equifibered {F G : J \u2964 C} (\u03b1 : F \u27f6 G) : Prop :=\n  \u2200 \u2983i j : J\u2984 (f : i \u27f6 j), IsPullback (F.map f) (\u03b1.app i) (\u03b1.app j) (G.map f)", "start": [56, 1], "end": [65, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.equifibered_of_isIso", "code": "theorem NatTrans.equifibered_of_isIso {F G : J \u2964 C} (\u03b1 : F \u27f6 G) [IsIso \u03b1] : Equifibered \u03b1", "start": [68, 1], "end": [69, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.Equifibered.comp", "code": "theorem NatTrans.Equifibered.comp {F G H : J \u2964 C} {\u03b1 : F \u27f6 G} {\u03b2 : G \u27f6 H} (h\u03b1 : Equifibered \u03b1)\n    (h\u03b2 : Equifibered \u03b2) : Equifibered (\u03b1 \u226b \u03b2)", "start": [72, 1], "end": [74, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsUniversalColimit", "code": "def IsUniversalColimit {F : J \u2964 C} (c : Cocone F) : Prop :=\n  \u2200 \u2983F' : J \u2964 C\u2984 (c' : Cocone F') (\u03b1 : F' \u27f6 F) (f : c'.pt \u27f6 c.pt)\n    (_ : \u03b1 \u226b c.\u03b9 = c'.\u03b9 \u226b (Functor.const J).map f) (_ : NatTrans.Equifibered \u03b1),\n    (\u2200 j : J, IsPullback (c'.\u03b9.app j) (\u03b1.app j) f (c.\u03b9.app j)) \u2192 Nonempty (IsColimit c')", "start": [77, 1], "end": [81, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsVanKampenColimit", "code": "def IsVanKampenColimit {F : J \u2964 C} (c : Cocone F) : Prop :=\n  \u2200 \u2983F' : J \u2964 C\u2984 (c' : Cocone F') (\u03b1 : F' \u27f6 F) (f : c'.pt \u27f6 c.pt)\n    (_ : \u03b1 \u226b c.\u03b9 = c'.\u03b9 \u226b (Functor.const J).map f) (_ : NatTrans.Equifibered \u03b1),\n    Nonempty (IsColimit c') \u2194 \u2200 j : J, IsPullback (c'.\u03b9.app j) (\u03b1.app j) f (c.\u03b9.app j)", "start": [84, 1], "end": [93, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsVanKampenColimit.isUniversal", "code": "theorem IsVanKampenColimit.isUniversal {F : J \u2964 C} {c : Cocone F} (H : IsVanKampenColimit c) :\n    IsUniversalColimit c", "start": [96, 1], "end": [98, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsVanKampenColimit.isColimit", "code": "noncomputable def IsVanKampenColimit.isColimit {F : J \u2964 C} {c : Cocone F}\n    (h : IsVanKampenColimit c) : IsColimit c := by\n  refine' ((h c (\ud835\udfd9 F) (\ud835\udfd9 c.pt : _) (by rw [Functor.map_id, Category.comp_id, Category.id_comp])\n    (NatTrans.equifibered_of_isIso _)).mpr fun j => _).some\n  haveI : IsIso (\ud835\udfd9 c.pt) := inferInstance\n  exact IsPullback.of_vert_isIso \u27e8by erw [NatTrans.id_app, Category.comp_id, Category.id_comp]\u27e9", "start": [101, 1], "end": [107, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsInitial.isVanKampenColimit", "code": "theorem IsInitial.isVanKampenColimit [HasStrictInitialObjects C] {X : C} (h : IsInitial X) :\n    IsVanKampenColimit (asEmptyCocone X)", "start": [110, 1], "end": [117, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinitaryExtensive", "code": "class FinitaryExtensive (C : Type u) [Category.{v} C] : Prop where\n  [hasFiniteCoproducts : HasFiniteCoproducts C]\n  \n  van_kampen' : \u2200 {X Y : C} (c : BinaryCofan X Y), IsColimit c \u2192 IsVanKampenColimit c", "start": [124, 1], "end": [131, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinitaryExtensive.vanKampen", "code": "theorem FinitaryExtensive.vanKampen [FinitaryExtensive C] {F : Discrete WalkingPair \u2964 C}\n    (c : Cocone F) (hc : IsColimit c) : IsVanKampenColimit c", "start": [136, 1], "end": [146, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mapPair_equifibered", "code": "theorem mapPair_equifibered {F F' : Discrete WalkingPair \u2964 C} (\u03b1 : F \u27f6 F') :\n    NatTrans.Equifibered \u03b1", "start": [149, 1], "end": [154, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BinaryCofan.isVanKampen_iff", "code": "theorem BinaryCofan.isVanKampen_iff (c : BinaryCofan X Y) :\n    IsVanKampenColimit c \u2194\n      \u2200 {X' Y' : C} (c' : BinaryCofan X' Y') (\u03b1X : X' \u27f6 X) (\u03b1Y : Y' \u27f6 Y) (f : c'.pt \u27f6 c.pt)\n        (_ : \u03b1X \u226b c.inl = c'.inl \u226b f) (_ : \u03b1Y \u226b c.inr = c'.inr \u226b f),\n        Nonempty (IsColimit c') \u2194 IsPullback c'.inl \u03b1X f c.inl \u2227 IsPullback c'.inr \u03b1Y f c.inr", "start": [157, 1], "end": [186, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BinaryCofan.isVanKampen_mk", "code": "theorem BinaryCofan.isVanKampen_mk {X Y : C} (c : BinaryCofan X Y)\n    (cofans : \u2200 X Y : C, BinaryCofan X Y) (colimits : \u2200 X Y, IsColimit (cofans X Y))\n    (cones : \u2200 {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z), PullbackCone f g)\n    (limits : \u2200 {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z), IsLimit (cones f g))\n    (h\u2081 : \u2200 {X' Y' : C} (\u03b1X : X' \u27f6 X) (\u03b1Y : Y' \u27f6 Y) (f : (cofans X' Y').pt \u27f6 c.pt)\n      (_ : \u03b1X \u226b c.inl = (cofans X' Y').inl \u226b f) (_ : \u03b1Y \u226b c.inr = (cofans X' Y').inr \u226b f),\n      IsPullback (cofans X' Y').inl \u03b1X f c.inl \u2227 IsPullback (cofans X' Y').inr \u03b1Y f c.inr)\n    (h\u2082 : \u2200 {Z : C} (f : Z \u27f6 c.pt),\n      IsColimit (BinaryCofan.mk (cones f c.inl).fst (cones f c.inr).fst)) :\n    IsVanKampenColimit c", "start": [189, 1], "end": [227, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BinaryCofan.mono_inr_of_isVanKampen", "code": "theorem BinaryCofan.mono_inr_of_isVanKampen [HasInitial C] {X Y : C} {c : BinaryCofan X Y}\n    (h : IsVanKampenColimit c) : Mono c.inr", "start": [230, 1], "end": [238, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinitaryExtensive.mono_inr_of_isColimit", "code": "theorem FinitaryExtensive.mono_inr_of_isColimit [FinitaryExtensive C] {c : BinaryCofan X Y}\n    (hc : IsColimit c) : Mono c.inr", "start": [241, 1], "end": [243, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinitaryExtensive.mono_inl_of_isColimit", "code": "theorem FinitaryExtensive.mono_inl_of_isColimit [FinitaryExtensive C] {c : BinaryCofan X Y}\n    (hc : IsColimit c) : Mono c.inl", "start": [246, 1], "end": [248, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.BinaryCofan.isPullback_initial_to_of_isVanKampen", "code": "theorem BinaryCofan.isPullback_initial_to_of_isVanKampen [HasInitial C] {c : BinaryCofan X Y}\n    (h : IsVanKampenColimit c) : IsPullback (initial.to _) (initial.to _) c.inl c.inr", "start": [257, 1], "end": [264, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FinitaryExtensive.isPullback_initial_to_binaryCofan", "code": "theorem FinitaryExtensive.isPullback_initial_to_binaryCofan [FinitaryExtensive C]\n    {c : BinaryCofan X Y} (hc : IsColimit c) :\n    IsPullback (initial.to _) (initial.to _) c.inl c.inr", "start": [267, 1], "end": [270, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasStrictInitial_of_isUniversal", "code": "theorem hasStrictInitial_of_isUniversal [HasInitial C]\n    (H : IsUniversalColimit (BinaryCofan.mk (\ud835\udfd9 (\u22a5_ C)) (\ud835\udfd9 (\u22a5_ C)))) : HasStrictInitialObjects C", "start": [273, 1], "end": [285, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasStrictInitialObjects_of_finitaryExtensive", "code": "instance (priority := 100) hasStrictInitialObjects_of_finitaryExtensive [FinitaryExtensive C] :\n    HasStrictInitialObjects C :=\n  hasStrictInitial_of_isUniversal (FinitaryExtensive.vanKampen _\n    ((BinaryCofan.isColimit_iff_isIso_inr initialIsInitial _).mpr (by\n      dsimp\n      infer_instance)).some).isUniversal", "start": [288, 1], "end": [293, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finitaryExtensive_iff_of_isTerminal", "code": "theorem finitaryExtensive_iff_of_isTerminal (C : Type u) [Category.{v} C] [HasFiniteCoproducts C]\n    (T : C) (HT : IsTerminal T) (c\u2080 : BinaryCofan T T) (hc\u2080 : IsColimit c\u2080) :\n    FinitaryExtensive C \u2194 IsVanKampenColimit c\u2080", "start": [296, 1], "end": [308, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types.finitaryExtensive", "code": "instance types.finitaryExtensive : FinitaryExtensive (Type u) := by\n  classical\n  rw [finitaryExtensive_iff_of_isTerminal (Type u) PUnit Types.isTerminalPunit _\n      (Types.binaryCoproductColimit _ _)]\n  apply BinaryCofan.isVanKampen_mk _ _ (fun X Y => Types.binaryCoproductColimit X Y) _\n      fun f g => (Limits.Types.pullbackLimitCone f g).2\n  \u00b7 intros _ _ _ _ f h\u03b1X h\u03b1Y\n    constructor\n    \u00b7 refine' \u27e8\u27e8h\u03b1X.symm\u27e9, \u27e8PullbackCone.isLimitAux' _ _\u27e9\u27e9\n      intro s\n      have : \u2200 x, \u2203! y, s.fst x = Sum.inl y := by\n        intro x\n        cases' h : s.fst x with val val\n        \u00b7 simp only [Types.binaryCoproductCocone_pt, Functor.const_obj_obj, Sum.inl.injEq,\n            exists_unique_eq']\n        \u00b7 apply_fun f at h\n          cases ((congr_fun s.condition x).symm.trans h).trans (congr_fun h\u03b1Y val : _).symm\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      exact \u27e8l, (funext hl).symm, Types.isTerminalPunit.hom_ext _ _,\n        fun {l'} h\u2081 _ => funext fun x => hl' x (l' x) (congr_fun h\u2081 x).symm\u27e9\n    \u00b7 refine' \u27e8\u27e8h\u03b1Y.symm\u27e9, \u27e8PullbackCone.isLimitAux' _ _\u27e9\u27e9\n      intro s\n      have : \u2200 x, \u2203! y, s.fst x = Sum.inr y := by\n        intro x\n        cases' h : s.fst x with val val\n        \u00b7 apply_fun f at h\n          cases ((congr_fun s.condition x).symm.trans h).trans (congr_fun h\u03b1X val : _).symm\n        \u00b7 simp only [Types.binaryCoproductCocone_pt, Functor.const_obj_obj, Sum.inr.injEq,\n            exists_unique_eq']\n      delta ExistsUnique at this\n      choose l hl hl' using this\n      exact \u27e8l, (funext hl).symm, Types.isTerminalPunit.hom_ext _ _,\n        fun {l'} h\u2081 _ => funext fun x => hl' x (l' x) (congr_fun h\u2081 x).symm\u27e9\n  \u00b7 intro Z f\n    dsimp [Limits.Types.binaryCoproductCocone]\n    delta Types.PullbackObj\n    have : \u2200 x, f x = Sum.inl PUnit.unit \u2228 f x = Sum.inr PUnit.unit := by\n      intro x\n      rcases f x with (\u27e8\u27e8\u27e9\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n      exacts [Or.inl rfl, Or.inr rfl]\n    let eX : { p : Z \u00d7 PUnit // f p.fst = Sum.inl p.snd } \u2243 { x : Z // f x = Sum.inl PUnit.unit } :=\n      \u27e8fun p => \u27e8p.1.1, by convert p.2\u27e9, fun x => \u27e8\u27e8_, _\u27e9, x.2\u27e9, fun _ => by ext; rfl,\n        fun _ => by ext; rfl\u27e9\n    let eY : { p : Z \u00d7 PUnit // f p.fst = Sum.inr p.snd } \u2243 { x : Z // f x = Sum.inr PUnit.unit } :=\n      \u27e8fun p => \u27e8p.1.1, p.2.trans (congr_arg Sum.inr <| Subsingleton.elim _ _)\u27e9,\n        fun x => \u27e8\u27e8_, _\u27e9, x.2\u27e9, fun _ => by ext; rfl, fun _ => by ext; rfl\u27e9\n    fapply BinaryCofan.isColimitMk\n    \u00b7 exact fun s x => dite _ (fun h => s.inl <| eX.symm \u27e8x, h\u27e9)\n        fun h => s.inr <| eY.symm \u27e8x, (this x).resolve_left h\u27e9\n    \u00b7 intro s\n      ext \u27e8\u27e8x, \u27e8\u27e9\u27e9, _\u27e9\n      dsimp\n      split_ifs <;> rfl\n    \u00b7 intro s\n      ext \u27e8\u27e8x, \u27e8\u27e9\u27e9, hx\u27e9\n      dsimp\n      split_ifs with h\n      \u00b7 cases h.symm.trans hx\n      \u00b7 rfl\n    \u00b7 intro s m e\u2081 e\u2082\n      ext x\n      split_ifs\n      \u00b7 rw [\u2190 e\u2081]\n        rfl\n      \u00b7 rw [\u2190 e\u2082]\n        rfl", "start": [311, 1], "end": [377, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finitaryExtensiveTopCatAux", "code": "noncomputable def finitaryExtensiveTopCatAux (Z : TopCat.{u})\n    (f : Z \u27f6 TopCat.of (Sum PUnit.{u + 1} PUnit.{u + 1})) :\n    IsColimit (BinaryCofan.mk\n      (TopCat.pullbackFst f (TopCat.binaryCofan (TopCat.of PUnit) (TopCat.of PUnit)).inl)\n      (TopCat.pullbackFst f (TopCat.binaryCofan (TopCat.of PUnit) (TopCat.of PUnit)).inr)) := by\n  have : \u2200 x, f x = Sum.inl PUnit.unit \u2228 f x = Sum.inr PUnit.unit := by\n    intro x\n    rcases f x with (\u27e8\u27e8\u27e9\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n    exacts [Or.inl rfl, Or.inr rfl]\n  letI eX : { p : Z \u00d7 PUnit // f p.fst = Sum.inl p.snd } \u2243 { x : Z // f x = Sum.inl PUnit.unit } :=\n    \u27e8fun p => \u27e8p.1.1, p.2.trans (congr_arg Sum.inl <| Subsingleton.elim _ _)\u27e9,\n      fun x => \u27e8\u27e8_, PUnit.unit\u27e9, x.2\u27e9, fun _ => by ext; rfl, fun _ => by ext; rfl\u27e9\n  letI eY : { p : Z \u00d7 PUnit // f p.fst = Sum.inr p.snd } \u2243 { x : Z // f x = Sum.inr PUnit.unit } :=\n    \u27e8fun p => \u27e8p.1.1, p.2.trans (congr_arg Sum.inr <| Subsingleton.elim _ _)\u27e9,\n      fun x => \u27e8\u27e8_, PUnit.unit\u27e9, x.2\u27e9, fun _ => by ext; rfl, fun _ => by ext; rfl\u27e9\n  fapply BinaryCofan.isColimitMk\n  classical \u00b7 refine' fun s => \u27e8fun x => dite _\n      (fun h => s.inl <| eX.symm \u27e8x, h\u27e9) fun h => s.inr <| eY.symm \u27e8x, (this x).resolve_left h\u27e9, _\u27e9\n    rw [continuous_iff_continuousAt]\n    intro x\n    by_cases f x = Sum.inl PUnit.unit\n    \u00b7 revert h x\n      apply (IsOpen.continuousOn_iff _).mp\n      \u00b7 rw [continuousOn_iff_continuous_restrict]\n        convert_to Continuous fun x : { x | f x = Sum.inl PUnit.unit } =>\n            s.inl \u27e8(x.1, PUnit.unit), x.2\u27e9\n        \u00b7 ext \u27e8x, hx\u27e9\n          exact dif_pos hx\n        have := (BinaryCofan.inl s).2\n        continuity\n      \u00b7 convert f.2.1 _ openEmbedding_inl.open_range\n        rename_i x\n        exact \u27e8fun h => \u27e8_, h.symm\u27e9,\n          fun \u27e8e, h\u27e9 => h.symm.trans (congr_arg Sum.inl <| Subsingleton.elim _ _)\u27e9\n    \u00b7 revert h x\n      apply (IsOpen.continuousOn_iff _).mp\n      \u00b7 rw [continuousOn_iff_continuous_restrict]\n        convert_to Continuous fun x : { x | f x \u2260 Sum.inl PUnit.unit } =>\n            s.inr \u27e8(x.1, PUnit.unit), (this _).resolve_left x.2\u27e9\n        \u00b7 ext \u27e8x, hx\u27e9\n          exact dif_neg hx\n        have := (BinaryCofan.inr s).2\n        continuity\n      \u00b7 convert f.2.1 _ openEmbedding_inr.open_range\n        rename_i x\n        change f x \u2260 Sum.inl PUnit.unit \u2194 f x \u2208 Set.range Sum.inr\n        trans f x = Sum.inr PUnit.unit\n        \u00b7 rcases f x with (\u27e8\u27e8\u27e9\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;>\n            simp only [iff_self_iff, eq_self_iff_true, not_true, Ne.def, not_false_iff]\n        \u00b7 exact \u27e8fun h => \u27e8_, h.symm\u27e9,\n            fun \u27e8e, h\u27e9 => h.symm.trans (congr_arg Sum.inr <| Subsingleton.elim _ _)\u27e9\n  \u00b7 intro s\n    ext \u27e8\u27e8x, \u27e8\u27e9\u27e9, (hx : f x = Sum.inl PUnit.unit)\u27e9\n    change dite _ _ _ = _\n    split_ifs with h\n    \u00b7 rfl\n    \u00b7 cases (h hx) \u00b7 intro s\n    ext \u27e8\u27e8x, \u27e8\u27e9\u27e9, hx\u27e9\n    change dite _ _ _ = _\n    split_ifs with h\n    \u00b7 cases h.symm.trans hx\n    \u00b7 rfl\n  \u00b7 intro s m e\u2081 e\u2082\n    ext x\n    change m x = dite _ _ _\n    split_ifs\n    \u00b7 rw [\u2190 e\u2081]\n      rfl\n    \u00b7 rw [\u2190 e\u2082]\n      rfl", "start": [382, 1], "end": [457, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.Equifibered.whiskerRight", "code": "theorem NatTrans.Equifibered.whiskerRight {F G : J \u2964 C} {\u03b1 : F \u27f6 G} (h\u03b1 : Equifibered \u03b1)\n    (H : C \u2964 D) [PreservesLimitsOfShape WalkingCospan H] : Equifibered (whiskerRight \u03b1 H)", "start": [513, 1], "end": [515, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsVanKampenColimit.of_iso", "code": "theorem IsVanKampenColimit.of_iso {F : J \u2964 C} {c c' : Cocone F} (H : IsVanKampenColimit c)\n    (e : c \u2245 c') : IsVanKampenColimit c'", "start": [518, 1], "end": [529, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsVanKampenColimit.of_map", "code": "theorem IsVanKampenColimit.of_map {D : Type*} [Category D] (G : C \u2964 D) {F : J \u2964 C} {c : Cocone F}\n    [PreservesLimitsOfShape WalkingCospan G] [ReflectsLimitsOfShape WalkingCospan G]\n    [PreservesColimitsOfShape J G] [ReflectsColimitsOfShape J G]\n    (H : IsVanKampenColimit (G.mapCocone c)) : IsVanKampenColimit c", "start": [532, 1], "end": [541, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isVanKampenColimit_of_evaluation", "code": "theorem isVanKampenColimit_of_evaluation [HasPullbacks D] [HasColimitsOfShape J D] (F : J \u2964 C \u2964 D)\n    (c : Cocone F) (hc : \u2200 x : C, IsVanKampenColimit (((evaluation C D).obj x).mapCocone c)) :\n    IsVanKampenColimit c", "start": [544, 1], "end": [561, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finitaryExtensive_of_preserves_and_reflects", "code": "theorem finitaryExtensive_of_preserves_and_reflects (F : C \u2964 D) [FinitaryExtensive D]\n    [HasFiniteCoproducts C] [PreservesLimitsOfShape WalkingCospan F]\n    [ReflectsLimitsOfShape WalkingCospan F] [PreservesColimitsOfShape (Discrete WalkingPair) F]\n    [ReflectsColimitsOfShape (Discrete WalkingPair) F] : FinitaryExtensive C", "start": [569, 1], "end": [573, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finitaryExtensive_of_preserves_and_reflects_isomorphism", "code": "theorem finitaryExtensive_of_preserves_and_reflects_isomorphism (F : C \u2964 D) [FinitaryExtensive D]\n    [HasFiniteCoproducts C] [HasPullbacks C] [PreservesLimitsOfShape WalkingCospan F]\n    [PreservesColimitsOfShape (Discrete WalkingPair) F] [ReflectsIsomorphisms F] :\n    FinitaryExtensive C", "start": [576, 1], "end": [583, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Multinomial.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finset/Sym.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Finsupp/Multiset.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Data/Fin/VecNotation.lean", "Mathlib/Data/Nat/Factorial/BigOperators.lean"], "premises": [{"full_name": "Nat.multinomial", "code": "def multinomial : \u2115 :=\n  (\u2211 i in s, f i)! / \u220f i in s, (f i)!", "start": [39, 1], "end": [45, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_pos", "code": "theorem multinomial_pos : 0 < multinomial s f", "start": [48, 1], "end": [50, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_spec", "code": "theorem multinomial_spec : (\u220f i in s, (f i)!) * multinomial s f = (\u2211 i in s, f i)!", "start": [53, 1], "end": [54, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_nil", "code": "@[simp]\ntheorem multinomial_nil : multinomial \u2205 f = 1", "start": [57, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_singleton", "code": "@[simp]\ntheorem multinomial_singleton : multinomial {a} f = 1", "start": [63, 1], "end": [65, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_insert_one", "code": "@[simp]\ntheorem multinomial_insert_one [DecidableEq \u03b1] (h : a \u2209 s) (h\u2081 : f a = 1) :\n    multinomial (insert a s) f = (s.sum f).succ * multinomial s f", "start": [68, 1], "end": [74, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_insert", "code": "theorem multinomial_insert [DecidableEq \u03b1] (h : a \u2209 s) :\n    multinomial (insert a s) f = (f a + s.sum f).choose (f a) * multinomial s f", "start": [77, 1], "end": [85, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_congr", "code": "theorem multinomial_congr {f g : \u03b1 \u2192 \u2115} (h : \u2200 a \u2208 s, f a = g a) :\n    multinomial s f = multinomial s g", "start": [88, 1], "end": [92, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.binomial_eq", "code": "theorem binomial_eq [DecidableEq \u03b1] (h : a \u2260 b) :\n    multinomial {a, b} f = (f a + f b)! / ((f a)! * (f b)!)", "start": [103, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.binomial_eq_choose", "code": "theorem binomial_eq_choose [DecidableEq \u03b1] (h : a \u2260 b) :\n    multinomial {a, b} f = (f a + f b).choose (f a)", "start": [108, 1], "end": [110, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.binomial_spec", "code": "theorem binomial_spec [DecidableEq \u03b1] (hab : a \u2260 b) :\n    (f a)! * (f b)! * multinomial {a, b} f = (f a + f b)!", "start": [113, 1], "end": [115, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.binomial_one", "code": "@[simp]\ntheorem binomial_one [DecidableEq \u03b1] (h : a \u2260 b) (h\u2081 : f a = 1) :\n    multinomial {a, b} f = (f b).succ", "start": [118, 1], "end": [121, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.binomial_succ_succ", "code": "theorem binomial_succ_succ [DecidableEq \u03b1] (h : a \u2260 b) :\n    multinomial {a, b} (Function.update (Function.update f a (f a).succ) b (f b).succ) =\n      multinomial {a, b} (Function.update f a (f a).succ) +\n      multinomial {a, b} (Function.update f b (f b).succ)", "start": [124, 1], "end": [132, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul_binomial", "code": "theorem succ_mul_binomial [DecidableEq \u03b1] (h : a \u2260 b) :\n    (f a + f b).succ * multinomial {a, b} f =\n      (f a).succ * multinomial {a, b} (Function.update f a (f a).succ)", "start": [135, 1], "end": [140, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_univ_two", "code": "theorem multinomial_univ_two (a b : \u2115) :\n    multinomial Finset.univ ![a, b] = (a + b)! / (a ! * b !)", "start": [146, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.multinomial_univ_three", "code": "theorem multinomial_univ_three (a b c : \u2115) :\n    multinomial Finset.univ ![a, b, c] = (a + b + c)! / (a ! * b ! * c !)", "start": [152, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multinomial", "code": "def multinomial (f : \u03b1 \u2192\u2080 \u2115) : \u2115 :=\n  (f.sum fun _ => id)! / f.prod fun _ n => n !", "start": [167, 1], "end": [171, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multinomial_eq", "code": "theorem multinomial_eq (f : \u03b1 \u2192\u2080 \u2115) : f.multinomial = Nat.multinomial f.support f", "start": [174, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multinomial_update", "code": "theorem multinomial_update (a : \u03b1) (f : \u03b1 \u2192\u2080 \u2115) :\n    f.multinomial = (f.sum fun _ => id).choose (f a) * (f.update a 0).multinomial", "start": [178, 1], "end": [189, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.multinomial", "code": "def multinomial [DecidableEq \u03b1] (m : Multiset \u03b1) : \u2115 :=\n  m.toFinsupp.multinomial", "start": [198, 1], "end": [202, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.multinomial_filter_ne", "code": "theorem multinomial_filter_ne [DecidableEq \u03b1] (a : \u03b1) (m : Multiset \u03b1) :\n    m.multinomial = m.card.choose (m.count a) * (m.filter ((\u00b7 \u2260 \u00b7) a)).multinomial", "start": [205, 1], "end": [214, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_pow_of_commute", "code": "theorem sum_pow_of_commute [Semiring R] (x : \u03b1 \u2192 R)\n    (hc : (s : Set \u03b1).Pairwise fun i j => Commute (x i) (x j)) :\n    \u2200 n,\n      s.sum x ^ n =\n        \u2211 k : s.sym n,\n          k.1.1.multinomial *\n            (k.1.1.map <| x).noncommProd\n              (Multiset.map_set_pairwise <| hc.mono <| mem_sym_iff.1 k.2)", "start": [225, 1], "end": [265, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_pow", "code": "theorem sum_pow [CommSemiring R] (x : \u03b1 \u2192 R) (n : \u2115) :\n    s.sum x ^ n = \u2211 k in s.sym n, k.val.multinomial * (k.val.map x).prod", "start": [269, 1], "end": [273, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/BorelCantelli.lean", "imports": ["Mathlib/Probability/Martingale/Convergence.lean", "Mathlib/Probability/Martingale/OptionalStopping.lean", "Mathlib/Probability/Martingale/Centering.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.leastGE", "code": "noncomputable def leastGE (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (r : \u211d) (n : \u2115) :=\n  hitting f (Set.Ici r) 0 n", "start": [49, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.isStoppingTime_leastGE", "code": "theorem Adapted.isStoppingTime_leastGE (r : \u211d) (n : \u2115) (hf : Adapted \u2131 f) :\n    IsStoppingTime \u2131 (leastGE f r n)", "start": [54, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.leastGE_le", "code": "theorem leastGE_le {i : \u2115} {r : \u211d} (\u03c9 : \u03a9) : leastGE f r i \u03c9 \u2264 i", "start": [59, 1], "end": [60, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.leastGE_mono", "code": "theorem leastGE_mono {n m : \u2115} (hnm : n \u2264 m) (r : \u211d) (\u03c9 : \u03a9) : leastGE f r n \u03c9 \u2264 leastGE f r m \u03c9", "start": [67, 1], "end": [68, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.leastGE_eq_min", "code": "theorem leastGE_eq_min (\u03c0 : \u03a9 \u2192 \u2115) (r : \u211d) (\u03c9 : \u03a9) {n : \u2115} (h\u03c0n : \u2200 \u03c9, \u03c0 \u03c9 \u2264 n) :\n    leastGE f r (\u03c0 \u03c9) \u03c9 = min (\u03c0 \u03c9) (leastGE f r n \u03c9)", "start": [71, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stoppedValue_stoppedValue_leastGE", "code": "theorem stoppedValue_stoppedValue_leastGE (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (\u03c0 : \u03a9 \u2192 \u2115) (r : \u211d) {n : \u2115}\n    (h\u03c0n : \u2200 \u03c9, \u03c0 \u03c9 \u2264 n) : stoppedValue (fun i => stoppedValue f (leastGE f r i)) \u03c0 =\n      stoppedValue (stoppedProcess f (leastGE f r n)) \u03c0", "start": [89, 1], "end": [92, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.stoppedValue_leastGE", "code": "theorem Submartingale.stoppedValue_leastGE [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc) (r : \u211d) :\n    Submartingale (fun i => stoppedValue f (leastGE f r i)) \u2131 \u03bc", "start": [95, 1], "end": [109, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.norm_stoppedValue_leastGE_le", "code": "theorem norm_stoppedValue_leastGE_le (hr : 0 \u2264 r) (hf0 : f 0 = 0)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) (i : \u2115) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, stoppedValue f (leastGE f r i) \u03c9 \u2264 r + R", "start": [114, 1], "end": [126, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.stoppedValue_leastGE_snorm_le", "code": "theorem Submartingale.stoppedValue_leastGE_snorm_le [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hr : 0 \u2264 r) (hf0 : f 0 = 0) (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) (i : \u2115) :\n    snorm (stoppedValue f (leastGE f r i)) 1 \u03bc \u2264 2 * \u03bc Set.univ * ENNReal.ofReal (r + R)", "start": [129, 1], "end": [136, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.stoppedValue_leastGE_snorm_le'", "code": "theorem Submartingale.stoppedValue_leastGE_snorm_le' [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hr : 0 \u2264 r) (hf0 : f 0 = 0) (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) (i : \u2115) :\n    snorm (stoppedValue f (leastGE f r i)) 1 \u03bc \u2264\n      ENNReal.toNNReal (2 * \u03bc Set.univ * ENNReal.ofReal (r + R))", "start": [139, 1], "end": [144, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.exists_tendsto_of_abs_bddAbove_aux", "code": "theorem Submartingale.exists_tendsto_of_abs_bddAbove_aux [IsFiniteMeasure \u03bc]\n    (hf : Submartingale f \u2131 \u03bc) (hf0 : f 0 = 0) (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, BddAbove (Set.range fun n => f n \u03c9) \u2192 \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [147, 1], "end": [169, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto_aux", "code": "theorem Submartingale.bddAbove_iff_exists_tendsto_aux [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hf0 : f 0 = 0) (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, BddAbove (Set.range fun n => f n \u03c9) \u2194 \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [172, 1], "end": [176, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.bddAbove_iff_exists_tendsto", "code": "theorem Submartingale.bddAbove_iff_exists_tendsto [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, BddAbove (Set.range fun n => f n \u03c9) \u2194 \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [179, 1], "end": [203, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.bddAbove_range_iff_bddBelow_range", "code": "theorem Martingale.bddAbove_range_iff_bddBelow_range [IsFiniteMeasure \u03bc] (hf : Martingale f \u2131 \u03bc)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, BddAbove (Set.range fun n => f n \u03c9) \u2194 BddBelow (Set.range fun n => f n \u03c9)", "start": [229, 1], "end": [254, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.ae_not_tendsto_atTop_atTop", "code": "theorem Martingale.ae_not_tendsto_atTop_atTop [IsFiniteMeasure \u03bc] (hf : Martingale f \u2131 \u03bc)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, \u00acTendsto (fun n => f n \u03c9) atTop atTop", "start": [257, 1], "end": [261, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.ae_not_tendsto_atTop_atBot", "code": "theorem Martingale.ae_not_tendsto_atTop_atBot [IsFiniteMeasure \u03bc] (hf : Martingale f \u2131 \u03bc)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, \u00acTendsto (fun n => f n \u03c9) atTop atBot", "start": [264, 1], "end": [268, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.process", "code": "noncomputable def process (s : \u2115 \u2192 Set \u03a9) (n : \u2115) : \u03a9 \u2192 \u211d :=\n  \u2211 k in Finset.range n, (s (k + 1)).indicator 1", "start": [273, 1], "end": [276, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.process_zero", "code": "theorem process_zero : process s 0 = 0", "start": [281, 1], "end": [281, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.adapted_process", "code": "theorem adapted_process (hs : \u2200 n, MeasurableSet[\u2131 n] (s n)) : Adapted \u2131 (process s)", "start": [284, 1], "end": [286, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.martingalePart_process_ae_eq", "code": "theorem martingalePart_process_ae_eq (\u2131 : Filtration \u2115 m0) (\u03bc : Measure \u03a9) (s : \u2115 \u2192 Set \u03a9) (n : \u2115) :\n    martingalePart (process s) \u2131 \u03bc n =\n      \u2211 k in Finset.range n, ((s (k + 1)).indicator 1 - \u03bc[(s (k + 1)).indicator 1|\u2131 k])", "start": [289, 1], "end": [294, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.predictablePart_process_ae_eq", "code": "theorem predictablePart_process_ae_eq (\u2131 : Filtration \u2115 m0) (\u03bc : Measure \u03a9) (s : \u2115 \u2192 Set \u03a9)\n    (n : \u2115) : predictablePart (process s) \u2131 \u03bc n =\n    \u2211 k in Finset.range n, \u03bc[(s (k + 1)).indicator (1 : \u03a9 \u2192 \u211d)|\u2131 k]", "start": [297, 1], "end": [302, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.process_difference_le", "code": "theorem process_difference_le (s : \u2115 \u2192 Set \u03a9) (\u03c9 : \u03a9) (n : \u2115) :\n    |process s (n + 1) \u03c9 - process s n \u03c9| \u2264 (1 : \u211d\u22650)", "start": [305, 1], "end": [311, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.BorelCantelli.integrable_process", "code": "theorem integrable_process (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc] (hs : \u2200 n, MeasurableSet[\u2131 n] (s n))\n    (n : \u2115) : Integrable (process s n) \u03bc", "start": [314, 1], "end": [317, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_sum_indicator_atTop_iff", "code": "theorem tendsto_sum_indicator_atTop_iff [IsFiniteMeasure \u03bc]\n    (hfmono : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 n, f n \u03c9 \u2264 f (n + 1) \u03c9) (hf : Adapted \u2131 f) (hint : \u2200 n, Integrable (f n) \u03bc)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 n, |f (n + 1) \u03c9 - f n \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, Tendsto (fun n => f n \u03c9) atTop atTop \u2194\n      Tendsto (fun n => predictablePart f \u2131 \u03bc n \u03c9) atTop atTop", "start": [324, 1], "end": [352, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_sum_indicator_atTop_iff'", "code": "theorem tendsto_sum_indicator_atTop_iff' [IsFiniteMeasure \u03bc] {s : \u2115 \u2192 Set \u03a9}\n    (hs : \u2200 n, MeasurableSet[\u2131 n] (s n)) : \u2200\u1d50 \u03c9 \u2202\u03bc,\n    Tendsto (fun n => \u2211 k in Finset.range n,\n      (s (k + 1)).indicator (1 : \u03a9 \u2192 \u211d) \u03c9) atTop atTop \u2194\n    Tendsto (fun n => \u2211 k in Finset.range n,\n      (\u03bc[(s (k + 1)).indicator (1 : \u03a9 \u2192 \u211d)|\u2131 k]) \u03c9) atTop atTop", "start": [357, 1], "end": [370, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_mem_limsup_atTop_iff", "code": "theorem ae_mem_limsup_atTop_iff (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc] {s : \u2115 \u2192 Set \u03a9}\n    (hs : \u2200 n, MeasurableSet[\u2131 n] (s n)) : \u2200\u1d50 \u03c9 \u2202\u03bc, \u03c9 \u2208 limsup s atTop \u2194\n    Tendsto (fun n => \u2211 k in Finset.range n,\n      (\u03bc[(s (k + 1)).indicator (1 : \u03a9 \u2192 \u211d)|\u2131 k]) \u03c9) atTop atTop", "start": [373, 1], "end": [380, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ConditionalExpectation.lean", "imports": ["Mathlib/Probability/Notation.lean", "Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "Mathlib/Probability/Independence/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.condexp_indep_eq", "code": "theorem condexp_indep_eq (hle\u2081 : m\u2081 \u2264 m) (hle\u2082 : m\u2082 \u2264 m) [SigmaFinite (\u03bc.trim hle\u2082)]\n    (hf : StronglyMeasurable[m\u2081] f) (hindp : Indep m\u2081 m\u2082 \u03bc) : \u03bc[f|m\u2082] =\u1d50[\u03bc] fun _ => \u03bc[f]", "start": [38, 1], "end": [77, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/End.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/Basic.lean", "Mathlib/CategoryTheory/Monoidal/Category.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.EndMonoidal", "code": "def EndMonoidal (X : C) :=\n  X \u27f6 X", "start": [20, 1], "end": [22, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Bitraversable/Lemmas.lean", "imports": ["Mathlib/Control/Bitraversable/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bitraversable.tfst", "code": "@[reducible]\ndef tfst {\u03b1 \u03b1'} (f : \u03b1 \u2192 F \u03b1') : t \u03b1 \u03b2 \u2192 F (t \u03b1' \u03b2) :=\n  bitraverse f pure", "start": [50, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.tsnd", "code": "@[reducible]\ndef tsnd {\u03b1 \u03b1'} (f : \u03b1 \u2192 F \u03b1') : t \u03b2 \u03b1 \u2192 F (t \u03b2 \u03b1') :=\n  bitraverse pure f", "start": [56, 1], "end": [59, 20], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.id_tfst", "code": "@[higher_order tfst_id]\ntheorem id_tfst : \u2200 {\u03b1 \u03b2} (x : t \u03b1 \u03b2), tfst (F := Id) pure x = pure x", "start": [64, 1], "end": [66, 16], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.id_tsnd", "code": "@[higher_order tsnd_id]\ntheorem id_tsnd : \u2200 {\u03b1 \u03b2} (x : t \u03b1 \u03b2), tsnd (F := Id) pure x = pure x", "start": [69, 1], "end": [71, 16], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.comp_tfst", "code": "@[higher_order tfst_comp_tfst]\ntheorem comp_tfst {\u03b1\u2080 \u03b1\u2081 \u03b1\u2082 \u03b2} (f : \u03b1\u2080 \u2192 F \u03b1\u2081) (f' : \u03b1\u2081 \u2192 G \u03b1\u2082) (x : t \u03b1\u2080 \u03b2) :\n    Comp.mk (tfst f' <$> tfst f x) = tfst (Comp.mk \u2218 map f' \u2218 f) x", "start": [74, 1], "end": [78, 55], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.tfst_tsnd", "code": "@[higher_order tfst_comp_tsnd]\ntheorem tfst_tsnd {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 F \u03b1\u2081) (f' : \u03b2\u2080 \u2192 G \u03b2\u2081) (x : t \u03b1\u2080 \u03b2\u2080) :\n    Comp.mk (tfst f <$> tsnd f' x)\n      = bitraverse (Comp.mk \u2218 pure \u2218 f) (Comp.mk \u2218 map pure \u2218 f') x", "start": [81, 1], "end": [86, 38], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.tsnd_tfst", "code": "@[higher_order tsnd_comp_tfst]\ntheorem tsnd_tfst {\u03b1\u2080 \u03b1\u2081 \u03b2\u2080 \u03b2\u2081} (f : \u03b1\u2080 \u2192 F \u03b1\u2081) (f' : \u03b2\u2080 \u2192 G \u03b2\u2081) (x : t \u03b1\u2080 \u03b2\u2080) :\n    Comp.mk (tsnd f' <$> tfst f x)\n      = bitraverse (Comp.mk \u2218 map pure \u2218 f) (Comp.mk \u2218 pure \u2218 f') x", "start": [89, 1], "end": [94, 38], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.comp_tsnd", "code": "@[higher_order tsnd_comp_tsnd]\ntheorem comp_tsnd {\u03b1 \u03b2\u2080 \u03b2\u2081 \u03b2\u2082} (g : \u03b2\u2080 \u2192 F \u03b2\u2081) (g' : \u03b2\u2081 \u2192 G \u03b2\u2082) (x : t \u03b1 \u03b2\u2080) :\n    Comp.mk (tsnd g' <$> tsnd g x) = tsnd (Comp.mk \u2218 map g' \u2218 g) x", "start": [97, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.tfst_eq_fst_id", "code": "@[higher_order]\ntheorem tfst_eq_fst_id {\u03b1 \u03b1' \u03b2} (f : \u03b1 \u2192 \u03b1') (x : t \u03b1 \u03b2) :\n    tfst (F := Id) (pure \u2218 f) x = pure (fst f x)", "start": [112, 1], "end": [115, 31], "kind": "commanddeclaration"}, {"full_name": "Bitraversable.tsnd_eq_snd_id", "code": "@[higher_order]\ntheorem tsnd_eq_snd_id {\u03b1 \u03b2 \u03b2'} (f : \u03b2 \u2192 \u03b2') (x : t \u03b1 \u03b2) :\n    tsnd (F := Id) (pure \u2218 f) x = pure (snd f x)", "start": [118, 1], "end": [121, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Hall/Basic.lean", "imports": ["Mathlib/Combinatorics/Hall/Finite.lean", "Mathlib/CategoryTheory/CofilteredSystem.lean", "Mathlib/Data/Rel.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hallMatchingsOn", "code": "def hallMatchingsOn {\u03b9 : Type u} {\u03b1 : Type v} (t : \u03b9 \u2192 Finset \u03b1) (\u03b9' : Finset \u03b9) :=\n  { f : \u03b9' \u2192 \u03b1 | Function.Injective f \u2227 \u2200 x, f x \u2208 t x }", "start": [60, 1], "end": [62, 57], "kind": "commanddeclaration"}, {"full_name": "hallMatchingsOn.restrict", "code": "def hallMatchingsOn.restrict {\u03b9 : Type u} {\u03b1 : Type v} (t : \u03b9 \u2192 Finset \u03b1) {\u03b9' \u03b9'' : Finset \u03b9}\n    (h : \u03b9' \u2286 \u03b9'') (f : hallMatchingsOn t \u03b9'') : hallMatchingsOn t \u03b9' := by\n  refine' \u27e8fun i => f.val \u27e8i, h i.property\u27e9, _\u27e9\n  cases' f.property with hinj hc\n  refine' \u27e8_, fun i => hc \u27e8i, h i.property\u27e9\u27e9\n  rintro \u27e8i, hi\u27e9 \u27e8j, hj\u27e9 hh\n  simpa only [Subtype.mk_eq_mk] using hinj hh", "start": [65, 1], "end": [72, 46], "kind": "commanddeclaration"}, {"full_name": "hallMatchingsOn.nonempty", "code": "theorem hallMatchingsOn.nonempty {\u03b9 : Type u} {\u03b1 : Type v} [DecidableEq \u03b1] (t : \u03b9 \u2192 Finset \u03b1)\n    (h : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card) (\u03b9' : Finset \u03b9) :\n    Nonempty (hallMatchingsOn t \u03b9')", "start": [75, 1], "end": [86, 23], "kind": "commanddeclaration"}, {"full_name": "hallMatchingsFunctor", "code": "def hallMatchingsFunctor {\u03b9 : Type u} {\u03b1 : Type v} (t : \u03b9 \u2192 Finset \u03b1) : (Finset \u03b9)\u1d52\u1d56 \u2964 Type max u v\n    where\n  obj \u03b9' := hallMatchingsOn t \u03b9'.unop\n  map {\u03b9' \u03b9''} g f := hallMatchingsOn.restrict t (CategoryTheory.leOfHom g.unop) f", "start": [89, 1], "end": [94, 83], "kind": "commanddeclaration"}, {"full_name": "hallMatchingsOn.finite", "code": "instance hallMatchingsOn.finite {\u03b9 : Type u} {\u03b1 : Type v} (t : \u03b9 \u2192 Finset \u03b1) (\u03b9' : Finset \u03b9) :\n    Finite (hallMatchingsOn t \u03b9') := by\n  classical\n    rw [hallMatchingsOn]\n    let g : hallMatchingsOn t \u03b9' \u2192 \u03b9' \u2192 \u03b9'.biUnion t := by\n      rintro f i\n      refine' \u27e8f.val i, _\u27e9\n      rw [mem_biUnion]\n      exact \u27e8i, i.property, f.property.2 i\u27e9\n    apply Finite.of_injective g\n    intro f f' h\n    ext a\n    rw [Function.funext_iff] at h\n    simpa using h a", "start": [97, 1], "end": [110, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.all_card_le_biUnion_card_iff_exists_injective", "code": "theorem Finset.all_card_le_biUnion_card_iff_exists_injective {\u03b9 : Type u} {\u03b1 : Type v}\n    [DecidableEq \u03b1] (t : \u03b9 \u2192 Finset \u03b1) :\n    (\u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card) \u2194\n      \u2203 f : \u03b9 \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t x", "start": [113, 1], "end": [163, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.all_card_le_rel_image_card_iff_exists_injective", "code": "theorem Fintype.all_card_le_rel_image_card_iff_exists_injective {\u03b1 : Type u} {\u03b2 : Type v}\n    [DecidableEq \u03b2] (r : \u03b1 \u2192 \u03b2 \u2192 Prop) [\u2200 a : \u03b1, Fintype (Rel.image r {a})] :\n    (\u2200 A : Finset \u03b1, A.card \u2264 Fintype.card (Rel.image r A)) \u2194\n      \u2203 f : \u03b1 \u2192 \u03b2, Function.Injective f \u2227 \u2200 x, r x (f x)", "start": [177, 1], "end": [202, 61], "kind": "commanddeclaration"}, {"full_name": "Fintype.all_card_le_filter_rel_iff_exists_injective", "code": "theorem Fintype.all_card_le_filter_rel_iff_exists_injective {\u03b1 : Type u} {\u03b2 : Type v} [Fintype \u03b2]\n    (r : \u03b1 \u2192 \u03b2 \u2192 Prop) [\u2200 a, DecidablePred (r a)] :\n    (\u2200 A : Finset \u03b1, A.card \u2264 (univ.filter fun b : \u03b2 => \u2203 a \u2208 A, r a b).card) \u2194\n      \u2203 f : \u03b1 \u2192 \u03b2, Function.Injective f \u2227 \u2200 x, r x (f x)", "start": [206, 1], "end": [225, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Kaehler.lean", "imports": ["Mathlib/RingTheory/IsTensorProduct.lean", "Mathlib/RingTheory/Derivation/ToSquareZero.lean", "Mathlib/RingTheory/Ideal/Cotangent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "KaehlerDifferential.ideal", "code": "abbrev KaehlerDifferential.ideal : Ideal (S \u2297[R] S) :=\n  RingHom.ker (TensorProduct.lmul' R : S \u2297[R] S \u2192\u2090[R] S)", "start": [48, 1], "end": [50, 57], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.one_smul_sub_smul_one_mem_ideal", "code": "theorem KaehlerDifferential.one_smul_sub_smul_one_mem_ideal (a : S) :\n    (1 : S) \u2297\u209c[R] a - a \u2297\u209c[R] (1 : S) \u2208 KaehlerDifferential.ideal R S", "start": [55, 1], "end": [56, 99], "kind": "commanddeclaration"}, {"full_name": "Derivation.tensorProductTo", "code": "def Derivation.tensorProductTo (D : Derivation R S M) : S \u2297[R] S \u2192\u2097[S] M :=\n  TensorProduct.AlgebraTensorModule.lift ((LinearMap.lsmul S (S \u2192\u2097[R] M)).flip D.toLinearMap)", "start": [63, 1], "end": [65, 94], "kind": "commanddeclaration"}, {"full_name": "Derivation.tensorProductTo_tmul", "code": "theorem Derivation.tensorProductTo_tmul (D : Derivation R S M) (s t : S) :\n    D.tensorProductTo (s \u2297\u209c t) = s \u2022 D t", "start": [68, 1], "end": [69, 48], "kind": "commanddeclaration"}, {"full_name": "Derivation.tensorProductTo_mul", "code": "theorem Derivation.tensorProductTo_mul (D : Derivation R S M) (x y : S \u2297[R] S) :\n    D.tensorProductTo (x * y) =\n      TensorProduct.lmul' (S := S) R x \u2022 D.tensorProductTo y +\n        TensorProduct.lmul' (S := S) R y \u2022 D.tensorProductTo x", "start": [72, 1], "end": [93, 90], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.submodule_span_range_eq_ideal", "code": "theorem KaehlerDifferential.submodule_span_range_eq_ideal :\n    Submodule.span S (Set.range fun s : S => (1 : S) \u2297\u209c[R] s - s \u2297\u209c[R] (1 : S)) =\n      (KaehlerDifferential.ideal R S).restrictScalars S", "start": [98, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.span_range_eq_ideal", "code": "theorem KaehlerDifferential.span_range_eq_ideal :\n    Ideal.span (Set.range fun s : S => (1 : S) \u2297\u209c[R] s - s \u2297\u209c[R] (1 : S)) =\n      KaehlerDifferential.ideal R S", "start": [125, 1], "end": [135, 32], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential", "code": "def KaehlerDifferential : Type v :=\n  (KaehlerDifferential.ideal R S).Cotangent", "start": [138, 1], "end": [147, 44], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.module", "code": "instance KaehlerDifferential.module : Module (S \u2297[R] S) (KaehlerDifferential R S) :=\n  Ideal.Cotangent.moduleOfTower _", "start": [154, 1], "end": [155, 34], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.module'", "code": "instance KaehlerDifferential.module' {R' : Type*} [CommRing R'] [Algebra R' S]\n  [SMulCommClass R R' S] :\n    Module R' (\u03a9[S\u2044R]) :=\n  Submodule.Quotient.module' _", "start": [163, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.isScalarTower_of_tower", "code": "instance KaehlerDifferential.isScalarTower_of_tower {R\u2081 R\u2082 : Type*} [CommRing R\u2081] [CommRing R\u2082]\n    [Algebra R\u2081 S] [Algebra R\u2082 S] [SMul R\u2081 R\u2082]\n    [SMulCommClass R R\u2081 S] [SMulCommClass R R\u2082 S] [IsScalarTower R\u2081 R\u2082 S] :\n    IsScalarTower R\u2081 R\u2082 (\u03a9[S\u2044R]) :=\n  Submodule.Quotient.isScalarTower _ _", "start": [172, 1], "end": [176, 39], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.isScalarTower'", "code": "instance KaehlerDifferential.isScalarTower' : IsScalarTower R (S \u2297[R] S) (\u03a9[S\u2044R]) :=\n  Submodule.Quotient.isScalarTower _ _", "start": [180, 1], "end": [181, 39], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.fromIdeal", "code": "def KaehlerDifferential.fromIdeal : KaehlerDifferential.ideal R S \u2192\u2097[S \u2297[R] S] \u03a9[S\u2044R] :=\n  (KaehlerDifferential.ideal R S).toCotangent", "start": [184, 1], "end": [186, 46], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.DLinearMap", "code": "def KaehlerDifferential.DLinearMap : S \u2192\u2097[R] \u03a9[S\u2044R] :=\n  ((KaehlerDifferential.fromIdeal R S).restrictScalars R).comp\n    ((TensorProduct.includeRight.toLinearMap - TensorProduct.includeLeft.toLinearMap :\n            S \u2192\u2097[R] S \u2297[R] S).codRestrict\n        ((KaehlerDifferential.ideal R S).restrictScalars R)\n        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R) :\n      _ \u2192\u2097[R] _)", "start": [189, 1], "end": [196, 17], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.DLinearMap_apply", "code": "theorem KaehlerDifferential.DLinearMap_apply (s : S) :\n    KaehlerDifferential.DLinearMap R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        \u27e81 \u2297\u209c s - s \u2297\u209c 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s\u27e9", "start": [200, 1], "end": [203, 90], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.D", "code": "def KaehlerDifferential.D : Derivation R S (\u03a9[S\u2044R]) :=\n  { toLinearMap := KaehlerDifferential.DLinearMap R S\n    map_one_eq_zero' := by\n      dsimp [KaehlerDifferential.DLinearMap_apply]\n      congr\n      rw [sub_self]\n    leibniz' := fun a b => by\n      have : LinearMap.CompatibleSMul { x // x \u2208 ideal R S } (\u03a9[S\u2044R]) S (S \u2297[R] S) := inferInstance\n      dsimp [KaehlerDifferential.DLinearMap_apply, - Ideal.toCotangent_apply]\n      erw [\u2190 LinearMap.map_smul_of_tower (M\u2082 := \u03a9[S\u2044R]),\n        \u2190 LinearMap.map_smul_of_tower (M\u2082 := \u03a9[S\u2044R]), \u2190 map_add, Ideal.toCotangent_eq, pow_two]\n      convert Submodule.mul_mem_mul (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R a : _)\n        (KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R b : _) using 1\n      simp only [AddSubgroupClass.coe_sub, Submodule.coe_add, Submodule.coe_mk,\n        TensorProduct.tmul_mul_tmul, mul_sub, sub_mul, mul_comm b, Submodule.coe_smul_of_tower,\n        smul_sub, TensorProduct.smul_tmul', smul_eq_mul, mul_one]\n      ring_nf }", "start": [207, 1], "end": [225, 16], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.D_apply", "code": "theorem KaehlerDifferential.D_apply (s : S) :\n    KaehlerDifferential.D R S s =\n      (KaehlerDifferential.ideal R S).toCotangent\n        \u27e81 \u2297\u209c s - s \u2297\u209c 1, KaehlerDifferential.one_smul_sub_smul_one_mem_ideal R s\u27e9", "start": [229, 1], "end": [232, 90], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.span_range_derivation", "code": "theorem KaehlerDifferential.span_range_derivation :\n    Submodule.span S (Set.range <| KaehlerDifferential.D R S) = \u22a4", "start": [236, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential", "code": "def Derivation.liftKaehlerDifferential (D : Derivation R S M) : \u03a9[S\u2044R] \u2192\u2097[S] M := by\n  refine LinearMap.comp ((((KaehlerDifferential.ideal R S) \u2022\n    (\u22a4 : Submodule (S \u2297[R] S) (KaehlerDifferential.ideal R S))).restrictScalars S).liftQ ?_ ?_)\n    (Submodule.Quotient.restrictScalarsEquiv S _).symm.toLinearMap\n  \u00b7 exact D.tensorProductTo.comp ((KaehlerDifferential.ideal R S).subtype.restrictScalars S)\n  \u00b7 intro x hx\n    change _ = _\n    refine Submodule.smul_induction_on hx ?_ ?_\n    \u00b7 rintro x (hx : _ = _) y -\n      dsimp\n      rw [show \u2191(x \u2022 y) = x * \u2191y by rfl, Derivation.tensorProductTo_mul, hx, y.prop, zero_smul,\n        zero_smul, zero_add]\n    \u00b7 intro x y ex ey; rw [map_add, ex, ey, zero_add]", "start": [260, 1], "end": [273, 54], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential_apply", "code": "theorem Derivation.liftKaehlerDifferential_apply (D : Derivation R S M) (x) :\n    D.liftKaehlerDifferential ((KaehlerDifferential.ideal R S).toCotangent x) =\n      D.tensorProductTo x", "start": [276, 1], "end": [278, 33], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential_comp", "code": "theorem Derivation.liftKaehlerDifferential_comp (D : Derivation R S M) :\n    D.liftKaehlerDifferential.compDer (KaehlerDifferential.D R S) = D", "start": [281, 1], "end": [287, 54], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential_comp_D", "code": "@[simp]\ntheorem Derivation.liftKaehlerDifferential_comp_D (D' : Derivation R S M) (x : S) :\n    D'.liftKaehlerDifferential (KaehlerDifferential.D R S x) = D' x", "start": [290, 1], "end": [293, 57], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential_unique", "code": "@[ext]\ntheorem Derivation.liftKaehlerDifferential_unique (f f' : \u03a9[S\u2044R] \u2192\u2097[S] M)\n    (hf : f.compDer (KaehlerDifferential.D R S) = f'.compDer (KaehlerDifferential.D R S)) :\n    f = f'", "start": [297, 1], "end": [309, 26], "kind": "commanddeclaration"}, {"full_name": "Derivation.liftKaehlerDifferential_D", "code": "theorem Derivation.liftKaehlerDifferential_D :\n    (KaehlerDifferential.D R S).liftKaehlerDifferential = LinearMap.id", "start": [314, 1], "end": [317, 61], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.D_tensorProductTo", "code": "theorem KaehlerDifferential.D_tensorProductTo (x : KaehlerDifferential.ideal R S) :\n    (KaehlerDifferential.D R S).tensorProductTo x =\n      (KaehlerDifferential.ideal R S).toCotangent x", "start": [323, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.tensorProductTo_surjective", "code": "theorem KaehlerDifferential.tensorProductTo_surjective :\n    Function.Surjective (KaehlerDifferential.D R S).tensorProductTo", "start": [333, 1], "end": [336, 53], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.linearMapEquivDerivation", "code": "def KaehlerDifferential.linearMapEquivDerivation : (\u03a9[S\u2044R] \u2192\u2097[S] M) \u2243\u2097[S] Derivation R S M :=\n  { Derivation.llcomp.flip <| KaehlerDifferential.D R S with\n    invFun := Derivation.liftKaehlerDifferential\n    left_inv := fun _ =>\n      Derivation.liftKaehlerDifferential_unique _ _ (Derivation.liftKaehlerDifferential_comp _)\n    right_inv := Derivation.liftKaehlerDifferential_comp }", "start": [339, 1], "end": [346, 59], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.quotientCotangentIdealRingEquiv", "code": "def KaehlerDifferential.quotientCotangentIdealRingEquiv :\n    (S \u2297 S \u29f8 KaehlerDifferential.ideal R S ^ 2) \u29f8 (KaehlerDifferential.ideal R S).cotangentIdeal \u2243+*\n      S := by\n  have : Function.RightInverse (TensorProduct.includeLeft (R := R) (A := S) (B := S))\n      (\u2191(TensorProduct.lmul' R : S \u2297[R] S \u2192\u2090[R] S) : S \u2297[R] S \u2192+* S) := by\n    intro x; rw [AlgHom.coe_toRingHom, \u2190 AlgHom.comp_apply, TensorProduct.lmul'_comp_includeLeft]\n    rfl\n  refine (Ideal.quotCotangent _).trans ?_\n  refine (Ideal.quotEquivOfEq ?_).trans (RingHom.quotientKerEquivOfRightInverse this)\n  ext; rfl", "start": [349, 1], "end": [359, 11], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.quotientCotangentIdeal", "code": "def KaehlerDifferential.quotientCotangentIdeal :\n    ((S \u2297 S \u29f8 KaehlerDifferential.ideal R S ^ 2) \u29f8\n        (KaehlerDifferential.ideal R S).cotangentIdeal) \u2243\u2090[S] S :=\n  { KaehlerDifferential.quotientCotangentIdealRingEquiv R S with\n    commutes' := (KaehlerDifferential.quotientCotangentIdealRingEquiv R S).apply_symm_apply }", "start": [362, 1], "end": [367, 94], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.End_equiv_aux", "code": "theorem KaehlerDifferential.End_equiv_aux (f : S \u2192\u2090[R] S \u2297 S \u29f8 KaehlerDifferential.ideal R S ^ 2) :\n    (Ideal.Quotient.mk\u2090 R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =\n        IsScalarTower.toAlgHom R S _ \u2194\n      (TensorProduct.lmul' R : S \u2297[R] S \u2192\u2090[R] S).kerSquareLift.comp f = AlgHom.id R S", "start": [370, 1], "end": [389, 37], "kind": "commanddeclaration"}, {"full_name": "smul_SSmod_SSmod", "code": "local instance smul_SSmod_SSmod : SMul (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2)\n    (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2) := Mul.toSMul _", "start": [395, 1], "end": [397, 67], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_S_right", "code": "@[nolint defLemma]\nlocal instance isScalarTower_S_right :\n    IsScalarTower S (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2)\n      (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2) := IsScalarTower.right", "start": [399, 1], "end": [403, 76], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_R_right", "code": "@[nolint defLemma]\nlocal instance isScalarTower_R_right :\n    IsScalarTower R (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2)\n      (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2) := IsScalarTower.right", "start": [405, 1], "end": [409, 76], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_SS_right", "code": "@[nolint defLemma]\nlocal instance isScalarTower_SS_right : IsScalarTower (S \u2297[R] S)\n    (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2) (S \u2297[R] S \u29f8 KaehlerDifferential.ideal R S ^ 2) :=\n  IsScalarTower.right", "start": [411, 1], "end": [415, 22], "kind": "commanddeclaration"}, {"full_name": "instS", "code": "local instance instS : Module S (KaehlerDifferential.ideal R S).cotangentIdeal :=\n  Submodule.module' _", "start": [417, 1], "end": [419, 22], "kind": "commanddeclaration"}, {"full_name": "instR", "code": "local instance instR : Module R (KaehlerDifferential.ideal R S).cotangentIdeal :=\n  Submodule.module' _", "start": [421, 1], "end": [423, 22], "kind": "commanddeclaration"}, {"full_name": "instSS", "code": "local instance instSS : Module (S \u2297[R] S) (KaehlerDifferential.ideal R S).cotangentIdeal :=\n  Submodule.module' _", "start": [425, 1], "end": [427, 22], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.endEquivDerivation'", "code": "noncomputable def KaehlerDifferential.endEquivDerivation' :\n    Derivation R S (\u03a9[S\u2044R]) \u2243\u2097[R] Derivation R S (ideal R S).cotangentIdeal :=\n  LinearEquiv.compDer ((KaehlerDifferential.ideal R S).cotangentEquivIdeal.restrictScalars S)", "start": [429, 1], "end": [433, 94], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.endEquivAuxEquiv", "code": "def KaehlerDifferential.endEquivAuxEquiv :\n    { f //\n        (Ideal.Quotient.mk\u2090 R (KaehlerDifferential.ideal R S).cotangentIdeal).comp f =\n          IsScalarTower.toAlgHom R S _ } \u2243\n      { f // (TensorProduct.lmul' R : S \u2297[R] S \u2192\u2090[R] S).kerSquareLift.comp f = AlgHom.id R S } :=\n  (Equiv.refl _).subtypeEquiv (KaehlerDifferential.End_equiv_aux R S)", "start": [436, 1], "end": [443, 70], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.endEquiv", "code": "noncomputable def KaehlerDifferential.endEquiv :\n    Module.End S (\u03a9[S\u2044R]) \u2243\n      { f // (TensorProduct.lmul' R : S \u2297[R] S \u2192\u2090[R] S).kerSquareLift.comp f = AlgHom.id R S } :=\n  (KaehlerDifferential.linearMapEquivDerivation R S).toEquiv.trans <|\n    (KaehlerDifferential.endEquivDerivation' R S).toEquiv.trans <|\n      (derivationToSquareZeroEquivLift (KaehlerDifferential.ideal R S).cotangentIdeal\n            (KaehlerDifferential.ideal R S).cotangentIdeal_square).trans <|\n        KaehlerDifferential.endEquivAuxEquiv R S", "start": [446, 1], "end": [457, 49], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal", "code": "noncomputable def KaehlerDifferential.kerTotal : Submodule S (S \u2192\u2080 S) :=\n  Submodule.span S\n    (((Set.range fun x : S \u00d7 S => single x.1 1 + single x.2 1 - single (x.1 + x.2) 1) \u222a\n        Set.range fun x : S \u00d7 S => single x.2 x.1 + single x.1 x.2 - single (x.1 * x.2) 1) \u222a\n      Set.range fun x : R => single (algebraMap R S x) 1)", "start": [466, 1], "end": [480, 58], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_mkQ_single_add", "code": "theorem KaehlerDifferential.kerTotal_mkQ_single_add (x y z) : (z\ud835\udda3x + y) = (z\ud835\udda3x) + z\ud835\udda3y", "start": [489, 1], "end": [493, 91], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_mkQ_single_mul", "code": "theorem KaehlerDifferential.kerTotal_mkQ_single_mul (x y z) :\n    (z\ud835\udda3x * y) = ((z * x)\ud835\udda3y) + (z * y)\ud835\udda3x", "start": [496, 1], "end": [502, 91], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_mkQ_single_algebraMap", "code": "theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap (x y) : (y\ud835\udda3algebraMap R S x) = 0", "start": [505, 1], "end": [507, 76], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one", "code": "theorem KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one (x) : (x\ud835\udda31) = 0", "start": [510, 1], "end": [511, 86], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_mkQ_single_smul", "code": "theorem KaehlerDifferential.kerTotal_mkQ_single_smul (r : R) (x y) : (y\ud835\udda3r \u2022 x) = r \u2022 y\ud835\udda3x", "start": [514, 1], "end": [517, 53], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.derivationQuotKerTotal", "code": "noncomputable def KaehlerDifferential.derivationQuotKerTotal :\n    Derivation R S ((S \u2192\u2080 S) \u29f8 KaehlerDifferential.kerTotal R S) where\n  toFun x := 1\ud835\udda3x\n  map_add' x y := KaehlerDifferential.kerTotal_mkQ_single_add _ _ _ _ _\n  map_smul' r s := KaehlerDifferential.kerTotal_mkQ_single_smul _ _ _ _ _\n  map_one_eq_zero' := KaehlerDifferential.kerTotal_mkQ_single_algebraMap_one _ _ _\n  leibniz' a b :=\n    (KaehlerDifferential.kerTotal_mkQ_single_mul _ _ _ _ _).trans\n      (by simp_rw [\u2190 Finsupp.smul_single_one _ (1 * _ : S)]; dsimp; simp)", "start": [520, 1], "end": [529, 74], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.derivationQuotKerTotal_apply", "code": "theorem KaehlerDifferential.derivationQuotKerTotal_apply (x) :\n    KaehlerDifferential.derivationQuotKerTotal R S x = 1\ud835\udda3x", "start": [532, 1], "end": [534, 6], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.derivationQuotKerTotal_lift_comp_total", "code": "theorem KaehlerDifferential.derivationQuotKerTotal_lift_comp_total :\n    (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential.comp\n        (Finsupp.total S (\u03a9[S\u2044R]) S (KaehlerDifferential.D R S)) =\n      Submodule.mkQ _", "start": [537, 1], "end": [544, 58], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_eq", "code": "theorem KaehlerDifferential.kerTotal_eq :\n    LinearMap.ker (Finsupp.total S (\u03a9[S\u2044R]) S (KaehlerDifferential.D R S)) =\n      KaehlerDifferential.kerTotal R S", "start": [547, 1], "end": [555, 97], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.total_surjective", "code": "theorem KaehlerDifferential.total_surjective :\n    Function.Surjective (Finsupp.total S (\u03a9[S\u2044R]) S (KaehlerDifferential.D R S))", "start": [558, 1], "end": [560, 96], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.quotKerTotalEquiv", "code": "@[simps!]\nnoncomputable def KaehlerDifferential.quotKerTotalEquiv :\n    ((S \u2192\u2080 S) \u29f8 KaehlerDifferential.kerTotal R S) \u2243\u2097[S] \u03a9[S\u2044R] :=\n  { (KaehlerDifferential.kerTotal R S).liftQ\n      (Finsupp.total S (\u03a9[S\u2044R]) S (KaehlerDifferential.D R S))\n      (KaehlerDifferential.kerTotal_eq R S).ge with\n    invFun := (KaehlerDifferential.derivationQuotKerTotal R S).liftKaehlerDifferential\n    left_inv := by\n      intro x\n      obtain \u27e8x, rfl\u27e9 := Submodule.mkQ_surjective _ x\n      exact\n        LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S : _) x\n    right_inv := by\n      intro x\n      obtain \u27e8x, rfl\u27e9 := KaehlerDifferential.total_surjective R S x\n      have := LinearMap.congr_fun (KaehlerDifferential.derivationQuotKerTotal_lift_comp_total R S) x\n      rw [LinearMap.comp_apply] at this\n      rw [this]\n      rfl }", "start": [563, 1], "end": [582, 12], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.quotKerTotalEquiv_symm_comp_D", "code": "theorem KaehlerDifferential.quotKerTotalEquiv_symm_comp_D :\n    (KaehlerDifferential.quotKerTotalEquiv R S).symm.toLinearMap.compDer\n        (KaehlerDifferential.D R S) =\n      KaehlerDifferential.derivationQuotKerTotal R S", "start": [585, 1], "end": [589, 88], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.kerTotal_map", "code": "theorem KaehlerDifferential.kerTotal_map (h : Function.Surjective (algebraMap A B)) :\n    (KaehlerDifferential.kerTotal R A).map finsupp_map \u2294\n        Submodule.span A (Set.range fun x : S => single (algebraMap S B x) (1 : B)) =\n      (KaehlerDifferential.kerTotal S B).restrictScalars _", "start": [603, 1], "end": [623, 96], "kind": "commanddeclaration"}, {"full_name": "Derivation.compAlgebraMap", "code": "def Derivation.compAlgebraMap [Module A M] [Module B M] [IsScalarTower A B M]\n    (d : Derivation R B M) : Derivation R A M where\n  map_one_eq_zero' := by simp\n  leibniz' a b := by simp\n  toLinearMap := d.toLinearMap.comp (IsScalarTower.toAlgHom R A B).toLinearMap", "start": [641, 1], "end": [647, 79], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.map", "code": "def KaehlerDifferential.map : \u03a9[A\u2044R] \u2192\u2097[A] \u03a9[B\u2044S] :=\n  Derivation.liftKaehlerDifferential\n    (((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A)", "start": [653, 1], "end": [660, 71], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.map_compDer", "code": "theorem KaehlerDifferential.map_compDer :\n    (KaehlerDifferential.map R S A B).compDer (KaehlerDifferential.D R A) =\n      ((KaehlerDifferential.D S B).restrictScalars R).compAlgebraMap A", "start": [663, 1], "end": [666, 44], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.map_D", "code": "theorem KaehlerDifferential.map_D (x : A) :\n    KaehlerDifferential.map R S A B (KaehlerDifferential.D R A x) =\n      KaehlerDifferential.D S B (algebraMap A B x)", "start": [669, 1], "end": [672, 67], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.map_surjective_of_surjective", "code": "theorem KaehlerDifferential.map_surjective_of_surjective\n    (h : Function.Surjective (algebraMap A B)) :\n    Function.Surjective (KaehlerDifferential.map R S A B)", "start": [678, 1], "end": [687, 17], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.mapBaseChange", "code": "noncomputable def KaehlerDifferential.mapBaseChange : B \u2297[A] \u03a9[A\u2044R] \u2192\u2097[B] \u03a9[B\u2044R] :=\n  (TensorProduct.isBaseChange A (\u03a9[A\u2044R]) B).lift (KaehlerDifferential.map R R A B)", "start": [690, 1], "end": [693, 83], "kind": "commanddeclaration"}, {"full_name": "KaehlerDifferential.mapBaseChange_tmul", "code": "@[simp]\ntheorem KaehlerDifferential.mapBaseChange_tmul (x : B) (y : \u03a9[A\u2044R]) :\n    KaehlerDifferential.mapBaseChange R A B (x \u2297\u209c y) = x \u2022 KaehlerDifferential.map R R A B y", "start": [696, 1], "end": [701, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorPower.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Algebra/DirectSum/Algebra.lean", "Mathlib/LinearAlgebra/PiTensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorPower", "code": "@[reducible]\ndef TensorPower (R : Type*) (n : \u2115) (M : Type*) [CommSemiring R] [AddCommMonoid M]\n    [Module R M] : Type _ :=\n  \u2a02[R] _ : Fin n, M", "start": [36, 1], "end": [41, 20], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.gradedMonoid_eq_of_reindex_cast", "code": "@[ext]\ntheorem gradedMonoid_eq_of_reindex_cast {\u03b9\u03b9 : Type*} {\u03b9 : \u03b9\u03b9 \u2192 Type*} :\n    \u2200 {a b : GradedMonoid fun ii => \u2a02[R] _ : \u03b9 ii, M} (h : a.fst = b.fst),\n      reindex R M (Equiv.cast <| congr_arg \u03b9 h) a.snd = b.snd \u2192 a = b", "start": [50, 1], "end": [58, 13], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gOne", "code": "instance gOne : GradedMonoid.GOne fun i => (\u2a02[R]^i) M where one := tprod R <| @Fin.elim0' M", "start": [69, 1], "end": [70, 92], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gOne_def", "code": "theorem gOne_def : \u209c1 = tprod R (@Fin.elim0' M)", "start": [75, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "TensorPower.mulEquiv", "code": "def mulEquiv {n m : \u2115} : (\u2a02[R]^n) M \u2297[R] (\u2a02[R]^m) M \u2243\u2097[R] (\u2a02[R]^(n + m)) M :=\n  (tmulEquiv R M).trans (reindex R M finSumFinEquiv)", "start": [79, 1], "end": [81, 53], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gMul", "code": "instance gMul : GradedMonoid.GMul fun i => (\u2a02[R]^i) M where\n  mul {i j} a b :=\n    (TensorProduct.mk R _ _).compr\u2082 (\u2191(mulEquiv : _ \u2243\u2097[R] (\u2a02[R]^(i + j)) M)) a b", "start": [84, 1], "end": [87, 81], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gMul_def", "code": "theorem gMul_def {i j} (a : (\u2a02[R]^i) M) (b : (\u2a02[R]^j) M) :\n    a \u209c* b = @mulEquiv R M _ _ _ i j (a \u2297\u209c b)", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gMul_eq_coe_linearMap", "code": "theorem gMul_eq_coe_linearMap {i j} (a : (\u2a02[R]^i) M) (b : (\u2a02[R]^j) M) :\n    a \u209c* b = ((TensorProduct.mk R _ _).compr\u2082 \u2191(mulEquiv : _ \u2243\u2097[R] (\u2a02[R]^(i + j)) M) :\n      (\u2a02[R]^i) M \u2192\u2097[R] (\u2a02[R]^j) M \u2192\u2097[R] (\u2a02[R]^(i + j)) M) a b", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast", "code": "def cast {i j} (h : i = j) : (\u2a02[R]^i) M \u2243\u2097[R] (\u2a02[R]^j) M :=\n  reindex R M (Fin.castIso h).toEquiv", "start": [105, 1], "end": [107, 38], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_tprod", "code": "theorem cast_tprod {i j} (h : i = j) (a : Fin i \u2192 M) :\n    cast R M h (tprod R a) = tprod R (a \u2218 Fin.cast h.symm)", "start": [110, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_refl", "code": "@[simp]\ntheorem cast_refl {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _", "start": [115, 1], "end": [117, 97], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_symm", "code": "@[simp]\ntheorem cast_symm {i j} (h : i = j) : (cast R M h).symm = cast R M h.symm", "start": [120, 1], "end": [122, 17], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_trans", "code": "@[simp]\ntheorem cast_trans {i j k} (h : i = j) (h' : j = k) :\n    (cast R M h).trans (cast R M h') = cast R M (h.trans h')", "start": [125, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_cast", "code": "@[simp]\ntheorem cast_cast {i j k} (h : i = j) (h' : j = k) (a : (\u2a02[R]^i) M) :\n    cast R M h' (cast R M h a) = cast R M (h.trans h') a", "start": [133, 1], "end": [136, 24], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gradedMonoid_eq_of_cast", "code": "@[ext]\ntheorem gradedMonoid_eq_of_cast {a b : GradedMonoid fun n => \u2a02[R] _ : Fin n, M} (h : a.fst = b.fst)\n    (h2 : cast R M h a.snd = b.snd) : a = b", "start": [139, 1], "end": [144, 36], "kind": "commanddeclaration"}, {"full_name": "TensorPower.cast_eq_cast", "code": "theorem cast_eq_cast {i j} (h : i = j) :\n    \u21d1(cast R M h) = _root_.cast (congrArg (fun i => (\u2a02[R]^i) M) h)", "start": [147, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "TensorPower.tprod_mul_tprod", "code": "theorem tprod_mul_tprod {na nb} (a : Fin na \u2192 M) (b : Fin nb \u2192 M) :\n    tprod R a \u209c* tprod R b = tprod R (Fin.append a b)", "start": [156, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "TensorPower.one_mul", "code": "theorem one_mul {n} (a : (\u2a02[R]^n) M) : cast R M (zero_add n) (\u209c1 \u209c* a) = a", "start": [169, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "TensorPower.mul_one", "code": "theorem mul_one {n} (a : (\u2a02[R]^n) M) : cast R M (add_zero _) (a \u209c* \u209c1) = a", "start": [181, 1], "end": [190, 58], "kind": "commanddeclaration"}, {"full_name": "TensorPower.mul_assoc", "code": "theorem mul_assoc {na nb nc} (a : (\u2a02[R]^na) M) (b : (\u2a02[R]^nb) M) (c : (\u2a02[R]^nc) M) :\n    cast R M (add_assoc _ _ _) (a \u209c* b \u209c* c) = a \u209c* (b \u209c* c)", "start": [193, 1], "end": [214, 34], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gmonoid", "code": "instance gmonoid : GradedMonoid.GMonoid fun i => (\u2a02[R]^i) M :=\n  { TensorPower.gMul, TensorPower.gOne with\n    one_mul := fun a => gradedMonoid_eq_of_cast (zero_add _) (one_mul _)\n    mul_one := fun a => gradedMonoid_eq_of_cast (add_zero _) (mul_one _)\n    mul_assoc := fun a b c => gradedMonoid_eq_of_cast (add_assoc _ _ _) (mul_assoc _ _ _) }", "start": [218, 1], "end": [222, 92], "kind": "commanddeclaration"}, {"full_name": "TensorPower.algebraMap\u2080", "code": "def algebraMap\u2080 : R \u2243\u2097[R] (\u2a02[R]^0) M :=\n  LinearEquiv.symm <| isEmptyEquiv (Fin 0)", "start": [225, 1], "end": [228, 43], "kind": "commanddeclaration"}, {"full_name": "TensorPower.algebraMap\u2080_eq_smul_one", "code": "theorem algebraMap\u2080_eq_smul_one (r : R) : (algebraMap\u2080 r : (\u2a02[R]^0) M) = r \u2022 \u209c1", "start": [231, 1], "end": [232, 28], "kind": "commanddeclaration"}, {"full_name": "TensorPower.algebraMap\u2080_one", "code": "theorem algebraMap\u2080_one : (algebraMap\u2080 1 : (\u2a02[R]^0) M) = \u209c1", "start": [235, 1], "end": [236, 51], "kind": "commanddeclaration"}, {"full_name": "TensorPower.algebraMap\u2080_mul", "code": "theorem algebraMap\u2080_mul {n} (r : R) (a : (\u2a02[R]^n) M) :\n    cast R M (zero_add _) (algebraMap\u2080 r \u209c* a) = r \u2022 a", "start": [239, 1], "end": [242, 60], "kind": "commanddeclaration"}, {"full_name": "TensorPower.mul_algebraMap\u2080", "code": "theorem mul_algebraMap\u2080 {n} (r : R) (a : (\u2a02[R]^n) M) :\n    cast R M (add_zero _) (a \u209c* algebraMap\u2080 r) = r \u2022 a", "start": [245, 1], "end": [248, 60], "kind": "commanddeclaration"}, {"full_name": "TensorPower.algebraMap\u2080_mul_algebraMap\u2080", "code": "theorem algebraMap\u2080_mul_algebraMap\u2080 (r s : R) :\n    cast R M (add_zero _) (algebraMap\u2080 r \u209c* algebraMap\u2080 s) = algebraMap\u2080 (r * s)", "start": [251, 1], "end": [254, 53], "kind": "commanddeclaration"}, {"full_name": "TensorPower.gsemiring", "code": "instance gsemiring : DirectSum.GSemiring fun i => (\u2a02[R]^i) M :=\n  { TensorPower.gmonoid with\n    mul_zero := fun a => LinearMap.map_zero _\n    zero_mul := fun b => LinearMap.map_zero\u2082 _ _\n    mul_add := fun a b\u2081 b\u2082 => LinearMap.map_add _ _ _\n    add_mul := fun a\u2081 a\u2082 b => LinearMap.map_add\u2082 _ _ _ _\n    natCast := fun n => algebraMap\u2080 (n : R)\n    natCast_zero := by simp only [Nat.cast_zero, map_zero]\n    natCast_succ := fun n => by simp only [Nat.cast_succ, map_add, algebraMap\u2080_one] }", "start": [257, 1], "end": [265, 86], "kind": "commanddeclaration"}, {"full_name": "TensorPower.galgebra", "code": "instance galgebra : DirectSum.GAlgebra R fun i => (\u2a02[R]^i) M where\n  toFun := (algebraMap\u2080 : R \u2243\u2097[R] (\u2a02[R]^0) M).toLinearMap.toAddMonoidHom\n  map_one := algebraMap\u2080_one\n  map_mul r s := gradedMonoid_eq_of_cast rfl (by\n    rw [\u2190 LinearEquiv.eq_symm_apply]\n    have := algebraMap\u2080_mul_algebraMap\u2080 (M := M) r s\n    exact this.symm)\n  commutes r x := gradedMonoid_eq_of_cast (add_comm _ _) (by\n    have := (algebraMap\u2080_mul r x.snd).trans (mul_algebraMap\u2080 r x.snd).symm\n    rw [\u2190 LinearEquiv.eq_symm_apply, cast_symm]\n    rw [\u2190 LinearEquiv.eq_symm_apply, cast_symm, cast_cast] at this\n    exact this)\n  smul_def r x := gradedMonoid_eq_of_cast (zero_add x.fst).symm (by\n    rw [\u2190 LinearEquiv.eq_symm_apply, cast_symm]\n    exact (algebraMap\u2080_mul r x.snd).symm)", "start": [270, 1], "end": [287, 42], "kind": "commanddeclaration"}, {"full_name": "TensorPower.galgebra_toFun_def", "code": "theorem galgebra_toFun_def (r : R) :\n    @DirectSum.GAlgebra.toFun \u2115 R (fun i => (\u2a02[R]^i) M) _ _ _ _ _ _ _ r = algebraMap\u2080 r", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/LocallyConstant/Algebra.lean", "imports": ["Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/LinearAlgebra/Pi.lean", "Mathlib/Topology/LocallyConstant/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyConstant.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one [One Y] : \u21d1(1 : LocallyConstant X Y) = (1 : X \u2192 Y)", "start": [29, 1], "end": [31, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.one_apply", "code": "@[to_additive]\ntheorem one_apply [One Y] (x : X) : (1 : LocallyConstant X Y) x = 1", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_inv [Inv Y] (f : LocallyConstant X Y) : \u21d1(f\u207b\u00b9 : LocallyConstant X Y) = (f : X \u2192 Y)\u207b\u00b9", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.inv_apply", "code": "@[to_additive]\ntheorem inv_apply [Inv Y] (f : LocallyConstant X Y) (x : X) : f\u207b\u00b9 x = (f x)\u207b\u00b9", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_mul", "code": "@[to_additive (attr := simp)]\ntheorem coe_mul [Mul Y] (f g : LocallyConstant X Y) : \u21d1(f * g) = f * g", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.mul_apply", "code": "@[to_additive]\ntheorem mul_apply [Mul Y] (f g : LocallyConstant X Y) (x : X) : (f * g) x = f x * g x", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coeFnMonoidHom", "code": "@[to_additive (attr := simps) \"`FunLike.coe` as an `AddMonoidHom`.\"]\ndef coeFnMonoidHom [MulOneClass Y] : LocallyConstant X Y \u2192* X \u2192 Y where\n  toFun := FunLike.coe\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [76, 1], "end": [81, 22], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.constMonoidHom", "code": "@[to_additive (attr := simps) \"The constant-function embedding, as an additive monoid hom.\"]\ndef constMonoidHom [MulOneClass Y] : Y \u2192* LocallyConstant X Y where\n  toFun := const X\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [85, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.charFn", "code": "noncomputable def charFn (hU : IsClopen U) : LocallyConstant X Y :=\n  indicator 1 hU", "start": [104, 1], "end": [107, 17], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_charFn", "code": "theorem coe_charFn (hU : IsClopen U) : (charFn Y hU : X \u2192 Y) = Set.indicator U 1", "start": [110, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.charFn_eq_one", "code": "theorem charFn_eq_one [Nontrivial Y] (x : X) (hU : IsClopen U) : charFn Y hU x = (1 : Y) \u2194 x \u2208 U", "start": [114, 1], "end": [115, 33], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.charFn_eq_zero", "code": "theorem charFn_eq_zero [Nontrivial Y] (x : X) (hU : IsClopen U) : charFn Y hU x = (0 : Y) \u2194 x \u2209 U", "start": [118, 1], "end": [119, 38], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.charFn_inj", "code": "theorem charFn_inj [Nontrivial Y] (hU : IsClopen U) (hV : IsClopen V)\n    (h : charFn Y hU = charFn Y hV) : U = V", "start": [122, 1], "end": [124, 43], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_div", "code": "@[to_additive]\ntheorem coe_div [Div Y] (f g : LocallyConstant X Y) : \u21d1(f / g) = f / g", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.div_apply", "code": "@[to_additive]\ntheorem div_apply [Div Y] (f g : LocallyConstant X Y) (x : X) : (f / g) x = f x / g x", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.smul", "code": "@[to_additive]\ninstance smul [SMul \u03b1 Y] : SMul \u03b1 (LocallyConstant X Y) where\n  smul n f := f.map (n \u2022 \u00b7)", "start": [156, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_smul", "code": "@[to_additive (attr := simp)]\ntheorem coe_smul [SMul R Y] (r : R) (f : LocallyConstant X Y) : \u21d1(r \u2022 f) = r \u2022 (f : X \u2192 Y)", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.smul_apply", "code": "@[to_additive]\ntheorem smul_apply [SMul R Y] (r : R) (f : LocallyConstant X Y) (x : X) : (r \u2022 f) x = r \u2022 f x", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.constRingHom", "code": "@[simps]\ndef constRingHom [NonAssocSemiring Y] : Y \u2192+* LocallyConstant X Y :=\n  { constMonoidHom, constAddMonoidHom with toFun := const X }", "start": [218, 1], "end": [221, 62], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coe_algebraMap", "code": "@[simp]\ntheorem coe_algebraMap (r : R) : \u21d1(algebraMap R (LocallyConstant X Y) r) = algebraMap R (X \u2192 Y) r", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coeFnRingHom", "code": "@[simps!] def coeFnRingHom [Semiring Y] : LocallyConstant X Y \u2192+* X \u2192 Y where\n  toMonoidHom := coeFnMonoidHom\n  __ := coeFnAddMonoidHom", "start": [299, 1], "end": [302, 26], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coeFn\u2097", "code": "@[simps!] def coeFn\u2097 (R : Type*) [Semiring R] [AddCommMonoid Y]\n    [Module R Y] : LocallyConstant X Y \u2192\u2097[R] X \u2192 Y where\n  toAddHom := coeFnAddMonoidHom.toAddHom\n  map_smul' _ _ := rfl", "start": [304, 1], "end": [308, 23], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.coeFnAlgHom", "code": "@[simps!] def coeFnAlgHom (R : Type*) [CommSemiring R] [Semiring Y] [Algebra R Y] :\n    LocallyConstant X Y \u2192\u2090[R] X \u2192 Y where\n  toRingHom := coeFnRingHom\n  commutes' _ := rfl", "start": [310, 1], "end": [314, 21], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.evalMonoidHom", "code": "@[to_additive (attr := simps!) \"Evaluation as an `AddMonoidHom`\"]\ndef evalMonoidHom [MulOneClass Y] (x : X) : LocallyConstant X Y \u2192* Y :=\n  (Pi.evalMonoidHom _ x).comp coeFnMonoidHom", "start": [320, 1], "end": [323, 45], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.eval\u2097", "code": "@[simps!] def eval\u2097 (R : Type*) [Semiring R] [AddCommMonoid Y]\n    [Module R Y] (x : X) : LocallyConstant X Y \u2192\u2097[R] Y :=\n  (LinearMap.proj x).comp (coeFn\u2097 R)", "start": [325, 1], "end": [328, 37], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.evalRingHom", "code": "@[simps!] def evalRingHom [Semiring Y] (x : X) : LocallyConstant X Y \u2192+* Y :=\n  (Pi.evalRingHom _ x).comp coeFnRingHom", "start": [330, 1], "end": [332, 41], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.eval\u2090", "code": "@[simps!]\ndef eval\u2090 (R : Type*) [CommSemiring R] [Semiring Y] [Algebra R Y] (x : X) :\n    LocallyConstant X Y \u2192\u2090[R] Y :=\n  (Pi.evalAlgHom _ _ x).comp (coeFnAlgHom R)", "start": [334, 1], "end": [338, 45], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.comapMulHom", "code": "@[to_additive (attr := simps) \"`LocallyConstant.comap` as an `AddHom`.\"]\nnoncomputable\ndef comapMulHom [Mul Z] (f : X \u2192 Y) (hf : Continuous f) :\n    LocallyConstant Y Z \u2192\u2099* LocallyConstant X Z where\n  toFun := comap f\n  map_mul' r s := by ext x; simp [hf]", "start": [346, 1], "end": [352, 38], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.comapMonoidHom", "code": "@[to_additive (attr := simps) \"`LocallyConstant.comap` as an `AddMonoidHom`.\"]\nnoncomputable\ndef comapMonoidHom [MulOneClass Z] (f : X \u2192 Y) (hf : Continuous f) :\n    LocallyConstant Y Z \u2192* LocallyConstant X Z where\n  toFun := comap f\n  map_one' := by ext x; simp [hf]\n  map_mul' := map_mul (comapMulHom f hf)", "start": [354, 1], "end": [361, 41], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.comap\u2097", "code": "@[simps!]\nnoncomputable\ndef comap\u2097 (R : Type*) [Semiring R] [AddCommMonoid Z] [Module R Z] (f : X \u2192 Y)\n    (hf : Continuous f) : LocallyConstant Y Z \u2192\u2097[R] LocallyConstant X Z where\n  toFun := comap f\n  map_add' := map_add (comapAddMonoidHom f hf)\n  map_smul' r s := by ext x; simp [hf]", "start": [363, 1], "end": [370, 39], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.comapRingHom", "code": "@[simps!]\nnoncomputable\ndef comapRingHom [Semiring Z] (f : X \u2192 Y) (hf : Continuous f) :\n    LocallyConstant Y Z \u2192+* LocallyConstant X Z where\n  toMonoidHom := comapMonoidHom f hf\n  __ := (comapAddMonoidHom f hf)", "start": [372, 1], "end": [378, 33], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.comap\u2090", "code": "@[simps!]\nnoncomputable\ndef comap\u2090 (R: Type*) [CommSemiring R] [Semiring Z] [Algebra R Z]\n    (f : X \u2192 Y) (hf : Continuous f) : LocallyConstant Y Z \u2192\u2090[R] LocallyConstant X Z where\n  toRingHom := comapRingHom f hf\n  commutes' r := by ext x; simp [hf]", "start": [380, 1], "end": [386, 37], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.ker_comap\u2097", "code": "lemma ker_comap\u2097 [Semiring R] [AddCommMonoid Z] [Module R Z] (f : X \u2192 Y)\n    (hf : Continuous f) (hfs : Function.Surjective f) :\n    LinearMap.ker (comap\u2097 R f hf : LocallyConstant Y Z \u2192\u2097[R] LocallyConstant X Z) = \u22a5 :=\n  LinearMap.ker_eq_bot_of_injective <| comap_injective _ hf hfs", "start": [388, 1], "end": [391, 64], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyConstant.congrLeftMulEquiv", "code": "@[to_additive (attr := simps!) \"`LocallyConstant.congrLeft` as an `AddEquiv`.\"]\nnoncomputable\ndef congrLeftMulEquiv [Mul Z] (e : X \u2243\u209c Y) :\n    LocallyConstant X Z \u2243* LocallyConstant Y Z where\n  toEquiv := congrLeft e\n  map_mul' := map_mul (comapMulHom _ e.symm.continuous)", "start": [393, 1], "end": [399, 56], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.congrLeft\u2097", "code": "@[simps!]\nnoncomputable\ndef congrLeft\u2097 (R: Type*) [Semiring R] [AddCommMonoid Z] [Module R Z] (e : X \u2243\u209c Y) :\n    LocallyConstant X Z \u2243\u2097[R] LocallyConstant Y Z where\n  toLinearMap := comap\u2097 R _ e.symm.continuous\n  __ := congrLeft e", "start": [401, 1], "end": [407, 20], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.congrLeftRingEquiv", "code": "@[simps!]\nnoncomputable\ndef congrLeftRingEquiv [Semiring Z] (e : X \u2243\u209c Y) :\n    LocallyConstant X Z \u2243+* LocallyConstant Y Z where\n  toEquiv := congrLeft e\n  __ := comapMonoidHom _ e.symm.continuous\n  __ := comapAddMonoidHom _ e.symm.continuous", "start": [409, 1], "end": [416, 46], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.congrLeft\u2090", "code": "@[simps!]\nnoncomputable\ndef congrLeft\u2090 (R: Type*) [CommSemiring R] [Semiring Z] [Algebra R Z] (e : X \u2243\u209c Y) :\n    LocallyConstant X Z \u2243\u2090[R] LocallyConstant Y Z where\n  toEquiv := congrLeft e\n  __ := comap\u2090 R _ e.symm.continuous", "start": [418, 1], "end": [424, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Groupoid/VertexGroup.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Combinatorics/Quiver/ConnectedComponent.lean", "Mathlib/Combinatorics/Quiver/Path.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/PathCategory.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/Group/Defs.lean"], "premises": [{"full_name": "CategoryTheory.Groupoid.vertexGroup", "code": "@[simps mul one inv]\ninstance vertexGroup (c : C) : Group (c \u27f6 c) where\n  mul := fun x y : c \u27f6 c => x \u226b y\n  mul_assoc := Category.assoc\n  one := \ud835\udfd9 c\n  one_mul := Category.id_comp\n  mul_one := Category.comp_id\n  inv := Groupoid.inv\n  mul_left_inv := inv_comp", "start": [42, 1], "end": [51, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.vertexGroup.inv_eq_inv", "code": "theorem vertexGroup.inv_eq_inv (c : C) (\u03b3 : c \u27f6 c) : \u03b3\u207b\u00b9 = CategoryTheory.inv \u03b3", "start": [54, 1], "end": [56, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.vertexGroupIsomOfMap", "code": "@[simps]\ndef vertexGroupIsomOfMap {c d : C} (f : c \u27f6 d) : (c \u27f6 c) \u2243* (d \u27f6 d)\n    where\n  toFun \u03b3 := inv f \u226b \u03b3 \u226b f\n  invFun \u03b4 := f \u226b \u03b4 \u226b inv f\n  left_inv \u03b3 := by\n    simp_rw [Category.assoc, comp_inv, Category.comp_id, \u2190 Category.assoc, comp_inv,\n      Category.id_comp]\n  right_inv \u03b4 := by\n    simp_rw [Category.assoc, inv_comp, \u2190 Category.assoc, inv_comp, Category.id_comp,\n      Category.comp_id]\n  map_mul' \u03b3\u2081 \u03b3\u2082 := by\n    simp only [vertexGroup_mul, inv_eq_inv, Category.assoc, IsIso.hom_inv_id_assoc]", "start": [59, 1], "end": [74, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.vertexGroupIsomOfPath", "code": "def vertexGroupIsomOfPath {c d : C} (p : Quiver.Path c d) : (c \u27f6 c) \u2243* (d \u27f6 d) :=\n  vertexGroupIsomOfMap (composePath p)", "start": [77, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.CategoryTheory.Functor.mapVertexGroup", "code": "@[simps]\ndef CategoryTheory.Functor.mapVertexGroup {D : Type v} [Groupoid D] (\u03c6 : C \u2964 D) (c : C) :\n    (c \u27f6 c) \u2192* (\u03c6.obj c \u27f6 \u03c6.obj c) where\n  toFun := \u03c6.map\n  map_one' := \u03c6.map_id c\n  map_mul' := \u03c6.map_comp", "start": [83, 1], "end": [89, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Groupoid/Basic.lean", "imports": ["Mathlib/Combinatorics/Quiver/Basic.lean", "Mathlib/CategoryTheory/Groupoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Groupoid.isThin_iff", "code": "theorem isThin_iff : Quiver.IsThin C \u2194 \u2200 c : C, Subsingleton (c \u27f6 c)", "start": [23, 1], "end": [30, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.IsTotallyDisconnected", "code": "def IsTotallyDisconnected :=\n  \u2200 c d : C, (c \u27f6 d) \u2192 c = d", "start": [37, 1], "end": [39, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/SuccPred.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Order/SuccPred/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.succ_eq", "code": "@[simp]\ntheorem succ_eq {n : \u2115} : SuccOrder.succ = fun a => if a < Fin.last n then a + 1 else a", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_apply", "code": "@[simp]\ntheorem succ_apply {n : \u2115} (a) : SuccOrder.succ a = if a < Fin.last n then a + 1 else a", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_eq", "code": "@[simp]\ntheorem pred_eq {n} : PredOrder.pred = fun a : Fin (n + 1) => if a = 0 then 0 else a - 1", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_apply", "code": "@[simp]\ntheorem pred_apply {n : \u2115} (a : Fin (n + 1)) : PredOrder.pred a = if a = 0 then 0 else a - 1", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Prod.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.boxProd", "code": "def boxProd (G : SimpleGraph \u03b1) (H : SimpleGraph \u03b2) : SimpleGraph (\u03b1 \u00d7 \u03b2) where\n  Adj x y := G.Adj x.1 y.1 \u2227 x.2 = y.2 \u2228 H.Adj x.2 y.2 \u2227 x.1 = y.1\n  symm x y := by simp [and_comm, or_comm, eq_comm, adj_comm]\n  loopless x := by simp", "start": [42, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_adj", "code": "@[simp]\ntheorem boxProd_adj : (G \u25a1 H).Adj x y \u2194 G.Adj x.1 y.1 \u2227 x.2 = y.2 \u2228 H.Adj x.2 y.2 \u2227 x.1 = y.1", "start": [55, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_adj_left", "code": "theorem boxProd_adj_left : (G \u25a1 H).Adj (a\u2081, b) (a\u2082, b) \u2194 G.Adj a\u2081 a\u2082", "start": [61, 1], "end": [62, 77], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_adj_right", "code": "theorem boxProd_adj_right : (G \u25a1 H).Adj (a, b\u2081) (a, b\u2082) \u2194 H.Adj b\u2081 b\u2082", "start": [66, 1], "end": [67, 77], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_neighborSet", "code": "theorem boxProd_neighborSet (x : \u03b1 \u00d7 \u03b2) :\n    (G \u25a1 H).neighborSet x = G.neighborSet x.1 \u00d7\u02e2 {x.2} \u222a {x.1} \u00d7\u02e2 H.neighborSet x.2", "start": [70, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProdComm", "code": "@[simps!]\ndef boxProdComm : G \u25a1 H \u2243g H \u25a1 G := \u27e8Equiv.prodComm _ _, or_comm\u27e9", "start": [79, 1], "end": [81, 66], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProdAssoc", "code": "@[simps!]\ndef boxProdAssoc (I : SimpleGraph \u03b3) : G \u25a1 H \u25a1 I \u2243g G \u25a1 (H \u25a1 I) :=\n  \u27e8Equiv.prodAssoc _ _ _, fun {x y} => by\n    simp only [boxProd_adj, Equiv.prodAssoc_apply, or_and_right, or_assoc, Prod.ext_iff,\n      and_assoc, @and_comm (x.fst.fst = _)]\u27e9", "start": [84, 1], "end": [89, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProdLeft", "code": "@[simps]\ndef boxProdLeft (b : \u03b2) : G \u21aag G \u25a1 H where\n  toFun a := (a, b)\n  inj' _ _ := congr_arg Prod.fst\n  map_rel_iff' {_ _} := boxProd_adj_left", "start": [92, 1], "end": [97, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProdRight", "code": "@[simps]\ndef boxProdRight (a : \u03b1) : H \u21aag G \u25a1 H where\n  toFun := Prod.mk a\n  inj' _ _ := congr_arg Prod.snd\n  map_rel_iff' {_ _} := boxProd_adj_right", "start": [100, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.boxProdLeft", "code": "protected def boxProdLeft (b : \u03b2) : G.Walk a\u2081 a\u2082 \u2192 (G \u25a1 H).Walk (a\u2081, b) (a\u2082, b) :=\n  Walk.map (G.boxProdLeft H b).toHom", "start": [112, 1], "end": [114, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.boxProdRight", "code": "protected def boxProdRight (a : \u03b1) : H.Walk b\u2081 b\u2082 \u2192 (G \u25a1 H).Walk (a, b\u2081) (a, b\u2082) :=\n  Walk.map (G.boxProdRight H a).toHom", "start": [119, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.ofBoxProdLeft", "code": "def ofBoxProdLeft [DecidableEq \u03b2] [DecidableRel G.Adj] {x y : \u03b1 \u00d7 \u03b2} :\n    (G \u25a1 H).Walk x y \u2192 G.Walk x.1 y.1\n  | nil => nil\n  | cons h w =>\n    Or.by_cases h\n      (fun hG => w.ofBoxProdLeft.cons hG.1)\n      (fun hH => hH.2 \u25b8 w.ofBoxProdLeft)", "start": [126, 1], "end": [133, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.ofBoxProdRight", "code": "def ofBoxProdRight [DecidableEq \u03b1] [DecidableRel H.Adj] {x y : \u03b1 \u00d7 \u03b2} :\n    (G \u25a1 H).Walk x y \u2192 H.Walk x.2 y.2\n  | nil => nil\n  | cons h w =>\n    (Or.symm h).by_cases\n      (fun hH => w.ofBoxProdRight.cons hH.1)\n      (fun hG => hG.2 \u25b8 w.ofBoxProdRight)", "start": [136, 1], "end": [143, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.ofBoxProdLeft_boxProdLeft", "code": "@[simp]\ntheorem ofBoxProdLeft_boxProdLeft [DecidableEq \u03b2] [DecidableRel G.Adj] {a\u2081 a\u2082 : \u03b1} :\n    \u2200 (w : G.Walk a\u2081 a\u2082), (w.boxProdLeft H b).ofBoxProdLeft = w", "start": [146, 1], "end": [153, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.ofBoxProdLeft_boxProdRight", "code": "@[simp]\ntheorem ofBoxProdLeft_boxProdRight [DecidableEq \u03b1] [DecidableRel G.Adj] {b\u2081 b\u2082 : \u03b1} :\n    \u2200 (w : G.Walk b\u2081 b\u2082), (w.boxProdRight G a).ofBoxProdRight = w", "start": [156, 1], "end": [164, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.boxProd", "code": "protected theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n    (G \u25a1 H).Preconnected", "start": [171, 1], "end": [176, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.ofBoxProdLeft", "code": "protected theorem Preconnected.ofBoxProdLeft [Nonempty \u03b2] (h : (G \u25a1 H).Preconnected) :\n    G.Preconnected", "start": [179, 1], "end": [184, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.ofBoxProdRight", "code": "protected theorem Preconnected.ofBoxProdRight [Nonempty \u03b1] (h : (G \u25a1 H).Preconnected) :\n    H.Preconnected", "start": [187, 1], "end": [192, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.boxProd", "code": "protected theorem Connected.boxProd (hG : G.Connected) (hH : H.Connected) : (G \u25a1 H).Connected", "start": [195, 1], "end": [198, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.ofBoxProdLeft", "code": "protected theorem Connected.ofBoxProdLeft (h : (G \u25a1 H).Connected) : G.Connected", "start": [201, 1], "end": [204, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.ofBoxProdRight", "code": "protected theorem Connected.ofBoxProdRight (h : (G \u25a1 H).Connected) : H.Connected", "start": [207, 1], "end": [210, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_connected", "code": "@[simp]\ntheorem boxProd_connected : (G \u25a1 H).Connected \u2194 G.Connected \u2227 H.Connected", "start": [213, 1], "end": [215, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProdFintypeNeighborSet", "code": "instance boxProdFintypeNeighborSet (x : \u03b1 \u00d7 \u03b2)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] :\n    Fintype ((G \u25a1 H).neighborSet x) :=\n  Fintype.ofEquiv\n    ((G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2) <|\n        Finset.disjoint_product.mpr <| Or.inl <| neighborFinset_disjoint_singleton _ _)\n    ((Equiv.refl _).subtypeEquiv fun y => by\n      simp_rw [Finset.mem_disjUnion, Finset.mem_product, Finset.mem_singleton, mem_neighborFinset,\n        mem_neighborSet, Equiv.refl_apply, boxProd_adj]\n      simp only [eq_comm, and_comm])", "start": [218, 1], "end": [227, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_neighborFinset", "code": "theorem boxProd_neighborFinset (x : \u03b1 \u00d7 \u03b2)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G \u25a1 H).neighborSet x)] :\n    (G \u25a1 H).neighborFinset x =\n      (G.neighborFinset x.1 \u00d7\u02e2 {x.2}).disjUnion ({x.1} \u00d7\u02e2 H.neighborFinset x.2)\n        (Finset.disjoint_product.mpr <| Or.inl <| neighborFinset_disjoint_singleton _ _)", "start": [230, 1], "end": [238, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.boxProd_degree", "code": "theorem boxProd_degree (x : \u03b1 \u00d7 \u03b2)\n    [Fintype (G.neighborSet x.1)] [Fintype (H.neighborSet x.2)] [Fintype ((G \u25a1 H).neighborSet x)] :\n    (G \u25a1 H).degree x = G.degree x.1 + H.degree x.2", "start": [241, 1], "end": [245, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/RingHom/FiniteType.lean", "imports": ["Mathlib/RingTheory/LocalProperties.lean", "Mathlib/RingTheory/Localization/InvSubmonoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.finiteType_stableUnderComposition", "code": "theorem finiteType_stableUnderComposition : StableUnderComposition @FiniteType", "start": [24, 1], "end": [26, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.finiteType_holdsForLocalizationAway", "code": "theorem finiteType_holdsForLocalizationAway : HoldsForLocalizationAway @FiniteType", "start": [29, 1], "end": [35, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.finiteType_ofLocalizationSpanTarget", "code": "theorem finiteType_ofLocalizationSpanTarget : OfLocalizationSpanTarget @FiniteType", "start": [38, 1], "end": [91, 23], "kind": "commanddeclaration"}, {"full_name": "RingHom.finiteType_is_local", "code": "theorem finiteType_is_local : PropertyIsLocal @FiniteType", "start": [94, 1], "end": [96, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.finiteType_respectsIso", "code": "theorem finiteType_respectsIso : RingHom.RespectsIso @RingHom.FiniteType", "start": [99, 1], "end": [100, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean", "imports": ["Mathlib/RingTheory/LocalProperties.lean", "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.RespectsIso.basicOpen_iff", "code": "theorem RespectsIso.basicOpen_iff (hP : RespectsIso @P) {X Y : Scheme} [IsAffine X] [IsAffine Y]\n    (f : X \u27f6 Y) (r : Y.presheaf.obj (Opposite.op \u22a4)) :\n    P (Scheme.\u0393.map (f \u2223_ Y.basicOpen r).op) \u2194\n    P (@IsLocalization.Away.map (Y.presheaf.obj (Opposite.op \u22a4)) _\n      (Y.presheaf.obj (Opposite.op <| Y.basicOpen r)) _ _ (X.presheaf.obj (Opposite.op \u22a4)) _\n      (X.presheaf.obj (Opposite.op <| X.basicOpen (Scheme.\u0393.map f.op r))) _ _\n      (Scheme.\u0393.map f.op) r _ <| @isLocalization_away_of_isAffine X _ (Scheme.\u0393.map f.op r))", "start": [47, 1], "end": [69, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.RespectsIso.basicOpen_iff_localization", "code": "theorem RespectsIso.basicOpen_iff_localization (hP : RespectsIso @P) {X Y : Scheme} [IsAffine X]\n    [IsAffine Y] (f : X \u27f6 Y) (r : Y.presheaf.obj (Opposite.op \u22a4)) :\n    P (Scheme.\u0393.map (f \u2223_ Y.basicOpen r).op) \u2194 P (Localization.awayMap (Scheme.\u0393.map f.op) r)", "start": [72, 1], "end": [79, 37], "kind": "commanddeclaration"}, {"full_name": "RingHom.RespectsIso.ofRestrict_morphismRestrict_iff_of_isAffine", "code": "theorem RespectsIso.ofRestrict_morphismRestrict_iff_of_isAffine (hP : RingHom.RespectsIso @P)\n    {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X \u27f6 Y) (r : Y.presheaf.obj (Opposite.op \u22a4)) :\n    P (Scheme.\u0393.map (f \u2223_ Y.basicOpen r).op) \u2194\n    P (Localization.awayMap (Scheme.\u0393.map f.op) r)", "start": [84, 1], "end": [100, 62], "kind": "commanddeclaration"}, {"full_name": "RingHom.RespectsIso.ofRestrict_morphismRestrict_iff", "code": "theorem RespectsIso.ofRestrict_morphismRestrict_iff (hP : RingHom.RespectsIso @P) {X Y : Scheme}\n    [IsAffine Y] (f : X \u27f6 Y) (r : Y.presheaf.obj (Opposite.op \u22a4)) (U : Opens X.carrier)\n    (hU : IsAffineOpen U) {V : Opens _}\n    (e : V = (Scheme.\u03b9Opens <| f \u207b\u00b9\u1d41 Y.basicOpen r) \u207b\u00b9\u1d41 U) :\n    P (Scheme.\u0393.map (Scheme.\u03b9Opens V \u226b f \u2223_ Y.basicOpen r).op) \u2194\n    P (Localization.awayMap (Scheme.\u0393.map (Scheme.\u03b9Opens U \u226b f).op) r)", "start": [102, 1], "end": [118, 62], "kind": "commanddeclaration"}, {"full_name": "RingHom.StableUnderBaseChange.\u0393_pullback_fst", "code": "theorem StableUnderBaseChange.\u0393_pullback_fst (hP : StableUnderBaseChange @P) (hP' : RespectsIso @P)\n    {X Y S : Scheme} [IsAffine X] [IsAffine Y] [IsAffine S] (f : X \u27f6 S) (g : Y \u27f6 S)\n    (H : P (Scheme.\u0393.map g.op)) : P (Scheme.\u0393.map (pullback.fst : pullback f g \u27f6 _).op)", "start": [121, 1], "end": [139, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.sourceAffineLocally", "code": "def sourceAffineLocally : AffineTargetMorphismProperty := fun X _ f _ =>\n  \u2200 U : X.affineOpens, P (Scheme.\u0393.map (X.ofRestrict U.1.openEmbedding \u226b f).op)", "start": [146, 1], "end": [149, 80], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affineLocally", "code": "abbrev affineLocally : MorphismProperty Scheme :=\n  targetAffineLocally (sourceAffineLocally @P)", "start": [152, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.sourceAffineLocally_respectsIso", "code": "theorem sourceAffineLocally_respectsIso (h\u2081 : RingHom.RespectsIso @P) :\n    (sourceAffineLocally @P).toProperty.RespectsIso", "start": [161, 1], "end": [176, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affineLocally_respectsIso", "code": "theorem affineLocally_respectsIso (h : RingHom.RespectsIso @P) : (affineLocally @P).RespectsIso", "start": [179, 1], "end": [180, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affineLocally_iff_affineOpens_le", "code": "theorem affineLocally_iff_affineOpens_le (hP : RingHom.RespectsIso @P) {X Y : Scheme} (f : X \u27f6 Y) :\n    affineLocally (@P) f \u2194\n    \u2200 (U : Y.affineOpens) (V : X.affineOpens) (e : V.1 \u2264 (Opens.map f.1.base).obj U.1),\n      P (Scheme.Hom.appLe f e)", "start": [183, 1], "end": [221, 73], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.scheme_restrict_basicOpen_of_localizationPreserves", "code": "theorem scheme_restrict_basicOpen_of_localizationPreserves (h\u2081 : RingHom.RespectsIso @P)\n    (h\u2082 : RingHom.LocalizationPreserves @P) {X Y : Scheme} [IsAffine Y] (f : X \u27f6 Y)\n    (r : Y.presheaf.obj (op \u22a4)) (H : sourceAffineLocally (@P) f)\n    (U : (X.restrict ((Opens.map f.1.base).obj <| Y.basicOpen r).openEmbedding).affineOpens) :\n    P (Scheme.\u0393.map ((X.restrict ((Opens.map f.1.base).obj <|\n      Y.basicOpen r).openEmbedding).ofRestrict U.1.openEmbedding \u226b f \u2223_ Y.basicOpen r).op)", "start": [224, 1], "end": [237, 88], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.sourceAffineLocally_isLocal", "code": "theorem sourceAffineLocally_isLocal (h\u2081 : RingHom.RespectsIso @P)\n    (h\u2082 : RingHom.LocalizationPreserves @P) (h\u2083 : RingHom.OfLocalizationSpan @P) :\n    (sourceAffineLocally @P).IsLocal", "start": [241, 1], "end": [262, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.sourceAffineLocally_of_source_open_cover_aux", "code": "theorem sourceAffineLocally_of_source_open_cover_aux (h\u2081 : RingHom.RespectsIso @P)\n    (h\u2083 : RingHom.OfLocalizationSpanTarget @P) {X Y : Scheme} (f : X \u27f6 Y) (U : X.affineOpens)\n    (s : Set (X.presheaf.obj (op U.1))) (hs : Ideal.span s = \u22a4)\n    (hs' : \u2200 r : s, P (Scheme.\u0393.map (X.ofRestrict (X.basicOpen r.1).openEmbedding \u226b f).op)) :\n    P (Scheme.\u0393.map (X.ofRestrict U.1.openEmbedding \u226b f).op)", "start": [269, 1], "end": [309, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersionCat_comp_of_sourceAffineLocally", "code": "theorem isOpenImmersionCat_comp_of_sourceAffineLocally (h\u2081 : RingHom.RespectsIso @P)\n    {X Y Z : Scheme} [IsAffine X] [IsAffine Z] (f : X \u27f6 Y) [IsOpenImmersion f] (g : Y \u27f6 Z)\n    (h\u2082 : sourceAffineLocally (@P) g) : P (Scheme.\u0393.map (f \u226b g).op)", "start": [312, 1], "end": [320, 28], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.sourceAffineLocally_of_source_openCover", "code": "theorem sourceAffineLocally_of_source_openCover {X Y : Scheme} (f : X \u27f6 Y) [IsAffine Y]\n    (\ud835\udcb0 : X.OpenCover) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (H : \u2200 i, P (Scheme.\u0393.map (\ud835\udcb0.map i \u226b f).op)) :\n    sourceAffineLocally (@P) f", "start": [331, 1], "end": [389, 90], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.affine_openCover_TFAE", "code": "theorem affine_openCover_TFAE {X Y : Scheme.{u}} [IsAffine Y] (f : X \u27f6 Y) :\n    List.TFAE\n      [sourceAffineLocally (@P) f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} X) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, P (Scheme.\u0393.map (\ud835\udcb0.map i \u226b f).op),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} X) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          P (Scheme.\u0393.map (\ud835\udcb0.map i \u226b f).op),\n        \u2200 {U : Scheme} (g : U \u27f6 X) [IsAffine U] [IsOpenImmersion g],\n          P (Scheme.\u0393.map (g \u226b f).op)]", "start": [392, 1], "end": [417, 14], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.openCover_TFAE", "code": "theorem openCover_TFAE {X Y : Scheme.{u}} [IsAffine Y] (f : X \u27f6 Y) :\n    List.TFAE\n      [sourceAffineLocally (@P) f,\n        \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} X, \u2200 i : \ud835\udcb0.J, sourceAffineLocally (@P) (\ud835\udcb0.map i \u226b f),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} X) (i : \ud835\udcb0.J), sourceAffineLocally (@P) (\ud835\udcb0.map i \u226b f),\n        \u2200 {U : Scheme} (g : U \u27f6 X) [IsOpenImmersion g], sourceAffineLocally (@P) (g \u226b f)]", "start": [420, 1], "end": [460, 14], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.sourceAffineLocally_comp_of_isOpenImmersion", "code": "theorem sourceAffineLocally_comp_of_isOpenImmersion {X Y Z : Scheme.{u}} [IsAffine Z] (f : X \u27f6 Y)\n    (g : Y \u27f6 Z) [IsOpenImmersion f] (H : sourceAffineLocally (@P) g) :\n    sourceAffineLocally (@P) (f \u226b g)", "start": [463, 1], "end": [468, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.source_affine_openCover_iff", "code": "theorem source_affine_openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y) [IsAffine Y]\n    (\ud835\udcb0 : Scheme.OpenCover.{u} X) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] :\n    sourceAffineLocally (@P) f \u2194 \u2200 i, P (Scheme.\u0393.map (\ud835\udcb0.map i \u226b f).op)", "start": [471, 1], "end": [483, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.isLocal_sourceAffineLocally", "code": "theorem isLocal_sourceAffineLocally : (sourceAffineLocally @P).IsLocal", "start": [486, 1], "end": [488, 55], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.is_local_affineLocally", "code": "theorem is_local_affineLocally : PropertyIsLocalAtTarget (affineLocally @P)", "start": [491, 1], "end": [492, 60], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.affine_openCover_iff", "code": "theorem affine_openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (\ud835\udcb0' : \u2200 i, Scheme.OpenCover.{u} ((\ud835\udcb0.pullbackCover f).obj i))\n    [\u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)] :\n    affineLocally (@P) f \u2194 \u2200 i j, P (Scheme.\u0393.map ((\ud835\udcb0' i).map j \u226b pullback.snd).op)", "start": [495, 1], "end": [500, 69], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.source_openCover_iff", "code": "@[nolint unusedHavesSuffices]\ntheorem source_openCover_iff {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} X) :\n    affineLocally (@P) f \u2194 \u2200 i, affineLocally (@P) (\ud835\udcb0.map i \u226b f)", "start": [504, 1], "end": [530, 12], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.affineLocally_of_isOpenImmersion", "code": "theorem affineLocally_of_isOpenImmersion (hP : RingHom.PropertyIsLocal @P) {X Y : Scheme}\n    (f : X \u27f6 Y) [hf : IsOpenImmersion f] : affineLocally (@P) f", "start": [533, 1], "end": [556, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.affineLocally_of_comp", "code": "theorem affineLocally_of_comp\n    (H : \u2200 {R S T : Type u} [CommRing R] [CommRing S] [CommRing T],\n      \u2200 (f : R \u2192+* S) (g : S \u2192+* T), P (g.comp f) \u2192 P g)\n    {X Y Z : Scheme} {f : X \u27f6 Y} {g : Y \u27f6 Z} (h : affineLocally (@P) (f \u226b g)) :\n    affineLocally (@P) f", "start": [559, 1], "end": [595, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.affineLocally_stableUnderComposition", "code": "theorem affineLocally_stableUnderComposition : (affineLocally @P).StableUnderComposition", "start": [598, 1], "end": [638, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Compactification/OnePoint.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Data/Fintype/Option.lean", "Mathlib/Topology/Sets/Opens.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OnePoint", "code": "def OnePoint (X : Type*) :=\n  Option X", "start": [51, 1], "end": [53, 11], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infty", "code": "@[match_pattern] def infty : OnePoint X := none", "start": [65, 1], "end": [66, 48], "kind": "commanddeclaration"}, {"full_name": "OnePoint.some", "code": "@[coe, match_pattern] def some : X \u2192 OnePoint X := Option.some", "start": [72, 1], "end": [73, 63], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infinite", "code": "instance infinite [Infinite X] : Infinite (OnePoint X) :=\n  inferInstanceAs (Infinite (Option X))", "start": [82, 1], "end": [83, 40], "kind": "commanddeclaration"}, {"full_name": "OnePoint.coe_injective", "code": "theorem coe_injective : Function.Injective ((\u2191) : X \u2192 OnePoint X)", "start": [86, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "OnePoint.coe_eq_coe", "code": "@[norm_cast]\ntheorem coe_eq_coe {x y : X} : (x : OnePoint X) = y \u2194 x = y", "start": [90, 1], "end": [92, 23], "kind": "commanddeclaration"}, {"full_name": "OnePoint.coe_ne_infty", "code": "@[simp]\ntheorem coe_ne_infty (x : X) : (x : OnePoint X) \u2260 \u221e", "start": [95, 1], "end": [97, 7], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infty_ne_coe", "code": "@[simp]\ntheorem infty_ne_coe (x : X) : \u221e \u2260 (x : OnePoint X)", "start": [100, 1], "end": [102, 7], "kind": "commanddeclaration"}, {"full_name": "OnePoint.rec", "code": "@[elab_as_elim]\nprotected def rec {C : OnePoint X \u2192 Sort*} (h\u2081 : C \u221e) (h\u2082 : \u2200 x : X, C x) :\n    \u2200 z : OnePoint X, C z\n  | \u221e => h\u2081\n  | (x : X) => h\u2082 x", "start": [105, 1], "end": [110, 20], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isCompl_range_coe_infty", "code": "theorem isCompl_range_coe_infty : IsCompl (range ((\u2191) : X \u2192 OnePoint X)) {\u221e}", "start": [113, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "OnePoint.range_coe_union_infty", "code": "theorem range_coe_union_infty : range ((\u2191) : X \u2192 OnePoint X) \u222a {\u221e} = univ", "start": [118, 1], "end": [119, 26], "kind": "commanddeclaration"}, {"full_name": "OnePoint.insert_infty_range_coe", "code": "@[simp]\ntheorem insert_infty_range_coe : insert \u221e (range (@some X)) = univ", "start": [122, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "OnePoint.range_coe_inter_infty", "code": "@[simp]\ntheorem range_coe_inter_infty : range ((\u2191) : X \u2192 OnePoint X) \u2229 {\u221e} = \u2205", "start": [126, 1], "end": [128, 26], "kind": "commanddeclaration"}, {"full_name": "OnePoint.compl_range_coe", "code": "@[simp]\ntheorem compl_range_coe : (range ((\u2191) : X \u2192 OnePoint X))\u1d9c = {\u221e}", "start": [131, 1], "end": [133, 21], "kind": "commanddeclaration"}, {"full_name": "OnePoint.compl_infty", "code": "theorem compl_infty : ({\u221e}\u1d9c : Set (OnePoint X)) = range ((\u2191) : X \u2192 OnePoint X)", "start": [136, 1], "end": [137, 45], "kind": "commanddeclaration"}, {"full_name": "OnePoint.compl_image_coe", "code": "theorem compl_image_coe (s : Set X) : ((\u2191) '' s : Set (OnePoint X))\u1d9c = (\u2191) '' s\u1d9c \u222a {\u221e}", "start": [140, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "OnePoint.ne_infty_iff_exists", "code": "theorem ne_infty_iff_exists {x : OnePoint X} : x \u2260 \u221e \u2194 \u2203 y : X, (y : OnePoint X) = x", "start": [144, 1], "end": [145, 42], "kind": "commanddeclaration"}, {"full_name": "OnePoint.canLift", "code": "instance canLift : CanLift (OnePoint X) X (\u2191) fun x => x \u2260 \u221e :=\n  WithTop.canLift", "start": [148, 1], "end": [149, 18], "kind": "commanddeclaration"}, {"full_name": "OnePoint.not_mem_range_coe_iff", "code": "theorem not_mem_range_coe_iff {x : OnePoint X} : x \u2209 range some \u2194 x = \u221e", "start": [152, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infty_not_mem_range_coe", "code": "theorem infty_not_mem_range_coe : \u221e \u2209 range ((\u2191) : X \u2192 OnePoint X)", "start": [156, 1], "end": [157, 30], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infty_not_mem_image_coe", "code": "theorem infty_not_mem_image_coe {s : Set X} : \u221e \u2209 ((\u2191) : X \u2192 OnePoint X) '' s", "start": [160, 1], "end": [161, 66], "kind": "commanddeclaration"}, {"full_name": "OnePoint.coe_preimage_infty", "code": "@[simp]\ntheorem coe_preimage_infty : ((\u2191) : X \u2192 OnePoint X) \u207b\u00b9' {\u221e} = \u2205", "start": [164, 1], "end": [167, 7], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_def", "code": "theorem isOpen_def :\n    IsOpen s \u2194 (\u221e \u2208 s \u2192 IsCompact ((\u2191) \u207b\u00b9' s : Set X)\u1d9c) \u2227 IsOpen ((\u2191) \u207b\u00b9' s : Set X)", "start": [206, 1], "end": [208, 10], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_iff_of_mem'", "code": "theorem isOpen_iff_of_mem' (h : \u221e \u2208 s) :\n    IsOpen s \u2194 IsCompact ((\u2191) \u207b\u00b9' s : Set X)\u1d9c \u2227 IsOpen ((\u2191) \u207b\u00b9' s : Set X)", "start": [211, 1], "end": [213, 23], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_iff_of_mem", "code": "theorem isOpen_iff_of_mem (h : \u221e \u2208 s) :\n    IsOpen s \u2194 IsClosed ((\u2191) \u207b\u00b9' s : Set X)\u1d9c \u2227 IsCompact ((\u2191) \u207b\u00b9' s : Set X)\u1d9c", "start": [216, 1], "end": [218, 65], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_iff_of_not_mem", "code": "theorem isOpen_iff_of_not_mem (h : \u221e \u2209 s) : IsOpen s \u2194 IsOpen ((\u2191) \u207b\u00b9' s : Set X)", "start": [221, 1], "end": [222, 23], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isClosed_iff_of_mem", "code": "theorem isClosed_iff_of_mem (h : \u221e \u2208 s) : IsClosed s \u2194 IsClosed ((\u2191) \u207b\u00b9' s : Set X)", "start": [225, 1], "end": [227, 90], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isClosed_iff_of_not_mem", "code": "theorem isClosed_iff_of_not_mem (h : \u221e \u2209 s) :\n    IsClosed s \u2194 IsClosed ((\u2191) \u207b\u00b9' s : Set X) \u2227 IsCompact ((\u2191) \u207b\u00b9' s : Set X)", "start": [230, 1], "end": [232, 90], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_image_coe", "code": "@[simp]\ntheorem isOpen_image_coe {s : Set X} : IsOpen ((\u2191) '' s : Set (OnePoint X)) \u2194 IsOpen s", "start": [235, 1], "end": [237, 88], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_compl_image_coe", "code": "theorem isOpen_compl_image_coe {s : Set X} :\n    IsOpen ((\u2191) '' s : Set (OnePoint X))\u1d9c \u2194 IsClosed s \u2227 IsCompact s", "start": [240, 1], "end": [243, 32], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isClosed_image_coe", "code": "@[simp]\ntheorem isClosed_image_coe {s : Set X} :\n    IsClosed ((\u2191) '' s : Set (OnePoint X)) \u2194 IsClosed s \u2227 IsCompact s", "start": [246, 1], "end": [249, 50], "kind": "commanddeclaration"}, {"full_name": "OnePoint.opensOfCompl", "code": "def opensOfCompl (s : Set X) (h\u2081 : IsClosed s) (h\u2082 : IsCompact s) :\n    TopologicalSpace.Opens (OnePoint X) :=\n  \u27e8((\u2191) '' s)\u1d9c, isOpen_compl_image_coe.2 \u27e8h\u2081, h\u2082\u27e9\u27e9", "start": [252, 1], "end": [255, 51], "kind": "commanddeclaration"}, {"full_name": "OnePoint.infty_mem_opensOfCompl", "code": "theorem infty_mem_opensOfCompl {s : Set X} (h\u2081 : IsClosed s) (h\u2082 : IsCompact s) :\n    \u221e \u2208 opensOfCompl s h\u2081 h\u2082", "start": [258, 1], "end": [260, 36], "kind": "commanddeclaration"}, {"full_name": "OnePoint.continuous_coe", "code": "@[continuity]\ntheorem continuous_coe : Continuous ((\u2191) : X \u2192 OnePoint X)", "start": [263, 1], "end": [265, 43], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpenMap_coe", "code": "theorem isOpenMap_coe : IsOpenMap ((\u2191) : X \u2192 OnePoint X)", "start": [268, 1], "end": [268, 88], "kind": "commanddeclaration"}, {"full_name": "OnePoint.openEmbedding_coe", "code": "theorem openEmbedding_coe : OpenEmbedding ((\u2191) : X \u2192 OnePoint X)", "start": [271, 1], "end": [272, 88], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isOpen_range_coe", "code": "theorem isOpen_range_coe : IsOpen (range ((\u2191) : X \u2192 OnePoint X))", "start": [275, 1], "end": [276, 31], "kind": "commanddeclaration"}, {"full_name": "OnePoint.isClosed_infty", "code": "theorem isClosed_infty : IsClosed ({\u221e} : Set (OnePoint X))", "start": [279, 1], "end": [281, 25], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhds_coe_eq", "code": "theorem nhds_coe_eq (x : X) : \ud835\udcdd \u2191x = map ((\u2191) : X \u2192 OnePoint X) (\ud835\udcdd x)", "start": [284, 1], "end": [285, 41], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_coe_image", "code": "theorem nhdsWithin_coe_image (s : Set X) (x : X) :\n    \ud835\udcdd[(\u2191) '' s] (x : OnePoint X) = map (\u2191) (\ud835\udcdd[s] x)", "start": [288, 1], "end": [290, 61], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_coe", "code": "theorem nhdsWithin_coe (s : Set (OnePoint X)) (x : X) : \ud835\udcdd[s] \u2191x = map (\u2191) (\ud835\udcdd[(\u2191) \u207b\u00b9' s] x)", "start": [293, 1], "end": [294, 58], "kind": "commanddeclaration"}, {"full_name": "OnePoint.comap_coe_nhds", "code": "theorem comap_coe_nhds (x : X) : comap ((\u2191) : X \u2192 OnePoint X) (\ud835\udcdd x) = \ud835\udcdd x", "start": [297, 1], "end": [298, 54], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_compl_coe_neBot", "code": "instance nhdsWithin_compl_coe_neBot (x : X) [h : NeBot (\ud835\udcdd[\u2260] x)] :\n    NeBot (\ud835\udcdd[\u2260] (x : OnePoint X)) := by\n  simpa [nhdsWithin_coe, preimage, coe_eq_coe] using h.map some", "start": [301, 1], "end": [305, 64], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_compl_infty_eq", "code": "theorem nhdsWithin_compl_infty_eq : \ud835\udcdd[\u2260] (\u221e : OnePoint X) = map (\u2191) (coclosedCompact X)", "start": [308, 1], "end": [315, 61], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_compl_infty_neBot", "code": "instance nhdsWithin_compl_infty_neBot [NoncompactSpace X] : NeBot (\ud835\udcdd[\u2260] (\u221e : OnePoint X)) := by\n  rw [nhdsWithin_compl_infty_eq]\n  infer_instance", "start": [318, 1], "end": [321, 17], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhdsWithin_compl_neBot", "code": "instance (priority := 900) nhdsWithin_compl_neBot [\u2200 x : X, NeBot (\ud835\udcdd[\u2260] x)] [NoncompactSpace X]\n    (x : OnePoint X) : NeBot (\ud835\udcdd[\u2260] x) :=\n  OnePoint.rec OnePoint.nhdsWithin_compl_infty_neBot\n    (fun y => OnePoint.nhdsWithin_compl_coe_neBot y) x", "start": [324, 1], "end": [327, 55], "kind": "commanddeclaration"}, {"full_name": "OnePoint.nhds_infty_eq", "code": "theorem nhds_infty_eq : \ud835\udcdd (\u221e : OnePoint X) = map (\u2191) (coclosedCompact X) \u2294 pure \u221e", "start": [330, 1], "end": [331, 72], "kind": "commanddeclaration"}, {"full_name": "OnePoint.hasBasis_nhds_infty", "code": "theorem hasBasis_nhds_infty :\n    (\ud835\udcdd (\u221e : OnePoint X)).HasBasis (fun s : Set X => IsClosed s \u2227 IsCompact s) fun s =>\n      (\u2191) '' s\u1d9c \u222a {\u221e}", "start": [334, 1], "end": [338, 52], "kind": "commanddeclaration"}, {"full_name": "OnePoint.comap_coe_nhds_infty", "code": "@[simp]\ntheorem comap_coe_nhds_infty : comap ((\u2191) : X \u2192 OnePoint X) (\ud835\udcdd \u221e) = coclosedCompact X", "start": [341, 1], "end": [343, 59], "kind": "commanddeclaration"}, {"full_name": "OnePoint.le_nhds_infty", "code": "theorem le_nhds_infty {f : Filter (OnePoint X)} :\n    f \u2264 \ud835\udcdd \u221e \u2194 \u2200 s : Set X, IsClosed s \u2192 IsCompact s \u2192 (\u2191) '' s\u1d9c \u222a {\u221e} \u2208 f", "start": [346, 1], "end": [348, 50], "kind": "commanddeclaration"}, {"full_name": "OnePoint.ultrafilter_le_nhds_infty", "code": "theorem ultrafilter_le_nhds_infty {f : Ultrafilter (OnePoint X)} :\n    (f : Filter (OnePoint X)) \u2264 \ud835\udcdd \u221e \u2194 \u2200 s : Set X, IsClosed s \u2192 IsCompact s \u2192 (\u2191) '' s \u2209 f", "start": [351, 1], "end": [354, 39], "kind": "commanddeclaration"}, {"full_name": "OnePoint.tendsto_nhds_infty'", "code": "theorem tendsto_nhds_infty' {\u03b1 : Type*} {f : OnePoint X \u2192 \u03b1} {l : Filter \u03b1} :\n    Tendsto f (\ud835\udcdd \u221e) l \u2194 Tendsto f (pure \u221e) l \u2227 Tendsto (f \u2218 (\u2191)) (coclosedCompact X) l", "start": [357, 1], "end": [359, 33], "kind": "commanddeclaration"}, {"full_name": "OnePoint.tendsto_nhds_infty", "code": "theorem tendsto_nhds_infty {\u03b1 : Type*} {f : OnePoint X \u2192 \u03b1} {l : Filter \u03b1} :\n    Tendsto f (\ud835\udcdd \u221e) l \u2194\n      \u2200 s \u2208 l, f \u221e \u2208 s \u2227 \u2203 t : Set X, IsClosed t \u2227 IsCompact t \u2227 MapsTo (f \u2218 (\u2191)) t\u1d9c s", "start": [362, 1], "end": [367, 30], "kind": "commanddeclaration"}, {"full_name": "OnePoint.continuousAt_infty'", "code": "theorem continuousAt_infty' {Y : Type*} [TopologicalSpace Y] {f : OnePoint X \u2192 Y} :\n    ContinuousAt f \u221e \u2194 Tendsto (f \u2218 (\u2191)) (coclosedCompact X) (\ud835\udcdd (f \u221e))", "start": [370, 1], "end": [372, 69], "kind": "commanddeclaration"}, {"full_name": "OnePoint.continuousAt_infty", "code": "theorem continuousAt_infty {Y : Type*} [TopologicalSpace Y] {f : OnePoint X \u2192 Y} :\n    ContinuousAt f \u221e \u2194\n      \u2200 s \u2208 \ud835\udcdd (f \u221e), \u2203 t : Set X, IsClosed t \u2227 IsCompact t \u2227 MapsTo (f \u2218 (\u2191)) t\u1d9c s", "start": [375, 1], "end": [378, 99], "kind": "commanddeclaration"}, {"full_name": "OnePoint.continuousAt_coe", "code": "theorem continuousAt_coe {Y : Type*} [TopologicalSpace Y] {f : OnePoint X \u2192 Y} {x : X} :\n    ContinuousAt f x \u2194 ContinuousAt (f \u2218 (\u2191)) x", "start": [381, 1], "end": [383, 70], "kind": "commanddeclaration"}, {"full_name": "OnePoint.denseRange_coe", "code": "theorem denseRange_coe [NoncompactSpace X] : DenseRange ((\u2191) : X \u2192 OnePoint X)", "start": [386, 1], "end": [390, 32], "kind": "commanddeclaration"}, {"full_name": "OnePoint.denseEmbedding_coe", "code": "theorem denseEmbedding_coe [NoncompactSpace X] : DenseEmbedding ((\u2191) : X \u2192 OnePoint X)", "start": [393, 1], "end": [394, 53], "kind": "commanddeclaration"}, {"full_name": "OnePoint.specializes_coe", "code": "@[simp]\ntheorem specializes_coe {x y : X} : (x : OnePoint X) \u2933 y \u2194 x \u2933 y", "start": [397, 1], "end": [399, 47], "kind": "commanddeclaration"}, {"full_name": "OnePoint.inseparable_coe", "code": "@[simp]\ntheorem inseparable_coe {x y : X} : Inseparable (x : OnePoint X) y \u2194 Inseparable x y", "start": [402, 1], "end": [404, 47], "kind": "commanddeclaration"}, {"full_name": "OnePoint.not_specializes_infty_coe", "code": "theorem not_specializes_infty_coe {x : X} : \u00acSpecializes \u221e (x : OnePoint X)", "start": [407, 1], "end": [408, 54], "kind": "commanddeclaration"}, {"full_name": "OnePoint.not_inseparable_infty_coe", "code": "theorem not_inseparable_infty_coe {x : X} : \u00acInseparable \u221e (x : OnePoint X)", "start": [411, 1], "end": [412, 42], "kind": "commanddeclaration"}, {"full_name": "OnePoint.not_inseparable_coe_infty", "code": "theorem not_inseparable_coe_infty {x : X} : \u00acInseparable (x : OnePoint X) \u221e", "start": [415, 1], "end": [416, 43], "kind": "commanddeclaration"}, {"full_name": "OnePoint.inseparable_iff", "code": "theorem inseparable_iff {x y : OnePoint X} :\n    Inseparable x y \u2194 x = \u221e \u2227 y = \u221e \u2228 \u2203 x' : X, x = x' \u2227 \u2203 y' : X, y = y' \u2227 Inseparable x' y'", "start": [419, 1], "end": [422, 94], "kind": "commanddeclaration"}, {"full_name": "OnePoint.not_continuous_cofiniteTopology_of_symm", "code": "theorem not_continuous_cofiniteTopology_of_symm [Infinite X] [DiscreteTopology X] :\n    \u00acContinuous (@CofiniteTopology.of (OnePoint X)).symm", "start": [481, 1], "end": [489, 67], "kind": "commanddeclaration"}, {"full_name": "Continuous.homeoOfEquivCompactToT2.t1_counterexample", "code": "theorem Continuous.homeoOfEquivCompactToT2.t1_counterexample :\n    \u2203 (\u03b1 \u03b2 : Type) (_ : TopologicalSpace \u03b1) (_ : TopologicalSpace \u03b2),\n      CompactSpace \u03b1 \u2227 T1Space \u03b2 \u2227 \u2203 f : \u03b1 \u2243 \u03b2, Continuous f \u2227 \u00acContinuous f.symm", "start": [494, 1], "end": [506, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Matrix.lean", "imports": ["Mathlib/Analysis/NormedSpace/PiLp.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.seminormedAddCommGroup", "code": "protected def seminormedAddCommGroup : SeminormedAddCommGroup (Matrix m n \u03b1) :=\n  Pi.seminormedAddCommGroup", "start": [66, 1], "end": [70, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_def", "code": "theorem norm_def (A : Matrix m n \u03b1) : \u2016A\u2016 = \u2016fun i j => A i j\u2016", "start": [77, 1], "end": [77, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_def", "code": "theorem nnnorm_def (A : Matrix m n \u03b1) : \u2016A\u2016\u208a = \u2016fun i j => A i j\u2016\u208a", "start": [80, 1], "end": [80, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_le_iff", "code": "theorem norm_le_iff {r : \u211d} (hr : 0 \u2264 r) {A : Matrix m n \u03b1} : \u2016A\u2016 \u2264 r \u2194 \u2200 i j, \u2016A i j\u2016 \u2264 r", "start": [82, 1], "end": [83, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_le_iff", "code": "theorem nnnorm_le_iff {r : \u211d\u22650} {A : Matrix m n \u03b1} : \u2016A\u2016\u208a \u2264 r \u2194 \u2200 i j, \u2016A i j\u2016\u208a \u2264 r", "start": [86, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_lt_iff", "code": "theorem norm_lt_iff {r : \u211d} (hr : 0 < r) {A : Matrix m n \u03b1} : \u2016A\u2016 < r \u2194 \u2200 i j, \u2016A i j\u2016 < r", "start": [90, 1], "end": [91, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_lt_iff", "code": "theorem nnnorm_lt_iff {r : \u211d\u22650} (hr : 0 < r) {A : Matrix m n \u03b1} :\n    \u2016A\u2016\u208a < r \u2194 \u2200 i j, \u2016A i j\u2016\u208a < r", "start": [94, 1], "end": [96, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_entry_le_entrywise_sup_norm", "code": "theorem norm_entry_le_entrywise_sup_norm (A : Matrix m n \u03b1) {i : m} {j : n} : \u2016A i j\u2016 \u2264 \u2016A\u2016", "start": [99, 1], "end": [100, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_entry_le_entrywise_sup_nnnorm", "code": "theorem nnnorm_entry_le_entrywise_sup_nnnorm (A : Matrix m n \u03b1) {i : m} {j : n} : \u2016A i j\u2016\u208a \u2264 \u2016A\u2016\u208a", "start": [103, 1], "end": [104, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_map_eq", "code": "@[simp]\ntheorem nnnorm_map_eq (A : Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a, \u2016f a\u2016\u208a = \u2016a\u2016\u208a) :\n    \u2016A.map f\u2016\u208a = \u2016A\u2016\u208a", "start": [107, 1], "end": [110, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_map_eq", "code": "@[simp]\ntheorem norm_map_eq (A : Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a, \u2016f a\u2016 = \u2016a\u2016) : \u2016A.map f\u2016 = \u2016A\u2016", "start": [113, 1], "end": [115, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_transpose", "code": "@[simp]\ntheorem nnnorm_transpose (A : Matrix m n \u03b1) : \u2016A\u1d40\u2016\u208a = \u2016A\u2016\u208a", "start": [118, 1], "end": [120, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_transpose", "code": "@[simp]\ntheorem norm_transpose (A : Matrix m n \u03b1) : \u2016A\u1d40\u2016 = \u2016A\u2016", "start": [123, 1], "end": [125, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_conjTranspose", "code": "@[simp]\ntheorem nnnorm_conjTranspose [StarAddMonoid \u03b1] [NormedStarGroup \u03b1] (A : Matrix m n \u03b1) :\n    \u2016A\u1d34\u2016\u208a = \u2016A\u2016\u208a", "start": [128, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_conjTranspose", "code": "@[simp]\ntheorem norm_conjTranspose [StarAddMonoid \u03b1] [NormedStarGroup \u03b1] (A : Matrix m n \u03b1) : \u2016A\u1d34\u2016 = \u2016A\u2016", "start": [134, 1], "end": [136, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_col", "code": "@[simp]\ntheorem nnnorm_col (v : m \u2192 \u03b1) : \u2016col v\u2016\u208a = \u2016v\u2016\u208a", "start": [142, 1], "end": [144, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_col", "code": "@[simp]\ntheorem norm_col (v : m \u2192 \u03b1) : \u2016col v\u2016 = \u2016v\u2016", "start": [147, 1], "end": [149, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_row", "code": "@[simp]\ntheorem nnnorm_row (v : n \u2192 \u03b1) : \u2016row v\u2016\u208a = \u2016v\u2016\u208a", "start": [152, 1], "end": [154, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_row", "code": "@[simp]\ntheorem norm_row (v : n \u2192 \u03b1) : \u2016row v\u2016 = \u2016v\u2016", "start": [157, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.nnnorm_diagonal", "code": "@[simp]\ntheorem nnnorm_diagonal [DecidableEq n] (v : n \u2192 \u03b1) : \u2016diagonal v\u2016\u208a = \u2016v\u2016\u208a", "start": [162, 1], "end": [172, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.norm_diagonal", "code": "@[simp]\ntheorem norm_diagonal [DecidableEq n] (v : n \u2192 \u03b1) : \u2016diagonal v\u2016 = \u2016v\u2016", "start": [175, 1], "end": [177, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.normedAddCommGroup", "code": "protected def normedAddCommGroup [NormedAddCommGroup \u03b1] : NormedAddCommGroup (Matrix m n \u03b1) :=\n  Pi.normedAddCommGroup", "start": [187, 1], "end": [191, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.normedSpace", "code": "protected def normedSpace : NormedSpace R (Matrix m n \u03b1) :=\n  Pi.normedSpace", "start": [200, 1], "end": [204, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpSeminormedAddCommGroup", "code": "@[local instance]\nprotected def linftyOpSeminormedAddCommGroup [SeminormedAddCommGroup \u03b1] :\n    SeminormedAddCommGroup (Matrix m n \u03b1) :=\n  (by infer_instance : SeminormedAddCommGroup (m \u2192 PiLp 1 fun j : n => \u03b1))", "start": [222, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNormedAddCommGroup", "code": "@[local instance]\nprotected def linftyOpNormedAddCommGroup [NormedAddCommGroup \u03b1] :\n    NormedAddCommGroup (Matrix m n \u03b1) :=\n  (by infer_instance : NormedAddCommGroup (m \u2192 PiLp 1 fun j : n => \u03b1))", "start": [231, 1], "end": [237, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNormedSpace", "code": "@[local instance]\nprotected def linftyOpNormedSpace [NormedField R] [SeminormedAddCommGroup \u03b1] [NormedSpace R \u03b1] :\n    NormedSpace R (Matrix m n \u03b1) :=\n  (by infer_instance : NormedSpace R (m \u2192 PiLp 1 fun j : n => \u03b1))", "start": [240, 1], "end": [246, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_def", "code": "theorem linfty_op_norm_def (A : Matrix m n \u03b1) :\n    \u2016A\u2016 = ((Finset.univ : Finset m).sup fun i : m => \u2211 j : n, \u2016A i j\u2016\u208a : \u211d\u22650)", "start": [253, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_def", "code": "theorem linfty_op_nnnorm_def (A : Matrix m n \u03b1) :\n    \u2016A\u2016\u208a = (Finset.univ : Finset m).sup fun i : m => \u2211 j : n, \u2016A i j\u2016\u208a", "start": [260, 1], "end": [262, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_col", "code": "@[simp, nolint simpNF] theorem linfty_op_nnnorm_col (v : m \u2192 \u03b1) : \u2016col v\u2016\u208a = \u2016v\u2016\u208a", "start": [265, 1], "end": [268, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_col", "code": "@[simp]\ntheorem linfty_op_norm_col (v : m \u2192 \u03b1) : \u2016col v\u2016 = \u2016v\u2016", "start": [271, 1], "end": [273, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_row", "code": "@[simp]\ntheorem linfty_op_nnnorm_row (v : n \u2192 \u03b1) : \u2016row v\u2016\u208a = \u2211 i, \u2016v i\u2016\u208a", "start": [276, 1], "end": [277, 100], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_row", "code": "@[simp]\ntheorem linfty_op_norm_row (v : n \u2192 \u03b1) : \u2016row v\u2016 = \u2211 i, \u2016v i\u2016", "start": [280, 1], "end": [282, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_diagonal", "code": "@[simp]\ntheorem linfty_op_nnnorm_diagonal [DecidableEq m] (v : m \u2192 \u03b1) : \u2016diagonal v\u2016\u208a = \u2016v\u2016\u208a", "start": [285, 1], "end": [291, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_diagonal", "code": "@[simp]\ntheorem linfty_op_norm_diagonal [DecidableEq m] (v : m \u2192 \u03b1) : \u2016diagonal v\u2016 = \u2016v\u2016", "start": [294, 1], "end": [296, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_mul", "code": "theorem linfty_op_nnnorm_mul (A : Matrix l m \u03b1) (B : Matrix m n \u03b1) : \u2016A * B\u2016\u208a \u2264 \u2016A\u2016\u208a * \u2016B\u2016\u208a", "start": [306, 1], "end": [321, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_mul", "code": "theorem linfty_op_norm_mul (A : Matrix l m \u03b1) (B : Matrix m n \u03b1) : \u2016A * B\u2016 \u2264 \u2016A\u2016 * \u2016B\u2016", "start": [324, 1], "end": [325, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_nnnorm_mulVec", "code": "theorem linfty_op_nnnorm_mulVec (A : Matrix l m \u03b1) (v : m \u2192 \u03b1) : \u2016A.mulVec v\u2016\u208a \u2264 \u2016A\u2016\u208a * \u2016v\u2016\u208a", "start": [328, 1], "end": [330, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_norm_mulVec", "code": "theorem linfty_op_norm_mulVec (A : Matrix l m \u03b1) (v : m \u2192 \u03b1) : \u2016Matrix.mulVec A v\u2016 \u2264 \u2016A\u2016 * \u2016v\u2016", "start": [333, 1], "end": [334, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNonUnitalSemiNormedRing", "code": "@[local instance]\nprotected def linftyOpNonUnitalSemiNormedRing [NonUnitalSeminormedRing \u03b1] :\n    NonUnitalSeminormedRing (Matrix n n \u03b1) :=\n  { Matrix.linftyOpSeminormedAddCommGroup, Matrix.instNonUnitalRing with\n    norm_mul := linfty_op_norm_mul }", "start": [339, 1], "end": [346, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.linfty_op_normOneClass", "code": "instance linfty_op_normOneClass [SeminormedRing \u03b1] [NormOneClass \u03b1] [DecidableEq n] [Nonempty n] :\n    NormOneClass (Matrix n n \u03b1) where norm_one := (linfty_op_norm_diagonal _).trans norm_one", "start": [349, 1], "end": [352, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpSemiNormedRing", "code": "@[local instance]\nprotected def linftyOpSemiNormedRing [SeminormedRing \u03b1] [DecidableEq n] :\n    SeminormedRing (Matrix n n \u03b1) :=\n  { Matrix.linftyOpNonUnitalSemiNormedRing, Matrix.instRing with }", "start": [355, 1], "end": [361, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNonUnitalNormedRing", "code": "@[local instance]\nprotected def linftyOpNonUnitalNormedRing [NonUnitalNormedRing \u03b1] :\n    NonUnitalNormedRing (Matrix n n \u03b1) :=\n  { Matrix.linftyOpNonUnitalSemiNormedRing with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [364, 1], "end": [371, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNormedRing", "code": "@[local instance]\nprotected def linftyOpNormedRing [NormedRing \u03b1] [DecidableEq n] : NormedRing (Matrix n n \u03b1) :=\n  { Matrix.linftyOpSemiNormedRing with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [374, 1], "end": [380, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.linftyOpNormedAlgebra", "code": "@[local instance]\nprotected def linftyOpNormedAlgebra [NormedField R] [SeminormedRing \u03b1] [NormedAlgebra R \u03b1]\n    [DecidableEq n] : NormedAlgebra R (Matrix n n \u03b1) :=\n  { Matrix.linftyOpNormedSpace, Matrix.instAlgebra with }", "start": [383, 1], "end": [389, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobeniusSeminormedAddCommGroup", "code": "@[local instance]\ndef frobeniusSeminormedAddCommGroup [SeminormedAddCommGroup \u03b1] :\n    SeminormedAddCommGroup (Matrix m n \u03b1) :=\n  inferInstanceAs (SeminormedAddCommGroup (PiLp 2 fun _i : m => PiLp 2 fun _j : n => \u03b1))", "start": [405, 1], "end": [411, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobeniusNormedAddCommGroup", "code": "@[local instance]\ndef frobeniusNormedAddCommGroup [NormedAddCommGroup \u03b1] : NormedAddCommGroup (Matrix m n \u03b1) :=\n  (by infer_instance : NormedAddCommGroup (PiLp 2 fun i : m => PiLp 2 fun j : n => \u03b1))", "start": [414, 1], "end": [419, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobeniusNormedSpace", "code": "@[local instance]\ndef frobeniusNormedSpace [NormedField R] [SeminormedAddCommGroup \u03b1] [NormedSpace R \u03b1] :\n    NormedSpace R (Matrix m n \u03b1) :=\n  (by infer_instance : NormedSpace R (PiLp 2 fun i : m => PiLp 2 fun j : n => \u03b1))", "start": [422, 1], "end": [428, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_def", "code": "theorem frobenius_nnnorm_def (A : Matrix m n \u03b1) :\n    \u2016A\u2016\u208a = (\u2211 i, \u2211 j, \u2016A i j\u2016\u208a ^ (2 : \u211d)) ^ (1 / 2 : \u211d)", "start": [435, 1], "end": [440, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_def", "code": "theorem frobenius_norm_def (A : Matrix m n \u03b1) :\n    \u2016A\u2016 = (\u2211 i, \u2211 j, \u2016A i j\u2016 ^ (2 : \u211d)) ^ (1 / 2 : \u211d)", "start": [443, 1], "end": [445, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_map_eq", "code": "@[simp]\ntheorem frobenius_nnnorm_map_eq (A : Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a, \u2016f a\u2016\u208a = \u2016a\u2016\u208a) :\n    \u2016A.map f\u2016\u208a = \u2016A\u2016\u208a", "start": [448, 1], "end": [450, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_map_eq", "code": "@[simp]\ntheorem frobenius_norm_map_eq (A : Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a, \u2016f a\u2016 = \u2016a\u2016) :\n    \u2016A.map f\u2016 = \u2016A\u2016", "start": [453, 1], "end": [456, 94], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_transpose", "code": "@[simp]\ntheorem frobenius_nnnorm_transpose (A : Matrix m n \u03b1) : \u2016A\u1d40\u2016\u208a = \u2016A\u2016\u208a", "start": [459, 1], "end": [462, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_transpose", "code": "@[simp]\ntheorem frobenius_norm_transpose (A : Matrix m n \u03b1) : \u2016A\u1d40\u2016 = \u2016A\u2016", "start": [465, 1], "end": [467, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_conjTranspose", "code": "@[simp]\ntheorem frobenius_nnnorm_conjTranspose [StarAddMonoid \u03b1] [NormedStarGroup \u03b1] (A : Matrix m n \u03b1) :\n    \u2016A\u1d34\u2016\u208a = \u2016A\u2016\u208a", "start": [470, 1], "end": [473, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_conjTranspose", "code": "@[simp]\ntheorem frobenius_norm_conjTranspose [StarAddMonoid \u03b1] [NormedStarGroup \u03b1] (A : Matrix m n \u03b1) :\n    \u2016A\u1d34\u2016 = \u2016A\u2016", "start": [476, 1], "end": [479, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_normedStarGroup", "code": "instance frobenius_normedStarGroup [StarAddMonoid \u03b1] [NormedStarGroup \u03b1] :\n    NormedStarGroup (Matrix m m \u03b1) :=\n  \u27e8frobenius_norm_conjTranspose\u27e9", "start": [482, 1], "end": [484, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_row", "code": "@[simp]\ntheorem frobenius_norm_row (v : m \u2192 \u03b1) : \u2016row v\u2016 = \u2016(WithLp.equiv 2 _).symm v\u2016", "start": [487, 1], "end": [490, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_row", "code": "@[simp]\ntheorem frobenius_nnnorm_row (v : m \u2192 \u03b1) : \u2016row v\u2016\u208a = \u2016(WithLp.equiv 2 _).symm v\u2016\u208a", "start": [493, 1], "end": [495, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_col", "code": "@[simp]\ntheorem frobenius_norm_col (v : n \u2192 \u03b1) : \u2016col v\u2016 = \u2016(WithLp.equiv 2 _).symm v\u2016", "start": [498, 1], "end": [501, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_col", "code": "@[simp]\ntheorem frobenius_nnnorm_col (v : n \u2192 \u03b1) : \u2016col v\u2016\u208a = \u2016(WithLp.equiv 2 _).symm v\u2016\u208a", "start": [504, 1], "end": [506, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_diagonal", "code": "@[simp]\ntheorem frobenius_nnnorm_diagonal [DecidableEq n] (v : n \u2192 \u03b1) :\n    \u2016diagonal v\u2016\u208a = \u2016(WithLp.equiv 2 _).symm v\u2016\u208a", "start": [509, 1], "end": [521, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_diagonal", "code": "@[simp]\ntheorem frobenius_norm_diagonal [DecidableEq n] (v : n \u2192 \u03b1) :\n    \u2016diagonal v\u2016 = \u2016(WithLp.equiv 2 _).symm v\u2016", "start": [524, 1], "end": [527, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_one", "code": "theorem frobenius_nnnorm_one [DecidableEq n] [SeminormedAddCommGroup \u03b1] [One \u03b1] :\n    \u2016(1 : Matrix n n \u03b1)\u2016\u208a = NNReal.sqrt (Fintype.card n) * \u2016(1 : \u03b1)\u2016\u208a", "start": [532, 1], "end": [539, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_nnnorm_mul", "code": "theorem frobenius_nnnorm_mul (A : Matrix l m \u03b1) (B : Matrix m n \u03b1) : \u2016A * B\u2016\u208a \u2264 \u2016A\u2016\u208a * \u2016B\u2016\u208a", "start": [546, 1], "end": [559, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobenius_norm_mul", "code": "theorem frobenius_norm_mul (A : Matrix l m \u03b1) (B : Matrix m n \u03b1) : \u2016A * B\u2016 \u2264 \u2016A\u2016 * \u2016B\u2016", "start": [562, 1], "end": [563, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobeniusNormedRing", "code": "@[local instance]\ndef frobeniusNormedRing [DecidableEq m] : NormedRing (Matrix m m \u03b1) :=\n  { Matrix.frobeniusSeminormedAddCommGroup, Matrix.instRing with\n    norm := Norm.norm\n    norm_mul := frobenius_norm_mul\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [566, 1], "end": [574, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.frobeniusNormedAlgebra", "code": "@[local instance]\ndef frobeniusNormedAlgebra [DecidableEq m] [NormedField R] [NormedAlgebra R \u03b1] :\n    NormedAlgebra R (Matrix m m \u03b1) :=\n  { Matrix.frobeniusNormedSpace, Matrix.instAlgebra with }", "start": [577, 1], "end": [583, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ModularForms/SlashInvariantForms.lean", "imports": ["Mathlib/NumberTheory/ModularForms/SlashActions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SlashInvariantForm", "code": "structure SlashInvariantForm where\n  toFun : \u210d \u2192 \u2102\n  slash_action_eq' : \u2200 \u03b3 : \u0393, toFun \u2223[k] \u03b3 = toFun", "start": [41, 1], "end": [44, 51], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantFormClass", "code": "class SlashInvariantFormClass extends FunLike F \u210d fun _ => \u2102 where\n  slash_action_eq : \u2200 (f : F) (\u03b3 : \u0393), (f : \u210d \u2192 \u2102) \u2223[k] \u03b3 = f", "start": [47, 1], "end": [50, 62], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantFormClass.slashInvariantForm", "code": "instance (priority := 100) SlashInvariantFormClass.slashInvariantForm :\n    SlashInvariantFormClass (SlashInvariantForm \u0393 k) \u0393 k where\n  coe := SlashInvariantForm.toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  slash_action_eq := SlashInvariantForm.slash_action_eq'", "start": [53, 1], "end": [57, 57], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.toFun_eq_coe", "code": "@[simp]\ntheorem SlashInvariantForm.toFun_eq_coe {f : SlashInvariantForm \u0393 k} : f.toFun = (f : \u210d \u2192 \u2102)", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_mk", "code": "@[simp]\ntheorem SlashInvariantForm.coe_mk (f : \u210d \u2192 \u2102) (hf : \u2200 \u03b3 : \u0393, f \u2223[k] \u03b3 = f) : \u21d1(mk f hf) = f", "start": [70, 1], "end": [71, 99], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.ext", "code": "@[ext]\ntheorem SlashInvariantForm.ext {f g : SlashInvariantForm \u0393 k} (h : \u2200 x, f x = g x) : f = g", "start": [73, 1], "end": [75, 20], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.copy", "code": "protected def SlashInvariantForm.copy (f : SlashInvariantForm \u0393 k) (f' : \u210d \u2192 \u2102) (h : f' = \u21d1f) :\n    SlashInvariantForm \u0393 k where\n  toFun := f'\n  slash_action_eq' := h.symm \u25b8 f.slash_action_eq'", "start": [78, 1], "end": [83, 50], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.SlashInvariantFormClass.coeToFun", "code": "instance (priority := 100) SlashInvariantFormClass.coeToFun [SlashInvariantFormClass F \u0393 k] :\n    CoeFun F fun _ => \u210d \u2192 \u2102 :=\n  FunLike.hasCoeToFun", "start": [94, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.slash_action_eqn", "code": "theorem slash_action_eqn [SlashInvariantFormClass F \u0393 k] (f : F) (\u03b3 : \u0393) : \u2191f \u2223[k] \u03b3 = \u21d1f", "start": [100, 1], "end": [101, 46], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.slash_action_eqn'", "code": "theorem slash_action_eqn' (k : \u2124) (\u0393 : Subgroup SL(2, \u2124)) [SlashInvariantFormClass F \u0393 k] (f : F)\n    (\u03b3 : \u0393) (z : \u210d) : f (\u03b3 \u2022 z) = ((\u2191\u2098[\u2124] \u03b3 1 0 : \u2102) * z + (\u2191\u2098[\u2124] \u03b3 1 1 : \u2102)) ^ k * f z", "start": [104, 1], "end": [106, 60], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.SlashInvariantFormClass.coe_coe", "code": "@[simp]\ntheorem SlashInvariantFormClass.coe_coe [SlashInvariantFormClass F \u0393 k] (f : F) :\n    ((f : SlashInvariantForm \u0393 k) : \u210d \u2192 \u2102) = f", "start": [114, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.instAdd", "code": "instance instAdd : Add (SlashInvariantForm \u0393 k) :=\n  \u27e8fun f g =>\n    { toFun := f + g\n      slash_action_eq' := fun \u03b3 => by\n        rw [SlashAction.add_slash, slash_action_eqn, slash_action_eqn] }\u27e9", "start": [120, 1], "end": [124, 74], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_add", "code": "@[simp]\ntheorem coe_add (f g : SlashInvariantForm \u0393 k) : \u21d1(f + g) = f + g", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.add_apply", "code": "@[simp]\ntheorem add_apply (f g : SlashInvariantForm \u0393 k) (z : \u210d) : (f + g) z = f z + g z", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.instZero", "code": "instance instZero : Zero (SlashInvariantForm \u0393 k) :=\n  \u27e8{toFun := 0\n    slash_action_eq' := SlashAction.zero_slash _}\u27e9", "start": [137, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : SlashInvariantForm \u0393 k) = (0 : \u210d \u2192 \u2102)", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.instSMul", "code": "instance instSMul : SMul \u03b1 (SlashInvariantForm \u0393 k) :=\n  \u27e8fun c f =>\n    { toFun := c \u2022 \u2191f\n      slash_action_eq' := fun \u03b3 => by rw [SlashAction.smul_slash_of_tower, slash_action_eqn] }\u27e9", "start": [151, 1], "end": [154, 96], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_smul", "code": "@[simp]\ntheorem coe_smul (f : SlashInvariantForm \u0393 k) (n : \u03b1) : \u21d1(n \u2022 f) = n \u2022 \u21d1f", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.smul_apply", "code": "@[simp]\ntheorem smul_apply (f : SlashInvariantForm \u0393 k) (n : \u03b1) (z : \u210d) : (n \u2022 f) z = n \u2022 f z", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.instNeg", "code": "instance instNeg : Neg (SlashInvariantForm \u0393 k) :=\n  \u27e8fun f =>\n    { toFun := -f\n      slash_action_eq' := fun \u03b3 => by rw [SlashAction.neg_slash, slash_action_eqn] }\u27e9", "start": [169, 1], "end": [172, 86], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_neg", "code": "@[simp]\ntheorem coe_neg (f : SlashInvariantForm \u0393 k) : \u21d1(-f) = -f", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : SlashInvariantForm \u0393 k) (z : \u210d) : (-f) z = -f z", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.instSub", "code": "instance instSub : Sub (SlashInvariantForm \u0393 k) :=\n  \u27e8fun f g => f + -g\u27e9", "start": [185, 1], "end": [186, 22], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_sub", "code": "@[simp]\ntheorem coe_sub (f g : SlashInvariantForm \u0393 k) : \u21d1(f - g) = f - g", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : SlashInvariantForm \u0393 k) (z : \u210d) : (f - g) z = f z - g z", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coeHom", "code": "def coeHom : SlashInvariantForm \u0393 k \u2192+ \u210d \u2192 \u2102 where\n  toFun f := f\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [202, 1], "end": [206, 22], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coeHom_injective", "code": "theorem coeHom_injective : Function.Injective (@coeHom \u0393 k)", "start": [209, 1], "end": [210, 24], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.one_coe_eq_one", "code": "@[simp]\ntheorem one_coe_eq_one : ((1 : SlashInvariantForm \u0393 0) : \u210d \u2192 \u2102) = 1", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.mul", "code": "def mul {k\u2081 k\u2082 : \u2124} {\u0393 : Subgroup SL(2, \u2124)} (f : SlashInvariantForm \u0393 k\u2081)\n    (g : SlashInvariantForm \u0393 k\u2082) : SlashInvariantForm \u0393 (k\u2081 + k\u2082) where\n  toFun := f * g\n  slash_action_eq' A := by\n    simp_rw [ModularForm.mul_slash_subgroup, SlashInvariantFormClass.slash_action_eq]", "start": [228, 1], "end": [234, 86], "kind": "commanddeclaration"}, {"full_name": "SlashInvariantForm.coe_mul", "code": "@[simp]\ntheorem coe_mul {k\u2081 k\u2082 : \u2124} {\u0393 : Subgroup SL(2, \u2124)} (f : SlashInvariantForm \u0393 k\u2081)\n    (g : SlashInvariantForm \u0393 k\u2082) : \u21d1(f.mul g) = \u21d1f * \u21d1g", "start": [236, 1], "end": [239, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/UpperHalfPlane/Manifold.lean", "imports": ["Mathlib/Geometry/Manifold/MFDeriv.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UpperHalfPlane.smooth_coe", "code": "theorem smooth_coe : Smooth \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) ((\u2191) : \u210d \u2192 \u2102)", "start": [28, 1], "end": [29, 87], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.mdifferentiable_coe", "code": "theorem mdifferentiable_coe : MDifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) ((\u2191) : \u210d \u2192 \u2102)", "start": [32, 1], "end": [34, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Semigroup.lean", "imports": ["Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "exists_idempotent_of_compact_t2_of_continuous_mul_left", "code": "@[to_additive\n      \"Any nonempty compact Hausdorff additive semigroup where right-addition is continuous\n      contains an idempotent, i.e. an `m` such that `m + m = m`\"]\ntheorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M]\n    [TopologicalSpace M] [CompactSpace M] [T2Space M]\n    (continuous_mul_left : \u2200 r : M, Continuous (\u00b7 * r)) : \u2203 m : M, m * m = m", "start": [23, 1], "end": [74, 97], "kind": "commanddeclaration"}, {"full_name": "exists_idempotent_in_compact_subsemigroup", "code": "@[to_additive exists_idempotent_in_compact_add_subsemigroup\n      \"A version of\n      `exists_idempotent_of_compact_t2_of_continuous_add_left` where the idempotent lies in\n      some specified nonempty compact additive subsemigroup.\"]\ntheorem exists_idempotent_in_compact_subsemigroup {M} [Semigroup M] [TopologicalSpace M] [T2Space M]\n    (continuous_mul_left : \u2200 r : M, Continuous (\u00b7 * r)) (s : Set M) (snemp : s.Nonempty)\n    (s_compact : IsCompact s) (s_add : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x * y \u2208 s) :\n    \u2203 m \u2208 s, m * m = m", "start": [80, 1], "end": [99, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/WellFounded.lean", "imports": ["Mathlib/Order/Antisymmetrization.lean", "Mathlib/Data/DFinsupp/Lex.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/SetTheory/Ordinal/Basic.lean", "Mathlib/Order/GameAdd.lean"], "premises": [{"full_name": "DFinsupp.lex_fibration", "code": "theorem lex_fibration [\u2200 (i) (s : Set \u03b9), Decidable (i \u2208 s)] :\n    Fibration (InvImage (GameAdd (DFinsupp.Lex r s) (DFinsupp.Lex r s)) snd) (DFinsupp.Lex r s)\n      fun x => piecewise x.2.1 x.2.2 x.1", "start": [60, 1], "end": [97, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.acc_of_single_erase", "code": "theorem Lex.acc_of_single_erase [DecidableEq \u03b9] {x : \u03a0\u2080 i, \u03b1 i} (i : \u03b9)\n    (hs : Acc (DFinsupp.Lex r s) <| single i (x i)) (hu : Acc (DFinsupp.Lex r s) <| x.erase i) :\n    Acc (DFinsupp.Lex r s) x", "start": [102, 1], "end": [108, 39], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.acc_zero", "code": "theorem Lex.acc_zero : Acc (DFinsupp.Lex r s) 0", "start": [113, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.acc_of_single", "code": "theorem Lex.acc_of_single [DecidableEq \u03b9] [\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)] (x : \u03a0\u2080 i, \u03b1 i) :\n    (\u2200 i \u2208 x.support, Acc (DFinsupp.Lex r s) <| single i (x i)) \u2192 Acc (DFinsupp.Lex r s) x", "start": [117, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.acc_single", "code": "theorem Lex.acc_single [DecidableEq \u03b9] {i : \u03b9} (hi : Acc (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) i) :\n    \u2200 a, Acc (DFinsupp.Lex r s) (single i a)", "start": [133, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.acc", "code": "theorem Lex.acc [DecidableEq \u03b9] [\u2200 (i) (x : \u03b1 i), Decidable (x \u2260 0)] (x : \u03a0\u2080 i, \u03b1 i)\n    (h : \u2200 i \u2208 x.support, Acc (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) i) : Acc (DFinsupp.Lex r s) x", "start": [155, 1], "end": [157, 73], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.wellFounded", "code": "theorem Lex.wellFounded (hr : WellFounded <| r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) : WellFounded (DFinsupp.Lex r s)", "start": [160, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.wellFounded'", "code": "theorem Lex.wellFounded' [IsTrichotomous \u03b9 r] (hr : WellFounded (Function.swap r)) :\n    WellFounded (DFinsupp.Lex r s)", "start": [164, 1], "end": [167, 100], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.wellFoundedLT", "code": "instance Lex.wellFoundedLT [LT \u03b9] [IsTrichotomous \u03b9 (\u00b7 < \u00b7)] [h\u03b9 : WellFoundedGT \u03b9]\n    [\u2200 i, CanonicallyOrderedAddCommMonoid (\u03b1 i)] [h\u03b1 : \u2200 i, WellFoundedLT (\u03b1 i)] :\n    WellFoundedLT (Lex (\u03a0\u2080 i, \u03b1 i)) :=\n  \u27e8Lex.wellFounded' (fun _ a => (zero_le a).not_lt) (fun i => (h\u03b1 i).wf) h\u03b9.wf\u27e9", "start": [172, 1], "end": [175, 80], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.wellFounded", "code": "theorem Pi.Lex.wellFounded [IsStrictTotalOrder \u03b9 r] [Finite \u03b9] (hs : \u2200 i, WellFounded (s i)) :\n    WellFounded (Pi.Lex r (fun {i} \u21a6 s i))", "start": [184, 1], "end": [191, 98], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.wellFoundedLT", "code": "instance Pi.Lex.wellFoundedLT [LinearOrder \u03b9] [Finite \u03b9] [\u2200 i, LT (\u03b1 i)]\n    [hwf : \u2200 i, WellFoundedLT (\u03b1 i)] : WellFoundedLT (Lex (\u2200 i, \u03b1 i)) :=\n  \u27e8Pi.Lex.wellFounded (\u00b7 < \u00b7) fun i => (hwf i).1\u27e9", "start": [194, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "Function.Lex.wellFoundedLT", "code": "instance Function.Lex.wellFoundedLT {\u03b1} [LinearOrder \u03b9] [Finite \u03b9] [LT \u03b1] [WellFoundedLT \u03b1] :\n    WellFoundedLT (Lex (\u03b9 \u2192 \u03b1)) :=\n  Pi.Lex.wellFoundedLT", "start": [199, 1], "end": [201, 23], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.wellFounded_of_finite", "code": "theorem DFinsupp.Lex.wellFounded_of_finite [IsStrictTotalOrder \u03b9 r] [Finite \u03b9] [\u2200 i, Zero (\u03b1 i)]\n    (hs : \u2200 i, WellFounded (s i)) : WellFounded (DFinsupp.Lex r s)", "start": [204, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.wellFoundedLT_of_finite", "code": "instance DFinsupp.Lex.wellFoundedLT_of_finite [LinearOrder \u03b9] [Finite \u03b9] [\u2200 i, Zero (\u03b1 i)]\n    [\u2200 i, LT (\u03b1 i)] [hwf : \u2200 i, WellFoundedLT (\u03b1 i)] : WellFoundedLT (Lex (\u03a0\u2080 i, \u03b1 i)) :=\n  \u27e8DFinsupp.Lex.wellFounded_of_finite (\u00b7 < \u00b7) fun i => (hwf i).1\u27e9", "start": [210, 1], "end": [212, 66], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.wellFoundedLT", "code": "protected theorem DFinsupp.wellFoundedLT [\u2200 i, Zero (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, WellFoundedLT (\u03b1 i)] (hbot : \u2200 \u2983i\u2984 \u2983a : \u03b1 i\u2984, \u00aca < 0) : WellFoundedLT (\u03a0\u2080 i, \u03b1 i)", "start": [215, 1], "end": [232, 52], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.wellFoundedLT'", "code": "instance DFinsupp.wellFoundedLT' [\u2200 i, CanonicallyOrderedAddCommMonoid (\u03b1 i)]\n    [\u2200 i, WellFoundedLT (\u03b1 i)] : WellFoundedLT (\u03a0\u2080 i, \u03b1 i) :=\n  DFinsupp.wellFoundedLT fun _i a => (zero_le a).not_lt", "start": [235, 1], "end": [237, 56], "kind": "commanddeclaration"}, {"full_name": "Pi.wellFoundedLT", "code": "instance Pi.wellFoundedLT [Finite \u03b9] [\u2200 i, Preorder (\u03b1 i)] [hw : \u2200 i, WellFoundedLT (\u03b1 i)] :\n    WellFoundedLT (\u2200 i, \u03b1 i) :=\n  \u27e8by\n    obtain h | \u27e8\u27e8x\u27e9\u27e9 := isEmpty_or_nonempty (\u2200 i, \u03b1 i)\n    \u00b7 convert emptyWf.wf\n    letI : \u2200 i, Zero (\u03b1 i) := fun i => \u27e8(hw i).wf.min \u22a4 \u27e8x i, trivial\u27e9\u27e9\n    haveI := Fintype.ofFinite \u03b9\n    refine' InvImage.wf equivFunOnFintype.symm (DFinsupp.wellFoundedLT fun i a => _).wf\n    exact (hw i).wf.not_lt_min \u22a4 _ trivial\u27e9", "start": [240, 1], "end": [248, 44], "kind": "commanddeclaration"}, {"full_name": "Function.wellFoundedLT", "code": "instance Function.wellFoundedLT {\u03b1} [Finite \u03b9] [Preorder \u03b1] [WellFoundedLT \u03b1] :\n    WellFoundedLT (\u03b9 \u2192 \u03b1) :=\n  Pi.wellFoundedLT", "start": [251, 1], "end": [253, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.wellFoundedLT_of_finite", "code": "instance DFinsupp.wellFoundedLT_of_finite [Finite \u03b9] [\u2200 i, Zero (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, WellFoundedLT (\u03b1 i)] : WellFoundedLT (\u03a0\u2080 i, \u03b1 i) :=\n  have := Fintype.ofFinite \u03b9\n  \u27e8InvImage.wf equivFunOnFintype Pi.wellFoundedLT.wf\u27e9", "start": [256, 1], "end": [259, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/DegreeSum.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Data/ZMod/Parity.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "SimpleGraph.dart_fst_fiber", "code": "theorem dart_fst_fiber [DecidableEq V] (v : V) :\n    (univ.filter fun d : G.Dart => d.fst = v) = univ.image (G.dartOfNeighborSet v)", "start": [58, 1], "end": [66, 8], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dart_fst_fiber_card_eq_degree", "code": "theorem dart_fst_fiber_card_eq_degree [DecidableEq V] (v : V) :\n    (univ.filter fun d : G.Dart => d.fst = v).card = G.degree v", "start": [69, 1], "end": [72, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dart_card_eq_sum_degrees", "code": "theorem dart_card_eq_sum_degrees : Fintype.card G.Dart = \u2211 v, G.degree v", "start": [75, 1], "end": [78, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Dart.edge_fiber", "code": "theorem Dart.edge_fiber (d : G.Dart) :\n    (univ.filter fun d' : G.Dart => d'.edge = d.edge) = {d, d.symm}", "start": [83, 1], "end": [85, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dart_edge_fiber_card", "code": "theorem dart_edge_fiber_card (e : Sym2 V) (h : e \u2208 G.edgeSet) :\n    (univ.filter fun d : G.Dart => d.edge = e).card = 2", "start": [90, 1], "end": [97, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dart_card_eq_twice_card_edges", "code": "theorem dart_card_eq_twice_card_edges : Fintype.card G.Dart = 2 * G.edgeFinset.card", "start": [100, 1], "end": [107, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.sum_degrees_eq_twice_card_edges", "code": "theorem sum_degrees_eq_twice_card_edges : \u2211 v, G.degree v = 2 * G.edgeFinset.card", "start": [110, 1], "end": [113, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.even_card_odd_degree_vertices", "code": "theorem even_card_odd_degree_vertices [Fintype V] [DecidableRel G.Adj] :\n    Even (univ.filter fun v => Odd (G.degree v)).card", "start": [118, 1], "end": [133, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.odd_card_odd_degree_vertices_ne", "code": "theorem odd_card_odd_degree_vertices_ne [Fintype V] [DecidableEq V] [DecidableRel G.Adj] (v : V)\n    (h : Odd (G.degree v)) : Odd (univ.filter fun w => w \u2260 v \u2227 Odd (G.degree w)).card", "start": [136, 1], "end": [155, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.exists_ne_odd_degree_of_exists_odd_degree", "code": "theorem exists_ne_odd_degree_of_exists_odd_degree [Fintype V] [DecidableRel G.Adj] (v : V)\n    (h : Odd (G.degree v)) : \u2203 w : V, w \u2260 v \u2227 Odd (G.degree w)", "start": [158, 1], "end": [167, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean", "imports": ["Mathlib/Topology/ContinuousFunction/StoneWeierstrass.lean", "Mathlib/Topology/ContinuousFunction/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Analysis/NormedSpace/Algebra.lean", "Mathlib/Analysis/NormedSpace/Star/Spectrum.lean", "Mathlib/Analysis/Normed/Group/Quotient.lean", "Mathlib/Topology/ContinuousFunction/Compact.lean"], "premises": [{"full_name": "Ideal.toCharacterSpace", "code": "noncomputable def Ideal.toCharacterSpace : characterSpace \u2102 A :=\n  CharacterSpace.equivAlgHom.symm <|\n    ((NormedRing.algEquivComplexOfComplete\n      (letI := Quotient.field I; isUnit_iff_ne_zero (G\u2080 := A \u29f8 I))).symm : A \u29f8 I \u2192\u2090[\u2102] \u2102).comp <|\n    Quotient.mk\u2090 \u2102 I", "start": [71, 1], "end": [79, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.toCharacterSpace_apply_eq_zero_of_mem", "code": "theorem Ideal.toCharacterSpace_apply_eq_zero_of_mem {a : A} (ha : a \u2208 I) :\n    I.toCharacterSpace a = 0", "start": [82, 1], "end": [88, 74], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.exists_apply_eq_zero", "code": "theorem WeakDual.CharacterSpace.exists_apply_eq_zero {a : A} (ha : \u00acIsUnit a) :\n    \u2203 f : characterSpace \u2102 A, f a = 0", "start": [91, 1], "end": [99, 62], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.mem_spectrum_iff_exists", "code": "theorem WeakDual.CharacterSpace.mem_spectrum_iff_exists {a : A} {z : \u2102} :\n    z \u2208 spectrum \u2102 a \u2194 \u2203 f : characterSpace \u2102 A, f a = z", "start": [102, 1], "end": [112, 40], "kind": "commanddeclaration"}, {"full_name": "spectrum.gelfandTransform_eq", "code": "theorem spectrum.gelfandTransform_eq (a : A) :\n    spectrum \u2102 (gelfandTransform \u2102 A a) = spectrum \u2102 a", "start": [115, 1], "end": [120, 16], "kind": "commanddeclaration"}, {"full_name": "gelfandTransform_map_star", "code": "theorem gelfandTransform_map_star (a : A) :\n    gelfandTransform \u2102 A (star a) = star (gelfandTransform \u2102 A a)", "start": [135, 1], "end": [137, 42], "kind": "commanddeclaration"}, {"full_name": "gelfandTransform_isometry", "code": "theorem gelfandTransform_isometry : Isometry (gelfandTransform \u2102 A)", "start": [142, 1], "end": [156, 52], "kind": "commanddeclaration"}, {"full_name": "gelfandTransform_bijective", "code": "theorem gelfandTransform_bijective : Function.Bijective (gelfandTransform \u2102 A)", "start": [159, 1], "end": [188, 72], "kind": "commanddeclaration"}, {"full_name": "gelfandStarTransform", "code": "@[simps!]\nnoncomputable def gelfandStarTransform : A \u2243\u22c6\u2090[\u2102] C(characterSpace \u2102 A, \u2102) :=\n  StarAlgEquiv.ofBijective\n    (show A \u2192\u22c6\u2090[\u2102] C(characterSpace \u2102 A, \u2102) from\n      { gelfandTransform \u2102 A with map_star' := fun x => gelfandTransform_map_star x })\n    (gelfandTransform_bijective A)", "start": [191, 1], "end": [198, 35], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.compContinuousMap", "code": "@[simps]\nnoncomputable def compContinuousMap (\u03c8 : A \u2192\u22c6\u2090[\u2102] B) : C(characterSpace \u2102 B, characterSpace \u2102 A)\n    where\n  toFun \u03c6 := equivAlgHom.symm ((equivAlgHom \u03c6).comp \u03c8.toAlgHom)\n  continuous_toFun :=\n    Continuous.subtype_mk\n      (continuous_of_continuous_eval fun a => map_continuous <| gelfandTransform \u2102 B (\u03c8 a)) _", "start": [217, 1], "end": [225, 94], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.compContinuousMap_id", "code": "@[simp]\ntheorem compContinuousMap_id :\n    compContinuousMap (StarAlgHom.id \u2102 A) = ContinuousMap.id (characterSpace \u2102 A)", "start": [230, 1], "end": [234, 48], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.compContinuousMap_comp", "code": "@[simp]\ntheorem compContinuousMap_comp (\u03c8\u2082 : B \u2192\u22c6\u2090[\u2102] C) (\u03c8\u2081 : A \u2192\u22c6\u2090[\u2102] B) :\n    compContinuousMap (\u03c8\u2082.comp \u03c8\u2081) = (compContinuousMap \u03c8\u2081).comp (compContinuousMap \u03c8\u2082)", "start": [239, 1], "end": [243, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/RelSeries.lean", "imports": ["Mathlib/Data/Rel.lean", "Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Data/List/Indexes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RelSeries", "code": "structure RelSeries where\n  \n  length : \u2115\n  \n  toFun : Fin (length + 1) \u2192 \u03b1\n  \n  step : \u2200 (i : Fin length), r (toFun (Fin.castSucc i)) (toFun i.succ)", "start": [20, 1], "end": [30, 71], "kind": "commanddeclaration"}, {"full_name": "RelSeries.singleton", "code": "@[simps!] def singleton (a : \u03b1) : RelSeries r where\n  length := 0\n  toFun _ := a\n  step := Fin.elim0", "start": [37, 1], "end": [43, 20], "kind": "commanddeclaration"}, {"full_name": "RelSeries.ext", "code": "@[ext]\nlemma ext {x y : RelSeries r} (length_eq : x.length = y.length)\n    (toFun_eq : x.toFun = y.toFun \u2218 Fin.cast (by rw [length_eq])) : x = y := by\n  rcases x with \u27e8nx, fx\u27e9\n  dsimp only at length_eq toFun_eq\n  subst length_eq toFun_eq\n  rfl", "start": [56, 1], "end": [62, 6], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.rel_of_lt", "code": "lemma rel_of_lt [IsTrans \u03b1 r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i < j) :\n    r (x i) (x j) :=\n  (Fin.liftFun_iff_succ r).mpr x.step h", "start": [64, 1], "end": [66, 40], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.rel_or_eq_of_le", "code": "lemma rel_or_eq_of_le [IsTrans \u03b1 r] (x : RelSeries r) {i j : Fin (x.length + 1)} (h : i \u2264 j) :\n    r (x i) (x j) \u2228 x i = x j :=\n  h.lt_or_eq.imp (x.rel_of_lt \u00b7) (by rw [\u00b7])", "start": [68, 1], "end": [70, 45], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.ofLE", "code": "@[simps!]\ndef ofLE (x : RelSeries r) {s : Rel \u03b1 \u03b1} (h : r \u2264 s) : RelSeries s where\n  length := x.length\n  toFun := x\n  step _ := h _ _ <| x.step _", "start": [72, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "RelSeries.coe_ofLE", "code": "lemma coe_ofLE (x : RelSeries r) {s : Rel \u03b1 \u03b1} (h : r \u2264 s) :\n    (x.ofLE h : _ \u2192 _) = x := rfl", "start": [82, 1], "end": [83, 34], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.toList", "code": "abbrev toList (x : RelSeries r) : List \u03b1 := List.ofFn x", "start": [85, 1], "end": [86, 56], "kind": "commanddeclaration"}, {"full_name": "RelSeries.toList_chain'", "code": "lemma toList_chain' (x : RelSeries r) : x.toList.Chain' r := by\n  rw [List.chain'_iff_get]\n  intros i h\n  convert x.step \u27e8i, by simpa using h\u27e9 <;> apply List.get_ofFn", "start": [88, 1], "end": [91, 63], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.toList_ne_empty", "code": "lemma toList_ne_empty (x : RelSeries r) : x.toList \u2260 [] := fun m =>\n  List.eq_nil_iff_forall_not_mem.mp m (x 0) <| (List.mem_ofFn _ _).mpr \u27e8_, rfl\u27e9", "start": [93, 1], "end": [94, 80], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.fromListChain'", "code": "@[simps]\ndef fromListChain' (x : List \u03b1) (x_ne_empty : x \u2260 []) (hx : x.Chain' r) : RelSeries r where\n  length := x.length.pred\n  toFun := x.get \u2218 Fin.cast (Nat.succ_pred_eq_of_pos <| List.length_pos.mpr x_ne_empty)\n  step i := List.chain'_iff_get.mp hx i i.2", "start": [96, 1], "end": [101, 44], "kind": "commanddeclaration"}, {"full_name": "RelSeries.Equiv", "code": "protected def Equiv : RelSeries r \u2243 {x : List \u03b1 | x \u2260 [] \u2227 x.Chain' r} where\n  toFun x := \u27e8_, x.toList_ne_empty, x.toList_chain'\u27e9\n  invFun x := fromListChain' _ x.2.1 x.2.2\n  left_inv x := ext (by simp) <| by ext; apply List.get_ofFn\n  right_inv x := by\n    refine Subtype.ext (List.ext_get ?_ <| fun n hn1 _ => List.get_ofFn _ _)\n    simp [Nat.succ_pred_eq_of_pos <| List.length_pos.mpr x.2.1]", "start": [103, 1], "end": [111, 64], "kind": "commanddeclaration"}, {"full_name": "Rel.FiniteDimensional", "code": "class FiniteDimensional : Prop where\n  \n  exists_longest_relSeries : \u2203 (x : RelSeries r), \u2200 (y : RelSeries r), y.length \u2264 x.length", "start": [119, 1], "end": [124, 91], "kind": "commanddeclaration"}, {"full_name": "Rel.InfiniteDimensional", "code": "class InfiniteDimensional : Prop where\n  \n  exists_relSeries_with_length : \u2200 (n : \u2115), \u2203 (x : RelSeries r), x.length = n", "start": [126, 1], "end": [131, 78], "kind": "commanddeclaration"}, {"full_name": "RelSeries.longestOf", "code": "protected noncomputable def longestOf [r.FiniteDimensional] : RelSeries r :=\n  Rel.FiniteDimensional.exists_longest_relSeries.choose", "start": [137, 1], "end": [139, 56], "kind": "commanddeclaration"}, {"full_name": "RelSeries.length_le_length_longestOf", "code": "lemma length_le_length_longestOf [r.FiniteDimensional] (x : RelSeries r) :\n    x.length \u2264 (RelSeries.longestOf r).length :=\n  Rel.FiniteDimensional.exists_longest_relSeries.choose_spec _", "start": [141, 1], "end": [143, 63], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.withLength", "code": "protected noncomputable def withLength [r.InfiniteDimensional] (n : \u2115) : RelSeries r :=\n  (Rel.InfiniteDimensional.exists_relSeries_with_length n).choose", "start": [145, 1], "end": [147, 66], "kind": "commanddeclaration"}, {"full_name": "RelSeries.length_withLength", "code": "@[simp] lemma length_withLength [r.InfiniteDimensional] (n : \u2115) :\n    (RelSeries.withLength r n).length = n :=\n  (Rel.InfiniteDimensional.exists_relSeries_with_length n).choose_spec", "start": [149, 1], "end": [151, 71], "kind": "mathlibtacticlemma"}, {"full_name": "RelSeries.nonempty_of_infiniteDimensional", "code": "lemma nonempty_of_infiniteDimensional [r.InfiniteDimensional] : Nonempty \u03b1 :=\n  \u27e8RelSeries.withLength r 0 0\u27e9", "start": [153, 1], "end": [155, 31], "kind": "mathlibtacticlemma"}, {"full_name": "FiniteDimensionalOrder", "code": "abbrev FiniteDimensionalOrder (\u03b3 : Type*) [Preorder \u03b3] :=\n  Rel.FiniteDimensional ((. < .) : \u03b3 \u2192 \u03b3 \u2192 Prop)", "start": [159, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "InfiniteDimensionalOrder", "code": "abbrev InfiniteDimensionalOrder (\u03b3 : Type*) [Preorder \u03b3] :=\n  Rel.InfiniteDimensional ((. < .) : \u03b3 \u2192 \u03b3 \u2192 Prop)", "start": [163, 1], "end": [165, 51], "kind": "commanddeclaration"}, {"full_name": "LTSeries", "code": "abbrev LTSeries := RelSeries ((. < .) : Rel \u03b1 \u03b1)", "start": [170, 1], "end": [173, 49], "kind": "commanddeclaration"}, {"full_name": "LTSeries.longestOf", "code": "protected noncomputable def longestOf [FiniteDimensionalOrder \u03b1] : LTSeries \u03b1 :=\n  RelSeries.longestOf _", "start": [177, 1], "end": [179, 24], "kind": "commanddeclaration"}, {"full_name": "LTSeries.withLength", "code": "protected noncomputable def withLength [InfiniteDimensionalOrder \u03b1] (n : \u2115) : LTSeries \u03b1 :=\n  RelSeries.withLength _ n", "start": [181, 1], "end": [183, 27], "kind": "commanddeclaration"}, {"full_name": "LTSeries.length_withLength", "code": "@[simp] lemma length_withLength [InfiniteDimensionalOrder \u03b1] (n : \u2115) :\n    (LTSeries.withLength \u03b1 n).length = n :=\n  RelSeries.length_withLength _ _", "start": [185, 1], "end": [187, 34], "kind": "mathlibtacticlemma"}, {"full_name": "LTSeries.nonempty_of_infiniteDimensionalType", "code": "lemma nonempty_of_infiniteDimensionalType [InfiniteDimensionalOrder \u03b1] : Nonempty \u03b1 :=\n  \u27e8LTSeries.withLength \u03b1 0 0\u27e9", "start": [189, 1], "end": [191, 30], "kind": "mathlibtacticlemma"}, {"full_name": "LTSeries.longestOf_is_longest", "code": "lemma longestOf_is_longest [FiniteDimensionalOrder \u03b1] (x : LTSeries \u03b1) :\n    x.length \u2264 (LTSeries.longestOf \u03b1).length :=\n  RelSeries.length_le_length_longestOf _ _", "start": [195, 1], "end": [197, 43], "kind": "mathlibtacticlemma"}, {"full_name": "LTSeries.longestOf_len_unique", "code": "lemma longestOf_len_unique [FiniteDimensionalOrder \u03b1] (p : LTSeries \u03b1)\n    (is_longest : \u2200 (q : LTSeries \u03b1), q.length \u2264 p.length) :\n    p.length = (LTSeries.longestOf \u03b1).length :=\n  le_antisymm (longestOf_is_longest _) (is_longest _)", "start": [199, 1], "end": [202, 54], "kind": "mathlibtacticlemma"}, {"full_name": "LTSeries.strictMono", "code": "lemma strictMono (x : LTSeries \u03b1) : StrictMono x :=\n  fun _ _ h => x.rel_of_lt h", "start": [205, 1], "end": [206, 29], "kind": "mathlibtacticlemma"}, {"full_name": "LTSeries.monotone", "code": "lemma monotone (x : LTSeries \u03b1) : Monotone x :=\n  x.strictMono.monotone", "start": [208, 1], "end": [209, 24], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean", "imports": ["Mathlib/Data/Nat/Factorial/DoubleFactorial.lean", "Mathlib/Data/Polynomial/Derivative.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.hermite", "code": "noncomputable def hermite : \u2115 \u2192 Polynomial \u2124\n  | 0 => 1\n  | n + 1 => X * hermite n - derivative (hermite n)", "start": [47, 1], "end": [50, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_succ", "code": "@[simp]\ntheorem hermite_succ (n : \u2115) : hermite (n + 1) = X * hermite n - derivative (hermite n)", "start": [53, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_eq_iterate", "code": "theorem hermite_eq_iterate (n : \u2115) : hermite n = (fun p => X * p - derivative p)^[n] 1", "start": [59, 1], "end": [62, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_zero", "code": "@[simp]\ntheorem hermite_zero : hermite 0 = C 1", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_one", "code": "theorem hermite_one : hermite 1 = X", "start": [72, 1], "end": [74, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_succ_zero", "code": "theorem coeff_hermite_succ_zero (n : \u2115) : coeff (hermite (n + 1)) 0 = -coeff (hermite n) 1", "start": [82, 1], "end": [83, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_succ_succ", "code": "theorem coeff_hermite_succ_succ (n k : \u2115) : coeff (hermite (n + 1)) (k + 1) =\n    coeff (hermite n) k - (k + 2) * coeff (hermite n) (k + 2)", "start": [86, 1], "end": [89, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_of_lt", "code": "theorem coeff_hermite_of_lt {n k : \u2115} (hnk : n < k) : coeff (hermite n) k = 0", "start": [92, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_self", "code": "@[simp]\ntheorem coeff_hermite_self (n : \u2115) : coeff (hermite n) n = 1", "start": [102, 1], "end": [107, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_hermite", "code": "@[simp]\ntheorem degree_hermite (n : \u2115) : (hermite n).degree = n", "start": [110, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_hermite", "code": "@[simp]\ntheorem natDegree_hermite {n : \u2115} : (hermite n).natDegree = n", "start": [119, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_hermite", "code": "@[simp]\ntheorem leadingCoeff_hermite (n : \u2115) : (hermite n).leadingCoeff = 1", "start": [124, 1], "end": [126, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hermite_monic", "code": "theorem hermite_monic (n : \u2115) : (hermite n).Monic", "start": [129, 1], "end": [130, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_of_odd_add", "code": "theorem coeff_hermite_of_odd_add {n k : \u2115} (hnk : Odd (n + k)) : coeff (hermite n) k = 0", "start": [133, 1], "end": [143, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_explicit", "code": "theorem coeff_hermite_explicit :\n    \u2200 n k : \u2115, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)\u203c * Nat.choose (2 * n + k) k", "start": [152, 1], "end": [202, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite_of_even_add", "code": "theorem coeff_hermite_of_even_add {n k : \u2115} (hnk : Even (n + k)) :\n    coeff (hermite n) k = (-1) ^ ((n - k) / 2) * (n - k - 1)\u203c * Nat.choose n k", "start": [205, 1], "end": [213, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_hermite", "code": "theorem coeff_hermite (n k : \u2115) :\n    coeff (hermite n) k =\n      if Even (n + k) then (-1 : \u2124) ^ ((n - k) / 2) * (n - k - 1)\u203c * Nat.choose n k else 0", "start": [216, 1], "end": [221, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/ReesAlgebra.lean", "imports": ["Mathlib/RingTheory/FiniteType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "reesAlgebra", "code": "def reesAlgebra : Subalgebra R R[X] where\n  carrier := { f | \u2200 i, f.coeff i \u2208 I ^ i }\n  mul_mem' hf hg i := by\n    rw [coeff_mul]\n    apply Ideal.sum_mem\n    rintro \u27e8j, k\u27e9 e\n    rw [\u2190 Finset.Nat.mem_antidiagonal.mp e, pow_add]\n    exact Ideal.mul_mem_mul (hf j) (hg k)\n  one_mem' i := by\n    rw [coeff_one]\n    split_ifs with h\n    \u00b7 subst h\n      simp\n    \u00b7 simp\n  add_mem' hf hg i := by\n    rw [coeff_add]\n    exact Ideal.add_mem _ (hf i) (hg i)\n  zero_mem' i := Ideal.zero_mem _\n  algebraMap_mem' r i := by\n    rw [algebraMap_apply, coeff_C]\n    split_ifs with h\n    \u00b7 subst h\n      simp\n    \u00b7 simp", "start": [36, 1], "end": [61, 11], "kind": "commanddeclaration"}, {"full_name": "mem_reesAlgebra_iff", "code": "theorem mem_reesAlgebra_iff (f : R[X]) : f \u2208 reesAlgebra I \u2194 \u2200 i, f.coeff i \u2208 I ^ i", "start": [64, 1], "end": [65, 10], "kind": "commanddeclaration"}, {"full_name": "mem_reesAlgebra_iff_support", "code": "theorem mem_reesAlgebra_iff_support (f : R[X]) :\n    f \u2208 reesAlgebra I \u2194 \u2200 i \u2208 f.support, f.coeff i \u2208 I ^ i", "start": [68, 1], "end": [73, 43], "kind": "commanddeclaration"}, {"full_name": "reesAlgebra.monomial_mem", "code": "theorem reesAlgebra.monomial_mem {I : Ideal R} {i : \u2115} {r : R} :\n    monomial i r \u2208 reesAlgebra I \u2194 r \u2208 I ^ i", "start": [76, 1], "end": [79, 20], "kind": "commanddeclaration"}, {"full_name": "monomial_mem_adjoin_monomial", "code": "theorem monomial_mem_adjoin_monomial {I : Ideal R} {n : \u2115} {r : R} (hr : r \u2208 I ^ n) :\n    monomial n r \u2208 Algebra.adjoin R (Submodule.map (monomial 1 : R \u2192\u2097[R] R[X]) I : Set R[X])", "start": [82, 1], "end": [95, 39], "kind": "commanddeclaration"}, {"full_name": "adjoin_monomial_eq_reesAlgebra", "code": "theorem adjoin_monomial_eq_reesAlgebra :\n    Algebra.adjoin R (Submodule.map (monomial 1 : R \u2192\u2097[R] R[X]) I : Set R[X]) = reesAlgebra I", "start": [98, 1], "end": [108, 46], "kind": "commanddeclaration"}, {"full_name": "reesAlgebra.fg", "code": "theorem reesAlgebra.fg (hI : I.FG) : (reesAlgebra I).FG", "start": [113, 1], "end": [123, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Module.lean", "imports": ["Mathlib/RingTheory/FiniteType.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PolynomialModule", "code": "@[nolint unusedArguments]\ndef PolynomialModule (R M : Type*) [CommRing R] [AddCommGroup M] [Module R M] := \u2115 \u2192\u2080 M", "start": [29, 1], "end": [48, 88], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.funLike", "code": "instance funLike : FunLike (PolynomialModule R M) \u2115 fun _ => M :=\n  Finsupp.funLike", "start": [68, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.zero_apply", "code": "theorem zero_apply (i : \u2115) : (0 : PolynomialModule R M) i = 0", "start": [74, 1], "end": [75, 21], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.add_apply", "code": "theorem add_apply (g\u2081 g\u2082 : PolynomialModule R M) (a : \u2115) : (g\u2081 + g\u2082) a = g\u2081 a + g\u2082 a", "start": [77, 1], "end": [78, 28], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.single", "code": "noncomputable def single (i : \u2115) : M \u2192+ PolynomialModule R M :=\n  Finsupp.singleAddHom i", "start": [80, 1], "end": [83, 25], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.single_apply", "code": "theorem single_apply (i : \u2115) (m : M) (n : \u2115) : single R i m n = ite (i = n) m 0", "start": [86, 1], "end": [87, 23], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.lsingle", "code": "noncomputable def lsingle (i : \u2115) : M \u2192\u2097[R] PolynomialModule R M :=\n  Finsupp.lsingle i", "start": [90, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.lsingle_apply", "code": "theorem lsingle_apply (i : \u2115) (m : M) (n : \u2115) : lsingle R i m n = ite (i = n) m 0", "start": [95, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.single_smul", "code": "theorem single_smul (i : \u2115) (r : R) (m : M) : single R i (r \u2022 m) = r \u2022 single R i m", "start": [99, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.induction_linear", "code": "theorem induction_linear {P : PolynomialModule R M \u2192 Prop} (f : PolynomialModule R M) (h0 : P 0)\n    (hadd : \u2200 f g, P f \u2192 P g \u2192 P (f + g)) (hsingle : \u2200 a b, P (single R a b)) : P f", "start": [105, 1], "end": [107, 45], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.polynomialModule", "code": "@[semireducible]\nnoncomputable instance polynomialModule : Module R[X] (PolynomialModule R M) :=\n  modulePolynomialOfEndo (Finsupp.lmapDomain _ _ Nat.succ)", "start": [110, 1], "end": [112, 59], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.isScalarTower'", "code": "instance isScalarTower' (M : Type u) [AddCommGroup M] [Module R M] [Module S M]\n    [IsScalarTower S R M] : IsScalarTower S R[X] (PolynomialModule R M) := by\n  haveI : IsScalarTower R R[X] (PolynomialModule R M) := modulePolynomialOfEndo.isScalarTower _\n  constructor\n  intro x y z\n  rw [\u2190 @IsScalarTower.algebraMap_smul S R, \u2190 @IsScalarTower.algebraMap_smul S R, smul_assoc]", "start": [119, 1], "end": [124, 94], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.monomial_smul_single", "code": "@[simp]\ntheorem monomial_smul_single (i : \u2115) (r : R) (j : \u2115) (m : M) :\n    monomial i r \u2022 single R j m = single R (i + j) (r \u2022 m)", "start": [127, 1], "end": [140, 35], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.monomial_smul_apply", "code": "@[simp]\ntheorem monomial_smul_apply (i : \u2115) (r : R) (g : PolynomialModule R M) (n : \u2115) :\n    (monomial i r \u2022 g) n = ite (i \u2264 n) (r \u2022 g (n - i)) 0", "start": [143, 1], "end": [158, 45], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.smul_single_apply", "code": "@[simp]\ntheorem smul_single_apply (i : \u2115) (f : R[X]) (m : M) (n : \u2115) :\n    (f \u2022 single R i m) n = ite (i \u2264 n) (f.coeff (n - i) \u2022 m) 0", "start": [161, 1], "end": [174, 15], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.smul_apply", "code": "theorem smul_apply (f : R[X]) (g : PolynomialModule R M) (n : \u2115) :\n    (f \u2022 g) n = \u2211 x in Finset.Nat.antidiagonal n, f.coeff x.1 \u2022 g x.2", "start": [177, 1], "end": [191, 39], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.equivPolynomialSelf", "code": "noncomputable def equivPolynomialSelf : PolynomialModule R R \u2243\u2097[R[X]] R[X] :=\n  { (Polynomial.toFinsuppIso R).symm with\n    map_smul' := fun r x => by\n      dsimp\n      rw [\u2190 RingEquiv.coe_toEquiv_symm, RingEquiv.coe_toEquiv]\n      induction' x using induction_linear with _ _ hp hq n a\n      \u00b7 rw [smul_zero, map_zero, mul_zero]\n      \u00b7 rw [smul_add, map_add, map_add, mul_add, hp, hq]\n      \u00b7 ext i\n        simp only [coeff_ofFinsupp, smul_single_apply, toFinsuppIso_symm_apply, coeff_ofFinsupp,\n        single_apply, ge_iff_le, smul_eq_mul, Polynomial.coeff_mul, mul_ite, mul_zero]\n        split_ifs with hn\n        \u00b7 rw [Finset.sum_eq_single (i - n, n)]\n          simp only [ite_true]\n          \u00b7 rintro \u27e8p, q\u27e9 hpq1 hpq2\n            rw [Finset.Nat.mem_antidiagonal] at hpq1\n            split_ifs with H\n            \u00b7 dsimp at H\n              exfalso\n              apply hpq2\n              rw [\u2190hpq1, H]\n              simp only [add_le_iff_nonpos_left, nonpos_iff_eq_zero, add_tsub_cancel_right]\n            \u00b7 rfl\n          \u00b7 intro H\n            exfalso\n            apply H\n            rw [Finset.Nat.mem_antidiagonal, tsub_add_cancel_of_le hn]\n        \u00b7 symm\n          rw [Finset.sum_ite_of_false, Finset.sum_const_zero]\n          simp_rw [Finset.Nat.mem_antidiagonal]\n          intro x hx\n          contrapose! hn\n          rw [add_comm, \u2190 hn] at hx\n          exact Nat.le.intro hx }", "start": [194, 1], "end": [228, 34], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.equivPolynomial", "code": "noncomputable def equivPolynomial {S : Type*} [CommRing S] [Algebra R S] :\n    PolynomialModule R S \u2243\u2097[R] S[X] :=\n  { (Polynomial.toFinsuppIso S).symm with map_smul' := fun _ _ => rfl }", "start": [231, 1], "end": [234, 72], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.map", "code": "noncomputable def map (f : M \u2192\u2097[R] M') : PolynomialModule R M \u2192\u2097[R] PolynomialModule R' M' :=\n  Finsupp.mapRange.linearMap f", "start": [241, 1], "end": [243, 31], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.map_single", "code": "@[simp]\ntheorem map_single (f : M \u2192\u2097[R] M') (i : \u2115) (m : M) : map R' f (single R i m) = single R' i (f m)", "start": [246, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.map_smul", "code": "theorem map_smul (f : M \u2192\u2097[R] M') (p : R[X]) (q : PolynomialModule R M) :\n    map R' f (p \u2022 q) = p.map (algebraMap R R') \u2022 map R' f q", "start": [251, 1], "end": [261, 35], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval", "code": "@[simps! (config := .lemmasOnly)]\ndef eval (r : R) : PolynomialModule R M \u2192\u2097[R] M where\n  toFun p := p.sum fun i m => r ^ i \u2022 m\n  map_add' x y := Finsupp.sum_add_index' (fun _ => smul_zero _) fun _ _ _ => smul_add _ _ _\n  map_smul' s m := by\n    refine' (Finsupp.sum_smul_index' _).trans _\n    \u00b7 exact fun i => smul_zero _\n    \u00b7 simp_rw [RingHom.id_apply, Finsupp.smul_sum]\n      congr\n      ext i c\n      rw [smul_comm]", "start": [264, 1], "end": [275, 21], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval_single", "code": "@[simp]\ntheorem eval_single (r : R) (i : \u2115) (m : M) : eval r (single R i m) = r ^ i \u2022 m", "start": [278, 1], "end": [280, 41], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval_lsingle", "code": "@[simp]\ntheorem eval_lsingle (r : R) (i : \u2115) (m : M) : eval r (lsingle R i m) = r ^ i \u2022 m", "start": [283, 1], "end": [285, 20], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval_smul", "code": "theorem eval_smul (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (p \u2022 q) = p.eval r \u2022 eval r q", "start": [288, 1], "end": [298, 36], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval_map", "code": "@[simp]\ntheorem eval_map (f : M \u2192\u2097[R] M') (q : PolynomialModule R M) (r : R) :\n    eval (algebraMap R R' r) (map R' f q) = f (eval r q)", "start": [301, 1], "end": [309, 86], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.eval_map'", "code": "@[simp]\ntheorem eval_map' (f : M \u2192\u2097[R] M) (q : PolynomialModule R M) (r : R) :\n    eval r (map R f q) = f (eval r q)", "start": [312, 1], "end": [315, 19], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.comp", "code": "@[simps!]\nnoncomputable def comp (p : R[X]) : PolynomialModule R M \u2192\u2097[R] PolynomialModule R M :=\n  @LinearMap.comp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n    (@RingHomInvPair.triples _ _ _ _ _ _ RingHomInvPair.ids)\n    ((eval p).restrictScalars R) (map R[X] (lsingle R 0))", "start": [320, 1], "end": [325, 58], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.comp_single", "code": "theorem comp_single (p : R[X]) (i : \u2115) (m : M) : comp p (single R i m) = p ^ i \u2022 single R 0 m", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.comp_eval", "code": "theorem comp_eval (p : R[X]) (q : PolynomialModule R M) (r : R) :\n    eval r (comp p q) = eval (p.eval r) q", "start": [334, 1], "end": [343, 27], "kind": "commanddeclaration"}, {"full_name": "PolynomialModule.comp_smul", "code": "theorem comp_smul (p p' : R[X]) (q : PolynomialModule R M) :\n    comp p (p' \u2022 q) = p'.comp p \u2022 comp p q", "start": [346, 1], "end": [349, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Sign.lean", "imports": ["Mathlib/Data/Real/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.sign", "code": "noncomputable def sign (r : \u211d) : \u211d :=\n  if r < 0 then -1 else if 0 < r then 1 else 0", "start": [30, 1], "end": [33, 47], "kind": "commanddeclaration"}, {"full_name": "Real.sign_of_neg", "code": "theorem sign_of_neg {r : \u211d} (hr : r < 0) : sign r = -1", "start": [36, 1], "end": [36, 82], "kind": "commanddeclaration"}, {"full_name": "Real.sign_of_pos", "code": "theorem sign_of_pos {r : \u211d} (hr : 0 < r) : sign r = 1", "start": [39, 1], "end": [39, 99], "kind": "commanddeclaration"}, {"full_name": "Real.sign_zero", "code": "@[simp]\ntheorem sign_zero : sign 0 = 0", "start": [42, 1], "end": [43, 91], "kind": "commanddeclaration"}, {"full_name": "Real.sign_one", "code": "@[simp]\ntheorem sign_one : sign 1 = 1", "start": [46, 1], "end": [48, 29], "kind": "commanddeclaration"}, {"full_name": "Real.sign_apply_eq", "code": "theorem sign_apply_eq (r : \u211d) : sign r = -1 \u2228 sign r = 0 \u2228 sign r = 1", "start": [51, 1], "end": [55, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sign_apply_eq_of_ne_zero", "code": "theorem sign_apply_eq_of_ne_zero (r : \u211d) (h : r \u2260 0) : sign r = -1 \u2228 sign r = 1", "start": [58, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Real.sign_eq_zero_iff", "code": "@[simp]\ntheorem sign_eq_zero_iff {r : \u211d} : sign r = 0 \u2194 r = 0", "start": [63, 1], "end": [71, 31], "kind": "commanddeclaration"}, {"full_name": "Real.sign_int_cast", "code": "theorem sign_int_cast (z : \u2124) : sign (z : \u211d) = \u2191(Int.sign z)", "start": [74, 1], "end": [79, 84], "kind": "commanddeclaration"}, {"full_name": "Real.sign_neg", "code": "theorem sign_neg {r : \u211d} : sign (-r) = -sign r", "start": [82, 1], "end": [86, 58], "kind": "commanddeclaration"}, {"full_name": "Real.sign_mul_nonneg", "code": "theorem sign_mul_nonneg (r : \u211d) : 0 \u2264 sign r * r", "start": [89, 1], "end": [95, 16], "kind": "commanddeclaration"}, {"full_name": "Real.sign_mul_pos_of_ne_zero", "code": "theorem sign_mul_pos_of_ne_zero (r : \u211d) (hr : r \u2260 0) : 0 < sign r * r", "start": [98, 1], "end": [101, 32], "kind": "commanddeclaration"}, {"full_name": "Real.inv_sign", "code": "@[simp]\ntheorem inv_sign (r : \u211d) : (sign r)\u207b\u00b9 = sign r", "start": [104, 1], "end": [112, 18], "kind": "commanddeclaration"}, {"full_name": "Real.sign_inv", "code": "@[simp]\ntheorem sign_inv (r : \u211d) : sign r\u207b\u00b9 = sign r", "start": [115, 1], "end": [120, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/NaturalTransformation.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/Functor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.OplaxNatTrans", "code": "structure OplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a \u27f6 G.obj a\n  naturality {a b : B} (f : a \u27f6 b) : F.map f \u226b app b \u27f6 app a \u226b G.map f\n  naturality_naturality :\n    \u2200 {a b : B} {f g : a \u27f6 b} (\u03b7 : f \u27f6 g),\n      F.map\u2082 \u03b7 \u25b7 app b \u226b naturality g = naturality f \u226b app a \u25c1 G.map\u2082 \u03b7 := by\n    aesop_cat\n  naturality_id :\n    \u2200 a : B,\n      naturality (\ud835\udfd9 a) \u226b app a \u25c1 G.mapId a =\n        F.mapId a \u25b7 app a \u226b (\u03bb_ (app a)).hom \u226b (\u03c1_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    \u2200 {a b c : B} (f : a \u27f6 b) (g : b \u27f6 c),\n      naturality (f \u226b g) \u226b app a \u25c1 G.mapComp f g =\n        F.mapComp f g \u25b7 app c \u226b\n          (\u03b1_ _ _ _).hom \u226b\n            F.map f \u25c1 naturality g \u226b (\u03b1_ _ _ _).inv \u226b naturality f \u25b7 G.map g \u226b (\u03b1_ _ _ _).hom := by\n    aesop_cat", "start": [40, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.id", "code": "@[simps]\ndef id : OplaxNatTrans F F where\n  app a := \ud835\udfd9 (F.obj a)\n  naturality {a b} f := (\u03c1_ (F.map f)).hom \u226b (\u03bb_ (F.map f)).inv", "start": [95, 1], "end": [99, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_naturality", "code": "@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_naturality (f : a' \u27f6 G.obj a) {g h : a \u27f6 b} (\u03b2 : g \u27f6 h) :\n    f \u25c1 G.map\u2082 \u03b2 \u25b7 \u03b8.app b \u226b f \u25c1 \u03b8.naturality h =\n      f \u25c1 \u03b8.naturality g \u226b f \u25c1 \u03b8.app a \u25c1 H.map\u2082 \u03b2", "start": [111, 1], "end": [115, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerRight_naturality_naturality", "code": "@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_naturality {f g : a \u27f6 b} (\u03b2 : f \u27f6 g) (h : G.obj b \u27f6 a') :\n    F.map\u2082 \u03b2 \u25b7 \u03b7.app b \u25b7 h \u226b \u03b7.naturality g \u25b7 h =\n      \u03b7.naturality f \u25b7 h \u226b (\u03b1_ _ _ _).hom \u226b \u03b7.app a \u25c1 G.map\u2082 \u03b2 \u25b7 h \u226b (\u03b1_ _ _ _).inv", "start": [118, 1], "end": [122, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_comp", "code": "@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_comp (f : a' \u27f6 G.obj a) (g : a \u27f6 b) (h : b \u27f6 c) :\n    f \u25c1 \u03b8.naturality (g \u226b h) \u226b f \u25c1 \u03b8.app a \u25c1 H.mapComp g h =\n      f \u25c1 G.mapComp g h \u25b7 \u03b8.app c \u226b\n        f \u25c1 (\u03b1_ _ _ _).hom \u226b\n          f \u25c1 G.map g \u25c1 \u03b8.naturality h \u226b\n            f \u25c1 (\u03b1_ _ _ _).inv \u226b f \u25c1 \u03b8.naturality g \u25b7 H.map h \u226b f \u25c1 (\u03b1_ _ _ _).hom", "start": [125, 1], "end": [132, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerRight_naturality_comp", "code": "@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_comp (f : a \u27f6 b) (g : b \u27f6 c) (h : G.obj c \u27f6 a') :\n    \u03b7.naturality (f \u226b g) \u25b7 h \u226b (\u03b1_ _ _ _).hom \u226b \u03b7.app a \u25c1 G.mapComp f g \u25b7 h =\n      F.mapComp f g \u25b7 \u03b7.app c \u25b7 h \u226b\n        (\u03b1_ _ _ _).hom \u25b7 h \u226b\n          (\u03b1_ _ _ _).hom \u226b\n            F.map f \u25c1 \u03b7.naturality g \u25b7 h \u226b\n              (\u03b1_ _ _ _).inv \u226b\n                (\u03b1_ _ _ _).inv \u25b7 h \u226b\n                  \u03b7.naturality f \u25b7 G.map g \u25b7 h \u226b (\u03b1_ _ _ _).hom \u25b7 h \u226b (\u03b1_ _ _ _).hom", "start": [135, 1], "end": [145, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerLeft_naturality_id", "code": "@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_id (f : a' \u27f6 G.obj a) :\n    f \u25c1 \u03b8.naturality (\ud835\udfd9 a) \u226b f \u25c1 \u03b8.app a \u25c1 H.mapId a =\n      f \u25c1 G.mapId a \u25b7 \u03b8.app a \u226b f \u25c1 (\u03bb_ (\u03b8.app a)).hom \u226b f \u25c1 (\u03c1_ (\u03b8.app a)).inv", "start": [148, 1], "end": [152, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.whiskerRight_naturality_id", "code": "@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_id (f : G.obj a \u27f6 a') :\n    \u03b7.naturality (\ud835\udfd9 a) \u25b7 f \u226b (\u03b1_ _ _ _).hom \u226b \u03b7.app a \u25c1 G.mapId a \u25b7 f =\n      F.mapId a \u25b7 \u03b7.app a \u25b7 f \u226b (\u03bb_ (\u03b7.app a)).hom \u25b7 f \u226b (\u03c1_ (\u03b7.app a)).inv \u25b7 f \u226b (\u03b1_ _ _ _).hom", "start": [155, 1], "end": [159, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.vcomp", "code": "@[simps]\ndef vcomp (\u03b7 : OplaxNatTrans F G) (\u03b8 : OplaxNatTrans G H) : OplaxNatTrans F H where\n  app a := \u03b7.app a \u226b \u03b8.app a\n  naturality {a b} f :=\n    (\u03b1_ _ _ _).inv \u226b\n      \u03b7.naturality f \u25b7 \u03b8.app b \u226b (\u03b1_ _ _ _).hom \u226b \u03b7.app a \u25c1 \u03b8.naturality f \u226b (\u03b1_ _ _ _).inv\n  naturality_comp {a b c} f g := by\n    calc\n      _ =\n          ?_ \u226b\n            F.mapComp f g \u25b7 \u03b7.app c \u25b7 \u03b8.app c \u226b\n              ?_ \u226b\n                F.map f \u25c1 \u03b7.naturality g \u25b7 \u03b8.app c \u226b\n                  ?_ \u226b\n                    (F.map f \u226b \u03b7.app b) \u25c1 \u03b8.naturality g \u226b\n                      \u03b7.naturality f \u25b7 (\u03b8.app b \u226b H.map g) \u226b\n                        ?_ \u226b \u03b7.app a \u25c1 \u03b8.naturality f \u25b7 H.map g \u226b ?_ :=\n        ?_\n      _ = _ := ?_\n    exact (\u03b1_ _ _ _).inv\n    exact (\u03b1_ _ _ _).hom \u25b7 _ \u226b (\u03b1_ _ _ _).hom\n    exact _ \u25c1 (\u03b1_ _ _ _).hom \u226b (\u03b1_ _ _ _).inv\n    exact (\u03b1_ _ _ _).hom \u226b _ \u25c1 (\u03b1_ _ _ _).inv\n    exact _ \u25c1 (\u03b1_ _ _ _).hom \u226b (\u03b1_ _ _ _).inv\n    \u00b7 rw [whisker_exchange_assoc]\n      simp only [comp_whiskerLeft, assoc, Iso.inv_hom_id_assoc, whiskerLeft_naturality_comp_assoc,\n        whiskerRight_naturality_comp_assoc, pentagon_assoc, whiskerRight_comp,\n        pentagon_hom_inv_inv_inv_inv_assoc]\n    \u00b7 simp\n  naturality_id _ := by\n    simp only [comp_whiskerLeft, assoc, Iso.inv_hom_id_assoc, whiskerLeft_naturality_id_assoc,\n      whiskerLeft_rightUnitor_inv, Iso.hom_inv_id, comp_id, whiskerRight_naturality_id_assoc,\n      leftUnitor_whiskerRight, triangle_assoc, inv_hom_whiskerRight_assoc, whiskerRight_comp]\n  naturality_naturality {_ _ _ _} _ := by\n    simp only [whiskerRight_comp, assoc, Iso.hom_inv_id_assoc,\n      whiskerRight_naturality_naturality_assoc, Iso.inv_hom_id_assoc,\n      whiskerLeft_naturality_naturality_assoc, comp_whiskerLeft]", "start": [164, 1], "end": [204, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification", "code": "@[ext]\nstructure Modification (\u03b7 \u03b8 : F \u27f6 G) where\n  app (a : B) : \u03b7.app a \u27f6 \u03b8.app a\n  naturality :\n    \u2200 {a b : B} (f : a \u27f6 b),\n      F.map f \u25c1 app b \u226b \u03b8.naturality f = \u03b7.naturality f \u226b app a \u25b7 G.map f := by\n    aesop_cat", "start": [221, 1], "end": [232, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.id", "code": "@[simps]\ndef id : Modification \u03b7 \u03b7 where app a := \ud835\udfd9 (\u03b7.app a)", "start": [254, 1], "end": [256, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.whiskerLeft_naturality", "code": "@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality (f : a' \u27f6 F.obj b) (g : b \u27f6 c) :\n    f \u25c1 F.map g \u25c1 \u0393.app c \u226b f \u25c1 \u03b8.naturality g = f \u25c1 \u03b7.naturality g \u226b f \u25c1 \u0393.app b \u25b7 G.map g", "start": [268, 1], "end": [271, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.whiskerRight_naturality", "code": "@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality (f : a \u27f6 b) (g : G.obj b \u27f6 a') :\n    F.map f \u25c1 \u0393.app b \u25b7 g \u226b (\u03b1_ _ _ _).inv \u226b \u03b8.naturality f \u25b7 g =\n      (\u03b1_ _ _ _).inv \u226b \u03b7.naturality f \u25b7 g \u226b \u0393.app a \u25b7 G.map f \u25b7 g", "start": [274, 1], "end": [278, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.vcomp", "code": "@[simps]\ndef vcomp (\u0393 : Modification \u03b7 \u03b8) (\u0394 : Modification \u03b8 \u03b9) : Modification \u03b7 \u03b9 where\n  app a := \u0393.app a \u226b \u0394.app a\n  naturality := by\n    intros\n    simp only [whiskerLeft_comp, assoc, naturality, naturality_assoc, comp_whiskerRight]", "start": [283, 1], "end": [290, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.category", "code": "@[simps]\ninstance category (F G : OplaxFunctor B C) : Category (F \u27f6 G) where\n  Hom := Modification\n  id := Modification.id\n  comp := Modification.vcomp", "start": [295, 1], "end": [300, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.OplaxNatTrans.ext", "code": "@[ext]\nlemma ext {F G : OplaxFunctor B C} {\u03b1 \u03b2 : F \u27f6 G} {m n : \u03b1 \u27f6 \u03b2} (w : \u2200 b, m.app b = n.app b) :\n    m = n := by\n  apply Modification.ext\n  ext\n  apply w", "start": [304, 1], "end": [309, 10], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.id_app'", "code": "@[simp]\nlemma Modification.id_app' {F G : OplaxFunctor B C} (\u03b1 : F \u27f6 G) :\n    Modification.app (\ud835\udfd9 \u03b1) X = \ud835\udfd9 (\u03b1.app X) := rfl", "start": [311, 1], "end": [313, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.OplaxNatTrans.Modification.comp_app'", "code": "@[simp]\nlemma Modification.comp_app' {F G : OplaxFunctor B C} {\u03b1 \u03b2 \u03b3 : F \u27f6 G} (m : \u03b1 \u27f6 \u03b2) (n : \u03b2 \u27f6 \u03b3) :\n    (m \u226b n).app X = m.app X \u226b n.app X := rfl", "start": [315, 1], "end": [317, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.OplaxNatTrans.ModificationIso.ofComponents", "code": "@[simps]\ndef ModificationIso.ofComponents (app : \u2200 a, \u03b7.app a \u2245 \u03b8.app a)\n    (naturality :\n      \u2200 {a b} (f : a \u27f6 b),\n        F.map f \u25c1 (app b).hom \u226b \u03b8.naturality f = \u03b7.naturality f \u226b (app a).hom \u25b7 G.map f) :\n    \u03b7 \u2245 \u03b8 where\n  hom := { app := fun a => (app a).hom }\n  inv :=\n    { app := fun a => (app a).inv\n      naturality := fun {a b} f => by\n        simpa using congr_arg (fun f => _ \u25c1 (app b).inv \u226b f \u226b (app a).inv \u25b7 _) (naturality f).symm }", "start": [319, 1], "end": [332, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Pi.lean", "imports": ["Mathlib/Analysis/Calculus/FDeriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hasFDerivAt_update", "code": "theorem hasFDerivAt_update (x : \u2200 i, E i) {i : \u03b9} (y : E i) :\n    HasFDerivAt (Function.update x i) (.pi (Pi.single i (.id \ud835\udd5c (E i)))) y", "start": [16, 1], "end": [28, 45], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_single", "code": "theorem hasFDerivAt_single {i : \u03b9} (y : E i) :\n    HasFDerivAt (Pi.single i) (.pi (Pi.single i (.id \ud835\udd5c (E i)))) y", "start": [30, 1], "end": [32, 25], "kind": "commanddeclaration"}, {"full_name": "fderiv_update", "code": "theorem fderiv_update (x : \u2200 i, E i) {i : \u03b9} (y : E i) :\n    fderiv \ud835\udd5c (Function.update x i) y = .pi (Pi.single i (.id \ud835\udd5c (E i)))", "start": [34, 1], "end": [36, 34], "kind": "commanddeclaration"}, {"full_name": "fderiv_single", "code": "theorem fderiv_single {i : \u03b9} (y : E i) :\n    fderiv \ud835\udd5c (Pi.single i) y = .pi (Pi.single i (.id \ud835\udd5c (E i)))", "start": [38, 1], "end": [40, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Shift/Quotient.lean", "imports": ["Mathlib/CategoryTheory/Quotient.lean", "Mathlib/CategoryTheory/Shift/Induced.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HomRel.IsCompatibleWithShift", "code": "class IsCompatibleWithShift : Prop :=\n  \n  condition : \u2200 (a : A) \u2983X Y : C\u2984 (f g : X \u27f6 Y), r f g \u2192 r (f\u27e6a\u27e7') (g\u27e6a\u27e7')", "start": [32, 1], "end": [36, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasShift.quotient", "code": "noncomputable instance HasShift.quotient [r.IsCompatibleWithShift A] :\n    HasShift (Quotient r) A :=\n  HasShift.induced (Quotient.functor r) A\n    (fun a => Quotient.lift r (shiftFunctor C a \u22d9 Quotient.functor r)\n      (fun _ _ _ _ hfg => Quotient.sound r (HomRel.IsCompatibleWithShift.condition _ _ _ hfg)))\n    (fun _ => Quotient.lift.isLift _ _ _) \u27e8\u27e8inferInstance\u27e9, inferInstance\u27e9", "start": [42, 1], "end": [49, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Quotient.functor_commShift", "code": "noncomputable instance Quotient.functor_commShift [r.IsCompatibleWithShift A] :\n    (Quotient.functor r).CommShift A :=\n  Functor.CommShift.ofInduced _ _ _ _ _", "start": [51, 1], "end": [54, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Identities.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/Data/Polynomial/Derivative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.powAddExpansion", "code": "def powAddExpansion {R : Type*} [CommSemiring R] (x y : R) :\n    \u2200 n : \u2115, { k // (x + y) ^ n = x ^ n + n * x ^ (n - 1) * y + k * y ^ 2 }\n  | 0 => \u27e80, by simp\u27e9\n  | 1 => \u27e80, by simp\u27e9\n  | n + 2 => by\n    cases' (powAddExpansion x y (n + 1)) with z hz\n    exists x * z + (n + 1) * x ^ n + z * y\n    calc\n      (x + y) ^ (n + 2) = (x + y) * (x + y) ^ (n + 1) := by ring\n      _ = (x + y) * (x ^ (n + 1) + \u2191(n + 1) * x ^ (n + 1 - 1) * y + z * y ^ 2) := by rw [hz]\n      _ = x ^ (n + 2) + \u2191(n + 2) * x ^ (n + 1) * y + (x * z + (n + 1) * x ^ n + z * y) * y ^ 2 := by\n        push_cast\n        ring!", "start": [37, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.polyBinomAux1", "code": "private def polyBinomAux1 (x y : R) (e : \u2115) (a : R) :\n    { k : R // a * (x + y) ^ e = a * (x ^ e + e * x ^ (e - 1) * y + k * y ^ 2) } := by\n  exists (powAddExpansion x y e).val\n  congr\n  apply (powAddExpansion _ _ _).property", "start": [56, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.poly_binom_aux2", "code": "private theorem poly_binom_aux2 (f : R[X]) (x y : R) :\n    f.eval (x + y) =\n      f.sum fun e a => a * (x ^ e + e * x ^ (e - 1) * y + (polyBinomAux1 x y e a).val * y ^ 2)", "start": [62, 1], "end": [66, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.poly_binom_aux3", "code": "private theorem poly_binom_aux3 (f : R[X]) (x y : R) :\n    f.eval (x + y) =\n      ((f.sum fun e a => a * x ^ e) + f.sum fun e a => a * e * x ^ (e - 1) * y) +\n        f.sum fun e a => a * (polyBinomAux1 x y e a).val * y ^ 2", "start": [68, 1], "end": [73, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.binomExpansion", "code": "def binomExpansion (f : R[X]) (x y : R) :\n    { k : R // f.eval (x + y) = f.eval x + f.derivative.eval x * y + k * y ^ 2 } := by\n  exists f.sum fun e a => a * (polyBinomAux1 x y e a).val\n  rw [poly_binom_aux3]\n  congr\n  \u00b7 rw [\u2190 eval_eq_sum]\n  \u00b7 rw [derivative_eval]\n    exact Finset.sum_mul.symm\n  \u00b7 exact Finset.sum_mul.symm", "start": [75, 1], "end": [87, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.powSubPowFactor", "code": "def powSubPowFactor (x y : R) : \u2200 i : \u2115, { z : R // x ^ i - y ^ i = z * (x - y) }\n  | 0 => \u27e80, by simp\u27e9\n  | 1 => \u27e81, by simp\u27e9\n  | k + 2 => by\n    cases' @powSubPowFactor x y (k + 1) with z hz\n    exists z * x + y ^ (k + 1)\n    linear_combination (norm := ring) x * hz", "start": [90, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.evalSubFactor", "code": "def evalSubFactor (f : R[X]) (x y : R) : { z : R // f.eval x - f.eval y = z * (x - y) } := by\n  refine' \u27e8f.sum fun i r => r * (powSubPowFactor x y i).val, _\u27e9\n  delta eval; rw [eval\u2082_eq_sum, eval\u2082_eq_sum];\n  simp only [sum, \u2190 Finset.sum_sub_distrib, Finset.sum_mul]\n  dsimp\n  congr with i\n  rw [mul_assoc, \u2190 (powSubPowFactor x y _).prop, mul_sub]", "start": [101, 1], "end": [110, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/DoubleCounting.lean", "imports": ["Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.bipartiteBelow", "code": "def bipartiteBelow : Finset \u03b1 := s.filter fun a \u21a6 r a b", "start": [48, 1], "end": [49, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.bipartiteAbove", "code": "def bipartiteAbove : Finset \u03b2 := t.filter (r a)", "start": [52, 1], "end": [53, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.bipartiteBelow_swap", "code": "theorem bipartiteBelow_swap : t.bipartiteBelow (swap r) a = t.bipartiteAbove r a", "start": [56, 1], "end": [56, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.bipartiteAbove_swap", "code": "theorem bipartiteAbove_swap : s.bipartiteAbove (swap r) b = s.bipartiteBelow r b", "start": [59, 1], "end": [59, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_bipartiteBelow", "code": "@[simp, norm_cast]\ntheorem coe_bipartiteBelow : (s.bipartiteBelow r b : Set \u03b1) = { a \u2208 s | r a b }", "start": [62, 1], "end": [63, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_bipartiteAbove", "code": "@[simp, norm_cast]\ntheorem coe_bipartiteAbove : (t.bipartiteAbove r a : Set \u03b2) = { b \u2208 t | r a b }", "start": [66, 1], "end": [67, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_bipartiteBelow", "code": "@[simp]\ntheorem mem_bipartiteBelow {a : \u03b1} : a \u2208 s.bipartiteBelow r b \u2194 a \u2208 s \u2227 r a b", "start": [72, 1], "end": [73, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_bipartiteAbove", "code": "@[simp]\ntheorem mem_bipartiteAbove {b : \u03b2} : b \u2208 t.bipartiteAbove r a \u2194 b \u2208 t \u2227 r a b", "start": [76, 1], "end": [77, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_bipartiteAbove_eq_sum_card_bipartiteBelow", "code": "theorem sum_card_bipartiteAbove_eq_sum_card_bipartiteBelow [\u2200 a b, Decidable (r a b)] :\n    (\u2211 a in s, (t.bipartiteAbove r a).card) = \u2211 b in t, (s.bipartiteBelow r b).card", "start": [80, 1], "end": [83, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_le_card_mul", "code": "theorem card_mul_le_card_mul [\u2200 a b, Decidable (r a b)]\n    (hm : \u2200 a \u2208 s, m \u2264 (t.bipartiteAbove r a).card)\n    (hn : \u2200 b \u2208 t, (s.bipartiteBelow r b).card \u2264 n) : s.card * m \u2264 t.card * n", "start": [86, 1], "end": [95, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_le_card_mul'", "code": "theorem card_mul_le_card_mul' [\u2200 a b, Decidable (r a b)]\n    (hn : \u2200 b \u2208 t, n \u2264 (s.bipartiteBelow r b).card)\n    (hm : \u2200 a \u2208 s, (t.bipartiteAbove r a).card \u2264 m) : t.card * n \u2264 s.card * m", "start": [98, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_eq_card_mul", "code": "theorem card_mul_eq_card_mul [\u2200 a b, Decidable (r a b)]\n    (hm : \u2200 a \u2208 s, (t.bipartiteAbove r a).card = m)\n    (hn : \u2200 b \u2208 t, (s.bipartiteBelow r b).card = n) : s.card * m = t.card * n", "start": [104, 1], "end": [108, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_of_forall_subsingleton", "code": "theorem card_le_card_of_forall_subsingleton (hs : \u2200 a \u2208 s, \u2203 b, b \u2208 t \u2227 r a b)\n    (ht : \u2200 b \u2208 t, ({ a \u2208 s | r a b } : Set \u03b1).Subsingleton) : s.card \u2264 t.card", "start": [111, 1], "end": [121, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_of_forall_subsingleton'", "code": "theorem card_le_card_of_forall_subsingleton' (ht : \u2200 b \u2208 t, \u2203 a, a \u2208 s \u2227 r a b)\n    (hs : \u2200 a \u2208 s, ({ b \u2208 t | r a b } : Set \u03b2).Subsingleton) : t.card \u2264 s.card", "start": [124, 1], "end": [126, 53], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_card_of_leftTotal_unique", "code": "theorem card_le_card_of_leftTotal_unique (h\u2081 : LeftTotal r) (h\u2082 : LeftUnique r) :\n    Fintype.card \u03b1 \u2264 Fintype.card \u03b2", "start": [139, 1], "end": [141, 99], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_card_of_rightTotal_unique", "code": "theorem card_le_card_of_rightTotal_unique (h\u2081 : RightTotal r) (h\u2082 : RightUnique r) :\n    Fintype.card \u03b2 \u2264 Fintype.card \u03b1", "start": [144, 1], "end": [146, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/NNRat.lean", "imports": ["Mathlib/Algebra/Order/Nonneg/Floor.lean", "Mathlib/Algebra/Order/Nonneg/Field.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NNRat", "code": "def NNRat := { q : \u211a // 0 \u2264 q } deriving\n  CanonicallyOrderedCommSemiring, CanonicallyLinearOrderedSemifield, LinearOrderedCommGroupWithZero,\n  Sub, Inhabited", "start": [33, 1], "end": [36, 17], "kind": "commanddeclaration"}, {"full_name": "NNRat.canLift", "code": "instance canLift : CanLift \u211a \u211a\u22650 (\u2191) fun q \u21a6 0 \u2264 q where\n  prf q hq := \u27e8\u27e8q, hq\u27e9, rfl\u27e9", "start": [64, 1], "end": [65, 29], "kind": "commanddeclaration"}, {"full_name": "NNRat.ext", "code": "@[ext]\ntheorem ext : (p : \u211a) = (q : \u211a) \u2192 p = q", "start": [68, 1], "end": [70, 14], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_injective", "code": "protected theorem coe_injective : Injective ((\u2191) : \u211a\u22650 \u2192 \u211a)", "start": [73, 1], "end": [74, 24], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj : (p : \u211a) = q \u2194 p = q", "start": [77, 1], "end": [79, 18], "kind": "commanddeclaration"}, {"full_name": "NNRat.ext_iff", "code": "theorem ext_iff : p = q \u2194 (p : \u211a) = q", "start": [82, 1], "end": [83, 18], "kind": "commanddeclaration"}, {"full_name": "NNRat.ne_iff", "code": "theorem ne_iff {x y : \u211a\u22650} : (x : \u211a) \u2260 (y : \u211a) \u2194 x \u2260 y", "start": [86, 1], "end": [87, 20], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_mk", "code": "@[norm_cast]\ntheorem coe_mk (q : \u211a) (hq) : ((\u27e8q, hq\u27e9 : \u211a\u22650) : \u211a) = q", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat", "code": "def _root_.Rat.toNNRat (q : \u211a) : \u211a\u22650 :=\n  \u27e8max q 0, le_max_right _ _\u27e9", "start": [95, 1], "end": [97, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_toNNRat", "code": "theorem _root_.Rat.coe_toNNRat (q : \u211a) (hq : 0 \u2264 q) : (q.toNNRat : \u211a) = q", "start": [100, 1], "end": [101, 17], "kind": "commanddeclaration"}, {"full_name": "Rat.le_coe_toNNRat", "code": "theorem _root_.Rat.le_coe_toNNRat (q : \u211a) : q \u2264 q.toNNRat", "start": [104, 1], "end": [105, 18], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_nonneg", "code": "@[simp]\ntheorem coe_nonneg (q : \u211a\u22650) : (0 : \u211a) \u2264 q", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u211a\u22650) : \u211a) = 0", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : \u211a\u22650) : \u211a) = 1", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (p q : \u211a\u22650) : ((p + q : \u211a\u22650) : \u211a) = p + q", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (p q : \u211a\u22650) : ((p * q : \u211a\u22650) : \u211a) = p * q", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv (q : \u211a\u22650) : ((q\u207b\u00b9 : \u211a\u22650) : \u211a) = (q : \u211a)\u207b\u00b9", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_div", "code": "@[simp, norm_cast]\ntheorem coe_div (p q : \u211a\u22650) : ((p / q : \u211a\u22650) : \u211a) = p / q", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (h : q \u2264 p) : ((p - q : \u211a\u22650) : \u211a) = p - q", "start": [149, 1], "end": [151, 52], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_eq_zero", "code": "@[simp]\ntheorem coe_eq_zero : (q : \u211a) = 0 \u2194 q = 0", "start": [154, 1], "end": [155, 58], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_ne_zero", "code": "theorem coe_ne_zero : (q : \u211a) \u2260 0 \u2194 q \u2260 0", "start": [158, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_le_coe", "code": "@[norm_cast] theorem coe_le_coe : (p : \u211a) \u2264 q \u2194 p \u2264 q", "start": [162, 1], "end": [164, 10], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_lt_coe", "code": "@[norm_cast] theorem coe_lt_coe : (p : \u211a) < q \u2194 p < q", "start": [167, 1], "end": [169, 10], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_pos", "code": "@[simp, norm_cast]\ntheorem coe_pos : (0 : \u211a) < q \u2194 0 < q", "start": [172, 1], "end": [174, 10], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_mono", "code": "theorem coe_mono : Monotone ((\u2191) : \u211a\u22650 \u2192 \u211a)", "start": [177, 1], "end": [178, 25], "kind": "commanddeclaration"}, {"full_name": "NNRat.toNNRat_mono", "code": "theorem toNNRat_mono : Monotone toNNRat", "start": [181, 1], "end": [182, 34], "kind": "commanddeclaration"}, {"full_name": "NNRat.toNNRat_coe", "code": "@[simp]\ntheorem toNNRat_coe (q : \u211a\u22650) : toNNRat q = q", "start": [185, 1], "end": [187, 25], "kind": "commanddeclaration"}, {"full_name": "NNRat.toNNRat_coe_nat", "code": "@[simp]\ntheorem toNNRat_coe_nat (n : \u2115) : toNNRat n = n", "start": [190, 1], "end": [192, 62], "kind": "commanddeclaration"}, {"full_name": "NNRat.gi", "code": "protected def gi : GaloisInsertion toNNRat (\u2191) :=\n  GaloisInsertion.monotoneIntro coe_mono toNNRat_mono Rat.le_coe_toNNRat toNNRat_coe", "start": [195, 1], "end": [197, 85], "kind": "commanddeclaration"}, {"full_name": "NNRat.coeHom", "code": "def coeHom : \u211a\u22650 \u2192+* \u211a where\n  toFun := (\u2191)\n  map_one' := coe_one\n  map_mul' := coe_mul\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [200, 1], "end": [206, 22], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_natCast", "code": "@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : (\u2191(\u2191n : \u211a\u22650) : \u211a) = n", "start": [209, 1], "end": [211, 23], "kind": "commanddeclaration"}, {"full_name": "NNRat.mk_coe_nat", "code": "@[simp]\ntheorem mk_coe_nat (n : \u2115) : @Eq \u211a\u22650 (\u27e8(n : \u211a), n.cast_nonneg\u27e9 : \u211a\u22650) n", "start": [214, 1], "end": [216, 27], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_coeHom", "code": "@[simp]\ntheorem coe_coeHom : \u21d1coeHom = ((\u2191) : \u211a\u22650 \u2192 \u211a)", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_indicator", "code": "@[simp, norm_cast]\ntheorem coe_indicator (s : Set \u03b1) (f : \u03b1 \u2192 \u211a\u22650) (a : \u03b1) :\n    ((s.indicator f a : \u211a\u22650) : \u211a) = s.indicator (fun x \u21a6 \u2191(f x)) a", "start": [240, 1], "end": [243, 42], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (q : \u211a\u22650) (n : \u2115) : (\u2191(q ^ n) : \u211a) = (q : \u211a) ^ n", "start": [246, 1], "end": [248, 21], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_list_sum", "code": "@[norm_cast]\ntheorem coe_list_sum (l : List \u211a\u22650) : (l.sum : \u211a) = (l.map (\u2191)).sum", "start": [251, 1], "end": [253, 24], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_list_prod", "code": "@[norm_cast]\ntheorem coe_list_prod (l : List \u211a\u22650) : (l.prod : \u211a) = (l.map (\u2191)).prod", "start": [256, 1], "end": [258, 25], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_multiset_sum", "code": "@[norm_cast]\ntheorem coe_multiset_sum (s : Multiset \u211a\u22650) : (s.sum : \u211a) = (s.map (\u2191)).sum", "start": [261, 1], "end": [263, 28], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_multiset_prod", "code": "@[norm_cast]\ntheorem coe_multiset_prod (s : Multiset \u211a\u22650) : (s.prod : \u211a) = (s.map (\u2191)).prod", "start": [266, 1], "end": [268, 29], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_sum", "code": "@[norm_cast]\ntheorem coe_sum {s : Finset \u03b1} {f : \u03b1 \u2192 \u211a\u22650} : \u2191(\u2211 a in s, f a) = \u2211 a in s, (f a : \u211a)", "start": [271, 1], "end": [273, 21], "kind": "commanddeclaration"}, {"full_name": "NNRat.toNNRat_sum_of_nonneg", "code": "theorem toNNRat_sum_of_nonneg {s : Finset \u03b1} {f : \u03b1 \u2192 \u211a} (hf : \u2200 a, a \u2208 s \u2192 0 \u2264 f a) :\n    (\u2211 a in s, f a).toNNRat = \u2211 a in s, (f a).toNNRat", "start": [276, 1], "end": [279, 78], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod {s : Finset \u03b1} {f : \u03b1 \u2192 \u211a\u22650} : \u2191(\u220f a in s, f a) = \u220f a in s, (f a : \u211a)", "start": [282, 1], "end": [284, 22], "kind": "commanddeclaration"}, {"full_name": "NNRat.toNNRat_prod_of_nonneg", "code": "theorem toNNRat_prod_of_nonneg {s : Finset \u03b1} {f : \u03b1 \u2192 \u211a} (hf : \u2200 a \u2208 s, 0 \u2264 f a) :\n    (\u220f a in s, f a).toNNRat = \u220f a in s, (f a).toNNRat", "start": [287, 1], "end": [290, 79], "kind": "commanddeclaration"}, {"full_name": "NNRat.nsmul_coe", "code": "@[norm_cast]\ntheorem nsmul_coe (q : \u211a\u22650) (n : \u2115) : \u2191(n \u2022 q) = n \u2022 (q : \u211a)", "start": [293, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "NNRat.bddAbove_coe", "code": "theorem bddAbove_coe {s : Set \u211a\u22650} : BddAbove ((\u2191) '' s : Set \u211a) \u2194 BddAbove s", "start": [298, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "NNRat.bddBelow_coe", "code": "theorem bddBelow_coe (s : Set \u211a\u22650) : BddBelow (((\u2191) : \u211a\u22650 \u2192 \u211a) '' s)", "start": [305, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max (x y : \u211a\u22650) : ((max x y : \u211a\u22650) : \u211a) = max (x : \u211a) (y : \u211a)", "start": [309, 1], "end": [311, 19], "kind": "commanddeclaration"}, {"full_name": "NNRat.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min (x y : \u211a\u22650) : ((min x y : \u211a\u22650) : \u211a) = min (x : \u211a) (y : \u211a)", "start": [314, 1], "end": [316, 19], "kind": "commanddeclaration"}, {"full_name": "NNRat.sub_def", "code": "theorem sub_def (p q : \u211a\u22650) : p - q = toNNRat (p - q)", "start": [319, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.abs_coe", "code": "@[simp]\ntheorem abs_coe (q : \u211a\u22650) : |(q : \u211a)| = q", "start": [323, 1], "end": [325, 20], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_zero", "code": "@[simp]\ntheorem toNNRat_zero : toNNRat 0 = 0", "start": [336, 1], "end": [337, 44], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_one", "code": "@[simp]\ntheorem toNNRat_one : toNNRat 1 = 1", "start": [340, 1], "end": [341, 43], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_pos", "code": "@[simp]\ntheorem toNNRat_pos : 0 < toNNRat q \u2194 0 < q", "start": [344, 1], "end": [345, 79], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_eq_zero", "code": "@[simp]\ntheorem toNNRat_eq_zero : toNNRat q = 0 \u2194 q \u2264 0", "start": [348, 1], "end": [350, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_of_nonpos", "code": "alias \u27e8_, toNNRat_of_nonpos\u27e9 := toNNRat_eq_zero", "start": [353, 1], "end": [353, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Rat.toNNRat_le_toNNRat_iff", "code": "@[simp]\ntheorem toNNRat_le_toNNRat_iff (hp : 0 \u2264 p) : toNNRat q \u2264 toNNRat p \u2194 q \u2264 p", "start": [356, 1], "end": [358, 35], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_lt_toNNRat_iff'", "code": "@[simp]\ntheorem toNNRat_lt_toNNRat_iff' : toNNRat q < toNNRat p \u2194 q < p \u2227 0 < p", "start": [361, 1], "end": [363, 42], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_lt_toNNRat_iff", "code": "theorem toNNRat_lt_toNNRat_iff (h : 0 < p) : toNNRat q < toNNRat p \u2194 q < p", "start": [366, 1], "end": [367, 49], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_lt_toNNRat_iff_of_nonneg", "code": "theorem toNNRat_lt_toNNRat_iff_of_nonneg (hq : 0 \u2264 q) : toNNRat q < toNNRat p \u2194 q < p", "start": [370, 1], "end": [371, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_add", "code": "@[simp]\ntheorem toNNRat_add (hq : 0 \u2264 q) (hp : 0 \u2264 p) : toNNRat (q + p) = toNNRat q + toNNRat p", "start": [374, 1], "end": [376, 53], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_add_le", "code": "theorem toNNRat_add_le : toNNRat (q + p) \u2264 toNNRat q + toNNRat p", "start": [379, 1], "end": [380, 90], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_le_iff_le_coe", "code": "theorem toNNRat_le_iff_le_coe {p : \u211a\u22650} : toNNRat q \u2264 p \u2194 q \u2264 \u2191p", "start": [383, 1], "end": [384, 18], "kind": "commanddeclaration"}, {"full_name": "Rat.le_toNNRat_iff_coe_le", "code": "theorem le_toNNRat_iff_coe_le {q : \u211a\u22650} (hp : 0 \u2264 p) : q \u2264 toNNRat p \u2194 \u2191q \u2264 p", "start": [387, 1], "end": [388, 42], "kind": "commanddeclaration"}, {"full_name": "Rat.le_toNNRat_iff_coe_le'", "code": "theorem le_toNNRat_iff_coe_le' {q : \u211a\u22650} (hq : 0 < q) : q \u2264 toNNRat p \u2194 \u2191q \u2264 p", "start": [391, 1], "end": [393, 86], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_lt_iff_lt_coe", "code": "theorem toNNRat_lt_iff_lt_coe {p : \u211a\u22650} (hq : 0 \u2264 q) : toNNRat q < p \u2194 q < \u2191p", "start": [396, 1], "end": [397, 42], "kind": "commanddeclaration"}, {"full_name": "Rat.lt_toNNRat_iff_coe_lt", "code": "theorem lt_toNNRat_iff_coe_lt {q : \u211a\u22650} : q < toNNRat p \u2194 \u2191q < p", "start": [400, 1], "end": [401, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_mul", "code": "theorem toNNRat_mul (hp : 0 \u2264 p) : toNNRat (p * q) = toNNRat p * toNNRat q", "start": [408, 1], "end": [412, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_inv", "code": "theorem toNNRat_inv (q : \u211a) : toNNRat q\u207b\u00b9 = (toNNRat q)\u207b\u00b9", "start": [415, 1], "end": [419, 32], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_div", "code": "theorem toNNRat_div (hp : 0 \u2264 p) : toNNRat (p / q) = toNNRat p / toNNRat q", "start": [422, 1], "end": [423, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.toNNRat_div'", "code": "theorem toNNRat_div' (hq : 0 \u2264 q) : toNNRat (p / q) = toNNRat p / toNNRat q", "start": [426, 1], "end": [427, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.nnabs", "code": "def Rat.nnabs (x : \u211a) : \u211a\u22650 :=\n  \u27e8abs x, abs_nonneg x\u27e9", "start": [432, 1], "end": [435, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nnabs", "code": "@[norm_cast, simp]\ntheorem Rat.coe_nnabs (x : \u211a) : (Rat.nnabs x : \u211a) = abs x", "start": [438, 1], "end": [439, 65], "kind": "commanddeclaration"}, {"full_name": "NNRat.num", "code": "def num (q : \u211a\u22650) : \u2115 :=\n  (q : \u211a).num.natAbs", "start": [449, 1], "end": [451, 21], "kind": "commanddeclaration"}, {"full_name": "NNRat.den", "code": "def den (q : \u211a\u22650) : \u2115 :=\n  (q : \u211a).den", "start": [454, 1], "end": [456, 14], "kind": "commanddeclaration"}, {"full_name": "NNRat.natAbs_num_coe", "code": "@[simp]\ntheorem natAbs_num_coe : (q : \u211a).num.natAbs = q.num", "start": [459, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.den_coe", "code": "@[simp]\ntheorem den_coe : (q : \u211a).den = q.den", "start": [464, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "NNRat.ext_num_den", "code": "theorem ext_num_den (hn : p.num = q.num) (hd : p.den = q.den) : p = q", "start": [469, 1], "end": [474, 13], "kind": "commanddeclaration"}, {"full_name": "NNRat.ext_num_den_iff", "code": "theorem ext_num_den_iff : p = q \u2194 p.num = q.num \u2227 p.den = q.den", "start": [477, 1], "end": [478, 65], "kind": "commanddeclaration"}, {"full_name": "NNRat.num_div_den", "code": "@[simp]\ntheorem num_div_den (q : \u211a\u22650) : (q.num : \u211a\u22650) / q.den = q", "start": [481, 1], "end": [486, 26], "kind": "commanddeclaration"}, {"full_name": "NNRat.rec", "code": "protected def rec {\u03b1 : \u211a\u22650 \u2192 Sort*} (h : \u2200 m n : \u2115, \u03b1 (m / n)) (q : \u211a\u22650) : \u03b1 q := by\n  rw [\u2190 num_div_den q]\n  apply h", "start": [489, 1], "end": [492, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean", "imports": ["Mathlib/CategoryTheory/Idempotents/SimplicialObject.lean", "Mathlib/AlgebraicTopology/DoldKan/EquivalenceAdditive.lean", "Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Idempotents.DoldKan.N", "code": "@[simps!, nolint unusedArguments]\ndef N  [IsIdempotentComplete C] [HasFiniteCoproducts C] : SimplicialObject C \u2964 ChainComplex C \u2115 :=\n  N\u2081 \u22d9 (toKaroubiEquivalence _).inverse", "start": [52, 1], "end": [57, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.\u0393", "code": "@[simps!, nolint unusedArguments]\ndef \u0393  [IsIdempotentComplete C] [HasFiniteCoproducts C] : ChainComplex C \u2115 \u2964 SimplicialObject C :=\n  \u0393\u2080", "start": [61, 1], "end": [64, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.hN\u2081", "code": "theorem hN\u2081 :\n    (toKaroubiEquivalence (SimplicialObject C)).functor \u22d9 Preadditive.DoldKan.equivalence.functor =\n      N\u2081", "start": [69, 1], "end": [72, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.h\u0393\u2080", "code": "theorem h\u0393\u2080 :\n    (toKaroubiEquivalence (ChainComplex C \u2115)).functor \u22d9 Preadditive.DoldKan.equivalence.inverse =\n      \u0393 \u22d9 (toKaroubiEquivalence _).functor", "start": [76, 1], "end": [79, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.equivalence", "code": "def equivalence : SimplicialObject C \u224c ChainComplex C \u2115 :=\n  Compatibility.equivalence (eqToIso hN\u2081) (eqToIso h\u0393\u2080)", "start": [82, 1], "end": [86, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.equivalence_functor", "code": "theorem equivalence_functor : (equivalence : SimplicialObject C \u224c _).functor = N", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.equivalence_inverse", "code": "theorem equivalence_inverse : (equivalence : SimplicialObject C \u224c _).inverse = \u0393", "start": [93, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.h\u03b7", "code": "theorem h\u03b7 :\n    Compatibility.\u03c4\u2080 =\n      Compatibility.\u03c4\u2081 (eqToIso hN\u2081) (eqToIso h\u0393\u2080)\n        (N\u2081\u0393\u2080 : \u0393 \u22d9 N\u2081 \u2245 (toKaroubiEquivalence (ChainComplex C \u2115)).functor)", "start": [97, 1], "end": [106, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.\u03b7", "code": "@[simps!]\ndef \u03b7 : \u0393 \u22d9 N \u2245 \ud835\udfed (ChainComplex C \u2115) :=\n  Compatibility.equivalenceCounitIso\n    (N\u2081\u0393\u2080 : (\u0393 : ChainComplex C \u2115 \u2964 _) \u22d9 N\u2081 \u2245 (toKaroubiEquivalence _).functor)", "start": [109, 1], "end": [113, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.equivalence_counitIso", "code": "theorem equivalence_counitIso :\n    DoldKan.equivalence.counitIso = (\u03b7 : \u0393 \u22d9 N \u2245 \ud835\udfed (ChainComplex C \u2115))", "start": [116, 1], "end": [118, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.h\u03b5", "code": "theorem h\u03b5 :\n    Compatibility.\u03c5 (eqToIso hN\u2081) =\n      (\u0393\u2082N\u2081 : (toKaroubiEquivalence _).functor \u2245\n          (N\u2081 : SimplicialObject C \u2964 _) \u22d9 Preadditive.DoldKan.equivalence.inverse)", "start": [121, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.\u03b5", "code": "def \u03b5 : \ud835\udfed (SimplicialObject C) \u2245 N \u22d9 \u0393 :=\n  Compatibility.equivalenceUnitIso (eqToIso h\u0393\u2080) \u0393\u2082N\u2081", "start": [136, 1], "end": [138, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.DoldKan.equivalence_unitIso", "code": "theorem equivalence_unitIso :\n    DoldKan.equivalence.unitIso = (\u03b5 : \ud835\udfed (SimplicialObject C) \u2245 N \u22d9 \u0393)", "start": [141, 1], "end": [143, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/Normalized.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/FunctorN.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicTopology.DoldKan.HigherFacesVanish.inclusionOfMooreComplexMap", "code": "theorem HigherFacesVanish.inclusionOfMooreComplexMap (n : \u2115) :\n    HigherFacesVanish (n + 1) ((inclusionOfMooreComplexMap X).f (n + 1))", "start": [44, 1], "end": [48, 85], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.factors_normalizedMooreComplex_PInfty", "code": "theorem factors_normalizedMooreComplex_PInfty (n : \u2115) :\n    Subobject.Factors (NormalizedMooreComplex.objX X n) (PInfty.f n)", "start": [52, 1], "end": [59, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.PInftyToNormalizedMooreComplex", "code": "@[simps!]\ndef PInftyToNormalizedMooreComplex (X : SimplicialObject A) : K[X] \u27f6 N[X] :=\n  ChainComplex.ofHom _ _ _ _ _ _\n    (fun n => factorThru _ _ (factors_normalizedMooreComplex_PInfty n)) fun n => by\n    rw [\u2190 cancel_mono (NormalizedMooreComplex.objX X n).arrow, assoc, assoc, factorThru_arrow,\n      \u2190 inclusionOfMooreComplexMap_f, \u2190 normalizedMooreComplex_objD,\n      \u2190 (inclusionOfMooreComplexMap X).comm (n + 1) n, inclusionOfMooreComplexMap_f,\n      factorThru_arrow_assoc, \u2190 alternatingFaceMapComplex_obj_d]\n    exact PInfty.comm (n + 1) n", "start": [63, 1], "end": [72, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap", "code": "@[reassoc (attr := simp)]\ntheorem PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap (X : SimplicialObject A) :\n    PInftyToNormalizedMooreComplex X \u226b inclusionOfMooreComplexMap X = PInfty", "start": [76, 1], "end": [78, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.PInftyToNormalizedMooreComplex_naturality", "code": "@[reassoc (attr := simp)]\ntheorem PInftyToNormalizedMooreComplex_naturality {X Y : SimplicialObject A} (f : X \u27f6 Y) :\n    AlternatingFaceMapComplex.map f \u226b PInftyToNormalizedMooreComplex Y =\n      PInftyToNormalizedMooreComplex X \u226b NormalizedMooreComplex.map f", "start": [82, 1], "end": [86, 15], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.PInfty_comp_PInftyToNormalizedMooreComplex", "code": "@[reassoc (attr := simp)]\ntheorem PInfty_comp_PInftyToNormalizedMooreComplex (X : SimplicialObject A) :\n    PInfty \u226b PInftyToNormalizedMooreComplex X = PInftyToNormalizedMooreComplex X", "start": [90, 1], "end": [92, 97], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.inclusionOfMooreComplexMap_comp_PInfty", "code": "@[reassoc (attr := simp)]\ntheorem inclusionOfMooreComplexMap_comp_PInfty (X : SimplicialObject A) :\n    inclusionOfMooreComplexMap X \u226b PInfty = inclusionOfMooreComplexMap X", "start": [96, 1], "end": [102, 74], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.splitMonoInclusionOfMooreComplexMap", "code": "def splitMonoInclusionOfMooreComplexMap (X : SimplicialObject A) :\n    SplitMono (inclusionOfMooreComplexMap X) where\n  retraction := PInftyToNormalizedMooreComplex X\n  id := by\n    simp only [\u2190 cancel_mono (inclusionOfMooreComplexMap X), assoc, id_comp,\n      PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap,\n      inclusionOfMooreComplexMap_comp_PInfty]", "start": [113, 1], "end": [120, 46], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.N\u2081_iso_normalizedMooreComplex_comp_toKaroubi", "code": "def N\u2081_iso_normalizedMooreComplex_comp_toKaroubi : N\u2081 \u2245 normalizedMooreComplex A \u22d9 toKaroubi _ where\n  hom :=\n    { app := fun X =>\n        { f := PInftyToNormalizedMooreComplex X\n          comm := by erw [comp_id, PInfty_comp_PInftyToNormalizedMooreComplex] }\n      naturality := fun X Y f => by\n        simp only [Functor.comp_map, normalizedMooreComplex_map,\n          PInftyToNormalizedMooreComplex_naturality, Karoubi.hom_ext_iff, Karoubi.comp_f, N\u2081_map_f,\n          PInfty_comp_PInftyToNormalizedMooreComplex_assoc, toKaroubi_map_f, assoc] }\n  inv :=\n    { app := fun X =>\n        { f := inclusionOfMooreComplexMap X\n          comm := by erw [inclusionOfMooreComplexMap_comp_PInfty, id_comp] }\n      naturality := fun X Y f => by\n        ext\n        simp only [Functor.comp_map, normalizedMooreComplex_map, Karoubi.comp_f, toKaroubi_map_f,\n          HomologicalComplex.comp_f, NormalizedMooreComplex.map_f,\n          inclusionOfMooreComplexMap_f, factorThru_arrow, N\u2081_map_f,\n          inclusionOfMooreComplexMap_comp_PInfty_assoc, AlternatingFaceMapComplex.map_f] }\n  hom_inv_id := by\n    ext X : 3\n    simp only [PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap,\n      NatTrans.comp_app, Karoubi.comp_f, N\u2081_obj_p, NatTrans.id_app, Karoubi.id_eq]\n  inv_hom_id := by\n    ext X : 3\n    rw [\u2190 cancel_mono (inclusionOfMooreComplexMap X)]\n    simp only [NatTrans.comp_app, Karoubi.comp_f, assoc, NatTrans.id_app, Karoubi.id_eq,\n      PInftyToNormalizedMooreComplex_comp_inclusionOfMooreComplexMap,\n      inclusionOfMooreComplexMap_comp_PInfty]\n    dsimp only [Functor.comp_obj, toKaroubi]\n    erw [id_comp]", "start": [126, 1], "end": [160, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/Layercake.lean", "imports": ["Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/Analysis/SpecialFunctions/Integrals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.countable_meas_le_ne_meas_lt", "code": "theorem countable_meas_le_ne_meas_lt (g : \u03b1 \u2192 R) :\n    {t : R | \u03bc {a : \u03b1 | t \u2264 g a} \u2260 \u03bc {a : \u03b1 | t < g a}}.Countable", "start": [73, 1], "end": [82, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.meas_le_ae_eq_meas_lt", "code": "theorem meas_le_ae_eq_meas_lt {R : Type*} [LinearOrder R] [MeasurableSpace R]\n    (\u03bd : Measure R) [NoAtoms \u03bd] (g : \u03b1 \u2192 R) :\n    (fun t => \u03bc {a : \u03b1 | t \u2264 g a}) =\u1d50[\u03bd] fun t => \u03bc {a : \u03b1 | t < g a}", "start": [84, 1], "end": [87, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite", "code": "theorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite\n    (\u03bc : Measure \u03b1) [SigmaFinite \u03bc]\n    (f_nn : 0 \u2264 f) (f_mble : Measurable f)\n    (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : \u2200 t > 0, 0 \u2264 g t) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) \u2202\u03bc) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t)", "start": [98, 1], "end": [183, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable", "code": "theorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable (\u03bc : Measure \u03b1)\n    (f_nn : 0 \u2264 f) (f_mble : Measurable f)\n    (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : \u2200 t > 0, 0 \u2264 g t) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) \u2202\u03bc) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t)", "start": [186, 1], "end": [381, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul", "code": "theorem lintegral_comp_eq_lintegral_meas_le_mul (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1d50[\u03bc] f)\n    (f_mble : AEMeasurable f \u03bc) (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : \u2200\u1d50 t \u2202volume.restrict (Ioi 0), 0 \u2264 g t) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) \u2202\u03bc) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t)", "start": [383, 1], "end": [437, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_lintegral_meas_le", "code": "theorem lintegral_eq_lintegral_meas_le (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1d50[\u03bc] f)\n    (f_mble : AEMeasurable f \u03bc) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9) \u2202\u03bc) = \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a}", "start": [440, 1], "end": [459, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rpow_eq_lintegral_meas_le_mul", "code": "theorem lintegral_rpow_eq_lintegral_meas_le_mul (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1d50[\u03bc] f)\n    (f_mble : AEMeasurable f \u03bc) {p : \u211d} (p_pos : 0 < p) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9 ^ p) \u2202\u03bc) =\n      ENNReal.ofReal p * \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (t ^ (p - 1))", "start": [462, 1], "end": [492, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul", "code": "theorem lintegral_comp_eq_lintegral_meas_lt_mul (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1d50[\u03bc] f)\n    (f_mble : AEMeasurable f \u03bc) (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : \u2200\u1d50 t \u2202volume.restrict (Ioi 0), 0 \u2264 g t) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) \u2202\u03bc) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t < f a} * ENNReal.ofReal (g t)", "start": [505, 1], "end": [526, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_eq_lintegral_meas_lt", "code": "theorem lintegral_eq_lintegral_meas_lt (\u03bc : Measure \u03b1)\n    (f_nn : 0 \u2264\u1d50[\u03bc] f) (f_mble : AEMeasurable f \u03bc) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9) \u2202\u03bc) = \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t < f a}", "start": [529, 1], "end": [543, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lintegral_rpow_eq_lintegral_meas_lt_mul", "code": "theorem lintegral_rpow_eq_lintegral_meas_lt_mul (\u03bc : Measure \u03b1)\n    (f_nn : 0 \u2264\u1d50[\u03bc] f) (f_mble : AEMeasurable f \u03bc) {p : \u211d} (p_pos : 0 < p) :\n    (\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9 ^ p) \u2202\u03bc) =\n      ENNReal.ofReal p * \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t < f a} * ENNReal.ofReal (t ^ (p - 1))", "start": [546, 1], "end": [562, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_eq_integral_meas_lt", "code": "theorem Integrable.integral_eq_integral_meas_lt\n    (f_intble : Integrable f \u03bc) (f_nn : 0 \u2264\u1d50[\u03bc] f) :\n    (\u222b \u03c9, f \u03c9 \u2202\u03bc) = \u222b t in Set.Ioi 0, ENNReal.toReal (\u03bc {a : \u03b1 | t < f a})", "start": [571, 1], "end": [596, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Hom/Ring.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Hom/Monoid.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/Algebra/Order/Archimedean.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": [{"full_name": "OrderRingHom", "code": "structure OrderRingHom (\u03b1 \u03b2 : Type*) [NonAssocSemiring \u03b1] [Preorder \u03b1] [NonAssocSemiring \u03b2]\n  [Preorder \u03b2] extends \u03b1 \u2192+* \u03b2 where\n  \n  monotone' : Monotone toFun", "start": [38, 1], "end": [47, 29], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso", "code": "structure OrderRingIso (\u03b1 \u03b2 : Type*) [Mul \u03b1] [Mul \u03b2] [Add \u03b1] [Add \u03b2] [LE \u03b1] [LE \u03b2] extends\n  \u03b1 \u2243+* \u03b2 where\n  \n  map_le_map_iff' {a b : \u03b1} : toFun a \u2264 toFun b \u2194 a \u2264 b", "start": [63, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "OrderRingHomClass", "code": "class OrderRingHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [NonAssocSemiring \u03b1] [Preorder \u03b1]\n  [NonAssocSemiring \u03b2] [Preorder \u03b2] extends RingHomClass F \u03b1 \u03b2 where\n  \n  monotone (f : F) : Monotone f", "start": [78, 1], "end": [83, 32], "kind": "commanddeclaration"}, {"full_name": "OrderRingIsoClass", "code": "class OrderRingIsoClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Mul \u03b1] [Add \u03b1] [LE \u03b1] [Mul \u03b2]\n  [Add \u03b2] [LE \u03b2] extends RingEquivClass F \u03b1 \u03b2 where\n  \n  map_le_map_iff (f : F) {a b : \u03b1} : f a \u2264 f b \u2194 a \u2264 b", "start": [86, 1], "end": [91, 55], "kind": "commanddeclaration"}, {"full_name": "OrderRingHomClass.toOrderAddMonoidHomClass", "code": "instance (priority := 100) OrderRingHomClass.toOrderAddMonoidHomClass [NonAssocSemiring \u03b1]\n    [Preorder \u03b1] [NonAssocSemiring \u03b2] [Preorder \u03b2] [OrderRingHomClass F \u03b1 \u03b2] :\n    OrderAddMonoidHomClass F \u03b1 \u03b2 :=\n  { \u2039OrderRingHomClass F \u03b1 \u03b2\u203a with }", "start": [95, 1], "end": [98, 37], "kind": "commanddeclaration"}, {"full_name": "OrderRingHomClass.toOrderMonoidWithZeroHomClass", "code": "instance (priority := 100) OrderRingHomClass.toOrderMonoidWithZeroHomClass [NonAssocSemiring \u03b1]\n    [Preorder \u03b1] [NonAssocSemiring \u03b2] [Preorder \u03b2] [OrderRingHomClass F \u03b1 \u03b2] :\n    OrderMonoidWithZeroHomClass F \u03b1 \u03b2 :=\n  { \u2039OrderRingHomClass F \u03b1 \u03b2\u203a with }", "start": [102, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "OrderRingIsoClass.toOrderIsoClass", "code": "instance (priority := 100) OrderRingIsoClass.toOrderIsoClass [Mul \u03b1] [Add \u03b1] [LE \u03b1]\n  [Mul \u03b2] [Add \u03b2] [LE \u03b2] [OrderRingIsoClass F \u03b1 \u03b2] : OrderIsoClass F \u03b1 \u03b2 :=\n  { \u2039OrderRingIsoClass F \u03b1 \u03b2\u203a with }", "start": [109, 1], "end": [111, 37], "kind": "commanddeclaration"}, {"full_name": "OrderRingIsoClass.toOrderRingHomClass", "code": "instance (priority := 100) OrderRingIsoClass.toOrderRingHomClass [NonAssocSemiring \u03b1]\n  [Preorder \u03b1] [NonAssocSemiring \u03b2] [Preorder \u03b2] [OrderRingIsoClass F \u03b1 \u03b2] :\n    OrderRingHomClass F \u03b1 \u03b2 :=\n  { monotone := fun f _ _ => (map_le_map_iff f).2\n    }", "start": [115, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHomClass.toOrderRingHom", "code": "@[coe]\ndef OrderRingHomClass.toOrderRingHom [NonAssocSemiring \u03b1] [Preorder \u03b1] [NonAssocSemiring \u03b2]\n    [Preorder \u03b2] [OrderRingHomClass F \u03b1 \u03b2] (f : F) : \u03b1 \u2192+*o \u03b2 :=\n{ (f : \u03b1 \u2192+* \u03b2) with monotone' := monotone f}", "start": [125, 1], "end": [130, 46], "kind": "commanddeclaration"}, {"full_name": "OrderRingIsoClass.toOrderRingIso", "code": "@[coe]\ndef OrderRingIsoClass.toOrderRingIso [Mul \u03b1] [Add \u03b1] [LE \u03b1] [Mul \u03b2] [Add \u03b2] [LE \u03b2]\n    [OrderRingIsoClass F \u03b1 \u03b2] (f : F) : \u03b1 \u2243+*o \u03b2 :=\n{ (f : \u03b1 \u2243+* \u03b2) with map_le_map_iff' := map_le_map_iff f}", "start": [139, 1], "end": [144, 58], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toOrderAddMonoidHom", "code": "def toOrderAddMonoidHom (f : \u03b1 \u2192+*o \u03b2) : \u03b1 \u2192+o \u03b2 :=\n  { f with }", "start": [163, 1], "end": [165, 13], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toOrderMonoidWithZeroHom", "code": "def toOrderMonoidWithZeroHom (f : \u03b1 \u2192+*o \u03b2) : \u03b1 \u2192*\u2080o \u03b2 :=\n  { f with }", "start": [168, 1], "end": [170, 13], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toFun_eq_coe", "code": "theorem toFun_eq_coe (f : \u03b1 \u2192+*o \u03b2) : f.toFun = f", "start": [192, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192+*o \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [196, 1], "end": [198, 20], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toRingHom_eq_coe", "code": "@[simp]\ntheorem toRingHom_eq_coe (f : \u03b1 \u2192+*o \u03b2) : f.toRingHom = f", "start": [201, 1], "end": [203, 27], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toOrderAddMonoidHom_eq_coe", "code": "@[simp]\ntheorem toOrderAddMonoidHom_eq_coe (f : \u03b1 \u2192+*o \u03b2) : f.toOrderAddMonoidHom = f", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.toOrderMonoidWithZeroHom_eq_coe", "code": "@[simp]\ntheorem toOrderMonoidWithZeroHom_eq_coe (f : \u03b1 \u2192+*o \u03b2) : f.toOrderMonoidWithZeroHom = f", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_coe_ringHom", "code": "@[simp]\ntheorem coe_coe_ringHom (f : \u03b1 \u2192+*o \u03b2) : \u21d1(f : \u03b1 \u2192+* \u03b2) = f", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_coe_orderAddMonoidHom", "code": "@[simp]\ntheorem coe_coe_orderAddMonoidHom (f : \u03b1 \u2192+*o \u03b2) : \u21d1(f : \u03b1 \u2192+o \u03b2) = f", "start": [221, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_coe_orderMonoidWithZeroHom", "code": "@[simp]\ntheorem coe_coe_orderMonoidWithZeroHom (f : \u03b1 \u2192+*o \u03b2) : \u21d1(f : \u03b1 \u2192*\u2080o \u03b2) = f", "start": [226, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_ringHom_apply", "code": "@[norm_cast]\ntheorem coe_ringHom_apply (f : \u03b1 \u2192+*o \u03b2) (a : \u03b1) : (f : \u03b1 \u2192+* \u03b2) a = f a", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_orderAddMonoidHom_apply", "code": "@[norm_cast]\ntheorem coe_orderAddMonoidHom_apply (f : \u03b1 \u2192+*o \u03b2) (a : \u03b1) : (f : \u03b1 \u2192+o \u03b2) a = f a", "start": [236, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_orderMonoidWithZeroHom_apply", "code": "@[norm_cast]\ntheorem coe_orderMonoidWithZeroHom_apply (f : \u03b1 \u2192+*o \u03b2) (a : \u03b1) : (f : \u03b1 \u2192*\u2080o \u03b2) a = f a", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.copy", "code": "protected def copy (f : \u03b1 \u2192+*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192+*o \u03b2 :=\n  { f.toRingHom.copy f' h, f.toOrderAddMonoidHom.copy f' h with }", "start": [246, 1], "end": [249, 66], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192+*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192+*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [257, 1], "end": [258, 17], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.id", "code": "protected def id : \u03b1 \u2192+*o \u03b1 :=\n  { RingHom.id _, OrderHom.id with }", "start": [263, 1], "end": [265, 37], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(OrderRingHom.id \u03b1) = id", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : OrderRingHom.id \u03b1 a = a", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_ringHom_id", "code": "@[simp]\ntheorem coe_ringHom_id : (OrderRingHom.id \u03b1 : \u03b1 \u2192+* \u03b1) = RingHom.id \u03b1", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_orderAddMonoidHom_id", "code": "@[simp]\ntheorem coe_orderAddMonoidHom_id : (OrderRingHom.id \u03b1 : \u03b1 \u2192+o \u03b1) = OrderAddMonoidHom.id \u03b1", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_orderMonoidWithZeroHom_id", "code": "@[simp]\ntheorem coe_orderMonoidWithZeroHom_id :\n    (OrderRingHom.id \u03b1 : \u03b1 \u2192*\u2080o \u03b1) = OrderMonoidWithZeroHom.id \u03b1", "start": [293, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.comp", "code": "protected def comp (f : \u03b2 \u2192+*o \u03b3) (g : \u03b1 \u2192+*o \u03b2) : \u03b1 \u2192+*o \u03b3 :=\n  { f.toRingHom.comp g.toRingHom, f.toOrderAddMonoidHom.comp g.toOrderAddMonoidHom with }", "start": [299, 1], "end": [301, 90], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : \u03b2 \u2192+*o \u03b3) (g : \u03b1 \u2192+*o \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : \u03b2 \u2192+*o \u03b3) (g : \u03b1 \u2192+*o \u03b2) (a : \u03b1) : f.comp g a = f (g a)", "start": [309, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.comp_assoc", "code": "theorem comp_assoc (f : \u03b3 \u2192+*o \u03b4) (g : \u03b2 \u2192+*o \u03b3) (h : \u03b1 \u2192+*o \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192+*o \u03b2) : f.comp (OrderRingHom.id \u03b1) = f", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192+*o \u03b2) : (OrderRingHom.id \u03b2).comp f = f", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {f\u2081 f\u2082 : \u03b2 \u2192+*o \u03b3} {g : \u03b1 \u2192+*o \u03b2} (hg : Surjective g) :\n    f\u2081.comp g = f\u2082.comp g \u2194 f\u2081 = f\u2082", "start": [329, 1], "end": [332, 75], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {f : \u03b2 \u2192+*o \u03b3} {g\u2081 g\u2082 : \u03b1 \u2192+*o \u03b2} (hf : Injective f) :\n    f.comp g\u2081 = f.comp g\u2082 \u2194 g\u2081 = g\u2082", "start": [335, 1], "end": [338, 81], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toOrderIso", "code": "@[coe]\ndef toOrderIso (f : \u03b1 \u2243+*o \u03b2) : \u03b1 \u2243o \u03b2 :=\n  \u27e8f.toRingEquiv.toEquiv, f.map_le_map_iff'\u27e9", "start": [362, 1], "end": [366, 45], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toFun_eq_coe", "code": "theorem toFun_eq_coe (f : \u03b1 \u2243+*o \u03b2) : f.toFun = f", "start": [384, 1], "end": [390, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2243+*o \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [393, 1], "end": [395, 20], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_mk", "code": "@[simp]\ntheorem coe_mk (e : \u03b1 \u2243+* \u03b2) (h) : \u21d1(\u27e8e, h\u27e9 : \u03b1 \u2243+*o \u03b2) = e", "start": [398, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.mk_coe", "code": "@[simp]\ntheorem mk_coe (e : \u03b1 \u2243+*o \u03b2) (h) : (\u27e8e, h\u27e9 : \u03b1 \u2243+*o \u03b2) = e", "start": [403, 1], "end": [405, 19], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toRingEquiv_eq_coe", "code": "@[simp]\ntheorem toRingEquiv_eq_coe (f : \u03b1 \u2243+*o \u03b2) : f.toRingEquiv = f", "start": [408, 1], "end": [410, 29], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toOrderIso_eq_coe", "code": "@[simp]\ntheorem toOrderIso_eq_coe (f : \u03b1 \u2243+*o \u03b2) : f.toOrderIso = f", "start": [413, 1], "end": [415, 19], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_toRingEquiv", "code": "@[simp, norm_cast]\ntheorem coe_toRingEquiv (f : \u03b1 \u2243+*o \u03b2) : \u21d1(f : \u03b1 \u2243+* \u03b2) = f", "start": [418, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_toOrderIso", "code": "@[simp, norm_cast]\ntheorem coe_toOrderIso (f : \u03b1 \u2243+*o \u03b2) : FunLike.coe (f : \u03b1 \u2243o \u03b2) = f", "start": [424, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.refl", "code": "@[refl]\nprotected def refl : \u03b1 \u2243+*o \u03b1 :=\n  \u27e8RingEquiv.refl \u03b1, Iff.rfl\u27e9", "start": [431, 1], "end": [434, 30], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : \u03b1) : OrderRingIso.refl \u03b1 x = x", "start": [440, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_ringEquiv_refl", "code": "@[simp]\ntheorem coe_ringEquiv_refl : (OrderRingIso.refl \u03b1 : \u03b1 \u2243+* \u03b1) = RingEquiv.refl \u03b1", "start": [445, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_orderIso_refl", "code": "@[simp]\ntheorem coe_orderIso_refl : (OrderRingIso.refl \u03b1 : \u03b1 \u2243o \u03b1) = OrderIso.refl \u03b1", "start": [450, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.symm", "code": "@[symm]\nprotected def symm (e : \u03b1 \u2243+*o \u03b2) : \u03b2 \u2243+*o \u03b1 :=\n  \u27e8e.toRingEquiv.symm, by\n    intro a b\n    erw [\u2190 map_le_map_iff e, e.1.apply_symm_apply, e.1.apply_symm_apply]\u27e9", "start": [457, 1], "end": [462, 74], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.Simps.symm_apply", "code": "def Simps.symm_apply (e : \u03b1 \u2243+*o \u03b2) : \u03b2 \u2192 \u03b1 :=\n  e.symm", "start": [465, 1], "end": [467, 9], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : \u03b1 \u2243+*o \u03b2) : e.symm.symm = e", "start": [470, 1], "end": [472, 19], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.trans", "code": "@[trans]\nprotected def trans (f : \u03b1 \u2243+*o \u03b2) (g : \u03b2 \u2243+*o \u03b3) : \u03b1 \u2243+*o \u03b3 :=\n  \u27e8f.toRingEquiv.trans g.toRingEquiv, (map_le_map_iff g).trans (map_le_map_iff f)\u27e9", "start": [475, 1], "end": [478, 83], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.trans_toRingEquiv", "code": "theorem trans_toRingEquiv (f : \u03b1 \u2243+*o \u03b2) (g : \u03b2 \u2243+*o \u03b3) :\n    (OrderRingIso.trans f g).toRingEquiv = RingEquiv.trans f.toRingEquiv g.toRingEquiv", "start": [483, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.trans_toRingEquiv_aux", "code": "@[simp]\ntheorem trans_toRingEquiv_aux (f : \u03b1 \u2243+*o \u03b2) (g : \u03b2 \u2243+*o \u03b3) :\n    RingEquivClass.toRingEquiv (OrderRingIso.trans f g)\n      = RingEquiv.trans f.toRingEquiv g.toRingEquiv", "start": [487, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.trans_apply", "code": "@[simp]\ntheorem trans_apply (f : \u03b1 \u2243+*o \u03b2) (g : \u03b2 \u2243+*o \u03b3) (a : \u03b1) : f.trans g a = g (f a)", "start": [493, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : \u03b1 \u2243+*o \u03b2) : e.trans e.symm = OrderRingIso.refl \u03b1", "start": [498, 1], "end": [500, 17], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : \u03b1 \u2243+*o \u03b2) : e.symm.trans e = OrderRingIso.refl \u03b2", "start": [503, 1], "end": [505, 18], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.symm_bijective", "code": "theorem symm_bijective : Bijective (OrderRingIso.symm : \u03b1 \u2243+*o \u03b2 \u2192 \u03b2 \u2243+*o \u03b1)", "start": [508, 1], "end": [510, 36], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toOrderRingHom", "code": "def toOrderRingHom (f : \u03b1 \u2243+*o \u03b2) : \u03b1 \u2192+*o \u03b2 :=\n  \u27e8f.toRingEquiv.toRingHom, fun _ _ => (map_le_map_iff f).2\u27e9", "start": [520, 1], "end": [522, 61], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toOrderRingHom_eq_coe", "code": "@[simp]\ntheorem toOrderRingHom_eq_coe (f : \u03b1 \u2243+*o \u03b2) : f.toOrderRingHom = f", "start": [525, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_toOrderRingHom", "code": "@[simp, norm_cast]\ntheorem coe_toOrderRingHom (f : \u03b1 \u2243+*o \u03b2) : \u21d1(f : \u03b1 \u2192+*o \u03b2) = f", "start": [530, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.coe_toOrderRingHom_refl", "code": "@[simp]\ntheorem coe_toOrderRingHom_refl : (OrderRingIso.refl \u03b1 : \u03b1 \u2192+*o \u03b1) = OrderRingHom.id \u03b1", "start": [535, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.toOrderRingHom_injective", "code": "theorem toOrderRingHom_injective : Injective (toOrderRingHom : \u03b1 \u2243+*o \u03b2 \u2192 \u03b1 \u2192+*o \u03b2)", "start": [540, 1], "end": [541, 80], "kind": "commanddeclaration"}, {"full_name": "OrderRingHom.subsingleton", "code": "instance OrderRingHom.subsingleton [LinearOrderedField \u03b1] [LinearOrderedField \u03b2] [Archimedean \u03b2] :\n    Subsingleton (\u03b1 \u2192+*o \u03b2) :=\n  \u27e8fun f g => by\n    ext x\n    by_contra' h' : f x \u2260 g x\n    wlog h : f x < g x generalizing \u03b1 \u03b2 with h\u2082\n    \u00b7 exact h\u2082 g f x (Ne.symm h') (h'.lt_or_lt.resolve_left h)\n    obtain \u27e8q, hf, hg\u27e9 := exists_rat_btwn h\n    rw [\u2190 map_ratCast f] at hf\n    rw [\u2190 map_ratCast g] at hg\n    exact\n      (lt_asymm ((OrderHomClass.mono g).reflect_lt hg) <|\n          (OrderHomClass.mono f).reflect_lt hf).elim\u27e9", "start": [556, 1], "end": [572, 54], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.subsingleton_right", "code": "instance OrderRingIso.subsingleton_right [LinearOrderedField \u03b1] [LinearOrderedField \u03b2]\n    [Archimedean \u03b2] : Subsingleton (\u03b1 \u2243+*o \u03b2) :=\n  OrderRingIso.toOrderRingHom_injective.subsingleton", "start": [575, 1], "end": [579, 53], "kind": "commanddeclaration"}, {"full_name": "OrderRingIso.subsingleton_left", "code": "instance OrderRingIso.subsingleton_left [LinearOrderedField \u03b1] [Archimedean \u03b1]\n    [LinearOrderedField \u03b2] : Subsingleton (\u03b1 \u2243+*o \u03b2) :=\n  OrderRingIso.symm_bijective.injective.subsingleton", "start": [582, 1], "end": [586, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Pointwise.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "Mathlib/Algebra/Bounds.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sSup_one", "code": "@[to_additive (attr := simp)]\ntheorem sSup_one : sSup (1 : Set \u03b1) = 1", "start": [41, 1], "end": [43, 17], "kind": "commanddeclaration"}, {"full_name": "sInf_one", "code": "@[to_additive (attr := simp)]\ntheorem sInf_one : sInf (1 : Set \u03b1) = 1", "start": [47, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "sSup_inv", "code": "@[to_additive]\ntheorem sSup_inv (s : Set \u03b1) : sSup s\u207b\u00b9 = (sInf s)\u207b\u00b9", "start": [60, 1], "end": [63, 43], "kind": "commanddeclaration"}, {"full_name": "sInf_inv", "code": "@[to_additive]\ntheorem sInf_inv (s : Set \u03b1) : sInf s\u207b\u00b9 = (sSup s)\u207b\u00b9", "start": [67, 1], "end": [70, 43], "kind": "commanddeclaration"}, {"full_name": "sSup_mul", "code": "@[to_additive]\ntheorem sSup_mul : sSup (s * t) = sSup s * sSup t", "start": [74, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "sInf_mul", "code": "@[to_additive]\ntheorem sInf_mul : sInf (s * t) = sInf s * sInf t", "start": [81, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "sSup_div", "code": "@[to_additive]\ntheorem sSup_div : sSup (s / t) = sSup s / sInf t", "start": [88, 1], "end": [89, 101], "kind": "commanddeclaration"}, {"full_name": "sInf_div", "code": "@[to_additive]\ntheorem sInf_div : sInf (s / t) = sInf s / sSup t", "start": [93, 1], "end": [94, 101], "kind": "commanddeclaration"}, {"full_name": "csSup_one", "code": "@[to_additive (attr := simp)]\ntheorem csSup_one : sSup (1 : Set \u03b1) = 1", "start": [110, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "csInf_one", "code": "@[to_additive (attr := simp)]\ntheorem csInf_one : sInf (1 : Set \u03b1) = 1", "start": [116, 1], "end": [118, 20], "kind": "commanddeclaration"}, {"full_name": "csSup_inv", "code": "@[to_additive]\ntheorem csSup_inv (hs\u2080 : s.Nonempty) (hs\u2081 : BddBelow s) : sSup s\u207b\u00b9 = (sInf s)\u207b\u00b9", "start": [129, 1], "end": [132, 51], "kind": "commanddeclaration"}, {"full_name": "csInf_inv", "code": "@[to_additive]\ntheorem csInf_inv (hs\u2080 : s.Nonempty) (hs\u2081 : BddAbove s) : sInf s\u207b\u00b9 = (sSup s)\u207b\u00b9", "start": [136, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "csSup_mul", "code": "@[to_additive]\ntheorem csSup_mul (hs\u2080 : s.Nonempty) (hs\u2081 : BddAbove s) (ht\u2080 : t.Nonempty) (ht\u2081 : BddAbove t) :\n    sSup (s * t) = sSup s * sSup t", "start": [143, 1], "end": [147, 72], "kind": "commanddeclaration"}, {"full_name": "csInf_mul", "code": "@[to_additive]\ntheorem csInf_mul (hs\u2080 : s.Nonempty) (hs\u2081 : BddBelow s) (ht\u2080 : t.Nonempty) (ht\u2081 : BddBelow t) :\n    sInf (s * t) = sInf s * sInf t", "start": [151, 1], "end": [155, 77], "kind": "commanddeclaration"}, {"full_name": "csSup_div", "code": "@[to_additive]\ntheorem csSup_div (hs\u2080 : s.Nonempty) (hs\u2081 : BddAbove s) (ht\u2080 : t.Nonempty) (ht\u2081 : BddBelow t) :\n    sSup (s / t) = sSup s / sInf t", "start": [159, 1], "end": [162, 92], "kind": "commanddeclaration"}, {"full_name": "csInf_div", "code": "@[to_additive]\ntheorem csInf_div (hs\u2080 : s.Nonempty) (hs\u2081 : BddBelow s) (ht\u2080 : t.Nonempty) (ht\u2081 : BddAbove t) :\n    sInf (s / t) = sInf s / sSup t", "start": [166, 1], "end": [169, 92], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Ioo", "code": "theorem smul_Ioo : r \u2022 Ioo a b = Ioo (r \u2022 a) (r \u2022 b)", "start": [185, 1], "end": [196, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Icc", "code": "theorem smul_Icc : r \u2022 Icc a b = Icc (r \u2022 a) (r \u2022 b)", "start": [199, 1], "end": [210, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Ico", "code": "theorem smul_Ico : r \u2022 Ico a b = Ico (r \u2022 a) (r \u2022 b)", "start": [213, 1], "end": [224, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Ioc", "code": "theorem smul_Ioc : r \u2022 Ioc a b = Ioc (r \u2022 a) (r \u2022 b)", "start": [227, 1], "end": [238, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Ioi", "code": "theorem smul_Ioi : r \u2022 Ioi a = Ioi (r \u2022 a)", "start": [241, 1], "end": [251, 42], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Iio", "code": "theorem smul_Iio : r \u2022 Iio a = Iio (r \u2022 a)", "start": [254, 1], "end": [264, 42], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Ici", "code": "theorem smul_Ici : r \u2022 Ici a = Ici (r \u2022 a)", "start": [267, 1], "end": [277, 42], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.smul_Iic", "code": "theorem smul_Iic : r \u2022 Iic a = Iic (r \u2022 a)", "start": [280, 1], "end": [290, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Topology/MetricSpace/Gluing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GromovHausdorff.ProdSpaceFun", "code": "@[reducible]\nprivate def ProdSpaceFun : Type _ :=\n  (X \u2295 Y) \u00d7 (X \u2295 Y) \u2192 \u211d", "start": [65, 1], "end": [67, 24], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.Cb", "code": "@[reducible]\nprivate def Cb : Type _ :=\n  BoundedContinuousFunction ((X \u2295 Y) \u00d7 (X \u2295 Y)) \u211d", "start": [69, 1], "end": [71, 50], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.maxVar", "code": "private def maxVar : \u211d\u22650 :=\n  2 * \u27e8diam (univ : Set X), diam_nonneg\u27e9 + 1 + 2 * \u27e8diam (univ : Set Y), diam_nonneg\u27e9", "start": [73, 1], "end": [74, 86], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.one_le_maxVar", "code": "private theorem one_le_maxVar : 1 \u2264 maxVar X Y", "start": [76, 1], "end": [79, 90], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates", "code": "def candidates : Set (ProdSpaceFun X Y) :=\n  { f | (((((\u2200 x y : X, f (Sum.inl x, Sum.inl y) = dist x y) \u2227\n      \u2200 x y : Y, f (Sum.inr x, Sum.inr y) = dist x y) \u2227\n      \u2200 x y, f (x, y) = f (y, x)) \u2227\n      \u2200 x y z, f (x, z) \u2264 f (x, y) + f (y, z)) \u2227\n      \u2200 x, f (x, x) = 0) \u2227\n      \u2200 x y, f (x, y) \u2264 maxVar X Y }", "start": [81, 1], "end": [89, 37], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesB", "code": "private def candidatesB : Set (Cb X Y) :=\n  { f : Cb X Y | (f : _ \u2192 \u211d) \u2208 candidates X Y }", "start": [92, 1], "end": [94, 48], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.maxVar_bound", "code": "private theorem maxVar_bound : dist x y \u2264 maxVar X Y", "start": [105, 1], "end": [118, 88], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_symm", "code": "private theorem candidates_symm (fA : f \u2208 candidates X Y) : f (x, y) = f (y, x)", "start": [120, 1], "end": [121, 17], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_triangle", "code": "private theorem candidates_triangle (fA : f \u2208 candidates X Y) : f (x, z) \u2264 f (x, y) + f (y, z)", "start": [123, 1], "end": [124, 17], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_refl", "code": "private theorem candidates_refl (fA : f \u2208 candidates X Y) : f (x, x) = 0", "start": [126, 1], "end": [127, 11], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_nonneg", "code": "private theorem candidates_nonneg (fA : f \u2208 candidates X Y) : 0 \u2264 f (x, y)", "start": [129, 1], "end": [136, 11], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_dist_inl", "code": "private theorem candidates_dist_inl (fA : f \u2208 candidates X Y) (x y : X) :\n    f (inl x, inl y) = dist x y", "start": [138, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_dist_inr", "code": "private theorem candidates_dist_inr (fA : f \u2208 candidates X Y) (x y : Y) :\n    f (inr x, inr y) = dist x y", "start": [142, 1], "end": [144, 19], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_le_maxVar", "code": "private theorem candidates_le_maxVar (fA : f \u2208 candidates X Y) : f (x, y) \u2264 maxVar X Y", "start": [146, 1], "end": [147, 11], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_dist_bound", "code": "private theorem candidates_dist_bound (fA : f \u2208 candidates X Y) :\n    \u2200 {x y : X \u2295 Y}, f (x, y) \u2264 maxVar X Y * dist x y", "start": [149, 1], "end": [177, 82], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_lipschitz_aux", "code": "private theorem candidates_lipschitz_aux (fA : f \u2208 candidates X Y) :\n    f (x, y) - f (z, t) \u2264 2 * maxVar X Y * dist (x, y) (z, t)", "start": [179, 1], "end": [195, 51], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidates_lipschitz", "code": "private theorem candidates_lipschitz (fA : f \u2208 candidates X Y) :\n    LipschitzWith (2 * maxVar X Y) f", "start": [197, 1], "end": [205, 36], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesBOfCandidates", "code": "def candidatesBOfCandidates (f : ProdSpaceFun X Y) (fA : f \u2208 candidates X Y) : Cb X Y :=\n  BoundedContinuousFunction.mkOfCompact \u27e8f, (candidates_lipschitz fA).continuous\u27e9", "start": [207, 1], "end": [209, 82], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesBOfCandidates_mem", "code": "theorem candidatesBOfCandidates_mem (f : ProdSpaceFun X Y) (fA : f \u2208 candidates X Y) :\n    candidatesBOfCandidates f fA \u2208 candidatesB X Y", "start": [212, 1], "end": [214, 5], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.dist_mem_candidates", "code": "private theorem dist_mem_candidates :\n    (fun p : (X \u2295 Y) \u00d7 (X \u2295 Y) => dist p.1 p.2) \u2208 candidates X Y", "start": [217, 1], "end": [222, 41], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesBDist", "code": "def candidatesBDist (X : Type u) (Y : Type v) [MetricSpace X] [CompactSpace X] [Inhabited X]\n    [MetricSpace Y] [CompactSpace Y] [Inhabited Y] : Cb X Y :=\n  candidatesBOfCandidates _ dist_mem_candidates", "start": [224, 1], "end": [227, 48], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesBDist_mem_candidatesB", "code": "theorem candidatesBDist_mem_candidatesB : candidatesBDist X Y \u2208 candidatesB X Y", "start": [230, 1], "end": [231, 34], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.candidatesB_nonempty", "code": "private theorem candidatesB_nonempty : (candidatesB X Y).Nonempty", "start": [234, 1], "end": [235, 39], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.closed_candidatesB", "code": "private theorem closed_candidatesB : IsClosed (candidatesB X Y)", "start": [237, 1], "end": [265, 93], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.isCompact_candidatesB", "code": "private theorem isCompact_candidatesB : IsCompact (candidatesB X Y)", "start": [267, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD", "code": "def HD (f : Cb X Y) :=\n  max (\u2a06 x, \u2a05 y, f (inl x, inr y)) (\u2a06 y, \u2a05 x, f (inl x, inr y))", "start": [281, 1], "end": [285, 64], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_below_aux1", "code": "theorem HD_below_aux1 {f : Cb X Y} (C : \u211d) {x : X} :\n    BddBelow (range fun y : Y => f (inl x, inr y) + C)", "start": [293, 1], "end": [296, 97], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_bound_aux1", "code": "private theorem HD_bound_aux1 (f : Cb X Y) (C : \u211d) :\n    BddAbove (range fun x : X => \u2a05 y, f (inl x, inr y) + C)", "start": [299, 1], "end": [305, 74], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_below_aux2", "code": "theorem HD_below_aux2 {f : Cb X Y} (C : \u211d) {y : Y} :\n    BddBelow (range fun x : X => f (inl x, inr y) + C)", "start": [307, 1], "end": [310, 97], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_bound_aux2", "code": "private theorem HD_bound_aux2 (f : Cb X Y) (C : \u211d) :\n    BddAbove (range fun y : Y => \u2a05 x, f (inl x, inr y) + C)", "start": [313, 1], "end": [319, 74], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_candidatesBDist_le", "code": "theorem HD_candidatesBDist_le :\n    HD (candidatesBDist X Y) \u2264 diam (univ : Set X) + 1 + diam (univ : Set Y)", "start": [321, 1], "end": [343, 23], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_lipschitz_aux1", "code": "private theorem HD_lipschitz_aux1 (f g : Cb X Y) :\n    (\u2a06 x, \u2a05 y, f (inl x, inr y)) \u2264 (\u2a06 x, \u2a05 y, g (inl x, inr y)) + dist f g", "start": [348, 1], "end": [374, 32], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_lipschitz_aux2", "code": "private theorem HD_lipschitz_aux2 (f g : Cb X Y) :\n    (\u2a06 y, \u2a05 x, f (inl x, inr y)) \u2264 (\u2a06 y, \u2a05 x, g (inl x, inr y)) + dist f g", "start": [376, 1], "end": [402, 17], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_lipschitz_aux3", "code": "private theorem HD_lipschitz_aux3 (f g : Cb X Y) : HD f \u2264 HD g + dist f g", "start": [404, 1], "end": [406, 79], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_continuous", "code": "private theorem HD_continuous : Continuous (HD : Cb X Y \u2192 \u211d)", "start": [408, 1], "end": [410, 71], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.exists_minimizer", "code": "private theorem exists_minimizer : \u2203 f \u2208 candidatesB X Y, \u2200 g \u2208 candidatesB X Y, HD f \u2264 HD g", "start": [422, 1], "end": [423, 89], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.optimalGHDist", "code": "private def optimalGHDist : Cb X Y :=\n  Classical.choose (exists_minimizer X Y)", "start": [425, 1], "end": [426, 42], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.optimalGHDist_mem_candidatesB", "code": "private theorem optimalGHDist_mem_candidatesB : optimalGHDist X Y \u2208 candidatesB X Y", "start": [428, 1], "end": [430, 13], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.HD_optimalGHDist_le", "code": "private theorem HD_optimalGHDist_le (g : Cb X Y) (hg : g \u2208 candidatesB X Y) :\n    HD (optimalGHDist X Y) \u2264 HD g", "start": [432, 1], "end": [435, 10], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.premetricOptimalGHDist", "code": "def premetricOptimalGHDist : PseudoMetricSpace (X \u2295 Y) where\n  dist p q := optimalGHDist X Y (p, q)\n  dist_self x := candidates_refl (optimalGHDist_mem_candidatesB X Y)\n  dist_comm x y := candidates_symm (optimalGHDist_mem_candidatesB X Y)\n  dist_triangle x y z := candidates_triangle (optimalGHDist_mem_candidatesB X Y)\n  edist_dist x y := by\n    simp only\n    congr\n    simp only [max, left_eq_sup]\n    exact candidates_nonneg (optimalGHDist_mem_candidatesB X Y)", "start": [437, 1], "end": [450, 64], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.OptimalGHCoupling", "code": "def OptimalGHCoupling : Type _ :=\n  @UniformSpace.SeparationQuotient (X \u2295 Y) (premetricOptimalGHDist X Y).toUniformSpace", "start": [455, 1], "end": [458, 87], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.optimalGHInjl", "code": "def optimalGHInjl (x : X) : OptimalGHCoupling X Y :=\n  Quotient.mk'' (inl x)", "start": [465, 1], "end": [467, 24], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.isometry_optimalGHInjl", "code": "theorem isometry_optimalGHInjl : Isometry (optimalGHInjl X Y)", "start": [470, 1], "end": [472, 93], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.optimalGHInjr", "code": "def optimalGHInjr (y : Y) : OptimalGHCoupling X Y :=\n  Quotient.mk'' (inr y)", "start": [475, 1], "end": [477, 24], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.isometry_optimalGHInjr", "code": "theorem isometry_optimalGHInjr : Isometry (optimalGHInjr X Y)", "start": [480, 1], "end": [482, 93], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.compactSpace_optimalGHCoupling", "code": "instance compactSpace_optimalGHCoupling : CompactSpace (OptimalGHCoupling X Y) := \u27e8by\n  rw [\u2190 range_quotient_mk']\n  exact isCompact_range (continuous_sum_dom.2\n    \u27e8(isometry_optimalGHInjl X Y).continuous, (isometry_optimalGHInjr X Y).continuous\u27e9)\u27e9", "start": [485, 1], "end": [489, 89], "kind": "commanddeclaration"}, {"full_name": "GromovHausdorff.hausdorffDist_optimal_le_HD", "code": "theorem hausdorffDist_optimal_le_HD {f} (h : f \u2208 candidatesB X Y) :\n    hausdorffDist (range (optimalGHInjl X Y)) (range (optimalGHInjr X Y)) \u2264 HD f", "start": [492, 1], "end": [522, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Kuratowski.lean", "imports": ["Mathlib/Topology/Sets/Compacts.lean", "Mathlib/Analysis/NormedSpace/lpSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "KuratowskiEmbedding.embeddingOfSubset", "code": "def embeddingOfSubset : \u2113^\u221e(\u2115) :=\n  \u27e8fun n => dist a (x n) - dist (x 0) (x n), by\n    apply mem\u2113p_infty\n    use dist a (x 0)\n    rintro - \u27e8n, rfl\u27e9\n    exact abs_dist_sub_le _ _ _\u27e9", "start": [39, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "KuratowskiEmbedding.embeddingOfSubset_coe", "code": "theorem embeddingOfSubset_coe : embeddingOfSubset x a n = dist a (x n) - dist (x 0) (x n)", "start": [50, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "KuratowskiEmbedding.embeddingOfSubset_dist_le", "code": "theorem embeddingOfSubset_dist_le (a b : \u03b1) :\n    dist (embeddingOfSubset x a) (embeddingOfSubset x b) \u2264 dist a b", "start": [54, 1], "end": [60, 7], "kind": "commanddeclaration"}, {"full_name": "KuratowskiEmbedding.embeddingOfSubset_isometry", "code": "theorem embeddingOfSubset_isometry (H : DenseRange x) : Isometry (embeddingOfSubset x)", "start": [63, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "KuratowskiEmbedding.exists_isometric_embedding", "code": "theorem exists_isometric_embedding (\u03b1 : Type u) [MetricSpace \u03b1] [SeparableSpace \u03b1] :\n    \u2203 f : \u03b1 \u2192 \u2113^\u221e(\u2115), Isometry f", "start": [93, 1], "end": [105, 85], "kind": "commanddeclaration"}, {"full_name": "kuratowskiEmbedding", "code": "def kuratowskiEmbedding (\u03b1 : Type u) [MetricSpace \u03b1] [SeparableSpace \u03b1] : \u03b1 \u2192 \u2113^\u221e(\u2115) :=\n  Classical.choose (KuratowskiEmbedding.exists_isometric_embedding \u03b1)", "start": [112, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "kuratowskiEmbedding.isometry", "code": "protected theorem kuratowskiEmbedding.isometry (\u03b1 : Type u) [MetricSpace \u03b1] [SeparableSpace \u03b1] :\n    Isometry (kuratowskiEmbedding \u03b1)", "start": [118, 1], "end": [123, 55], "kind": "commanddeclaration"}, {"full_name": "NonemptyCompacts.kuratowskiEmbedding", "code": "nonrec def NonemptyCompacts.kuratowskiEmbedding (\u03b1 : Type u) [MetricSpace \u03b1] [CompactSpace \u03b1]\n    [Nonempty \u03b1] : NonemptyCompacts \u2113^\u221e(\u2115) where\n  carrier := range (kuratowskiEmbedding \u03b1)\n  isCompact' := isCompact_range (kuratowskiEmbedding.isometry \u03b1).continuous\n  nonempty' := range_nonempty _", "start": [126, 1], "end": [131, 32], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.extend_lp_infty", "code": "theorem LipschitzOnWith.extend_lp_infty [PseudoMetricSpace \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u2113^\u221e(\u03b9)}\n    {K : \u211d\u22650} (hfl : LipschitzOnWith K f s): \u2203 g : \u03b1 \u2192 \u2113^\u221e(\u03b9), LipschitzWith K g \u2227 EqOn f g s", "start": [134, 1], "end": [167, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Closeds.lean", "imports": ["Mathlib/Topology/Sets/Compacts.lean", "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EMetric.Closeds.emetricSpace", "code": "instance Closeds.emetricSpace : EMetricSpace (Closeds \u03b1) where\n  edist s t := hausdorffEdist (s : Set \u03b1) t\n  edist_self s := hausdorffEdist_self\n  edist_comm s t := hausdorffEdist_comm\n  edist_triangle s t u := hausdorffEdist_triangle\n  eq_of_edist_eq_zero {s t} h :=\n    Closeds.ext <| (hausdorffEdist_zero_iff_eq_of_closed s.closed t.closed).1 h", "start": [42, 1], "end": [50, 80], "kind": "commanddeclaration"}, {"full_name": "EMetric.continuous_infEdist_hausdorffEdist", "code": "theorem continuous_infEdist_hausdorffEdist :\n    Continuous fun p : \u03b1 \u00d7 Closeds \u03b1 => infEdist p.1 p.2", "start": [53, 1], "end": [67, 78], "kind": "commanddeclaration"}, {"full_name": "EMetric.isClosed_subsets_of_isClosed", "code": "theorem isClosed_subsets_of_isClosed (hs : IsClosed s) :\n    IsClosed { t : Closeds \u03b1 | (t : Set \u03b1) \u2286 s }", "start": [71, 1], "end": [85, 30], "kind": "commanddeclaration"}, {"full_name": "EMetric.Closeds.edist_eq", "code": "theorem Closeds.edist_eq {s t : Closeds \u03b1} : edist s t = hausdorffEdist (s : Set \u03b1) t", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "EMetric.Closeds.completeSpace", "code": "instance Closeds.completeSpace [CompleteSpace \u03b1] : CompleteSpace (Closeds \u03b1) := by\n  \n  let B : \u2115 \u2192 \u211d\u22650\u221e := fun n => 2\u207b\u00b9 ^ n\n  have B_pos : \u2200 n, (0 : \u211d\u22650\u221e) < B n := by simp [ENNReal.pow_pos]\n  have B_ne_top : \u2200 n, B n \u2260 \u22a4 := by simp [ENNReal.pow_ne_top]\n  \n  refine' complete_of_convergent_controlled_sequences B B_pos fun s hs => _\n  let t0 := \u22c2 n, closure (\u22c3 m \u2265 n, s m : Set \u03b1)\n  let t : Closeds \u03b1 := \u27e8t0, isClosed_iInter fun _ => isClosed_closure\u27e9\n  use t\n  have I1 : \u2200 n, \u2200 x \u2208 s n, \u2203 y \u2208 t0, edist x y \u2264 2 * B n := by\n    \n    intro n x hx\n    obtain \u27e8z, hz\u2080, hz\u27e9 :\n      \u2203 z : \u2200 l, s (n + l), (z 0 : \u03b1) = x \u2227 \u2200 k, edist (z k : \u03b1) (z (k + 1) : \u03b1) \u2264 B n / 2 ^ k := by\n      have : \u2200 (l) (z : s (n + l)), \u2203 z' : s (n + l + 1), edist (z : \u03b1) z' \u2264 B n / 2 ^ l := by\n        intro l z\n        obtain \u27e8z', z'_mem, hz'\u27e9 : \u2203 z' \u2208 s (n + l + 1), edist (z : \u03b1) z' < B n / 2 ^ l := by\n          refine' exists_edist_lt_of_hausdorffEdist_lt _ _\n          \u00b7 exact (s (n + l) : Set \u03b1)\n          \u00b7 exact z.2\n          simp only [ENNReal.inv_pow, div_eq_mul_inv]\n          rw [\u2190 pow_add]\n          apply hs <;> simp\n        exact \u27e8\u27e8z', z'_mem\u27e9, le_of_lt hz'\u27e9\n      use fun k => Nat.recOn k \u27e8x, hx\u27e9 fun l z => choose (this l z)\n      simp only [Nat.add_zero, Nat.zero_eq, Nat.rec_zero, Nat.rec_add_one, true_and]\n      exact fun k => choose_spec (this k _)\n    have : CauchySeq fun k => (z k : \u03b1) := cauchySeq_of_edist_le_geometric_two (B n) (B_ne_top n) hz\n    rcases cauchySeq_tendsto_of_complete this with \u27e8y, y_lim\u27e9\n    use y\n    have : y \u2208 t0 :=\n      mem_iInter.2 fun k =>\n        mem_closure_of_tendsto y_lim\n          (by\n            simp only [exists_prop, Set.mem_iUnion, Filter.eventually_atTop, Set.mem_preimage,\n              Set.preimage_iUnion]\n            exact \u27e8k, fun m hm => \u27e8n + m, zero_add k \u25b8 add_le_add (zero_le n) hm, (z m).2\u27e9\u27e9)\n    use this\n    rw [\u2190 hz\u2080]\n    exact edist_le_of_edist_le_geometric_two_of_tendsto\u2080 (B n) hz y_lim\n  have I2 : \u2200 n, \u2200 x \u2208 t0, \u2203 y \u2208 s n, edist x y \u2264 2 * B n := by\n    \n    intro n x xt0\n    have : x \u2208 closure (\u22c3 m \u2265 n, s m : Set \u03b1) := by apply mem_iInter.1 xt0 n\n    rcases mem_closure_iff.1 this (B n) (B_pos n) with \u27e8z, hz, Dxz\u27e9\n    simp only [exists_prop, Set.mem_iUnion] at hz\n    rcases hz with \u27e8m, \u27e8m_ge_n, hm\u27e9\u27e9\n    have : hausdorffEdist (s m : Set \u03b1) (s n) < B n := hs n m n m_ge_n (le_refl n)\n    rcases exists_edist_lt_of_hausdorffEdist_lt hm this with \u27e8y, hy, Dzy\u27e9\n    exact\n      \u27e8y, hy,\n        calc\n          edist x y \u2264 edist x z + edist z y := edist_triangle _ _ _\n          _ \u2264 B n + B n := (add_le_add (le_of_lt Dxz) (le_of_lt Dzy))\n          _ = 2 * B n := (two_mul _).symm\n          \u27e9\n  have main : \u2200 n : \u2115, edist (s n) t \u2264 2 * B n := fun n =>\n    hausdorffEdist_le_of_mem_edist (I1 n) (I2 n)\n  refine' tendsto_atTop.2 fun \u03b5 \u03b5pos => _\n  have : Tendsto (fun n => 2 * B n) atTop (\ud835\udcdd (2 * 0)) :=\n    ENNReal.Tendsto.const_mul\n      (ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1 <| by simp [ENNReal.one_lt_two]) (Or.inr <| by simp)\n  rw [mul_zero] at this\n  obtain \u27e8N, hN\u27e9 : \u2203 N, \u2200 b \u2265 N, \u03b5 > 2 * B b :=\n    ((tendsto_order.1 this).2 \u03b5 \u03b5pos).exists_forall_of_atTop\n  exact \u27e8N, fun n hn => lt_of_le_of_lt (main n) (hN n hn)\u27e9", "start": [93, 1], "end": [191, 59], "kind": "commanddeclaration"}, {"full_name": "EMetric.Closeds.compactSpace", "code": "instance Closeds.compactSpace [CompactSpace \u03b1] : CompactSpace (Closeds \u03b1) :=\n  \u27e8by\n    \n    refine'\n      isCompact_of_totallyBounded_isClosed (EMetric.totallyBounded_iff.2 fun \u03b5 \u03b5pos => _)\n        isClosed_univ\n    rcases exists_between \u03b5pos with \u27e8\u03b4, \u03b4pos, \u03b4lt\u27e9\n    rcases EMetric.totallyBounded_iff.1\n        (isCompact_iff_totallyBounded_isComplete.1 (@isCompact_univ \u03b1 _ _)).1 \u03b4 \u03b4pos with\n      \u27e8s, fs, hs\u27e9\n    have main : \u2200 u : Set \u03b1, \u2203 (v : _) (_ : v \u2286 s), hausdorffEdist u v \u2264 \u03b4 := by\n      intro u\n      let v := { x : \u03b1 | x \u2208 s \u2227 \u2203 y \u2208 u, edist x y < \u03b4 }\n      exists v, (fun x hx => hx.1 : v \u2286 s)\n      refine' hausdorffEdist_le_of_mem_edist _ _\n      \u00b7 intro x hx\n        have : x \u2208 \u22c3 y \u2208 s, ball y \u03b4 := hs (by simp)\n        rcases mem_iUnion\u2082.1 this with \u27e8y, ys, dy\u27e9\n        have : edist y x < \u03b4 := by simp at dy; rwa [edist_comm] at dy\n        exact \u27e8y, \u27e8ys, \u27e8x, hx, this\u27e9\u27e9, le_of_lt dy\u27e9\n      \u00b7 rintro x \u27e8_, \u27e8y, yu, hy\u27e9\u27e9\n        exact \u27e8y, yu, le_of_lt hy\u27e9\n    let F := { f : Closeds \u03b1 | (f : Set \u03b1) \u2286 s }\n    refine' \u27e8F, _, fun u _ => _\u27e9\n    \u00b7 apply @Finite.of_finite_image _ _ F _\n      \u00b7 apply fs.finite_subsets.subset fun b => _\n        exact fun s => (s : Set \u03b1)\n        simp only [and_imp, Set.mem_image, Set.mem_setOf_eq, exists_imp]\n        intro _ x hx hx'\n        rwa [hx'] at hx\n      \u00b7 exact SetLike.coe_injective.injOn F\n    \u00b7 obtain \u27e8t0, t0s, Dut0\u27e9 := main u\n      have : IsClosed t0 := (fs.subset t0s).isCompact.isClosed\n      let t : Closeds \u03b1 := \u27e8t0, this\u27e9\n      have : t \u2208 F := t0s\n      have : edist u t < \u03b5 := lt_of_le_of_lt Dut0 \u03b4lt\n      apply mem_iUnion\u2082.2\n      exact \u27e8t, \u2039t \u2208 F\u203a, this\u27e9\u27e9", "start": [194, 1], "end": [240, 32], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.emetricSpace", "code": "instance NonemptyCompacts.emetricSpace : EMetricSpace (NonemptyCompacts \u03b1) where\n  edist s t := hausdorffEdist (s : Set \u03b1) t\n  edist_self s := hausdorffEdist_self\n  edist_comm s t := hausdorffEdist_comm\n  edist_triangle s t u := hausdorffEdist_triangle\n  eq_of_edist_eq_zero {s t} h := NonemptyCompacts.ext <| by\n    have : closure (s : Set \u03b1) = closure t := hausdorffEdist_zero_iff_closure_eq_closure.1 h\n    rwa [s.isCompact.isClosed.closure_eq, t.isCompact.isClosed.closure_eq] at this", "start": [243, 1], "end": [252, 83], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.ToCloseds.uniformEmbedding", "code": "theorem NonemptyCompacts.ToCloseds.uniformEmbedding :\n    UniformEmbedding (@NonemptyCompacts.toCloseds \u03b1 _ _)", "start": [255, 1], "end": [258, 43], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.isClosed_in_closeds", "code": "theorem NonemptyCompacts.isClosed_in_closeds [CompleteSpace \u03b1] :\n    IsClosed (range <| @NonemptyCompacts.toCloseds \u03b1 _ _)", "start": [261, 1], "end": [297, 30], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.completeSpace", "code": "instance NonemptyCompacts.completeSpace [CompleteSpace \u03b1] : CompleteSpace (NonemptyCompacts \u03b1) :=\n  (completeSpace_iff_isComplete_range\n        NonemptyCompacts.ToCloseds.uniformEmbedding.toUniformInducing).2 <|\n    NonemptyCompacts.isClosed_in_closeds.isComplete", "start": [300, 1], "end": [305, 52], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.compactSpace", "code": "instance NonemptyCompacts.compactSpace [CompactSpace \u03b1] : CompactSpace (NonemptyCompacts \u03b1) :=\n  \u27e8by\n    rw [NonemptyCompacts.ToCloseds.uniformEmbedding.embedding.isCompact_iff]\n    rw [image_univ]\n    exact NonemptyCompacts.isClosed_in_closeds.isCompact\u27e9", "start": [308, 1], "end": [314, 58], "kind": "commanddeclaration"}, {"full_name": "EMetric.NonemptyCompacts.secondCountableTopology", "code": "instance NonemptyCompacts.secondCountableTopology [SecondCountableTopology \u03b1] :\n    SecondCountableTopology (NonemptyCompacts \u03b1) :=\n  haveI : SeparableSpace (NonemptyCompacts \u03b1) := by\n    \n    rcases exists_countable_dense \u03b1 with \u27e8s, cs, s_dense\u27e9\n    let v0 := { t : Set \u03b1 | t.Finite \u2227 t \u2286 s }\n    let v : Set (NonemptyCompacts \u03b1) := { t : NonemptyCompacts \u03b1 | (t : Set \u03b1) \u2208 v0 }\n    refine' \u27e8\u27e8v, _, _\u27e9\u27e9\n    \u00b7 have : v0.Countable := countable_setOf_finite_subset cs\n      exact this.preimage SetLike.coe_injective\n    \u00b7 refine' fun t => mem_closure_iff.2 fun \u03b5 \u03b5pos => _\n      rcases exists_between \u03b5pos with \u27e8\u03b4, \u03b4pos, \u03b4lt\u27e9\n      have \u03b4pos' : 0 < \u03b4 / 2 := ENNReal.half_pos \u03b4pos.ne'\n      have Exy : \u2200 x, \u2203 y, y \u2208 s \u2227 edist x y < \u03b4 / 2 := by\n        intro x\n        rcases mem_closure_iff.1 (s_dense x) (\u03b4 / 2) \u03b4pos' with \u27e8y, ys, hy\u27e9\n        exact \u27e8y, \u27e8ys, hy\u27e9\u27e9\n      let F x := choose (Exy x)\n      have Fspec : \u2200 x, F x \u2208 s \u2227 edist x (F x) < \u03b4 / 2 := fun x => choose_spec (Exy x)\n      have : TotallyBounded (t : Set \u03b1) := t.isCompact.totallyBounded\n      rcases totallyBounded_iff.1 this (\u03b4 / 2) \u03b4pos' with \u27e8a, af, ta\u27e9\n      let b := F '' a\n      have : b.Finite := af.image _\n      have tb : \u2200 x \u2208 t, \u2203 y \u2208 b, edist x y < \u03b4 := by\n        intro x hx\n        rcases mem_iUnion\u2082.1 (ta hx) with \u27e8z, za, Dxz\u27e9\n        exists F z, mem_image_of_mem _ za\n        calc\n          edist x (F z) \u2264 edist x z + edist z (F z) := edist_triangle _ _ _\n          _ < \u03b4 / 2 + \u03b4 / 2 := (ENNReal.add_lt_add Dxz (Fspec z).2)\n          _ = \u03b4 := ENNReal.add_halves _\n      let c := { y \u2208 b | \u2203 x \u2208 t, edist x y < \u03b4 }\n      have : c.Finite := \u2039b.Finite\u203a.subset fun x hx => hx.1\n      have tc : \u2200 x \u2208 t, \u2203 y \u2208 c, edist x y \u2264 \u03b4 := by\n        intro x hx\n        rcases tb x hx with \u27e8y, yv, Dxy\u27e9\n        have : y \u2208 c := by simp [-mem_image]; exact \u27e8yv, \u27e8x, hx, Dxy\u27e9\u27e9\n        exact \u27e8y, this, le_of_lt Dxy\u27e9\n      have ct : \u2200 y \u2208 c, \u2203 x \u2208 t, edist y x \u2264 \u03b4 := by\n        rintro y \u27e8_, x, xt, Dyx\u27e9\n        have : edist y x \u2264 \u03b4 :=\n          calc\n            edist y x = edist x y := edist_comm _ _\n            _ \u2264 \u03b4 := le_of_lt Dyx\n        exact \u27e8x, xt, this\u27e9\n      have : hausdorffEdist (t : Set \u03b1) c \u2264 \u03b4 := hausdorffEdist_le_of_mem_edist tc ct\n      have Dtc : hausdorffEdist (t : Set \u03b1) c < \u03b5 := this.trans_lt \u03b4lt\n      have hc : c.Nonempty := nonempty_of_hausdorffEdist_ne_top t.nonempty (ne_top_of_lt Dtc)\n      let d : NonemptyCompacts \u03b1 := \u27e8\u27e8c, \u2039c.Finite\u203a.isCompact\u27e9, hc\u27e9\n      have : c \u2286 s := by\n        intro x hx\n        rcases (mem_image _ _ _).1 hx.1 with \u27e8y, \u27e8_, yx\u27e9\u27e9\n        rw [\u2190 yx]\n        exact (Fspec y).1\n      have : d \u2208 v := \u27e8\u2039c.Finite\u203a, this\u27e9\n      exact \u27e8d, \u2039d \u2208 v\u203a, Dtc\u27e9\n  UniformSpace.secondCountable_of_separable (NonemptyCompacts \u03b1)", "start": [317, 1], "end": [391, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.NonemptyCompacts.metricSpace", "code": "instance NonemptyCompacts.metricSpace : MetricSpace (NonemptyCompacts \u03b1) :=\n  EMetricSpace.toMetricSpace fun x y =>\n    hausdorffEdist_ne_top_of_nonempty_of_bounded x.nonempty y.nonempty x.isCompact.isBounded\n      y.isCompact.isBounded", "start": [406, 1], "end": [411, 28], "kind": "commanddeclaration"}, {"full_name": "Metric.NonemptyCompacts.dist_eq", "code": "theorem NonemptyCompacts.dist_eq {x y : NonemptyCompacts \u03b1} :\n    dist x y = hausdorffDist (x : Set \u03b1) y", "start": [414, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.lipschitz_infDist_set", "code": "theorem lipschitz_infDist_set (x : \u03b1) : LipschitzWith 1 fun s : NonemptyCompacts \u03b1 => infDist x s", "start": [420, 1], "end": [423, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.lipschitz_infDist", "code": "theorem lipschitz_infDist : LipschitzWith 2 fun p : \u03b1 \u00d7 NonemptyCompacts \u03b1 => infDist p.1 p.2", "start": [426, 1], "end": [431, 11], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuous_infDist_Hausdorff_dist", "code": "theorem uniformContinuous_infDist_Hausdorff_dist :\n    UniformContinuous fun p : \u03b1 \u00d7 NonemptyCompacts \u03b1 => infDist p.1 p.2", "start": [434, 1], "end": [436, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Semiconj/Basic.lean", "imports": ["Mathlib/Algebra/Group/Semiconj/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy.inv_inv_symm_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_inv_symm_iff : SemiconjBy a\u207b\u00b9 x\u207b\u00b9 y\u207b\u00b9 \u2194 SemiconjBy a y x", "start": [24, 1], "end": [27, 82], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_inv_symm", "code": "@[to_additive]\ntheorem inv_inv_symm : SemiconjBy a x y \u2192 SemiconjBy a\u207b\u00b9 y\u207b\u00b9 x\u207b\u00b9", "start": [31, 1], "end": [33, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/TwoPointing.lean", "imports": ["Mathlib/Logic/Nontrivial/Defs.lean", "Mathlib/Data/Sum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TwoPointing", "code": "@[ext]\nstructure TwoPointing (\u03b1 : Type*) extends \u03b1 \u00d7 \u03b1 where\n  \n  fst_ne_snd : fst \u2260 snd\n  deriving DecidableEq", "start": [31, 1], "end": [36, 23], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.snd_ne_fst", "code": "theorem snd_ne_fst : p.snd \u2260 p.fst", "start": [47, 1], "end": [48, 20], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.swap", "code": "@[simps]\ndef swap : TwoPointing \u03b1 :=\n  \u27e8(p.snd, p.fst), p.snd_ne_fst\u27e9", "start": [51, 1], "end": [54, 33], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.swap_fst", "code": "theorem swap_fst : p.swap.fst = p.snd", "start": [58, 1], "end": [58, 45], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.swap_snd", "code": "theorem swap_snd : p.swap.snd = p.fst", "start": [61, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.swap_swap", "code": "@[simp]\ntheorem swap_swap : p.swap.swap = p", "start": [64, 1], "end": [65, 43], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.to_nontrivial", "code": "@[reducible]\ntheorem to_nontrivial : Nontrivial \u03b1", "start": [69, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.nonempty_two_pointing_iff", "code": "@[simp]\ntheorem nonempty_two_pointing_iff : Nonempty (TwoPointing \u03b1) \u2194 Nontrivial \u03b1", "start": [78, 1], "end": [80, 54], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.pi", "code": "def pi : TwoPointing (\u03b1 \u2192 \u03b2) where\n  fst _ := q.fst\n  snd _ := q.snd\n  fst_ne_snd h := q.fst_ne_snd (congr_fun h (Classical.arbitrary \u03b1))", "start": [87, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.pi_fst", "code": "@[simp]\ntheorem pi_fst : (q.pi \u03b1).fst = const \u03b1 q.fst", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.pi_snd", "code": "@[simp]\ntheorem pi_snd : (q.pi \u03b1).snd = const \u03b1 q.snd", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prod", "code": "def prod : TwoPointing (\u03b1 \u00d7 \u03b2) where\n  fst := (p.fst, q.fst)\n  snd := (p.snd, q.snd)\n  fst_ne_snd h := p.fst_ne_snd (congr_arg Prod.fst h)", "start": [106, 1], "end": [110, 54], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prod_fst", "code": "@[simp]\ntheorem prod_fst : (p.prod q).fst = (p.fst, q.fst)", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prod_snd", "code": "@[simp]\ntheorem prod_snd : (p.prod q).snd = (p.snd, q.snd)", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.sum", "code": "protected def sum : TwoPointing (Sum \u03b1 \u03b2) :=\n  \u27e8(Sum.inl p.fst, Sum.inr q.snd), Sum.inl_ne_inr\u27e9", "start": [123, 1], "end": [126, 51], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.sum_fst", "code": "@[simp]\ntheorem sum_fst : (p.sum q).fst = Sum.inl p.fst", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.sum_snd", "code": "@[simp]\ntheorem sum_snd : (p.sum q).snd = Sum.inr q.snd", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.bool", "code": "protected def bool : TwoPointing Bool :=\n  \u27e8(false, true), Bool.false_ne_true\u27e9", "start": [139, 1], "end": [141, 38], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.bool_fst", "code": "@[simp]\ntheorem bool_fst : TwoPointing.bool.fst = false", "start": [144, 1], "end": [145, 55], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.bool_snd", "code": "@[simp]\ntheorem bool_snd : TwoPointing.bool.snd = true", "start": [148, 1], "end": [149, 54], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prop", "code": "protected def prop : TwoPointing Prop :=\n  \u27e8(False, True), false_ne_true\u27e9", "start": [155, 1], "end": [157, 33], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prop_fst", "code": "@[simp]\ntheorem prop_fst : TwoPointing.prop.fst = False", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "TwoPointing.prop_snd", "code": "@[simp]\ntheorem prop_snd : TwoPointing.prop.snd = True", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Even.lean", "imports": ["Mathlib/LinearAlgebra/CliffordAlgebra/Grading.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Fold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CliffordAlgebra.even", "code": "def even : Subalgebra R (CliffordAlgebra Q) :=\n  (evenOdd Q 0).toSubalgebra (SetLike.one_mem_graded _) fun _x _y hx hy =>\n    add_zero (0 : ZMod 2) \u25b8 SetLike.mul_mem_graded hx hy", "start": [55, 1], "end": [58, 57], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even_toSubmodule", "code": "@[simp]\ntheorem even_toSubmodule : Subalgebra.toSubmodule (even Q) = evenOdd Q 0", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EvenHom", "code": "@[ext]\nstructure EvenHom : Type max uA uM where\n  bilin : M \u2192\u2097[R] M \u2192\u2097[R] A\n  contract (m : M) : bilin m m = algebraMap R A (Q m)\n  contract_mid (m\u2081 m\u2082 m\u2083 : M) : bilin m\u2081 m\u2082 * bilin m\u2082 m\u2083 = Q m\u2082 \u2022 bilin m\u2081 m\u2083", "start": [70, 1], "end": [75, 79], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.EvenHom.compr\u2082", "code": "@[simps]\ndef EvenHom.compr\u2082 (g : EvenHom Q A) (f : A \u2192\u2090[R] B) : EvenHom Q B where\n  bilin := g.bilin.compr\u2082 f.toLinearMap\n  contract _m := (f.congr_arg <| g.contract _).trans <| f.commutes _\n  contract_mid _m\u2081 _m\u2082 _m\u2083 :=\n    (f.map_mul _ _).symm.trans <| (f.congr_arg <| g.contract_mid _ _ _).trans <| f.map_smul _ _", "start": [80, 1], "end": [86, 96], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.\u03b9", "code": "@[simps! bilin_apply_apply_coe]\nnonrec def even.\u03b9 : EvenHom Q (even Q) where\n  bilin :=\n    LinearMap.mk\u2082 R (fun m\u2081 m\u2082 => \u27e8\u03b9 Q m\u2081 * \u03b9 Q m\u2082, \u03b9_mul_\u03b9_mem_evenOdd_zero Q _ _\u27e9)\n      (fun _ _ _ => by simp only [LinearMap.map_add, add_mul]; rfl)\n      (fun _ _ _ => by simp only [LinearMap.map_smul, smul_mul_assoc]; rfl)\n      (fun _ _ _ => by simp only [LinearMap.map_add, mul_add]; rfl) fun _ _ _ => by\n      simp only [LinearMap.map_smul, mul_smul_comm]; rfl\n  contract m := Subtype.ext <| \u03b9_sq_scalar Q m\n  contract_mid m\u2081 m\u2082 m\u2083 :=\n    Subtype.ext <|\n      calc\n        \u03b9 Q m\u2081 * \u03b9 Q m\u2082 * (\u03b9 Q m\u2082 * \u03b9 Q m\u2083) = \u03b9 Q m\u2081 * (\u03b9 Q m\u2082 * \u03b9 Q m\u2082 * \u03b9 Q m\u2083) := by\n          simp only [mul_assoc]\n        _ = Q m\u2082 \u2022 (\u03b9 Q m\u2081 * \u03b9 Q m\u2083) := by rw [Algebra.smul_def, \u03b9_sq_scalar, Algebra.left_comm]", "start": [91, 1], "end": [106, 97], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.algHom_ext", "code": "@[ext high]\ntheorem even.algHom_ext \u2983f g : even Q \u2192\u2090[R] A\u2984 (h : (even.\u03b9 Q).compr\u2082 f = (even.\u03b9 Q).compr\u2082 g) :\n    f = g", "start": [114, 1], "end": [130, 69], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.S", "code": "private def S : Submodule R (M \u2192\u2097[R] A) :=\n  Submodule.span R\n    {f' | \u2203 x m\u2082, f' = LinearMap.lcomp R _ (f.bilin.flip m\u2082) (LinearMap.mulRight R x)}", "start": [137, 1], "end": [141, 87], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.fFold", "code": "private def fFold : M \u2192\u2097[R] A \u00d7 S f \u2192\u2097[R] A \u00d7 S f :=\n  LinearMap.mk\u2082 R\n    (fun m acc =>\n      \n      (acc.2.val m,\n        \u27e8(LinearMap.mulRight R acc.1).comp (f.bilin.flip m), Submodule.subset_span <| \u27e8_, _, rfl\u27e9\u27e9))\n    (fun m\u2081 m\u2082 a =>\n      Prod.ext (LinearMap.map_add _ m\u2081 m\u2082)\n        (Subtype.ext <|\n          LinearMap.ext fun m\u2083 =>\n            show f.bilin m\u2083 (m\u2081 + m\u2082) * a.1 = f.bilin m\u2083 m\u2081 * a.1 + f.bilin m\u2083 m\u2082 * a.1 by\n              rw [map_add, add_mul]))\n    (fun c m a =>\n      Prod.ext (LinearMap.map_smul _ c m)\n        (Subtype.ext <|\n          LinearMap.ext fun m\u2083 =>\n            show f.bilin m\u2083 (c \u2022 m) * a.1 = c \u2022 (f.bilin m\u2083 m * a.1) by\n              rw [LinearMap.map_smul, smul_mul_assoc]))\n    (fun m a\u2081 a\u2082 => Prod.ext rfl (Subtype.ext <| LinearMap.ext fun m\u2083 => mul_add _ _ _))\n    fun c m a => Prod.ext rfl (Subtype.ext <| LinearMap.ext fun m\u2083 => mul_smul_comm _ _ _)", "start": [143, 1], "end": [171, 91], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.fst_fFold_fFold", "code": "@[simp]\nprivate theorem fst_fFold_fFold (m\u2081 m\u2082 : M) (x : A \u00d7 S f) :\n    (fFold f m\u2081 (fFold f m\u2082 x)).fst = f.bilin m\u2081 m\u2082 * x.fst", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.snd_fFold_fFold", "code": "@[simp]\nprivate theorem snd_fFold_fFold (m\u2081 m\u2082 m\u2083 : M) (x : A \u00d7 S f) :\n    ((fFold f m\u2081 (fFold f m\u2082 x)).snd : M \u2192\u2097[R] A) m\u2083 = f.bilin m\u2083 m\u2081 * (x.snd : M \u2192\u2097[R] A) m\u2082", "start": [178, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.fFold_fFold", "code": "private theorem fFold_fFold (m : M) (x : A \u00d7 S f) : fFold f m (fFold f m x) = Q m \u2022 x", "start": [183, 1], "end": [199, 85], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.aux", "code": "@[simps! (config := { isSimp := false }) apply]\ndef aux (f : EvenHom Q A) : CliffordAlgebra.even Q \u2192\u2097[R] A := by\n  refine ?_ \u2218\u2097 (even Q).val.toLinearMap\n  letI : AddCommGroup (S f) := AddSubgroupClass.toAddCommGroup _\n  exact LinearMap.fst R _ _ \u2218\u2097 foldr Q (fFold f) (fFold_fFold f) (1, 0)", "start": [203, 1], "end": [210, 72], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.aux_one", "code": "@[simp]\ntheorem aux_one : aux f 1 = 1", "start": [213, 1], "end": [215, 41], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.aux_\u03b9", "code": "@[simp]\ntheorem aux_\u03b9 (m\u2081 m\u2082 : M) : aux f ((even.\u03b9 Q).bilin m\u2081 m\u2082) = f.bilin m\u2081 m\u2082", "start": [218, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.aux_algebraMap", "code": "@[simp]\ntheorem aux_algebraMap (r) (hr) : aux f \u27e8algebraMap R _ r, hr\u27e9 = algebraMap R _ r", "start": [226, 1], "end": [228, 98], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift.aux_mul", "code": "@[simp]\ntheorem aux_mul (x y : even Q) : aux f (x * y) = aux f x * aux f y", "start": [231, 1], "end": [247, 8], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift", "code": "@[simps! symm_apply_bilin]\ndef even.lift : EvenHom Q A \u2243 (CliffordAlgebra.even Q \u2192\u2090[R] A) where\n  toFun f := AlgHom.ofLinearMap (aux f) (aux_one f) (aux_mul f)\n  invFun F := (even.\u03b9 Q).compr\u2082 F\n  left_inv f := EvenHom.ext _ _ <| LinearMap.ext\u2082 <| even.lift.aux_\u03b9 f\n  right_inv _ := even.algHom_ext Q <| EvenHom.ext _ _ <| LinearMap.ext\u2082 <| even.lift.aux_\u03b9 _", "start": [256, 1], "end": [264, 93], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.even.lift_\u03b9", "code": "theorem even.lift_\u03b9 (f : EvenHom Q A) (m\u2081 m\u2082 : M) :\n    even.lift Q f ((even.\u03b9 Q).bilin m\u2081 m\u2082) = f.bilin m\u2081 m\u2082", "start": [268, 1], "end": [270, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/SemigroupCat/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/CategoryTheory/Elementwise.lean", "Mathlib/Algebra/PEmptyInstances.lean", "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean"], "premises": [{"full_name": "MagmaCat", "code": "@[to_additive]\ndef MagmaCat : Type (u + 1) :=\n  Bundled Mul", "start": [38, 1], "end": [41, 14], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.bundledHom", "code": "@[to_additive]\ninstance bundledHom : BundledHom @MulHom :=\n  \u27e8@MulHom.toFun, @MulHom.id, @MulHom.comp,\n    by intros; apply @FunLike.coe_injective, by aesop_cat, by aesop_cat\u27e9", "start": [50, 1], "end": [54, 73], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.instConcreteCategory", "code": "instance instConcreteCategory : ConcreteCategory MagmaCat := BundledHom.concreteCategory MulHom", "start": [62, 1], "end": [62, 96], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.instMulHomClass", "code": "@[to_additive]\ninstance instMulHomClass (X Y : MagmaCat) : MulHomClass (X \u27f6 Y) X Y :=\n  inferInstanceAs <| MulHomClass (X \u2192\u2099* Y) X Y", "start": [79, 1], "end": [81, 47], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.of", "code": "@[to_additive]\ndef of (M : Type u) [Mul M] : MagmaCat :=\n  Bundled.of M", "start": [83, 1], "end": [86, 15], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.coe_of", "code": "@[to_additive (attr := simp)]\ntheorem coe_of (R : Type u) [Mul R] : (MagmaCat.of R : Type u) = R", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.mulEquiv_coe_eq", "code": "@[to_additive (attr := simp)]\nlemma mulEquiv_coe_eq {X Y : Type _} [Mul X] [Mul Y] (e : X \u2243* Y) :\n    (@FunLike.coe (MagmaCat.of X \u27f6 MagmaCat.of Y) _ (fun _ => (forget MagmaCat).obj _)\n      ConcreteCategory.funLike (e : X \u2192\u2099* Y) : X \u2192 Y) = \u2191e :=\n  rfl", "start": [99, 1], "end": [103, 6], "kind": "mathlibtacticlemma"}, {"full_name": "MagmaCat.ofHom", "code": "@[to_additive]\ndef ofHom {X Y : Type u} [Mul X] [Mul Y] (f : X \u2192\u2099* Y) : of X \u27f6 of Y := f", "start": [105, 1], "end": [107, 74], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.ofHom_apply", "code": "@[to_additive] theorem ofHom_apply {X Y : Type u} [Mul X] [Mul Y] (f : X \u2192\u2099* Y) (x : X) : ofHom f x = f x", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat", "code": "@[to_additive]\ndef SemigroupCat : Type (u + 1) :=\n  Bundled Semigroup", "start": [126, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.instConcreteCategory", "code": "instance instConcreteCategory : ConcreteCategory SemigroupCat :=\n  BundledHom.concreteCategory (fun _ _ => _)", "start": [146, 1], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.instMulHomClass", "code": "@[to_additive]\ninstance instMulHomClass (X Y : SemigroupCat) : MulHomClass (X \u27f6 Y) X Y :=\n  inferInstanceAs <| MulHomClass (X \u2192\u2099* Y) X Y", "start": [164, 1], "end": [166, 47], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.of", "code": "@[to_additive]\ndef of (M : Type u) [Semigroup M] : SemigroupCat :=\n  Bundled.of M", "start": [168, 1], "end": [171, 15], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.coe_of", "code": "@[to_additive (attr := simp)]\ntheorem coe_of (R : Type u) [Semigroup R] : (SemigroupCat.of R : Type u) = R", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.mulEquiv_coe_eq", "code": "@[to_additive (attr := simp)]\nlemma mulEquiv_coe_eq {X Y : Type _} [Semigroup X] [Semigroup Y] (e : X \u2243* Y) :\n    (@FunLike.coe (SemigroupCat.of X \u27f6 SemigroupCat.of Y) _ (fun _ => (forget SemigroupCat).obj _)\n      ConcreteCategory.funLike (e : X \u2192\u2099* Y) : X \u2192 Y) = \u2191e :=\n  rfl", "start": [184, 1], "end": [188, 6], "kind": "mathlibtacticlemma"}, {"full_name": "SemigroupCat.ofHom", "code": "@[to_additive]\ndef ofHom {X Y : Type u} [Semigroup X] [Semigroup Y] (f : X \u2192\u2099* Y) : of X \u27f6 of Y :=\n  f", "start": [190, 1], "end": [193, 4], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.ofHom_apply", "code": "@[to_additive] theorem ofHom_apply {X Y : Type u} [Semigroup X] [Semigroup Y] (f : X \u2192\u2099* Y) (x : X) :\n    ofHom f x = f x", "start": [200, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.hasForgetToMagmaCat", "code": "@[to_additive]\ninstance hasForgetToMagmaCat : HasForget\u2082 SemigroupCat MagmaCat :=\n  BundledHom.forget\u2082 _ _", "start": [211, 1], "end": [213, 25], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toMagmaCatIso", "code": "@[to_additive (attr := simps)\n      \"Build an isomorphism in the category `AddMagmaCat` from an `AddEquiv` between `Add`s.\"]\ndef MulEquiv.toMagmaCatIso (e : X \u2243* Y) : MagmaCat.of X \u2245 MagmaCat.of Y where\n  hom := e.toMulHom\n  inv := e.symm.toMulHom\n  hom_inv_id := by\n    ext\n    simp_rw [comp_apply, toMulHom_eq_coe, MagmaCat.mulEquiv_coe_eq, symm_apply_apply, id_apply]", "start": [225, 1], "end": [233, 96], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toSemigroupCatIso", "code": "@[to_additive (attr := simps)\n  \"Build an isomorphism in the category\n  `AddSemigroup` from an `AddEquiv` between `AddSemigroup`s.\"]\ndef MulEquiv.toSemigroupCatIso (e : X \u2243* Y) : SemigroupCat.of X \u2245 SemigroupCat.of Y where\n  hom := e.toMulHom\n  inv := e.symm.toMulHom", "start": [244, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.magmaCatIsoToMulEquiv", "code": "@[to_additive\n      \"Build an `AddEquiv` from an isomorphism in the category `AddMagma`.\"]\ndef magmaCatIsoToMulEquiv {X Y : MagmaCat} (i : X \u2245 Y) : X \u2243* Y :=\n  MulHom.toMulEquiv i.hom i.inv i.hom_inv_id i.inv_hom_id", "start": [258, 1], "end": [262, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.semigroupCatIsoToMulEquiv", "code": "@[to_additive\n  \"Build an `AddEquiv` from an isomorphism in the category `AddSemigroup`.\"]\ndef semigroupCatIsoToMulEquiv {X Y : SemigroupCat} (i : X \u2245 Y) : X \u2243* Y :=\n  MulHom.toMulEquiv i.hom i.inv i.hom_inv_id i.inv_hom_id", "start": [266, 1], "end": [270, 58], "kind": "commanddeclaration"}, {"full_name": "mulEquivIsoMagmaIso", "code": "@[to_additive\n    \"additive equivalences between `Add`s are the same\n    as (isomorphic to) isomorphisms in `AddMagma`\"]\ndef mulEquivIsoMagmaIso {X Y : Type u} [Mul X] [Mul Y] :\n    X \u2243* Y \u2245 MagmaCat.of X \u2245 MagmaCat.of Y where\n  hom e := e.toMagmaCatIso\n  inv i := i.magmaCatIsoToMulEquiv", "start": [276, 1], "end": [284, 35], "kind": "commanddeclaration"}, {"full_name": "mulEquivIsoSemigroupCatIso", "code": "@[to_additive\n  \"additive equivalences between `AddSemigroup`s are\n  the same as (isomorphic to) isomorphisms in `AddSemigroup`\"]\ndef mulEquivIsoSemigroupCatIso {X Y : Type u} [Semigroup X] [Semigroup Y] :\n    X \u2243* Y \u2245 SemigroupCat.of X \u2245 SemigroupCat.of Y where\n  hom e := e.toSemigroupCatIso\n  inv i := i.semigroupCatIsoToMulEquiv", "start": [288, 1], "end": [296, 39], "kind": "commanddeclaration"}, {"full_name": "MagmaCat.forgetReflectsIsos", "code": "@[to_additive]\ninstance MagmaCat.forgetReflectsIsos : ReflectsIsomorphisms (forget MagmaCat.{u}) where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget MagmaCat).map f)\n    let e : X \u2243* Y := { f, i.toEquiv with }\n    exact \u27e8(IsIso.of_iso e.toMagmaCatIso).1\u27e9", "start": [300, 1], "end": [305, 45], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.forgetReflectsIsos", "code": "@[to_additive]\ninstance SemigroupCat.forgetReflectsIsos : ReflectsIsomorphisms (forget SemigroupCat.{u}) where\n  reflects {X Y} f _ := by\n    let i := asIso ((forget SemigroupCat).map f)\n    let e : X \u2243* Y := { f, i.toEquiv with }\n    exact \u27e8(IsIso.of_iso e.toSemigroupCatIso).1\u27e9", "start": [309, 1], "end": [314, 49], "kind": "commanddeclaration"}, {"full_name": "SemigroupCat.forget\u2082Full", "code": "@[to_additive]\ninstance SemigroupCat.forget\u2082Full : Full (forget\u2082 SemigroupCat MagmaCat) where preimage f := f", "start": [321, 1], "end": [322, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/WithOne/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Group/WithOne/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithOne.involutiveInv", "code": "@[to_additive]\ninstance involutiveInv [InvolutiveInv \u03b1] : InvolutiveInv (WithOne \u03b1) :=\n  { WithOne.inv with\n    inv_inv := fun a =>\n      (Option.map_map _ _ _).trans <| by simp_rw [inv_comp_inv, Option.map_id, id] }", "start": [30, 1], "end": [34, 85], "kind": "commanddeclaration"}, {"full_name": "WithOne.coeMulHom", "code": "@[to_additive (attr := simps apply) \"`WithZero.coe` as a bundled morphism\"]\ndef coeMulHom [Mul \u03b1] : \u03b1 \u2192\u2099* WithOne \u03b1 where\n  toFun := coe\n  map_mul' _ _ := rfl", "start": [42, 1], "end": [46, 22], "kind": "commanddeclaration"}, {"full_name": "WithOne.lift", "code": "@[to_additive \"Lift an add semigroup homomorphism `f` to a bundled add monoid homorphism.\"]\ndef lift : (\u03b1 \u2192\u2099* \u03b2) \u2243 (WithOne \u03b1 \u2192* \u03b2) where\n  toFun f :=\n    { toFun := fun x => Option.casesOn x 1 f, map_one' := rfl,\n      map_mul' := fun x y => WithOne.cases_on x (by rw [one_mul]; exact (one_mul _).symm)\n        (fun x => WithOne.cases_on y (by rw [mul_one]; exact (mul_one _).symm)\n          (fun y => f.map_mul x y)) }\n  invFun F := F.toMulHom.comp coeMulHom\n  left_inv f := MulHom.ext fun x => rfl\n  right_inv F := MonoidHom.ext fun x => WithOne.cases_on x F.map_one.symm (fun x => rfl)", "start": [61, 1], "end": [71, 89], "kind": "commanddeclaration"}, {"full_name": "WithOne.lift_coe", "code": "@[to_additive (attr := simp)]\ntheorem lift_coe (x : \u03b1) : lift f x = f x", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.lift_one", "code": "@[to_additive]\ntheorem lift_one : lift f 1 = 1", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.lift_unique", "code": "@[to_additive]\ntheorem lift_unique (f : WithOne \u03b1 \u2192* \u03b2) : f = lift (f.toMulHom.comp coeMulHom)", "start": [91, 1], "end": [93, 33], "kind": "commanddeclaration"}, {"full_name": "WithOne.map", "code": "@[to_additive \"Given an additive map from `\u03b1 \u2192 \u03b2` returns an add monoid homomorphism from\n`WithZero \u03b1` to `WithZero \u03b2`\"]\ndef map (f : \u03b1 \u2192\u2099* \u03b2) : WithOne \u03b1 \u2192* WithOne \u03b2 :=\n  lift (coeMulHom.comp f)", "start": [103, 1], "end": [108, 26], "kind": "commanddeclaration"}, {"full_name": "WithOne.map_coe", "code": "@[to_additive (attr := simp)]\ntheorem map_coe (f : \u03b1 \u2192\u2099* \u03b2) (a : \u03b1) : map f (a : WithOne \u03b1) = f a", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id : map (MulHom.id \u03b1) = MonoidHom.id (WithOne \u03b1)", "start": [118, 1], "end": [121, 45], "kind": "commanddeclaration"}, {"full_name": "WithOne.map_map", "code": "@[to_additive]\ntheorem map_map (f : \u03b1 \u2192\u2099* \u03b2) (g : \u03b2 \u2192\u2099* \u03b3) (x) : map g (map f x) = map (g.comp f) x", "start": [125, 1], "end": [127, 45], "kind": "commanddeclaration"}, {"full_name": "WithOne.map_comp", "code": "@[to_additive (attr := simp)]\ntheorem map_comp (f : \u03b1 \u2192\u2099* \u03b2) (g : \u03b2 \u2192\u2099* \u03b3) : map (g.comp f) = (map g).comp (map f)", "start": [131, 1], "end": [133, 46], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.withOneCongr", "code": "@[to_additive (attr := simps apply) \"A version of `Equiv.optionCongr` for `WithZero`.\"]\ndef _root_.MulEquiv.withOneCongr (e : \u03b1 \u2243* \u03b2) : WithOne \u03b1 \u2243* WithOne \u03b2 :=\n  { map e.toMulHom with\n    toFun := map e.toMulHom, invFun := map e.symm.toMulHom,\n    left_inv := (by induction \u00b7 using WithOne.cases_on <;> simp)\n    right_inv := (by induction \u00b7 using WithOne.cases_on <;> simp) }", "start": [139, 1], "end": [145, 68], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.withOneCongr_refl", "code": "@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_refl : (MulEquiv.refl \u03b1).withOneCongr = MulEquiv.refl _", "start": [153, 1], "end": [155, 40], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.withOneCongr_symm", "code": "@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_symm (e : \u03b1 \u2243* \u03b2) :\n    e.withOneCongr.symm = e.symm.withOneCongr", "start": [158, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.withOneCongr_trans", "code": "@[to_additive (attr := simp)]\ntheorem _root_.MulEquiv.withOneCongr_trans (e\u2081 : \u03b1 \u2243* \u03b2) (e\u2082 : \u03b2 \u2243* \u03b3) :\n    e\u2081.withOneCongr.trans e\u2082.withOneCongr = (e\u2081.trans e\u2082).withOneCongr", "start": [164, 1], "end": [167, 53], "kind": "commanddeclaration"}, {"full_name": "WithZero.involutiveInv", "code": "instance involutiveInv [InvolutiveInv \u03b1] : InvolutiveInv (WithZero \u03b1) :=\n  { WithZero.inv with\n    inv_inv := fun a =>\n      (Option.map_map _ _ _).trans <| by simp_rw [inv_comp_inv, Option.map_id, id] }", "start": [176, 1], "end": [179, 85], "kind": "commanddeclaration"}, {"full_name": "WithZero.divisionMonoid", "code": "instance divisionMonoid [DivisionMonoid \u03b1] : DivisionMonoid (WithZero \u03b1) :=\n  { WithZero.divInvMonoid, WithZero.involutiveInv with\n    mul_inv_rev := fun a b =>\n      match a, b with\n      | none, none => rfl\n      | none, some b => rfl\n      | some a, none => rfl\n      | some a, some b => congr_arg some <| mul_inv_rev _ _,\n    inv_eq_of_mul := fun a b \u21a6\n      match a, b with\n      | none, none => fun _ \u21a6 rfl\n      | none, some b => fun _ \u21a6 by contradiction\n      | some a, none => fun _ \u21a6 by contradiction\n      | some a, some b => fun h \u21a6\n        congr_arg some <| inv_eq_of_mul_eq_one_right <| Option.some_injective _ h }", "start": [181, 1], "end": [195, 84], "kind": "commanddeclaration"}, {"full_name": "WithZero.divisionCommMonoid", "code": "instance divisionCommMonoid [DivisionCommMonoid \u03b1] : DivisionCommMonoid (WithZero \u03b1) :=\n  { WithZero.divisionMonoid, WithZero.commSemigroup with }", "start": [197, 1], "end": [198, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/Data/Int/Bitwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.inv_pow'", "code": "@[simp]\ntheorem inv_pow' (A : M) (n : \u2115) : A\u207b\u00b9 ^ n = (A ^ n)\u207b\u00b9", "start": [42, 1], "end": [46, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.pow_sub'", "code": "theorem pow_sub' (A : M) {m n : \u2115} (ha : IsUnit A.det) (h : n \u2264 m) :\n    A ^ (m - n) = A ^ m * (A ^ n)\u207b\u00b9", "start": [49, 1], "end": [53, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.pow_inv_comm'", "code": "theorem pow_inv_comm' (A : M) (m n : \u2115) : A\u207b\u00b9 ^ m * A ^ n = A ^ n * A\u207b\u00b9 ^ m", "start": [56, 1], "end": [70, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_zpow", "code": "@[simp]\ntheorem one_zpow : \u2200 n : \u2124, (1 : M) ^ n = 1", "start": [79, 1], "end": [82, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_zpow", "code": "theorem zero_zpow : \u2200 z : \u2124, z \u2260 0 \u2192 (0 : M) ^ z = 0", "start": [85, 1], "end": [90, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_zpow_eq", "code": "theorem zero_zpow_eq (n : \u2124) : (0 : M) ^ n = if n = 0 then 1 else 0", "start": [93, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_zpow", "code": "theorem inv_zpow (A : M) : \u2200 n : \u2124, A\u207b\u00b9 ^ n = (A ^ n)\u207b\u00b9", "start": [99, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_neg_one", "code": "@[simp]\ntheorem zpow_neg_one (A : M) : A ^ (-1 : \u2124) = A\u207b\u00b9", "start": [104, 1], "end": [107, 78], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_coe_nat", "code": "theorem zpow_coe_nat (A : M) (n : \u2115) : A ^ (n : \u2124) = A ^ n", "start": [110, 1], "end": [111, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_neg_coe_nat", "code": "@[simp]\ntheorem zpow_neg_coe_nat (A : M) (n : \u2115) : A ^ (-n : \u2124) = (A ^ n)\u207b\u00b9", "start": [114, 1], "end": [118, 37], "kind": "commanddeclaration"}, {"full_name": "IsUnit.det_zpow", "code": "theorem _root_.IsUnit.det_zpow {A : M} (h : IsUnit A.det) (n : \u2124) : IsUnit (A ^ n).det", "start": [121, 1], "end": [124, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_zpow_iff", "code": "theorem isUnit_det_zpow_iff {A : M} {z : \u2124} : IsUnit (A ^ z).det \u2194 IsUnit A.det \u2228 z = 0", "start": [127, 1], "end": [134, 9], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_neg", "code": "theorem zpow_neg {A : M} (h : IsUnit A.det) : \u2200 n : \u2124, A ^ (-n) = (A ^ n)\u207b\u00b9", "start": [137, 1], "end": [142, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_zpow'", "code": "theorem inv_zpow' {A : M} (h : IsUnit A.det) (n : \u2124) : A\u207b\u00b9 ^ n = A ^ (-n)", "start": [145, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_add_one", "code": "theorem zpow_add_one {A : M} (h : IsUnit A.det) : \u2200 n : \u2124, A ^ (n + 1) = A ^ n * A", "start": [149, 1], "end": [158, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_sub_one", "code": "theorem zpow_sub_one {A : M} (h : IsUnit A.det) (n : \u2124) : A ^ (n - 1) = A ^ n * A\u207b\u00b9", "start": [161, 1], "end": [165, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_add", "code": "theorem zpow_add {A : M} (ha : IsUnit A.det) (m n : \u2124) : A ^ (m + n) = A ^ m * A ^ n", "start": [168, 1], "end": [172, 91], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_add_of_nonpos", "code": "theorem zpow_add_of_nonpos {A : M} {m n : \u2124} (hm : m \u2264 0) (hn : n \u2264 0) :\n    A ^ (m + n) = A ^ m * A ^ n", "start": [175, 1], "end": [181, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_add_of_nonneg", "code": "theorem zpow_add_of_nonneg {A : M} {m n : \u2124} (hm : 0 \u2264 m) (hn : 0 \u2264 n) :\n    A ^ (m + n) = A ^ m * A ^ n", "start": [184, 1], "end": [188, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_one_add", "code": "theorem zpow_one_add {A : M} (h : IsUnit A.det) (i : \u2124) : A ^ (1 + i) = A * A ^ i", "start": [191, 1], "end": [192, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.SemiconjBy.zpow_right", "code": "theorem SemiconjBy.zpow_right {A X Y : M} (hx : IsUnit X.det) (hy : IsUnit Y.det)\n    (h : SemiconjBy A X Y) : \u2200 m : \u2124, SemiconjBy A (X ^ m) (Y ^ m)", "start": [195, 1], "end": [211, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.zpow_right", "code": "theorem Commute.zpow_right {A B : M} (h : Commute A B) (m : \u2124) : Commute A (B ^ m)", "start": [214, 1], "end": [219, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.zpow_left", "code": "theorem Commute.zpow_left {A B : M} (h : Commute A B) (m : \u2124) : Commute (A ^ m) B", "start": [222, 1], "end": [223, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.zpow_zpow", "code": "theorem Commute.zpow_zpow {A B : M} (h : Commute A B) (m n : \u2124) : Commute (A ^ m) (B ^ n)", "start": [226, 1], "end": [227, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.zpow_self", "code": "theorem Commute.zpow_self (A : M) (n : \u2124) : Commute (A ^ n) A", "start": [230, 1], "end": [231, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.self_zpow", "code": "theorem Commute.self_zpow (A : M) (n : \u2124) : Commute A (A ^ n)", "start": [234, 1], "end": [235, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.zpow_zpow_self", "code": "theorem Commute.zpow_zpow_self (A : M) (m n : \u2124) : Commute (A ^ m) (A ^ n)", "start": [238, 1], "end": [239, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_bit0", "code": "theorem zpow_bit0 (A : M) (n : \u2124) : A ^ bit0 n = A ^ n * A ^ n", "start": [243, 1], "end": [246, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_add_one_of_ne_neg_one", "code": "theorem zpow_add_one_of_ne_neg_one {A : M} : \u2200 n : \u2124, n \u2260 -1 \u2192 A ^ (n + 1) = A ^ n * A", "start": [249, 1], "end": [256, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_bit1", "code": "theorem zpow_bit1 (A : M) (n : \u2124) : A ^ bit1 n = A ^ n * A ^ n * A", "start": [260, 1], "end": [263, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_mul", "code": "theorem zpow_mul (A : M) (h : IsUnit A.det) : \u2200 m n : \u2124, A ^ (m * n) = (A ^ m) ^ n", "start": [266, 1], "end": [277, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_mul'", "code": "theorem zpow_mul' (A : M) (h : IsUnit A.det) (m n : \u2124) : A ^ (m * n) = (A ^ n) ^ m", "start": [280, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.coe_units_zpow", "code": "@[simp, norm_cast]\ntheorem coe_units_zpow (u : M\u02e3) : \u2200 n : \u2124, ((u ^ n : M\u02e3) : M) = (u : M) ^ n", "start": [285, 1], "end": [289, 98], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_ne_zero_of_isUnit_det", "code": "theorem zpow_ne_zero_of_isUnit_det [Nonempty n'] [Nontrivial R] {A : M} (ha : IsUnit A.det)\n    (z : \u2124) : A ^ z \u2260 0", "start": [292, 1], "end": [297, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_sub", "code": "theorem zpow_sub {A : M} (ha : IsUnit A.det) (z1 z2 : \u2124) : A ^ (z1 - z2) = A ^ z1 / A ^ z2", "start": [300, 1], "end": [301, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.Commute.mul_zpow", "code": "theorem Commute.mul_zpow {A B : M} (h : Commute A B) : \u2200 i : \u2124, (A * B) ^ i = A ^ i * B ^ i", "start": [304, 1], "end": [308, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_bit0'", "code": "theorem zpow_bit0' (A : M) (n : \u2124) : A ^ bit0 n = (A * A) ^ n", "start": [312, 1], "end": [313, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_bit1'", "code": "theorem zpow_bit1' (A : M) (n : \u2124) : A ^ bit1 n = (A * A) ^ n * A", "start": [317, 1], "end": [318, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.zpow_neg_mul_zpow_self", "code": "theorem zpow_neg_mul_zpow_self (n : \u2124) {A : M} (h : IsUnit A.det) : A ^ (-n) * A ^ n = 1", "start": [321, 1], "end": [322, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_div_pow", "code": "theorem one_div_pow {A : M} (n : \u2115) : (1 / A) ^ n = 1 / A ^ n", "start": [325, 1], "end": [325, 98], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_div_zpow", "code": "theorem one_div_zpow {A : M} (n : \u2124) : (1 / A) ^ n = 1 / A ^ n", "start": [328, 1], "end": [328, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_zpow", "code": "@[simp]\ntheorem transpose_zpow (A : M) : \u2200 n : \u2124, (A ^ n)\u1d40 = A\u1d40 ^ n", "start": [331, 1], "end": [334, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_zpow", "code": "@[simp]\ntheorem conjTranspose_zpow [StarRing R] (A : M) : \u2200 n : \u2124, (A ^ n)\u1d34 = A\u1d34 ^ n", "start": [337, 1], "end": [340, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Matrix.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "Mathlib/Topology/UniformSpace/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.uniformity", "code": "theorem uniformity :\n    \ud835\udce4 (Matrix m n \ud835\udd5c) = \u2a05 (i : m) (j : n), (\ud835\udce4 \ud835\udd5c).comap fun a => (a.1 i j, a.2 i j)", "start": [25, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.uniformContinuous", "code": "theorem uniformContinuous {\u03b2 : Type*} [UniformSpace \u03b2] {f : \u03b2 \u2192 Matrix m n \ud835\udd5c} :\n    UniformContinuous f \u2194 \u2200 i j, UniformContinuous fun x => f x i j", "start": [32, 1], "end": [35, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Hom/Basic.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousOrderHom", "code": "structure ContinuousOrderHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b1]\n  [TopologicalSpace \u03b2] extends OrderHom \u03b1 \u03b2 where\n  continuous_toFun : Continuous toFun", "start": [35, 1], "end": [38, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHomClass", "code": "class ContinuousOrderHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Preorder \u03b1] [Preorder \u03b2]\n    [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] extends\n    ContinuousMapClass F \u03b1 \u03b2 where\n  map_monotone (f : F) : Monotone f", "start": [47, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHomClass.toOrderHomClass", "code": "instance (priority := 100) toOrderHomClass  :\n    OrderHomClass F \u03b1 \u03b2 :=\n  { \u2039ContinuousOrderHomClass F \u03b1 \u03b2\u203a with\n    map_rel := ContinuousOrderHomClass.map_monotone }", "start": [63, 1], "end": [66, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHomClass.toContinuousOrderHom", "code": "@[coe]\ndef toContinuousOrderHom (f : F) : \u03b1 \u2192Co \u03b2 :=\n    { toFun := f\n      monotone' := ContinuousOrderHomClass.map_monotone f\n      continuous_toFun := map_continuous f }", "start": [73, 1], "end": [79, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.toContinuousMap", "code": "def toContinuousMap (f : \u03b1 \u2192Co \u03b2) : C(\u03b1, \u03b2) :=\n  { f with }", "start": [96, 1], "end": [98, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.coe_toOrderHom", "code": "@[simp] theorem coe_toOrderHom (f : \u03b1 \u2192Co \u03b2) : \u21d1f.toOrderHom = f", "start": [111, 1], "end": [111, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : \u03b1 \u2192Co \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [113, 1], "end": [113, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192Co \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [116, 1], "end": [118, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.copy", "code": "protected def copy (f : \u03b1 \u2192Co \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192Co \u03b2 :=\n  \u27e8f.toOrderHom.copy f' h, h.symm.subst f.continuous_toFun\u27e9", "start": [121, 1], "end": [124, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192Co \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192Co \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [132, 1], "end": [133, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.id", "code": "protected def id : \u03b1 \u2192Co \u03b1 :=\n  \u27e8OrderHom.id, continuous_id\u27e9", "start": [138, 1], "end": [140, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(ContinuousOrderHom.id \u03b1) = id", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : ContinuousOrderHom.id \u03b1 a = a", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.comp", "code": "def comp (f : \u03b2 \u2192Co \u03b3) (g : \u03b1 \u2192Co \u03b2) : ContinuousOrderHom \u03b1 \u03b3 :=\n  \u27e8f.toOrderHom.comp g.toOrderHom, f.continuous_toFun.comp g.continuous_toFun\u27e9", "start": [158, 1], "end": [160, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : \u03b2 \u2192Co \u03b3) (g : \u03b1 \u2192Co \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : \u03b2 \u2192Co \u03b3) (g : \u03b1 \u2192Co \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : \u03b3 \u2192Co \u03b4) (g : \u03b2 \u2192Co \u03b3) (h : \u03b1 \u2192Co \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192Co \u03b2) : f.comp (ContinuousOrderHom.id \u03b1) = f", "start": [179, 1], "end": [181, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192Co \u03b2) : (ContinuousOrderHom.id \u03b2).comp f = f", "start": [184, 1], "end": [186, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192Co \u03b3} {f : \u03b1 \u2192Co \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [189, 1], "end": [192, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousOrderHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192Co \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192Co \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [195, 1], "end": [198, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/NonUnitalSubalgebra.lean", "imports": ["Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Algebra/Star/Center.lean", "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StarMemClass.instInvolutiveStar", "code": "instance instInvolutiveStar {S R : Type*} [InvolutiveStar R] [SetLike S R] [StarMemClass S R]\n    (s : S) : InvolutiveStar s where\n  star_involutive r := Subtype.ext <| star_star (r : R)", "start": [24, 1], "end": [27, 56], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.instStarMul", "code": "instance instStarMul {S R : Type*} [Mul R] [StarMul R] [SetLike S R]\n    [MulMemClass S R] [StarMemClass S R] (s : S) : StarMul s where\n  star_mul _ _ := Subtype.ext <| star_mul _ _", "start": [29, 1], "end": [34, 46], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.instStarAddMonoid", "code": "instance instStarAddMonoid {S R : Type*} [AddMonoid R] [StarAddMonoid R] [SetLike S R]\n    [AddSubmonoidClass S R] [StarMemClass S R] (s : S) : StarAddMonoid s where\n  star_add _ _ := Subtype.ext <| star_add _ _", "start": [36, 1], "end": [41, 46], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.instStarRing", "code": "instance instStarRing {S R : Type*} [NonUnitalNonAssocSemiring R] [StarRing R] [SetLike S R]\n    [NonUnitalSubsemiringClass S R] [StarMemClass S R] (s : S) : StarRing s :=\n  { StarMemClass.instStarMul s, StarMemClass.instStarAddMonoid s with }", "start": [43, 1], "end": [48, 72], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.instStarModule", "code": "instance instStarModule {S : Type*} (R : Type*) {M : Type*} [Star R] [Star M] [SMul R M]\n    [StarModule R M] [SetLike S M] [SMulMemClass S R M] [StarMemClass S M] (s : S) :\n    StarModule R s where\n  star_smul _ _ := Subtype.ext <| star_smul _ _", "start": [50, 1], "end": [55, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebraClass.subtype", "code": "def subtype (s : S) : s \u2192\u22c6\u2099\u2090[R] A :=\n  { NonUnitalSubalgebraClass.subtype s with\n    toFun := Subtype.val\n    map_star' := fun _ => rfl }", "start": [73, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebraClass.coeSubtype", "code": "@[simp]\ntheorem coeSubtype : (subtype s : s \u2192 A) = Subtype.val", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra", "code": "structure NonUnitalStarSubalgebra (R : Type u) (A : Type v) [CommSemiring R]\n    [NonUnitalNonAssocSemiring A] [Module R A] [Star A]\n    extends NonUnitalSubalgebra R A : Type v where\n  \n  star_mem' : \u2200 {a : A} (_ha : a \u2208 carrier), star a \u2208 carrier", "start": [85, 1], "end": [91, 62], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instSetLike", "code": "instance instSetLike : SetLike (NonUnitalStarSubalgebra R A) A where\n  coe {s} := s.carrier\n  coe_injective' p q h := by cases p; cases q; congr; exact SetLike.coe_injective h", "start": [104, 1], "end": [106, 84], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instNonUnitalSubsemiringClass", "code": "instance instNonUnitalSubsemiringClass : NonUnitalSubsemiringClass (NonUnitalStarSubalgebra R A) A\n    where\n  add_mem {s} := s.add_mem'\n  mul_mem {s} := s.mul_mem'\n  zero_mem {s} := s.zero_mem'", "start": [108, 1], "end": [112, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instSMulMemClass", "code": "instance instSMulMemClass : SMulMemClass (NonUnitalStarSubalgebra R A) R A where\n  smul_mem {s} := s.smul_mem'", "start": [114, 1], "end": [115, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instStarMemClass", "code": "instance instStarMemClass : StarMemClass (NonUnitalStarSubalgebra R A) A where\n  star_mem {s} := s.star_mem'", "start": [117, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instNonUnitalSubringClass", "code": "instance instNonUnitalSubringClass {R : Type u} {A : Type v} [CommRing R] [NonUnitalNonAssocRing A]\n    [Module R A] [Star A] : NonUnitalSubringClass (NonUnitalStarSubalgebra R A) A :=\n  { NonUnitalStarSubalgebra.instNonUnitalSubsemiringClass with\n    neg_mem := fun _S {x} hx => neg_one_smul R x \u25b8 SMulMemClass.smul_mem _ hx }", "start": [120, 1], "end": [123, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_carrier", "code": "theorem mem_carrier {s : NonUnitalStarSubalgebra R A} {x : A} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [125, 1], "end": [126, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.ext", "code": "@[ext]\ntheorem ext {S T : NonUnitalStarSubalgebra R A} (h : \u2200 x : A, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [128, 1], "end": [130, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem mem_toNonUnitalSubalgebra {S : NonUnitalStarSubalgebra R A} {x} :\n    x \u2208 S.toNonUnitalSubalgebra \u2194 x \u2208 S", "start": [132, 1], "end": [135, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem coe_toNonUnitalSubalgebra (S : NonUnitalStarSubalgebra R A) :\n    (\u2191S.toNonUnitalSubalgebra : Set A) = S", "start": [137, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra_injective", "code": "theorem toNonUnitalSubalgebra_injective :\n    Function.Injective\n      (toNonUnitalSubalgebra : NonUnitalStarSubalgebra R A \u2192 NonUnitalSubalgebra R A)", "start": [142, 1], "end": [146, 83], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra_inj", "code": "theorem toNonUnitalSubalgebra_inj {S U : NonUnitalStarSubalgebra R A} :\n    S.toNonUnitalSubalgebra = U.toNonUnitalSubalgebra \u2194 S = U", "start": [148, 1], "end": [150, 41], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra_le_iff", "code": "theorem toNonUnitalSubalgebra_le_iff {S\u2081 S\u2082 : NonUnitalStarSubalgebra R A} :\n    S\u2081.toNonUnitalSubalgebra \u2264 S\u2082.toNonUnitalSubalgebra \u2194 S\u2081 \u2264 S\u2082", "start": [152, 1], "end": [154, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.copy", "code": "protected def copy (S : NonUnitalStarSubalgebra R A) (s : Set A) (hs : s = \u2191S) :\n    NonUnitalStarSubalgebra R A :=\n  { S.toNonUnitalSubalgebra.copy s hs with\n    star_mem' := @fun x (hx : x \u2208 s) => by\n      show star x \u2208 s\n      rw [hs] at hx \u22a2\n      exact S.star_mem' hx }", "start": [156, 1], "end": [164, 29], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : NonUnitalStarSubalgebra R A) (s : Set A) (hs : s = \u2191S) :\n    (S.copy s hs : Set A) = s", "start": [166, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.copy_eq", "code": "theorem copy_eq (S : NonUnitalStarSubalgebra R A) (s : Set A) (hs : s = \u2191S) : S.copy s hs = S", "start": [171, 1], "end": [172, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubring", "code": "def toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] (S : NonUnitalStarSubalgebra R A) : NonUnitalSubring A where\n  toNonUnitalSubsemiring := S.toNonUnitalSubsemiring\n  neg_mem' := neg_mem (s := S)", "start": [176, 1], "end": [180, 31], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_toNonUnitalSubring", "code": "@[simp]\ntheorem mem_toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] {S : NonUnitalStarSubalgebra R A} {x} : x \u2208 S.toNonUnitalSubring \u2194 x \u2208 S", "start": [182, 1], "end": [185, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_toNonUnitalSubring", "code": "@[simp]\ntheorem coe_toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] (S : NonUnitalStarSubalgebra R A) : (\u2191S.toNonUnitalSubring : Set A) = S", "start": [187, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubring_injective", "code": "theorem toNonUnitalSubring_injective {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A]\n    [Module R A] [Star A] :\n    Function.Injective (toNonUnitalSubring : NonUnitalStarSubalgebra R A \u2192 NonUnitalSubring A)", "start": [192, 1], "end": [195, 90], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubring_inj", "code": "theorem toNonUnitalSubring_inj {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] {S U : NonUnitalStarSubalgebra R A} :\n    S.toNonUnitalSubring = U.toNonUnitalSubring \u2194 S = U", "start": [197, 1], "end": [200, 38], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instInhabited", "code": "instance instInhabited : Inhabited S :=\n  \u27e8(0 : S.toNonUnitalSubalgebra)\u27e9", "start": [202, 1], "end": [203, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSemiring", "code": "instance toNonUnitalSemiring {R A} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [Star A]\n    (S : NonUnitalStarSubalgebra R A) : NonUnitalSemiring S :=\n  inferInstance", "start": [210, 1], "end": [212, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalCommSemiring", "code": "instance toNonUnitalCommSemiring {R A} [CommSemiring R] [NonUnitalCommSemiring A] [Module R A]\n    [Star A] (S : NonUnitalStarSubalgebra R A) : NonUnitalCommSemiring S :=\n  inferInstance", "start": [214, 1], "end": [216, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalRing", "code": "instance toNonUnitalRing {R A} [CommRing R] [NonUnitalRing A] [Module R A] [Star A]\n    (S : NonUnitalStarSubalgebra R A) : NonUnitalRing S :=\n  inferInstance", "start": [218, 1], "end": [220, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalCommRing", "code": "instance toNonUnitalCommRing {R A} [CommRing R] [NonUnitalCommRing A] [Module R A] [Star A]\n    (S : NonUnitalStarSubalgebra R A) : NonUnitalCommRing S :=\n  inferInstance", "start": [222, 1], "end": [224, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra'", "code": "def toNonUnitalSubalgebra' : NonUnitalStarSubalgebra R A \u21aao NonUnitalSubalgebra R A where\n  toEmbedding :=\n    { toFun := fun S => S.toNonUnitalSubalgebra\n      inj' := fun S T h => ext <| by apply SetLike.ext_iff.1 h }\n  map_rel_iff' := SetLike.coe_subset_coe.symm.trans SetLike.coe_subset_coe", "start": [227, 1], "end": [233, 75], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.module'", "code": "instance module' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] : Module R' S :=\n  SMulMemClass.toModule' _ R' R A S", "start": [239, 1], "end": [240, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instModule", "code": "instance instModule : Module R S :=\n  S.module'", "start": [242, 1], "end": [243, 12], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instIsScalarTower'", "code": "instance instIsScalarTower' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] :\n    IsScalarTower R' R S :=\n  S.toNonUnitalSubalgebra.instIsScalarTower'", "start": [245, 1], "end": [247, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instIsScalarTower", "code": "instance instIsScalarTower [IsScalarTower R A A] : IsScalarTower R S S where\n  smul_assoc r x y := Subtype.ext <| smul_assoc r (x : A) (y : A)", "start": [249, 1], "end": [250, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instSMulCommClass'", "code": "instance instSMulCommClass' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A]\n    [SMulCommClass R' R A] : SMulCommClass R' R S where\n  smul_comm r' r s := Subtype.ext <| smul_comm r' r (s : A)", "start": [252, 1], "end": [254, 60], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass R A A] : SMulCommClass R S S where\n  smul_comm r x y := Subtype.ext <| smul_comm r (x : A) (y : A)", "start": [256, 1], "end": [257, 64], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.noZeroSMulDivisors_bot", "code": "instance noZeroSMulDivisors_bot [NoZeroSMulDivisors R A] : NoZeroSMulDivisors R S :=\n  \u27e8fun {c x} h =>\n    have : c = 0 \u2228 (x : A) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg ((\u2191) : S \u2192 A) h)\n    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr\u27e9", "start": [261, 1], "end": [264, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_add", "code": "protected theorem coe_add (x y : S) : (\u2191(x + y) : A) = \u2191x + \u2191y", "start": [266, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_mul", "code": "protected theorem coe_mul (x y : S) : (\u2191(x * y) : A) = \u2191x * \u2191y", "start": [269, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_zero", "code": "protected theorem coe_zero : ((0 : S) : A) = 0", "start": [272, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_neg", "code": "protected theorem coe_neg {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] {S : NonUnitalStarSubalgebra R A} (x : S) : (\u2191(-x) : A) = -\u2191x", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_sub", "code": "protected theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    [Star A] {S : NonUnitalStarSubalgebra R A} (x y : S) : (\u2191(x - y) : A) = \u2191x - \u2191y", "start": [279, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] (r : R') (x : S) :\n    (r \u2022 x : A) = r \u2022 (x : A)", "start": [283, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_eq_zero", "code": "protected theorem coe_eq_zero {x : S} : (x : A) = 0 \u2194 x = 0", "start": [288, 1], "end": [289, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra_subtype", "code": "@[simp]\ntheorem toNonUnitalSubalgebra_subtype :\n    NonUnitalSubalgebraClass.subtype S = NonUnitalStarSubalgebraClass.subtype S", "start": [291, 1], "end": [294, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toSubring_subtype", "code": "@[simp]\ntheorem toSubring_subtype {R A : Type*} [CommRing R] [NonUnitalRing A] [Module R A] [Star A]\n    (S : NonUnitalStarSubalgebra R A) :\n    NonUnitalSubringClass.subtype S = NonUnitalStarSubalgebraClass.subtype S", "start": [296, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map", "code": "def map (f : F) (S : NonUnitalStarSubalgebra R A) : NonUnitalStarSubalgebra R B where\n  toNonUnitalSubalgebra := S.toNonUnitalSubalgebra.map (f : A \u2192\u2099\u2090[R] B)\n  star_mem' := by rintro _ \u27e8a, ha, rfl\u27e9; exact \u27e8star a, star_mem (s := S) ha, map_star f a\u27e9", "start": [302, 1], "end": [305, 92], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_mono", "code": "theorem map_mono {S\u2081 S\u2082 : NonUnitalStarSubalgebra R A} {f : F} :\n    S\u2081 \u2264 S\u2082 \u2192 (map f S\u2081 : NonUnitalStarSubalgebra R B) \u2264 map f S\u2082", "start": [307, 1], "end": [309, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_injective", "code": "theorem map_injective {f : F} (hf : Function.Injective f) :\n    Function.Injective (map f : NonUnitalStarSubalgebra R A \u2192 NonUnitalStarSubalgebra R B)", "start": [311, 1], "end": [314, 87], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_id", "code": "@[simp]\ntheorem map_id (S : NonUnitalStarSubalgebra R A) : map (NonUnitalStarAlgHom.id R A) S = S", "start": [316, 1], "end": [318, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_map", "code": "theorem map_map (S : NonUnitalStarSubalgebra R A) (g : B \u2192\u22c6\u2099\u2090[R] C) (f : A \u2192\u22c6\u2099\u2090[R] B) :\n    (S.map f).map g = S.map (g.comp f)", "start": [320, 1], "end": [322, 49], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_map", "code": "@[simp]\ntheorem mem_map {S : NonUnitalStarSubalgebra R A} {f : F} {y : B} :\n    y \u2208 map f S \u2194 \u2203 x \u2208 S, f x = y", "start": [324, 1], "end": [327, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_toNonUnitalSubalgebra", "code": "theorem map_toNonUnitalSubalgebra {S : NonUnitalStarSubalgebra R A} {f : F} :\n    (map f S : NonUnitalStarSubalgebra R B).toNonUnitalSubalgebra =\n      NonUnitalSubalgebra.map f S.toNonUnitalSubalgebra", "start": [329, 1], "end": [332, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_map", "code": "@[simp]\ntheorem coe_map (S : NonUnitalStarSubalgebra R A) (f : F) : map f S = f '' S", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.comap", "code": "def comap (f : F) (S : NonUnitalStarSubalgebra R B) : NonUnitalStarSubalgebra R A where\n  toNonUnitalSubalgebra := S.toNonUnitalSubalgebra.comap f\n  star_mem' := @fun a (ha : f a \u2208 S) =>\n    show f (star a) \u2208 S from (map_star f a).symm \u25b8 star_mem (s := S) ha", "start": [338, 1], "end": [342, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.map_le", "code": "theorem map_le {S : NonUnitalStarSubalgebra R A} {f : F} {U : NonUnitalStarSubalgebra R B} :\n    map f S \u2264 U \u2194 S \u2264 comap f U", "start": [344, 1], "end": [346, 23], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.gc_map_comap", "code": "theorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f)", "start": [348, 1], "end": [349, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_comap", "code": "@[simp]\ntheorem mem_comap (S : NonUnitalStarSubalgebra R B) (f : F) (x : A) : x \u2208 comap f S \u2194 f x \u2208 S", "start": [351, 1], "end": [353, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap (S : NonUnitalStarSubalgebra R B) (f : F) : comap f S = f \u207b\u00b9' (S : Set B)", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instNoZeroDivisors", "code": "instance instNoZeroDivisors {R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [NoZeroDivisors A]\n    [Module R A] [Star A] (S : NonUnitalStarSubalgebra R A) : NoZeroDivisors S :=\n  NonUnitalSubsemiringClass.noZeroDivisors S", "start": [359, 1], "end": [361, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalStarSubalgebra", "code": "def toNonUnitalStarSubalgebra (h_star : \u2200 x, x \u2208 s \u2192 star x \u2208 s) : NonUnitalStarSubalgebra R A :=\n  { s with\n    star_mem' := @h_star }", "start": [370, 1], "end": [373, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_toNonUnitalStarSubalgebra", "code": "@[simp]\ntheorem mem_toNonUnitalStarSubalgebra {s : NonUnitalSubalgebra R A} {h_star} {x} :\n    x \u2208 s.toNonUnitalStarSubalgebra h_star \u2194 x \u2208 s", "start": [375, 1], "end": [378, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_toNonUnitalStarSubalgebra", "code": "@[simp]\ntheorem coe_toNonUnitalStarSubalgebra (s : NonUnitalSubalgebra R A) (h_star) :\n    (s.toNonUnitalStarSubalgebra h_star : Set A) = s", "start": [380, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalStarSubalgebra_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem toNonUnitalStarSubalgebra_toNonUnitalSubalgebra (s : NonUnitalSubalgebra R A) (h_star) :\n    (s.toNonUnitalStarSubalgebra h_star).toNonUnitalSubalgebra = s", "start": [385, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.toNonUnitalSubalgebra_toNonUnitalStarSubalgebra", "code": "@[simp]\ntheorem _root_.NonUnitalStarSubalgebra.toNonUnitalSubalgebra_toNonUnitalStarSubalgebra\n    (S : NonUnitalStarSubalgebra R A) :\n    (S.toNonUnitalSubalgebra.toNonUnitalStarSubalgebra fun _ => star_mem (s := S)) = S", "start": [390, 1], "end": [394, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.range", "code": "protected def range (\u03c6 : F) : NonUnitalStarSubalgebra R B where\n  toNonUnitalSubalgebra := NonUnitalAlgHom.range (\u03c6 : A \u2192\u2099\u2090[R] B)\n  star_mem' := by rintro _ \u27e8a, rfl\u27e9; exact \u27e8star a, map_star \u03c6 a\u27e9", "start": [405, 1], "end": [408, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.mem_range", "code": "@[simp]\ntheorem mem_range (\u03c6 : F) {y : B} :\n    y \u2208 (NonUnitalStarAlgHom.range \u03c6 : NonUnitalStarSubalgebra R B) \u2194 \u2203 x : A, \u03c6 x = y", "start": [410, 1], "end": [413, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.mem_range_self", "code": "theorem mem_range_self (\u03c6 : F) (x : A) :\n    \u03c6 x \u2208 (NonUnitalStarAlgHom.range \u03c6 : NonUnitalStarSubalgebra R B)", "start": [415, 1], "end": [417, 43], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_range", "code": "@[simp]\ntheorem coe_range (\u03c6 : F) :\n    ((NonUnitalStarAlgHom.range \u03c6 : NonUnitalStarSubalgebra R B) : Set B) = Set.range (\u03c6 : A \u2192 B)", "start": [419, 1], "end": [422, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.range_comp", "code": "theorem range_comp (f : A \u2192\u22c6\u2099\u2090[R] B) (g : B \u2192\u22c6\u2099\u2090[R] C) :\n    NonUnitalStarAlgHom.range (g.comp f) = (NonUnitalStarAlgHom.range f).map g", "start": [424, 1], "end": [426, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.range_comp_le_range", "code": "theorem range_comp_le_range (f : A \u2192\u22c6\u2099\u2090[R] B) (g : B \u2192\u22c6\u2099\u2090[R] C) :\n    NonUnitalStarAlgHom.range (g.comp f) \u2264 NonUnitalStarAlgHom.range g", "start": [428, 1], "end": [430, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.codRestrict", "code": "def codRestrict (f : F) (S : NonUnitalStarSubalgebra R B) (hf : \u2200 x, f x \u2208 S) : A \u2192\u22c6\u2099\u2090[R] S where\n  toNonUnitalAlgHom := NonUnitalAlgHom.codRestrict f S.toNonUnitalSubalgebra hf\n  map_star' := fun a => Subtype.ext <| map_star f a", "start": [432, 1], "end": [435, 52], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.subtype_comp_codRestrict", "code": "@[simp]\ntheorem subtype_comp_codRestrict (f : F) (S : NonUnitalStarSubalgebra R B) (hf : \u2200 x : A, f x \u2208 S) :\n    (NonUnitalStarSubalgebraClass.subtype S).comp (NonUnitalStarAlgHom.codRestrict f S hf) = f", "start": [437, 1], "end": [440, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_codRestrict", "code": "@[simp]\ntheorem coe_codRestrict (f : F) (S : NonUnitalStarSubalgebra R B) (hf : \u2200 x, f x \u2208 S) (x : A) :\n    \u2191(NonUnitalStarAlgHom.codRestrict f S hf x) = f x", "start": [442, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.injective_codRestrict", "code": "theorem injective_codRestrict (f : F) (S : NonUnitalStarSubalgebra R B) (hf : \u2200 x : A, f x \u2208 S) :\n    Function.Injective (NonUnitalStarAlgHom.codRestrict f S hf) \u2194 Function.Injective f", "start": [447, 1], "end": [449, 97], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.rangeRestrict", "code": "@[reducible]\ndef rangeRestrict (f : F) : A \u2192\u22c6\u2099\u2090[R] (NonUnitalStarAlgHom.range f : NonUnitalStarSubalgebra R B) :=\n  NonUnitalStarAlgHom.codRestrict f (NonUnitalStarAlgHom.range f)\n    (NonUnitalStarAlgHom.mem_range_self f)", "start": [451, 1], "end": [457, 43], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.equalizer", "code": "def equalizer (\u03d5 \u03c8 : F) : NonUnitalStarSubalgebra R A where\n  toNonUnitalSubalgebra := NonUnitalAlgHom.equalizer \u03d5 \u03c8\n  star_mem' := @fun x (hx : \u03d5 x = \u03c8 x) => by simp [map_star, hx]", "start": [459, 1], "end": [462, 65], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.mem_equalizer", "code": "@[simp]\ntheorem mem_equalizer (\u03c6 \u03c8 : F) (x : A) :\n    x \u2208 NonUnitalStarAlgHom.equalizer \u03c6 \u03c8 \u2194 \u03c6 x = \u03c8 x", "start": [464, 1], "end": [467, 10], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofLeftInverse'", "code": "def ofLeftInverse' {g : B \u2192 A} {f : F} (h : Function.LeftInverse g f) :\n    A \u2243\u22c6\u2090[R] NonUnitalStarAlgHom.range f :=\n  { NonUnitalStarAlgHom.rangeRestrict f with\n    toFun := NonUnitalStarAlgHom.rangeRestrict f\n    invFun := g \u2218 (NonUnitalStarSubalgebraClass.subtype <| NonUnitalStarAlgHom.range f)\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := (NonUnitalStarAlgHom.mem_range f).mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [478, 1], "end": [491, 47], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofLeftInverse'_apply", "code": "@[simp]\ntheorem ofLeftInverse'_apply {g : B \u2192 A} {f : F} (h : Function.LeftInverse g f) (x : A) :\n    ofLeftInverse' h x = f x", "start": [493, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofLeftInverse'_symm_apply", "code": "@[simp]\ntheorem ofLeftInverse'_symm_apply {g : B \u2192 A} {f : F} (h : Function.LeftInverse g f)\n    (x : NonUnitalStarAlgHom.range f) : (ofLeftInverse' h).symm x = g x", "start": [498, 1], "end": [501, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofInjective'", "code": "noncomputable def ofInjective' (f : F) (hf : Function.Injective f) :\n    A \u2243\u22c6\u2090[R] NonUnitalStarAlgHom.range f :=\n  ofLeftInverse' (Classical.choose_spec hf.hasLeftInverse)", "start": [503, 1], "end": [506, 59], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofInjective'_apply", "code": "@[simp]\ntheorem ofInjective'_apply (f : F) (hf : Function.Injective f) (x : A) :\n    ofInjective' f hf x = f x", "start": [508, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instInvolutiveStar", "code": "instance instInvolutiveStar : InvolutiveStar (NonUnitalSubalgebra R A)\n    where\n  star S :=\n    { carrier := star S.carrier\n      mul_mem' := @fun x y hx hy => by simpa only [Set.mem_star, NonUnitalSubalgebra.mem_carrier]\n        using (star_mul x y).symm \u25b8 mul_mem hy hx\n      add_mem' := @fun x y hx hy => by simpa only [Set.mem_star, NonUnitalSubalgebra.mem_carrier]\n        using (star_add x y).symm \u25b8 add_mem hx hy\n      zero_mem' := Set.mem_star.mp ((star_zero A).symm \u25b8 zero_mem S : star (0 : A) \u2208 S)\n      smul_mem' := fun r x hx => by simpa only [Set.mem_star, NonUnitalSubalgebra.mem_carrier]\n        using (star_smul r x).symm \u25b8 SMulMemClass.smul_mem (star r) hx }\n  star_involutive S := NonUnitalSubalgebra.ext fun x =>\n      \u27e8fun hx => star_star x \u25b8 hx, fun hx => ((star_star x).symm \u25b8 hx : star (star x) \u2208 S)\u27e9", "start": [528, 1], "end": [541, 92], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_star_iff", "code": "@[simp]\ntheorem mem_star_iff (S : NonUnitalSubalgebra R A) (x : A) : x \u2208 star S \u2194 star x \u2208 S", "start": [543, 1], "end": [545, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.star_mem_star_iff", "code": "theorem star_mem_star_iff (S : NonUnitalSubalgebra R A) (x : A) : star x \u2208 star S \u2194 x \u2208 S", "start": [547, 1], "end": [548, 7], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_star", "code": "@[simp]\ntheorem coe_star (S : NonUnitalSubalgebra R A) : star S = star (S : Set A)", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.star_mono", "code": "theorem star_mono : Monotone (star : NonUnitalSubalgebra R A \u2192 NonUnitalSubalgebra R A)", "start": [554, 1], "end": [555, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.star_adjoin_comm", "code": "theorem star_adjoin_comm (s : Set A) :\n    star (NonUnitalAlgebra.adjoin R s) = NonUnitalAlgebra.adjoin R (star s)", "start": [559, 1], "end": [566, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure", "code": "@[simps!]\ndef starClosure (S : NonUnitalSubalgebra R A) : NonUnitalStarSubalgebra R A where\n  toNonUnitalSubalgebra := S \u2294 star S\n  star_mem' := @fun a (ha : a \u2208 S \u2294 star S) => show star a \u2208 S \u2294 star S by\n    simp only [\u2190 mem_star_iff _ a, \u2190 (@NonUnitalAlgebra.gi R A _ _ _ _ _).l_sup_u _ _] at *\n    convert ha using 2\n    simp only [Set.sup_eq_union, star_adjoin_comm, Set.union_star, coe_star, star_star,\n      Set.union_comm]", "start": [570, 1], "end": [579, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure_le", "code": "theorem starClosure_le {S\u2081 : NonUnitalSubalgebra R A} {S\u2082 : NonUnitalStarSubalgebra R A}\n    (h : S\u2081 \u2264 S\u2082.toNonUnitalSubalgebra) : S\u2081.starClosure \u2264 S\u2082", "start": [581, 1], "end": [585, 94], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure_le_iff", "code": "theorem starClosure_le_iff {S\u2081 : NonUnitalSubalgebra R A} {S\u2082 : NonUnitalStarSubalgebra R A} :\n    S\u2081.starClosure \u2264 S\u2082 \u2194 S\u2081 \u2264 S\u2082.toNonUnitalSubalgebra", "start": [587, 1], "end": [589, 49], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure_toNonunitalSubalgebra", "code": "@[simp]\ntheorem starClosure_toNonunitalSubalgebra {S : NonUnitalSubalgebra R A} :\n    S.starClosure.toNonUnitalSubalgebra = S \u2294 star S", "start": [591, 1], "end": [594, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure_mono", "code": "@[mono]\ntheorem starClosure_mono : Monotone (starClosure (R := R) (A := A))", "start": [596, 1], "end": [598, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.adjoin", "code": "def adjoin (s : Set A) : NonUnitalStarSubalgebra R A where\n  toNonUnitalSubalgebra := NonUnitalAlgebra.adjoin R (s \u222a star s)\n  star_mem' _ := by\n    rwa [NonUnitalSubalgebra.mem_carrier, \u2190 NonUnitalSubalgebra.mem_star_iff,\n      NonUnitalSubalgebra.star_adjoin_comm, Set.union_star, star_star, Set.union_comm]", "start": [617, 1], "end": [622, 87], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.adjoin_eq_starClosure_adjoin", "code": "theorem adjoin_eq_starClosure_adjoin (s : Set A) :\n    adjoin R s = (NonUnitalAlgebra.adjoin R s).starClosure", "start": [624, 1], "end": [630, 97], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.adjoin_toNonUnitalSubalgebra", "code": "theorem adjoin_toNonUnitalSubalgebra (s : Set A) :\n    (adjoin R s).toNonUnitalSubalgebra = NonUnitalAlgebra.adjoin R (s \u222a star s)", "start": [632, 1], "end": [634, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.subset_adjoin", "code": "@[aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_adjoin (s : Set A) : s \u2286 adjoin R s", "start": [636, 1], "end": [638, 79], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.star_subset_adjoin", "code": "theorem star_subset_adjoin (s : Set A) : star s \u2286 adjoin R s", "start": [640, 1], "end": [641, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.self_mem_adjoin_singleton", "code": "theorem self_mem_adjoin_singleton (x : A) : x \u2208 adjoin R ({x} : Set A)", "start": [643, 1], "end": [644, 81], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.star_self_mem_adjoin_singleton", "code": "theorem star_self_mem_adjoin_singleton (x : A) : star x \u2208 adjoin R ({x} : Set A)", "start": [646, 1], "end": [647, 44], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.gc", "code": "protected theorem gc : GaloisConnection (adjoin R : Set A \u2192 NonUnitalStarSubalgebra R A) (\u2191)", "start": [651, 1], "end": [656, 96], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.gi", "code": "protected def gi : GaloisInsertion (adjoin R : Set A \u2192 NonUnitalStarSubalgebra R A) (\u2191) where\n  choice s hs := (adjoin R s).copy s <| le_antisymm (NonUnitalStarAlgebra.gc.le_u_l s) hs\n  gc := NonUnitalStarAlgebra.gc\n  le_l_u S := (NonUnitalStarAlgebra.gc (S : Set A) (adjoin R S)).1 <| le_rfl\n  choice_eq _ _ := NonUnitalStarSubalgebra.copy_eq _ _ _", "start": [658, 1], "end": [663, 57], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.adjoin_le", "code": "theorem adjoin_le {S : NonUnitalStarSubalgebra R A} {s : Set A} (hs : s \u2286 S) : adjoin R s \u2264 S", "start": [665, 1], "end": [666, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.adjoin_le_iff", "code": "theorem adjoin_le_iff {S : NonUnitalStarSubalgebra R A} {s : Set A} : adjoin R s \u2264 S \u2194 s \u2286 S", "start": [668, 1], "end": [669, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.starClosure_eq_adjoin", "code": "theorem _root_.NonUnitalSubalgebra.starClosure_eq_adjoin (S : NonUnitalSubalgebra R A) :\n    S.starClosure = adjoin R (S : Set A)", "start": [671, 1], "end": [674, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : NonUnitalStarSubalgebra R A) : Set A) = Set.univ", "start": [679, 1], "end": [681, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_top", "code": "@[simp]\ntheorem mem_top {x : A} : x \u2208 (\u22a4 : NonUnitalStarSubalgebra R A)", "start": [683, 1], "end": [685, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.top_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem top_toNonUnitalSubalgebra :\n    (\u22a4 : NonUnitalStarSubalgebra R A).toNonUnitalSubalgebra = \u22a4", "start": [687, 1], "end": [689, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.toNonUnitalSubalgebra_eq_top", "code": "@[simp]\ntheorem toNonUnitalSubalgebra_eq_top {S : NonUnitalStarSubalgebra R A} :\n    S.toNonUnitalSubalgebra = \u22a4 \u2194 S = \u22a4", "start": [691, 1], "end": [694, 92], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_sup_left", "code": "theorem mem_sup_left {S T : NonUnitalStarSubalgebra R A} : \u2200 {x : A}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [696, 1], "end": [698, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_sup_right", "code": "theorem mem_sup_right {S T : NonUnitalStarSubalgebra R A} : \u2200 {x : A}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [700, 1], "end": [702, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mul_mem_sup", "code": "theorem mul_mem_sup {S T : NonUnitalStarSubalgebra R A} {x y : A} (hx : x \u2208 S) (hy : y \u2208 T) :\n    x * y \u2208 S \u2294 T", "start": [704, 1], "end": [706, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.map_sup", "code": "theorem map_sup (f : F) (S T : NonUnitalStarSubalgebra R A) :\n    ((S \u2294 T).map f : NonUnitalStarSubalgebra R B) = S.map f \u2294 T.map f", "start": [708, 1], "end": [710, 49], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (S T : NonUnitalStarSubalgebra R A) : (\u2191(S \u2293 T) : Set A) = (S : Set A) \u2229 T", "start": [712, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_inf", "code": "@[simp]\ntheorem mem_inf {S T : NonUnitalStarSubalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T", "start": [716, 1], "end": [718, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.inf_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem inf_toNonUnitalSubalgebra (S T : NonUnitalStarSubalgebra R A) :\n    (S \u2293 T).toNonUnitalSubalgebra = S.toNonUnitalSubalgebra \u2293 T.toNonUnitalSubalgebra", "start": [720, 1], "end": [723, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (NonUnitalStarSubalgebra R A)) : (\u2191(sInf S) : Set A) = \u22c2 s \u2208 S, \u2191s", "start": [726, 1], "end": [728, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_sInf", "code": "theorem mem_sInf {S : Set (NonUnitalStarSubalgebra R A)} {x : A} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [730, 1], "end": [731, 59], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.sInf_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem sInf_toNonUnitalSubalgebra (S : Set (NonUnitalStarSubalgebra R A)) :\n    (sInf S).toNonUnitalSubalgebra = sInf (NonUnitalStarSubalgebra.toNonUnitalSubalgebra '' S)", "start": [733, 1], "end": [736, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalStarSubalgebra R A} :\n    (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i", "start": [738, 1], "end": [740, 55], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalStarSubalgebra R A} {x : A} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [742, 1], "end": [743, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.iInf_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem iInf_toNonUnitalSubalgebra {\u03b9 : Sort*} (S : \u03b9 \u2192 NonUnitalStarSubalgebra R A) :\n    (\u2a05 i, S i).toNonUnitalSubalgebra = \u2a05 i, (S i).toNonUnitalSubalgebra", "start": [745, 1], "end": [748, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.mem_bot", "code": "theorem mem_bot {x : A} : x \u2208 (\u22a5 : NonUnitalStarSubalgebra R A) \u2194 x = 0", "start": [753, 1], "end": [755, 98], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.toNonUnitalSubalgebra_bot", "code": "theorem toNonUnitalSubalgebra_bot :\n    (\u22a5 : NonUnitalStarSubalgebra R A).toNonUnitalSubalgebra = \u22a5", "start": [757, 1], "end": [760, 99], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.coe_bot", "code": "@[simp]\ntheorem coe_bot : ((\u22a5 : NonUnitalStarSubalgebra R A) : Set A) = {0}", "start": [762, 1], "end": [765, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.eq_top_iff", "code": "theorem eq_top_iff {S : NonUnitalStarSubalgebra R A} : S = \u22a4 \u2194 \u2200 x : A, x \u2208 S", "start": [767, 1], "end": [769, 63], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.range_top_iff_surjective", "code": "theorem range_top_iff_surjective (f : F) :\n    NonUnitalStarAlgHom.range f = (\u22a4 : NonUnitalStarSubalgebra R B) \u2194 Function.Surjective f", "start": [771, 1], "end": [773, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.range_id", "code": "@[simp]\ntheorem range_id : NonUnitalStarAlgHom.range (NonUnitalStarAlgHom.id R A) = \u22a4", "start": [775, 1], "end": [777, 37], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.map_top", "code": "@[simp]\ntheorem map_top (f : F) : (\u22a4 : NonUnitalStarSubalgebra R A).map f = NonUnitalStarAlgHom.range f", "start": [779, 1], "end": [781, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.map_bot", "code": "@[simp]\ntheorem map_bot (f : F) : (\u22a5 : NonUnitalStarSubalgebra R A).map f = \u22a5", "start": [783, 1], "end": [785, 95], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.comap_top", "code": "@[simp]\ntheorem comap_top (f : F) : (\u22a4 : NonUnitalStarSubalgebra R B).comap f = \u22a4", "start": [787, 1], "end": [789, 33], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgebra.toTop", "code": "def toTop : A \u2192\u22c6\u2099\u2090[R] (\u22a4 : NonUnitalStarSubalgebra R A) :=\n  NonUnitalStarAlgHom.codRestrict (NonUnitalStarAlgHom.id R A) \u22a4 fun _ => mem_top", "start": [791, 1], "end": [793, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.subsingleton_of_subsingleton", "code": "instance subsingleton_of_subsingleton [Subsingleton A] :\n    Subsingleton (NonUnitalStarSubalgebra R A) :=\n  \u27e8fun B C => ext fun x => by simp only [Subsingleton.elim x 0, zero_mem B, zero_mem C]\u27e9", "start": [808, 1], "end": [810, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.subsingleton", "code": "instance _root_.NonUnitalStarAlgHom.subsingleton [Subsingleton (NonUnitalStarSubalgebra R A)] :\n    Subsingleton (A \u2192\u22c6\u2099\u2090[R] B) :=\n  \u27e8fun f g => NonUnitalStarAlgHom.ext fun a =>\n    have : a \u2208 (\u22a5 : NonUnitalStarSubalgebra R A) :=\n      Subsingleton.elim (\u22a4 : NonUnitalStarSubalgebra R A) \u22a5 \u25b8 mem_top\n    (mem_bot.mp this).symm \u25b8 (map_zero f).trans (map_zero g).symm\u27e9", "start": [812, 1], "end": [817, 67], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.range_val", "code": "theorem range_val : NonUnitalStarAlgHom.range (NonUnitalStarSubalgebraClass.subtype S) = S", "start": [819, 1], "end": [820, 101], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion", "code": "def inclusion {S T : NonUnitalStarSubalgebra R A} (h : S \u2264 T) : S \u2192\u22c6\u2099\u2090[R] T where\n  toNonUnitalAlgHom := NonUnitalSubalgebra.inclusion h\n  map_star' _ := rfl", "start": [822, 1], "end": [830, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion_injective", "code": "theorem inclusion_injective {S T : NonUnitalStarSubalgebra R A} (h : S \u2264 T) :\n    Function.Injective (inclusion h)", "start": [832, 1], "end": [834, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion_self", "code": "@[simp]\ntheorem inclusion_self {S : NonUnitalStarSubalgebra R A} :\n    inclusion (le_refl S) = NonUnitalAlgHom.id R S", "start": [836, 1], "end": [839, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion_mk", "code": "@[simp]\ntheorem inclusion_mk {S T : NonUnitalStarSubalgebra R A} (h : S \u2264 T) (x : A) (hx : x \u2208 S) :\n    inclusion h \u27e8x, hx\u27e9 = \u27e8x, h hx\u27e9", "start": [841, 1], "end": [844, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion_right", "code": "theorem inclusion_right {S T : NonUnitalStarSubalgebra R A} (h : S \u2264 T) (x : T) (m : (x : A) \u2208 S) :\n    inclusion h \u27e8x, m\u27e9 = x", "start": [846, 1], "end": [848, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.inclusion_inclusion", "code": "@[simp]\ntheorem inclusion_inclusion {S T U : NonUnitalStarSubalgebra R A} (hst : S \u2264 T) (htu : T \u2264 U)\n    (x : S) : inclusion htu (inclusion hst x) = inclusion (le_trans hst htu) x", "start": [850, 1], "end": [853, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.val_inclusion", "code": "@[simp]\ntheorem val_inclusion {S T : NonUnitalStarSubalgebra R A} (h : S \u2264 T) (s : S) :\n    (inclusion h s : A) = s", "start": [855, 1], "end": [858, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.prod", "code": "def prod : NonUnitalStarSubalgebra R (A \u00d7 B) :=\n  { S.toNonUnitalSubalgebra.prod S\u2081.toNonUnitalSubalgebra with\n    carrier := S \u00d7\u02e2 S\u2081\n    star_mem' := fun hx => \u27e8star_mem hx.1, star_mem hx.2\u27e9 }", "start": [863, 1], "end": [867, 60], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_prod", "code": "@[simp]\ntheorem coe_prod : (prod S S\u2081 : Set (A \u00d7 B)) = (S : Set A) \u00d7\u02e2 S\u2081", "start": [869, 1], "end": [871, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.prod_toNonUnitalSubalgebra", "code": "theorem prod_toNonUnitalSubalgebra :\n    (S.prod S\u2081).toNonUnitalSubalgebra = S.toNonUnitalSubalgebra.prod S\u2081.toNonUnitalSubalgebra", "start": [873, 1], "end": [875, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_prod", "code": "@[simp]\ntheorem mem_prod {S : NonUnitalStarSubalgebra R A} {S\u2081 : NonUnitalStarSubalgebra R B} {x : A \u00d7 B} :\n    x \u2208 prod S S\u2081 \u2194 x.1 \u2208 S \u2227 x.2 \u2208 S\u2081", "start": [877, 1], "end": [880, 15], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.prod_top", "code": "@[simp]\ntheorem prod_top : (prod \u22a4 \u22a4 : NonUnitalStarSubalgebra R (A \u00d7 B)) = \u22a4", "start": [882, 1], "end": [883, 86], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.prod_mono", "code": "theorem prod_mono {S T : NonUnitalStarSubalgebra R A} {S\u2081 T\u2081 : NonUnitalStarSubalgebra R B} :\n    S \u2264 T \u2192 S\u2081 \u2264 T\u2081 \u2192 prod S S\u2081 \u2264 prod T T\u2081", "start": [885, 1], "end": [887, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.prod_inf_prod", "code": "@[simp]\ntheorem prod_inf_prod {S T : NonUnitalStarSubalgebra R A} {S\u2081 T\u2081 : NonUnitalStarSubalgebra R B} :\n    S.prod S\u2081 \u2293 T.prod T\u2081 = (S \u2293 T).prod (S\u2081 \u2293 T\u2081)", "start": [889, 1], "end": [892, 44], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed [Nonempty \u03b9] {S : \u03b9 \u2192 NonUnitalStarSubalgebra R A}\n    (dir : Directed (\u00b7 \u2264 \u00b7) S) : \u2191(iSup S) = \u22c3 i, (S i : Set A)", "start": [900, 1], "end": [925, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.iSupLift", "code": "noncomputable def iSupLift [Nonempty \u03b9] (K : \u03b9 \u2192 NonUnitalStarSubalgebra R A)\n    (dir : Directed (\u00b7 \u2264 \u00b7) K) (f : \u2200 i, K i \u2192\u22c6\u2099\u2090[R] B)\n    (hf : \u2200 (i j : \u03b9) (h : K i \u2264 K j), f i = (f j).comp (inclusion h))\n    (T : NonUnitalStarSubalgebra R A) (hT : T = iSup K) : \u21a5T \u2192\u22c6\u2099\u2090[R] B := by\n  subst hT\n  exact\n    { toFun :=\n        Set.iUnionLift (fun i => \u2191(K i)) (fun i x => f i x)\n          (fun i j x hxi hxj => by\n            let \u27e8k, hik, hjk\u27e9 := dir i j\n            simp only\n            rw [hf i k hik, hf j k hjk]\n            rfl)\n          (\u2191(iSup K)) (by rw [coe_iSup_of_directed dir])\n      map_zero' := by\n        dsimp only [SetLike.coe_sort_coe, NonUnitalAlgHom.coe_comp, Function.comp_apply,\n          inclusion_mk, Eq.ndrec, id_eq, eq_mpr_eq_cast]\n        exact Set.iUnionLift_const _ (fun i : \u03b9 => (0 : K i)) (fun _ => rfl)  _ (by simp)\n      map_mul' := by\n        dsimp only [SetLike.coe_sort_coe, NonUnitalAlgHom.coe_comp, Function.comp_apply,\n          inclusion_mk, Eq.ndrec, id_eq, eq_mpr_eq_cast, ZeroMemClass.coe_zero,\n          AddSubmonoid.mk_add_mk, Set.inclusion_mk]\n        apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 * \u00b7))\n        on_goal 3 => rw [coe_iSup_of_directed dir]\n        all_goals simp\n      map_add' := by\n        dsimp only [SetLike.coe_sort_coe, NonUnitalAlgHom.coe_comp, Function.comp_apply,\n          inclusion_mk, Eq.ndrec, id_eq, eq_mpr_eq_cast]\n        apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 + \u00b7))\n        on_goal 3 => rw [coe_iSup_of_directed dir]\n        all_goals simp\n      map_smul' := fun r => by\n        dsimp only [SetLike.coe_sort_coe, NonUnitalAlgHom.coe_comp, Function.comp_apply,\n          inclusion_mk, Eq.ndrec, id_eq, eq_mpr_eq_cast]\n        apply Set.iUnionLift_unary (coe_iSup_of_directed dir) _ (fun _ x => r \u2022 x)\n          (fun _ _ => rfl)\n        on_goal 2 => rw [coe_iSup_of_directed dir]\n        all_goals simp\n      map_star' := by\n        dsimp only [SetLike.coe_sort_coe, NonUnitalStarAlgHom.comp_apply, inclusion_mk, Eq.ndrec,\n          id_eq, eq_mpr_eq_cast, ZeroMemClass.coe_zero, AddSubmonoid.mk_add_mk, Set.inclusion_mk,\n          MulMemClass.mk_mul_mk, NonUnitalAlgHom.toDistribMulActionHom_eq_coe,\n          DistribMulActionHom.toFun_eq_coe, NonUnitalAlgHom.coe_to_distribMulActionHom,\n          NonUnitalAlgHom.coe_mk]\n        apply Set.iUnionLift_unary (coe_iSup_of_directed dir) _ (fun _ x => star x)\n          (fun _ _ => rfl)\n        on_goal 2 => rw [coe_iSup_of_directed dir]\n        all_goals simp [map_star] }", "start": [927, 1], "end": [977, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.iSupLift_inclusion", "code": "@[simp]\ntheorem iSupLift_inclusion {i : \u03b9} (x : K i) (h : K i \u2264 T) :\n    iSupLift K dir f hf T hT (inclusion h x) = f i x", "start": [983, 1], "end": [989, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.iSupLift_comp_inclusion", "code": "@[simp]\ntheorem iSupLift_comp_inclusion {i : \u03b9} (h : K i \u2264 T) :\n    (iSupLift K dir f hf T hT).comp (inclusion h) = f i", "start": [991, 1], "end": [993, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.iSupLift_mk", "code": "@[simp]\ntheorem iSupLift_mk {i : \u03b9} (x : K i) (hx : (x : A) \u2208 T) :\n    iSupLift K dir f hf T hT \u27e8x, hx\u27e9 = f i x", "start": [995, 1], "end": [1000, 26], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.iSupLift_of_mem", "code": "theorem iSupLift_of_mem {i : \u03b9} (x : T) (hx : (x : A) \u2208 K i) :\n    iSupLift K dir f hf T hT x = f i \u27e8x, hx\u27e9", "start": [1002, 1], "end": [1006, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.center", "code": "def center : NonUnitalStarSubalgebra R A where\n  toNonUnitalSubalgebra := NonUnitalSubalgebra.center R A\n  star_mem' := Set.star_mem_center", "start": [1014, 1], "end": [1018, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_center", "code": "theorem coe_center : (center R A : Set A) = Set.center A", "start": [1020, 1], "end": [1021, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.center_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem center_toNonUnitalSubalgebra :\n    (center R A).toNonUnitalSubalgebra = NonUnitalSubalgebra.center R A", "start": [1023, 1], "end": [1026, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (A : Type*) [NonUnitalCommSemiring A] [StarRing A] [Module R A]\n    [IsScalarTower R A A] [SMulCommClass R A A] [StarModule R A] : center R A = \u22a4", "start": [1028, 1], "end": [1031, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instNonUnitalCommSemiring", "code": "instance instNonUnitalCommSemiring : NonUnitalCommSemiring (center R A) :=\n  NonUnitalSubalgebra.center.instNonUnitalCommSemiring", "start": [1035, 1], "end": [1036, 55], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.instNonUnitalCommRing", "code": "instance instNonUnitalCommRing {A : Type*} [NonUnitalRing A] [StarRing A] [Module R A]\n    [IsScalarTower R A A] [SMulCommClass R A A] : NonUnitalCommRing (center R A) :=\n  NonUnitalSubalgebra.center.instNonUnitalCommRing", "start": [1038, 1], "end": [1040, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_center_iff", "code": "theorem mem_center_iff {a : A} : a \u2208 center R A \u2194 \u2200 b : A, b * a = a * b", "start": [1042, 1], "end": [1043, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.centralizer", "code": "def centralizer (s : Set A) : NonUnitalStarSubalgebra R A :=\n  { NonUnitalSubalgebra.centralizer R (s \u222a star s) with\n    star_mem' := Set.star_mem_centralizer }", "start": [1051, 1], "end": [1054, 44], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set A) : (centralizer R s : Set A) = (s \u222a star s).centralizer", "start": [1056, 1], "end": [1058, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {s : Set A} {z : A} :\n    z \u2208 centralizer R s \u2194 \u2200 g \u2208 s, g * z = z * g \u2227 star g * z = z * star g", "start": [1060, 1], "end": [1065, 91], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.centralizer_le", "code": "theorem centralizer_le (s t : Set A) (h : s \u2286 t) : centralizer R t \u2264 centralizer R s", "start": [1067, 1], "end": [1068, 75], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarSubalgebra.centralizer_univ", "code": "@[simp]\ntheorem centralizer_univ : centralizer R Set.univ = center R A", "start": [1070, 1], "end": [1072, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Ordering/Lemmas.lean", "imports": ["Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Init/IteSimp.lean", "Mathlib/Init/Algebra/Classes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordering.ite_eq_lt_distrib", "code": "@[simp]\ntheorem ite_eq_lt_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.lt) = if c then a = Ordering.lt else b = Ordering.lt", "start": [21, 1], "end": [24, 26], "kind": "commanddeclaration"}, {"full_name": "Ordering.ite_eq_eq_distrib", "code": "@[simp]\ntheorem ite_eq_eq_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.eq) = if c then a = Ordering.eq else b = Ordering.eq", "start": [27, 1], "end": [30, 26], "kind": "commanddeclaration"}, {"full_name": "Ordering.ite_eq_gt_distrib", "code": "@[simp]\ntheorem ite_eq_gt_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.gt) = if c then a = Ordering.gt else b = Ordering.gt", "start": [33, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "cmpUsing_eq_lt", "code": "@[simp]\ntheorem cmpUsing_eq_lt (a b : \u03b1) : (cmpUsing lt a b = Ordering.lt) = lt a b", "start": [47, 1], "end": [48, 87], "kind": "commanddeclaration"}, {"full_name": "cmpUsing_eq_gt", "code": "@[simp]\ntheorem cmpUsing_eq_gt [IsStrictOrder \u03b1 lt] (a b : \u03b1) :\n    (cmpUsing lt a b = Ordering.gt) = lt b a", "start": [51, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "cmpUsing_eq_eq", "code": "@[simp]\ntheorem cmpUsing_eq_eq (a b : \u03b1) : (cmpUsing lt a b = Ordering.eq) = (\u00aclt a b \u2227 \u00aclt b a)", "start": [66, 1], "end": [67, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/Barrelled.lean", "imports": ["Mathlib/Topology/MetricSpace/Baire.lean", "Mathlib/Topology/Semicontinuous.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BarrelledSpace", "code": "class BarrelledSpace (\ud835\udd5c E : Type*) [SeminormedRing \ud835\udd5c] [AddGroup E] [SMul \ud835\udd5c E]\n    [TopologicalSpace E] : Prop where\n  \n  continuous_of_lowerSemicontinuous : \u2200 p : Seminorm \ud835\udd5c E, LowerSemicontinuous p \u2192 Continuous p", "start": [78, 1], "end": [86, 95], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_lowerSemicontinuous", "code": "theorem Seminorm.continuous_of_lowerSemicontinuous {\ud835\udd5c E : Type*} [AddGroup E] [SMul \ud835\udd5c E]\n    [SeminormedRing \ud835\udd5c] [TopologicalSpace E] [BarrelledSpace \ud835\udd5c E] (p : Seminorm \ud835\udd5c E)\n    (hp : LowerSemicontinuous p) : Continuous p", "start": [88, 1], "end": [91, 56], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_iSup", "code": "theorem Seminorm.continuous_iSup {\u03b9 \ud835\udd5c E : Type*} [NormedField \ud835\udd5c]  [AddCommGroup E] [Module \ud835\udd5c E]\n    [TopologicalSpace E] [BarrelledSpace \ud835\udd5c E] (p : \u03b9 \u2192 Seminorm \ud835\udd5c E)\n    (hp : \u2200 i, Continuous (p i)) (bdd : BddAbove (range p)) :\n    Continuous (\u2a06 i, p i)", "start": [93, 1], "end": [102, 19], "kind": "commanddeclaration"}, {"full_name": "BaireSpace.instBarrelledSpace", "code": "instance BaireSpace.instBarrelledSpace [TopologicalSpace E] [TopologicalAddGroup E]\n    [ContinuousConstSMul \ud835\udd5c\u2081 E] [BaireSpace E] :\n    BarrelledSpace \ud835\udd5c\u2081 E where\n  continuous_of_lowerSemicontinuous := by\n    intro p hp\n    have h\u2081 : \u2200 n : \u2115, IsClosed (p.closedBall (0 : E) n) := fun n \u21a6 by\n      simpa [p.closedBall_zero_eq] using hp.isClosed_preimage n\n    have h\u2082 : (\u22c3 n : \u2115, p.closedBall (0 : E) n) = univ :=\n      eq_univ_of_forall fun x \u21a6 mem_iUnion.mpr (exists_nat_ge <| p (x - 0))\n    rcases nonempty_interior_of_iUnion_of_closed h\u2081 h\u2082 with \u27e8n, \u27e8x, hxn\u27e9\u27e9\n    refine Seminorm.continuous' (r := n + n) ?_\n    rw [p.closedBall_zero_eq] at hxn \u22a2\n    have hxn' : p x \u2264 n := by convert interior_subset hxn\n    rw [mem_interior_iff_mem_nhds, \u2190 map_add_left_nhds_zero] at hxn\n    filter_upwards [hxn] with y hy\n    calc p y = p (x + y - x) := by rw [add_sub_cancel']\n      _ \u2264 p (x + y) + p x := map_sub_le_add _ _ _\n      _ \u2264 n + n := add_le_add hy hxn'", "start": [112, 1], "end": [143, 38], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.banach_steinhaus", "code": "protected theorem banach_steinhaus (H : \u2200 k x, BddAbove (range fun i \u21a6 q k (\ud835\udcd5 i x))) :\n    UniformEquicontinuous ((\u2191) \u2218 \ud835\udcd5)", "start": [151, 1], "end": [170, 69], "kind": "commanddeclaration"}, {"full_name": "WithSeminorms.continuousLinearMapOfTendsto", "code": "protected def continuousLinearMapOfTendsto [T2Space F] {l : Filter \u03b1} [l.IsCountablyGenerated]\n    [l.NeBot] (g : \u03b1 \u2192 E \u2192SL[\u03c3\u2081\u2082] F) {f : E \u2192 F} (h : Tendsto (fun n x \u21a6 g n x) l (\ud835\udcdd f)) :\n    E \u2192SL[\u03c3\u2081\u2082] F where\n  toLinearMap := linearMapOfTendsto _ _ h\n  cont := by\n    rcases l.exists_seq_tendsto with \u27e8u, hu\u27e9\n    refine (h.comp hu).continuous_of_equicontinuousAt (hq.banach_steinhaus ?_).equicontinuous\n    intro k x\n    rw [tendsto_pi_nhds] at h\n    exact (((hq.continuous_seminorm k).tendsto _).comp <| (h x).comp hu).bddAbove_range", "start": [172, 1], "end": [195, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ConditionalProbability.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.cond", "code": "def cond (s : Set \u03a9) : Measure \u03a9 :=\n  (\u03bc s)\u207b\u00b9 \u2022 \u03bc.restrict s", "start": [69, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_isProbabilityMeasure", "code": "theorem cond_isProbabilityMeasure [IsFiniteMeasure \u03bc] (hcs : \u03bc s \u2260 0) :\n    IsProbabilityMeasure (\u03bc[|s])", "start": [81, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_empty", "code": "@[simp]\ntheorem cond_empty : \u03bc[|\u2205] = 0", "start": [92, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_univ", "code": "@[simp]\ntheorem cond_univ [IsProbabilityMeasure \u03bc] : \u03bc[|Set.univ] = \u03bc", "start": [96, 1], "end": [98, 51], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_apply", "code": "theorem cond_apply (hms : MeasurableSet s) (t : Set \u03a9) : \u03bc[t|s] = (\u03bc s)\u207b\u00b9 * \u03bc (s \u2229 t)", "start": [101, 1], "end": [103, 90], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_inter_self", "code": "theorem cond_inter_self (hms : MeasurableSet s) (t : Set \u03a9) : \u03bc[s \u2229 t|s] = \u03bc[t|s]", "start": [106, 1], "end": [107, 79], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.inter_pos_of_cond_ne_zero", "code": "theorem inter_pos_of_cond_ne_zero (hms : MeasurableSet s) (hcst : \u03bc[t|s] \u2260 0) : 0 < \u03bc (s \u2229 t)", "start": [110, 1], "end": [114, 35], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_pos_of_inter_ne_zero", "code": "theorem cond_pos_of_inter_ne_zero [IsFiniteMeasure \u03bc]\n    (hms : MeasurableSet s) (hci : \u03bc (s \u2229 t) \u2260 0) : 0 < (\u03bc[|s]) t", "start": [117, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_cond_eq_cond_inter'", "code": "theorem cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : \u03bc s \u2260 \u221e)\n    (hci : \u03bc (s \u2229 t) \u2260 0) : \u03bc[|s][|t] = \u03bc[|s \u2229 t]", "start": [124, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_cond_eq_cond_inter", "code": "theorem cond_cond_eq_cond_inter [IsFiniteMeasure \u03bc] (hms : MeasurableSet s) (hmt : MeasurableSet t)\n    (hci : \u03bc (s \u2229 t) \u2260 0) : \u03bc[|s][|t] = \u03bc[|s \u2229 t]", "start": [133, 1], "end": [137, 62], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_mul_eq_inter'", "code": "theorem cond_mul_eq_inter' (hms : MeasurableSet s) (hcs : \u03bc s \u2260 0) (hcs' : \u03bc s \u2260 \u221e) (t : Set \u03a9) :\n    \u03bc[t|s] * \u03bc s = \u03bc (s \u2229 t)", "start": [140, 1], "end": [142, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_mul_eq_inter", "code": "theorem cond_mul_eq_inter [IsFiniteMeasure \u03bc] (hms : MeasurableSet s) (hcs : \u03bc s \u2260 0) (t : Set \u03a9) :\n    \u03bc[t|s] * \u03bc s = \u03bc (s \u2229 t)", "start": [145, 1], "end": [147, 54], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_add_cond_compl_eq", "code": "theorem cond_add_cond_compl_eq [IsFiniteMeasure \u03bc] (hms : MeasurableSet s) (hcs : \u03bc s \u2260 0)\n    (hcs' : \u03bc s\u1d9c \u2260 0) : \u03bc[t|s] * \u03bc s + \u03bc[t|s\u1d9c] * \u03bc s\u1d9c = \u03bc t", "start": [150, 1], "end": [155, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.cond_eq_inv_mul_cond_mul", "code": "theorem cond_eq_inv_mul_cond_mul [IsFiniteMeasure \u03bc]\n    (hms : MeasurableSet s) (hmt : MeasurableSet t) : \u03bc[t|s] = (\u03bc s)\u207b\u00b9 * \u03bc[s|t] * \u03bc t", "start": [158, 1], "end": [163, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/ExpChar.lean", "imports": ["Mathlib/Data/Nat/Prime.lean", "Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ExpChar", "code": "class inductive ExpChar (R : Type u) [Semiring R] : \u2115 \u2192 Prop\n  | zero [CharZero R] : ExpChar R 1\n  | prime {q : \u2115} (hprime : q.Prime) [hchar : CharP R q] : ExpChar R q", "start": [41, 1], "end": [44, 71], "kind": "commanddeclaration"}, {"full_name": "expChar_one_of_char_zero", "code": "theorem expChar_one_of_char_zero (q : \u2115) [hp : CharP R 0] [hq : ExpChar R q] : q = 1", "start": [48, 1], "end": [52, 92], "kind": "commanddeclaration"}, {"full_name": "char_eq_expChar_iff", "code": "theorem char_eq_expChar_iff (p q : \u2115) [hp : CharP R p] [hq : ExpChar R q] : p = q \u2194 p.Prime", "start": [55, 1], "end": [60, 76], "kind": "commanddeclaration"}, {"full_name": "char_zero_of_expChar_one", "code": "theorem char_zero_of_expChar_one (p : \u2115) [hp : CharP R p] [hq : ExpChar R 1] : p = 0", "start": [67, 1], "end": [71, 49], "kind": "commanddeclaration"}, {"full_name": "charZero_of_expChar_one'", "code": "instance (priority := 100) charZero_of_expChar_one' [hq : ExpChar R 1] : CharZero R := by\n  cases hq\n  \u00b7 assumption\n  \u00b7 exact False.elim (CharP.char_ne_one R 1 rfl)", "start": [75, 1], "end": [79, 49], "kind": "commanddeclaration"}, {"full_name": "expChar_one_iff_char_zero", "code": "theorem expChar_one_iff_char_zero (p q : \u2115) [CharP R p] [ExpChar R q] : q = 1 \u2194 p = 0", "start": [82, 1], "end": [88, 39], "kind": "commanddeclaration"}, {"full_name": "char_prime_of_ne_zero", "code": "theorem char_prime_of_ne_zero {p : \u2115} [hp : CharP R p] (p_ne_zero : p \u2260 0) : Nat.Prime p", "start": [95, 1], "end": [99, 18], "kind": "commanddeclaration"}, {"full_name": "expChar_is_prime_or_one", "code": "theorem expChar_is_prime_or_one (q : \u2115) [hq : ExpChar R q] : Nat.Prime q \u2228 q = 1", "start": [102, 1], "end": [106, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/Halting.lean", "imports": ["Mathlib/Computability/PartrecCode.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Partrec.merge'", "code": "theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :\n    \u2203 h, Nat.Partrec h \u2227\n      \u2200 a, (\u2200 x \u2208 h a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((h a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)", "start": [27, 1], "end": [57, 39], "kind": "commanddeclaration"}, {"full_name": "Partrec.merge'", "code": "theorem merge' {f g : \u03b1 \u2192. \u03c3} (hf : Partrec f) (hg : Partrec g) :\n    \u2203 k : \u03b1 \u2192. \u03c3,\n      Partrec k \u2227 \u2200 a, (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)", "start": [74, 1], "end": [98, 18], "kind": "commanddeclaration"}, {"full_name": "Partrec.merge", "code": "theorem merge {f g : \u03b1 \u2192. \u03c3} (hf : Partrec f) (hg : Partrec g)\n    (H : \u2200 (a), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y) :\n    \u2203 k : \u03b1 \u2192. \u03c3, Partrec k \u2227 \u2200 a x, x \u2208 k a \u2194 x \u2208 f a \u2228 x \u2208 g a", "start": [101, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Partrec.cond", "code": "theorem cond {c : \u03b1 \u2192 Bool} {f : \u03b1 \u2192. \u03c3} {g : \u03b1 \u2192. \u03c3} (hc : Computable c) (hf : Partrec f)\n    (hg : Partrec g) : Partrec fun a => cond (c a) (f a) (g a)", "start": [116, 1], "end": [122, 53], "kind": "commanddeclaration"}, {"full_name": "Partrec.sum_casesOn", "code": "nonrec theorem sum_casesOn {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192. \u03c3} (hf : Computable f)\n    (hg : Partrec\u2082 g) (hh : Partrec\u2082 h) : @Partrec _ \u03c3 _ _ fun a => Sum.casesOn (f a) (g a) (h a)", "start": [125, 1], "end": [131, 76], "kind": "commanddeclaration"}, {"full_name": "ComputablePred", "code": "def ComputablePred {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) :=\n  \u2203 _ : DecidablePred p, Computable fun a => decide (p a)", "start": [136, 1], "end": [138, 58], "kind": "commanddeclaration"}, {"full_name": "RePred", "code": "def RePred {\u03b1} [Primcodable \u03b1] (p : \u03b1 \u2192 Prop) :=\n  Partrec fun a => Part.assert (p a) fun _ => Part.some ()", "start": [141, 1], "end": [144, 59], "kind": "commanddeclaration"}, {"full_name": "RePred.of_eq", "code": "theorem RePred.of_eq {\u03b1} [Primcodable \u03b1] {p q : \u03b1 \u2192 Prop} (hp : RePred p) (H : \u2200 a, p a \u2194 q a) :\n    RePred q", "start": [147, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "Partrec.dom_re", "code": "theorem Partrec.dom_re {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {f : \u03b1 \u2192. \u03b2} (h : Partrec f) :\n    RePred fun a => (f a).Dom", "start": [152, 1], "end": [154, 96], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.of_eq", "code": "theorem ComputablePred.of_eq {\u03b1} [Primcodable \u03b1] {p q : \u03b1 \u2192 Prop} (hp : ComputablePred p)\n    (H : \u2200 a, p a \u2194 q a) : ComputablePred q", "start": [157, 1], "end": [159, 47], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.computable_iff", "code": "theorem computable_iff {p : \u03b1 \u2192 Prop} :\n    ComputablePred p \u2194 \u2203 f : \u03b1 \u2192 Bool, Computable f \u2227 p = fun a => (f a : Prop)", "start": [172, 1], "end": [175, 69], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.not", "code": "protected theorem not {p : \u03b1 \u2192 Prop} (hp : ComputablePred p) : ComputablePred fun a => \u00acp a", "start": [178, 1], "end": [184, 27], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.to_re", "code": "theorem to_re {p : \u03b1 \u2192 Prop} (hp : ComputablePred p) : RePred p", "start": [187, 1], "end": [194, 30], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.rice", "code": "theorem rice (C : Set (\u2115 \u2192. \u2115)) (h : ComputablePred fun c => eval c \u2208 C) {f g} (hf : Nat.Partrec f)\n    (hg : Nat.Partrec g) (fC : f \u2208 C) : g \u2208 C", "start": [197, 1], "end": [211, 18], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.rice\u2082", "code": "theorem rice\u2082 (C : Set Code) (H : \u2200 cf cg, eval cf = eval cg \u2192 (cf \u2208 C \u2194 cg \u2208 C)) :\n    (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ", "start": [214, 1], "end": [229, 61], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.halting_problem_re", "code": "theorem halting_problem_re (n) : RePred fun c => (eval c n).Dom", "start": [232, 1], "end": [233, 61], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.halting_problem", "code": "theorem halting_problem (n) : \u00acComputablePred fun c => (eval c n).Dom", "start": [236, 1], "end": [237, 76], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.computable_iff_re_compl_re", "code": "theorem computable_iff_re_compl_re {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a", "start": [244, 1], "end": [258, 29], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.computable_iff_re_compl_re'", "code": "theorem computable_iff_re_compl_re' {p : \u03b1 \u2192 Prop} :\n    ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a", "start": [261, 1], "end": [263, 45], "kind": "commanddeclaration"}, {"full_name": "ComputablePred.halting_problem_not_re", "code": "theorem halting_problem_not_re (n) : \u00acRePred fun c => \u00ac(eval c n).Dom", "start": [266, 1], "end": [267, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'", "code": "inductive Partrec' : \u2200 {n}, (Vector \u2115 n \u2192. \u2115) \u2192 Prop\n  | prim {n f} : @Primrec' n f \u2192 @Partrec' n f\n  | comp {m n f} (g : Fin n \u2192 Vector \u2115 m \u2192. \u2115) :\n    Partrec' f \u2192 (\u2200 i, Partrec' (g i)) \u2192 Partrec' fun v => (mOfFn fun i => g i v) >>= f\n  | rfind {n} {f : Vector \u2115 (n + 1) \u2192 \u2115} :\n    @Partrec' (n + 1) f \u2192 Partrec' fun v => rfind fun n => some (f (n ::\u1d65 v) = 0)", "start": [276, 1], "end": [282, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.to_part", "code": "theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f", "start": [295, 1], "end": [304, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.of_eq", "code": "theorem of_eq {n} {f g : Vector \u2115 n \u2192. \u2115} (hf : Partrec' f) (H : \u2200 i, f i = g i) : Partrec' g", "start": [307, 1], "end": [308, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.of_prim", "code": "theorem of_prim {n} {f : Vector \u2115 n \u2192 \u2115} (hf : Primrec f) : @Partrec' n f", "start": [311, 1], "end": [312, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.head", "code": "theorem head {n : \u2115} : @Partrec' n.succ (@head \u2115 n)", "start": [315, 1], "end": [316, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.tail", "code": "theorem tail {n f} (hf : @Partrec' n f) : @Partrec' n.succ fun v => f v.tail", "start": [319, 1], "end": [321, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.bind", "code": "protected theorem bind {n f g} (hf : @Partrec' n f) (hg : @Partrec' (n + 1) g) :\n    @Partrec' n fun v => (f v).bind fun a => g (a ::\u1d65 v)", "start": [324, 1], "end": [329, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.map", "code": "protected theorem map {n f} {g : Vector \u2115 (n + 1) \u2192 \u2115} (hf : @Partrec' n f)\n    (hg : @Partrec' (n + 1) g) : @Partrec' n fun v => (f v).map fun a => g (a ::\u1d65 v)", "start": [332, 1], "end": [334, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.Vec", "code": "def Vec {n m} (f : Vector \u2115 n \u2192 Vector \u2115 m) :=\n  \u2200 i, Partrec' fun v => (f v).get i", "start": [337, 1], "end": [340, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.Vec.prim", "code": "nonrec theorem Vec.prim {n m f} (hf : @Nat.Primrec'.Vec n m f) : Vec f", "start": [343, 1], "end": [343, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.nil", "code": "protected theorem nil {n} : @Vec n 0 fun _ => nil", "start": [346, 1], "end": [346, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.cons", "code": "protected theorem cons {n m} {f : Vector \u2115 n \u2192 \u2115} {g} (hf : @Partrec' n f) (hg : @Vec n m g) :\n    Vec fun v => f v ::\u1d65 g v", "start": [349, 1], "end": [351, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.idv", "code": "theorem idv {n} : @Vec n n id", "start": [354, 1], "end": [355, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.comp'", "code": "theorem comp' {n m f g} (hf : @Partrec' m f) (hg : @Vec n m g) : Partrec' fun v => f (g v)", "start": [358, 1], "end": [359, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.comp\u2081", "code": "theorem comp\u2081 {n} (f : \u2115 \u2192. \u2115) {g : Vector \u2115 n \u2192 \u2115} (hf : @Partrec' 1 fun v => f v.head)\n    (hg : @Partrec' n g) : @Partrec' n fun v => f (g v)", "start": [362, 1], "end": [364, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.rfindOpt", "code": "theorem rfindOpt {n} {f : Vector \u2115 (n + 1) \u2192 \u2115} (hf : @Partrec' (n + 1) f) :\n    @Partrec' n fun v => Nat.rfindOpt fun a => ofNat (Option \u2115) (f (a ::\u1d65 v))", "start": [367, 1], "end": [387, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.of_part", "code": "theorem of_part : \u2200 {n f}, _root_.Partrec f \u2192 @Partrec' n f", "start": [392, 1], "end": [407, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.part_iff", "code": "theorem part_iff {n f} : @Partrec' n f \u2194 _root_.Partrec f", "start": [410, 1], "end": [411, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.part_iff\u2081", "code": "theorem part_iff\u2081 {f : \u2115 \u2192. \u2115} : (@Partrec' 1 fun v => f v.head) \u2194 _root_.Partrec f", "start": [414, 1], "end": [419, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.part_iff\u2082", "code": "theorem part_iff\u2082 {f : \u2115 \u2192 \u2115 \u2192. \u2115} : (@Partrec' 2 fun v => f v.head v.tail.head) \u2194 Partrec\u2082 f", "start": [422, 1], "end": [427, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec'.vec_iff", "code": "theorem vec_iff {m n f} : @Vec m n f \u2194 Computable f", "start": [430, 1], "end": [432, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/TuringMachine.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/Order/Basic.lean", "Mathlib/Data/Vector/Basic.lean", "Mathlib/Logic/Function/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Prod.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Data/Fintype/Pi.lean", "Mathlib/Data/Fintype/Option.lean"], "premises": [{"full_name": "Turing.BlankExtends", "code": "def BlankExtends {\u0393} [Inhabited \u0393] (l\u2081 l\u2082 : List \u0393) : Prop :=\n  \u2203 n, l\u2082 = l\u2081 ++ List.replicate n default", "start": [72, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankExtends.refl", "code": "@[refl]\ntheorem BlankExtends.refl {\u0393} [Inhabited \u0393] (l : List \u0393) : BlankExtends l l", "start": [78, 1], "end": [80, 15], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankExtends.trans", "code": "@[trans]\ntheorem BlankExtends.trans {\u0393} [Inhabited \u0393] {l\u2081 l\u2082 l\u2083 : List \u0393} :\n    BlankExtends l\u2081 l\u2082 \u2192 BlankExtends l\u2082 l\u2083 \u2192 BlankExtends l\u2081 l\u2083", "start": [83, 1], "end": [87, 46], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankExtends.below_of_le", "code": "theorem BlankExtends.below_of_le {\u0393} [Inhabited \u0393] {l l\u2081 l\u2082 : List \u0393} :\n    BlankExtends l l\u2081 \u2192 BlankExtends l l\u2082 \u2192 l\u2081.length \u2264 l\u2082.length \u2192 BlankExtends l\u2081 l\u2082", "start": [90, 1], "end": [94, 79], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankExtends.above", "code": "def BlankExtends.above {\u0393} [Inhabited \u0393] {l l\u2081 l\u2082 : List \u0393} (h\u2081 : BlankExtends l l\u2081)\n    (h\u2082 : BlankExtends l l\u2082) : { l' // BlankExtends l\u2081 l' \u2227 BlankExtends l\u2082 l' } :=\n  if h : l\u2081.length \u2264 l\u2082.length then \u27e8l\u2082, h\u2081.below_of_le h\u2082 h, BlankExtends.refl _\u27e9\n  else \u27e8l\u2081, BlankExtends.refl _, h\u2082.below_of_le h\u2081 (le_of_not_ge h)\u27e9", "start": [97, 1], "end": [102, 69], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankExtends.above_of_le", "code": "theorem BlankExtends.above_of_le {\u0393} [Inhabited \u0393] {l l\u2081 l\u2082 : List \u0393} :\n    BlankExtends l\u2081 l \u2192 BlankExtends l\u2082 l \u2192 l\u2081.length \u2264 l\u2082.length \u2192 BlankExtends l\u2081 l\u2082", "start": [105, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel", "code": "def BlankRel {\u0393} [Inhabited \u0393] (l\u2081 l\u2082 : List \u0393) : Prop :=\n  BlankExtends l\u2081 l\u2082 \u2228 BlankExtends l\u2082 l\u2081", "start": [115, 1], "end": [118, 42], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.refl", "code": "@[refl]\ntheorem BlankRel.refl {\u0393} [Inhabited \u0393] (l : List \u0393) : BlankRel l l", "start": [121, 1], "end": [123, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.symm", "code": "@[symm]\ntheorem BlankRel.symm {\u0393} [Inhabited \u0393] {l\u2081 l\u2082 : List \u0393} : BlankRel l\u2081 l\u2082 \u2192 BlankRel l\u2082 l\u2081", "start": [126, 1], "end": [128, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.trans", "code": "@[trans]\ntheorem BlankRel.trans {\u0393} [Inhabited \u0393] {l\u2081 l\u2082 l\u2083 : List \u0393} :\n    BlankRel l\u2081 l\u2082 \u2192 BlankRel l\u2082 l\u2083 \u2192 BlankRel l\u2081 l\u2083", "start": [131, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.above", "code": "def BlankRel.above {\u0393} [Inhabited \u0393] {l\u2081 l\u2082 : List \u0393} (h : BlankRel l\u2081 l\u2082) :\n    { l // BlankExtends l\u2081 l \u2227 BlankExtends l\u2082 l } := by\n  refine'\n    if hl : l\u2081.length \u2264 l\u2082.length then \u27e8l\u2082, Or.elim h id fun h' \u21a6 _, BlankExtends.refl _\u27e9\n    else \u27e8l\u2081, BlankExtends.refl _, Or.elim h (fun h' \u21a6 _) id\u27e9\n  exact (BlankExtends.refl _).above_of_le h' hl\n  exact (BlankExtends.refl _).above_of_le h' (le_of_not_ge hl)", "start": [145, 1], "end": [152, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.below", "code": "def BlankRel.below {\u0393} [Inhabited \u0393] {l\u2081 l\u2082 : List \u0393} (h : BlankRel l\u2081 l\u2082) :\n    { l // BlankExtends l l\u2081 \u2227 BlankExtends l l\u2082 } := by\n  refine'\n    if hl : l\u2081.length \u2264 l\u2082.length then \u27e8l\u2081, BlankExtends.refl _, Or.elim h id fun h' \u21a6 _\u27e9\n    else \u27e8l\u2082, Or.elim h (fun h' \u21a6 _) id, BlankExtends.refl _\u27e9\n  exact (BlankExtends.refl _).above_of_le h' hl\n  exact (BlankExtends.refl _).above_of_le h' (le_of_not_ge hl)", "start": [155, 1], "end": [162, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.equivalence", "code": "theorem BlankRel.equivalence (\u0393) [Inhabited \u0393] : Equivalence (@BlankRel \u0393 _)", "start": [165, 1], "end": [166, 59], "kind": "commanddeclaration"}, {"full_name": "Turing.BlankRel.setoid", "code": "def BlankRel.setoid (\u0393) [Inhabited \u0393] : Setoid (List \u0393) :=\n  \u27e8_, BlankRel.equivalence _\u27e9", "start": [169, 1], "end": [171, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank", "code": "def ListBlank (\u0393) [Inhabited \u0393] :=\n  Quotient (BlankRel.setoid \u0393)", "start": [174, 1], "end": [178, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.inhabited", "code": "instance ListBlank.inhabited {\u0393} [Inhabited \u0393] : Inhabited (ListBlank \u0393) :=\n  \u27e8Quotient.mk'' []\u27e9", "start": [181, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.hasEmptyc", "code": "instance ListBlank.hasEmptyc {\u0393} [Inhabited \u0393] : EmptyCollection (ListBlank \u0393) :=\n  \u27e8Quotient.mk'' []\u27e9", "start": [185, 1], "end": [186, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.liftOn", "code": "@[reducible]  protected def ListBlank.liftOn {\u0393} [Inhabited \u0393] {\u03b1} (l : ListBlank \u0393) (f : List \u0393 \u2192 \u03b1)\n    (H : \u2200 a b, BlankExtends a b \u2192 f a = f b) : \u03b1 :=\n  l.liftOn' f <| by rintro a b (h | h) <;> [exact H _ _ h; exact (H _ _ h).symm]", "start": [189, 1], "end": [194, 81], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.mk", "code": "def ListBlank.mk {\u0393} [Inhabited \u0393] : List \u0393 \u2192 ListBlank \u0393 :=\n  Quotient.mk''", "start": [197, 1], "end": [199, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.induction_on", "code": "@[elab_as_elim]\nprotected theorem ListBlank.induction_on {\u0393} [Inhabited \u0393] {p : ListBlank \u0393 \u2192 Prop}\n    (q : ListBlank \u0393) (h : \u2200 a, p (ListBlank.mk a)) : p q", "start": [202, 1], "end": [205, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.head", "code": "def ListBlank.head {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) : \u0393 := by\n  apply l.liftOn List.headI\n  rintro a _ \u27e8i, rfl\u27e9\n  cases a\n  \u00b7 cases i <;> rfl\n  rfl", "start": [208, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.head_mk", "code": "@[simp]\ntheorem ListBlank.head_mk {\u0393} [Inhabited \u0393] (l : List \u0393) :\n    ListBlank.head (ListBlank.mk l) = l.headI", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.tail", "code": "def ListBlank.tail {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) : ListBlank \u0393 := by\n  apply l.liftOn (fun l \u21a6 ListBlank.mk l.tail)\n  rintro a _ \u27e8i, rfl\u27e9\n  refine' Quotient.sound' (Or.inl _)\n  cases a\n  \u00b7 cases' i with i <;> [exact \u27e80, rfl\u27e9; exact \u27e8i, rfl\u27e9]\n  exact \u27e8i, rfl\u27e9", "start": [223, 1], "end": [230, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.tail_mk", "code": "@[simp]\ntheorem ListBlank.tail_mk {\u0393} [Inhabited \u0393] (l : List \u0393) :\n    ListBlank.tail (ListBlank.mk l) = ListBlank.mk l.tail", "start": [233, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.cons", "code": "def ListBlank.cons {\u0393} [Inhabited \u0393] (a : \u0393) (l : ListBlank \u0393) : ListBlank \u0393 := by\n  apply l.liftOn (fun l \u21a6 ListBlank.mk (List.cons a l))\n  rintro _ _ \u27e8i, rfl\u27e9\n  exact Quotient.sound' (Or.inl \u27e8i, rfl\u27e9)", "start": [239, 1], "end": [243, 42], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.cons_mk", "code": "@[simp]\ntheorem ListBlank.cons_mk {\u0393} [Inhabited \u0393] (a : \u0393) (l : List \u0393) :\n    ListBlank.cons a (ListBlank.mk l) = ListBlank.mk (a :: l)", "start": [246, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.head_cons", "code": "@[simp]\ntheorem ListBlank.head_cons {\u0393} [Inhabited \u0393] (a : \u0393) : \u2200 l : ListBlank \u0393, (l.cons a).head = a", "start": [252, 1], "end": [254, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.tail_cons", "code": "@[simp]\ntheorem ListBlank.tail_cons {\u0393} [Inhabited \u0393] (a : \u0393) : \u2200 l : ListBlank \u0393, (l.cons a).tail = l", "start": [257, 1], "end": [259, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.cons_head_tail", "code": "@[simp]\ntheorem ListBlank.cons_head_tail {\u0393} [Inhabited \u0393] : \u2200 l : ListBlank \u0393, l.tail.cons l.head = l", "start": [262, 1], "end": [270, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.exists_cons", "code": "theorem ListBlank.exists_cons {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) :\n    \u2203 a l', l = ListBlank.cons a l'", "start": [273, 1], "end": [277, 44], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth", "code": "def ListBlank.nth {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) (n : \u2115) : \u0393 := by\n  apply l.liftOn (fun l \u21a6 List.getI l n)\n  rintro l _ \u27e8i, rfl\u27e9\n  cases' lt_or_le n _ with h h\n  \u00b7 rw [List.getI_append _ _ _ h]\n  rw [List.getI_eq_default _ h]\n  cases' le_or_lt _ n with h\u2082 h\u2082\n  \u00b7 rw [List.getI_eq_default _ h\u2082]\n  rw [List.getI_eq_get _ h\u2082, List.get_append_right' h, List.get_replicate]", "start": [280, 1], "end": [289, 75], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth_mk", "code": "@[simp]\ntheorem ListBlank.nth_mk {\u0393} [Inhabited \u0393] (l : List \u0393) (n : \u2115) :\n    (ListBlank.mk l).nth n = l.getI n", "start": [292, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth_zero", "code": "@[simp]\ntheorem ListBlank.nth_zero {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) : l.nth 0 = l.head", "start": [298, 1], "end": [301, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth_succ", "code": "@[simp]\ntheorem ListBlank.nth_succ {\u0393} [Inhabited \u0393] (l : ListBlank \u0393) (n : \u2115) :\n    l.nth (n + 1) = l.tail.nth n", "start": [304, 1], "end": [308, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.ext", "code": "@[ext]\ntheorem ListBlank.ext {\u0393} [i : Inhabited \u0393] {L\u2081 L\u2082 : ListBlank \u0393} :\n    (\u2200 i, L\u2081.nth i = L\u2082.nth i) \u2192 L\u2081 = L\u2082", "start": [311, 1], "end": [327, 81], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.modifyNth", "code": "@[simp]\ndef ListBlank.modifyNth {\u0393} [Inhabited \u0393] (f : \u0393 \u2192 \u0393) : \u2115 \u2192 ListBlank \u0393 \u2192 ListBlank \u0393\n  | 0, L => L.tail.cons (f L.head)\n  | n + 1, L => (L.tail.modifyNth f n).cons L.head", "start": [330, 1], "end": [334, 51], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth_modifyNth", "code": "theorem ListBlank.nth_modifyNth {\u0393} [Inhabited \u0393] (f : \u0393 \u2192 \u0393) (n i) (L : ListBlank \u0393) :\n    (L.modifyNth f n).nth i = if i = n then f (L.nth i) else L.nth i", "start": [337, 1], "end": [345, 99], "kind": "commanddeclaration"}, {"full_name": "Turing.PointedMap", "code": "structure PointedMap.{u, v} (\u0393 : Type u) (\u0393' : Type v) [Inhabited \u0393] [Inhabited \u0393'] :\n    Type max u v where\n  f : \u0393 \u2192 \u0393'\n  map_pt' : f default = default", "start": [348, 1], "end": [352, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.PointedMap.mk_val", "code": "theorem PointedMap.mk_val {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : \u0393 \u2192 \u0393') (pt) :\n    (PointedMap.mk f pt : \u0393 \u2192 \u0393') = f", "start": [362, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.PointedMap.map_pt", "code": "@[simp]\ntheorem PointedMap.map_pt {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') :\n    f default = default", "start": [367, 1], "end": [370, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.PointedMap.headI_map", "code": "@[simp]\ntheorem PointedMap.headI_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : List \u0393) : (l.map f).headI = f l.headI", "start": [373, 1], "end": [376, 54], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.map", "code": "def ListBlank.map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (l : ListBlank \u0393) :\n    ListBlank \u0393' := by\n  apply l.liftOn (fun l \u21a6 ListBlank.mk (List.map f l))\n  rintro l _ \u27e8i, rfl\u27e9; refine' Quotient.sound' (Or.inl \u27e8i, _\u27e9)\n  simp only [PointedMap.map_pt, List.map_append, List.map_replicate]", "start": [379, 1], "end": [385, 69], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.map_mk", "code": "@[simp]\ntheorem ListBlank.map_mk {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (l : List \u0393) :\n    (ListBlank.mk l).map f = ListBlank.mk (l.map f)", "start": [388, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.head_map", "code": "@[simp]\ntheorem ListBlank.head_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : ListBlank \u0393) : (l.map f).head = f l.head", "start": [394, 1], "end": [398, 44], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.tail_map", "code": "@[simp]\ntheorem ListBlank.tail_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : ListBlank \u0393) : (l.map f).tail = l.tail.map f", "start": [401, 1], "end": [405, 44], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.map_cons", "code": "@[simp]\ntheorem ListBlank.map_cons {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : ListBlank \u0393) (a : \u0393) : (l.cons a).map f = (l.map f).cons (f a)", "start": [408, 1], "end": [412, 95], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.nth_map", "code": "@[simp]\ntheorem ListBlank.nth_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n    (l : ListBlank \u0393) (n : \u2115) : (l.map f).nth n = f (l.nth n)", "start": [415, 1], "end": [424, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.proj", "code": "def proj {\u03b9 : Type*} {\u0393 : \u03b9 \u2192 Type*} [\u2200 i, Inhabited (\u0393 i)] (i : \u03b9) :\n    PointedMap (\u2200 i, \u0393 i) (\u0393 i) :=\n  \u27e8fun a \u21a6 a i, rfl\u27e9", "start": [427, 1], "end": [430, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.proj_map_nth", "code": "theorem proj_map_nth {\u03b9 : Type*} {\u0393 : \u03b9 \u2192 Type*} [\u2200 i, Inhabited (\u0393 i)] (i : \u03b9) (L n) :\n    (ListBlank.map (@proj \u03b9 \u0393 _ i) L).nth n = L.nth n i", "start": [433, 1], "end": [435, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.map_modifyNth", "code": "theorem ListBlank.map_modifyNth {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (F : PointedMap \u0393 \u0393')\n    (f : \u0393 \u2192 \u0393) (f' : \u0393' \u2192 \u0393') (H : \u2200 x, F (f x) = f' (F x)) (n) (L : ListBlank \u0393) :\n    (L.modifyNth f n).map F = (L.map F).modifyNth f' n", "start": [438, 1], "end": [442, 99], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.append", "code": "@[simp]\ndef ListBlank.append {\u0393} [Inhabited \u0393] : List \u0393 \u2192 ListBlank \u0393 \u2192 ListBlank \u0393\n  | [], L => L\n  | a :: l, L => ListBlank.cons a (ListBlank.append l L)", "start": [445, 1], "end": [449, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.append_mk", "code": "@[simp]\ntheorem ListBlank.append_mk {\u0393} [Inhabited \u0393] (l\u2081 l\u2082 : List \u0393) :\n    ListBlank.append l\u2081 (ListBlank.mk l\u2082) = ListBlank.mk (l\u2081 ++ l\u2082)", "start": [452, 1], "end": [456, 90], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.append_assoc", "code": "theorem ListBlank.append_assoc {\u0393} [Inhabited \u0393] (l\u2081 l\u2082 : List \u0393) (l\u2083 : ListBlank \u0393) :\n    ListBlank.append (l\u2081 ++ l\u2082) l\u2083 = ListBlank.append l\u2081 (ListBlank.append l\u2082 l\u2083)", "start": [459, 1], "end": [464, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.bind", "code": "def ListBlank.bind {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (l : ListBlank \u0393) (f : \u0393 \u2192 List \u0393')\n    (hf : \u2203 n, f default = List.replicate n default) : ListBlank \u0393' := by\n  apply l.liftOn (fun l \u21a6 ListBlank.mk (List.bind l f))\n  rintro l _ \u27e8i, rfl\u27e9; cases' hf with n e; refine' Quotient.sound' (Or.inl \u27e8i * n, _\u27e9)\n  rw [List.append_bind, mul_comm]; congr\n  induction' i with i IH; rfl\n  simp only [IH, e, List.replicate_add, Nat.mul_succ, add_comm, List.replicate_succ, List.cons_bind]", "start": [467, 1], "end": [475, 101], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.bind_mk", "code": "@[simp]\ntheorem ListBlank.bind_mk {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (l : List \u0393) (f : \u0393 \u2192 List \u0393') (hf) :\n    (ListBlank.mk l).bind f hf = ListBlank.mk (l.bind f)", "start": [478, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.ListBlank.cons_bind", "code": "@[simp]\ntheorem ListBlank.cons_bind {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (a : \u0393) (l : ListBlank \u0393)\n    (f : \u0393 \u2192 List \u0393') (hf) : (l.cons a).bind f hf = (l.bind f hf).append (f a)", "start": [484, 1], "end": [490, 88], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape", "code": "structure Tape (\u0393 : Type*) [Inhabited \u0393] where\n  head : \u0393\n  left : ListBlank \u0393\n  right : ListBlank \u0393", "start": [493, 1], "end": [500, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.inhabited", "code": "instance Tape.inhabited {\u0393} [Inhabited \u0393] : Inhabited (Tape \u0393) :=\n  \u27e8by constructor <;> apply default\u27e9", "start": [503, 1], "end": [504, 37], "kind": "commanddeclaration"}, {"full_name": "Turing.Dir", "code": "inductive Dir\n  | left\n  | right\n  deriving DecidableEq, Inhabited", "start": [507, 1], "end": [512, 34], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.left\u2080", "code": "def Tape.left\u2080 {\u0393} [Inhabited \u0393] (T : Tape \u0393) : ListBlank \u0393 :=\n  T.left.cons T.head", "start": [515, 1], "end": [517, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.right\u2080", "code": "def Tape.right\u2080 {\u0393} [Inhabited \u0393] (T : Tape \u0393) : ListBlank \u0393 :=\n  T.right.cons T.head", "start": [520, 1], "end": [522, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move", "code": "def Tape.move {\u0393} [Inhabited \u0393] : Dir \u2192 Tape \u0393 \u2192 Tape \u0393\n  | Dir.left, \u27e8a, L, R\u27e9 => \u27e8L.head, L.tail, R.cons a\u27e9\n  | Dir.right, \u27e8a, L, R\u27e9 => \u27e8R.head, L.cons a, R.tail\u27e9", "start": [525, 1], "end": [529, 55], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_left_right", "code": "@[simp]\ntheorem Tape.move_left_right {\u0393} [Inhabited \u0393] (T : Tape \u0393) :\n    (T.move Dir.left).move Dir.right = T", "start": [532, 1], "end": [535, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_right_left", "code": "@[simp]\ntheorem Tape.move_right_left {\u0393} [Inhabited \u0393] (T : Tape \u0393) :\n    (T.move Dir.right).move Dir.left = T", "start": [538, 1], "end": [541, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'", "code": "def Tape.mk' {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) : Tape \u0393 :=\n  \u27e8R.head, L, R.tail\u27e9", "start": [544, 1], "end": [546, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_left", "code": "@[simp]\ntheorem Tape.mk'_left {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) : (Tape.mk' L R).left = L", "start": [549, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_head", "code": "@[simp]\ntheorem Tape.mk'_head {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) : (Tape.mk' L R).head = R.head", "start": [554, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_right", "code": "@[simp]\ntheorem Tape.mk'_right {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) : (Tape.mk' L R).right = R.tail", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_right\u2080", "code": "@[simp]\ntheorem Tape.mk'_right\u2080 {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) : (Tape.mk' L R).right\u2080 = R", "start": [564, 1], "end": [566, 29], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_left_right\u2080", "code": "@[simp]\ntheorem Tape.mk'_left_right\u2080 {\u0393} [Inhabited \u0393] (T : Tape \u0393) : Tape.mk' T.left T.right\u2080 = T", "start": [569, 1], "end": [573, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.exists_mk'", "code": "theorem Tape.exists_mk' {\u0393} [Inhabited \u0393] (T : Tape \u0393) : \u2203 L R, T = Tape.mk' L R", "start": [576, 1], "end": [577, 40], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_left_mk'", "code": "@[simp]\ntheorem Tape.move_left_mk' {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) :\n    (Tape.mk' L R).move Dir.left = Tape.mk' L.tail (R.cons L.head)", "start": [580, 1], "end": [584, 39], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_right_mk'", "code": "@[simp]\ntheorem Tape.move_right_mk' {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) :\n    (Tape.mk' L R).move Dir.right = Tape.mk' (L.cons R.head) R.tail", "start": [587, 1], "end": [591, 39], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk\u2082", "code": "def Tape.mk\u2082 {\u0393} [Inhabited \u0393] (L R : List \u0393) : Tape \u0393 :=\n  Tape.mk' (ListBlank.mk L) (ListBlank.mk R)", "start": [594, 1], "end": [596, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk\u2081", "code": "def Tape.mk\u2081 {\u0393} [Inhabited \u0393] (l : List \u0393) : Tape \u0393 :=\n  Tape.mk\u2082 [] l", "start": [599, 1], "end": [602, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.nth", "code": "def Tape.nth {\u0393} [Inhabited \u0393] (T : Tape \u0393) : \u2124 \u2192 \u0393\n  | 0 => T.head\n  | (n + 1 : \u2115) => T.right.nth n\n  | -(n + 1 : \u2115) => T.left.nth n", "start": [605, 1], "end": [610, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.nth_zero", "code": "@[simp]\ntheorem Tape.nth_zero {\u0393} [Inhabited \u0393] (T : Tape \u0393) : T.nth 0 = T.1", "start": [613, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.right\u2080_nth", "code": "theorem Tape.right\u2080_nth {\u0393} [Inhabited \u0393] (T : Tape \u0393) (n : \u2115) : T.right\u2080.nth n = T.nth n", "start": [618, 1], "end": [620, 79], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.mk'_nth_nat", "code": "@[simp]\ntheorem Tape.mk'_nth_nat {\u0393} [Inhabited \u0393] (L R : ListBlank \u0393) (n : \u2115) :\n    (Tape.mk' L R).nth n = R.nth n", "start": [623, 1], "end": [626, 42], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_left_nth", "code": "@[simp]\ntheorem Tape.move_left_nth {\u0393} [Inhabited \u0393] :\n    \u2200 (T : Tape \u0393) (i : \u2124), (T.move Dir.left).nth i = T.nth (i - 1)", "start": [629, 1], "end": [638, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_right_nth", "code": "@[simp]\ntheorem Tape.move_right_nth {\u0393} [Inhabited \u0393] (T : Tape \u0393) (i : \u2124) :\n    (T.move Dir.right).nth i = T.nth (i + 1)", "start": [641, 1], "end": [645, 42], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.move_right_n_head", "code": "@[simp]\ntheorem Tape.move_right_n_head {\u0393} [Inhabited \u0393] (T : Tape \u0393) (i : \u2115) :\n    ((Tape.move Dir.right)^[i] T).head = T.nth i", "start": [648, 1], "end": [653, 90], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.write", "code": "def Tape.write {\u0393} [Inhabited \u0393] (b : \u0393) (T : Tape \u0393) : Tape \u0393 :=\n  { T with head := b }", "start": [656, 1], "end": [658, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.write_self", "code": "@[simp]\ntheorem Tape.write_self {\u0393} [Inhabited \u0393] : \u2200 T : Tape \u0393, T.write T.1 = T", "start": [661, 1], "end": [663, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.write_nth", "code": "@[simp]\ntheorem Tape.write_nth {\u0393} [Inhabited \u0393] (b : \u0393) :\n    \u2200 (T : Tape \u0393) {i : \u2124}, (T.write b).nth i = if i = 0 then b else T.nth i", "start": [666, 1], "end": [671, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.write_mk'", "code": "@[simp]\ntheorem Tape.write_mk' {\u0393} [Inhabited \u0393] (a b : \u0393) (L R : ListBlank \u0393) :\n    (Tape.mk' L (R.cons a)).write b = Tape.mk' L (R.cons b)", "start": [674, 1], "end": [678, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map", "code": "def Tape.map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (T : Tape \u0393) : Tape \u0393' :=\n  \u27e8f T.1, T.2.map f, T.3.map f\u27e9", "start": [681, 1], "end": [683, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_fst", "code": "@[simp]\ntheorem Tape.map_fst {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') :\n    \u2200 T : Tape \u0393, (T.map f).1 = f T.1", "start": [686, 1], "end": [689, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_write", "code": "@[simp]\ntheorem Tape.map_write {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (b : \u0393) :\n    \u2200 T : Tape \u0393, (T.write b).map f = (T.map f).write (f b)", "start": [692, 1], "end": [695, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.write_move_right_n", "code": "@[simp, nolint simpNF]\ntheorem Tape.write_move_right_n {\u0393} [Inhabited \u0393] (f : \u0393 \u2192 \u0393) (L R : ListBlank \u0393) (n : \u2115) :\n    ((Tape.move Dir.right)^[n] (Tape.mk' L R)).write (f (R.nth n)) =\n      (Tape.move Dir.right)^[n] (Tape.mk' L (R.modifyNth f n))", "start": [700, 1], "end": [708, 49], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_move", "code": "theorem Tape.map_move {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (T : Tape \u0393) (d) :\n    (T.move d).map f = (T.map f).move d", "start": [711, 1], "end": [715, 58], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_mk'", "code": "theorem Tape.map_mk' {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (L R : ListBlank \u0393) :\n    (Tape.mk' L R).map f = Tape.mk' (L.map f) (R.map f)", "start": [718, 1], "end": [721, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_mk\u2082", "code": "theorem Tape.map_mk\u2082 {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (L R : List \u0393) :\n    (Tape.mk\u2082 L R).map f = Tape.mk\u2082 (L.map f) (R.map f)", "start": [724, 1], "end": [726, 55], "kind": "commanddeclaration"}, {"full_name": "Turing.Tape.map_mk\u2081", "code": "theorem Tape.map_mk\u2081 {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393') (l : List \u0393) :\n    (Tape.mk\u2081 l).map f = Tape.mk\u2081 (l.map f)", "start": [729, 1], "end": [731, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.eval", "code": "def eval {\u03c3} (f : \u03c3 \u2192 Option \u03c3) : \u03c3 \u2192 Part \u03c3 :=\n  PFun.fix fun s \u21a6 Part.some <| (f s).elim (Sum.inl s) Sum.inr", "start": [734, 1], "end": [738, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches", "code": "def Reaches {\u03c3} (f : \u03c3 \u2192 Option \u03c3) : \u03c3 \u2192 \u03c3 \u2192 Prop :=\n  ReflTransGen fun a b \u21a6 b \u2208 f a", "start": [741, 1], "end": [745, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2081", "code": "def Reaches\u2081 {\u03c3} (f : \u03c3 \u2192 Option \u03c3) : \u03c3 \u2192 \u03c3 \u2192 Prop :=\n  TransGen fun a b \u21a6 b \u2208 f a", "start": [748, 1], "end": [752, 29], "kind": "commanddeclaration"}, {"full_name": "Turing.reaches\u2081_eq", "code": "theorem reaches\u2081_eq {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c} (h : f a = f b) :\n    Reaches\u2081 f a c \u2194 Reaches\u2081 f b c", "start": [755, 1], "end": [757, 72], "kind": "commanddeclaration"}, {"full_name": "Turing.reaches_total", "code": "theorem reaches_total {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c} (hab : Reaches f a b) (hac : Reaches f a c) :\n    Reaches f b c \u2228 Reaches f c b", "start": [760, 1], "end": [762, 77], "kind": "commanddeclaration"}, {"full_name": "Turing.reaches\u2081_fwd", "code": "theorem reaches\u2081_fwd {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c} (h\u2081 : Reaches\u2081 f a c) (h\u2082 : b \u2208 f a) :\n    Reaches f b c", "start": [765, 1], "end": [768, 44], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080", "code": "def Reaches\u2080 {\u03c3} (f : \u03c3 \u2192 Option \u03c3) (a b : \u03c3) : Prop :=\n  \u2200 c, Reaches\u2081 f b c \u2192 Reaches\u2081 f a c", "start": [771, 1], "end": [775, 39], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.trans", "code": "theorem Reaches\u2080.trans {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c : \u03c3} (h\u2081 : Reaches\u2080 f a b)\n    (h\u2082 : Reaches\u2080 f b c) : Reaches\u2080 f a c", "start": [778, 1], "end": [780, 28], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.refl", "code": "@[refl]\ntheorem Reaches\u2080.refl {\u03c3} {f : \u03c3 \u2192 Option \u03c3} (a : \u03c3) : Reaches\u2080 f a a", "start": [783, 1], "end": [785, 14], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.single", "code": "theorem Reaches\u2080.single {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b : \u03c3} (h : b \u2208 f a) : Reaches\u2080 f a b", "start": [788, 1], "end": [789, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.head", "code": "theorem Reaches\u2080.head {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c : \u03c3} (h : b \u2208 f a) (h\u2082 : Reaches\u2080 f b c) :\n    Reaches\u2080 f a c", "start": [792, 1], "end": [794, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.tail", "code": "theorem Reaches\u2080.tail {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c : \u03c3} (h\u2081 : Reaches\u2080 f a b) (h : c \u2208 f b) :\n    Reaches\u2080 f a c", "start": [797, 1], "end": [799, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.reaches\u2080_eq", "code": "theorem reaches\u2080_eq {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b} (e : f a = f b) : Reaches\u2080 f a b", "start": [802, 1], "end": [803, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2081.to\u2080", "code": "theorem Reaches\u2081.to\u2080 {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b : \u03c3} (h : Reaches\u2081 f a b) : Reaches\u2080 f a b", "start": [806, 1], "end": [807, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches.to\u2080", "code": "theorem Reaches.to\u2080 {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b : \u03c3} (h : Reaches f a b) : Reaches\u2080 f a b", "start": [810, 1], "end": [811, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.Reaches\u2080.tail'", "code": "theorem Reaches\u2080.tail' {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b c : \u03c3} (h : Reaches\u2080 f a b) (h\u2082 : c \u2208 f b) :\n    Reaches\u2081 f a c", "start": [814, 1], "end": [816, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.evalInduction", "code": "@[elab_as_elim]\ndef evalInduction {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {b : \u03c3} {C : \u03c3 \u2192 Sort*} {a : \u03c3}\n    (h : b \u2208 eval f a) (H : \u2200 a, b \u2208 eval f a \u2192 (\u2200 a', f a = some a' \u2192 C a') \u2192 C a) : C a :=\n  PFun.fixInduction h fun a' ha' h' \u21a6\n    H _ ha' fun b' e \u21a6 h' _ <| Part.mem_some_iff.2 <| by rw [e]; rfl", "start": [819, 1], "end": [827, 69], "kind": "commanddeclaration"}, {"full_name": "Turing.mem_eval", "code": "theorem mem_eval {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b} : b \u2208 eval f a \u2194 Reaches f a b \u2227 f b = none", "start": [830, 1], "end": [848, 26], "kind": "commanddeclaration"}, {"full_name": "Turing.eval_maximal\u2081", "code": "theorem eval_maximal\u2081 {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b} (h : b \u2208 eval f a) (c) : \u00acReaches\u2081 f b c", "start": [851, 1], "end": [855, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.eval_maximal", "code": "theorem eval_maximal {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b} (h : b \u2208 eval f a) {c} : Reaches f b c \u2194 c = b", "start": [858, 1], "end": [860, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.reaches_eval", "code": "theorem reaches_eval {\u03c3} {f : \u03c3 \u2192 Option \u03c3} {a b} (ab : Reaches f a b) : eval f a = eval f b", "start": [863, 1], "end": [869, 39], "kind": "commanddeclaration"}, {"full_name": "Turing.Respects", "code": "def Respects {\u03c3\u2081 \u03c3\u2082} (f\u2081 : \u03c3\u2081 \u2192 Option \u03c3\u2081) (f\u2082 : \u03c3\u2082 \u2192 Option \u03c3\u2082) (tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop) :=\n  \u2200 \u2983a\u2081 a\u2082\u2984, tr a\u2081 a\u2082 \u2192 (match f\u2081 a\u2081 with\n    | some b\u2081 => \u2203 b\u2082, tr b\u2081 b\u2082 \u2227 Reaches\u2081 f\u2082 a\u2082 b\u2082\n    | none => f\u2082 a\u2082 = none : Prop)", "start": [872, 1], "end": [880, 35], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_reaches\u2081", "code": "theorem tr_reaches\u2081 {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 a\u2082}\n    (aa : tr a\u2081 a\u2082) {b\u2081} (ab : Reaches\u2081 f\u2081 a\u2081 b\u2081) : \u2203 b\u2082, tr b\u2081 b\u2082 \u2227 Reaches\u2081 f\u2082 a\u2082 b\u2082", "start": [883, 1], "end": [892, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_reaches", "code": "theorem tr_reaches {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 a\u2082}\n    (aa : tr a\u2081 a\u2082) {b\u2081} (ab : Reaches f\u2081 a\u2081 b\u2081) : \u2203 b\u2082, tr b\u2081 b\u2082 \u2227 Reaches f\u2082 a\u2082 b\u2082", "start": [895, 1], "end": [900, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_reaches_rev", "code": "theorem tr_reaches_rev {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 a\u2082}\n    (aa : tr a\u2081 a\u2082) {b\u2082} (ab : Reaches f\u2082 a\u2082 b\u2082) :\n    \u2203 c\u2081 c\u2082, Reaches f\u2082 b\u2082 c\u2082 \u2227 tr c\u2081 c\u2082 \u2227 Reaches f\u2081 a\u2081 c\u2081", "start": [903, 1], "end": [920, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_eval", "code": "theorem tr_eval {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 b\u2081 a\u2082}\n    (aa : tr a\u2081 a\u2082) (ab : b\u2081 \u2208 eval f\u2081 a\u2081) : \u2203 b\u2082, tr b\u2081 b\u2082 \u2227 b\u2082 \u2208 eval f\u2082 a\u2082", "start": [923, 1], "end": [928, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_eval_rev", "code": "theorem tr_eval_rev {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 b\u2082 a\u2082}\n    (aa : tr a\u2081 a\u2082) (ab : b\u2082 \u2208 eval f\u2082 a\u2082) : \u2203 b\u2081, tr b\u2081 b\u2082 \u2227 b\u2081 \u2208 eval f\u2081 a\u2081", "start": [931, 1], "end": [943, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_eval_dom", "code": "theorem tr_eval_dom {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop} (H : Respects f\u2081 f\u2082 tr) {a\u2081 a\u2082}\n    (aa : tr a\u2081 a\u2082) : (eval f\u2082 a\u2082).Dom \u2194 (eval f\u2081 a\u2081).Dom", "start": [946, 1], "end": [953, 7], "kind": "commanddeclaration"}, {"full_name": "Turing.FRespects", "code": "def FRespects {\u03c3\u2081 \u03c3\u2082} (f\u2082 : \u03c3\u2082 \u2192 Option \u03c3\u2082) (tr : \u03c3\u2081 \u2192 \u03c3\u2082) (a\u2082 : \u03c3\u2082) : Option \u03c3\u2081 \u2192 Prop\n  | some b\u2081 => Reaches\u2081 f\u2082 a\u2082 (tr b\u2081)\n  | none => f\u2082 a\u2082 = none", "start": [956, 1], "end": [959, 25], "kind": "commanddeclaration"}, {"full_name": "Turing.frespects_eq", "code": "theorem frespects_eq {\u03c3\u2081 \u03c3\u2082} {f\u2082 : \u03c3\u2082 \u2192 Option \u03c3\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082} {a\u2082 b\u2082} (h : f\u2082 a\u2082 = f\u2082 b\u2082) :\n    \u2200 {b\u2081}, FRespects f\u2082 tr a\u2082 b\u2081 \u2194 FRespects f\u2082 tr b\u2082 b\u2081", "start": [962, 1], "end": [965, 40], "kind": "commanddeclaration"}, {"full_name": "Turing.fun_respects", "code": "theorem fun_respects {\u03c3\u2081 \u03c3\u2082 f\u2081 f\u2082} {tr : \u03c3\u2081 \u2192 \u03c3\u2082} :\n    (Respects f\u2081 f\u2082 fun a b \u21a6 tr a = b) \u2194 \u2200 \u2983a\u2081\u2984, FRespects f\u2082 tr (tr a\u2081) (f\u2081 a\u2081)", "start": [968, 1], "end": [971, 81], "kind": "commanddeclaration"}, {"full_name": "Turing.tr_eval'", "code": "theorem tr_eval' {\u03c3\u2081 \u03c3\u2082} (f\u2081 : \u03c3\u2081 \u2192 Option \u03c3\u2081) (f\u2082 : \u03c3\u2082 \u2192 Option \u03c3\u2082) (tr : \u03c3\u2081 \u2192 \u03c3\u2082)\n    (H : Respects f\u2081 f\u2082 fun a b \u21a6 tr a = b) (a\u2081) : eval f\u2082 (tr a\u2081) = tr <$> eval f\u2081 a\u2081", "start": [974, 1], "end": [983, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Stmt", "code": "inductive Stmt\n  | move : Dir \u2192 Stmt\n  | write : \u0393 \u2192 Stmt", "start": [1024, 1], "end": [1028, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Stmt.inhabited", "code": "instance Stmt.inhabited : Inhabited Stmt\u2080 :=\n  \u27e8Stmt.write default\u27e9", "start": [1033, 1], "end": [1034, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Machine", "code": "@[nolint unusedArguments] def Machine [Inhabited \u039b] :=\n  \u039b \u2192 \u0393 \u2192 Option (\u039b \u00d7 Stmt\u2080)", "start": [1037, 1], "end": [1048, 29], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Machine.inhabited", "code": "instance Machine.inhabited : Inhabited Machine\u2080 := by\n  unfold Machine; infer_instance", "start": [1053, 1], "end": [1054, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Cfg", "code": "structure Cfg where\n  q : \u039b\n  Tape : Tape \u0393", "start": [1057, 1], "end": [1064, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Cfg.inhabited", "code": "instance Cfg.inhabited : Inhabited Cfg\u2080 :=\n  \u27e8\u27e8default, default\u27e9\u27e9", "start": [1069, 1], "end": [1070, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.step", "code": "def step (M : Machine\u2080) : Cfg\u2080 \u2192 Option Cfg\u2080 :=\n  fun \u27e8q, T\u27e9 \u21a6 (M q T.1).map fun \u27e8q', a\u27e9 \u21a6 \u27e8q', match a with\n    | Stmt.move d => T.move d\n    | Stmt.write a => T.write a\u27e9", "start": [1075, 1], "end": [1079, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Reaches", "code": "def Reaches (M : Machine\u2080) : Cfg\u2080 \u2192 Cfg\u2080 \u2192 Prop :=\n  ReflTransGen fun a b \u21a6 b \u2208 step M a", "start": [1082, 1], "end": [1085, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.init", "code": "def init (l : List \u0393) : Cfg\u2080 :=\n  \u27e8default, Tape.mk\u2081 l\u27e9", "start": [1088, 1], "end": [1090, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.eval", "code": "def eval (M : Machine\u2080) (l : List \u0393) : Part (ListBlank \u0393) :=\n  (Turing.eval (step M) (init l)).map fun c \u21a6 c.Tape.right\u2080", "start": [1093, 1], "end": [1096, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Supports", "code": "def Supports (M : Machine\u2080) (S : Set \u039b) :=\n  default \u2208 S \u2227 \u2200 {q a q' s}, (q', s) \u2208 M q a \u2192 q \u2208 S \u2192 q' \u2208 S", "start": [1099, 1], "end": [1107, 63], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.step_supports", "code": "theorem step_supports (M : Machine\u2080) {S : Set \u039b} (ss : Supports M S) :\n    \u2200 {c c' : Cfg\u2080}, c' \u2208 step M c \u2192 c.q \u2208 S \u2192 c'.q \u2208 S", "start": [1110, 1], "end": [1114, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.univ_supports", "code": "theorem univ_supports (M : Machine\u2080) : Supports M Set.univ", "start": [1117, 1], "end": [1118, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Stmt.map", "code": "def Stmt.map (f : PointedMap \u0393 \u0393') : Stmt \u0393 \u2192 Stmt \u0393'\n  | Stmt.move d => Stmt.move d\n  | Stmt.write a => Stmt.write (f a)", "start": [1133, 1], "end": [1137, 37], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Cfg.map", "code": "def Cfg.map (f : PointedMap \u0393 \u0393') (g : \u039b \u2192 \u039b') : Cfg \u0393 \u039b \u2192 Cfg \u0393' \u039b'\n  | \u27e8q, T\u27e9 => \u27e8g q, T.map f\u27e9", "start": [1140, 1], "end": [1143, 29], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Machine.map", "code": "def Machine.map : Machine \u0393' \u039b'\n  | q, l => (M (g\u2082 q) (f\u2082 l)).map (Prod.map g\u2081 (Stmt.map f\u2081))", "start": [1148, 1], "end": [1152, 62], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Machine.map_step", "code": "theorem Machine.map_step {S : Set \u039b} (f\u2082\u2081 : Function.RightInverse f\u2081 f\u2082)\n    (g\u2082\u2081 : \u2200 q \u2208 S, g\u2082 (g\u2081 q) = q) :\n    \u2200 c : Cfg \u0393 \u039b,\n      c.q \u2208 S \u2192 (step M c).map (Cfg.map f\u2081 g\u2081) = step (M.map f\u2081 f\u2082 g\u2081 g\u2082) (Cfg.map f\u2081 g\u2081 c)", "start": [1155, 1], "end": [1166, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.map_init", "code": "theorem map_init (g\u2081 : PointedMap \u039b \u039b') (l : List \u0393) : (init l).map f\u2081 g\u2081 = init (l.map f\u2081)", "start": [1169, 1], "end": [1170, 56], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0.Machine.map_respects", "code": "theorem Machine.map_respects (g\u2081 : PointedMap \u039b \u039b') (g\u2082 : \u039b' \u2192 \u039b) {S} (ss : Supports M S)\n    (f\u2082\u2081 : Function.RightInverse f\u2081 f\u2082) (g\u2082\u2081 : \u2200 q \u2208 S, g\u2082 (g\u2081 q) = q) :\n    Respects (step M) (step (M.map f\u2081 f\u2082 g\u2081 g\u2082)) fun a b \u21a6 a.q \u2208 S \u2227 Cfg.map f\u2081 g\u2081 a = b", "start": [1173, 1], "end": [1182, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.Stmt", "code": "inductive Stmt\n  | move : Dir \u2192 Stmt \u2192 Stmt\n  | write : (\u0393 \u2192 \u03c3 \u2192 \u0393) \u2192 Stmt \u2192 Stmt\n  | load : (\u0393 \u2192 \u03c3 \u2192 \u03c3) \u2192 Stmt \u2192 Stmt\n  | branch : (\u0393 \u2192 \u03c3 \u2192 Bool) \u2192 Stmt \u2192 Stmt \u2192 Stmt\n  | goto : (\u0393 \u2192 \u03c3 \u2192 \u039b) \u2192 Stmt\n  | halt : Stmt", "start": [1235, 1], "end": [1253, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.Stmt.inhabited", "code": "instance Stmt.inhabited : Inhabited Stmt\u2081 :=\n  \u27e8halt\u27e9", "start": [1260, 1], "end": [1261, 9], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.Cfg", "code": "structure Cfg where\n  l : Option \u039b\n  var : \u03c3\n  Tape : Tape \u0393", "start": [1264, 1], "end": [1269, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.Cfg.inhabited", "code": "instance Cfg.inhabited [Inhabited \u03c3] : Inhabited Cfg\u2081 :=\n  \u27e8\u27e8default, default, default\u27e9\u27e9", "start": [1274, 1], "end": [1275, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stepAux", "code": "def stepAux : Stmt\u2081 \u2192 \u03c3 \u2192 Tape \u0393 \u2192 Cfg\u2081\n  | move d q, v, T => stepAux q v (T.move d)\n  | write a q, v, T => stepAux q v (T.write (a T.1 v))\n  | load s q, v, T => stepAux q (s T.1 v) T\n  | branch p q\u2081 q\u2082, v, T => cond (p T.1 v) (stepAux q\u2081 v T) (stepAux q\u2082 v T)\n  | goto l, v, T => \u27e8some (l T.1 v), v, T\u27e9\n  | halt, v, T => \u27e8none, v, T\u27e9", "start": [1280, 1], "end": [1287, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.step", "code": "def step (M : \u039b \u2192 Stmt\u2081) : Cfg\u2081 \u2192 Option Cfg\u2081\n  | \u27e8none, _, _\u27e9 => none\n  | \u27e8some l, v, T\u27e9 => some (stepAux (M l) v T)", "start": [1290, 1], "end": [1293, 47], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.SupportsStmt", "code": "def SupportsStmt (S : Finset \u039b) : Stmt\u2081 \u2192 Prop\n  | move _ q => SupportsStmt S q\n  | write _ q => SupportsStmt S q\n  | load _ q => SupportsStmt S q\n  | branch _ q\u2081 q\u2082 => SupportsStmt S q\u2081 \u2227 SupportsStmt S q\u2082\n  | goto l => \u2200 a v, l a v \u2208 S\n  | halt => True", "start": [1296, 1], "end": [1304, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts\u2081", "code": "noncomputable def stmts\u2081 : Stmt\u2081 \u2192 Finset Stmt\u2081\n  | Q@(move _ q) => insert Q (stmts\u2081 q)\n  | Q@(write _ q) => insert Q (stmts\u2081 q)\n  | Q@(load _ q) => insert Q (stmts\u2081 q)\n  | Q@(branch _ q\u2081 q\u2082) => insert Q (stmts\u2081 q\u2081 \u222a stmts\u2081 q\u2082)\n  | Q => {Q}", "start": [1309, 1], "end": [1315, 13], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts\u2081_self", "code": "theorem stmts\u2081_self {q : Stmt\u2081} : q \u2208 stmts\u2081 q", "start": [1318, 1], "end": [1319, 84], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts\u2081_trans", "code": "theorem stmts\u2081_trans {q\u2081 q\u2082 : Stmt\u2081} : q\u2081 \u2208 stmts\u2081 q\u2082 \u2192 stmts\u2081 q\u2081 \u2286 stmts\u2081 q\u2082", "start": [1322, 1], "end": [1338, 36], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts\u2081_supportsStmt_mono", "code": "theorem stmts\u2081_supportsStmt_mono {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2081} (h : q\u2081 \u2208 stmts\u2081 q\u2082)\n    (hs : SupportsStmt S q\u2082) : SupportsStmt S q\u2081", "start": [1341, 1], "end": [1349, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts", "code": "noncomputable def stmts (M : \u039b \u2192 Stmt\u2081) (S : Finset \u039b) : Finset (Option Stmt\u2081) :=\n  Finset.insertNone (S.biUnion fun q \u21a6 stmts\u2081 (M q))", "start": [1352, 1], "end": [1355, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts_trans", "code": "theorem stmts_trans {M : \u039b \u2192 Stmt\u2081} {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2081} (h\u2081 : q\u2081 \u2208 stmts\u2081 q\u2082) :\n    some q\u2082 \u2208 stmts M S \u2192 some q\u2081 \u2208 stmts M S", "start": [1358, 1], "end": [1362, 50], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.Supports", "code": "def Supports (M : \u039b \u2192 Stmt\u2081) (S : Finset \u039b) :=\n  default \u2208 S \u2227 \u2200 q \u2208 S, SupportsStmt S (M q)", "start": [1367, 1], "end": [1371, 46], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.stmts_supportsStmt", "code": "theorem stmts_supportsStmt {M : \u039b \u2192 Stmt\u2081} {S : Finset \u039b} {q : Stmt\u2081} (ss : Supports M S) :\n    some q \u2208 stmts M S \u2192 SupportsStmt S q", "start": [1374, 1], "end": [1378, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.step_supports", "code": "theorem step_supports (M : \u039b \u2192 Stmt\u2081) {S : Finset \u039b} (ss : Supports M S) :\n    \u2200 {c c' : Cfg\u2081}, c' \u2208 step M c \u2192 c.l \u2208 Finset.insertNone S \u2192 c'.l \u2208 Finset.insertNone S", "start": [1381, 1], "end": [1393, 46], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.init", "code": "def init (l : List \u0393) : Cfg\u2081 :=\n  \u27e8some default, default, Tape.mk\u2081 l\u27e9", "start": [1398, 1], "end": [1401, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1.eval", "code": "def eval (M : \u039b \u2192 Stmt\u2081) (l : List \u0393) : Part (ListBlank \u0393) :=\n  (Turing.eval (step M) (init l)).map fun c \u21a6 c.Tape.right\u2080", "start": [1404, 1], "end": [1407, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.\u039b'", "code": "@[nolint unusedArguments] def \u039b' (M : \u039b \u2192 TM1.Stmt \u0393 \u039b \u03c3) :=\n  Option Stmt\u2081 \u00d7 \u03c3", "start": [1456, 1], "end": [1463, 19], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.trAux", "code": "def trAux (s : \u0393) : Stmt\u2081 \u2192 \u03c3 \u2192 \u039b'\u2081\u2080 \u00d7 Stmt\u2080\n  | TM1.Stmt.move d q, v => ((some q, v), move d)\n  | TM1.Stmt.write a q, v => ((some q, v), write (a s v))\n  | TM1.Stmt.load a q, v => trAux s q (a s v)\n  | TM1.Stmt.branch p q\u2081 q\u2082, v => cond (p s v) (trAux s q\u2081 v) (trAux s q\u2082 v)\n  | TM1.Stmt.goto l, v => ((some (M (l s v)), v), write s)\n  | TM1.Stmt.halt, v => ((none, v), write s)", "start": [1473, 1], "end": [1483, 45], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.tr", "code": "def tr : TM0.Machine \u0393 \u039b'\u2081\u2080\n  | (none, _), _ => none\n  | (some q, v), s => some (trAux M s q v)", "start": [1488, 1], "end": [1491, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.trCfg", "code": "def trCfg : Cfg\u2081 \u2192 Cfg\u2081\u2080\n  | \u27e8l, v, T\u27e9 => \u27e8(l.map M, v), T\u27e9", "start": [1494, 1], "end": [1496, 35], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.tr_respects", "code": "theorem tr_respects :\n    Respects (TM1.step M) (TM0.step (tr M)) fun (c\u2081 : Cfg\u2081) (c\u2082 : Cfg\u2081\u2080) \u21a6 trCfg M c\u2081 = c\u2082", "start": [1499, 1], "end": [1513, 100], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.tr_eval", "code": "theorem tr_eval (l : List \u0393) : TM0.eval (tr M) l = TM1.eval M l", "start": [1516, 1], "end": [1520, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.trStmts", "code": "noncomputable def trStmts (S : Finset \u039b) : Finset \u039b'\u2081\u2080 :=\n  (TM1.stmts M S) \u00d7\u02e2 Finset.univ", "start": [1525, 1], "end": [1528, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to0.tr_supports", "code": "theorem tr_supports {S : Finset \u039b} (ss : TM1.Supports M S) :\n    TM0.Supports (tr M) \u2191(trStmts M S)", "start": [1535, 1], "end": [1577, 26], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.exists_enc_dec", "code": "theorem exists_enc_dec [Fintype \u0393] : \u2203 (n : \u2115) (enc : \u0393 \u2192 Vector Bool n) (dec : Vector Bool n \u2192 \u0393),\n    enc default = Vector.replicate n false \u2227 \u2200 a, dec (enc a) = a", "start": [1619, 1], "end": [1630, 94], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.\u039b'", "code": "inductive \u039b'\n  | normal : \u039b \u2192 \u039b'\n  | write : \u0393 \u2192 Stmt\u2081 \u2192 \u039b'", "start": [1641, 1], "end": [1644, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.readAux", "code": "def readAux : \u2200 n, (Vector Bool n \u2192 Stmt'\u2081) \u2192 Stmt'\u2081\n  | 0, f => f Vector.nil\n  | i + 1, f =>\n    Stmt.branch (fun a _ \u21a6 a) (Stmt.move Dir.right <| readAux i fun v \u21a6 f (true ::\u1d65 v))\n      (Stmt.move Dir.right <| readAux i fun v \u21a6 f (false ::\u1d65 v))", "start": [1656, 1], "end": [1661, 65], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.move", "code": "def move (d : Dir) (q : Stmt'\u2081) : Stmt'\u2081 :=\n  (Stmt.move d)^[n] q", "start": [1666, 1], "end": [1668, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.read", "code": "def read (f : \u0393 \u2192 Stmt'\u2081) : Stmt'\u2081 :=\n  readAux n fun v \u21a6 move\u2099 Dir.left <| f (dec v)", "start": [1673, 1], "end": [1676, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.write", "code": "def write : List Bool \u2192 Stmt'\u2081 \u2192 Stmt'\u2081\n  | [], q => q\n  | a :: l, q => (Stmt.write fun _ _ \u21a6 a) <| Stmt.move Dir.right <| write l q", "start": [1679, 1], "end": [1682, 78], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trNormal", "code": "def trNormal : Stmt\u2081 \u2192 Stmt'\u2081\n  | Stmt.move d q => move\u2099 d <| trNormal q\n  | Stmt.write f q => read dec fun a \u21a6 Stmt.goto fun _ s \u21a6 \u039b'.write (f a s) q\n  | Stmt.load f q => read dec fun a \u21a6 (Stmt.load fun _ s \u21a6 f a s) <| trNormal q\n  | Stmt.branch p q\u2081 q\u2082 =>\n    read dec fun a \u21a6 Stmt.branch (fun _ s \u21a6 p a s) (trNormal q\u2081) (trNormal q\u2082)\n  | Stmt.goto l => read dec fun a \u21a6 Stmt.goto fun _ s \u21a6 \u039b'.normal (l a s)\n  | Stmt.halt => Stmt.halt", "start": [1685, 1], "end": [1694, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.stepAux_move", "code": "theorem stepAux_move (d : Dir) (q : Stmt'\u2081) (v : \u03c3) (T : Tape Bool) :\n    stepAux (move\u2099 d q) v T = stepAux q v ((Tape.move d)^[n] T)", "start": [1697, 1], "end": [1703, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.supportsStmt_move", "code": "theorem supportsStmt_move {S : Finset \u039b'\u2081} {d : Dir} {q : Stmt'\u2081} :\n    SupportsStmt S (move\u2099 d q) = SupportsStmt S q", "start": [1706, 1], "end": [1709, 70], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.supportsStmt_write", "code": "theorem supportsStmt_write {S : Finset \u039b'\u2081} {l : List Bool} {q : Stmt'\u2081} :\n    SupportsStmt S (write l q) = SupportsStmt S q", "start": [1712, 1], "end": [1714, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.supportsStmt_read", "code": "theorem supportsStmt_read {S : Finset \u039b'\u2081} :\n    \u2200 {f : \u0393 \u2192 Stmt'\u2081}, (\u2200 a, SupportsStmt S (f a)) \u2192 SupportsStmt S (read dec f)", "start": [1717, 1], "end": [1724, 50], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trTape'", "code": "def trTape' (L R : ListBlank \u0393) : Tape Bool := by\n  refine'\n      Tape.mk' (L.bind (fun x \u21a6 (enc x).toList.reverse) \u27e8n, _\u27e9)\n        (R.bind (fun x \u21a6 (enc x).toList) \u27e8n, _\u27e9) <;>\n    simp only [enc0, Vector.replicate, List.reverse_replicate, Bool.default_bool, Vector.toList_mk]", "start": [1733, 1], "end": [1738, 100], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trTape", "code": "def trTape (T : Tape \u0393) : Tape Bool :=\n  trTape' enc0 T.left T.right\u2080", "start": [1741, 1], "end": [1743, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trTape_mk'", "code": "theorem trTape_mk' (L R : ListBlank \u0393) : trTape enc0 (Tape.mk' L R) = trTape' enc0 L R", "start": [1746, 1], "end": [1747, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.tr", "code": "def tr : \u039b'\u2081 \u2192 Stmt'\u2081\n  | \u039b'.normal l => trNormal dec (M l)\n  | \u039b'.write a q => write (enc a).toList <| move\u2099 Dir.left <| trNormal dec q", "start": [1754, 1], "end": [1757, 77], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trCfg", "code": "def trCfg : Cfg\u2081 \u2192 Cfg'\u2081\n  | \u27e8l, v, T\u27e9 => \u27e8l.map \u039b'.normal, v, trTape enc0 T\u27e9", "start": [1760, 1], "end": [1762, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trTape'_move_left", "code": "theorem trTape'_move_left (L R : ListBlank \u0393) :\n    (Tape.move Dir.left)^[n] (trTape' enc0 L R) = trTape' enc0 L.tail (R.cons L.head)", "start": [1767, 1], "end": [1782, 93], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trTape'_move_right", "code": "theorem trTape'_move_right (L R : ListBlank \u0393) :\n    (Tape.move Dir.right)^[n] (trTape' enc0 L R) = trTape' enc0 (L.cons R.head) R.tail", "start": [1785, 1], "end": [1794, 73], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.stepAux_write", "code": "theorem stepAux_write (q : Stmt'\u2081) (v : \u03c3) (a b : \u0393) (L R : ListBlank \u0393) :\n    stepAux (write (enc a).toList q) v (trTape' enc0 L (ListBlank.cons b R)) =\n      stepAux q v (trTape' enc0 (ListBlank.cons a L) R)", "start": [1797, 1], "end": [1813, 25], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.stepAux_read", "code": "theorem stepAux_read (f : \u0393 \u2192 Stmt'\u2081) (v : \u03c3) (L R : ListBlank \u0393) :\n    stepAux (read dec f) v (trTape' enc0 L R) = stepAux (f R.head) v (trTape' enc0 L R)", "start": [1818, 1], "end": [1846, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.tr_respects", "code": "theorem tr_respects {enc\u2080} :\n    Respects (step M) (step (tr enc dec M)) fun c\u2081 c\u2082 \u21a6 trCfg enc enc\u2080 c\u2081 = c\u2082", "start": [1849, 1], "end": [1888, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.writes", "code": "noncomputable def writes : Stmt\u2081 \u2192 Finset \u039b'\u2081\n  | Stmt.move _ q => writes q\n  | Stmt.write _ q => (Finset.univ.image fun a \u21a6 \u039b'.write a q) \u222a writes q\n  | Stmt.load _ q => writes q\n  | Stmt.branch _ q\u2081 q\u2082 => writes q\u2081 \u222a writes q\u2082\n  | Stmt.goto _ => \u2205\n  | Stmt.halt => \u2205", "start": [1895, 1], "end": [1902, 19], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.trSupp", "code": "noncomputable def trSupp (S : Finset \u039b) : Finset \u039b'\u2081 :=\n  S.biUnion fun l \u21a6 insert (\u039b'.normal l) (writes (M l))", "start": [1905, 1], "end": [1908, 56], "kind": "commanddeclaration"}, {"full_name": "Turing.TM1to1.tr_supports", "code": "theorem tr_supports {S : Finset \u039b} (ss : Supports M S) : Supports (tr enc dec M) (trSupp M S)", "start": [1911, 1], "end": [1952, 61], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0to1.\u039b'", "code": "inductive \u039b'\n  | normal : \u039b \u2192 \u039b'\n  | act : TM0.Stmt \u0393 \u2192 \u039b \u2192 \u039b'", "start": [1985, 1], "end": [1990, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0to1.tr", "code": "def tr : \u039b'\u2081 \u2192 Stmt\u2081\n  | \u039b'.normal q =>\n    branch (fun a _ \u21a6 (M q a).isNone) halt <|\n      goto fun a _ \u21a6 match M q a with\n      | none => default | some (q', s) => \u039b'.act s q'\n  | \u039b'.act (TM0.Stmt.move d) q => move d <| goto fun _ _ \u21a6 \u039b'.normal q\n  | \u039b'.act (TM0.Stmt.write a) q => (write fun _ _ \u21a6 a) <| goto fun _ _ \u21a6 \u039b'.normal q", "start": [2008, 1], "end": [2016, 85], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0to1.trCfg", "code": "def trCfg : Cfg\u2080 \u2192 Cfg\u2081\n  | \u27e8q, T\u27e9 => \u27e8cond (M q T.1).isSome (some (\u039b'.normal q)) none, (), T\u27e9", "start": [2019, 1], "end": [2021, 71], "kind": "commanddeclaration"}, {"full_name": "Turing.TM0to1.tr_respects", "code": "theorem tr_respects : Respects (TM0.step M) (TM1.step (tr M)) fun a b \u21a6 trCfg M a = b", "start": [2024, 1], "end": [2045, 10], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Stmt", "code": "inductive Stmt\n  | push : \u2200 k, (\u03c3 \u2192 \u0393 k) \u2192 Stmt \u2192 Stmt\n  | peek : \u2200 k, (\u03c3 \u2192 Option (\u0393 k) \u2192 \u03c3) \u2192 Stmt \u2192 Stmt\n  | pop : \u2200 k, (\u03c3 \u2192 Option (\u0393 k) \u2192 \u03c3) \u2192 Stmt \u2192 Stmt\n  | load : (\u03c3 \u2192 \u03c3) \u2192 Stmt \u2192 Stmt\n  | branch : (\u03c3 \u2192 Bool) \u2192 Stmt \u2192 Stmt \u2192 Stmt\n  | goto : (\u03c3 \u2192 \u039b) \u2192 Stmt\n  | halt : Stmt", "start": [2099, 1], "end": [2112, 16], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Stmt.inhabited", "code": "instance Stmt.inhabited : Inhabited Stmt\u2082 :=\n  \u27e8halt\u27e9", "start": [2119, 1], "end": [2120, 9], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Cfg", "code": "structure Cfg where\n  l : Option \u039b\n  var : \u03c3\n  stk : \u2200 k, List (\u0393 k)", "start": [2123, 1], "end": [2129, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Cfg.inhabited", "code": "instance Cfg.inhabited [Inhabited \u03c3] : Inhabited Cfg\u2082 :=\n  \u27e8\u27e8default, default, default\u27e9\u27e9", "start": [2134, 1], "end": [2135, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stepAux", "code": "@[simp]\ndef stepAux : Stmt\u2082 \u2192 \u03c3 \u2192 (\u2200 k, List (\u0393 k)) \u2192 Cfg\u2082\n  | push k f q, v, S => stepAux q v (update S k (f v :: S k))\n  | peek k f q, v, S => stepAux q (f v (S k).head?) S\n  | pop k f q, v, S => stepAux q (f v (S k).head?) (update S k (S k).tail)\n  | load a q, v, S => stepAux q (a v) S\n  | branch f q\u2081 q\u2082, v, S => cond (f v) (stepAux q\u2081 v S) (stepAux q\u2082 v S)\n  | goto f, v, S => \u27e8some (f v), v, S\u27e9\n  | halt, v, S => \u27e8none, v, S\u27e9", "start": [2140, 1], "end": [2149, 31], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.step", "code": "@[simp]\ndef step (M : \u039b \u2192 Stmt\u2082) : Cfg\u2082 \u2192 Option Cfg\u2082\n  | \u27e8none, _, _\u27e9 => none\n  | \u27e8some l, v, S\u27e9 => some (stepAux (M l) v S)", "start": [2152, 1], "end": [2156, 47], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Reaches", "code": "def Reaches (M : \u039b \u2192 Stmt\u2082) : Cfg\u2082 \u2192 Cfg\u2082 \u2192 Prop :=\n  ReflTransGen fun a b \u21a6 b \u2208 step M a", "start": [2159, 1], "end": [2161, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.SupportsStmt", "code": "def SupportsStmt (S : Finset \u039b) : Stmt\u2082 \u2192 Prop\n  | push _ _ q => SupportsStmt S q\n  | peek _ _ q => SupportsStmt S q\n  | pop _ _ q => SupportsStmt S q\n  | load _ q => SupportsStmt S q\n  | branch _ q\u2081 q\u2082 => SupportsStmt S q\u2081 \u2227 SupportsStmt S q\u2082\n  | goto l => \u2200 v, l v \u2208 S\n  | halt => True", "start": [2164, 1], "end": [2172, 17], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts\u2081", "code": "noncomputable def stmts\u2081 : Stmt\u2082 \u2192 Finset Stmt\u2082\n  | Q@(push _ _ q) => insert Q (stmts\u2081 q)\n  | Q@(peek _ _ q) => insert Q (stmts\u2081 q)\n  | Q@(pop _ _ q) => insert Q (stmts\u2081 q)\n  | Q@(load _ q) => insert Q (stmts\u2081 q)\n  | Q@(branch _ q\u2081 q\u2082) => insert Q (stmts\u2081 q\u2081 \u222a stmts\u2081 q\u2082)\n  | Q@(goto _) => {Q}\n  | Q@halt => {Q}", "start": [2177, 1], "end": [2185, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts\u2081_self", "code": "theorem stmts\u2081_self {q : Stmt\u2082} : q \u2208 stmts\u2081 q", "start": [2188, 1], "end": [2189, 84], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts\u2081_trans", "code": "theorem stmts\u2081_trans {q\u2081 q\u2082 : Stmt\u2082} : q\u2081 \u2208 stmts\u2081 q\u2082 \u2192 stmts\u2081 q\u2081 \u2286 stmts\u2081 q\u2082", "start": [2192, 1], "end": [2208, 36], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts\u2081_supportsStmt_mono", "code": "theorem stmts\u2081_supportsStmt_mono {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2082} (h : q\u2081 \u2208 stmts\u2081 q\u2082)\n    (hs : SupportsStmt S q\u2082) : SupportsStmt S q\u2081", "start": [2211, 1], "end": [2219, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts", "code": "noncomputable def stmts (M : \u039b \u2192 Stmt\u2082) (S : Finset \u039b) : Finset (Option Stmt\u2082) :=\n  Finset.insertNone (S.biUnion fun q \u21a6 stmts\u2081 (M q))", "start": [2222, 1], "end": [2224, 53], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts_trans", "code": "theorem stmts_trans {M : \u039b \u2192 Stmt\u2082} {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2082} (h\u2081 : q\u2081 \u2208 stmts\u2081 q\u2082) :\n    some q\u2082 \u2208 stmts M S \u2192 some q\u2081 \u2208 stmts M S", "start": [2227, 1], "end": [2231, 50], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.Supports", "code": "def Supports (M : \u039b \u2192 Stmt\u2082) (S : Finset \u039b) :=\n  default \u2208 S \u2227 \u2200 q \u2208 S, SupportsStmt S (M q)", "start": [2236, 1], "end": [2239, 46], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.stmts_supportsStmt", "code": "theorem stmts_supportsStmt {M : \u039b \u2192 Stmt\u2082} {S : Finset \u039b} {q : Stmt\u2082} (ss : Supports M S) :\n    some q \u2208 stmts M S \u2192 SupportsStmt S q", "start": [2242, 1], "end": [2246, 60], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.step_supports", "code": "theorem step_supports (M : \u039b \u2192 Stmt\u2082) {S : Finset \u039b} (ss : Supports M S) :\n    \u2200 {c c' : Cfg\u2082}, c' \u2208 step M c \u2192 c.l \u2208 Finset.insertNone S \u2192 c'.l \u2208 Finset.insertNone S", "start": [2249, 1], "end": [2261, 46], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.init", "code": "def init (k : K) (L : List (\u0393 k)) : Cfg\u2082 :=\n  \u27e8some default, default, update (fun _ \u21a6 []) k L\u27e9", "start": [2266, 1], "end": [2268, 51], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2.eval", "code": "def eval (M : \u039b \u2192 Stmt\u2082) (k : K) (L : List (\u0393 k)) : Part (List (\u0393 k)) :=\n  (Turing.eval (step M) (init k L)).map fun c \u21a6 c.stk k", "start": [2271, 1], "end": [2273, 56], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.stk_nth_val", "code": "theorem stk_nth_val {K : Type*} {\u0393 : K \u2192 Type*} {L : ListBlank (\u2200 k, Option (\u0393 k))} {k S} (n)\n    (hL : ListBlank.map (proj k) L = ListBlank.mk (List.map some S).reverse) :\n    L.nth n k = S.reverse.get? n", "start": [2325, 1], "end": [2330, 33], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.\u0393'", "code": "def \u0393' :=\n  Bool \u00d7 \u2200 k, Option (\u0393 k)", "start": [2348, 1], "end": [2351, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.\u0393'.inhabited", "code": "instance \u0393'.inhabited : Inhabited \u0393'\u2082\u2081 :=\n  \u27e8\u27e8false, fun _ \u21a6 none\u27e9\u27e9", "start": [2356, 1], "end": [2357, 26], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.\u0393'.fintype", "code": "instance \u0393'.fintype [Fintype K] [\u2200 k, Fintype (\u0393 k)] : Fintype \u0393'\u2082\u2081 :=\n  instFintypeProd _ _", "start": [2360, 1], "end": [2361, 22], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom", "code": "def addBottom (L : ListBlank (\u2200 k, Option (\u0393 k))) : ListBlank \u0393'\u2082\u2081 :=\n  ListBlank.cons (true, L.head) (L.tail.map \u27e8Prod.mk false, rfl\u27e9)", "start": [2364, 1], "end": [2367, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom_map", "code": "theorem addBottom_map (L : ListBlank (\u2200 k, Option (\u0393 k))) :\n    (addBottom L).map \u27e8Prod.snd, by rfl\u27e9 = L", "start": [2370, 1], "end": [2375, 42], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom_modifyNth", "code": "theorem addBottom_modifyNth (f : (\u2200 k, Option (\u0393 k)) \u2192 \u2200 k, Option (\u0393 k))\n    (L : ListBlank (\u2200 k, Option (\u0393 k))) (n : \u2115) :\n    (addBottom L).modifyNth (fun a \u21a6 (a.1, f a.2)) n = addBottom (L.modifyNth f n)", "start": [2378, 1], "end": [2383, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom_nth_snd", "code": "theorem addBottom_nth_snd (L : ListBlank (\u2200 k, Option (\u0393 k))) (n : \u2115) :\n    ((addBottom L).nth n).2 = L.nth n", "start": [2386, 1], "end": [2388, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom_nth_succ_fst", "code": "theorem addBottom_nth_succ_fst (L : ListBlank (\u2200 k, Option (\u0393 k))) (n : \u2115) :\n    ((addBottom L).nth (n + 1)).1 = false", "start": [2391, 1], "end": [2393, 77], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.addBottom_head_fst", "code": "theorem addBottom_head_fst (L : ListBlank (\u2200 k, Option (\u0393 k))) : (addBottom L).head.1 = true", "start": [2396, 1], "end": [2397, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.StAct", "code": "inductive StAct (k : K)\n  | push : (\u03c3 \u2192 \u0393 k) \u2192 StAct k\n  | peek : (\u03c3 \u2192 Option (\u0393 k) \u2192 \u03c3) \u2192 StAct k\n  | pop : (\u03c3 \u2192 Option (\u0393 k) \u2192 \u03c3) \u2192 StAct k", "start": [2400, 1], "end": [2406, 43], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.StAct.inhabited", "code": "instance StAct.inhabited {k : K} : Inhabited (StAct\u2082 k) :=\n  \u27e8StAct.peek fun s _ \u21a6 s\u27e9", "start": [2411, 1], "end": [2412, 27], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.stRun", "code": "def stRun {k : K} : StAct\u2082 k \u2192 Stmt\u2082 \u2192 Stmt\u2082\n  | push f => TM2.Stmt.push k f\n  | peek f => TM2.Stmt.peek k f\n  | pop f => TM2.Stmt.pop k f", "start": [2420, 1], "end": [2424, 30], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.stVar", "code": "def stVar {k : K} (v : \u03c3) (l : List (\u0393 k)) : StAct\u2082 k \u2192 \u03c3\n  | push _ => v\n  | peek f => f v l.head?\n  | pop f => f v l.head?", "start": [2427, 1], "end": [2431, 25], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.stWrite", "code": "def stWrite {k : K} (v : \u03c3) (l : List (\u0393 k)) : StAct\u2082 k \u2192 List (\u0393 k)\n  | push f => f v :: l\n  | peek _ => l\n  | pop _ => l.tail", "start": [2434, 1], "end": [2438, 20], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.stmtStRec", "code": "@[elab_as_elim]\ndef stmtStRec.{l} {C : Stmt\u2082 \u2192 Sort l} (H\u2081 : \u2200 (k) (s : StAct\u2082 k) (q) (_ : C q), C (stRun s q))\n    (H\u2082 : \u2200 (a q) (_ : C q), C (TM2.Stmt.load a q))\n    (H\u2083 : \u2200 (p q\u2081 q\u2082) (_ : C q\u2081) (_ : C q\u2082), C (TM2.Stmt.branch p q\u2081 q\u2082))\n    (H\u2084 : \u2200 l, C (TM2.Stmt.goto l)) (H\u2085 : C TM2.Stmt.halt) : \u2200 n, C n\n  | TM2.Stmt.push _ f q => H\u2081 _ (push f) _ (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q)\n  | TM2.Stmt.peek _ f q => H\u2081 _ (peek f) _ (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q)\n  | TM2.Stmt.pop _ f q => H\u2081 _ (pop f) _ (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q)\n  | TM2.Stmt.load _ q => H\u2082 _ _ (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q)\n  | TM2.Stmt.branch _ q\u2081 q\u2082 => H\u2083 _ _ _ (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q\u2081) (stmtStRec H\u2081 H\u2082 H\u2083 H\u2084 H\u2085 q\u2082)\n  | TM2.Stmt.goto _ => H\u2084 _\n  | TM2.Stmt.halt => H\u2085", "start": [2441, 1], "end": [2455, 24], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.supports_run", "code": "theorem supports_run (S : Finset \u039b) {k : K} (s : StAct\u2082 k) (q : Stmt\u2082) :\n    TM2.SupportsStmt S (stRun s q) \u2194 TM2.SupportsStmt S q", "start": [2458, 1], "end": [2460, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.\u039b'", "code": "inductive \u039b'\n  | normal : \u039b \u2192 \u039b'\n  | go (k : K) : StAct\u2082 k \u2192 Stmt\u2082 \u2192 \u039b'\n  | ret : Stmt\u2082 \u2192 \u039b'", "start": [2465, 1], "end": [2471, 21], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.\u039b'.inhabited", "code": "instance \u039b'.inhabited : Inhabited \u039b'\u2082\u2081 :=\n  \u27e8normal default\u27e9", "start": [2478, 1], "end": [2479, 19], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trStAct", "code": "def trStAct {k : K} (q : Stmt\u2082\u2081) : StAct\u2082 k \u2192 Stmt\u2082\u2081\n  | StAct.push f => (write fun a s \u21a6 (a.1, update a.2 k <| some <| f s)) <| move Dir.right q\n  | StAct.peek f => move Dir.left <| (load fun a s \u21a6 f s (a.2 k)) <| move Dir.right q\n  | StAct.pop f =>\n    branch (fun a _ \u21a6 a.1) (load (fun _ s \u21a6 f s none) q)\n      (move Dir.left <|\n        (load fun a s \u21a6 f s (a.2 k)) <| write (fun a _ \u21a6 (a.1, update a.2 k none)) q)", "start": [2488, 1], "end": [2496, 86], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trInit", "code": "def trInit (k : K) (L : List (\u0393 k)) : List \u0393'\u2082\u2081 :=\n  let L' : List \u0393'\u2082\u2081 := L.reverse.map fun a \u21a6 (false, update (fun _ \u21a6 none) k (some a))\n  (true, L'.headI.2) :: L'.tail", "start": [2499, 1], "end": [2503, 32], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.step_run", "code": "theorem step_run {k : K} (q : Stmt\u2082) (v : \u03c3) (S : \u2200 k, List (\u0393 k)) : \u2200 s : StAct\u2082 k,\n    TM2.stepAux (stRun s q) v S = TM2.stepAux q (stVar v (S k) s) (update S k (stWrite v (S k) s))", "start": [2506, 1], "end": [2510, 23], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trNormal", "code": "def trNormal : Stmt\u2082 \u2192 Stmt\u2082\u2081\n  | TM2.Stmt.push k f q => goto fun _ _ \u21a6 go k (StAct.push f) q\n  | TM2.Stmt.peek k f q => goto fun _ _ \u21a6 go k (StAct.peek f) q\n  | TM2.Stmt.pop k f q => goto fun _ _ \u21a6 go k (StAct.pop f) q\n  | TM2.Stmt.load a q => load (fun _ \u21a6 a) (trNormal q)\n  | TM2.Stmt.branch f q\u2081 q\u2082 => branch (fun _ \u21a6 f) (trNormal q\u2081) (trNormal q\u2082)\n  | TM2.Stmt.goto l => goto fun _ s \u21a6 normal (l s)\n  | TM2.Stmt.halt => halt", "start": [2513, 1], "end": [2523, 26], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trNormal_run", "code": "theorem trNormal_run {k : K} (s : StAct\u2082 k) (q : Stmt\u2082) :\n    trNormal (stRun s q) = goto fun _ _ \u21a6 go k s q", "start": [2526, 1], "end": [2528, 18], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trStmts\u2081", "code": "noncomputable def trStmts\u2081 : Stmt\u2082 \u2192 Finset \u039b'\u2082\u2081\n  | TM2.Stmt.push k f q => {go k (StAct.push f) q, ret q} \u222a trStmts\u2081 q\n  | TM2.Stmt.peek k f q => {go k (StAct.peek f) q, ret q} \u222a trStmts\u2081 q\n  | TM2.Stmt.pop k f q => {go k (StAct.pop f) q, ret q} \u222a trStmts\u2081 q\n  | TM2.Stmt.load _ q => trStmts\u2081 q\n  | TM2.Stmt.branch _ q\u2081 q\u2082 => trStmts\u2081 q\u2081 \u222a trStmts\u2081 q\u2082\n  | _ => \u2205", "start": [2533, 1], "end": [2540, 11], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trStmts\u2081_run", "code": "theorem trStmts\u2081_run {k : K} {s : StAct\u2082 k} {q : Stmt\u2082} :\n    trStmts\u2081 (stRun s q) = {go k s q, ret q} \u222a trStmts\u2081 q", "start": [2543, 1], "end": [2545, 35], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_respects_aux\u2082", "code": "theorem tr_respects_aux\u2082 {k : K} {q : Stmt\u2082\u2081} {v : \u03c3} {S : \u2200 k, List (\u0393 k)}\n    {L : ListBlank (\u2200 k, Option (\u0393 k))}\n    (hL : \u2200 k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StAct\u2082 k) :\n    let v' := stVar v (S k) o\n    let Sk' := stWrite v (S k) o\n    let S' := update S k Sk'\n    \u2203 L' : ListBlank (\u2200 k, Option (\u0393 k)),\n      (\u2200 k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) \u2227\n        TM1.stepAux (trStAct q o) v\n            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' \u2205 (addBottom L))) =\n          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' \u2205 (addBottom L')))", "start": [2548, 1], "end": [2630, 38], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr", "code": "def tr : \u039b'\u2082\u2081 \u2192 Stmt\u2082\u2081\n  | normal q => trNormal (M q)\n  | go k s q =>\n    branch (fun a _ \u21a6 (a.2 k).isNone) (trStAct (goto fun _ _ \u21a6 ret q) s)\n      (move Dir.right <| goto fun _ _ \u21a6 go k s q)\n  | ret q => branch (fun a _ \u21a6 a.1) (trNormal q) (move Dir.left <| goto fun _ _ \u21a6 ret q)", "start": [2635, 1], "end": [2642, 89], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.TrCfg", "code": "inductive TrCfg : Cfg\u2082 \u2192 Cfg\u2082\u2081 \u2192 Prop\n  | mk {q : Option \u039b} {v : \u03c3} {S : \u2200 k, List (\u0393 k)} (L : ListBlank (\u2200 k, Option (\u0393 k))) :\n    (\u2200 k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) \u2192\n      TrCfg \u27e8q, v, S\u27e9 \u27e8q.map normal, v, Tape.mk' \u2205 (addBottom L)\u27e9", "start": [2648, 1], "end": [2652, 66], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_respects_aux\u2081", "code": "theorem tr_respects_aux\u2081 {k} (o q v) {S : List (\u0393 k)} {L : ListBlank (\u2200 k, Option (\u0393 k))}\n    (hL : L.map (proj k) = ListBlank.mk (S.map some).reverse) (n) (H : n \u2264 S.length) :\n    Reaches\u2080 (TM1.step (tr M)) \u27e8some (go k o q), v, Tape.mk' \u2205 (addBottom L)\u27e9\n      \u27e8some (go k o q), v, (Tape.move Dir.right)^[n] (Tape.mk' \u2205 (addBottom L))\u27e9", "start": [2655, 1], "end": [2664, 74], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_respects_aux\u2083", "code": "theorem tr_respects_aux\u2083 {q v} {L : ListBlank (\u2200 k, Option (\u0393 k))} (n) : Reaches\u2080 (TM1.step (tr M))\n    \u27e8some (ret q), v, (Tape.move Dir.right)^[n] (Tape.mk' \u2205 (addBottom L))\u27e9\n    \u27e8some (ret q), v, Tape.mk' \u2205 (addBottom L)\u27e9", "start": [2667, 1], "end": [2675, 6], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_respects_aux", "code": "theorem tr_respects_aux {q v T k} {S : \u2200 k, List (\u0393 k)}\n    (hT : \u2200 k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) (o : StAct\u2082 k)\n    (IH : \u2200 {v : \u03c3} {S : \u2200 k : K, List (\u0393 k)} {T : ListBlank (\u2200 k, Option (\u0393 k))},\n      (\u2200 k, ListBlank.map (proj k) T = ListBlank.mk ((S k).map some).reverse) \u2192\n      \u2203 b, TrCfg (TM2.stepAux q v S) b \u2227\n        Reaches (TM1.step (tr M)) (TM1.stepAux (trNormal q) v (Tape.mk' \u2205 (addBottom T))) b) :\n    \u2203 b, TrCfg (TM2.stepAux (stRun o q) v S) b \u2227 Reaches (TM1.step (tr M))\n      (TM1.stepAux (trNormal (stRun o q)) v (Tape.mk' \u2205 (addBottom T))) b", "start": [2678, 1], "end": [2696, 11], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_respects", "code": "theorem tr_respects : Respects (TM2.step M) (TM1.step (tr M)) TrCfg", "start": [2701, 1], "end": [2720, 48], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trCfg_init", "code": "theorem trCfg_init (k) (L : List (\u0393 k)) : TrCfg (TM2.init k L) (TM1.init (trInit k L) : Cfg\u2082\u2081)", "start": [2723, 1], "end": [2743, 8], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_eval_dom", "code": "theorem tr_eval_dom (k) (L : List (\u0393 k)) :\n    (TM1.eval (tr M) (trInit k L)).Dom \u2194 (TM2.eval M k L).Dom", "start": [2746, 1], "end": [2748, 54], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_eval", "code": "theorem tr_eval (k) (L : List (\u0393 k)) {L\u2081 L\u2082} (H\u2081 : L\u2081 \u2208 TM1.eval (tr M) (trInit k L))\n    (H\u2082 : L\u2082 \u2208 TM2.eval M k L) :\n    \u2203 (S : \u2200 k, List (\u0393 k)) (L' : ListBlank (\u2200 k, Option (\u0393 k))),\n      addBottom L' = L\u2081 \u2227\n        (\u2200 k, L'.map (proj k) = ListBlank.mk ((S k).map some).reverse) \u2227 S k = L\u2082", "start": [2751, 1], "end": [2760, 57], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.trSupp", "code": "noncomputable def trSupp (S : Finset \u039b) : Finset \u039b'\u2082\u2081 :=\n  S.biUnion fun l \u21a6 insert (normal l) (trStmts\u2081 (M l))", "start": [2763, 1], "end": [2765, 55], "kind": "commanddeclaration"}, {"full_name": "Turing.TM2to1.tr_supports", "code": "theorem tr_supports {S} (ss : TM2.Supports M S) : TM1.Supports (tr M) (trSupp M S)", "start": [2768, 1], "end": [2813, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean", "imports": ["Mathlib/MeasureTheory/Measure/FiniteMeasure.lean", "Mathlib/MeasureTheory/Integral/Average.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.ProbabilityMeasure", "code": "def ProbabilityMeasure (\u03a9 : Type*) [MeasurableSpace \u03a9] : Type _ :=\n  { \u03bc : Measure \u03a9 // IsProbabilityMeasure \u03bc }", "start": [103, 1], "end": [106, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toMeasure", "code": "@[coe]\ndef toMeasure : ProbabilityMeasure \u03a9 \u2192 Measure \u03a9 := Subtype.val", "start": [118, 1], "end": [120, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.val_eq_to_measure", "code": "@[simp]\ntheorem val_eq_to_measure (\u03bd : ProbabilityMeasure \u03a9) : \u03bd.val = (\u03bd : Measure \u03a9)", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toMeasure_injective", "code": "theorem toMeasure_injective : Function.Injective ((\u2191) : ProbabilityMeasure \u03a9 \u2192 Measure \u03a9)", "start": [140, 1], "end": [141, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.coeFn_univ", "code": "theorem coeFn_univ (\u03bd : ProbabilityMeasure \u03a9) : \u03bd univ = 1", "start": [145, 1], "end": [146, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.coeFn_univ_ne_zero", "code": "theorem coeFn_univ_ne_zero (\u03bd : ProbabilityMeasure \u03a9) : \u03bd univ \u2260 0", "start": [149, 1], "end": [150, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toFiniteMeasure", "code": "def toFiniteMeasure (\u03bc : ProbabilityMeasure \u03a9) : FiniteMeasure \u03a9 :=\n  \u27e8\u03bc, inferInstance\u27e9", "start": [153, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toMeasure_comp_toFiniteMeasure_eq_toMeasure", "code": "@[simp]\ntheorem toMeasure_comp_toFiniteMeasure_eq_toMeasure (\u03bd : ProbabilityMeasure \u03a9) :\n    (\u03bd.toFiniteMeasure : Measure \u03a9) = (\u03bd : Measure \u03a9)", "start": [158, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.coeFn_comp_toFiniteMeasure_eq_coeFn", "code": "@[simp]\ntheorem coeFn_comp_toFiniteMeasure_eq_coeFn (\u03bd : ProbabilityMeasure \u03a9) :\n    (\u03bd.toFiniteMeasure : Set \u03a9 \u2192 \u211d\u22650) = (\u03bd : Set \u03a9 \u2192 \u211d\u22650)", "start": [164, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure", "code": "@[simp]\ntheorem ennreal_coeFn_eq_coeFn_toMeasure (\u03bd : ProbabilityMeasure \u03a9) (s : Set \u03a9) :\n    (\u03bd s : \u211d\u22650\u221e) = (\u03bd : Measure \u03a9) s", "start": [170, 1], "end": [174, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.apply_mono", "code": "theorem apply_mono (\u03bc : ProbabilityMeasure \u03a9) {s\u2081 s\u2082 : Set \u03a9} (h : s\u2081 \u2286 s\u2082) : \u03bc s\u2081 \u2264 \u03bc s\u2082", "start": [177, 1], "end": [179, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.apply_le_one", "code": "@[simp] theorem apply_le_one (\u03bc : ProbabilityMeasure \u03a9) (s : Set \u03a9) : \u03bc s \u2264 1", "start": [182, 1], "end": [183, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.nonempty", "code": "theorem nonempty (\u03bc : ProbabilityMeasure \u03a9) : Nonempty \u03a9", "start": [185, 1], "end": [190, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.eq_of_forall_toMeasure_apply_eq", "code": "@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (\u03bc \u03bd : ProbabilityMeasure \u03a9)\n    (h : \u2200 s : Set \u03a9, MeasurableSet s \u2192 (\u03bc : Measure \u03a9) s = (\u03bd : Measure \u03a9) s) : \u03bc = \u03bd", "start": [193, 1], "end": [198, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.eq_of_forall_apply_eq", "code": "theorem eq_of_forall_apply_eq (\u03bc \u03bd : ProbabilityMeasure \u03a9)\n    (h : \u2200 s : Set \u03a9, MeasurableSet s \u2192 \u03bc s = \u03bd s) : \u03bc = \u03bd", "start": [201, 1], "end": [204, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.mass_toFiniteMeasure", "code": "@[simp]\ntheorem mass_toFiniteMeasure (\u03bc : ProbabilityMeasure \u03a9) : \u03bc.toFiniteMeasure.mass = 1", "start": [207, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toFiniteMeasure_nonzero", "code": "theorem toFiniteMeasure_nonzero (\u03bc : ProbabilityMeasure \u03a9) : \u03bc.toFiniteMeasure \u2260 0", "start": [212, 1], "end": [214, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.testAgainstNN_lipschitz", "code": "theorem testAgainstNN_lipschitz (\u03bc : ProbabilityMeasure \u03a9) :\n    LipschitzWith 1 fun f : \u03a9 \u2192\u1d47 \u211d\u22650 => \u03bc.toFiniteMeasure.testAgainstNN f", "start": [219, 1], "end": [221, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toFiniteMeasure_continuous", "code": "theorem toFiniteMeasure_continuous :\n    Continuous (toFiniteMeasure : ProbabilityMeasure \u03a9 \u2192 FiniteMeasure \u03a9)", "start": [230, 1], "end": [232, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toWeakDualBCNN", "code": "def toWeakDualBCNN : ProbabilityMeasure \u03a9 \u2192 WeakDual \u211d\u22650 (\u03a9 \u2192\u1d47 \u211d\u22650) :=\n  FiniteMeasure.toWeakDualBCNN \u2218 toFiniteMeasure", "start": [235, 1], "end": [238, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.coe_toWeakDualBCNN", "code": "@[simp]\ntheorem coe_toWeakDualBCNN (\u03bc : ProbabilityMeasure \u03a9) :\n    \u21d1\u03bc.toWeakDualBCNN = \u03bc.toFiniteMeasure.testAgainstNN", "start": [241, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toWeakDualBCNN_apply", "code": "@[simp]\ntheorem toWeakDualBCNN_apply (\u03bc : ProbabilityMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.toWeakDualBCNN f = (\u222b\u207b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)).toNNReal", "start": [247, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toWeakDualBCNN_continuous", "code": "theorem toWeakDualBCNN_continuous : Continuous fun \u03bc : ProbabilityMeasure \u03a9 => \u03bc.toWeakDualBCNN", "start": [253, 1], "end": [254, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.continuous_testAgainstNN_eval", "code": "theorem continuous_testAgainstNN_eval (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    Continuous fun \u03bc : ProbabilityMeasure \u03a9 => \u03bc.toFiniteMeasure.testAgainstNN f", "start": [259, 1], "end": [261, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.toFiniteMeasure_embedding", "code": "theorem toFiniteMeasure_embedding (\u03a9 : Type*) [MeasurableSpace \u03a9] [TopologicalSpace \u03a9]\n    [OpensMeasurableSpace \u03a9] :\n    Embedding (toFiniteMeasure : ProbabilityMeasure \u03a9 \u2192 FiniteMeasure \u03a9)", "start": [265, 1], "end": [269, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_nhds_iff_toFiniteMeasure_tendsto_nhds", "code": "theorem tendsto_nhds_iff_toFiniteMeasure_tendsto_nhds {\u03b4 : Type*} (F : Filter \u03b4)\n    {\u03bcs : \u03b4 \u2192 ProbabilityMeasure \u03a9} {\u03bc\u2080 : ProbabilityMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc\u2080) \u2194 Tendsto (toFiniteMeasure \u2218 \u03bcs) F (\ud835\udcdd \u03bc\u2080.toFiniteMeasure)", "start": [272, 1], "end": [275, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto", "code": "theorem tendsto_iff_forall_lintegral_tendsto {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 ProbabilityMeasure \u03a9} {\u03bc : ProbabilityMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d\u22650,\n        Tendsto (fun i => \u222b\u207b \u03c9, f \u03c9 \u2202(\u03bcs i : Measure \u03a9)) F (\ud835\udcdd (\u222b\u207b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)))", "start": [278, 1], "end": [287, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_iff_forall_integral_tendsto", "code": "theorem tendsto_iff_forall_integral_tendsto {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 ProbabilityMeasure \u03a9} {\u03bc : ProbabilityMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d,\n        Tendsto (fun i => \u222b \u03c9, f \u03c9 \u2202(\u03bcs i : Measure \u03a9)) F (\ud835\udcdd (\u222b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)))", "start": [290, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.normalize", "code": "def normalize : ProbabilityMeasure \u03a9 :=\n  if zero : \u03bc.mass = 0 then \u27e8Measure.dirac \u2039Nonempty \u03a9\u203a.some, Measure.dirac.isProbabilityMeasure\u27e9\n  else\n    { val := \u03bc.mass\u207b\u00b9 \u2022 \u03bc\n      property := by\n        refine' \u27e8_\u27e9\n        rw [FiniteMeasure.toMeasure_smul]\n        simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,\n          Measure.nnreal_smul_coe_apply, ne_eq, mass_zero_iff, ENNReal.coe_inv zero, ennreal_mass]\n        rw [\u2190Ne.def, \u2190ENNReal.coe_ne_zero, ennreal_mass] at zero\n        exact ENNReal.inv_mul_cancel zero \u03bc.prop.measure_univ_lt_top.ne }", "start": [324, 1], "end": [337, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.self_eq_mass_mul_normalize", "code": "@[simp]\ntheorem self_eq_mass_mul_normalize (s : Set \u03a9) : \u03bc s = \u03bc.mass * \u03bc.normalize s", "start": [340, 1], "end": [351, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.self_eq_mass_smul_normalize", "code": "theorem self_eq_mass_smul_normalize : \u03bc = \u03bc.mass \u2022 \u03bc.normalize.toFiniteMeasure", "start": [354, 1], "end": [358, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.normalize_eq_of_nonzero", "code": "theorem normalize_eq_of_nonzero (nonzero : \u03bc \u2260 0) (s : Set \u03a9) : \u03bc.normalize s = \u03bc.mass\u207b\u00b9 * \u03bc s", "start": [361, 1], "end": [363, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.normalize_eq_inv_mass_smul_of_nonzero", "code": "theorem normalize_eq_inv_mass_smul_of_nonzero (nonzero : \u03bc \u2260 0) :\n    \u03bc.normalize.toFiniteMeasure = \u03bc.mass\u207b\u00b9 \u2022 \u03bc", "start": [366, 1], "end": [371, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure_normalize_eq_of_nonzero", "code": "theorem toMeasure_normalize_eq_of_nonzero (nonzero : \u03bc \u2260 0) :\n    (\u03bc.normalize : Measure \u03a9) = \u03bc.mass\u207b\u00b9 \u2022 \u03bc", "start": [374, 1], "end": [379, 44], "kind": "commanddeclaration"}, {"full_name": "ProbabilityMeasure.toFiniteMeasure_normalize_eq_self", "code": "@[simp]\ntheorem _root_.ProbabilityMeasure.toFiniteMeasure_normalize_eq_self {m0 : MeasurableSpace \u03a9}\n    (\u03bc : ProbabilityMeasure \u03a9) : \u03bc.toFiniteMeasure.normalize = \u03bc", "start": [382, 1], "end": [389, 8], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.average_eq_integral_normalize", "code": "theorem average_eq_integral_normalize {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    (nonzero : \u03bc \u2260 0) (f : \u03a9 \u2192 E) :\n    average (\u03bc : Measure \u03a9) f = \u222b \u03c9, f \u03c9 \u2202(\u03bc.normalize : Measure \u03a9)", "start": [392, 1], "end": [399, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_eq_mass_mul", "code": "theorem testAgainstNN_eq_mass_mul (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN f = \u03bc.mass * \u03bc.normalize.toFiniteMeasure.testAgainstNN f", "start": [404, 1], "end": [407, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.normalize_testAgainstNN", "code": "theorem normalize_testAgainstNN (nonzero : \u03bc \u2260 0) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.normalize.toFiniteMeasure.testAgainstNN f = \u03bc.mass\u207b\u00b9 * \u03bc.testAgainstNN f", "start": [410, 1], "end": [412, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_of_tendsto_normalize_testAgainstNN_of_tendsto_mass", "code": "theorem tendsto_testAgainstNN_of_tendsto_normalize_testAgainstNN_of_tendsto_mass {\u03b3 : Type*}\n    {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    (\u03bcs_lim : Tendsto (fun i => (\u03bcs i).normalize) F (\ud835\udcdd \u03bc.normalize))\n    (mass_lim : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd \u03bc.mass)) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    Tendsto (fun i => (\u03bcs i).testAgainstNN f) F (\ud835\udcdd (\u03bc.testAgainstNN f))", "start": [419, 1], "end": [435, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_normalize_testAgainstNN_of_tendsto", "code": "theorem tendsto_normalize_testAgainstNN_of_tendsto {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9} (\u03bcs_lim : Tendsto \u03bcs F (\ud835\udcdd \u03bc)) (nonzero : \u03bc \u2260 0) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    Tendsto (fun i => (\u03bcs i).normalize.toFiniteMeasure.testAgainstNN f) F\n      (\ud835\udcdd (\u03bc.normalize.toFiniteMeasure.testAgainstNN f))", "start": [438, 1], "end": [461, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_of_tendsto_normalize_testAgainstNN_of_tendsto_mass", "code": "theorem tendsto_of_tendsto_normalize_testAgainstNN_of_tendsto_mass {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9} (\u03bcs_lim : Tendsto (fun i => (\u03bcs i).normalize) F (\ud835\udcdd \u03bc.normalize))\n    (mass_lim : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd \u03bc.mass)) : Tendsto \u03bcs F (\ud835\udcdd \u03bc)", "start": [464, 1], "end": [471, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_normalize_of_tendsto", "code": "theorem tendsto_normalize_of_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    (\u03bcs_lim : Tendsto \u03bcs F (\ud835\udcdd \u03bc)) (nonzero : \u03bc \u2260 0) :\n    Tendsto (fun i => (\u03bcs i).normalize) F (\ud835\udcdd \u03bc.normalize)", "start": [474, 1], "end": [481, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_normalize_iff_tendsto", "code": "theorem tendsto_normalize_iff_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    (nonzero : \u03bc \u2260 0) :\n    Tendsto (fun i => (\u03bcs i).normalize) F (\ud835\udcdd \u03bc.normalize) \u2227\n        Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd \u03bc.mass) \u2194\n      Tendsto \u03bcs F (\ud835\udcdd \u03bc)", "start": [484, 1], "end": [495, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.map", "code": "noncomputable def map (\u03bd : ProbabilityMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_aemble : AEMeasurable f \u03bd) :\n    ProbabilityMeasure \u03a9' :=\n  \u27e8(\u03bd : Measure \u03a9).map f,\n   \u27e8by simp only [Measure.map_apply_of_aemeasurable f_aemble MeasurableSet.univ,\n                  preimage_univ, measure_univ]\u27e9\u27e9", "start": [508, 1], "end": [513, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ProbabilityMeasure.map_apply'", "code": "lemma map_apply' (\u03bd : ProbabilityMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_aemble : AEMeasurable f \u03bd)\n    {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    (\u03bd.map f_aemble : Measure \u03a9') A = (\u03bd : Measure \u03a9) (f \u207b\u00b9' A) :=\n  Measure.map_apply_of_aemeasurable f_aemble A_mble", "start": [515, 1], "end": [520, 52], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ProbabilityMeasure.map_apply_of_aemeasurable", "code": "lemma map_apply_of_aemeasurable (\u03bd : ProbabilityMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'}\n    (f_aemble : AEMeasurable f \u03bd) {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    (\u03bd.map f_aemble) A = \u03bd (f \u207b\u00b9' A) := by\n  have := \u03bd.map_apply' f_aemble A_mble\n  exact (ENNReal.toNNReal_eq_toNNReal_iff' (measure_ne_top _ _) (measure_ne_top _ _)).mpr this", "start": [522, 1], "end": [526, 95], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ProbabilityMeasure.map_apply", "code": "@[simp] lemma map_apply (\u03bd : ProbabilityMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_aemble : AEMeasurable f \u03bd)\n    {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    (\u03bd.map f_aemble) A = \u03bd (f \u207b\u00b9' A) :=\n  map_apply_of_aemeasurable \u03bd f_aemble A_mble", "start": [528, 1], "end": [531, 46], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ProbabilityMeasure.tendsto_map_of_tendsto_of_continuous", "code": "lemma tendsto_map_of_tendsto_of_continuous {\u03b9 : Type*} {L : Filter \u03b9}\n    (\u03bds : \u03b9 \u2192 ProbabilityMeasure \u03a9) (\u03bd : ProbabilityMeasure \u03a9) (lim : Tendsto \u03bds L (\ud835\udcdd \u03bd))\n    {f : \u03a9 \u2192 \u03a9'} (f_cont : Continuous f) :\n    Tendsto (fun i \u21a6 (\u03bds i).map f_cont.measurable.aemeasurable) L\n      (\ud835\udcdd (\u03bd.map f_cont.measurable.aemeasurable)) := by\n  rw [ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto] at lim \u22a2\n  intro g\n  convert lim (g.compContinuous \u27e8f, f_cont\u27e9) <;>\n  \u00b7 simp only [map, compContinuous_apply, ContinuousMap.coe_mk]\n    refine lintegral_map ?_ f_cont.measurable\n    exact (ENNReal.continuous_coe.comp g.continuous).measurable", "start": [536, 1], "end": [549, 64], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ProbabilityMeasure.continuous_map", "code": "lemma continuous_map {f : \u03a9 \u2192 \u03a9'} (f_cont : Continuous f) :\n    Continuous (fun \u03bd \u21a6 ProbabilityMeasure.map \u03bd f_cont.measurable.aemeasurable) := by\n  rw [continuous_iff_continuousAt]\n  exact fun _ \u21a6 tendsto_map_of_tendsto_of_continuous _ _ continuous_id.continuousAt f_cont", "start": [551, 1], "end": [557, 91], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/EpiMono.lean", "Mathlib/CategoryTheory/Preadditive/Injective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean", "Mathlib/Algebra/Category/ModuleCat/EpiMono.lean"], "premises": [{"full_name": "CategoryTheory.Injective.injective_iff_preservesEpimorphisms_preadditiveYoneda_obj", "code": "theorem injective_iff_preservesEpimorphisms_preadditiveYoneda_obj (J : C) :\n    Injective J \u2194 (preadditiveYoneda.obj J).PreservesEpimorphisms", "start": [32, 1], "end": [40, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.injective_iff_preservesEpimorphisms_preadditive_yoneda_obj'", "code": "theorem injective_iff_preservesEpimorphisms_preadditive_yoneda_obj' (J : C) :\n    Injective J \u2194 (preadditiveYonedaObj J).PreservesEpimorphisms", "start": [43, 1], "end": [51, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ClassNumber/Finite.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "Mathlib/RingTheory/Norm.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "Mathlib/LinearAlgebra/Matrix/AbsoluteValue.lean", "Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean", "Mathlib/RingTheory/ClassGroup.lean"], "premises": [{"full_name": "ClassGroup.normBound", "code": "noncomputable def normBound : \u2124 :=\n  let n := Fintype.card \u03b9\n  let i : \u03b9 := Nonempty.some bS.index_nonempty\n  let m : \u2124 :=\n    Finset.max'\n      (Finset.univ.image fun ijk : \u03b9 \u00d7 \u03b9 \u00d7 \u03b9 =>\n        abv (Algebra.leftMulMatrix bS (bS ijk.1) ijk.2.1 ijk.2.2))\n      \u27e8_, Finset.mem_image.mpr \u27e8\u27e8i, i, i\u27e9, Finset.mem_univ _, rfl\u27e9\u27e9\n  Nat.factorial n \u2022 (n \u2022 m) ^ n", "start": [56, 1], "end": [67, 32], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.normBound_pos", "code": "theorem normBound_pos : 0 < normBound abv bS", "start": [70, 1], "end": [83, 65], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.norm_le", "code": "theorem norm_le (a : S) {y : \u2124} (hy : \u2200 k, abv (bS.repr a k) \u2264 y) :\n    abv (Algebra.norm R a) \u2264 normBound abv bS * y ^ Fintype.card \u03b9", "start": [86, 1], "end": [106, 67], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.norm_lt", "code": "theorem norm_lt {T : Type*} [LinearOrderedRing T] (a : S) {y : T}\n    (hy : \u2200 k, (abv (bS.repr a k) : T) < y) :\n    (abv (Algebra.norm R a) : T) < normBound abv bS * y ^ Fintype.card \u03b9", "start": [109, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.exists_min", "code": "theorem exists_min (I : (Ideal S)\u2070) :\n    \u2203 b \u2208 (I : Ideal S),\n      b \u2260 0 \u2227 \u2200 c \u2208 (I : Ideal S), abv (Algebra.norm R c) < abv (Algebra.norm R b) \u2192 c =\n      (0 : S)", "start": [138, 1], "end": [157, 40], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.cardM", "code": "noncomputable def cardM : \u2115 :=\n  adm.card (normBound abv bS ^ (-1 / Fintype.card \u03b9 : \u211d)) ^ Fintype.card \u03b9", "start": [164, 1], "end": [172, 75], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.distinctElems", "code": "noncomputable def distinctElems : Fin (cardM bS adm).succ \u21aa R :=\n  Fin.valEmbedding.trans (Infinite.natEmbedding R)", "start": [178, 1], "end": [180, 51], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.finsetApprox", "code": "noncomputable def finsetApprox : Finset R :=\n  (Finset.univ.image fun xy : _ \u00d7 _ => distinctElems bS adm xy.1 - distinctElems bS adm xy.2).erase\n    0", "start": [185, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.finsetApprox.zero_not_mem", "code": "theorem finsetApprox.zero_not_mem : (0 : R) \u2209 finsetApprox bS adm", "start": [192, 1], "end": [193, 27], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mem_finsetApprox", "code": "@[simp]\ntheorem mem_finsetApprox {x : R} :\n    x \u2208 finsetApprox bS adm \u2194 \u2203 i j, i \u2260 j \u2227 distinctElems bS adm i - distinctElems bS adm j =\n    x", "start": [196, 1], "end": [209, 60], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.exists_mem_finsetApprox", "code": "theorem exists_mem_finsetApprox (a : S) {b} (hb : b \u2260 (0 : R)) :\n    \u2203 q : S,\n      \u2203 r \u2208 finsetApprox bS adm, abv (Algebra.norm R (r \u2022 a - b \u2022 q)) <\n      abv (Algebra.norm R (algebraMap R S b))", "start": [218, 1], "end": [269, 24], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.exists_mem_finset_approx'", "code": "theorem exists_mem_finset_approx' (h : Algebra.IsAlgebraic R L) (a : S) {b : S} (hb : b \u2260 0) :\n    \u2203 q : S,\n      \u2203 r \u2208 finsetApprox bS adm, abv (Algebra.norm R (r \u2022 a - q * b)) < abv (Algebra.norm R b)", "start": [272, 1], "end": [290, 35], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.prod_finsetApprox_ne_zero", "code": "theorem prod_finsetApprox_ne_zero : algebraMap R S (\u220f m in finsetApprox bS adm, m) \u2260 0", "start": [295, 1], "end": [299, 44], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.ne_bot_of_prod_finsetApprox_mem", "code": "theorem ne_bot_of_prod_finsetApprox_mem (J : Ideal S)\n    (h : algebraMap _ _ (\u220f m in finsetApprox bS adm, m) \u2208 J) : J \u2260 \u22a5", "start": [302, 1], "end": [304, 69], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.exists_mk0_eq_mk0", "code": "theorem exists_mk0_eq_mk0 [IsDedekindDomain S] (h : Algebra.IsAlgebraic R L) (I : (Ideal S)\u2070) :\n    \u2203 J : (Ideal S)\u2070,\n      ClassGroup.mk0 I = ClassGroup.mk0 J \u2227\n        algebraMap _ _ (\u220f m in finsetApprox bS adm, m) \u2208 (J : Ideal S)", "start": [307, 1], "end": [341, 65], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mkMMem", "code": "noncomputable def mkMMem [IsDedekindDomain S]\n    (J : { J : Ideal S // algebraMap _ _ (\u220f m in finsetApprox bS adm, m) \u2208 J }) : ClassGroup S :=\n  ClassGroup.mk0\n    \u27e8J.1, mem_nonZeroDivisors_iff_ne_zero.mpr (ne_bot_of_prod_finsetApprox_mem bS adm J.1 J.2)\u27e9", "start": [344, 1], "end": [350, 96], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mkMMem_surjective", "code": "theorem mkMMem_surjective [IsDedekindDomain S] (h : Algebra.IsAlgebraic R L) :\n    Function.Surjective (ClassGroup.mkMMem bS adm)", "start": [354, 1], "end": [359, 38], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.fintypeOfAdmissibleOfAlgebraic", "code": "noncomputable def fintypeOfAdmissibleOfAlgebraic [IsDedekindDomain S]\n    (h : Algebra.IsAlgebraic R L) : Fintype (ClassGroup S) :=\n  @Fintype.ofSurjective _ _ _\n    (@Fintype.ofEquiv _\n      { J // J \u2223 Ideal.span ({algebraMap R S (\u220f m : R in finsetApprox bS adm, m)} : Set S) }\n      (UniqueFactorizationMonoid.fintypeSubtypeDvd _\n        (by\n          rw [Ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]\n          exact prod_finsetApprox_ne_zero bS adm))\n      ((Equiv.refl _).subtypeEquiv fun I =>\n        Ideal.dvd_iff_le.trans (by\n          rw [Equiv.refl_apply, Ideal.span_le, Set.singleton_subset_iff]; rfl)))\n    (ClassGroup.mkMMem bS adm) (ClassGroup.mkMMem_surjective L bS adm h)", "start": [365, 1], "end": [383, 73], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.fintypeOfAdmissibleOfFinite", "code": "noncomputable def fintypeOfAdmissibleOfFinite : Fintype (ClassGroup S) := by\n  letI := Classical.decEq L\n  letI := IsIntegralClosure.isFractionRing_of_finite_extension R K L S\n  letI := IsIntegralClosure.isDedekindDomain R K L S\n  choose s b hb_int using FiniteDimensional.exists_is_basis_integral R K L\nhave : LinearIndependent R ((Algebra.traceForm K L).dualBasis\n      (traceForm_nondegenerate K L) b) := by\n    refine' (Basis.linearIndependent _).restrict_scalars _\n    simp only [Algebra.smul_def, mul_one]\n    apply IsFractionRing.injective\n  obtain \u27e8n, b\u27e9 :=\n    Submodule.basisOfPidOfLESpan this (IsIntegralClosure.range_le_span_dualBasis S b hb_int)\n  let f : (S \u29f8 LinearMap.ker (LinearMap.restrictScalars R (Algebra.linearMap S L))) \u2243\u2097[R] S := by\n    rw [LinearMap.ker_eq_bot.mpr]\n    \u00b7 exact Submodule.quotEquivOfEqBot _ rfl\n    \u00b7 exact IsIntegralClosure.algebraMap_injective _ R _\n  let bS := b.map ((LinearMap.quotKerEquivRange _).symm \u226a\u226b\u2097 f)\n  exact fintypeOfAdmissibleOfAlgebraic L bS adm (fun x =>\n    (IsFractionRing.isAlgebraic_iff R K L).mpr (Algebra.isAlgebraic_of_finite K _ x))", "start": [386, 1], "end": [412, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ClassNumber/AdmissibleAbs.lean", "imports": ["Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AbsoluteValue.exists_partition_int", "code": "theorem exists_partition_int (n : \u2115) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : \u2124} (hb : b \u2260 0) (A : Fin n \u2192 \u2124) :\n    \u2203 t : Fin n \u2192 Fin \u23081 / \u03b5\u2309\u208a,\n    \u2200 i\u2080 i\u2081, t i\u2080 = t i\u2081 \u2192 \u2191(abs (A i\u2081 % b - A i\u2080 % b)) < abs b \u2022 \u03b5", "start": [28, 1], "end": [51, 35], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.absIsAdmissible", "code": "noncomputable def absIsAdmissible : IsAdmissible AbsoluteValue.abs :=\n  { AbsoluteValue.abs_isEuclidean with\n    card := fun \u03b5 \u21a6 \u23081 / \u03b5\u2309\u208a\n    exists_partition' := fun n _ h\u03b5 _ hb \u21a6 exists_partition_int n h\u03b5 hb }", "start": [54, 1], "end": [58, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/UnitTrinomial.lean", "imports": ["Mathlib/Data/Polynomial/Mirror.lean", "Mathlib/Analysis/Complex/Polynomial.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.trinomial", "code": "noncomputable def trinomial :=\n  C u * X ^ k + C v * X ^ m + C w * X ^ n", "start": [38, 1], "end": [40, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_def", "code": "theorem trinomial_def : trinomial k m n u v w = C u * X ^ k + C v * X ^ m + C w * X ^ n", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_leading_coeff'", "code": "theorem trinomial_leading_coeff' (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff n = w", "start": [49, 1], "end": [52, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_middle_coeff", "code": "theorem trinomial_middle_coeff (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff m = v", "start": [55, 1], "end": [58, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_trailing_coeff'", "code": "theorem trinomial_trailing_coeff' (hkm : k < m) (hmn : m < n) :\n    (trinomial k m n u v w).coeff k = u", "start": [61, 1], "end": [64, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_natDegree", "code": "theorem trinomial_natDegree (hkm : k < m) (hmn : m < n) (hw : w \u2260 0) :\n    (trinomial k m n u v w).natDegree = n", "start": [67, 1], "end": [78, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_natTrailingDegree", "code": "theorem trinomial_natTrailingDegree (hkm : k < m) (hmn : m < n) (hu : u \u2260 0) :\n    (trinomial k m n u v w).natTrailingDegree = k", "start": [81, 1], "end": [92, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_leadingCoeff", "code": "theorem trinomial_leadingCoeff (hkm : k < m) (hmn : m < n) (hw : w \u2260 0) :\n    (trinomial k m n u v w).leadingCoeff = w", "start": [95, 1], "end": [97, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_trailingCoeff", "code": "theorem trinomial_trailingCoeff (hkm : k < m) (hmn : m < n) (hu : u \u2260 0) :\n    (trinomial k m n u v w).trailingCoeff = u", "start": [100, 1], "end": [102, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_monic", "code": "theorem trinomial_monic (hkm : k < m) (hmn : m < n) : (trinomial k m n u v 1).Monic", "start": [105, 1], "end": [107, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_mirror", "code": "theorem trinomial_mirror (hkm : k < m) (hmn : m < n) (hu : u \u2260 0) (hw : w \u2260 0) :\n    (trinomial k m n u v w).mirror = trinomial k (n - m + k) n w v u", "start": [110, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trinomial_support", "code": "theorem trinomial_support (hkm : k < m) (hmn : m < n) (hu : u \u2260 0) (hv : v \u2260 0) (hw : w \u2260 0) :\n    (trinomial k m n u v w).support = {k, m, n}", "start": [120, 1], "end": [122, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial", "code": "def IsUnitTrinomial :=\n  \u2203 (k m n : \u2115) (_ : k < m) (_ : m < n) (u v w : Units \u2124), p = trinomial k m n (u : \u2124) v w", "start": [129, 1], "end": [131, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.not_isUnit", "code": "theorem not_isUnit (hp : p.IsUnitTrinomial) : \u00acIsUnit p", "start": [138, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.card_support_eq_three", "code": "theorem card_support_eq_three (hp : p.IsUnitTrinomial) : p.support.card = 3", "start": [146, 1], "end": [148, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.ne_zero", "code": "theorem ne_zero (hp : p.IsUnitTrinomial) : p \u2260 0", "start": [151, 1], "end": [153, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.coeff_isUnit", "code": "theorem coeff_isUnit (hp : p.IsUnitTrinomial) {k : \u2115} (hk : k \u2208 p.support) :\n    IsUnit (p.coeff k)", "start": [156, 1], "end": [164, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.leadingCoeff_isUnit", "code": "theorem leadingCoeff_isUnit (hp : p.IsUnitTrinomial) : IsUnit p.leadingCoeff", "start": [167, 1], "end": [168, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.trailingCoeff_isUnit", "code": "theorem trailingCoeff_isUnit (hp : p.IsUnitTrinomial) : IsUnit p.trailingCoeff", "start": [171, 1], "end": [172, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnitTrinomial_iff", "code": "theorem isUnitTrinomial_iff :\n    p.IsUnitTrinomial \u2194 p.support.card = 3 \u2227 \u2200 k \u2208 p.support, IsUnit (p.coeff k)", "start": [177, 1], "end": [190, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnitTrinomial_iff'", "code": "theorem isUnitTrinomial_iff' :\n    p.IsUnitTrinomial \u2194\n      (p * p.mirror).coeff (((p * p.mirror).natDegree + (p * p.mirror).natTrailingDegree) / 2) =\n        3", "start": [193, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnitTrinomial_iff''", "code": "theorem isUnitTrinomial_iff'' (h : p * p.mirror = q * q.mirror) :\n    p.IsUnitTrinomial \u2194 q.IsUnitTrinomial", "start": [214, 1], "end": [216, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_aux1", "code": "theorem irreducible_aux1 {k m n : \u2115} (hkm : k < m) (hmn : m < n) (u v w : Units \u2124)\n    (hp : p = trinomial k m n (u : \u2124) v w) :\n    C (v : \u2124) * (C (u : \u2124) * X ^ (m + n) + C (w : \u2124) * X ^ (n - m + k + n)) =\n      \u27e8Finsupp.filter (Set.Ioo (k + n) (n + n)) (p * p.mirror).toFinsupp\u27e9", "start": [221, 1], "end": [253, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_aux2", "code": "theorem irreducible_aux2 {k m m' n : \u2115} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n)\n    (u v w : Units \u2124) (hp : p = trinomial k m n (u : \u2124) v w) (hq : q = trinomial k m' n (u : \u2124) v w)\n    (h : p * p.mirror = q * q.mirror) : q = p \u2228 q = p.mirror", "start": [256, 1], "end": [278, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_aux3", "code": "theorem irreducible_aux3 {k m m' n : \u2115} (hkm : k < m) (hmn : m < n) (hkm' : k < m') (hmn' : m' < n)\n    (u v w x z : Units \u2124) (hp : p = trinomial k m n (u : \u2124) v w)\n    (hq : q = trinomial k m' n (x : \u2124) v z) (h : p * p.mirror = q * q.mirror) :\n    q = p \u2228 q = p.mirror", "start": [281, 1], "end": [307, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_of_coprime", "code": "theorem irreducible_of_coprime (hp : p.IsUnitTrinomial)\n    (h : \u2200 q : \u2124[X], q \u2223 p \u2192 q \u2223 p.mirror \u2192 IsUnit q) : Irreducible p", "start": [310, 1], "end": [342, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_of_isCoprime", "code": "theorem irreducible_of_isCoprime (hp : p.IsUnitTrinomial) (h : IsCoprime p p.mirror) :\n    Irreducible p", "start": [345, 1], "end": [348, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsUnitTrinomial.irreducible_of_coprime'", "code": "theorem irreducible_of_coprime' (hp : IsUnitTrinomial p)\n    (h : \u2200 z : \u2102, \u00ac(aeval z p = 0 \u2227 aeval z (mirror p) = 0)) : Irreducible p", "start": [351, 1], "end": [371, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ZMod/Units.lean", "imports": ["Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZMod.unitsMap", "code": "def unitsMap (hm : n \u2223 m) : (ZMod m)\u02e3 \u2192* (ZMod n)\u02e3 := Units.map (castHom hm (ZMod n))", "start": [17, 1], "end": [19, 86], "kind": "commanddeclaration"}, {"full_name": "ZMod.unitsMap_def", "code": "lemma unitsMap_def (hm : n \u2223 m) : unitsMap hm = Units.map (castHom hm (ZMod n)) := rfl", "start": [21, 1], "end": [21, 87], "kind": "mathlibtacticlemma"}, {"full_name": "ZMod.unitsMap_comp", "code": "lemma unitsMap_comp {d : \u2115} (hm : n \u2223 m) (hd : m \u2223 d) :\n    (unitsMap hm).comp (unitsMap hd) = unitsMap (dvd_trans hm hd) := by\n  simp only [unitsMap_def]\n  rw [\u2190 Units.map_comp]\n  exact congr_arg Units.map <| congr_arg RingHom.toMonoidHom <| castHom_comp hm hd", "start": [23, 1], "end": [27, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ZMod.unitsMap_self", "code": "@[simp]\nlemma unitsMap_self (n : \u2115) : unitsMap (dvd_refl n) = MonoidHom.id _ := by\n  simp [unitsMap, castHom_self]", "start": [29, 1], "end": [31, 32], "kind": "mathlibtacticlemma"}, {"full_name": "ZMod.IsUnit_cast_of_dvd", "code": "lemma IsUnit_cast_of_dvd (hm : n \u2223 m) (a : Units (ZMod m)) :  IsUnit ((a : ZMod m) : ZMod n) :=\n  Units.isUnit (unitsMap hm a)", "start": [33, 1], "end": [34, 31], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/IsLocallyHomeomorph.lean", "imports": ["Mathlib/Topology/LocalHomeomorph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLocallyHomeomorphOn", "code": "def IsLocallyHomeomorphOn :=\n  \u2200 x \u2208 s, \u2203 e : LocalHomeomorph X Y, x \u2208 e.source \u2227 f = e", "start": [31, 1], "end": [34, 59], "kind": "commanddeclaration"}, {"full_name": "isLocallyHomeomorphOn_iff_openEmbedding_restrict", "code": "theorem isLocallyHomeomorphOn_iff_openEmbedding_restrict {f : X \u2192 Y} :\n    IsLocallyHomeomorphOn f s \u2194 \u2200 x \u2208 s, \u2203 U \u2208 \ud835\udcdd x, OpenEmbedding (U.restrict f)", "start": [37, 1], "end": [50, 45], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.mk", "code": "theorem mk (h : \u2200 x \u2208 s, \u2203 e : LocalHomeomorph X Y, x \u2208 e.source \u2227 \u2200 y \u2208 e.source, f y = e y) :\n    IsLocallyHomeomorphOn f s", "start": [54, 1], "end": [68, 15], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.mono", "code": "theorem mono {t : Set X} (hf : IsLocallyHomeomorphOn f t) (hst : s \u2286 t) :\n    IsLocallyHomeomorphOn f s", "start": [73, 1], "end": [74, 58], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.of_comp_left", "code": "theorem of_comp_left (hgf : IsLocallyHomeomorphOn (g \u2218 f) s) (hg : IsLocallyHomeomorphOn g (f '' s))\n    (cont : \u2200 x \u2208 s, ContinuousAt f x) : IsLocallyHomeomorphOn f s", "start": [76, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.of_comp_right", "code": "theorem of_comp_right (hgf : IsLocallyHomeomorphOn (g \u2218 f) s) (hf : IsLocallyHomeomorphOn f s) :\n    IsLocallyHomeomorphOn g (f '' s)", "start": [88, 1], "end": [96, 53], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.map_nhds_eq", "code": "theorem map_nhds_eq (hf : IsLocallyHomeomorphOn f s) {x : X} (hx : x \u2208 s) : (\ud835\udcdd x).map f = \ud835\udcdd (f x)", "start": [98, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.continuousAt", "code": "protected theorem continuousAt (hf : IsLocallyHomeomorphOn f s) {x : X} (hx : x \u2208 s) :\n    ContinuousAt f x", "start": [103, 1], "end": [105, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.continuousOn", "code": "protected theorem continuousOn (hf : IsLocallyHomeomorphOn f s) : ContinuousOn f s", "start": [108, 1], "end": [109, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorphOn.comp", "code": "protected theorem comp (hg : IsLocallyHomeomorphOn g t) (hf : IsLocallyHomeomorphOn f s)\n    (h : Set.MapsTo f s t) : IsLocallyHomeomorphOn (g \u2218 f) s", "start": [112, 1], "end": [117, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph", "code": "def IsLocallyHomeomorph :=\n  \u2200 x : X, \u2203 e : LocalHomeomorph X Y, x \u2208 e.source \u2227 f = e", "start": [122, 1], "end": [125, 59], "kind": "commanddeclaration"}, {"full_name": "isLocallyHomeomorph_homeomorph", "code": "theorem isLocallyHomeomorph_homeomorph (f : X \u2243\u209c Y) : IsLocallyHomeomorph f", "start": [128, 1], "end": [129, 46], "kind": "commanddeclaration"}, {"full_name": "isLocallyHomeomorph_iff_isLocallyHomeomorphOn_univ", "code": "theorem isLocallyHomeomorph_iff_isLocallyHomeomorphOn_univ :\n    IsLocallyHomeomorph f \u2194 IsLocallyHomeomorphOn f Set.univ", "start": [133, 1], "end": [135, 43], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.isLocallyHomeomorphOn", "code": "protected theorem IsLocallyHomeomorph.isLocallyHomeomorphOn (hf : IsLocallyHomeomorph f) :\n    IsLocallyHomeomorphOn f s", "start": [138, 1], "end": [139, 48], "kind": "commanddeclaration"}, {"full_name": "isLocallyHomeomorph_iff_openEmbedding_restrict", "code": "theorem isLocallyHomeomorph_iff_openEmbedding_restrict {f : X \u2192 Y} :\n    IsLocallyHomeomorph f \u2194 \u2200 x : X, \u2203 U \u2208 \ud835\udcdd x, OpenEmbedding (U.restrict f)", "start": [142, 1], "end": [145, 86], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.isLocallyHomeomorph", "code": "theorem OpenEmbedding.isLocallyHomeomorph (hf : OpenEmbedding f) : IsLocallyHomeomorph f", "start": [147, 1], "end": [149, 72], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.mk", "code": "theorem mk (h : \u2200 x : X, \u2203 e : LocalHomeomorph X Y, x \u2208 e.source \u2227 \u2200 y \u2208 e.source, f y = e y) :\n    IsLocallyHomeomorph f", "start": [155, 1], "end": [161, 59], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.of_comp", "code": "theorem of_comp (hgf : IsLocallyHomeomorph (g \u2218 f)) (hg : IsLocallyHomeomorph g)\n    (cont : Continuous f) : IsLocallyHomeomorph f", "start": [166, 1], "end": [169, 96], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.map_nhds_eq", "code": "theorem map_nhds_eq (hf : IsLocallyHomeomorph f) (x : X) : (\ud835\udcdd x).map f = \ud835\udcdd (f x)", "start": [171, 1], "end": [172, 56], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.continuous", "code": "protected theorem continuous (hf : IsLocallyHomeomorph f) : Continuous f", "start": [175, 1], "end": [176, 77], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.isOpenMap", "code": "protected theorem isOpenMap (hf : IsLocallyHomeomorph f) : IsOpenMap f", "start": [179, 1], "end": [180, 60], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.comp", "code": "protected theorem comp (hg : IsLocallyHomeomorph g) (hf : IsLocallyHomeomorph f) :\n    IsLocallyHomeomorph (g \u2218 f)", "start": [183, 1], "end": [186, 86], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.openEmbedding_of_injective", "code": "theorem openEmbedding_of_injective (hf : IsLocallyHomeomorph f) (hi : f.Injective) :\n    OpenEmbedding f", "start": [189, 1], "end": [191, 75], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.openEmbedding_of_comp", "code": "theorem openEmbedding_of_comp (hf : IsLocallyHomeomorph g) (hgf : OpenEmbedding (g \u2218 f))\n    (cont : Continuous f) : OpenEmbedding f", "start": [193, 1], "end": [196, 87], "kind": "commanddeclaration"}, {"full_name": "IsLocallyHomeomorph.isTopologicalBasis", "code": "theorem isTopologicalBasis (hf : IsLocallyHomeomorph f) : IsTopologicalBasis\n    {U : Set X | \u2203 V : Set Y, IsOpen V \u2227 \u2203 s : C(V,X), f \u2218 s = (\u2191) \u2227 Set.range s = U}", "start": [199, 1], "end": [213, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/Interval.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Data/DFinsupp/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean"], "premises": [{"full_name": "Finset.dfinsupp", "code": "def dfinsupp (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i)) : Finset (\u03a0\u2080 i, \u03b1 i) :=\n  (s.pi t).map\n    \u27e8fun f => DFinsupp.mk s fun i => f i i.2, by\n      refine' (mk_injective _).comp fun f g h => _\n      ext i hi\n      convert congr_fun h \u27e8i, hi\u27e9\u27e9", "start": [31, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dfinsupp", "code": "@[simp]\ntheorem card_dfinsupp (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i)) :\n    (s.dfinsupp t).card = \u220f i in s, (t i).card", "start": [40, 1], "end": [43, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_dfinsupp_iff", "code": "theorem mem_dfinsupp_iff : f \u2208 s.dfinsupp t \u2194 f.support \u2286 s \u2227 \u2200 i \u2208 s, f i \u2208 t i", "start": [48, 1], "end": [58, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_dfinsupp_iff_of_support_subset", "code": "@[simp]\ntheorem mem_dfinsupp_iff_of_support_subset {t : \u03a0\u2080 i, Finset (\u03b1 i)} (ht : t.support \u2286 s) :\n    f \u2208 s.dfinsupp t \u2194 \u2200 i, f i \u2208 t i", "start": [61, 1], "end": [73, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.singleton", "code": "def singleton (f : \u03a0\u2080 i, \u03b1 i) : \u03a0\u2080 i, Finset (\u03b1 i) where\n  toFun i := {f i}\n  support' := f.support'.map fun s => \u27e8s.1, fun i => (s.prop i).imp id (congr_arg _)\u27e9", "start": [86, 1], "end": [89, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_singleton_apply_iff", "code": "theorem mem_singleton_apply_iff : a \u2208 f.singleton i \u2194 a = f i", "start": [92, 1], "end": [93, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.rangeIcc", "code": "def rangeIcc (f g : \u03a0\u2080 i, \u03b1 i) : \u03a0\u2080 i, Finset (\u03b1 i) where\n  toFun i := Icc (f i) (g i)\n  support' := f.support'.bind fun fs => g.support'.map fun gs =>\n    \u27e8 fs.1 + gs.1,\n      fun i => or_iff_not_imp_left.2 fun h => by\n        have hf : f i = 0 := (fs.prop i).resolve_left\n            (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_right _ _) h)\n        have hg : g i = 0 := (gs.prop i).resolve_left\n            (Multiset.not_mem_mono (Multiset.Le.subset <| Multiset.le_add_left _ _) h)\n        simp_rw [hf, hg]\n        exact Icc_self _\u27e9", "start": [103, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.rangeIcc_apply", "code": "@[simp]\ntheorem rangeIcc_apply (f g : \u03a0\u2080 i, \u03b1 i) (i : \u03b9) : f.rangeIcc g i = Icc (f i) (g i)", "start": [118, 1], "end": [119, 91], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_rangeIcc_apply_iff", "code": "theorem mem_rangeIcc_apply_iff : a \u2208 f.rangeIcc g i \u2194 f i \u2264 a \u2227 a \u2264 g i", "start": [122, 1], "end": [122, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_rangeIcc_subset", "code": "theorem support_rangeIcc_subset [DecidableEq \u03b9] [\u2200 i, DecidableEq (\u03b1 i)] :\n    (f.rangeIcc g).support \u2286 f.support \u222a g.support", "start": [125, 1], "end": [132, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.pi", "code": "def pi (f : \u03a0\u2080 i, Finset (\u03b1 i)) : Finset (\u03a0\u2080 i, \u03b1 i) := f.support.dfinsupp f", "start": [141, 1], "end": [143, 77], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_pi", "code": "@[simp]\ntheorem mem_pi {f : \u03a0\u2080 i, Finset (\u03b1 i)} {g : \u03a0\u2080 i, \u03b1 i} : g \u2208 f.pi \u2194 \u2200 i, g i \u2208 f i", "start": [146, 1], "end": [148, 54], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_pi", "code": "@[simp]\ntheorem card_pi (f : \u03a0\u2080 i, Finset (\u03b1 i)) : f.pi.card = f.prod fun i => (f i).card", "start": [151, 1], "end": [154, 82], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Icc_eq", "code": "theorem Icc_eq : Icc f g = (f.support \u222a g.support).dfinsupp (f.rangeIcc g)", "start": [175, 1], "end": [175, 82], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Icc", "code": "theorem card_Icc : (Icc f g).card = \u220f i in f.support \u222a g.support, (Icc (f i) (g i)).card", "start": [178, 1], "end": [179, 20], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Ico", "code": "theorem card_Ico : (Ico f g).card = (\u220f i in f.support \u222a g.support, (Icc (f i) (g i)).card) - 1", "start": [182, 1], "end": [183, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Ioc", "code": "theorem card_Ioc : (Ioc f g).card = (\u220f i in f.support \u222a g.support, (Icc (f i) (g i)).card) - 1", "start": [186, 1], "end": [187, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Ioo", "code": "theorem card_Ioo : (Ioo f g).card = (\u220f i in f.support \u222a g.support, (Icc (f i) (g i)).card) - 2", "start": [190, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_uIcc", "code": "theorem card_uIcc : (uIcc f g).card = \u220f i in f.support \u222a g.support, (uIcc (f i) (g i)).card", "start": [200, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Iic", "code": "theorem card_Iic : (Iic f).card = \u220f i in f.support, (Iic (f i)).card", "start": [214, 1], "end": [216, 17], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.card_Iio", "code": "theorem card_Iio : (Iio f).card = (\u220f i in f.support, (Iic (f i)).card) - 1", "start": [219, 1], "end": [220, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/Multiset.lean", "imports": ["Mathlib/Data/DFinsupp/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFinsupp.addZeroClass'", "code": "instance addZeroClass' {\u03b2} [AddZeroClass \u03b2] : AddZeroClass (\u03a0\u2080 _ : \u03b1, \u03b2) :=\n  @DFinsupp.addZeroClass \u03b1 (fun _ \u21a6 \u03b2) _", "start": [23, 1], "end": [25, 41], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset", "code": "def toMultiset : (\u03a0\u2080 _ : \u03b1, \u2115) \u2192+ Multiset \u03b1 :=\n  DFinsupp.sumAddHom fun a : \u03b1 \u21a6 Multiset.replicateAddMonoidHom a", "start": [30, 1], "end": [32, 66], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_single", "code": "@[simp]\ntheorem toMultiset_single (a : \u03b1) (n : \u2115) :\n    toMultiset (DFinsupp.single a n) = Multiset.replicate n a", "start": [35, 1], "end": [38, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp", "code": "def toDFinsupp : Multiset \u03b1 \u2192+ \u03a0\u2080 _ : \u03b1, \u2115 where\n  toFun s :=\n    { toFun := fun n \u21a6 s.count n\n      support' := Trunc.mk \u27e8s, fun i \u21a6 (em (i \u2208 s)).imp_right Multiset.count_eq_zero_of_not_mem\u27e9 }\n  map_zero' := rfl\n  map_add' _ _ := DFinsupp.ext fun _ \u21a6 Multiset.count_add _ _ _", "start": [47, 1], "end": [53, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_apply", "code": "@[simp]\ntheorem toDFinsupp_apply (s : Multiset \u03b1) (a : \u03b1) : Multiset.toDFinsupp s a = s.count a", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_support", "code": "@[simp]\ntheorem toDFinsupp_support (s : Multiset \u03b1) : s.toDFinsupp.support = s.toFinset", "start": [61, 1], "end": [63, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_replicate", "code": "@[simp]\ntheorem toDFinsupp_replicate (a : \u03b1) (n : \u2115) :\n    toDFinsupp (Multiset.replicate n a) = DFinsupp.single a n", "start": [66, 1], "end": [71, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_singleton", "code": "@[simp]\ntheorem toDFinsupp_singleton (a : \u03b1) : toDFinsupp {a} = DFinsupp.single a 1", "start": [74, 1], "end": [76, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.equivDFinsupp", "code": "@[simps! apply symm_apply]\ndef equivDFinsupp : Multiset \u03b1 \u2243+ \u03a0\u2080 _ : \u03b1, \u2115 :=\n  AddMonoidHom.toAddEquiv Multiset.toDFinsupp DFinsupp.toMultiset (by ext; simp) (by ext; simp)", "start": [79, 1], "end": [82, 96], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_toMultiset", "code": "@[simp]\ntheorem toDFinsupp_toMultiset (s : Multiset \u03b1) : DFinsupp.toMultiset (Multiset.toDFinsupp s) = s", "start": [85, 1], "end": [87, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_injective", "code": "theorem toDFinsupp_injective : Injective (toDFinsupp : Multiset \u03b1 \u2192 \u03a0\u2080 _a, \u2115)", "start": [90, 1], "end": [91, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_inj", "code": "@[simp]\ntheorem toDFinsupp_inj : toDFinsupp s = toDFinsupp t \u2194 s = t", "start": [94, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_le_toDFinsupp", "code": "@[simp]\ntheorem toDFinsupp_le_toDFinsupp : toDFinsupp s \u2264 toDFinsupp t \u2194 s \u2264 t", "start": [99, 1], "end": [101, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_lt_toDFinsupp", "code": "@[simp]\ntheorem toDFinsupp_lt_toDFinsupp : toDFinsupp s < toDFinsupp t \u2194 s < t", "start": [104, 1], "end": [106, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_inter", "code": "@[simp]\ntheorem toDFinsupp_inter (s t : Multiset \u03b1) : toDFinsupp (s \u2229 t) = toDFinsupp s \u2293 toDFinsupp t", "start": [109, 1], "end": [111, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.toDFinsupp_union", "code": "@[simp]\ntheorem toDFinsupp_union (s t : Multiset \u03b1) : toDFinsupp (s \u222a t) = toDFinsupp s \u2294 toDFinsupp t", "start": [114, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_toDFinsupp", "code": "@[simp]\ntheorem toMultiset_toDFinsupp [DecidableEq \u03b1] (f : \u03a0\u2080 _ : \u03b1, \u2115) :\n    Multiset.toDFinsupp (DFinsupp.toMultiset f) = f", "start": [126, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_injective", "code": "theorem toMultiset_injective : Injective (toMultiset : (\u03a0\u2080 _a, \u2115) \u2192 Multiset \u03b1)", "start": [132, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_inj", "code": "@[simp]\ntheorem toMultiset_inj : toMultiset f = toMultiset g \u2194 f = g", "start": [136, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_le_toMultiset", "code": "@[simp]\ntheorem toMultiset_le_toMultiset : toMultiset f \u2264 toMultiset g \u2194 f \u2264 g", "start": [141, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_lt_toMultiset", "code": "@[simp]\ntheorem toMultiset_lt_toMultiset : toMultiset f < toMultiset g \u2194 f < g", "start": [146, 1], "end": [148, 71], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_inf", "code": "@[simp]\ntheorem toMultiset_inf : toMultiset (f \u2293 g) = toMultiset f \u2229 toMultiset g", "start": [153, 1], "end": [155, 43], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toMultiset_sup", "code": "@[simp]\ntheorem toMultiset_sup : toMultiset (f \u2294 g) = toMultiset f\u222a toMultiset g", "start": [158, 1], "end": [160, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Complemented.lean", "imports": ["Mathlib/Analysis/NormedSpace/Banach.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.ker_closedComplemented_of_finiteDimensional_range", "code": "theorem ker_closedComplemented_of_finiteDimensional_range (f : E \u2192L[\ud835\udd5c] F)\n    [FiniteDimensional \ud835\udd5c (range f)] : (ker f).ClosedComplemented", "start": [39, 1], "end": [43, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl", "code": "nonrec def equivProdOfSurjectiveOfIsCompl (f : E \u2192L[\ud835\udd5c] F) (g : E \u2192L[\ud835\udd5c] G) (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) : E \u2243L[\ud835\udd5c] F \u00d7 G :=\n  (f.equivProdOfSurjectiveOfIsCompl (g : E \u2192\u2097[\ud835\udd5c] G) hf hg hfg).toContinuousLinearEquivOfContinuous\n    (f.continuous.prod_mk g.continuous)", "start": [50, 1], "end": [56, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_equivProdOfSurjectiveOfIsCompl", "code": "@[simp]\ntheorem coe_equivProdOfSurjectiveOfIsCompl {f : E \u2192L[\ud835\udd5c] F} {g : E \u2192L[\ud835\udd5c] G} (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg : E \u2192\u2097[\ud835\udd5c] F \u00d7 G) = f.prod g", "start": [59, 1], "end": [62, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_toLinearEquiv", "code": "@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_toLinearEquiv {f : E \u2192L[\ud835\udd5c] F} {g : E \u2192L[\ud835\udd5c] G}\n    (hf : range f = \u22a4) (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg).toLinearEquiv =\n      LinearMap.equivProdOfSurjectiveOfIsCompl f g hf hg hfg", "start": [65, 1], "end": [69, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_apply", "code": "@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_apply {f : E \u2192L[\ud835\udd5c] F} {g : E \u2192L[\ud835\udd5c] G} (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) (x : E) :\n    equivProdOfSurjectiveOfIsCompl f g hf hg hfg x = (f x, g x)", "start": [72, 1], "end": [75, 71], "kind": "commanddeclaration"}, {"full_name": "Subspace.prodEquivOfClosedCompl", "code": "def prodEquivOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) : (p \u00d7 q) \u2243L[\ud835\udd5c] E := by\n  haveI := hp.completeSpace_coe; haveI := hq.completeSpace_coe\n  refine' (p.prodEquivOfIsCompl q h).toContinuousLinearEquivOfContinuous _\n  exact (p.subtypeL.coprod q.subtypeL).continuous", "start": [84, 1], "end": [90, 50], "kind": "commanddeclaration"}, {"full_name": "Subspace.linearProjOfClosedCompl", "code": "def linearProjOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) : E \u2192L[\ud835\udd5c] p :=\n  ContinuousLinearMap.fst \ud835\udd5c p q \u2218L \u2191(prodEquivOfClosedCompl p q h hp hq).symm", "start": [93, 1], "end": [96, 78], "kind": "commanddeclaration"}, {"full_name": "Subspace.coe_prodEquivOfClosedCompl", "code": "@[simp]\ntheorem coe_prodEquivOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    \u21d1(p.prodEquivOfClosedCompl q h hp hq) = p.prodEquivOfIsCompl q h", "start": [101, 1], "end": [104, 76], "kind": "commanddeclaration"}, {"full_name": "Subspace.coe_prodEquivOfClosedCompl_symm", "code": "@[simp]\ntheorem coe_prodEquivOfClosedCompl_symm (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    \u21d1(p.prodEquivOfClosedCompl q h hp hq).symm = (p.prodEquivOfIsCompl q h).symm", "start": [107, 1], "end": [110, 88], "kind": "commanddeclaration"}, {"full_name": "Subspace.coe_continuous_linearProjOfClosedCompl", "code": "@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    (p.linearProjOfClosedCompl q h hp hq : E \u2192\u2097[\ud835\udd5c] p) = p.linearProjOfIsCompl q h", "start": [113, 1], "end": [116, 89], "kind": "commanddeclaration"}, {"full_name": "Subspace.coe_continuous_linearProjOfClosedCompl'", "code": "@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl' (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    \u21d1(p.linearProjOfClosedCompl q h hp hq) = p.linearProjOfIsCompl q h", "start": [119, 1], "end": [122, 78], "kind": "commanddeclaration"}, {"full_name": "Subspace.closedComplemented_of_closed_compl", "code": "theorem closedComplemented_of_closed_compl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) : p.ClosedComplemented", "start": [125, 1], "end": [127, 84], "kind": "commanddeclaration"}, {"full_name": "Subspace.closedComplemented_iff_has_closed_compl", "code": "theorem closedComplemented_iff_has_closed_compl :\n    p.ClosedComplemented \u2194\n      IsClosed (p : Set E) \u2227 \u2203 (q : Subspace \ud835\udd5c E) (_ : IsClosed (q : Set E)), IsCompl p q", "start": [130, 1], "end": [134, 76], "kind": "commanddeclaration"}, {"full_name": "Subspace.closedComplemented_of_quotient_finiteDimensional", "code": "theorem closedComplemented_of_quotient_finiteDimensional [CompleteSpace \ud835\udd5c]\n    [FiniteDimensional \ud835\udd5c (E \u29f8 p)] (hp : IsClosed (p : Set E)) : p.ClosedComplemented", "start": [137, 1], "end": [141, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/Product.lean", "Mathlib/Topology/Homotopy/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "unitInterval.path01", "code": "def path01 : Path (0 : I) 1 where\n  toFun := id\n  source' := rfl\n  target' := rfl", "start": [49, 1], "end": [53, 17], "kind": "commanddeclaration"}, {"full_name": "unitInterval.upath01", "code": "def upath01 : Path (ULift.up 0 : ULift.{u} I) (ULift.up 1) where\n  toFun := ULift.up\n  source' := rfl\n  target' := rfl", "start": [56, 1], "end": [60, 17], "kind": "commanddeclaration"}, {"full_name": "unitInterval.uhpath01", "code": "def uhpath01 : @fromTop (TopCat.of <| ULift.{u} I) (ULift.up (0 : I)) \u27f6 fromTop (ULift.up 1) :=\n  \u27e6upath01\u27e7", "start": [65, 1], "end": [67, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.hcast", "code": "abbrev hcast {X : TopCat} {x\u2080 x\u2081 : X} (hx : x\u2080 = x\u2081) : fromTop x\u2080 \u27f6 fromTop x\u2081 :=\n  eqToHom hx", "start": [80, 1], "end": [82, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.hcast_def", "code": "@[simp]\ntheorem hcast_def {X : TopCat} {x\u2080 x\u2081 : X} (hx\u2080 : x\u2080 = x\u2081) : hcast hx\u2080 = eqToHom hx\u2080", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.heq_path_of_eq_image", "code": "theorem heq_path_of_eq_image : HEq ((\u03c0\u2098 f).map \u27e6p\u27e7) ((\u03c0\u2098 g).map \u27e6q\u27e7)", "start": [93, 1], "end": [96, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.start_path", "code": "private theorem start_path : f x\u2080 = g x\u2082", "start": [99, 1], "end": [99, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.end_path", "code": "private theorem end_path : f x\u2081 = g x\u2083", "start": [101, 1], "end": [101, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.eq_path_of_eq_image", "code": "theorem eq_path_of_eq_image :\n    (\u03c0\u2098 f).map \u27e6p\u27e7 = hcast (start_path hfg) \u226b (\u03c0\u2098 g).map \u27e6q\u27e7 \u226b hcast (end_path hfg).symm", "start": [103, 1], "end": [107, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.uliftMap", "code": "def uliftMap : C(TopCat.of (ULift.{u} I \u00d7 X), Y) :=\n  \u27e8fun x => H (x.1.down, x.2),\n    H.continuous.comp ((continuous_induced_dom.comp continuous_fst).prod_mk continuous_snd)\u27e9", "start": [139, 1], "end": [142, 93], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.ulift_apply", "code": "@[simp, nolint simpNF]\ntheorem ulift_apply (i : ULift.{u} I) (x : X) : H.uliftMap (i, x) = H (i.down, x)", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.prodToProdTopI", "code": "abbrev prodToProdTopI {a\u2081 a\u2082 : TopCat.of (ULift I)} {b\u2081 b\u2082 : X} (p\u2081 : fromTop a\u2081 \u27f6 fromTop a\u2082)\n    (p\u2082 : fromTop b\u2081 \u27f6 fromTop b\u2082) :=\n  (prodToProdTop (TopCat.of <| ULift I) X).map (X := (a\u2081, b\u2081)) (Y := (a\u2082, b\u2082)) (p\u2081, p\u2082)", "start": [151, 1], "end": [155, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.diagonalPath", "code": "def diagonalPath : fromTop (H (0, x\u2080)) \u27f6 fromTop (H (1, x\u2081)) :=\n  (\u03c0\u2098 H.uliftMap).map (prodToProdTopI uhpath01 p)", "start": [159, 1], "end": [161, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.diagonalPath'", "code": "def diagonalPath' : fromTop (f x\u2080) \u27f6 fromTop (g x\u2081) :=\n  hcast (H.apply_zero x\u2080).symm \u226b H.diagonalPath p \u226b hcast (H.apply_one x\u2081)", "start": [164, 1], "end": [166, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.apply_zero_path", "code": "theorem apply_zero_path : (\u03c0\u2098 f).map p = hcast (H.apply_zero x\u2080).symm \u226b\n    (\u03c0\u2098 H.uliftMap).map (prodToProdTopI (\ud835\udfd9 (@fromTop (TopCat.of _) (ULift.up 0))) p) \u226b\n    hcast (H.apply_zero x\u2081)", "start": [169, 1], "end": [176, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.apply_one_path", "code": "theorem apply_one_path : (\u03c0\u2098 g).map p = hcast (H.apply_one x\u2080).symm \u226b\n    (\u03c0\u2098 H.uliftMap).map (prodToProdTopI (\ud835\udfd9 (@fromTop (TopCat.of _) (ULift.up 1))) p) \u226b\n    hcast (H.apply_one x\u2081)", "start": [179, 1], "end": [186, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.evalAt_eq", "code": "theorem evalAt_eq (x : X) : \u27e6H.evalAt x\u27e7 = hcast (H.apply_zero x).symm \u226b\n    (\u03c0\u2098 H.uliftMap).map (prodToProdTopI uhpath01 (\ud835\udfd9 x)) \u226b hcast (H.apply_one x).symm.symm", "start": [189, 1], "end": [196, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.eq_diag_path", "code": "theorem eq_diag_path : (\u03c0\u2098 f).map p \u226b \u27e6H.evalAt x\u2081\u27e7 = H.diagonalPath' p \u2227\n    (\u27e6H.evalAt x\u2080\u27e7 \u226b (\u03c0\u2098 g).map p : fromTop (f x\u2080) \u27f6 fromTop (g x\u2081)) = H.diagonalPath' p", "start": [200, 1], "end": [209, 62], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.homotopicMapsNatIso", "code": "def homotopicMapsNatIso : @Quiver.Hom _ Functor.category.toQuiver (\u03c0\u2098 f) (\u03c0\u2098 g) where\n  app x := \u27e6H.evalAt x\u27e7\n  naturality x y p := by erw [(H.eq_diag_path p).1, (H.eq_diag_path p).2]", "start": [224, 1], "end": [230, 74], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.equivOfHomotopyEquiv", "code": "def equivOfHomotopyEquiv (hequiv : X \u2243\u2095 Y) : \u03c0\u2093 X \u224c \u03c0\u2093 Y := by\n  apply CategoryTheory.Equivalence.mk (\u03c0\u2098 hequiv.toFun : \u03c0\u2093 X \u2964 \u03c0\u2093 Y)\n    (\u03c0\u2098 hequiv.invFun : \u03c0\u2093 Y \u2964 \u03c0\u2093 X) <;>\n    simp only [Grpd.hom_to_functor, Grpd.id_to_functor]\n  \u00b7 convert (asIso (homotopicMapsNatIso hequiv.left_inv.some)).symm\n    exacts [((\u03c0).map_id X).symm, ((\u03c0).map_comp _ _).symm]\n  \u00b7 convert asIso (homotopicMapsNatIso hequiv.right_inv.some)\n    exacts [((\u03c0).map_comp _ _).symm, ((\u03c0).map_id Y).symm]", "start": [237, 1], "end": [245, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/PUnit.lean", "imports": ["Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FundamentalGroupoid.punitEquivDiscretePUnit", "code": "def punitEquivDiscretePUnit : FundamentalGroupoid PUnit.{u + 1} \u224c Discrete PUnit.{v + 1} :=\n  CategoryTheory.Equivalence.mk (Functor.star _) ((CategoryTheory.Functor.const _).obj PUnit.unit)\n    (NatIso.ofComponents fun _ => eqToIso (by simp))\n    (Functor.punitExt _ _)", "start": [37, 1], "end": [42, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Join.lean", "imports": ["Mathlib/Analysis/Convex/Combination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "convexJoin", "code": "def convexJoin (s t : Set E) : Set E :=\n  \u22c3 (x \u2208 s) (y \u2208 t), segment \ud835\udd5c x y", "start": [30, 1], "end": [33, 35], "kind": "commanddeclaration"}, {"full_name": "mem_convexJoin", "code": "theorem mem_convexJoin : x \u2208 convexJoin \ud835\udd5c s t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, x \u2208 segment \ud835\udd5c a b", "start": [38, 1], "end": [39, 20], "kind": "commanddeclaration"}, {"full_name": "convexJoin_comm", "code": "theorem convexJoin_comm (s t : Set E) : convexJoin \ud835\udd5c s t = convexJoin \ud835\udd5c t s", "start": [42, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "convexJoin_mono", "code": "theorem convexJoin_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : convexJoin \ud835\udd5c s\u2081 t\u2081 \u2286 convexJoin \ud835\udd5c s\u2082 t\u2082", "start": [46, 1], "end": [47, 60], "kind": "commanddeclaration"}, {"full_name": "convexJoin_mono_left", "code": "theorem convexJoin_mono_left (hs : s\u2081 \u2286 s\u2082) : convexJoin \ud835\udd5c s\u2081 t \u2286 convexJoin \ud835\udd5c s\u2082 t", "start": [50, 1], "end": [51, 32], "kind": "commanddeclaration"}, {"full_name": "convexJoin_mono_right", "code": "theorem convexJoin_mono_right (ht : t\u2081 \u2286 t\u2082) : convexJoin \ud835\udd5c s t\u2081 \u2286 convexJoin \ud835\udd5c s t\u2082", "start": [54, 1], "end": [55, 32], "kind": "commanddeclaration"}, {"full_name": "convexJoin_empty_left", "code": "@[simp]\ntheorem convexJoin_empty_left (t : Set E) : convexJoin \ud835\udd5c \u2205 t = \u2205", "start": [58, 1], "end": [59, 89], "kind": "commanddeclaration"}, {"full_name": "convexJoin_empty_right", "code": "@[simp]\ntheorem convexJoin_empty_right (s : Set E) : convexJoin \ud835\udd5c s \u2205 = \u2205", "start": [62, 1], "end": [63, 90], "kind": "commanddeclaration"}, {"full_name": "convexJoin_singleton_left", "code": "@[simp]\ntheorem convexJoin_singleton_left (t : Set E) (x : E) :\n    convexJoin \ud835\udd5c {x} t = \u22c3 y \u2208 t, segment \ud835\udd5c x y", "start": [66, 1], "end": [68, 72], "kind": "commanddeclaration"}, {"full_name": "convexJoin_singleton_right", "code": "@[simp]\ntheorem convexJoin_singleton_right (s : Set E) (y : E) :\n    convexJoin \ud835\udd5c s {y} = \u22c3 x \u2208 s, segment \ud835\udd5c x y", "start": [71, 1], "end": [73, 72], "kind": "commanddeclaration"}, {"full_name": "convexJoin_singletons", "code": "theorem convexJoin_singletons (x : E) : convexJoin \ud835\udd5c {x} {y} = segment \ud835\udd5c x y", "start": [77, 1], "end": [77, 88], "kind": "commanddeclaration"}, {"full_name": "convexJoin_union_left", "code": "@[simp]\ntheorem convexJoin_union_left (s\u2081 s\u2082 t : Set E) :\n    convexJoin \ud835\udd5c (s\u2081 \u222a s\u2082) t = convexJoin \ud835\udd5c s\u2081 t \u222a convexJoin \ud835\udd5c s\u2082 t", "start": [80, 1], "end": [83, 67], "kind": "commanddeclaration"}, {"full_name": "convexJoin_union_right", "code": "@[simp]\ntheorem convexJoin_union_right (s t\u2081 t\u2082 : Set E) :\n    convexJoin \ud835\udd5c s (t\u2081 \u222a t\u2082) = convexJoin \ud835\udd5c s t\u2081 \u222a convexJoin \ud835\udd5c s t\u2082", "start": [86, 1], "end": [89, 53], "kind": "commanddeclaration"}, {"full_name": "convexJoin_iUnion_left", "code": "@[simp]\ntheorem convexJoin_iUnion_left (s : \u03b9 \u2192 Set E) (t : Set E) :\n    convexJoin \ud835\udd5c (\u22c3 i, s i) t = \u22c3 i, convexJoin \ud835\udd5c (s i) t", "start": [92, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "convexJoin_iUnion_right", "code": "@[simp]\ntheorem convexJoin_iUnion_right (s : Set E) (t : \u03b9 \u2192 Set E) :\n    convexJoin \ud835\udd5c s (\u22c3 i, t i) = \u22c3 i, convexJoin \ud835\udd5c s (t i)", "start": [99, 1], "end": [102, 54], "kind": "commanddeclaration"}, {"full_name": "segment_subset_convexJoin", "code": "theorem segment_subset_convexJoin (hx : x \u2208 s) (hy : y \u2208 t) : segment \ud835\udd5c x y \u2286 convexJoin \ud835\udd5c s t", "start": [105, 1], "end": [106, 86], "kind": "commanddeclaration"}, {"full_name": "subset_convexJoin_left", "code": "theorem subset_convexJoin_left (h : t.Nonempty) : s \u2286 convexJoin \ud835\udd5c s t", "start": [109, 1], "end": [111, 60], "kind": "commanddeclaration"}, {"full_name": "subset_convexJoin_right", "code": "theorem subset_convexJoin_right (h : s.Nonempty) : t \u2286 convexJoin \ud835\udd5c s t", "start": [114, 1], "end": [115, 58], "kind": "commanddeclaration"}, {"full_name": "convexJoin_subset", "code": "theorem convexJoin_subset (hs : s \u2286 u) (ht : t \u2286 u) (hu : Convex \ud835\udd5c u) : convexJoin \ud835\udd5c s t \u2286 u", "start": [118, 1], "end": [119, 92], "kind": "commanddeclaration"}, {"full_name": "convexJoin_subset_convexHull", "code": "theorem convexJoin_subset_convexHull (s t : Set E) : convexJoin \ud835\udd5c s t \u2286 convexHull \ud835\udd5c (s \u222a t)", "start": [122, 1], "end": [125, 26], "kind": "commanddeclaration"}, {"full_name": "convexJoin_assoc_aux", "code": "theorem convexJoin_assoc_aux (s t u : Set E) :\n    convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s t) u \u2286 convexJoin \ud835\udd5c s (convexJoin \ud835\udd5c t u)", "start": [134, 1], "end": [151, 73], "kind": "commanddeclaration"}, {"full_name": "convexJoin_assoc", "code": "theorem convexJoin_assoc (s t u : Set E) :\n    convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s t) u = convexJoin \ud835\udd5c s (convexJoin \ud835\udd5c t u)", "start": [154, 1], "end": [158, 35], "kind": "commanddeclaration"}, {"full_name": "convexJoin_left_comm", "code": "theorem convexJoin_left_comm (s t u : Set E) :\n    convexJoin \ud835\udd5c s (convexJoin \ud835\udd5c t u) = convexJoin \ud835\udd5c t (convexJoin \ud835\udd5c s u)", "start": [161, 1], "end": [163, 48], "kind": "commanddeclaration"}, {"full_name": "convexJoin_right_comm", "code": "theorem convexJoin_right_comm (s t u : Set E) :\n    convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s t) u = convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s u) t", "start": [166, 1], "end": [168, 46], "kind": "commanddeclaration"}, {"full_name": "convexJoin_convexJoin_convexJoin_comm", "code": "theorem convexJoin_convexJoin_convexJoin_comm (s t u v : Set E) :\n    convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s t) (convexJoin \ud835\udd5c u v) =\n      convexJoin \ud835\udd5c (convexJoin \ud835\udd5c s u) (convexJoin \ud835\udd5c t v)", "start": [171, 1], "end": [174, 57], "kind": "commanddeclaration"}, {"full_name": "Convex.convexJoin", "code": "protected theorem Convex.convexJoin (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) :\n    Convex \ud835\udd5c (convexJoin \ud835\udd5c s t)", "start": [178, 1], "end": [188, 36], "kind": "commanddeclaration"}, {"full_name": "Convex.convexHull_union", "code": "protected theorem Convex.convexHull_union (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) (hs\u2080 : s.Nonempty)\n    (ht\u2080 : t.Nonempty) : convexHull \ud835\udd5c (s \u222a t) = convexJoin \ud835\udd5c s t", "start": [191, 1], "end": [195, 37], "kind": "commanddeclaration"}, {"full_name": "convexHull_union", "code": "theorem convexHull_union (hs : s.Nonempty) (ht : t.Nonempty) :\n    convexHull \ud835\udd5c (s \u222a t) = convexJoin \ud835\udd5c (convexHull \ud835\udd5c s) (convexHull \ud835\udd5c t)", "start": [198, 1], "end": [201, 101], "kind": "commanddeclaration"}, {"full_name": "convexHull_insert", "code": "theorem convexHull_insert (hs : s.Nonempty) :\n    convexHull \ud835\udd5c (insert x s) = convexJoin \ud835\udd5c {x} (convexHull \ud835\udd5c s)", "start": [204, 1], "end": [206, 83], "kind": "commanddeclaration"}, {"full_name": "convexJoin_segments", "code": "theorem convexJoin_segments (a b c d : E) :\n    convexJoin \ud835\udd5c (segment \ud835\udd5c a b) (segment \ud835\udd5c c d) = convexHull \ud835\udd5c {a, b, c, d}", "start": [209, 1], "end": [213, 26], "kind": "commanddeclaration"}, {"full_name": "convexJoin_segment_singleton", "code": "theorem convexJoin_segment_singleton (a b c : E) :\n    convexJoin \ud835\udd5c (segment \ud835\udd5c a b) {c} = convexHull \ud835\udd5c {a, b, c}", "start": [216, 1], "end": [218, 83], "kind": "commanddeclaration"}, {"full_name": "convexJoin_singleton_segment", "code": "theorem convexJoin_singleton_segment (a b c : E) :\n    convexJoin \ud835\udd5c {a} (segment \ud835\udd5c b c) = convexHull \ud835\udd5c {a, b, c}", "start": [221, 1], "end": [223, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/PosDef.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Spectrum.lean", "Mathlib/LinearAlgebra/QuadraticForm/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.PosDef", "code": "def PosDef (M : Matrix n n R) :=\n  M.IsHermitian \u2227 \u2200 x : n \u2192 R, x \u2260 0 \u2192 0 < dotProduct (star x) (M.mulVec x)", "start": [36, 1], "end": [39, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosDef.isHermitian", "code": "theorem PosDef.isHermitian {M : Matrix n n R} (hM : M.PosDef) : M.IsHermitian", "start": [42, 1], "end": [43, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosDef.re_dotProduct_pos", "code": "theorem PosDef.re_dotProduct_pos {M : Matrix n n \ud835\udd5c} (hM : M.PosDef) {x : n \u2192 \ud835\udd5c} (hx : x \u2260 0) :\n    0 < IsROrC.re (dotProduct (star x) (M.mulVec x))", "start": [46, 1], "end": [48, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosSemidef", "code": "def PosSemidef (M : Matrix n n R) :=\n  M.IsHermitian \u2227 \u2200 x : n \u2192 R, 0 \u2264 dotProduct (star x) (M.mulVec x)", "start": [50, 1], "end": [53, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosSemidef.re_dotProduct_nonneg", "code": "theorem PosSemidef.re_dotProduct_nonneg {M : Matrix n n \ud835\udd5c} (hM : M.PosSemidef) (x : n \u2192 \ud835\udd5c) :\n    0 \u2264 IsROrC.re (dotProduct (star x) (M.mulVec x))", "start": [56, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosDef.posSemidef", "code": "theorem PosDef.posSemidef {M : Matrix n n R} (hM : M.PosDef) : M.PosSemidef", "start": [60, 1], "end": [66, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosSemidef.submatrix", "code": "theorem PosSemidef.submatrix {M : Matrix n n R} (hM : M.PosSemidef) (e : m \u2243 n) :\n    (M.submatrix e e).PosSemidef", "start": [69, 1], "end": [82, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.posSemidef_submatrix_equiv", "code": "@[simp]\ntheorem posSemidef_submatrix_equiv {M : Matrix n n R} (e : m \u2243 n) :\n    (M.submatrix e e).PosSemidef \u2194 M.PosSemidef", "start": [85, 1], "end": [88, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosDef.transpose", "code": "theorem PosDef.transpose {M : Matrix n n R} (hM : M.PosDef) : M\u1d40.PosDef", "start": [91, 1], "end": [94, 78], "kind": "commanddeclaration"}, {"full_name": "Matrix.posDef_of_toQuadraticForm'", "code": "theorem posDef_of_toQuadraticForm' [DecidableEq n] {M : Matrix n n \u211d} (hM : M.IsSymm)\n    (hMq : M.toQuadraticForm'.PosDef) : M.PosDef", "start": [97, 1], "end": [102, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.posDef_toQuadraticForm'", "code": "theorem posDef_toQuadraticForm' [DecidableEq n] {M : Matrix n n \u211d} (hM : M.PosDef) :\n    M.toQuadraticForm'.PosDef", "start": [105, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.posSemidef_conjTranspose_mul_self", "code": "theorem posSemidef_conjTranspose_mul_self (A : Matrix m n R) : Matrix.PosSemidef (A\u1d34 * A)", "start": [112, 1], "end": [116, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.posSemidef_self_mul_conjTranspose", "code": "theorem posSemidef_self_mul_conjTranspose (A : Matrix m n R) : Matrix.PosSemidef (A * A\u1d34)", "start": [118, 1], "end": [120, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.PosDef.eigenvalues_pos", "code": "lemma PosDef.eigenvalues_pos [DecidableEq n] {A : Matrix n n \ud835\udd5c}\n    (hA : Matrix.PosDef A) (i : n) : 0 < hA.1.eigenvalues i := by\n  rw [hA.1.eigenvalues_eq, hA.1.transpose_eigenvectorMatrix_apply]\n  exact hA.re_dotProduct_pos <| hA.1.eigenvectorBasis.orthonormal.ne_zero i", "start": [122, 1], "end": [126, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.PosSemidef.eigenvalues_nonneg", "code": "lemma PosSemidef.eigenvalues_nonneg [DecidableEq n] {A : Matrix n n \ud835\udd5c}\n    (hA : Matrix.PosSemidef A) (i : n) : 0 \u2264 hA.1.eigenvalues i :=\n  (hA.re_dotProduct_nonneg _).trans_eq (hA.1.eigenvalues_eq _).symm", "start": [128, 1], "end": [131, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.eigenvalues_conjTranspose_mul_self_nonneg", "code": "lemma eigenvalues_conjTranspose_mul_self_nonneg (A : Matrix m n \ud835\udd5c) [DecidableEq n] (i : n) :\n    0 \u2264 (isHermitian_transpose_mul_self A).eigenvalues i :=\n  (Matrix.posSemidef_conjTranspose_mul_self _).eigenvalues_nonneg _", "start": [133, 1], "end": [135, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.eigenvalues_self_mul_conjTranspose_nonneg", "code": "lemma eigenvalues_self_mul_conjTranspose_nonneg (A : Matrix m n \ud835\udd5c) [DecidableEq m] (i : m) :\n    0 \u2264 (isHermitian_mul_conjTranspose_self A).eigenvalues i :=\n  (Matrix.posSemidef_self_mul_conjTranspose _).eigenvalues_nonneg _", "start": [137, 1], "end": [139, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.PosDef.det_pos", "code": "theorem det_pos [DecidableEq n] : 0 < det M", "start": [145, 1], "end": [154, 63], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.posDef_of_toMatrix'", "code": "theorem posDef_of_toMatrix' [DecidableEq n] {Q : QuadraticForm \u211d (n \u2192 \u211d)}\n    (hQ : Q.toMatrix'.PosDef) : Q.PosDef", "start": [165, 1], "end": [169, 42], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.posDef_toMatrix'", "code": "theorem posDef_toMatrix' [DecidableEq n] {Q : QuadraticForm \u211d (n \u2192 \u211d)} (hQ : Q.PosDef) :\n    Q.toMatrix'.PosDef", "start": [172, 1], "end": [176, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.NormedAddCommGroup.ofMatrix", "code": "@[reducible]\nnoncomputable def NormedAddCommGroup.ofMatrix {M : Matrix n n \ud835\udd5c} (hM : M.PosDef) :\n    NormedAddCommGroup (n \u2192 \ud835\udd5c) :=\n  @InnerProductSpace.Core.toNormedAddCommGroup _ _ _ _ _\n    { inner := fun x y => dotProduct (star x) (M.mulVec y)\n      conj_symm := fun x y => by\n        dsimp only [Inner.inner]\n        rw [star_dotProduct, starRingEnd_apply, star_star, star_mulVec, dotProduct_mulVec,\n          hM.isHermitian.eq]\n      nonneg_re := fun x => by\n        by_cases h : x = 0\n        \u00b7 simp [h]\n        \u00b7 exact le_of_lt (hM.re_dotProduct_pos h)\n      definite := fun x (hx : dotProduct _ _ = 0) => by\n        by_contra' h\n        simpa [hx, lt_irrefl] using hM.re_dotProduct_pos h\n      add_left := by simp only [star_add, add_dotProduct, eq_self_iff_true, forall_const]\n      smul_left := fun x y r => by\n        simp only\n        rw [\u2190 smul_eq_mul, \u2190 smul_dotProduct, starRingEnd_apply, \u2190 star_smul] }", "start": [185, 1], "end": [205, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.InnerProductSpace.ofMatrix", "code": "def InnerProductSpace.ofMatrix {M : Matrix n n \ud835\udd5c} (hM : M.PosDef) :\n    @InnerProductSpace \ud835\udd5c (n \u2192 \ud835\udd5c) _ (NormedAddCommGroup.ofMatrix hM) :=\n  InnerProductSpace.ofCore _", "start": [208, 1], "end": [211, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Factorization.lean", "imports": ["Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/Data/Nat/Multiplicity.lean", "Mathlib/Data/Nat/Choose/Central.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.factorization_choose_le_log", "code": "theorem factorization_choose_le_log : (choose n k).factorization p \u2264 log p n", "start": [37, 1], "end": [47, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_factorization_choose_le", "code": "theorem pow_factorization_choose_le (hn : 0 < n) : p ^ (choose n k).factorization p \u2264 n", "start": [50, 1], "end": [52, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_choose_le_one", "code": "theorem factorization_choose_le_one (p_large : n < p ^ 2) : (choose n k).factorization p \u2264 1", "start": [55, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_choose_of_lt_three_mul", "code": "theorem factorization_choose_of_lt_three_mul (hp' : p \u2260 2) (hk : p \u2264 k) (hk' : p \u2264 n - k)\n    (hn : n < 3 * p) : (choose n k).factorization p = 0", "start": [63, 1], "end": [90, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_centralBinom_of_two_mul_self_lt_three_mul", "code": "theorem factorization_centralBinom_of_two_mul_self_lt_three_mul (n_big : 2 < n) (p_le_n : p \u2264 n)\n    (big : 2 * n < 3 * p) : (centralBinom n).factorization p = 0", "start": [93, 1], "end": [100, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_factorial_eq_zero_of_lt", "code": "theorem factorization_factorial_eq_zero_of_lt (h : n < p) : (factorial n).factorization p = 0", "start": [103, 1], "end": [106, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_choose_eq_zero_of_lt", "code": "theorem factorization_choose_eq_zero_of_lt (h : n < p) : (choose n k).factorization p = 0", "start": [109, 1], "end": [113, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_centralBinom_eq_zero_of_two_mul_lt", "code": "theorem factorization_centralBinom_eq_zero_of_two_mul_lt (h : 2 * n < p) :\n    (centralBinom n).factorization p = 0", "start": [116, 1], "end": [120, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.le_two_mul_of_factorization_centralBinom_pos", "code": "theorem le_two_mul_of_factorization_centralBinom_pos\n    (h_pos : 0 < (centralBinom n).factorization p) : p \u2264 2 * n", "start": [123, 1], "end": [126, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_pow_factorization_choose", "code": "theorem prod_pow_factorization_choose (n k : \u2115) (hkn : k \u2264 n) :\n    (\u220f p in Finset.range (n + 1), p ^ (Nat.choose n k).factorization p) = choose n k", "start": [129, 1], "end": [142, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_pow_factorization_centralBinom", "code": "theorem prod_pow_factorization_centralBinom (n : \u2115) :\n    (\u220f p in Finset.range (2 * n + 1), p ^ (centralBinom n).factorization p) = centralBinom n", "start": [145, 1], "end": [150, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Primorial.lean", "imports": ["Mathlib/Data/Nat/Prime.lean", "Mathlib/Data/Nat/Choose/Dvd.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Associated.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "primorial", "code": "def primorial (n : \u2115) : \u2115 :=\n  \u220f p in filter Nat.Prime (range (n + 1)), p", "start": [33, 1], "end": [36, 45], "kind": "commanddeclaration"}, {"full_name": "primorial_pos", "code": "theorem primorial_pos (n : \u2115) : 0 < n#", "start": [42, 1], "end": [43, 47], "kind": "commanddeclaration"}, {"full_name": "primorial_succ", "code": "theorem primorial_succ {n : \u2115} (hn1 : n \u2260 1) (hn : Odd n) : (n + 1)# = n#", "start": [46, 1], "end": [49, 50], "kind": "commanddeclaration"}, {"full_name": "primorial_add", "code": "theorem primorial_add (m n : \u2115) :\n    (m + n)# = m# * \u220f p in filter Nat.Prime (Ico (m + 1) (m + n + 1)), p", "start": [52, 1], "end": [56, 66], "kind": "commanddeclaration"}, {"full_name": "primorial_add_dvd", "code": "theorem primorial_add_dvd {m n : \u2115} (h : n \u2264 m) : (m + n)# \u2223 m# * choose (m + n) m", "start": [59, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "primorial_add_le", "code": "theorem primorial_add_le {m n : \u2115} (h : n \u2264 m) : (m + n)# \u2264 m# * choose (m + n) m", "start": [70, 1], "end": [71, 99], "kind": "commanddeclaration"}, {"full_name": "primorial_le_4_pow", "code": "theorem primorial_le_4_pow (n : \u2115) : n# \u2264 4 ^ n", "start": [74, 1], "end": [92, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SetFamily/Shadow.lean", "imports": ["Mathlib/Logic/Function/Iterate.lean", "Mathlib/Data/Finset/Slice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.shadow", "code": "def shadow (\ud835\udc9c : Finset (Finset \u03b1)) : Finset (Finset \u03b1) :=\n  \ud835\udc9c.sup fun s => s.image (erase s)", "start": [56, 1], "end": [60, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.shadow_empty", "code": "@[simp]\ntheorem shadow_empty : \u2202 (\u2205 : Finset (Finset \u03b1)) = \u2205", "start": [68, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.shadow_singleton_empty", "code": "@[simp]\ntheorem shadow_singleton_empty : \u2202 ({\u2205} : Finset (Finset \u03b1)) = \u2205", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.shadow_monotone", "code": "@[mono]\ntheorem shadow_monotone : Monotone (shadow : Finset (Finset \u03b1) \u2192 Finset (Finset \u03b1))", "start": [80, 1], "end": [83, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_shadow_iff", "code": "theorem mem_shadow_iff : s \u2208 \u2202 \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, \u2203 a \u2208 t, erase t a = s", "start": [86, 1], "end": [89, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_mem_shadow", "code": "theorem erase_mem_shadow (hs : s \u2208 \ud835\udc9c) (ha : a \u2208 s) : erase s a \u2208 \u2202 \ud835\udc9c", "start": [92, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_shadow_iff_insert_mem", "code": "theorem mem_shadow_iff_insert_mem : s \u2208 \u2202 \ud835\udc9c \u2194 \u2203 (a : _) (_ : a \u2209 s), insert a s \u2208 \ud835\udc9c", "start": [96, 1], "end": [104, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.Set.Sized.shadow", "code": "protected theorem Set.Sized.shadow (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    (\u2202 \ud835\udc9c : Set (Finset \u03b1)).Sized (r - 1)", "start": [107, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sized_shadow_iff", "code": "theorem sized_shadow_iff (h : \u2205 \u2209 \ud835\udc9c) :\n    (\u2202 \ud835\udc9c : Set (Finset \u03b1)).Sized r \u2194 (\ud835\udc9c : Set (Finset \u03b1)).Sized (r + 1)", "start": [115, 1], "end": [119, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_shadow_iff_exists_mem_card_add_one", "code": "theorem mem_shadow_iff_exists_mem_card_add_one :\n    s \u2208 \u2202 \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, s \u2286 t \u2227 t.card = s.card + 1", "start": [122, 1], "end": [133, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_subset_of_mem_shadow", "code": "theorem exists_subset_of_mem_shadow (hs : s \u2208 \u2202 \ud835\udc9c) : \u2203 t \u2208 \ud835\udc9c, s \u2286 t", "start": [136, 1], "end": [139, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_shadow_iff_exists_mem_card_add", "code": "theorem mem_shadow_iff_exists_mem_card_add :\n    s \u2208 \u2202 ^[k] \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, s \u2286 t \u2227 t.card = s.card + k", "start": [142, 1], "end": [168, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.upShadow", "code": "def upShadow (\ud835\udc9c : Finset (Finset \u03b1)) : Finset (Finset \u03b1) :=\n  \ud835\udc9c.sup fun s => s\u1d9c.image fun a => insert a s", "start": [179, 1], "end": [183, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.upShadow_empty", "code": "@[simp]\ntheorem upShadow_empty : \u2202\u207a (\u2205 : Finset (Finset \u03b1)) = \u2205", "start": [189, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.upShadow_monotone", "code": "@[mono]\ntheorem upShadow_monotone : Monotone (upShadow : Finset (Finset \u03b1) \u2192 Finset (Finset \u03b1))", "start": [195, 1], "end": [198, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_upShadow_iff", "code": "theorem mem_upShadow_iff : s \u2208 \u2202\u207a \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, \u2203 (a : _) (_ : a \u2209 t), insert a t = s", "start": [201, 1], "end": [204, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_mem_upShadow", "code": "theorem insert_mem_upShadow (hs : s \u2208 \ud835\udc9c) (ha : a \u2209 s) : insert a s \u2208 \u2202\u207a \ud835\udc9c", "start": [207, 1], "end": [208, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.Set.Sized.upShadow", "code": "protected theorem Set.Sized.upShadow (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    (\u2202\u207a \ud835\udc9c : Set (Finset \u03b1)).Sized (r + 1)", "start": [211, 1], "end": [216, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_upShadow_iff_erase_mem", "code": "theorem mem_upShadow_iff_erase_mem : s \u2208 \u2202\u207a \ud835\udc9c \u2194 \u2203 a \u2208 s, s.erase a \u2208 \ud835\udc9c", "start": [219, 1], "end": [227, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_upShadow_iff_exists_mem_card_add_one", "code": "theorem mem_upShadow_iff_exists_mem_card_add_one :\n    s \u2208 \u2202\u207a \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, t \u2286 s \u2227 t.card + 1 = s.card", "start": [230, 1], "end": [240, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_subset_of_mem_upShadow", "code": "theorem exists_subset_of_mem_upShadow (hs : s \u2208 \u2202\u207a \ud835\udc9c) : \u2203 t \u2208 \ud835\udc9c, t \u2286 s", "start": [243, 1], "end": [246, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_upShadow_iff_exists_mem_card_add", "code": "theorem mem_upShadow_iff_exists_mem_card_add :\n    s \u2208 \u2202\u207a ^[k] \ud835\udc9c \u2194 \u2203 t \u2208 \ud835\udc9c, t \u2286 s \u2227 t.card + k = s.card", "start": [249, 1], "end": [275, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.shadow_image_compl", "code": "@[simp]\ntheorem shadow_image_compl : (\u2202 \ud835\udc9c).image compl = \u2202\u207a (\ud835\udc9c.image compl)", "start": [278, 1], "end": [286, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.upShadow_image_compl", "code": "@[simp]\ntheorem upShadow_image_compl : (\u2202\u207a \ud835\udc9c).image compl = \u2202 (\ud835\udc9c.image compl)", "start": [289, 1], "end": [297, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/CondDistrib.lean", "imports": ["Mathlib/Probability/Notation.lean", "Mathlib/Probability/Kernel/Disintegration.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.condDistrib", "code": "noncomputable irreducible_def condDistrib {_ : MeasurableSpace \u03b1} [MeasurableSpace \u03b2] (Y : \u03b1 \u2192 \u03a9)\n    (X : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] : kernel \u03b2 \u03a9 :=\n  (\u03bc.map fun a => (X a, Y a)).condKernel", "start": [56, 1], "end": [64, 41], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "ProbabilityTheory.measurable_condDistrib", "code": "theorem measurable_condDistrib (hs : MeasurableSet s) :\n    Measurable[m\u03b2.comap X] fun a => condDistrib Y X \u03bc (X a) s", "start": [74, 1], "end": [76, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.ae_integrable_condDistrib_map_iff", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.ae_integrable_condDistrib_map_iff\n    (hY : AEMeasurable Y \u03bc) (hf : AEStronglyMeasurable f (\u03bc.map fun a => (X a, Y a))) :\n    (\u2200\u1d50 a \u2202\u03bc.map X, Integrable (fun \u03c9 => f (a, \u03c9)) (condDistrib Y X \u03bc a)) \u2227\n      Integrable (fun a => \u222b \u03c9, \u2016f (a, \u03c9)\u2016 \u2202condDistrib Y X \u03bc a) (\u03bc.map X) \u2194\n    Integrable f (\u03bc.map fun a => (X a, Y a))", "start": [79, 1], "end": [84, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integral_condDistrib_map", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condDistrib_map\n    (hY : AEMeasurable Y \u03bc) (hf : AEStronglyMeasurable f (\u03bc.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable (fun x => \u222b y, f (x, y) \u2202condDistrib Y X \u03bc x) (\u03bc.map X)", "start": [89, 1], "end": [92, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integral_condDistrib", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condDistrib (hX : AEMeasurable X \u03bc)\n    (hY : AEMeasurable Y \u03bc) (hf : AEStronglyMeasurable f (\u03bc.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable (fun a => \u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)) \u03bc", "start": [95, 1], "end": [98, 56], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.aestronglyMeasurable'_integral_condDistrib", "code": "theorem aestronglyMeasurable'_integral_condDistrib (hX : AEMeasurable X \u03bc) (hY : AEMeasurable Y \u03bc)\n    (hf : AEStronglyMeasurable f (\u03bc.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable' (m\u03b2.comap X) (fun a => \u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)) \u03bc", "start": [101, 1], "end": [104, 58], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condDistrib_ae_eq_of_measure_eq_compProd", "code": "theorem condDistrib_ae_eq_of_measure_eq_compProd (hX : Measurable X) (hY : Measurable Y)\n    (\u03ba : kernel \u03b2 \u03a9) [IsFiniteKernel \u03ba]\n    (h\u03ba : \u03bc.map (fun x => (X x, Y x)) =\n      (kernel.const Unit (\u03bc.map X) \u2297\u2096 kernel.prodMkLeft Unit \u03ba) ()) :\n    \u2200\u1d50 x \u2202\u03bc.map X, \u03ba x = condDistrib Y X \u03bc x", "start": [109, 1], "end": [123, 17], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_toReal_condDistrib", "code": "theorem integrable_toReal_condDistrib (hX : AEMeasurable X \u03bc) (hs : MeasurableSet s) :\n    Integrable (fun a => (condDistrib Y X \u03bc (X a) s).toReal) \u03bc", "start": [127, 1], "end": [135, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.condDistrib_ae_map", "code": "theorem _root_.MeasureTheory.Integrable.condDistrib_ae_map\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    \u2200\u1d50 b \u2202\u03bc.map X, Integrable (fun \u03c9 => f (b, \u03c9)) (condDistrib Y X \u03bc b)", "start": [138, 1], "end": [141, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.condDistrib_ae", "code": "theorem _root_.MeasureTheory.Integrable.condDistrib_ae (hX : AEMeasurable X \u03bc)\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    \u2200\u1d50 a \u2202\u03bc, Integrable (fun \u03c9 => f (X a, \u03c9)) (condDistrib Y X \u03bc (X a))", "start": [144, 1], "end": [147, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_norm_condDistrib_map", "code": "theorem _root_.MeasureTheory.Integrable.integral_norm_condDistrib_map\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202condDistrib Y X \u03bc x) (\u03bc.map X)", "start": [150, 1], "end": [153, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_norm_condDistrib", "code": "theorem _root_.MeasureTheory.Integrable.integral_norm_condDistrib (hX : AEMeasurable X \u03bc)\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun a => \u222b y, \u2016f (X a, y)\u2016 \u2202condDistrib Y X \u03bc (X a)) \u03bc", "start": [156, 1], "end": [159, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.norm_integral_condDistrib_map", "code": "theorem _root_.MeasureTheory.Integrable.norm_integral_condDistrib_map\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun x => \u2016\u222b y, f (x, y) \u2202condDistrib Y X \u03bc x\u2016) (\u03bc.map X)", "start": [164, 1], "end": [167, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.norm_integral_condDistrib", "code": "theorem _root_.MeasureTheory.Integrable.norm_integral_condDistrib (hX : AEMeasurable X \u03bc)\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun a => \u2016\u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)\u2016) \u03bc", "start": [170, 1], "end": [173, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_condDistrib_map", "code": "theorem _root_.MeasureTheory.Integrable.integral_condDistrib_map\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun x => \u222b y, f (x, y) \u2202condDistrib Y X \u03bc x) (\u03bc.map X)", "start": [176, 1], "end": [180, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_condDistrib", "code": "theorem _root_.MeasureTheory.Integrable.integral_condDistrib (hX : AEMeasurable X \u03bc)\n    (hY : AEMeasurable Y \u03bc) (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    Integrable (fun a => \u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)) \u03bc", "start": [183, 1], "end": [186, 60], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_preimage_condDistrib", "code": "theorem set_lintegral_preimage_condDistrib (hX : Measurable X) (hY : AEMeasurable Y \u03bc)\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    \u222b\u207b a in X \u207b\u00b9' t, condDistrib Y X \u03bc (X a) s \u2202\u03bc = \u03bc (X \u207b\u00b9' t \u2229 Y \u207b\u00b9' s)", "start": [191, 1], "end": [199, 99], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condDistrib_of_measurableSet", "code": "theorem set_lintegral_condDistrib_of_measurableSet (hX : Measurable X) (hY : AEMeasurable Y \u03bc)\n    (hs : MeasurableSet s) {t : Set \u03b1} (ht : MeasurableSet[m\u03b2.comap X] t) :\n    \u222b\u207b a in t, condDistrib Y X \u03bc (X a) s \u2202\u03bc = \u03bc (t \u2229 Y \u207b\u00b9' s)", "start": [202, 1], "end": [206, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condDistrib_ae_eq_condexp", "code": "theorem condDistrib_ae_eq_condexp (hX : Measurable X) (hY : Measurable Y) (hs : MeasurableSet s) :\n    (fun a => (condDistrib Y X \u03bc (X a) s).toReal) =\u1d50[\u03bc] \u03bc\u27e6Y \u207b\u00b9' s|m\u03b2.comap X\u27e7", "start": [209, 1], "end": [222, 82], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib'", "code": "theorem condexp_prod_ae_eq_integral_condDistrib' [NormedSpace \u211d F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y \u03bc)\n    (hf_int : Integrable f (\u03bc.map fun a => (X a, Y a))) :\n    \u03bc[fun a => f (X a, Y a)|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, f (X a,y) \u2202condDistrib Y X \u03bc (X a)", "start": [225, 1], "end": [247, 81], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib\u2080", "code": "theorem condexp_prod_ae_eq_integral_condDistrib\u2080 [NormedSpace \u211d F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y \u03bc)\n    (hf : AEStronglyMeasurable f (\u03bc.map fun a => (X a, Y a)))\n    (hf_int : Integrable (fun a => f (X a, Y a)) \u03bc) :\n    \u03bc[fun a => f (X a, Y a)|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)", "start": [250, 1], "end": [259, 57], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib", "code": "theorem condexp_prod_ae_eq_integral_condDistrib [NormedSpace \u211d F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y \u03bc) (hf : StronglyMeasurable f)\n    (hf_int : Integrable (fun a => f (X a, Y a)) \u03bc) :\n    \u03bc[fun a => f (X a, Y a)|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, f (X a, y) \u2202condDistrib Y X \u03bc (X a)", "start": [262, 1], "end": [270, 57], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_ae_eq_integral_condDistrib", "code": "theorem condexp_ae_eq_integral_condDistrib [NormedSpace \u211d F] [CompleteSpace F] (hX : Measurable X)\n    (hY : AEMeasurable Y \u03bc) {f : \u03a9 \u2192 F} (hf : StronglyMeasurable f)\n    (hf_int : Integrable (fun a => f (Y a)) \u03bc) :\n    \u03bc[fun a => f (Y a)|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, f y \u2202condDistrib Y X \u03bc (X a)", "start": [273, 1], "end": [277, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_ae_eq_integral_condDistrib'", "code": "theorem condexp_ae_eq_integral_condDistrib' {\u03a9} [NormedAddCommGroup \u03a9] [NormedSpace \u211d \u03a9]\n    [CompleteSpace \u03a9] [MeasurableSpace \u03a9] [BorelSpace \u03a9] [SecondCountableTopology \u03a9] {Y : \u03b1 \u2192 \u03a9}\n    (hX : Measurable X) (hY_int : Integrable Y \u03bc) :\n    \u03bc[Y|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, y \u2202condDistrib Y X \u03bc (X a)", "start": [280, 1], "end": [286, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_mk", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_mk\n    {\u03a9 F} {m\u03a9 : MeasurableSpace \u03a9} (X : \u03a9 \u2192 \u03b2) {\u03bc : Measure \u03a9} [TopologicalSpace F] {f : \u03a9 \u2192 F}\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x : \u03b2 \u00d7 \u03a9 => f x.2) (\u03bc.map fun \u03c9 => (X \u03c9, \u03c9))", "start": [291, 1], "end": [309, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.comp_snd_map_prod_mk", "code": "theorem _root_.MeasureTheory.Integrable.comp_snd_map_prod_mk\n    {\u03a9} {m\u03a9 : MeasurableSpace \u03a9} (X : \u03a9 \u2192 \u03b2) {\u03bc : Measure \u03a9} {f : \u03a9 \u2192 F} (hf_int : Integrable f \u03bc) :\n    Integrable (fun x : \u03b2 \u00d7 \u03a9 => f x.2) (\u03bc.map fun \u03c9 => (X \u03c9, \u03c9))", "start": [312, 1], "end": [322, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.aestronglyMeasurable_comp_snd_map_prod_mk_iff", "code": "theorem aestronglyMeasurable_comp_snd_map_prod_mk_iff {\u03a9 F} {_ : MeasurableSpace \u03a9}\n    [TopologicalSpace F] {X : \u03a9 \u2192 \u03b2} {\u03bc : Measure \u03a9} (hX : Measurable X) {f : \u03a9 \u2192 F} :\n    AEStronglyMeasurable (fun x : \u03b2 \u00d7 \u03a9 => f x.2) (\u03bc.map fun \u03c9 => (X \u03c9, \u03c9)) \u2194\n    AEStronglyMeasurable f \u03bc", "start": [325, 1], "end": [329, 93], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_comp_snd_map_prod_mk_iff", "code": "theorem integrable_comp_snd_map_prod_mk_iff {\u03a9} {_ : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u03b2} {\u03bc : Measure \u03a9}\n    (hX : Measurable X) {f : \u03a9 \u2192 F} :\n    Integrable (fun x : \u03b2 \u00d7 \u03a9 => f x.2) (\u03bc.map fun \u03c9 => (X \u03c9, \u03c9)) \u2194 Integrable f \u03bc", "start": [332, 1], "end": [335, 93], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condexp_ae_eq_integral_condDistrib_id", "code": "theorem condexp_ae_eq_integral_condDistrib_id [NormedSpace \u211d F] [CompleteSpace F] {X : \u03a9 \u2192 \u03b2}\n    {\u03bc : Measure \u03a9} [IsFiniteMeasure \u03bc] (hX : Measurable X) {f : \u03a9 \u2192 F} (hf_int : Integrable f \u03bc) :\n    \u03bc[f|m\u03b2.comap X] =\u1d50[\u03bc] fun a => \u222b y, f y \u2202condDistrib id X \u03bc (X a)", "start": [338, 1], "end": [341, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Algebra/Ring/FreeCommRing.lean", "imports": ["Mathlib/RingTheory/FreeCommRing.lean", "Mathlib/ModelTheory/Algebra/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Ring.exists_term_realize_eq_freeCommRing", "code": "private theorem exists_term_realize_eq_freeCommRing (p : FreeCommRing \u03b1) :\n    \u2203 t : Language.ring.Term \u03b1,\n      (t.realize FreeCommRing.of : FreeCommRing \u03b1) = p", "start": [34, 1], "end": [43, 45], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.termOfFreeCommRing", "code": "noncomputable def termOfFreeCommRing (p : FreeCommRing \u03b1) : Language.ring.Term \u03b1 :=\n  Classical.choose (exists_term_realize_eq_freeCommRing p)", "start": [47, 1], "end": [49, 59], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_termOfFreeCommRing", "code": "@[simp]\ntheorem realize_termOfFreeCommRing (p : FreeCommRing \u03b1) (v : \u03b1 \u2192 R) :\n    (termOfFreeCommRing p).realize v = FreeCommRing.lift v p", "start": [53, 1], "end": [63, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Algebra/Field/Basic.lean", "imports": ["Mathlib/ModelTheory/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Field/MinimalAxioms.lean", "Mathlib/ModelTheory/Algebra/Ring/Basic.lean", "Mathlib/ModelTheory/Semantics.lean"], "premises": [{"full_name": "FirstOrder.Field.FieldAxiom", "code": "inductive FieldAxiom : Type\n  | addAssoc : FieldAxiom\n  | zeroAdd : FieldAxiom\n  | addLeftNeg : FieldAxiom\n  | mulAssoc : FieldAxiom\n  | mulComm : FieldAxiom\n  | oneMul : FieldAxiom\n  | existsInv : FieldAxiom\n  | leftDistrib : FieldAxiom\n  | existsPairNe : FieldAxiom", "start": [36, 1], "end": [48, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.FieldAxiom.toSentence", "code": "@[simp]\ndef FieldAxiom.toSentence : FieldAxiom \u2192 Language.ring.Sentence\n  | .addAssoc => \u2200' \u2200' \u2200' (((&0 + &1) + &2) =' (&0 + (&1 + &2)))\n  | .zeroAdd => \u2200' (((0 : Language.ring.Term _) + &0) =' &0)\n  | .addLeftNeg => \u2200' \u2200' ((-&0 + &0) =' 0)\n  | .mulAssoc => \u2200' \u2200' \u2200' (((&0 * &1) * &2) =' (&0 * (&1 * &2)))\n  | .mulComm => \u2200' \u2200' ((&0 * &1) =' (&1 * &0))\n  | .oneMul => \u2200' (((1 : Language.ring.Term _) * &0) =' &0)\n  | .existsInv => \u2200' (\u223c(&0 =' 0) \u27f9 \u2203' ((&0 * &1) =' 1))\n  | .leftDistrib => \u2200' \u2200' \u2200' ((&0 * (&1 + &2)) =' ((&0 * &1) + (&0 * &2)))\n  | .existsPairNe => \u2203' \u2203' (\u223c(&0 =' &1))", "start": [50, 1], "end": [61, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.FieldAxiom.toProp", "code": "@[simp]\ndef FieldAxiom.toProp (K : Type*) [Add K] [Mul K] [Neg K] [Zero K] [One K] :\n    FieldAxiom \u2192 Prop\n  | .addAssoc => \u2200 x y z : K, (x + y) + z = x + (y + z)\n  | .zeroAdd => \u2200 x : K, 0 + x = x\n  | .addLeftNeg => \u2200 x : K, -x + x = 0\n  | .mulAssoc => \u2200 x y z : K, (x * y) * z = x * (y * z)\n  | .mulComm => \u2200 x y : K, x * y = y * x\n  | .oneMul => \u2200 x : K, 1 * x = x\n  | .existsInv => \u2200 x : K, x \u2260 0 \u2192 \u2203 y, x * y = 1\n  | .leftDistrib => \u2200 x y z : K, x * (y + z) = x * y + x * z\n  | .existsPairNe => \u2203 x y : K, x \u2260 y", "start": [63, 1], "end": [75, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.field", "code": "def _root_.FirstOrder.Language.Theory.field : Language.ring.Theory :=\n  Set.range FieldAxiom.toSentence", "start": [77, 1], "end": [79, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.FieldAxiom.realize_toSentence_iff_toProp", "code": "theorem FieldAxiom.realize_toSentence_iff_toProp {K : Type*}\n    [Add K] [Mul K] [Neg K] [Zero K] [One K] [CompatibleRing K]\n    (ax : FieldAxiom) :\n    (K \u22a8 (ax.toSentence : Sentence Language.ring)) \u2194 ax.toProp K", "start": [81, 1], "end": [86, 53], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.FieldAxiom.toProp_of_model", "code": "theorem FieldAxiom.toProp_of_model {K : Type*}\n    [Add K] [Mul K] [Neg K] [Zero K] [One K] [CompatibleRing K]\n    [Theory.field.Model K] (ax : FieldAxiom) : ax.toProp K", "start": [88, 1], "end": [93, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.fieldOfModelField", "code": "@[reducible]\nnoncomputable def fieldOfModelField (K : Type*) [Language.ring.Structure K]\n    [Theory.field.Model K] : Field K :=\n  letI : DecidableEq K := Classical.decEq K\n  letI := addOfRingStructure K\n  letI := mulOfRingStructure K\n  letI := negOfRingStructure K\n  letI := zeroOfRingStructure K\n  letI := oneOfRingStructure K\n  letI := compatibleRingOfRingStructure K\n  have exists_inv : \u2200 x : K, x \u2260 0 \u2192 \u2203 y : K, x * y = 1 :=\n    existsInv.toProp_of_model\n  letI : Inv K := \u27e8fun x => if hx0 : x = 0 then 0 else Classical.choose (exists_inv x hx0)\u27e9\n  Field.ofMinimalAxioms K\n    addAssoc.toProp_of_model\n    zeroAdd.toProp_of_model\n    addLeftNeg.toProp_of_model\n    mulAssoc.toProp_of_model\n    mulComm.toProp_of_model\n    oneMul.toProp_of_model\n    (fun x hx0 => show x * (dite _ _ _) = _ from\n        (dif_neg hx0).symm \u25b8 Classical.choose_spec (existsInv.toProp_of_model x hx0))\n    (dif_pos rfl)\n    leftDistrib.toProp_of_model\n    existsPairNe.toProp_of_model", "start": [97, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Field.compatibleRingOfModelField", "code": "@[reducible]\nnoncomputable def compatibleRingOfModelField (K : Type*) [Language.ring.Structure K]\n    [Theory.field.Model K] : CompatibleRing K :=\n  compatibleRingOfRingStructure K", "start": [132, 1], "end": [141, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/WeaklyInitial.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.has_weakly_initial_of_weakly_initial_set_and_hasProducts", "code": "theorem has_weakly_initial_of_weakly_initial_set_and_hasProducts [HasProducts.{v} C] {\u03b9 : Type v}\n    {B : \u03b9 \u2192 C} (hB : \u2200 A : C, \u2203 i, Nonempty (B i \u27f6 A)) : \u2203 T : C, \u2200 X, Nonempty (T \u27f6 X)", "start": [32, 1], "end": [38, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasInitial_of_weakly_initial_and_hasWideEqualizers", "code": "theorem hasInitial_of_weakly_initial_and_hasWideEqualizers [HasWideEqualizers.{v} C] {T : C}\n    (hT : \u2200 X, Nonempty (T \u27f6 X)) : HasInitial C", "start": [41, 1], "end": [64, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Subobject/Comma.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Finite.lean", "Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "Mathlib/CategoryTheory/Subobject/WellPowered.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.StructuredArrow.projectSubobject", "code": "def projectSubobject [HasLimits C] [PreservesLimits T] {A : StructuredArrow S T} :\n    Subobject A \u2192 Subobject A.right := by\n  refine' Subobject.lift (fun P f hf => Subobject.mk f.right) _\n  intro P Q f g hf hg i hi\n  refine' Subobject.mk_eq_mk_of_comm _ _ ((proj S T).mapIso i) _\n  exact congr_arg CommaMorphism.right hi", "start": [47, 1], "end": [54, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.projectSubobject_mk", "code": "@[simp]\ntheorem projectSubobject_mk [HasLimits C] [PreservesLimits T] {A P : StructuredArrow S T}\n    (f : P \u27f6 A) [Mono f] : projectSubobject (Subobject.mk f) = Subobject.mk f.right", "start": [57, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.projectSubobject_factors", "code": "theorem projectSubobject_factors [HasLimits C] [PreservesLimits T] {A : StructuredArrow S T} :\n    \u2200 P : Subobject A, \u2203 q, q \u226b T.map (projectSubobject P).arrow = A.hom", "start": [63, 1], "end": [68, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.liftSubobject", "code": "@[simp]\ndef liftSubobject {A : StructuredArrow S T} (P : Subobject A.right) {q}\n    (hq : q \u226b T.map P.arrow = A.hom) : Subobject A :=\n  Subobject.mk (homMk P.arrow hq : mk q \u27f6 A)", "start": [71, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.lift_projectSubobject", "code": "theorem lift_projectSubobject [HasLimits C] [PreservesLimits T] {A : StructuredArrow S T} :\n    \u2200 (P : Subobject A) {q} (hq : q \u226b T.map (projectSubobject P).arrow = A.hom),\n      liftSubobject (projectSubobject P) hq = P", "start": [80, 1], "end": [92, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.subobjectEquiv", "code": "@[simps!]\ndef subobjectEquiv [HasLimits C] [PreservesLimits T] (A : StructuredArrow S T) :\n    Subobject A \u2243o { P : Subobject A.right // \u2203 q, q \u226b T.map P.arrow = A.hom } where\n  toFun P := \u27e8projectSubobject P, projectSubobject_factors P\u27e9\n  invFun P := liftSubobject P.val P.prop.choose_spec\n  left_inv P := lift_projectSubobject _ _\n  right_inv P := Subtype.ext (by simp only [liftSubobject, homMk_right, projectSubobject_mk,\n      Subobject.mk_arrow, Subtype.coe_eta])\n  map_rel_iff' := by\n    apply Subobject.ind\u2082\n    intro P Q f g hf hg\n    refine' \u27e8fun h => Subobject.mk_le_mk_of_comm _ _, fun h => _\u27e9\n    \u00b7 exact homMk (Subobject.ofMkLEMk _ _ h)\n        ((cancel_mono (T.map g.right)).1 (by simp [\u2190 T.map_comp]))\n    \u00b7 aesop_cat\n    \u00b7 refine' Subobject.mk_le_mk_of_comm (Subobject.ofMkLEMk _ _ h).right _\n      exact congr_arg CommaMorphism.right (Subobject.ofMkLEMk_comp h)", "start": [95, 1], "end": [114, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.wellPowered_structuredArrow", "code": "instance wellPowered_structuredArrow [WellPowered C] [HasLimits C] [PreservesLimits T] :\n    WellPowered (StructuredArrow S T) where\n  subobject_small X := small_map (subobjectEquiv X).toEquiv", "start": [121, 1], "end": [125, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.projectQuotient", "code": "def projectQuotient [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    Subobject (op A) \u2192 Subobject (op A.left) := by\n  refine' Subobject.lift (fun P f hf => Subobject.mk f.unop.left.op) _\n  intro P Q f g hf hg i hi\n  refine' Subobject.mk_eq_mk_of_comm _ _ ((proj S T).mapIso i.unop).op (Quiver.Hom.unop_inj _)\n  have := congr_arg Quiver.Hom.unop hi\n  simpa using congr_arg CommaMorphism.left this", "start": [134, 1], "end": [142, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.projectQuotient_mk", "code": "@[simp]\ntheorem projectQuotient_mk [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)\u1d52\u1d56} (f : P \u27f6 op A) [Mono f] :\n    projectQuotient (Subobject.mk f) = Subobject.mk f.unop.left.op", "start": [145, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.projectQuotient_factors", "code": "theorem projectQuotient_factors [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    \u2200 P : Subobject (op A), \u2203 q, S.map (projectQuotient P).arrow.unop \u226b q = A.hom", "start": [152, 1], "end": [158, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.liftQuotient", "code": "@[simp]\ndef liftQuotient {A : CostructuredArrow S T} (P : Subobject (op A.left)) {q}\n    (hq : S.map P.arrow.unop \u226b q = A.hom) : Subobject (op A) :=\n  Subobject.mk (homMk P.arrow.unop hq : A \u27f6 mk q).op", "start": [161, 1], "end": [167, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.unop_left_comp_underlyingIso_hom_unop", "code": "@[simp]\ntheorem unop_left_comp_underlyingIso_hom_unop {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)\u1d52\u1d56} (f : P \u27f6 op A) [Mono f.unop.left.op] :\n    f.unop.left \u226b (Subobject.underlyingIso f.unop.left.op).hom.unop =\n      (Subobject.mk f.unop.left.op).arrow.unop", "start": [170, 1], "end": [179, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.lift_projectQuotient", "code": "theorem lift_projectQuotient [HasColimits C] [PreservesColimits S] {A : CostructuredArrow S T} :\n    \u2200 (P : Subobject (op A)) {q} (hq : S.map (projectQuotient P).arrow.unop \u226b q = A.hom),\n      liftQuotient (projectQuotient P) hq = P", "start": [182, 1], "end": [195, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.unop_left_comp_ofMkLEMk_unop", "code": "theorem unop_left_comp_ofMkLEMk_unop {A : CostructuredArrow S T} {P Q : (CostructuredArrow S T)\u1d52\u1d56}\n    {f : P \u27f6 op A} {g : Q \u27f6 op A} [Mono f.unop.left.op] [Mono g.unop.left.op]\n    (h : Subobject.mk f.unop.left.op \u2264 Subobject.mk g.unop.left.op) :\n    g.unop.left \u226b (Subobject.ofMkLEMk f.unop.left.op g.unop.left.op h).unop = f.unop.left", "start": [198, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.quotientEquiv", "code": "def quotientEquiv [HasColimits C] [PreservesColimits S] (A : CostructuredArrow S T) :\n    Subobject (op A) \u2243o { P : Subobject (op A.left) // \u2203 q, S.map P.arrow.unop \u226b q = A.hom } where\n  toFun P := \u27e8projectQuotient P, projectQuotient_factors P\u27e9\n  invFun P := liftQuotient P.val P.prop.choose_spec\n  left_inv P := lift_projectQuotient _ _\n  right_inv P := Subtype.ext (by simp only [liftQuotient, Quiver.Hom.unop_op, homMk_left,\n      Quiver.Hom.op_unop, projectQuotient_mk, Subobject.mk_arrow])\n  map_rel_iff' := by\n    apply Subobject.ind\u2082\n    intro P Q f g hf hg\n    refine' \u27e8fun h => Subobject.mk_le_mk_of_comm _ _, fun h => _\u27e9\n    \u00b7 refine' (homMk (Subobject.ofMkLEMk _ _ h).unop ((cancel_epi (S.map g.unop.left)).1 _)).op\n      dsimp\n      simp only [\u2190 S.map_comp_assoc, unop_left_comp_ofMkLEMk_unop, unop_op, CommaMorphism.w,\n        Functor.const_obj_obj, right_eq_id, Functor.const_obj_map, Category.comp_id]\n    \u00b7 apply Quiver.Hom.unop_inj\n      ext\n      exact unop_left_comp_ofMkLEMk_unop _\n    \u00b7 refine' Subobject.mk_le_mk_of_comm (Subobject.ofMkLEMk _ _ h).unop.left.op _\n      refine' Quiver.Hom.unop_inj _\n      have := congr_arg Quiver.Hom.unop (Subobject.ofMkLEMk_comp h)\n      simpa only [unop_op, Functor.id_obj, Functor.const_obj_obj, MonoOver.mk'_obj, Over.mk_left,\n        MonoOver.mk'_arrow, unop_comp, Quiver.Hom.unop_op, comp_left]\n          using congr_arg CommaMorphism.left this", "start": [210, 1], "end": [236, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.well_copowered_costructuredArrow", "code": "instance well_copowered_costructuredArrow [WellPowered C\u1d52\u1d56] [HasColimits C] [PreservesColimits S] :\n    WellPowered (CostructuredArrow S T)\u1d52\u1d56 where\n  subobject_small X := small_map (quotientEquiv (unop X)).toEquiv", "start": [239, 1], "end": [243, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Taylor.lean", "imports": ["Mathlib/Data/Polynomial/HasseDeriv.lean", "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.taylor", "code": "def taylor (r : R) : R[X] \u2192\u2097[R] R[X] where\n  toFun f := f.comp (X + C r)\n  map_add' f g := add_comp\n  map_smul' c f := by simp only [smul_eq_C_mul, C_mul_comp, RingHom.id_apply]", "start": [34, 1], "end": [38, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_apply", "code": "theorem taylor_apply : taylor r f = f.comp (X + C r)", "start": [41, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_X", "code": "@[simp]\ntheorem taylor_X : taylor r X = X + C r", "start": [45, 1], "end": [46, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_C", "code": "@[simp]\ntheorem taylor_C (x : R) : taylor r (C x) = C x", "start": [50, 1], "end": [51, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_zero'", "code": "@[simp]\ntheorem taylor_zero' : taylor (0 : R) = LinearMap.id", "start": [55, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_zero", "code": "theorem taylor_zero (f : R[X]) : taylor 0 f = f", "start": [62, 1], "end": [62, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_one", "code": "@[simp]\ntheorem taylor_one : taylor r (1 : R[X]) = C 1", "start": [65, 1], "end": [66, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_monomial", "code": "@[simp]\ntheorem taylor_monomial (i : \u2115) (k : R) : taylor r (monomial i k) = C k * (X + C r) ^ i", "start": [69, 1], "end": [71, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_coeff", "code": "theorem taylor_coeff (n : \u2115) : (taylor r f).coeff n = (hasseDeriv n f).eval r", "start": [74, 1], "end": [84, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_coeff_zero", "code": "@[simp]\ntheorem taylor_coeff_zero : (taylor r f).coeff 0 = f.eval r", "start": [87, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_coeff_one", "code": "@[simp]\ntheorem taylor_coeff_one : (taylor r f).coeff 1 = f.derivative.eval r", "start": [92, 1], "end": [94, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_taylor", "code": "@[simp]\ntheorem natDegree_taylor (p : R[X]) (r : R) : natDegree (taylor r p) = natDegree p", "start": [97, 1], "end": [102, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_mul", "code": "@[simp]\ntheorem taylor_mul {R} [CommSemiring R] (r : R) (p q : R[X]) :\n    taylor r (p * q) = taylor r p * taylor r q", "start": [105, 1], "end": [107, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylorAlgHom", "code": "@[simps!]\ndef taylorAlgHom {R} [CommSemiring R] (r : R) : R[X] \u2192\u2090[R] R[X] :=\n  AlgHom.ofLinearMap (taylor r) (taylor_one r) (taylor_mul r)", "start": [110, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_taylor", "code": "theorem taylor_taylor {R} [CommSemiring R] (f : R[X]) (r s : R) :\n    taylor r (taylor s f) = taylor (r + s) f", "start": [116, 1], "end": [118, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_eval", "code": "theorem taylor_eval {R} [CommSemiring R] (r : R) (f : R[X]) (s : R) :\n    (taylor r f).eval s = f.eval (s + r)", "start": [121, 1], "end": [123, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_eval_sub", "code": "theorem taylor_eval_sub {R} [CommRing R] (r : R) (f : R[X]) (s : R) :\n    (taylor r f).eval (s - r) = f.eval s", "start": [126, 1], "end": [127, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.taylor_injective", "code": "theorem taylor_injective {R} [CommRing R] (r : R) : Function.Injective (taylor r)", "start": [130, 1], "end": [134, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_hasseDeriv_eq_zero", "code": "theorem eq_zero_of_hasseDeriv_eq_zero {R} [CommRing R] (f : R[X]) (r : R)\n    (h : \u2200 k, (hasseDeriv k f).eval r = 0) : f = 0", "start": [137, 1], "end": [142, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_taylor_eq", "code": "theorem sum_taylor_eq {R} [CommRing R] (f : R[X]) (r : R) :\n    ((taylor r f).sum fun i a => C a * (X - C r) ^ i) = f", "start": [145, 1], "end": [149, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Trace.lean", "Mathlib/LinearAlgebra/Matrix/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean"], "premises": [{"full_name": "Matrix.IsAdjMatrix", "code": "structure IsAdjMatrix [Zero \u03b1] [One \u03b1] (A : Matrix V V \u03b1) : Prop where\n  zero_or_one : \u2200 i j, A i j = 0 \u2228 A i j = 1 := by aesop\n  symm : A.IsSymm := by aesop\n  apply_diag : \u2200 i, A i i = 0 := by aesop", "start": [49, 1], "end": [56, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.apply_diag_ne", "code": "@[simp]\ntheorem apply_diag_ne [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (h : IsAdjMatrix A) (i : V) : \u00acA i i = 1", "start": [63, 1], "end": [65, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.apply_ne_one_iff", "code": "@[simp]\ntheorem apply_ne_one_iff [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (h : IsAdjMatrix A) (i j : V) :\n    \u00acA i j = 1 \u2194 A i j = 0", "start": [68, 1], "end": [70, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.apply_ne_zero_iff", "code": "@[simp]\ntheorem apply_ne_zero_iff [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (h : IsAdjMatrix A) (i j : V) :\n    \u00acA i j = 0 \u2194 A i j = 1", "start": [73, 1], "end": [75, 78], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.toGraph", "code": "@[simps]\ndef toGraph [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (h : IsAdjMatrix A) : SimpleGraph V where\n  Adj i j := A i j = 1\n  symm i j hij := by simp only; rwa [h.symm.apply i j]\n  loopless i := by simp [h]", "start": [78, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.compl", "code": "def compl [Zero \u03b1] [One \u03b1] [DecidableEq \u03b1] [DecidableEq V] (A : Matrix V V \u03b1) : Matrix V V \u03b1 :=\n  fun i j => ite (i = j) 0 (ite (A i j = 0) 1 0)", "start": [94, 1], "end": [97, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.compl_apply_diag", "code": "@[simp]\ntheorem compl_apply_diag [Zero \u03b1] [One \u03b1] (i : V) : A.compl i i = 0", "start": [104, 1], "end": [105, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.compl_apply", "code": "@[simp]\ntheorem compl_apply [Zero \u03b1] [One \u03b1] (i j : V) : A.compl i j = 0 \u2228 A.compl i j = 1", "start": [108, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.isSymm_compl", "code": "@[simp]\ntheorem isSymm_compl [Zero \u03b1] [One \u03b1] (h : A.IsSymm) : A.compl.IsSymm", "start": [114, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.isAdjMatrix_compl", "code": "@[simp]\ntheorem isAdjMatrix_compl [Zero \u03b1] [One \u03b1] (h : A.IsSymm) : IsAdjMatrix A.compl", "start": [120, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.compl", "code": "@[simp]\ntheorem compl [Zero \u03b1] [One \u03b1] (h : IsAdjMatrix A) : IsAdjMatrix A.compl", "start": [129, 1], "end": [131, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.toGraph_compl_eq", "code": "theorem toGraph_compl_eq [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (h : IsAdjMatrix A) :\n    h.compl.toGraph = h.toGraph\u1d9c", "start": [134, 1], "end": [137, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix", "code": "def adjMatrix [Zero \u03b1] [One \u03b1] : Matrix V V \u03b1 :=\n  of fun i j => if G.Adj i j then (1 : \u03b1) else 0", "start": [154, 1], "end": [157, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_apply", "code": "@[simp]\ntheorem adjMatrix_apply (v w : V) [Zero \u03b1] [One \u03b1] :\n    G.adjMatrix \u03b1 v w = if G.Adj v w then 1 else 0", "start": [163, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.transpose_adjMatrix", "code": "@[simp]\ntheorem transpose_adjMatrix [Zero \u03b1] [One \u03b1] : (G.adjMatrix \u03b1)\u1d40 = G.adjMatrix \u03b1", "start": [169, 1], "end": [172, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isSymm_adjMatrix", "code": "@[simp]\ntheorem isSymm_adjMatrix [Zero \u03b1] [One \u03b1] : (G.adjMatrix \u03b1).IsSymm", "start": [175, 1], "end": [177, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isAdjMatrix_adjMatrix", "code": "@[simp]\ntheorem isAdjMatrix_adjMatrix [Zero \u03b1] [One \u03b1] : (G.adjMatrix \u03b1).IsAdjMatrix", "start": [182, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.toGraph_adjMatrix_eq", "code": "theorem toGraph_adjMatrix_eq [MulZeroOneClass \u03b1] [Nontrivial \u03b1] :\n    (G.isAdjMatrix_adjMatrix \u03b1).toGraph = G", "start": [188, 1], "end": [193, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_dotProduct", "code": "@[simp]\ntheorem adjMatrix_dotProduct [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    dotProduct (G.adjMatrix \u03b1 v) vec = \u2211 u in G.neighborFinset v, vec u", "start": [198, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dotProduct_adjMatrix", "code": "@[simp]\ntheorem dotProduct_adjMatrix [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    dotProduct vec (G.adjMatrix \u03b1 v) = \u2211 u in G.neighborFinset v, vec u", "start": [204, 1], "end": [207, 76], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_mulVec_apply", "code": "@[simp]\ntheorem adjMatrix_mulVec_apply [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    ((G.adjMatrix \u03b1).mulVec vec) v = \u2211 u in G.neighborFinset v, vec u", "start": [210, 1], "end": [213, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_vecMul_apply", "code": "@[simp]\ntheorem adjMatrix_vecMul_apply [NonAssocSemiring \u03b1] (v : V) (vec : V \u2192 \u03b1) :\n    ((G.adjMatrix \u03b1).vecMul vec) v = \u2211 u in G.neighborFinset v, vec u", "start": [216, 1], "end": [221, 66], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_mul_apply", "code": "@[simp]\ntheorem adjMatrix_mul_apply [NonAssocSemiring \u03b1] (M : Matrix V V \u03b1) (v w : V) :\n    (G.adjMatrix \u03b1 * M) v w = \u2211 u in G.neighborFinset v, M u w", "start": [224, 1], "end": [227, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.mul_adjMatrix_apply", "code": "@[simp]\ntheorem mul_adjMatrix_apply [NonAssocSemiring \u03b1] (M : Matrix V V \u03b1) (v w : V) :\n    (M * G.adjMatrix \u03b1) v w = \u2211 u in G.neighborFinset w, M v u", "start": [230, 1], "end": [233, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.trace_adjMatrix", "code": "@[simp]\ntheorem trace_adjMatrix [AddCommMonoid \u03b1] [One \u03b1] : Matrix.trace (G.adjMatrix \u03b1) = 0", "start": [238, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_mul_self_apply_self", "code": "theorem adjMatrix_mul_self_apply_self [NonAssocSemiring \u03b1] (i : V) :\n    (G.adjMatrix \u03b1 * G.adjMatrix \u03b1) i i = degree G i", "start": [245, 1], "end": [246, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_mulVec_const_apply", "code": "theorem adjMatrix_mulVec_const_apply [Semiring \u03b1] {a : \u03b1} {v : V} :\n    (G.adjMatrix \u03b1).mulVec (Function.const _ a) v = G.degree v * a", "start": [252, 1], "end": [253, 87], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_mulVec_const_apply_of_regular", "code": "theorem adjMatrix_mulVec_const_apply_of_regular [Semiring \u03b1] {d : \u2115} {a : \u03b1}\n    (hd : G.IsRegularOfDegree d) {v : V} : (G.adjMatrix \u03b1).mulVec (Function.const _ a) v = d * a", "start": [256, 1], "end": [258, 17], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adjMatrix_pow_apply_eq_card_walk", "code": "theorem adjMatrix_pow_apply_eq_card_walk [DecidableEq V] [Semiring \u03b1] (n : \u2115) (u v : V) :\n    (G.adjMatrix \u03b1 ^ n) u v = Fintype.card { p : G.Walk u v | p.length = n }", "start": [261, 1], "end": [279, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsAdjMatrix.adjMatrix_toGraph_eq", "code": "theorem adjMatrix_toGraph_eq [DecidableEq \u03b1] : h.toGraph.adjMatrix \u03b1 = A", "start": [290, 1], "end": [294, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Dilation.lean", "imports": ["Mathlib/Data/FunLike/Basic.lean", "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Dilation", "code": "structure Dilation where\n  toFun : \u03b1 \u2192 \u03b2\n  edist_eq' : \u2203 r : \u211d\u22650, r \u2260 0 \u2227 \u2200 x y : \u03b1, edist (toFun x) (toFun y) = r * edist x y", "start": [63, 1], "end": [66, 86], "kind": "commanddeclaration"}, {"full_name": "DilationClass", "code": "class DilationClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [PseudoEMetricSpace \u03b1]\n    [PseudoEMetricSpace \u03b2] extends FunLike F \u03b1 fun _ => \u03b2 where\n  edist_eq' : \u2200 f : F, \u2203 r : \u211d\u22650, r \u2260 0 \u2227 \u2200 x y : \u03b1, edist (f x) (f y) = r * edist x y", "start": [71, 1], "end": [75, 87], "kind": "commanddeclaration"}, {"full_name": "Dilation.toDilationClass", "code": "instance toDilationClass : DilationClass (\u03b1 \u2192\u1d48 \u03b2) \u03b1 \u03b2 where\n  coe := toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  edist_eq' f := edist_eq' f", "start": [88, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "Dilation.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe {f : \u03b1 \u2192\u1d48 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u03b1 \u2192 \u03b2) (h) : \u21d1(\u27e8f, h\u27e9 : \u03b1 \u2192\u1d48 \u03b2) = f", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.congr_fun", "code": "theorem congr_fun {f g : \u03b1 \u2192\u1d48 \u03b2} (h : f = g) (x : \u03b1) : f x = g x", "start": [107, 1], "end": [108, 24], "kind": "commanddeclaration"}, {"full_name": "Dilation.congr_arg", "code": "theorem congr_arg (f : \u03b1 \u2192\u1d48 \u03b2) {x y : \u03b1} (h : x = y) : f x = f y", "start": [111, 1], "end": [112, 24], "kind": "commanddeclaration"}, {"full_name": "Dilation.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192\u1d48 \u03b2} (h : \u2200 x, f x = g x) : f = g", "start": [115, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "Dilation.ext_iff", "code": "theorem ext_iff {f g : \u03b1 \u2192\u1d48 \u03b2} : f = g \u2194 \u2200 x, f x = g x", "start": [120, 1], "end": [121, 18], "kind": "commanddeclaration"}, {"full_name": "Dilation.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : \u03b1 \u2192\u1d48 \u03b2) (h) : Dilation.mk f h = f", "start": [124, 1], "end": [126, 19], "kind": "commanddeclaration"}, {"full_name": "Dilation.copy", "code": "@[simps (config := { fullyApplied := false })]\nprotected def copy (f : \u03b1 \u2192\u1d48 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = \u21d1f) : \u03b1 \u2192\u1d48 \u03b2 where\n  toFun := f'\n  edist_eq' := h.symm \u25b8 f.edist_eq'", "start": [129, 1], "end": [134, 36], "kind": "commanddeclaration"}, {"full_name": "Dilation.copy_eq_self", "code": "theorem copy_eq_self (f : \u03b1 \u2192\u1d48 \u03b2) {f' : \u03b1 \u2192 \u03b2} (h : f' = f) : f.copy f' h = f", "start": [137, 1], "end": [138, 17], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio", "code": "def ratio [DilationClass F \u03b1 \u03b2] (f : F) : \u211d\u22650 :=\n  if \u2200 x y : \u03b1, edist x y = 0 \u2228 edist x y = \u22a4 then 1 else (DilationClass.edist_eq' f).choose", "start": [141, 1], "end": [144, 93], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_of_trivial", "code": "theorem ratio_of_trivial [DilationClass F \u03b1 \u03b2] (f : F)\n    (h : \u2200 x y : \u03b1, edist x y = 0 \u2228 edist x y = \u221e) : ratio f = 1", "start": [147, 1], "end": [149, 11], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_of_subsingleton", "code": "@[nontriviality]\ntheorem ratio_of_subsingleton [Subsingleton \u03b1] [DilationClass F \u03b1 \u03b2] (f : F) : ratio f = 1", "start": [151, 1], "end": [153, 54], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_ne_zero", "code": "theorem ratio_ne_zero [DilationClass F \u03b1 \u03b2] (f : F) : ratio f \u2260 0", "start": [155, 1], "end": [158, 50], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_pos", "code": "theorem ratio_pos [DilationClass F \u03b1 \u03b2] (f : F) : 0 < ratio f", "start": [161, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "Dilation.edist_eq", "code": "@[simp]\ntheorem edist_eq [DilationClass F \u03b1 \u03b2] (f : F) (x y : \u03b1) :\n    edist (f x) (f y) = ratio f * edist x y", "start": [165, 1], "end": [174, 54], "kind": "commanddeclaration"}, {"full_name": "Dilation.nndist_eq", "code": "@[simp]\ntheorem nndist_eq {\u03b1 \u03b2 F : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [DilationClass F \u03b1 \u03b2]\n    (f : F) (x y : \u03b1) : nndist (f x) (f y) = ratio f * nndist x y", "start": [177, 1], "end": [180, 78], "kind": "commanddeclaration"}, {"full_name": "Dilation.dist_eq", "code": "@[simp]\ntheorem dist_eq {\u03b1 \u03b2 F : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] [DilationClass F \u03b1 \u03b2]\n    (f : F) (x y : \u03b1) : dist (f x) (f y) = ratio f * dist x y", "start": [183, 1], "end": [186, 53], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_unique", "code": "theorem ratio_unique [DilationClass F \u03b1 \u03b2] {f : F} {x y : \u03b1} {r : \u211d\u22650} (h\u2080 : edist x y \u2260 0)\n    (htop : edist x y \u2260 \u22a4) (hr : edist (f x) (f y) = r * edist x y) : r = ratio f", "start": [189, 1], "end": [193, 93], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_unique_of_nndist_ne_zero", "code": "theorem ratio_unique_of_nndist_ne_zero {\u03b1 \u03b2 F : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    [DilationClass F \u03b1 \u03b2] {f : F} {x y : \u03b1} {r : \u211d\u22650} (hxy : nndist x y \u2260 0)\n    (hr : nndist (f x) (f y) = r * nndist x y) : r = ratio f", "start": [196, 1], "end": [202, 62], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_unique_of_dist_ne_zero", "code": "theorem ratio_unique_of_dist_ne_zero {\u03b1 \u03b2} {F : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    [DilationClass F \u03b1 \u03b2] {f : F} {x y : \u03b1} {r : \u211d\u22650} (hxy : dist x y \u2260 0)\n    (hr : dist (f x) (f y) = r * dist x y) : r = ratio f", "start": [205, 1], "end": [211, 68], "kind": "commanddeclaration"}, {"full_name": "Dilation.mkOfNNDistEq", "code": "def mkOfNNDistEq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : \u2203 r : \u211d\u22650, r \u2260 0 \u2227 \u2200 x y : \u03b1, nndist (f x) (f y) = r * nndist x y) : \u03b1 \u2192\u1d48 \u03b2 where\n  toFun := f\n  edist_eq' := by\n    rcases h with \u27e8r, hne, h\u27e9\n    refine' \u27e8r, hne, fun x y => _\u27e9\n    rw [edist_nndist, edist_nndist, \u2190 ENNReal.coe_mul, h x y]", "start": [214, 1], "end": [221, 62], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_mkOfNNDistEq", "code": "@[simp]\ntheorem coe_mkOfNNDistEq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (h) :\n    \u21d1(mkOfNNDistEq f h : \u03b1 \u2192\u1d48 \u03b2) = f", "start": [224, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.mk_coe_of_nndist_eq", "code": "@[simp]\ntheorem mk_coe_of_nndist_eq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192\u1d48 \u03b2)\n    (h) : Dilation.mkOfNNDistEq f h = f", "start": [230, 1], "end": [233, 19], "kind": "commanddeclaration"}, {"full_name": "Dilation.mkOfDistEq", "code": "def mkOfDistEq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : \u2203 r : \u211d\u22650, r \u2260 0 \u2227 \u2200 x y : \u03b1, dist (f x) (f y) = r * dist x y) : \u03b1 \u2192\u1d48 \u03b2 :=\n  mkOfNNDistEq f <|\n    h.imp fun r hr =>\n      \u27e8hr.1, fun x y => NNReal.eq <| by rw [coe_nndist, hr.2, NNReal.coe_mul, coe_nndist]\u27e9", "start": [236, 1], "end": [241, 91], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_mkOfDistEq", "code": "@[simp]\ntheorem coe_mkOfDistEq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (h) :\n    \u21d1(mkOfDistEq f h : \u03b1 \u2192\u1d48 \u03b2) = f", "start": [244, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.mk_coe_of_dist_eq", "code": "@[simp]\ntheorem mk_coe_of_dist_eq {\u03b1 \u03b2} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (f : \u03b1 \u2192\u1d48 \u03b2) (h) :\n    Dilation.mkOfDistEq f h = f", "start": [250, 1], "end": [253, 19], "kind": "commanddeclaration"}, {"full_name": "Dilation.lipschitz", "code": "theorem lipschitz : LipschitzWith (ratio f) (f : \u03b1 \u2192 \u03b2)", "start": [266, 1], "end": [266, 90], "kind": "commanddeclaration"}, {"full_name": "Dilation.antilipschitz", "code": "theorem antilipschitz : AntilipschitzWith (ratio f)\u207b\u00b9 (f : \u03b1 \u2192 \u03b2)", "start": [269, 1], "end": [272, 100], "kind": "commanddeclaration"}, {"full_name": "Dilation.injective", "code": "protected theorem injective {\u03b1 : Type*} [EMetricSpace \u03b1] [DilationClass F \u03b1 \u03b2] (f : F) :\n    Injective f", "start": [275, 1], "end": [278, 30], "kind": "commanddeclaration"}, {"full_name": "Dilation.id", "code": "protected def id (\u03b1) [PseudoEMetricSpace \u03b1] : \u03b1 \u2192\u1d48 \u03b1 where\n  toFun := id\n  edist_eq' := \u27e81, one_ne_zero, fun x y => by simp only [id.def, ENNReal.coe_one, one_mul]\u27e9", "start": [281, 1], "end": [284, 92], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_id", "code": "@[simp] theorem coe_id : \u21d1(Dilation.id \u03b1) = id", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_id", "code": "theorem ratio_id : ratio (Dilation.id \u03b1) = 1", "start": [295, 1], "end": [301, 9], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp", "code": "def comp (g : \u03b2 \u2192\u1d48 \u03b3) (f : \u03b1 \u2192\u1d48 \u03b2) : \u03b1 \u2192\u1d48 \u03b3 where\n  toFun := g \u2218 f\n  edist_eq' := \u27e8ratio g * ratio f, mul_ne_zero (ratio_ne_zero g) (ratio_ne_zero f),\n    fun x y => by simp_rw [Function.comp, edist_eq, ENNReal.coe_mul, mul_assoc]\u27e9", "start": [304, 1], "end": [308, 81], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp_assoc", "code": "theorem comp_assoc {\u03b4 : Type*} [PseudoEMetricSpace \u03b4] (f : \u03b1 \u2192\u1d48 \u03b2) (g : \u03b2 \u2192\u1d48 \u03b3)\n    (h : \u03b3 \u2192\u1d48 \u03b4) : (h.comp g).comp f = h.comp (g.comp f)", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : \u03b2 \u2192\u1d48 \u03b3) (f : \u03b1 \u2192\u1d48 \u03b2) : (g.comp f : \u03b1 \u2192 \u03b3) = g \u2218 f", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp_apply", "code": "theorem comp_apply (g : \u03b2 \u2192\u1d48 \u03b3) (f : \u03b1 \u2192\u1d48 \u03b2) (x : \u03b1) : (g.comp f : \u03b1 \u2192 \u03b3) x = g (f x)", "start": [321, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_comp'", "code": "theorem ratio_comp' {g : \u03b2 \u2192\u1d48 \u03b3} {f : \u03b1 \u2192\u1d48 \u03b2}\n    (hne : \u2203 x y : \u03b1, edist x y \u2260 0 \u2227 edist x y \u2260 \u22a4) : ratio (g.comp f) = ratio g * ratio f", "start": [326, 1], "end": [337, 46], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192\u1d48 \u03b2) : f.comp (Dilation.id \u03b1) = f", "start": [340, 1], "end": [342, 19], "kind": "commanddeclaration"}, {"full_name": "Dilation.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192\u1d48 \u03b2) : (Dilation.id \u03b2).comp f = f", "start": [345, 1], "end": [347, 19], "kind": "commanddeclaration"}, {"full_name": "Dilation.one_def", "code": "theorem one_def : (1 : \u03b1 \u2192\u1d48 \u03b1) = Dilation.id \u03b1", "start": [357, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.mul_def", "code": "theorem mul_def (f g : \u03b1 \u2192\u1d48 \u03b1) : f * g = f.comp g", "start": [361, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : \u03b1 \u2192\u1d48 \u03b1) = id", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : \u03b1 \u2192\u1d48 \u03b1) : \u21d1(f * g) = f \u2218 g", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_one", "code": "@[simp] theorem ratio_one : ratio (1 : \u03b1 \u2192\u1d48 \u03b1) = 1", "start": [375, 1], "end": [375, 63], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_mul", "code": "@[simp]\ntheorem ratio_mul (f g : \u03b1 \u2192\u1d48 \u03b1) : ratio (f * g) = ratio f * ratio g", "start": [377, 1], "end": [382, 22], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratioHom", "code": "@[simps]\ndef ratioHom : (\u03b1 \u2192\u1d48 \u03b1) \u2192* \u211d\u22650 := \u27e8\u27e8ratio, ratio_one\u27e9, ratio_mul\u27e9", "start": [384, 1], "end": [386, 66], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_pow", "code": "@[simp]\ntheorem ratio_pow (f : \u03b1 \u2192\u1d48 \u03b1) (n : \u2115) : ratio (f ^ n) = ratio f ^ n", "start": [388, 1], "end": [390, 23], "kind": "commanddeclaration"}, {"full_name": "Dilation.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192\u1d48 \u03b3} {f : \u03b1 \u2192\u1d48 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [392, 1], "end": [395, 73], "kind": "commanddeclaration"}, {"full_name": "Dilation.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192\u1d48 \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192\u1d48 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [398, 1], "end": [401, 95], "kind": "commanddeclaration"}, {"full_name": "Dilation.uniformInducing", "code": "protected theorem uniformInducing : UniformInducing (f : \u03b1 \u2192 \u03b2)", "start": [404, 1], "end": [406, 68], "kind": "commanddeclaration"}, {"full_name": "Dilation.tendsto_nhds_iff", "code": "theorem tendsto_nhds_iff {\u03b9 : Type*} {g : \u03b9 \u2192 \u03b1} {a : Filter \u03b9} {b : \u03b1} :\n    Filter.Tendsto g a (\ud835\udcdd b) \u2194 Filter.Tendsto ((f : \u03b1 \u2192 \u03b2) \u2218 g) a (\ud835\udcdd (f b))", "start": [409, 1], "end": [411, 57], "kind": "commanddeclaration"}, {"full_name": "Dilation.toContinuous", "code": "theorem toContinuous : Continuous (f : \u03b1 \u2192 \u03b2)", "start": [414, 1], "end": [416, 27], "kind": "commanddeclaration"}, {"full_name": "Dilation.ediam_image", "code": "theorem ediam_image (s : Set \u03b1) : EMetric.diam ((f : \u03b1 \u2192 \u03b2) '' s) = ratio f * EMetric.diam s", "start": [419, 1], "end": [424, 67], "kind": "commanddeclaration"}, {"full_name": "Dilation.ediam_range", "code": "theorem ediam_range : EMetric.diam (range (f : \u03b1 \u2192 \u03b2)) = ratio f * EMetric.diam (univ : Set \u03b1)", "start": [427, 1], "end": [429, 46], "kind": "commanddeclaration"}, {"full_name": "Dilation.mapsTo_emetric_ball", "code": "theorem mapsTo_emetric_ball (x : \u03b1) (r : \u211d\u22650\u221e) :\n    MapsTo (f : \u03b1 \u2192 \u03b2) (EMetric.ball x r) (EMetric.ball (f x) (ratio f * r))", "start": [432, 1], "end": [436, 97], "kind": "commanddeclaration"}, {"full_name": "Dilation.mapsTo_emetric_closedBall", "code": "theorem mapsTo_emetric_closedBall (x : \u03b1) (r' : \u211d\u22650\u221e) :\n    MapsTo (f : \u03b1 \u2192 \u03b2) (EMetric.closedBall x r') (EMetric.closedBall (f x) (ratio f * r'))", "start": [439, 1], "end": [443, 76], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp_continuousOn_iff", "code": "theorem comp_continuousOn_iff {\u03b3} [TopologicalSpace \u03b3] {g : \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    ContinuousOn ((f : \u03b1 \u2192 \u03b2) \u2218 g) s \u2194 ContinuousOn g s", "start": [446, 1], "end": [448, 62], "kind": "commanddeclaration"}, {"full_name": "Dilation.comp_continuous_iff", "code": "theorem comp_continuous_iff {\u03b3} [TopologicalSpace \u03b3] {g : \u03b3 \u2192 \u03b1} :\n    Continuous ((f : \u03b1 \u2192 \u03b2) \u2218 g) \u2194 Continuous g", "start": [451, 1], "end": [453, 60], "kind": "commanddeclaration"}, {"full_name": "Dilation.uniformEmbedding", "code": "protected theorem uniformEmbedding [PseudoEMetricSpace \u03b2] [DilationClass F \u03b1 \u03b2] (f : F) :\n    UniformEmbedding f", "start": [462, 1], "end": [465, 69], "kind": "commanddeclaration"}, {"full_name": "Dilation.embedding", "code": "protected theorem embedding [PseudoEMetricSpace \u03b2] [DilationClass F \u03b1 \u03b2] (f : F) :\n    Embedding (f : \u03b1 \u2192 \u03b2)", "start": [468, 1], "end": [471, 42], "kind": "commanddeclaration"}, {"full_name": "Dilation.closedEmbedding", "code": "protected theorem closedEmbedding [CompleteSpace \u03b1] [EMetricSpace \u03b2] [DilationClass F \u03b1 \u03b2] (f : F) :\n    ClosedEmbedding f", "start": [474, 1], "end": [477, 68], "kind": "commanddeclaration"}, {"full_name": "Dilation.ratio_comp", "code": "@[simp]\ntheorem ratio_comp [MetricSpace \u03b1] [Nontrivial \u03b1] [PseudoEMetricSpace \u03b2]\n    [PseudoEMetricSpace \u03b3] {g : \u03b2 \u2192\u1d48 \u03b3} {f : \u03b1 \u2192\u1d48 \u03b2} : ratio (g.comp f) = ratio g * ratio f", "start": [482, 1], "end": [491, 90], "kind": "commanddeclaration"}, {"full_name": "Dilation.diam_image", "code": "theorem diam_image (s : Set \u03b1) : Metric.diam ((f : \u03b1 \u2192 \u03b2) '' s) = ratio f * Metric.diam s", "start": [497, 1], "end": [499, 54], "kind": "commanddeclaration"}, {"full_name": "Dilation.diam_range", "code": "theorem diam_range : Metric.diam (range (f : \u03b1 \u2192 \u03b2)) = ratio f * Metric.diam (univ : Set \u03b1)", "start": [502, 1], "end": [503, 32], "kind": "commanddeclaration"}, {"full_name": "Dilation.mapsTo_ball", "code": "theorem mapsTo_ball (x : \u03b1) (r' : \u211d) :\n    MapsTo (f : \u03b1 \u2192 \u03b2) (Metric.ball x r') (Metric.ball (f x) (ratio f * r'))", "start": [506, 1], "end": [509, 100], "kind": "commanddeclaration"}, {"full_name": "Dilation.mapsTo_sphere", "code": "theorem mapsTo_sphere (x : \u03b1) (r' : \u211d) :\n    MapsTo (f : \u03b1 \u2192 \u03b2) (Metric.sphere x r') (Metric.sphere (f x) (ratio f * r'))", "start": [512, 1], "end": [515, 54], "kind": "commanddeclaration"}, {"full_name": "Dilation.mapsTo_closedBall", "code": "theorem mapsTo_closedBall (x : \u03b1) (r' : \u211d) :\n    MapsTo (f : \u03b1 \u2192 \u03b2) (Metric.closedBall x r') (Metric.closedBall (f x) (ratio f * r'))", "start": [518, 1], "end": [521, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/SingleObj.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Basic.lean", "Mathlib/CategoryTheory/SingleObj.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/ProjectiveSpace/Basic.lean", "imports": ["Mathlib/LinearAlgebra/FiniteDimensional.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "projectivizationSetoid", "code": "def projectivizationSetoid : Setoid { v : V // v \u2260 0 } :=\n  (MulAction.orbitRel K\u02e3 V).comap (\u2191)", "start": [38, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "Projectivization", "code": "def Projectivization := Quotient (projectivizationSetoid K V)", "start": [43, 1], "end": [45, 62], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk", "code": "def mk (v : V) (hv : v \u2260 0) : \u2119 K V :=\n  Quotient.mk'' \u27e8v, hv\u27e9", "start": [54, 1], "end": [56, 24], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk'", "code": "def mk' (v : { v : V // v \u2260 0 }) : \u2119 K V :=\n  Quotient.mk'' v", "start": [59, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk'_eq_mk", "code": "@[simp]\ntheorem mk'_eq_mk (v : { v : V // v \u2260 0 }) : mk' K v = mk K \u2191v v.2", "start": [64, 1], "end": [65, 74], "kind": "commanddeclaration"}, {"full_name": "Projectivization.rep", "code": "protected noncomputable def rep (v : \u2119 K V) : V :=\n  v.out'", "start": [74, 1], "end": [76, 9], "kind": "commanddeclaration"}, {"full_name": "Projectivization.rep_nonzero", "code": "theorem rep_nonzero (v : \u2119 K V) : v.rep \u2260 0", "start": [79, 1], "end": [80, 11], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk_rep", "code": "@[simp]\ntheorem mk_rep (v : \u2119 K V) : mk K v.rep v.rep_nonzero = v", "start": [83, 1], "end": [84, 80], "kind": "commanddeclaration"}, {"full_name": "Projectivization.submodule", "code": "protected def submodule (v : \u2119 K V) : Submodule K V :=\n  (Quotient.liftOn' v fun v => K \u2219 (v : V)) <| by\n    rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 \u27e8x, rfl : x \u2022 b = a\u27e9\n    exact Submodule.span_singleton_group_smul_eq _ x _", "start": [89, 1], "end": [93, 55], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk_eq_mk_iff", "code": "theorem mk_eq_mk_iff (v w : V) (hv : v \u2260 0) (hw : w \u2260 0) :\n    mk K v hv = mk K w hw \u2194 \u2203 a : K\u02e3, a \u2022 w = v", "start": [98, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk_eq_mk_iff'", "code": "theorem mk_eq_mk_iff' (v w : V) (hv : v \u2260 0) (hw : w \u2260 0) :\n    mk K v hv = mk K w hw \u2194 \u2203 a : K, a \u2022 w = v", "start": [103, 1], "end": [113, 29], "kind": "commanddeclaration"}, {"full_name": "Projectivization.exists_smul_eq_mk_rep", "code": "theorem exists_smul_eq_mk_rep (v : V) (hv : v \u2260 0) : \u2203 a : K\u02e3, a \u2022 v = (mk K v hv).rep", "start": [116, 1], "end": [117, 55], "kind": "commanddeclaration"}, {"full_name": "Projectivization.ind", "code": "@[elab_as_elim]\ntheorem ind {P : \u2119 K V \u2192 Prop} (h : \u2200 (v : V) (h : v \u2260 0), P (mk K v h)) : \u2200 p, P p", "start": [122, 1], "end": [126, 36], "kind": "commanddeclaration"}, {"full_name": "Projectivization.submodule_mk", "code": "@[simp]\ntheorem submodule_mk (v : V) (hv : v \u2260 0) : (mk K v hv).submodule = K \u2219 v", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "Projectivization.submodule_eq", "code": "theorem submodule_eq (v : \u2119 K V) : v.submodule = K \u2219 v.rep", "start": [134, 1], "end": [135, 30], "kind": "commanddeclaration"}, {"full_name": "Projectivization.finrank_submodule", "code": "theorem finrank_submodule (v : \u2119 K V) : finrank K v.submodule = 1", "start": [138, 1], "end": [140, 45], "kind": "commanddeclaration"}, {"full_name": "Projectivization.submodule_injective", "code": "theorem submodule_injective :\n    Function.Injective (Projectivization.submodule : \u2119 K V \u2192 Submodule K V)", "start": [148, 1], "end": [153, 46], "kind": "commanddeclaration"}, {"full_name": "Projectivization.equivSubmodule", "code": "noncomputable def equivSubmodule : \u2119 K V \u2243 { H : Submodule K V // finrank K H = 1 } :=\n  (Equiv.ofInjective _ submodule_injective).trans <| .subtypeEquiv (.refl _) fun H \u21a6 by\n    refine \u27e8fun \u27e8v, hv\u27e9 \u21a6 hv \u25b8 v.finrank_submodule, fun h \u21a6 ?_\u27e9\n    rcases finrank_eq_one_iff'.1 h with \u27e8v : H, hv\u2080, hv : \u2200 w : H, _\u27e9\n    use mk K (v : V) (Subtype.coe_injective.ne hv\u2080)\n    rw [submodule_mk, SetLike.ext'_iff, Submodule.span_singleton_eq_range]\n    refine (Set.range_subset_iff.2 fun _ \u21a6 H.smul_mem _ v.2).antisymm fun x hx \u21a6 ?_\n    rcases hv \u27e8x, hx\u27e9 with \u27e8c, hc\u27e9\n    exact \u27e8c, congr_arg Subtype.val hc\u27e9", "start": [158, 1], "end": [168, 40], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk''", "code": "noncomputable def mk'' (H : Submodule K V) (h : finrank K H = 1) : \u2119 K V :=\n  (equivSubmodule K V).symm \u27e8H, h\u27e9", "start": [173, 1], "end": [175, 35], "kind": "commanddeclaration"}, {"full_name": "Projectivization.submodule_mk''", "code": "@[simp]\ntheorem submodule_mk'' (H : Submodule K V) (h : finrank K H = 1) : (mk'' H h).submodule = H", "start": [178, 1], "end": [180, 72], "kind": "commanddeclaration"}, {"full_name": "Projectivization.mk''_submodule", "code": "@[simp]\ntheorem mk''_submodule (v : \u2119 K V) : mk'' v.submodule v.finrank_submodule = v", "start": [183, 1], "end": [185, 42], "kind": "commanddeclaration"}, {"full_name": "Projectivization.map", "code": "def map {\u03c3 : K \u2192+* L} (f : V \u2192\u209b\u2097[\u03c3] W) (hf : Function.Injective f) : \u2119 K V \u2192 \u2119 L W :=\n  Quotient.map' (fun v => \u27e8f v, fun c => v.2 (hf (by simp [c]))\u27e9)\n    (by\n      rintro \u27e8u, hu\u27e9 \u27e8v, hv\u27e9 \u27e8a, ha\u27e9\n      use Units.map \u03c3.toMonoidHom a\n      dsimp at ha \u22a2\n      erw [\u2190 f.map_smul\u209b\u2097, ha])", "start": [192, 1], "end": [199, 32], "kind": "commanddeclaration"}, {"full_name": "Projectivization.map_mk", "code": "theorem map_mk {\u03c3 : K \u2192+* L} (f : V \u2192\u209b\u2097[\u03c3] W) (hf : Function.Injective f) (v : V) (hv : v \u2260 0) :\n    map f hf (mk K v hv) = mk L (f v) (map_zero f \u25b8 hf.ne hv)", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Projectivization.map_injective", "code": "theorem map_injective {\u03c3 : K \u2192+* L} {\u03c4 : L \u2192+* K} [RingHomInvPair \u03c3 \u03c4] (f : V \u2192\u209b\u2097[\u03c3] W)\n    (hf : Function.Injective f) : Function.Injective (map f hf)", "start": [206, 1], "end": [214, 52], "kind": "commanddeclaration"}, {"full_name": "Projectivization.map_id", "code": "@[simp]\ntheorem map_id : map (LinearMap.id : V \u2192\u2097[K] V) (LinearEquiv.refl K V).injective = id", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Projectivization.map_comp", "code": "theorem map_comp {F U : Type*} [Field F] [AddCommGroup U] [Module F U] {\u03c3 : K \u2192+* L} {\u03c4 : L \u2192+* F}\n    {\u03b3 : K \u2192+* F} [RingHomCompTriple \u03c3 \u03c4 \u03b3] (f : V \u2192\u209b\u2097[\u03c3] W) (hf : Function.Injective f)\n    (g : W \u2192\u209b\u2097[\u03c4] U) (hg : Function.Injective g) :\n    map (g.comp f) (hg.comp hf) = map g hg \u2218 map f hf", "start": [224, 1], "end": [229, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/Products.lean", "imports": ["Mathlib/CategoryTheory/Monad/Algebra.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Over.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.prodComonad", "code": "@[simps!]\ndef prodComonad : Comonad C where\n  toFunctor := prod.functor.obj X\n  \u03b5' := { app := fun Y => Limits.prod.snd }\n  \u03b4' := { app := fun Y => prod.lift Limits.prod.fst (\ud835\udfd9 _) }", "start": [42, 1], "end": [47, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coalgebraToOver", "code": "@[simps]\ndef coalgebraToOver : Coalgebra (prodComonad X) \u2964 Over X where\n  obj A := Over.mk (A.a \u226b Limits.prod.fst)\n  map f :=\n    Over.homMk f.f\n      (by\n        rw [Over.mk_hom, \u2190 f.h_assoc]\n        dsimp\n        simp)", "start": [50, 1], "end": [61, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.overToCoalgebra", "code": "@[simps]\ndef overToCoalgebra : Over X \u2964 Coalgebra (prodComonad X) where\n  obj f :=\n    { A := f.left\n      a := prod.lift f.hom (\ud835\udfd9 _) }\n  map g := { f := g.left }", "start": [64, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coalgebraEquivOver", "code": "@[simps]\ndef coalgebraEquivOver : Coalgebra (prodComonad X) \u224c Over X where\n  functor := coalgebraToOver X\n  inverse := overToCoalgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Coalgebra.isoMk (Iso.refl _) (prod.hom_ext (by simp) (by simpa using A.counit))\n  counitIso := NatIso.ofComponents fun f => Over.isoMk (Iso.refl _)", "start": [75, 1], "end": [82, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coprodMonad", "code": "@[simps!]\ndef coprodMonad : Monad C where\n  toFunctor := coprod.functor.obj X\n  \u03b7' := { app := fun Y => coprod.inr }\n  \u03bc' := { app := fun Y => coprod.desc coprod.inl (\ud835\udfd9 _) }", "start": [93, 1], "end": [98, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.algebraToUnder", "code": "@[simps]\ndef algebraToUnder : Monad.Algebra (coprodMonad X) \u2964 Under X where\n  obj A := Under.mk (coprod.inl \u226b A.a)\n  map f :=\n    Under.homMk f.f\n      (by\n        rw [Under.mk_hom, Category.assoc, \u2190 f.h]\n        dsimp\n        simp)", "start": [101, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.underToAlgebra", "code": "@[simps]\ndef underToAlgebra : Under X \u2964 Monad.Algebra (coprodMonad X) where\n  obj f :=\n    { A := f.right\n      a := coprod.desc f.hom (\ud835\udfd9 _) }\n  map g := { f := g.right }", "start": [115, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.algebraEquivUnder", "code": "@[simps]\ndef algebraEquivUnder : Monad.Algebra (coprodMonad X) \u224c Under X where\n  functor := algebraToUnder X\n  inverse := underToAlgebra X\n  unitIso := NatIso.ofComponents fun A =>\n    Monad.Algebra.isoMk (Iso.refl _) (coprod.hom_ext (by simp) (by simpa using A.unit.symm))\n  counitIso :=\n    NatIso.ofComponents fun f => Under.isoMk (Iso.refl _)", "start": [126, 1], "end": [135, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Hausdorff.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "Mathlib/Topology/MetricSpace/MetricSeparated.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean", "Mathlib/Topology/MetricSpace/Holder.lean", "Mathlib/Analysis/Convex/Between.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Measure/Haar/InnerProductSpace.lean"], "premises": [{"full_name": "MeasureTheory.OuterMeasure.IsMetric", "code": "def IsMetric (\u03bc : OuterMeasure X) : Prop :=\n  \u2200 s t : Set X, IsMetricSeparated s t \u2192 \u03bc (s \u222a t) = \u03bc s + \u03bc t", "start": [133, 1], "end": [136, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.IsMetric.finset_iUnion_of_pairwise_separated", "code": "theorem finset_iUnion_of_pairwise_separated (hm : IsMetric \u03bc) {I : Finset \u03b9} {s : \u03b9 \u2192 Set X}\n    (hI : \u2200 i \u2208 I, \u2200 j \u2208 I, i \u2260 j \u2192 IsMetricSeparated (s i) (s j)) :\n    \u03bc (\u22c3 i \u2208 I, s i) = \u2211 i in I, \u03bc (s i)", "start": [143, 1], "end": [154, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.IsMetric.borel_le_caratheodory", "code": "theorem borel_le_caratheodory (hm : IsMetric \u03bc) : borel X \u2264 \u03bc.caratheodory", "start": [157, 1], "end": [228, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.IsMetric.le_caratheodory", "code": "theorem le_caratheodory [MeasurableSpace X] [BorelSpace X] (hm : IsMetric \u03bc) :\n    \u2039MeasurableSpace X\u203a \u2264 \u03bc.caratheodory", "start": [231, 1], "end": [234, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.pre", "code": "def mkMetric'.pre (m : Set X \u2192 \u211d\u22650\u221e) (r : \u211d\u22650\u221e) : OuterMeasure X :=\n  boundedBy <| extend fun s (_ : diam s \u2264 r) => m s", "start": [248, 1], "end": [252, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'", "code": "def mkMetric' (m : Set X \u2192 \u211d\u22650\u221e) : OuterMeasure X :=\n  \u2a06 r > 0, mkMetric'.pre m r", "start": [255, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric", "code": "def mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) : OuterMeasure X :=\n  mkMetric' fun s => m (diam s)", "start": [262, 1], "end": [265, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.le_pre", "code": "theorem le_pre : \u03bc \u2264 pre m r \u2194 \u2200 s : Set X, diam s \u2264 r \u2192 \u03bc s \u2264 m s", "start": [272, 1], "end": [273, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.pre_le", "code": "theorem pre_le (hs : diam s \u2264 r) : pre m r s \u2264 m s", "start": [276, 1], "end": [277, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.mono_pre", "code": "theorem mono_pre (m : Set X \u2192 \u211d\u22650\u221e) {r r' : \u211d\u22650\u221e} (h : r \u2264 r') : pre m r' \u2264 pre m r", "start": [280, 1], "end": [281, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.mono_pre_nat", "code": "theorem mono_pre_nat (m : Set X \u2192 \u211d\u22650\u221e) : Monotone fun k : \u2115 => pre m k\u207b\u00b9", "start": [284, 1], "end": [285, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre", "code": "theorem tendsto_pre (m : Set X \u2192 \u211d\u22650\u221e) (s : Set X) :\n    Tendsto (fun r => pre m r s) (\ud835\udcdd[>] 0) (\ud835\udcdd <| mkMetric' m s)", "start": [288, 1], "end": [292, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.tendsto_pre_nat", "code": "theorem tendsto_pre_nat (m : Set X \u2192 \u211d\u22650\u221e) (s : Set X) :\n    Tendsto (fun n : \u2115 => pre m n\u207b\u00b9 s) atTop (\ud835\udcdd <| mkMetric' m s)", "start": [295, 1], "end": [299, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.eq_iSup_nat", "code": "theorem eq_iSup_nat (m : Set X \u2192 \u211d\u22650\u221e) : mkMetric' m = \u2a06 n : \u2115, mkMetric'.pre m n\u207b\u00b9", "start": [302, 1], "end": [306, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'.trim_pre", "code": "theorem trim_pre [MeasurableSpace X] [OpensMeasurableSpace X] (m : Set X \u2192 \u211d\u22650\u221e)\n    (hcl : \u2200 s, m (closure s) = m s) (r : \u211d\u22650\u221e) : (pre m r).trim = pre m r", "start": [309, 1], "end": [317, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric'_isMetric", "code": "theorem mkMetric'_isMetric (m : Set X \u2192 \u211d\u22650\u221e) : (mkMetric' m).IsMetric", "start": [322, 1], "end": [333, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric_mono_smul", "code": "theorem mkMetric_mono_smul {m\u2081 m\u2082 : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) (h0 : c \u2260 0)\n    (hle : m\u2081 \u2264\u1da0[\ud835\udcdd[\u2265] 0] c \u2022 m\u2082) : (mkMetric m\u2081 : OuterMeasure X) \u2264 c \u2022 mkMetric m\u2082", "start": [336, 1], "end": [353, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric_top", "code": "@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => \u221e : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) : OuterMeasure X) = \u22a4", "start": [356, 1], "end": [361, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric_mono", "code": "theorem mkMetric_mono {m\u2081 m\u2082 : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} (hle : m\u2081 \u2264\u1da0[\ud835\udcdd[\u2265] 0] m\u2082) :\n    (mkMetric m\u2081 : OuterMeasure X) \u2264 mkMetric m\u2082", "start": [364, 1], "end": [368, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isometry_comap_mkMetric", "code": "theorem isometry_comap_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) {f : X \u2192 Y} (hf : Isometry f)\n    (H : Monotone m \u2228 Surjective f) : comap f (mkMetric m) = mkMetric m", "start": [371, 1], "end": [384, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric_smul", "code": "theorem mkMetric_smul (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) (hc' : c \u2260 0) :\n    (mkMetric (c \u2022 m) : OuterMeasure X) = c \u2022 mkMetric m", "start": [387, 1], "end": [390, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mkMetric_nnreal_smul", "code": "theorem mkMetric_nnreal_smul (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) {c : \u211d\u22650} (hc : c \u2260 0) :\n    (mkMetric (c \u2022 m) : OuterMeasure X) = c \u2022 mkMetric m", "start": [393, 1], "end": [396, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isometry_map_mkMetric", "code": "theorem isometry_map_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) {f : X \u2192 Y} (hf : Isometry f)\n    (H : Monotone m \u2228 Surjective f) : map f (mkMetric m) = restrict (range f) (mkMetric m)", "start": [399, 1], "end": [401, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isometryEquiv_comap_mkMetric", "code": "theorem isometryEquiv_comap_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) (f : X \u2243\u1d62 Y) :\n    comap f (mkMetric m) = mkMetric m", "start": [404, 1], "end": [406, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isometryEquiv_map_mkMetric", "code": "theorem isometryEquiv_map_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) (f : X \u2243\u1d62 Y) :\n    map f (mkMetric m) = mkMetric m", "start": [409, 1], "end": [411, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_mkMetric", "code": "theorem trim_mkMetric [MeasurableSpace X] [BorelSpace X] (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) :\n    (mkMetric m : OuterMeasure X).trim = mkMetric m", "start": [414, 1], "end": [419, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_mkMetric", "code": "theorem le_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) (\u03bc : OuterMeasure X) (r : \u211d\u22650\u221e) (h0 : 0 < r)\n    (hr : \u2200 s, diam s \u2264 r \u2192 \u03bc s \u2264 m (diam s)) : \u03bc \u2264 mkMetric m", "start": [422, 1], "end": [424, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric'", "code": "def mkMetric' (m : Set X \u2192 \u211d\u22650\u221e) : Measure X :=\n  (OuterMeasure.mkMetric' m).toMeasure (OuterMeasure.mkMetric'_isMetric _).le_caratheodory", "start": [443, 1], "end": [447, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric", "code": "def mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) : Measure X :=\n  (OuterMeasure.mkMetric m).toMeasure (OuterMeasure.mkMetric'_isMetric _).le_caratheodory", "start": [450, 1], "end": [454, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric'_toOuterMeasure", "code": "@[simp]\ntheorem mkMetric'_toOuterMeasure (m : Set X \u2192 \u211d\u22650\u221e) :\n    (mkMetric' m).toOuterMeasure = (OuterMeasure.mkMetric' m).trim", "start": [457, 1], "end": [460, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_toOuterMeasure", "code": "@[simp]\ntheorem mkMetric_toOuterMeasure (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) :\n    (mkMetric m : Measure X).toOuterMeasure = OuterMeasure.mkMetric m", "start": [463, 1], "end": [466, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_mkMetric", "code": "theorem OuterMeasure.coe_mkMetric [MeasurableSpace X] [BorelSpace X] (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) :\n    \u21d1(OuterMeasure.mkMetric m : OuterMeasure X) = Measure.mkMetric m", "start": [471, 1], "end": [473, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_mono_smul", "code": "theorem mkMetric_mono_smul {m\u2081 m\u2082 : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) (h0 : c \u2260 0)\n    (hle : m\u2081 \u2264\u1da0[\ud835\udcdd[\u2265] 0] c \u2022 m\u2082) : (mkMetric m\u2081 : Measure X) \u2264 c \u2022 mkMetric m\u2082", "start": [480, 1], "end": [486, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_top", "code": "@[simp]\ntheorem mkMetric_top : (mkMetric (fun _ => \u221e : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) : Measure X) = \u22a4", "start": [489, 1], "end": [492, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_mono", "code": "theorem mkMetric_mono {m\u2081 m\u2082 : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} (hle : m\u2081 \u2264\u1da0[\ud835\udcdd[\u2265] 0] m\u2082) :\n    (mkMetric m\u2081 : Measure X) \u2264 mkMetric m\u2082", "start": [495, 1], "end": [499, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_apply", "code": "theorem mkMetric_apply (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) (s : Set X) :\n    mkMetric m s =\n      \u2a06 (r : \u211d\u22650\u221e) (_ : 0 < r),\n        \u2a05 (t : \u2115 \u2192 Set X) (_ : s \u2286 iUnion t) (_ : \u2200 n, diam (t n) \u2264 r),\n          \u2211' n, \u2a06 _ : (t n).Nonempty, m (diam (t n))", "start": [502, 1], "end": [527, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_mkMetric", "code": "theorem le_mkMetric (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) (\u03bc : Measure X) (\u03b5 : \u211d\u22650\u221e) (h\u2080 : 0 < \u03b5)\n    (h : \u2200 s : Set X, diam s \u2264 \u03b5 \u2192 \u03bc s \u2264 m (diam s)) : \u03bc \u2264 mkMetric m", "start": [530, 1], "end": [533, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_le_liminf_tsum", "code": "theorem mkMetric_le_liminf_tsum {\u03b2 : Type*} {\u03b9 : \u03b2 \u2192 Type*} [\u2200 n, Countable (\u03b9 n)] (s : Set X)\n    {l : Filter \u03b2} (r : \u03b2 \u2192 \u211d\u22650\u221e) (hr : Tendsto r l (\ud835\udcdd 0)) (t : \u2200 n : \u03b2, \u03b9 n \u2192 Set X)\n    (ht : \u2200\u1da0 n in l, \u2200 i, diam (t n i) \u2264 r n) (hst : \u2200\u1da0 n in l, s \u2286 \u22c3 i, t n i) (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) :\n    mkMetric m s \u2264 liminf (fun n => \u2211' i, m (diam (t n i))) l", "start": [536, 1], "end": [559, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.mkMetric_le_liminf_sum", "code": "theorem mkMetric_le_liminf_sum {\u03b2 : Type*} {\u03b9 : \u03b2 \u2192 Type*} [h\u03b9 : \u2200 n, Fintype (\u03b9 n)] (s : Set X)\n    {l : Filter \u03b2} (r : \u03b2 \u2192 \u211d\u22650\u221e) (hr : Tendsto r l (\ud835\udcdd 0)) (t : \u2200 n : \u03b2, \u03b9 n \u2192 Set X)\n    (ht : \u2200\u1da0 n in l, \u2200 i, diam (t n i) \u2264 r n) (hst : \u2200\u1da0 n in l, s \u2286 \u22c3 i, t n i) (m : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e) :\n    mkMetric m s \u2264 liminf (fun n => \u2211 i, m (diam (t n i))) l", "start": [562, 1], "end": [569, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure", "code": "def hausdorffMeasure (d : \u211d) : Measure X :=\n  mkMetric fun r => r ^ d", "start": [577, 1], "end": [579, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.le_hausdorffMeasure", "code": "theorem le_hausdorffMeasure (d : \u211d) (\u03bc : Measure X) (\u03b5 : \u211d\u22650\u221e) (h\u2080 : 0 < \u03b5)\n    (h : \u2200 s : Set X, diam s \u2264 \u03b5 \u2192 \u03bc s \u2264 diam s ^ d) : \u03bc \u2264 \u03bcH[d]", "start": [585, 1], "end": [587, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_apply", "code": "theorem hausdorffMeasure_apply (d : \u211d) (s : Set X) :\n    \u03bcH[d] s =\n      \u2a06 (r : \u211d\u22650\u221e) (_ : 0 < r),\n        \u2a05 (t : \u2115 \u2192 Set X) (_ : s \u2286 \u22c3 n, t n) (_ : \u2200 n, diam (t n) \u2264 r),\n          \u2211' n, \u2a06 _ : (t n).Nonempty, diam (t n) ^ d", "start": [590, 1], "end": [596, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_le_liminf_tsum", "code": "theorem hausdorffMeasure_le_liminf_tsum {\u03b2 : Type*} {\u03b9 : \u03b2 \u2192 Type*} [\u2200 n, Countable (\u03b9 n)]\n    (d : \u211d) (s : Set X) {l : Filter \u03b2} (r : \u03b2 \u2192 \u211d\u22650\u221e) (hr : Tendsto r l (\ud835\udcdd 0))\n    (t : \u2200 n : \u03b2, \u03b9 n \u2192 Set X) (ht : \u2200\u1da0 n in l, \u2200 i, diam (t n i) \u2264 r n)\n    (hst : \u2200\u1da0 n in l, s \u2286 \u22c3 i, t n i) : \u03bcH[d] s \u2264 liminf (fun n => \u2211' i, diam (t n i) ^ d) l", "start": [599, 1], "end": [605, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_le_liminf_sum", "code": "theorem hausdorffMeasure_le_liminf_sum {\u03b2 : Type*} {\u03b9 : \u03b2 \u2192 Type*} [\u2200 n, Fintype (\u03b9 n)]\n    (d : \u211d) (s : Set X) {l : Filter \u03b2} (r : \u03b2 \u2192 \u211d\u22650\u221e) (hr : Tendsto r l (\ud835\udcdd 0))\n    (t : \u2200 n : \u03b2, \u03b9 n \u2192 Set X) (ht : \u2200\u1da0 n in l, \u2200 i, diam (t n i) \u2264 r n)\n    (hst : \u2200\u1da0 n in l, s \u2286 \u22c3 i, t n i) : \u03bcH[d] s \u2264 liminf (fun n => \u2211 i, diam (t n i) ^ d) l", "start": [608, 1], "end": [614, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_zero_or_top", "code": "theorem hausdorffMeasure_zero_or_top {d\u2081 d\u2082 : \u211d} (h : d\u2081 < d\u2082) (s : Set X) :\n    \u03bcH[d\u2082] s = 0 \u2228 \u03bcH[d\u2081] s = \u221e", "start": [617, 1], "end": [643, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_mono", "code": "theorem hausdorffMeasure_mono {d\u2081 d\u2082 : \u211d} (h : d\u2081 \u2264 d\u2082) (s : Set X) : \u03bcH[d\u2082] s \u2264 \u03bcH[d\u2081] s", "start": [646, 1], "end": [651, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.noAtoms_hausdorff", "code": "theorem noAtoms_hausdorff {d : \u211d} (hd : 0 < d) : NoAtoms (hausdorffMeasure d : Measure X)", "start": [656, 1], "end": [662, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_zero_singleton", "code": "@[simp]\ntheorem hausdorffMeasure_zero_singleton (x : X) : \u03bcH[0] ({x} : Set X) = 1", "start": [667, 1], "end": [690, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.one_le_hausdorffMeasure_zero_of_nonempty", "code": "theorem one_le_hausdorffMeasure_zero_of_nonempty {s : Set X} (h : s.Nonempty) : 1 \u2264 \u03bcH[0] s", "start": [693, 1], "end": [697, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_le_one_of_subsingleton", "code": "theorem hausdorffMeasure_le_one_of_subsingleton {s : Set X} (hs : s.Subsingleton) {d : \u211d}\n    (hd : 0 \u2264 d) : \u03bcH[d] s \u2264 1", "start": [700, 1], "end": [708, 45], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.hausdorffMeasure_image_le", "code": "theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : \u211d} (hd : 0 \u2264 d) :\n    \u03bcH[d] (f '' s) \u2264 (C : \u211d\u22650\u221e) ^ d * \u03bcH[r * d] s", "start": [730, 1], "end": [771, 63], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.hausdorffMeasure_image_le", "code": "theorem hausdorffMeasure_image_le (h : LipschitzOnWith K f s) {d : \u211d} (hd : 0 \u2264 d) :\n    \u03bcH[d] (f '' s) \u2264 (K : \u211d\u22650\u221e) ^ d * \u03bcH[d] s", "start": [780, 1], "end": [783, 101], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.hausdorffMeasure_image_le", "code": "theorem hausdorffMeasure_image_le (h : LipschitzWith K f) {d : \u211d} (hd : 0 \u2264 d) (s : Set X) :\n    \u03bcH[d] (f '' s) \u2264 (K : \u211d\u22650\u221e) ^ d * \u03bcH[d] s", "start": [792, 1], "end": [796, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.hausdorffMeasure_smul\u2080", "code": "theorem MeasureTheory.Measure.hausdorffMeasure_smul\u2080 {\ud835\udd5c E : Type*} [NormedAddCommGroup E]\n    [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] [MeasurableSpace E] [BorelSpace E] {d : \u211d} (hd : 0 \u2264 d)\n    {r : \ud835\udd5c} (hr : r \u2260 0) (s : Set E) : \u03bcH[d] (r \u2022 s) = NNReal.rpow \u2016r\u2016\u208a d \u2022 \u03bcH[d] s", "start": [803, 1], "end": [816, 71], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.hausdorffMeasure_preimage_le", "code": "theorem hausdorffMeasure_preimage_le (hf : AntilipschitzWith K f) (hd : 0 \u2264 d) (s : Set Y) :\n    \u03bcH[d] (f \u207b\u00b9' s) \u2264 (K : \u211d\u22650\u221e) ^ d * \u03bcH[d] s", "start": [828, 1], "end": [857, 59], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_hausdorffMeasure_image", "code": "theorem le_hausdorffMeasure_image (hf : AntilipschitzWith K f) (hd : 0 \u2264 d) (s : Set X) :\n    \u03bcH[d] s \u2264 (K : \u211d\u22650\u221e) ^ d * \u03bcH[d] (f '' s)", "start": [860, 1], "end": [864, 87], "kind": "commanddeclaration"}, {"full_name": "Isometry.hausdorffMeasure_image", "code": "theorem hausdorffMeasure_image (hf : Isometry f) (hd : 0 \u2264 d \u2228 Surjective f) (s : Set X) :\n    \u03bcH[d] (f '' s) = \u03bcH[d] s", "start": [878, 1], "end": [886, 8], "kind": "commanddeclaration"}, {"full_name": "Isometry.hausdorffMeasure_preimage", "code": "theorem hausdorffMeasure_preimage (hf : Isometry f) (hd : 0 \u2264 d \u2228 Surjective f) (s : Set Y) :\n    \u03bcH[d] (f \u207b\u00b9' s) = \u03bcH[d] (s \u2229 range f)", "start": [889, 1], "end": [891, 69], "kind": "commanddeclaration"}, {"full_name": "Isometry.map_hausdorffMeasure", "code": "theorem map_hausdorffMeasure (hf : Isometry f) (hd : 0 \u2264 d \u2228 Surjective f) :\n    Measure.map f \u03bcH[d] = \u03bcH[d].restrict (range f)", "start": [894, 1], "end": [898, 37], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.hausdorffMeasure_image", "code": "@[simp]\ntheorem hausdorffMeasure_image (e : X \u2243\u1d62 Y) (d : \u211d) (s : Set X) : \u03bcH[d] (e '' s) = \u03bcH[d] s", "start": [905, 1], "end": [907, 60], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.hausdorffMeasure_preimage", "code": "@[simp]\ntheorem hausdorffMeasure_preimage (e : X \u2243\u1d62 Y) (d : \u211d) (s : Set Y) : \u03bcH[d] (e \u207b\u00b9' s) = \u03bcH[d] s", "start": [910, 1], "end": [912, 53], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.map_hausdorffMeasure", "code": "@[simp]\ntheorem map_hausdorffMeasure (e : X \u2243\u1d62 Y) (d : \u211d) : Measure.map e \u03bcH[d] = \u03bcH[d]", "start": [915, 1], "end": [917, 99], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.measurePreserving_hausdorffMeasure", "code": "theorem measurePreserving_hausdorffMeasure (e : X \u2243\u1d62 Y) (d : \u211d) : MeasurePreserving e \u03bcH[d] \u03bcH[d]", "start": [920, 1], "end": [921, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_smul", "code": "@[to_additive]\ntheorem hausdorffMeasure_smul {\u03b1 : Type*} [SMul \u03b1 X] [IsometricSMul \u03b1 X] {d : \u211d} (c : \u03b1)\n    (h : 0 \u2264 d \u2228 Surjective ((\u00b7 \u2022 \u00b7) c : X \u2192 X)) (s : Set X) : \u03bcH[d] (c \u2022 s) = \u03bcH[d] s", "start": [928, 1], "end": [931, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_pi_real", "code": "@[simp]\ntheorem hausdorffMeasure_pi_real {\u03b9 : Type*} [Fintype \u03b9] :\n    (\u03bcH[Fintype.card \u03b9] : Measure (\u03b9 \u2192 \u211d)) = volume", "start": [948, 1], "end": [1039, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_measurePreserving_funUnique", "code": "theorem hausdorffMeasure_measurePreserving_funUnique [Unique \u03b9]\n    [TopologicalSpace.SecondCountableTopology X] (d : \u211d) :\n    MeasurePreserving (MeasurableEquiv.funUnique \u03b9 X) \u03bcH[d] \u03bcH[d]", "start": [1044, 1], "end": [1047, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_measurePreserving_piFinTwo", "code": "theorem hausdorffMeasure_measurePreserving_piFinTwo (\u03b1 : Fin 2 \u2192 Type*)\n    [\u2200 i, MeasurableSpace (\u03b1 i)] [\u2200 i, EMetricSpace (\u03b1 i)] [\u2200 i, BorelSpace (\u03b1 i)]\n    [\u2200 i, TopologicalSpace.SecondCountableTopology (\u03b1 i)] (d : \u211d) :\n    MeasurePreserving (MeasurableEquiv.piFinTwo \u03b1) \u03bcH[d] \u03bcH[d]", "start": [1050, 1], "end": [1054, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_real", "code": "@[simp]\ntheorem hausdorffMeasure_real : (\u03bcH[1] : Measure \u211d) = volume", "start": [1057, 1], "end": [1062, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_prod_real", "code": "@[simp]\ntheorem hausdorffMeasure_prod_real : (\u03bcH[2] : Measure (\u211d \u00d7 \u211d)) = volume", "start": [1065, 1], "end": [1070, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_smul_right_image", "code": "theorem hausdorffMeasure_smul_right_image [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [MeasurableSpace E] [BorelSpace E] (v : E) (s : Set \u211d) :\n    \u03bcH[1] ((fun r => r \u2022 v) '' s) = \u2016v\u2016\u208a \u2022 \u03bcH[1] s", "start": [1079, 1], "end": [1108, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_homothety_image", "code": "theorem hausdorffMeasure_homothety_image {d : \u211d} (hd : 0 \u2264 d) (x : P) {c : \ud835\udd5c} (hc : c \u2260 0)\n    (s : Set P) : \u03bcH[d] (AffineMap.homothety x c '' s) = NNReal.rpow \u2016c\u2016\u208a d \u2022 \u03bcH[d] s", "start": [1117, 1], "end": [1126, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_homothety_preimage", "code": "theorem hausdorffMeasure_homothety_preimage {d : \u211d} (hd : 0 \u2264 d) (x : P) {c : \ud835\udd5c} (hc : c \u2260 0)\n    (s : Set P) : \u03bcH[d] (AffineMap.homothety x c \u207b\u00b9' s) = NNReal.rpow \u2016c\u2016\u208a\u207b\u00b9 d \u2022 \u03bcH[d] s", "start": [1129, 1], "end": [1134, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_lineMap_image", "code": "theorem hausdorffMeasure_lineMap_image (x y : P) (s : Set \u211d) :\n    \u03bcH[1] (AffineMap.lineMap x y '' s) = nndist x y \u2022 \u03bcH[1] s", "start": [1149, 1], "end": [1158, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_affineSegment", "code": "@[simp]\ntheorem hausdorffMeasure_affineSegment (x y : P) : \u03bcH[1] (affineSegment \u211d x y) = edist x y", "start": [1161, 1], "end": [1166, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.hausdorffMeasure_segment", "code": "@[simp]\ntheorem hausdorffMeasure_segment {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [MeasurableSpace E] [BorelSpace E] (x y : E) : \u03bcH[1] (segment \u211d x y) = edist x y", "start": [1171, 1], "end": [1175, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sigma/Order.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "Mathlib/Data/Sigma/Lex.lean", "Mathlib/Mathport/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sigma.le", "code": "protected inductive le [\u2200 i, LE (\u03b1 i)] : \u2200 _a _b : \u03a3 i, \u03b1 i, Prop\n  | fiber (i : \u03b9) (a b : \u03b1 i) : a \u2264 b \u2192 Sigma.le \u27e8i, a\u27e9 \u27e8i, b\u27e9", "start": [52, 1], "end": [54, 63], "kind": "commanddeclaration"}, {"full_name": "Sigma.lt", "code": "protected inductive lt [\u2200 i, LT (\u03b1 i)] : \u2200 _a _b : \u03a3i, \u03b1 i, Prop\n  | fiber (i : \u03b9) (a b : \u03b1 i) : a < b \u2192 Sigma.lt \u27e8i, a\u27e9 \u27e8i, b\u27e9", "start": [57, 1], "end": [59, 63], "kind": "commanddeclaration"}, {"full_name": "Sigma.LE", "code": "protected instance LE [\u2200 i, LE (\u03b1 i)] : LE (\u03a3i, \u03b1 i) where\n  le := Sigma.le", "start": [62, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "Sigma.LT", "code": "protected instance LT [\u2200 i, LT (\u03b1 i)] : LT (\u03a3i, \u03b1 i) where\n  lt := Sigma.lt", "start": [65, 1], "end": [66, 17], "kind": "commanddeclaration"}, {"full_name": "Sigma.mk_le_mk_iff", "code": "@[simp]\ntheorem mk_le_mk_iff [\u2200 i, LE (\u03b1 i)] {i : \u03b9} {a b : \u03b1 i} : (\u27e8i, a\u27e9 : Sigma \u03b1) \u2264 \u27e8i, b\u27e9 \u2194 a \u2264 b", "start": [68, 1], "end": [70, 48], "kind": "commanddeclaration"}, {"full_name": "Sigma.mk_lt_mk_iff", "code": "@[simp]\ntheorem mk_lt_mk_iff [\u2200 i, LT (\u03b1 i)] {i : \u03b9} {a b : \u03b1 i} : (\u27e8i, a\u27e9 : Sigma \u03b1) < \u27e8i, b\u27e9 \u2194 a < b", "start": [73, 1], "end": [75, 48], "kind": "commanddeclaration"}, {"full_name": "Sigma.le_def", "code": "theorem le_def [\u2200 i, LE (\u03b1 i)] {a b : \u03a3i, \u03b1 i} : a \u2264 b \u2194 \u2203 h : a.1 = b.1, h.rec a.2 \u2264 b.2", "start": [78, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "Sigma.lt_def", "code": "theorem lt_def [\u2200 i, LT (\u03b1 i)] {a b : \u03a3i, \u03b1 i} : a < b \u2194 \u2203 h : a.1 = b.1, h.rec a.2 < b.2", "start": [88, 1], "end": [95, 27], "kind": "commanddeclaration"}, {"full_name": "Sigma.preorder", "code": "protected instance preorder [\u2200 i, Preorder (\u03b1 i)] : Preorder (\u03a3i, \u03b1 i) :=\n  { Sigma.LE, Sigma.LT with\n    le_refl := fun \u27e8i, a\u27e9 => Sigma.le.fiber i a a le_rfl,\n    le_trans := by\n      rintro _ _ _ \u27e8i, a, b, hab\u27e9 \u27e8_, _, c, hbc\u27e9\n      exact le.fiber i a c (hab.trans hbc),\n    lt_iff_le_not_le := fun _ _ => by\n      constructor\n      \u00b7 rintro \u27e8i, a, b, hab\u27e9\n        rwa [mk_le_mk_iff, mk_le_mk_iff, \u2190 lt_iff_le_not_le]\n      \u00b7 rintro \u27e8\u27e8i, a, b, hab\u27e9, h\u27e9\n        rw [mk_le_mk_iff] at h\n        exact mk_lt_mk_iff.2 (hab.lt_of_not_le h) }", "start": [98, 1], "end": [110, 52], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.LE", "code": "protected instance LE [LT \u03b9] [\u2200 i, LE (\u03b1 i)] : LE (\u03a3\u2097 i, \u03b1 i) where\n  le := Lex (\u00b7 < \u00b7) fun _ => (\u00b7 \u2264 \u00b7)", "start": [132, 1], "end": [134, 37], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.LT", "code": "protected instance LT [LT \u03b9] [\u2200 i, LT (\u03b1 i)] : LT (\u03a3\u2097 i, \u03b1 i) where\n  lt := Lex (\u00b7 < \u00b7) fun _ => (\u00b7 < \u00b7)", "start": [137, 1], "end": [139, 37], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.le_def", "code": "theorem le_def [LT \u03b9] [\u2200 i, LE (\u03b1 i)] {a b : \u03a3\u2097 i, \u03b1 i} :\n    a \u2264 b \u2194 a.1 < b.1 \u2228 \u2203 h : a.1 = b.1, h.rec a.2 \u2264 b.2", "start": [142, 1], "end": [144, 16], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.lt_def", "code": "theorem lt_def [LT \u03b9] [\u2200 i, LT (\u03b1 i)] {a b : \u03a3\u2097 i, \u03b1 i} :\n    a < b \u2194 a.1 < b.1 \u2228 \u2203 h : a.1 = b.1, h.rec a.2 < b.2", "start": [147, 1], "end": [149, 16], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.preorder", "code": "instance preorder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] : Preorder (\u03a3\u2097 i, \u03b1 i) :=\n  { Sigma.Lex.LE, Sigma.Lex.LT with\n    le_refl := fun \u27e8i, a\u27e9 => Lex.right a a le_rfl,\n    le_trans := fun _ _ _ => trans_of ((Lex (\u00b7 < \u00b7)) fun _ => (\u00b7 \u2264 \u00b7)),\n    lt_iff_le_not_le := by\n      refine' fun a b => \u27e8fun hab => \u27e8hab.mono_right fun i a b => le_of_lt, _\u27e9, _\u27e9\n      \u00b7 rintro (\u27e8b, a, hji\u27e9 | \u27e8b, a, hba\u27e9) <;> obtain \u27e8_, _, hij\u27e9 | \u27e8_, _, hab\u27e9 := hab\n        \u00b7 exact hij.not_lt hji\n        \u00b7 exact lt_irrefl _ hji\n        \u00b7 exact lt_irrefl _ hij\n        \u00b7 exact hab.not_le hba\n      \u00b7 rintro \u27e8\u27e8a, b, hij\u27e9 | \u27e8a, b, hab\u27e9, hba\u27e9\n        \u00b7 exact Sigma.Lex.left _ _ hij\n        \u00b7 exact Sigma.Lex.right _ _ (hab.lt_of_not_le fun h => hba <| Sigma.Lex.right _ _ h) }", "start": [152, 1], "end": [166, 95], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.partialOrder", "code": "instance partialOrder [Preorder \u03b9] [\u2200 i, PartialOrder (\u03b1 i)] :\n    PartialOrder (\u03a3\u2097 i, \u03b1 i) :=\n  { Lex.preorder with\n    le_antisymm := fun _ _ => antisymm_of ((Lex (\u00b7 < \u00b7)) fun _ => (\u00b7 \u2264 \u00b7)) }", "start": [169, 1], "end": [173, 77], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.linearOrder", "code": "instance linearOrder [LinearOrder \u03b9] [\u2200 i, LinearOrder (\u03b1 i)] :\n    LinearOrder (\u03a3\u2097 i, \u03b1 i) :=\n  { Lex.partialOrder with\n    le_total := total_of ((Lex (\u00b7 < \u00b7)) fun _ => (\u00b7 \u2264 \u00b7)),\n    decidableEq := Sigma.instDecidableEqSigma,\n    decidableLE := Lex.decidable _ _ }", "start": [178, 1], "end": [184, 39], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.orderBot", "code": "instance orderBot [PartialOrder \u03b9] [OrderBot \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderBot (\u03b1 \u22a5)] :\n    OrderBot (\u03a3\u2097 i, \u03b1 i) where\n  bot := \u27e8\u22a5, \u22a5\u27e9\n  bot_le := fun \u27e8a, b\u27e9 => by\n    obtain rfl | ha := eq_bot_or_bot_lt a\n    \u00b7 exact Lex.right _ _ bot_le\n    \u00b7 exact Lex.left _ _ ha", "start": [187, 1], "end": [194, 28], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.orderTop", "code": "instance orderTop [PartialOrder \u03b9] [OrderTop \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderTop (\u03b1 \u22a4)] :\n    OrderTop (\u03a3\u2097 i, \u03b1 i) where\n  top := \u27e8\u22a4, \u22a4\u27e9\n  le_top := fun \u27e8a, b\u27e9 => by\n    obtain rfl | ha := eq_top_or_lt_top a\n    \u00b7 exact Lex.right _ _ le_top\n    \u00b7 exact Lex.left _ _ ha", "start": [197, 1], "end": [204, 28], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.boundedOrder", "code": "instance boundedOrder [PartialOrder \u03b9] [BoundedOrder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderBot (\u03b1 \u22a5)]\n    [OrderTop (\u03b1 \u22a4)] : BoundedOrder (\u03a3\u2097 i, \u03b1 i) :=\n  { Lex.orderBot, Lex.orderTop with }", "start": [207, 1], "end": [210, 38], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.denselyOrdered", "code": "instance denselyOrdered [Preorder \u03b9] [DenselyOrdered \u03b9] [\u2200 i, Nonempty (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] : DenselyOrdered (\u03a3\u2097 i, \u03b1 i) where\n  dense := by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | \u27e8_, b, h\u27e9)\n    \u00b7 obtain \u27e8k, hi, hj\u27e9 := exists_between h\n      obtain \u27e8c\u27e9 : Nonempty (\u03b1 k) := inferInstance\n      exact \u27e8\u27e8k, c\u27e9, left _ _ hi, left _ _ hj\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ _ ha, right _ _ hb\u27e9", "start": [213, 1], "end": [221, 49], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.denselyOrdered_of_noMaxOrder", "code": "instance denselyOrdered_of_noMaxOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] [\u2200 i, NoMaxOrder (\u03b1 i)] :\n    DenselyOrdered (\u03a3\u2097 i, \u03b1 i) where\n  dense := by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | \u27e8_, b, h\u27e9)\n    \u00b7 obtain \u27e8c, ha\u27e9 := exists_gt a\n      exact \u27e8\u27e8i, c\u27e9, right _ _ ha, left _ _ h\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ _ ha, right _ _ hb\u27e9", "start": [224, 1], "end": [232, 49], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.denselyOrdered_of_noMinOrder", "code": "instance denselyOrdered_of_noMinOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] [\u2200 i, NoMinOrder (\u03b1 i)] :\n    DenselyOrdered (\u03a3\u2097 i, \u03b1 i) where\n  dense := by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | \u27e8_, b, h\u27e9)\n    \u00b7 obtain \u27e8c, hb\u27e9 := exists_lt b\n      exact \u27e8\u27e8j, c\u27e9, left _ _ h, right _ _ hb\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ _ ha, right _ _ hb\u27e9", "start": [235, 1], "end": [243, 49], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.noMaxOrder_of_nonempty", "code": "instance noMaxOrder_of_nonempty [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [NoMaxOrder \u03b9]\n    [\u2200 i, Nonempty (\u03b1 i)] : NoMaxOrder (\u03a3\u2097 i, \u03b1 i) where\n  exists_gt := by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8j, h\u27e9 := exists_gt i\n    obtain \u27e8b\u27e9 : Nonempty (\u03b1 j) := inferInstance\n    exact \u27e8\u27e8j, b\u27e9, left _ _ h\u27e9", "start": [246, 1], "end": [252, 31], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.noMinOrder_of_nonempty", "code": "instance noMinOrder_of_nonempty [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [NoMinOrder \u03b9]\n    [\u2200 i, Nonempty (\u03b1 i)] : NoMinOrder (\u03a3\u2097 i, \u03b1 i) where\n  exists_lt := by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8j, h\u27e9 := exists_lt i\n    obtain \u27e8b\u27e9 : Nonempty (\u03b1 j) := inferInstance\n    exact \u27e8\u27e8j, b\u27e9, left _ _ h\u27e9", "start": [256, 1], "end": [262, 31], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.noMaxOrder", "code": "instance noMaxOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, NoMaxOrder (\u03b1 i)] :\n    NoMaxOrder (\u03a3\u2097 i, \u03b1 i) where\n  exists_gt := by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8b, h\u27e9 := exists_gt a\n    exact \u27e8\u27e8i, b\u27e9, right _ _ h\u27e9", "start": [265, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.noMinOrder", "code": "instance noMinOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, NoMinOrder (\u03b1 i)] :\n    NoMinOrder (\u03a3\u2097 i, \u03b1 i) where\n  exists_lt := by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8b, h\u27e9 := exists_lt a\n    exact \u27e8\u27e8i, b\u27e9, right _ _ h\u27e9", "start": [273, 1], "end": [278, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Semisimple.lean", "imports": ["Mathlib/Algebra/Lie/Solvable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieModule.IsIrreducible", "code": "class LieModule.IsIrreducible (R : Type u) (L : Type v) (M : Type w) [CommRing R] [LieRing L]\n    [LieAlgebra R L] [AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M] :\n    Prop where\n  Irreducible : \u2200 N : LieSubmodule R L M, N \u2260 \u22a5 \u2192 N = \u22a4", "start": [34, 1], "end": [38, 56], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.IsSimple", "code": "class IsSimple extends LieModule.IsIrreducible R L L : Prop where\n  non_abelian : \u00acIsLieAbelian L", "start": [47, 1], "end": [50, 32], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.IsSemisimple", "code": "class IsSemisimple : Prop where\n  semisimple : radical R L = \u22a5", "start": [53, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isSemisimple_iff_no_solvable_ideals", "code": "theorem isSemisimple_iff_no_solvable_ideals :\n    IsSemisimple R L \u2194 \u2200 I : LieIdeal R L, IsSolvable R I \u2192 I = \u22a5", "start": [64, 1], "end": [66, 71], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isSemisimple_iff_no_abelian_ideals", "code": "theorem isSemisimple_iff_no_abelian_ideals :\n    IsSemisimple R L \u2194 \u2200 I : LieIdeal R L, IsLieAbelian I \u2192 I = \u22a5", "start": [69, 1], "end": [75, 42], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.center_eq_bot_of_semisimple", "code": "@[simp]\ntheorem center_eq_bot_of_semisimple [h : IsSemisimple R L] : center R L = \u22a5", "start": [78, 1], "end": [80, 72], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isSemisimpleOfIsSimple", "code": "instance (priority := 100) isSemisimpleOfIsSimple [h : IsSimple R L] : IsSemisimple R L := by\n  rw [isSemisimple_iff_no_abelian_ideals]\n  intro I hI\n  obtain @\u27e8\u27e8h\u2081\u27e9, h\u2082\u27e9 := id h\n  by_contra contra\n  rw [h\u2081 I contra, lie_abelian_iff_equiv_lie_abelian LieIdeal.topEquiv] at hI\n  exact h\u2082 hI", "start": [83, 1], "end": [90, 14], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.subsingleton_of_semisimple_lie_abelian", "code": "theorem subsingleton_of_semisimple_lie_abelian [IsSemisimple R L] [h : IsLieAbelian L] :\n    Subsingleton L", "start": [93, 1], "end": [97, 80], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.abelian_radical_of_semisimple", "code": "theorem abelian_radical_of_semisimple [IsSemisimple R L] : IsLieAbelian (radical R L)", "start": [100, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.abelian_radical_iff_solvable_is_abelian", "code": "theorem abelian_radical_iff_solvable_is_abelian [IsNoetherian R L] :\n    IsLieAbelian (radical R L) \u2194 \u2200 I : LieIdeal R L, IsSolvable R I \u2192 IsLieAbelian I", "start": [104, 1], "end": [115, 37], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ad_ker_eq_bot_of_semisimple", "code": "theorem ad_ker_eq_bot_of_semisimple [IsSemisimple R L] : (ad R L).ker = \u22a5", "start": [118, 1], "end": [118, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Weights/Cartan.lean", "imports": ["Mathlib/Algebra/Lie/Character.lean", "Mathlib/Algebra/Lie/CartanSubalgebra.lean", "Mathlib/Algebra/Lie/Weights/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieModule.IsWeight", "code": "def IsWeight (\u03c7 : LieCharacter R H) : Prop :=\n  weightSpace M \u03c7 \u2260 \u22a5", "start": [44, 1], "end": [47, 22], "kind": "commanddeclaration"}, {"full_name": "LieModule.isWeight_zero_of_nilpotent", "code": "theorem isWeight_zero_of_nilpotent [Nontrivial M] [LieAlgebra.IsNilpotent R L] [IsNilpotent R L M] :\n    IsWeight (\u22a4 : LieSubalgebra R L) M 0", "start": [50, 1], "end": [54, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpace", "code": "abbrev rootSpace (\u03c7 : H \u2192 R) : LieSubmodule R H L :=\n  weightSpace L \u03c7", "start": [64, 1], "end": [67, 18], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.zero_rootSpace_eq_top_of_nilpotent", "code": "theorem zero_rootSpace_eq_top_of_nilpotent [IsNilpotent R L] :\n    rootSpace (\u22a4 : LieSubalgebra R L) 0 = \u22a4", "start": [70, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.IsRoot", "code": "abbrev IsRoot (\u03c7 : LieCharacter R H) :=\n  \u03c7 \u2260 0 \u2227 IsWeight H L \u03c7", "start": [75, 1], "end": [78, 25], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpace_comap_eq_weightSpace", "code": "@[simp]\ntheorem rootSpace_comap_eq_weightSpace (\u03c7 : H \u2192 R) :\n    (rootSpace H \u03c7).comap H.incl' = weightSpace H \u03c7", "start": [81, 1], "end": [84, 58], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.lie_mem_weightSpace_of_mem_weightSpace", "code": "theorem lie_mem_weightSpace_of_mem_weightSpace {\u03c7\u2081 \u03c7\u2082 : H \u2192 R} {x : L} {m : M}\n    (hx : x \u2208 rootSpace H \u03c7\u2081) (hm : m \u2208 weightSpace M \u03c7\u2082) : \u2045x, m\u2046 \u2208 weightSpace M (\u03c7\u2081 + \u03c7\u2082)", "start": [89, 1], "end": [97, 54], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpaceWeightSpaceProductAux", "code": "def rootSpaceWeightSpaceProductAux {\u03c7\u2081 \u03c7\u2082 \u03c7\u2083 : H \u2192 R} (h\u03c7 : \u03c7\u2081 + \u03c7\u2082 = \u03c7\u2083) :\n    rootSpace H \u03c7\u2081 \u2192\u2097[R] weightSpace M \u03c7\u2082 \u2192\u2097[R] weightSpace M \u03c7\u2083 where\n  toFun x :=\n    { toFun := fun m =>\n        \u27e8\u2045(x : L), (m : M)\u2046, h\u03c7 \u25b8 lie_mem_weightSpace_of_mem_weightSpace x.property m.property\u27e9\n      map_add' := fun m n => by simp only [LieSubmodule.coe_add, lie_add]; rfl\n      map_smul' := fun t m => by\n        dsimp only\n        conv_lhs =>\n          congr\n          rw [LieSubmodule.coe_smul, lie_smul] }\n  map_add' x y := by\n    ext m\n    simp only [AddSubmonoid.coe_add, Submodule.coe_toAddSubmonoid, add_lie, LinearMap.coe_mk,\n      AddHom.coe_mk, LinearMap.add_apply, AddSubmonoid.mk_add_mk]\n  map_smul' t x := by\n    simp only [RingHom.id_apply]\n    ext m\n    simp only [SetLike.val_smul, smul_lie, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.smul_apply,\n      SetLike.mk_smul_mk]", "start": [102, 1], "end": [124, 26], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpaceWeightSpaceProduct", "code": "def rootSpaceWeightSpaceProduct (\u03c7\u2081 \u03c7\u2082 \u03c7\u2083 : H \u2192 R) (h\u03c7 : \u03c7\u2081 + \u03c7\u2082 = \u03c7\u2083) :\n    rootSpace H \u03c7\u2081 \u2297[R] weightSpace M \u03c7\u2082 \u2192\u2097\u2045R,H\u2046 weightSpace M \u03c7\u2083 :=\n  liftLie R H (rootSpace H \u03c7\u2081) (weightSpace M \u03c7\u2082) (weightSpace M \u03c7\u2083)\n    { toLinearMap := rootSpaceWeightSpaceProductAux R L H M h\u03c7\n      map_lie' := fun {x y} => by\n        ext m\n        simp only [rootSpaceWeightSpaceProductAux, LieSubmodule.coe_bracket,\n          LieSubalgebra.coe_bracket_of_module, lie_lie, LinearMap.coe_mk, AddHom.coe_mk,\n          Subtype.coe_mk, LieHom.lie_apply, LieSubmodule.coe_sub] }", "start": [129, 1], "end": [139, 68], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.coe_rootSpaceWeightSpaceProduct_tmul", "code": "@[simp]\ntheorem coe_rootSpaceWeightSpaceProduct_tmul (\u03c7\u2081 \u03c7\u2082 \u03c7\u2083 : H \u2192 R) (h\u03c7 : \u03c7\u2081 + \u03c7\u2082 = \u03c7\u2083)\n    (x : rootSpace H \u03c7\u2081) (m : weightSpace M \u03c7\u2082) :\n    (rootSpaceWeightSpaceProduct R L H M \u03c7\u2081 \u03c7\u2082 \u03c7\u2083 h\u03c7 (x \u2297\u209c m) : M) = \u2045(x : L), (m : M)\u2046", "start": [142, 1], "end": [148, 22], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpaceProduct", "code": "def rootSpaceProduct (\u03c7\u2081 \u03c7\u2082 \u03c7\u2083 : H \u2192 R) (h\u03c7 : \u03c7\u2081 + \u03c7\u2082 = \u03c7\u2083) :\n    rootSpace H \u03c7\u2081 \u2297[R] rootSpace H \u03c7\u2082 \u2192\u2097\u2045R,H\u2046 rootSpace H \u03c7\u2083 :=\n  rootSpaceWeightSpaceProduct R L H L \u03c7\u2081 \u03c7\u2082 \u03c7\u2083 h\u03c7", "start": [151, 1], "end": [155, 50], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpaceProduct_def", "code": "@[simp]\ntheorem rootSpaceProduct_def : rootSpaceProduct R L H = rootSpaceWeightSpaceProduct R L H L", "start": [158, 1], "end": [159, 99], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpaceProduct_tmul", "code": "theorem rootSpaceProduct_tmul (\u03c7\u2081 \u03c7\u2082 \u03c7\u2083 : H \u2192 R) (h\u03c7 : \u03c7\u2081 + \u03c7\u2082 = \u03c7\u2083) (x : rootSpace H \u03c7\u2081)\n    (y : rootSpace H \u03c7\u2082) : (rootSpaceProduct R L H \u03c7\u2081 \u03c7\u2082 \u03c7\u2083 h\u03c7 (x \u2297\u209c y) : L) = \u2045(x : L), (y : L)\u2046", "start": [162, 1], "end": [164, 76], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.zeroRootSubalgebra", "code": "def zeroRootSubalgebra : LieSubalgebra R L :=\n  { toSubmodule := (rootSpace H 0 : Submodule R L)\n    lie_mem' := fun {x y hx hy} => by\n      let xy : rootSpace H 0 \u2297[R] rootSpace H 0 := \u27e8x, hx\u27e9 \u2297\u209c \u27e8y, hy\u27e9\n      suffices (rootSpaceProduct R L H 0 0 0 (add_zero 0) xy : L) \u2208 rootSpace H 0 by\n        rwa [rootSpaceProduct_tmul, Subtype.coe_mk, Subtype.coe_mk] at this\n      exact (rootSpaceProduct R L H 0 0 0 (add_zero 0) xy).property }", "start": [167, 1], "end": [175, 70], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.coe_zeroRootSubalgebra", "code": "@[simp]\ntheorem coe_zeroRootSubalgebra : (zeroRootSubalgebra R L H : Submodule R L) = rootSpace H 0", "start": [178, 1], "end": [179, 99], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.mem_zeroRootSubalgebra", "code": "theorem mem_zeroRootSubalgebra (x : L) :\n    x \u2208 zeroRootSubalgebra R L H \u2194 \u2200 y : H, \u2203 k : \u2115, (toEndomorphism R H L y ^ k) x = 0", "start": [182, 1], "end": [185, 66], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.toLieSubmodule_le_rootSpace_zero", "code": "theorem toLieSubmodule_le_rootSpace_zero : H.toLieSubmodule \u2264 rootSpace H 0", "start": [188, 1], "end": [209, 10], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.le_zeroRootSubalgebra", "code": "theorem le_zeroRootSubalgebra : H \u2264 zeroRootSubalgebra R L H", "start": [212, 1], "end": [215, 47], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.zeroRootSubalgebra_normalizer_eq_self", "code": "@[simp]\ntheorem zeroRootSubalgebra_normalizer_eq_self :\n    (zeroRootSubalgebra R L H).normalizer = zeroRootSubalgebra R L H", "start": [218, 1], "end": [232, 63], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.is_cartan_of_zeroRootSubalgebra_eq", "code": "theorem is_cartan_of_zeroRootSubalgebra_eq (h : zeroRootSubalgebra R L H = H) :\n    H.IsCartanSubalgebra", "start": [235, 1], "end": [243, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.zeroRootSubalgebra_eq_of_is_cartan", "code": "@[simp]\ntheorem zeroRootSubalgebra_eq_of_is_cartan (H : LieSubalgebra R L) [H.IsCartanSubalgebra]\n    [IsNoetherian R L] : zeroRootSubalgebra R L H = H", "start": [246, 1], "end": [252, 73], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.zeroRootSubalgebra_eq_iff_is_cartan", "code": "theorem zeroRootSubalgebra_eq_iff_is_cartan [IsNoetherian R L] :\n    zeroRootSubalgebra R L H = H \u2194 H.IsCartanSubalgebra", "start": [255, 1], "end": [257, 62], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.rootSpace_zero_eq", "code": "@[simp]\ntheorem rootSpace_zero_eq (H : LieSubalgebra R L) [H.IsCartanSubalgebra] [IsNoetherian R L] :\n    rootSpace H 0 = H.toLieSubmodule", "start": [260, 1], "end": [264, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/PID.lean", "imports": ["Mathlib/LinearAlgebra/Trace.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.trace_restrict_eq_of_forall_mem", "code": "lemma trace_restrict_eq_of_forall_mem [IsDomain R] [IsPrincipalIdealRing R]\n    (p : Submodule R M) (f : M \u2192\u2097[R] M)\n    (hf : \u2200 x, f x \u2208 p) (hf' : \u2200 x \u2208 p, f x \u2208 p := fun x _ \u21a6 hf x) :\n    trace R p (f.restrict hf') = trace R M f := by\n  let \u03b9 := Module.Free.ChooseBasisIndex R M\n  obtain \u27e8n, snf : Basis.SmithNormalForm p \u03b9 n\u27e9 := p.smithNormalForm (Module.Free.chooseBasis R M)\n  rw [trace_eq_matrix_trace R snf.bM, trace_eq_matrix_trace R snf.bN]\n  set A : Matrix (Fin n) (Fin n) R := toMatrix snf.bN snf.bN (f.restrict hf')\n  set B : Matrix \u03b9 \u03b9 R := toMatrix snf.bM snf.bM f\n  have aux : \u2200 i, B i i \u2260 0 \u2192 i \u2208 Set.range snf.f := fun i hi \u21a6 by\n    contrapose! hi; exact snf.repr_eq_zero_of_nmem_range \u27e8_, (hf _)\u27e9 hi\n  change \u2211 i, A i i = \u2211 i, B i i\n  rw [\u2190 Finset.sum_filter_of_ne (p := fun j \u21a6 j \u2208 Set.range snf.f) (by simpa using aux)]\n  simp", "start": [30, 1], "end": [45, 7], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Set/Card.lean", "imports": ["Mathlib/Data/Finite/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.encard", "code": "noncomputable def encard (s : Set \u03b1) := PartENat.withTopEquiv (PartENat.card s)", "start": [65, 1], "end": [66, 80], "kind": "commanddeclaration"}, {"full_name": "Set.encard_univ_coe", "code": "@[simp] theorem encard_univ_coe (s : Set \u03b1) : encard (univ : Set s) = encard s", "start": [68, 1], "end": [69, 63], "kind": "commanddeclaration"}, {"full_name": "Set.encard_univ", "code": "theorem encard_univ (\u03b1 : Type*) :\n    encard (univ : Set \u03b1) = PartENat.withTopEquiv (PartENat.card \u03b1)", "start": [71, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.encard_eq_coe_toFinset_card", "code": "theorem Finite.encard_eq_coe_toFinset_card (h : s.Finite) : s.encard = h.toFinset.card", "start": [75, 1], "end": [78, 69], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_coe_toFinset_card", "code": "theorem encard_eq_coe_toFinset_card (s : Set \u03b1) [Fintype s] : encard s = s.toFinset.card", "start": [80, 1], "end": [82, 71], "kind": "commanddeclaration"}, {"full_name": "Set.encard_coe_eq_coe_finsetCard", "code": "theorem encard_coe_eq_coe_finsetCard (s : Finset \u03b1) : encard (s : Set \u03b1) = s.card", "start": [84, 1], "end": [85, 72], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.encard_eq", "code": "theorem Infinite.encard_eq {s : Set \u03b1} (h : s.Infinite) : s.encard = \u22a4", "start": [87, 1], "end": [90, 70], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_zero", "code": "@[simp] theorem encard_eq_zero : s.encard = 0 \u2194 s = \u2205", "start": [92, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "Set.encard_empty", "code": "@[simp] theorem encard_empty : (\u2205 : Set \u03b1).encard = 0", "start": [97, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_encard_ne_zero", "code": "theorem nonempty_of_encard_ne_zero (h : s.encard \u2260 0) : s.Nonempty", "start": [100, 1], "end": [101, 55], "kind": "commanddeclaration"}, {"full_name": "Set.encard_ne_zero", "code": "theorem encard_ne_zero : s.encard \u2260 0 \u2194 s.Nonempty", "start": [103, 1], "end": [104, 52], "kind": "commanddeclaration"}, {"full_name": "Set.encard_pos", "code": "@[simp] theorem encard_pos : 0 < s.encard \u2194 s.Nonempty", "start": [106, 1], "end": [107, 39], "kind": "commanddeclaration"}, {"full_name": "Set.encard_singleton", "code": "@[simp] theorem encard_singleton (e : \u03b1) : ({e} : Set \u03b1).encard = 1", "start": [109, 1], "end": [111, 87], "kind": "commanddeclaration"}, {"full_name": "Set.encard_union_eq", "code": "theorem encard_union_eq (h : Disjoint s t) : (s \u222a t).encard = s.encard + t.encard", "start": [113, 1], "end": [116, 82], "kind": "commanddeclaration"}, {"full_name": "Set.encard_insert_of_not_mem", "code": "theorem encard_insert_of_not_mem (has : a \u2209 s) : (insert a s).encard = s.encard + 1", "start": [118, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.encard_lt_top", "code": "theorem Finite.encard_lt_top (h : s.Finite) : s.encard < \u22a4", "start": [121, 1], "end": [125, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.encard_eq_coe", "code": "theorem Finite.encard_eq_coe (h : s.Finite) : s.encard = ENat.toNat s.encard", "start": [127, 1], "end": [128, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_encard_eq_coe", "code": "theorem Finite.exists_encard_eq_coe (h : s.Finite) : \u2203 (n : \u2115), s.encard = n", "start": [130, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Set.encard_lt_top_iff", "code": "@[simp] theorem encard_lt_top_iff : s.encard < \u22a4 \u2194 s.Finite", "start": [133, 1], "end": [134, 82], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_top_iff", "code": "@[simp] theorem encard_eq_top_iff : s.encard = \u22a4 \u2194 s.Infinite", "start": [136, 1], "end": [137, 82], "kind": "commanddeclaration"}, {"full_name": "Set.encard_ne_top_iff", "code": "theorem encard_ne_top_iff : s.encard \u2260 \u22a4 \u2194 s.Finite", "start": [139, 1], "end": [140, 7], "kind": "commanddeclaration"}, {"full_name": "Set.finite_of_encard_le_coe", "code": "theorem finite_of_encard_le_coe {k : \u2115} (h : s.encard \u2264 k) : s.Finite", "start": [142, 1], "end": [143, 67], "kind": "commanddeclaration"}, {"full_name": "Set.finite_of_encard_eq_coe", "code": "theorem finite_of_encard_eq_coe {k : \u2115} (h : s.encard = k) : s.Finite", "start": [145, 1], "end": [146, 31], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_coe_iff", "code": "theorem encard_le_coe_iff {k : \u2115} : s.encard \u2264 k \u2194 s.Finite \u2227 \u2203 (n\u2080 : \u2115), s.encard = n\u2080 \u2227 n\u2080 \u2264 k", "start": [148, 1], "end": [150, 53], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_of_subset", "code": "theorem encard_le_of_subset (h : s \u2286 t) : s.encard \u2264 t.encard", "start": [154, 1], "end": [155, 85], "kind": "commanddeclaration"}, {"full_name": "Set.encard_mono", "code": "theorem encard_mono {\u03b1 : Type*} : Monotone (encard : Set \u03b1 \u2192 \u2115\u221e)", "start": [157, 1], "end": [158, 32], "kind": "commanddeclaration"}, {"full_name": "Set.encard_diff_add_encard_of_subset", "code": "theorem encard_diff_add_encard_of_subset (h : s \u2286 t) : (t \\ s).encard + s.encard = t.encard", "start": [160, 1], "end": [161, 94], "kind": "commanddeclaration"}, {"full_name": "Set.one_le_encard_iff_nonempty", "code": "@[simp] theorem one_le_encard_iff_nonempty : 1 \u2264 s.encard \u2194 s.Nonempty", "start": [163, 1], "end": [164, 79], "kind": "commanddeclaration"}, {"full_name": "Set.encard_diff_add_encard_inter", "code": "theorem encard_diff_add_encard_inter (s t : Set \u03b1) :\n    (s \\ t).encard + (s \u2229 t).encard = s.encard", "start": [166, 1], "end": [169, 22], "kind": "commanddeclaration"}, {"full_name": "Set.encard_union_add_encard_inter", "code": "theorem encard_union_add_encard_inter (s t : Set \u03b1) :\n    (s \u222a t).encard + (s \u2229 t).encard = s.encard + t.encard", "start": [171, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_encard_iff_encard_diff_eq_encard_diff", "code": "theorem encard_eq_encard_iff_encard_diff_eq_encard_diff (h : (s \u2229 t).Finite) :\n    s.encard = t.encard \u2194 (s \\ t).encard = (t \\ s).encard", "start": [176, 1], "end": [179, 53], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_encard_iff_encard_diff_le_encard_diff", "code": "theorem encard_le_encard_iff_encard_diff_le_encard_diff (h : (s \u2229 t).Finite) :\n    s.encard \u2264 t.encard \u2194 (s \\ t).encard \u2264 (t \\ s).encard", "start": [181, 1], "end": [184, 53], "kind": "commanddeclaration"}, {"full_name": "Set.encard_lt_encard_iff_encard_diff_lt_encard_diff", "code": "theorem encard_lt_encard_iff_encard_diff_lt_encard_diff (h : (s \u2229 t).Finite) :\n    s.encard < t.encard \u2194 (s \\ t).encard < (t \\ s).encard", "start": [186, 1], "end": [189, 53], "kind": "commanddeclaration"}, {"full_name": "Set.encard_union_le", "code": "theorem encard_union_le (s t : Set \u03b1) : (s \u222a t).encard \u2264 s.encard + t.encard", "start": [191, 1], "end": [192, 57], "kind": "commanddeclaration"}, {"full_name": "Set.finite_iff_finite_of_encard_eq_encard", "code": "theorem finite_iff_finite_of_encard_eq_encard (h : s.encard = t.encard) : s.Finite \u2194 t.Finite", "start": [194, 1], "end": [195, 49], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_iff_infinite_of_encard_eq_encard", "code": "theorem infinite_iff_infinite_of_encard_eq_encard (h : s.encard = t.encard) :\n    s.Infinite \u2194 t.Infinite", "start": [197, 1], "end": [198, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.finite_of_encard_le", "code": "theorem Finite.finite_of_encard_le {s : Set \u03b1} {t : Set \u03b2} (hs : s.Finite)\n    (h : t.encard \u2264 s.encard) : t.Finite", "start": [200, 1], "end": [202, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.eq_of_subset_of_encard_le", "code": "theorem Finite.eq_of_subset_of_encard_le (ht : t.Finite) (hst : s \u2286 t) (hts : t.encard \u2264 s.encard) :\n    s = t", "start": [204, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.eq_of_subset_of_encard_le'", "code": "theorem Finite.eq_of_subset_of_encard_le' (hs : s.Finite) (hst : s \u2286 t)\n    (hts : t.encard \u2264 s.encard) : s = t", "start": [211, 1], "end": [213, 65], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.encard_lt_encard", "code": "theorem Finite.encard_lt_encard (ht : t.Finite) (h : s \u2282 t) : s.encard < t.encard", "start": [215, 1], "end": [216, 101], "kind": "commanddeclaration"}, {"full_name": "Set.encard_strictMono", "code": "theorem encard_strictMono [Finite \u03b1] : StrictMono (encard : Set \u03b1 \u2192 \u2115\u221e)", "start": [218, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "Set.encard_diff_add_encard", "code": "theorem encard_diff_add_encard (s t : Set \u03b1) : (s \\ t).encard + t.encard = (s \u222a t).encard", "start": [221, 1], "end": [222, 61], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_encard_diff_add_encard", "code": "theorem encard_le_encard_diff_add_encard (s t : Set \u03b1) : s.encard \u2264 (s \\ t).encard + t.encard", "start": [224, 1], "end": [225, 83], "kind": "commanddeclaration"}, {"full_name": "Set.tsub_encard_le_encard_diff", "code": "theorem tsub_encard_le_encard_diff (s t : Set \u03b1) : s.encard - t.encard \u2264 (s \\ t).encard", "start": [227, 1], "end": [228, 74], "kind": "commanddeclaration"}, {"full_name": "Set.encard_add_encard_compl", "code": "theorem encard_add_encard_compl (s : Set \u03b1) : s.encard + s\u1d9c.encard = (univ : Set \u03b1).encard", "start": [230, 1], "end": [231, 63], "kind": "commanddeclaration"}, {"full_name": "Set.encard_insert_le", "code": "theorem encard_insert_le (s : Set \u03b1) (x : \u03b1) : (insert x s).encard \u2264 s.encard + 1", "start": [237, 1], "end": [238, 68], "kind": "commanddeclaration"}, {"full_name": "Set.encard_singleton_inter", "code": "theorem encard_singleton_inter (s : Set \u03b1) (x : \u03b1) : ({x} \u2229 s).encard \u2264 1", "start": [240, 1], "end": [241, 78], "kind": "commanddeclaration"}, {"full_name": "Set.encard_diff_singleton_add_one", "code": "theorem encard_diff_singleton_add_one (h : a \u2208 s) :\n    (s \\ {a}).encard + 1 = s.encard", "start": [243, 1], "end": [245, 94], "kind": "commanddeclaration"}, {"full_name": "Set.encard_diff_singleton_of_mem", "code": "theorem encard_diff_singleton_of_mem (h : a \u2208 s) :\n    (s \\ {a}).encard = s.encard - 1", "start": [247, 1], "end": [250, 50], "kind": "commanddeclaration"}, {"full_name": "Set.encard_tsub_one_le_encard_diff_singleton", "code": "theorem encard_tsub_one_le_encard_diff_singleton (s : Set \u03b1) (x : \u03b1) :\n    s.encard - 1 \u2264 (s \\ {x}).encard", "start": [252, 1], "end": [254, 61], "kind": "commanddeclaration"}, {"full_name": "Set.encard_exchange", "code": "theorem encard_exchange (ha : a \u2209 s) (hb : b \u2208 s) : (insert a (s \\ {b})).encard = s.encard", "start": [256, 1], "end": [258, 86], "kind": "commanddeclaration"}, {"full_name": "Set.encard_exchange'", "code": "theorem encard_exchange' (ha : a \u2209 s) (hb : b \u2208 s) : (insert a s \\ {b}).encard = s.encard", "start": [260, 1], "end": [261, 87], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_add_one_iff", "code": "theorem encard_eq_add_one_iff {k : \u2115\u221e} :\n    s.encard = k + 1 \u2194 (\u2203 a t, \u00aca \u2208 t \u2227 insert a t = s \u2227 t.encard = k)", "start": [263, 1], "end": [271, 34], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt", "code": "theorem eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt (s : Set \u03b1) :\n    s = \u2205 \u2228 s.encard = \u22a4 \u2228 \u2203 a \u2208 s, (s \\ {a}).encard < s.encard", "start": [273, 1], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "Set.encard_pair", "code": "theorem encard_pair (hne : x \u2260 y) : ({x, y} : Set \u03b1).encard = 2", "start": [286, 1], "end": [288, 71], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_one", "code": "theorem encard_eq_one : s.encard = 1 \u2194 \u2203 x, s = {x}", "start": [290, 1], "end": [293, 93], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_one_iff_eq", "code": "theorem encard_le_one_iff_eq : s.encard \u2264 1 \u2194 s = \u2205 \u2228 \u2203 x, s = {x}", "start": [295, 1], "end": [297, 19], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_one_iff", "code": "theorem encard_le_one_iff : s.encard \u2264 1 \u2194 \u2200 a b, a \u2208 s \u2192 b \u2208 s \u2192 a = b", "start": [299, 1], "end": [304, 36], "kind": "commanddeclaration"}, {"full_name": "Set.one_lt_encard_iff", "code": "theorem one_lt_encard_iff : 1 < s.encard \u2194 \u2203 a b, a \u2208 s \u2227 b \u2208 s \u2227 a \u2260 b", "start": [306, 1], "end": [307, 66], "kind": "commanddeclaration"}, {"full_name": "Set.exists_ne_of_one_lt_encard", "code": "theorem exists_ne_of_one_lt_encard (h : 1 < s.encard) (a : \u03b1) : \u2203 b \u2208 s, b \u2260 a", "start": [309, 1], "end": [313, 26], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_two", "code": "theorem encard_eq_two : s.encard = 2 \u2194 \u2203 x y, x \u2260 y \u2227 s = {x, y}", "start": [315, 1], "end": [322, 54], "kind": "commanddeclaration"}, {"full_name": "Set.encard_eq_three", "code": "theorem encard_eq_three {\u03b1 : Type u_1} {s : Set \u03b1} :\n    encard s = 3 \u2194 \u2203 x y z, x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z \u2227 s = {x, y, z}", "start": [324, 1], "end": [336, 90], "kind": "commanddeclaration"}, {"full_name": "Set.Nat.encard_range", "code": "theorem Nat.encard_range (k : \u2115) : {i | i < k}.encard = k", "start": [338, 1], "end": [341, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.eq_insert_of_subset_of_encard_eq_succ", "code": "theorem Finite.eq_insert_of_subset_of_encard_eq_succ (hs : s.Finite) (h : s \u2286 t)\n    (hst : t.encard = s.encard + 1) : \u2203 a, t = insert a s", "start": [345, 1], "end": [349, 82], "kind": "commanddeclaration"}, {"full_name": "Set.exists_subset_encard_eq", "code": "theorem exists_subset_encard_eq (hk : k \u2264 s.encard) : \u2203 t, t \u2286 s \u2227 t.encard = k", "start": [351, 1], "end": [361, 39], "kind": "commanddeclaration"}, {"full_name": "Set.exists_superset_subset_encard_eq", "code": "theorem exists_superset_subset_encard_eq (hst : s \u2286 t) (hsk : s.encard \u2264 k) (hkt : k \u2264 t.encard) :\n    \u2203 r, s \u2286 r \u2227 r \u2286 t \u2227 r.encard = k", "start": [363, 1], "end": [374, 75], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.encard_image", "code": "theorem InjOn.encard_image (h : InjOn f s) : (f '' s).encard = s.encard", "start": [380, 1], "end": [381, 54], "kind": "commanddeclaration"}, {"full_name": "Set.encard_congr", "code": "theorem encard_congr (e : s \u2243 t) : s.encard = t.encard", "start": [383, 1], "end": [384, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.encard_image", "code": "theorem _root_.Function.Injective.encard_image (hf : f.Injective) (s : Set \u03b1) :\n    (f '' s).encard = s.encard", "start": [386, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.enccard_le", "code": "theorem _root_.Function.Embedding.enccard_le (e : s \u21aa t) : s.encard \u2264 t.encard", "start": [390, 1], "end": [392, 30], "kind": "commanddeclaration"}, {"full_name": "Set.encard_image_le", "code": "theorem encard_image_le (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : (f '' s).encard \u2264 s.encard", "start": [394, 1], "end": [399, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.injOn_of_encard_image_eq", "code": "theorem Finite.injOn_of_encard_image_eq (hs : s.Finite) (h : (f '' s).encard = s.encard) :\n    InjOn f s", "start": [401, 1], "end": [407, 81], "kind": "commanddeclaration"}, {"full_name": "Set.encard_preimage_of_injective_subset_range", "code": "theorem encard_preimage_of_injective_subset_range (hf : f.Injective) (ht : t \u2286 range f) :\n    (f \u207b\u00b9' t).encard = t.encard", "start": [409, 1], "end": [411, 88], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_encard_of_injOn", "code": "theorem encard_le_encard_of_injOn (hf : MapsTo f s t) (f_inj : InjOn f s) :\n    s.encard \u2264 t.encard", "start": [413, 1], "end": [415, 90], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_injOn_of_encard_le", "code": "theorem Finite.exists_injOn_of_encard_le [Nonempty \u03b2] {s : Set \u03b1} {t : Set \u03b2} (hs : s.Finite)\n    (hle : s.encard \u2264 t.encard) : \u2203 (f : \u03b1 \u2192 \u03b2), s \u2286 f \u207b\u00b9' t \u2227 InjOn f s", "start": [417, 1], "end": [440, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_bijOn_of_encard_eq", "code": "theorem Finite.exists_bijOn_of_encard_eq [Nonempty \u03b2] (hs : s.Finite) (h : s.encard = t.encard) :\n    \u2203 (f : \u03b1 \u2192 \u03b2), BijOn f s t", "start": [442, 1], "end": [447, 46], "kind": "commanddeclaration"}, {"full_name": "Set.ncard", "code": "noncomputable def ncard (s : Set \u03b1) :=\n  ENat.toNat s.encard", "start": [470, 1], "end": [472, 22], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_def", "code": "theorem ncard_def (s : Set \u03b1) : s.ncard = ENat.toNat s.encard", "start": [475, 1], "end": [475, 69], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.cast_ncard_eq", "code": "theorem Finite.cast_ncard_eq (hs : s.Finite) : s.ncard = s.encard", "start": [477, 1], "end": [478, 87], "kind": "commanddeclaration"}, {"full_name": "Set.Nat.card_coe_set_eq", "code": "@[simp] theorem Nat.card_coe_set_eq (s : Set \u03b1) : Nat.card s = s.ncard", "start": [480, 1], "end": [486, 72], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_toFinset_card", "code": "theorem ncard_eq_toFinset_card (s : Set \u03b1) (hs : s.Finite := by toFinite_tac) :\n    s.ncard = hs.toFinset.card", "start": [489, 1], "end": [492, 45], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_toFinset_card'", "code": "theorem ncard_eq_toFinset_card' (s : Set \u03b1) [Fintype s] :\n    s.ncard = s.toFinset.card", "start": [495, 1], "end": [497, 56], "kind": "commanddeclaration"}, {"full_name": "Set.encard_le_coe_iff_finite_ncard_le", "code": "theorem encard_le_coe_iff_finite_ncard_le {k : \u2115} : s.encard \u2264 k \u2194 s.Finite \u2227 s.ncard \u2264 k", "start": [499, 1], "end": [502, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.ncard", "code": "theorem Infinite.ncard (hs : s.Infinite) : s.ncard = 0", "start": [504, 1], "end": [505, 75], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_of_subset", "code": "theorem ncard_le_of_subset (hst : s \u2286 t) (ht : t.Finite := by toFinite_tac) :\n    s.ncard \u2264 t.ncard", "start": [508, 1], "end": [511, 24], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_mono", "code": "theorem ncard_mono [Finite \u03b1] : @Monotone (Set \u03b1) _ _ _ ncard", "start": [514, 1], "end": [514, 94], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_zero", "code": "@[simp] theorem ncard_eq_zero (hs : s.Finite := by toFinite_tac) :\n    s.ncard = 0 \u2194 s = \u2205", "start": [517, 1], "end": [519, 80], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_coe_Finset", "code": "@[simp] theorem ncard_coe_Finset (s : Finset \u03b1) : (s : Set \u03b1).ncard = s.card", "start": [522, 1], "end": [523, 62], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_univ", "code": "theorem ncard_univ (\u03b1 : Type*) : (univ : Set \u03b1).ncard = Nat.card \u03b1", "start": [526, 1], "end": [531, 22], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_empty", "code": "@[simp] theorem ncard_empty (\u03b1 : Type*) : (\u2205 : Set \u03b1).ncard = 0", "start": [534, 1], "end": [535, 21], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_pos", "code": "theorem ncard_pos (hs : s.Finite := by toFinite_tac) : 0 < s.ncard \u2194 s.Nonempty", "start": [538, 1], "end": [539, 72], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_ne_zero_of_mem", "code": "theorem ncard_ne_zero_of_mem (h : a \u2208 s) (hs : s.Finite := by toFinite_tac) : s.ncard \u2260 0", "start": [542, 1], "end": [543, 38], "kind": "commanddeclaration"}, {"full_name": "Set.finite_of_ncard_ne_zero", "code": "theorem finite_of_ncard_ne_zero (hs : s.ncard \u2260 0) : s.Finite", "start": [546, 1], "end": [547, 57], "kind": "commanddeclaration"}, {"full_name": "Set.finite_of_ncard_pos", "code": "theorem finite_of_ncard_pos (hs : 0 < s.ncard) : s.Finite", "start": [550, 1], "end": [551, 37], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_ncard_ne_zero", "code": "theorem nonempty_of_ncard_ne_zero (hs : s.ncard \u2260 0) : s.Nonempty", "start": [554, 1], "end": [555, 53], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_singleton", "code": "@[simp] theorem ncard_singleton (a : \u03b1) : ({a} : Set \u03b1).ncard = 1", "start": [558, 1], "end": [559, 32], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_singleton_inter", "code": "theorem ncard_singleton_inter (a : \u03b1) (s : Set \u03b1) : ({a} \u2229 s).ncard \u2264 1", "start": [562, 1], "end": [564, 31], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_insert_of_not_mem", "code": "@[simp] theorem ncard_insert_of_not_mem (h : a \u2209 s) (hs : s.Finite := by toFinite_tac) :\n    (insert a s).ncard = s.ncard + 1", "start": [568, 1], "end": [571, 50], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_insert_of_mem", "code": "theorem ncard_insert_of_mem (h : a \u2208 s) : ncard (insert a s) = s.ncard", "start": [574, 1], "end": [575, 28], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_insert_le", "code": "theorem ncard_insert_le (a : \u03b1) (s : Set \u03b1) : (insert a s).ncard \u2264 s.ncard + 1", "start": [578, 1], "end": [582, 22], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_insert_eq_ite", "code": "theorem ncard_insert_eq_ite [Decidable (a \u2208 s)] (hs : s.Finite := by toFinite_tac) :\n    ncard (insert a s) = if a \u2208 s then s.ncard else s.ncard + 1", "start": [585, 1], "end": [589, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_ncard_insert", "code": "theorem ncard_le_ncard_insert (a : \u03b1) (s : Set \u03b1) : s.ncard \u2264 (insert a s).ncard", "start": [592, 1], "end": [596, 49], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_pair", "code": "@[simp] theorem ncard_pair (h : a \u2260 b) : ({a, b} : Set \u03b1).ncard = 2", "start": [599, 1], "end": [600, 55], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_singleton_add_one", "code": "@[simp] theorem ncard_diff_singleton_add_one (h : a \u2208 s) (hs : s.Finite := by toFinite_tac) :\n    (s \\ {a}).ncard + 1 = s.ncard", "start": [603, 1], "end": [606, 37], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_singleton_of_mem", "code": "@[simp] theorem ncard_diff_singleton_of_mem (h : a \u2208 s) (hs : s.Finite := by toFinite_tac) :\n    (s \\ {a}).ncard = s.ncard - 1", "start": [609, 1], "end": [611, 56], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_singleton_lt_of_mem", "code": "theorem ncard_diff_singleton_lt_of_mem (h : a \u2208 s) (hs : s.Finite := by toFinite_tac) :\n    (s \\ {a}).ncard < s.ncard", "start": [614, 1], "end": [616, 61], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_singleton_le", "code": "theorem ncard_diff_singleton_le (s : Set \u03b1) (a : \u03b1) : (s \\ {a}).ncard \u2264 s.ncard", "start": [619, 1], "end": [623, 51], "kind": "commanddeclaration"}, {"full_name": "Set.pred_ncard_le_ncard_diff_singleton", "code": "theorem pred_ncard_le_ncard_diff_singleton (s : Set \u03b1) (a : \u03b1) : s.ncard - 1 \u2264 (s \\ {a}).ncard", "start": [626, 1], "end": [633, 16], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_exchange", "code": "theorem ncard_exchange (ha : a \u2209 s) (hb : b \u2208 s) : (insert a (s \\ {b})).ncard = s.ncard", "start": [636, 1], "end": [637, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_exchange'", "code": "theorem ncard_exchange' (ha : a \u2209 s) (hb : b \u2208 s) : (insert a s \\ {b}).ncard = s.ncard", "start": [640, 1], "end": [642, 84], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_image_le", "code": "theorem ncard_image_le (hs : s.Finite := by toFinite_tac) : (f '' s).ncard \u2264 s.ncard", "start": [647, 1], "end": [648, 90], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_image_of_injOn", "code": "theorem ncard_image_of_injOn (H : Set.InjOn f s) : (f '' s).ncard = s.ncard", "start": [651, 1], "end": [652, 41], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_of_ncard_image_eq", "code": "theorem injOn_of_ncard_image_eq (h : (f '' s).ncard = s.ncard) (hs : s.Finite := by toFinite_tac) :\n    Set.InjOn f s", "start": [655, 1], "end": [658, 38], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_image_iff", "code": "theorem ncard_image_iff (hs : s.Finite := by toFinite_tac) :\n    (f '' s).ncard = s.ncard \u2194 Set.InjOn f s", "start": [661, 1], "end": [663, 63], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_image_of_injective", "code": "theorem ncard_image_of_injective (s : Set \u03b1) (H : f.Injective) : (f '' s).ncard = s.ncard", "start": [666, 1], "end": [667, 43], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_preimage_of_injective_subset_range", "code": "theorem ncard_preimage_of_injective_subset_range {s : Set \u03b2} (H : f.Injective)\n    (hs : s \u2286 Set.range f) :\n    (f \u207b\u00b9' s).ncard = s.ncard", "start": [670, 1], "end": [673, 68], "kind": "commanddeclaration"}, {"full_name": "Set.fiber_ncard_ne_zero_iff_mem_image", "code": "theorem fiber_ncard_ne_zero_iff_mem_image {y : \u03b2} (hs : s.Finite := by toFinite_tac) :\n    { x \u2208 s | f x = y }.ncard \u2260 0 \u2194 y \u2208 f '' s", "start": [676, 1], "end": [681, 33], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_map", "code": "@[simp] theorem ncard_map (f : \u03b1 \u21aa \u03b2) : (f '' s).ncard = s.ncard", "start": [684, 1], "end": [685, 36], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_subtype", "code": "@[simp] theorem ncard_subtype (P : \u03b1 \u2192 Prop) (s : Set \u03b1) :\n    { x : Subtype P | (x : \u03b1) \u2208 s }.ncard = (s \u2229 setOf P).ncard", "start": [688, 1], "end": [692, 37], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_inter_le_ncard_left", "code": "theorem ncard_inter_le_ncard_left (s t : Set \u03b1) (hs : s.Finite := by toFinite_tac) :\n    (s \u2229 t).ncard \u2264 s.ncard", "start": [695, 1], "end": [697, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_inter_le_ncard_right", "code": "theorem ncard_inter_le_ncard_right (s t : Set \u03b1) (ht : t.Finite := by toFinite_tac) :\n    (s \u2229 t).ncard \u2264 t.ncard", "start": [700, 1], "end": [702, 49], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_subset_of_ncard_le", "code": "theorem eq_of_subset_of_ncard_le (h : s \u2286 t) (h' : t.ncard \u2264 s.ncard)\n    (ht : t.Finite := by toFinite_tac) : s = t", "start": [705, 1], "end": [708, 91], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iff_eq_of_ncard_le", "code": "theorem subset_iff_eq_of_ncard_le (h : t.ncard \u2264 s.ncard) (ht : t.Finite := by toFinite_tac) :\n    s \u2286 t \u2194 s = t", "start": [711, 1], "end": [713, 60], "kind": "commanddeclaration"}, {"full_name": "Set.map_eq_of_subset", "code": "theorem map_eq_of_subset {f : \u03b1 \u21aa \u03b1} (h : f '' s \u2286 s) (hs : s.Finite := by toFinite_tac) :\n    f '' s = s", "start": [716, 1], "end": [718, 49], "kind": "commanddeclaration"}, {"full_name": "Set.sep_of_ncard_eq", "code": "theorem sep_of_ncard_eq {P : \u03b1 \u2192 Prop} (h : { x \u2208 s | P x }.ncard = s.ncard) (ha : a \u2208 s)\n    (hs : s.Finite := by toFinite_tac) : P a", "start": [721, 1], "end": [723, 85], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_lt_ncard", "code": "theorem ncard_lt_ncard (h : s \u2282 t) (ht : t.Finite := by toFinite_tac) :\n    s.ncard < t.ncard", "start": [726, 1], "end": [729, 30], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_strictMono", "code": "theorem ncard_strictMono [Finite \u03b1] : @StrictMono (Set \u03b1) _ _ _ ncard", "start": [732, 1], "end": [733, 31], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_of_bijective", "code": "theorem ncard_eq_of_bijective {n : \u2115} (f : \u2200 i, i < n \u2192 \u03b1)\n    (hf : \u2200 a \u2208 s, \u2203 i, \u2203 h : i < n, f i h = a) (hf' : \u2200 (i) (h : i < n), f i h \u2208 s)\n    (f_inj : \u2200 (i j) (hi : i < n) (hj : j < n), f i hi = f j hj \u2192 i = j)\n    (hs : s.Finite := by toFinite_tac) :\n    s.ncard = n", "start": [736, 1], "end": [743, 18], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_congr", "code": "theorem ncard_congr {t : Set \u03b2} (f : \u2200 a \u2208 s, \u03b2) (h\u2081 : \u2200 a ha, f a ha \u2208 t)\n    (h\u2082 : \u2200 a b ha hb, f a ha = f b hb \u2192 a = b) (h\u2083 : \u2200 b \u2208 t, \u2203 a ha, f a ha = b) :\n    s.ncard = t.ncard", "start": [746, 1], "end": [760, 51], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_ncard_of_injOn", "code": "theorem ncard_le_ncard_of_injOn {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a \u2208 s, f a \u2208 t) (f_inj : InjOn f s)\n    (ht : t.Finite := by toFinite_tac) :\n    s.ncard \u2264 t.ncard", "start": [763, 1], "end": [767, 84], "kind": "commanddeclaration"}, {"full_name": "Set.exists_ne_map_eq_of_ncard_lt_of_maps_to", "code": "theorem exists_ne_map_eq_of_ncard_lt_of_maps_to {t : Set \u03b2} (hc : t.ncard < s.ncard) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Finite := by toFinite_tac) :\n    \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y", "start": [770, 1], "end": [775, 55], "kind": "commanddeclaration"}, {"full_name": "Set.le_ncard_of_inj_on_range", "code": "theorem le_ncard_of_inj_on_range {n : \u2115} (f : \u2115 \u2192 \u03b1) (hf : \u2200 i < n, f i \u2208 s)\n    (f_inj : \u2200 i < n, \u2200 j < n, f i = f j \u2192 i = j) (hs : s.Finite := by toFinite_tac) :\n    n \u2264 s.ncard", "start": [778, 1], "end": [782, 49], "kind": "commanddeclaration"}, {"full_name": "Set.surj_on_of_inj_on_of_ncard_le", "code": "theorem surj_on_of_inj_on_of_ncard_le {t : Set \u03b2} (f : \u2200 a \u2208 s, \u03b2) (hf : \u2200 a ha, f a ha \u2208 t)\n    (hinj : \u2200 a\u2081 a\u2082 ha\u2081 ha\u2082, f a\u2081 ha\u2081 = f a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082) (hst : t.ncard \u2264 s.ncard)\n    (ht : t.Finite := by toFinite_tac) :\n    \u2200 b \u2208 t, \u2203 a ha, b = f a ha", "start": [785, 1], "end": [804, 59], "kind": "commanddeclaration"}, {"full_name": "Set.inj_on_of_surj_on_of_ncard_le", "code": "theorem inj_on_of_surj_on_of_ncard_le {t : Set \u03b2} (f : \u2200 a \u2208 s, \u03b2) (hf : \u2200 a ha, f a ha \u2208 t)\n    (hsurj : \u2200 b \u2208 t, \u2203 a ha, b = f a ha) (hst : s.ncard \u2264 t.ncard) \u2983a\u2081 a\u2082\u2984 (ha\u2081 : a\u2081 \u2208 s)\n    (ha\u2082 : a\u2082 \u2208 s) (ha\u2081a\u2082 : f a\u2081 ha\u2081 = f a\u2082 ha\u2082) (hs : s.Finite := by toFinite_tac) :\n    a\u2081 = a\u2082", "start": [807, 1], "end": [825, 39], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_union_add_ncard_inter", "code": "theorem ncard_union_add_ncard_inter (s t : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s \u222a t).ncard + (s \u2229 t).ncard = s.ncard + t.ncard", "start": [830, 1], "end": [833, 86], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_inter_add_ncard_union", "code": "theorem ncard_inter_add_ncard_union (s t : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s \u2229 t).ncard + (s \u222a t).ncard = s.ncard + t.ncard", "start": [836, 1], "end": [838, 55], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_union_le", "code": "theorem ncard_union_le (s t : Set \u03b1) : (s \u222a t).ncard \u2264 s.ncard + t.ncard", "start": [841, 1], "end": [848, 16], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_union_eq", "code": "theorem ncard_union_eq (h : Disjoint s t) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s \u222a t).ncard = s.ncard + t.ncard", "start": [851, 1], "end": [854, 90], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_add_ncard_of_subset", "code": "theorem ncard_diff_add_ncard_of_subset (h : s \u2286 t) (ht : t.Finite := by toFinite_tac) :\n    (t \\ s).ncard + s.ncard = t.ncard", "start": [857, 1], "end": [861, 40], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff", "code": "theorem ncard_diff (h : s \u2286 t) (ht : t.Finite := by toFinite_tac) :\n    (t \\ s).ncard = t.ncard - s.ncard", "start": [864, 1], "end": [866, 68], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_ncard_diff_add_ncard", "code": "theorem ncard_le_ncard_diff_add_ncard (s t : Set \u03b1) (ht : t.Finite := by toFinite_tac) :\n    s.ncard \u2264 (s \\ t).ncard + t.ncard", "start": [869, 1], "end": [876, 16], "kind": "commanddeclaration"}, {"full_name": "Set.le_ncard_diff", "code": "theorem le_ncard_diff (s t : Set \u03b1) (hs : s.Finite := by toFinite_tac) :\n    t.ncard - s.ncard \u2264 (t \\ s).ncard", "start": [879, 1], "end": [881, 86], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_diff_add_ncard", "code": "theorem ncard_diff_add_ncard (s t : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n  (ht : t.Finite := by toFinite_tac) :\n    (s \\ t).ncard + t.ncard = (s \u222a t).ncard", "start": [884, 1], "end": [887, 75], "kind": "commanddeclaration"}, {"full_name": "Set.diff_nonempty_of_ncard_lt_ncard", "code": "theorem diff_nonempty_of_ncard_lt_ncard (h : s.ncard < t.ncard) (hs : s.Finite := by toFinite_tac) :\n    (t \\ s).Nonempty", "start": [890, 1], "end": [893, 53], "kind": "commanddeclaration"}, {"full_name": "Set.exists_mem_not_mem_of_ncard_lt_ncard", "code": "theorem exists_mem_not_mem_of_ncard_lt_ncard (h : s.ncard < t.ncard)\n    (hs : s.Finite := by toFinite_tac) : \u2203 e, e \u2208 t \u2227 e \u2209 s", "start": [896, 1], "end": [898, 39], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_inter_add_ncard_diff_eq_ncard", "code": "@[simp] theorem ncard_inter_add_ncard_diff_eq_ncard (s t : Set \u03b1)\n    (hs : s.Finite := by toFinite_tac) : (s \u2229 t).ncard + (s \\ t).ncard = s.ncard", "start": [901, 1], "end": [904, 68], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_ncard_iff_ncard_diff_eq_ncard_diff", "code": "theorem ncard_eq_ncard_iff_ncard_diff_eq_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard = t.ncard \u2194 (s \\ t).ncard = (t \\ s).ncard", "start": [907, 1], "end": [910, 31], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_ncard_iff_ncard_diff_le_ncard_diff", "code": "theorem ncard_le_ncard_iff_ncard_diff_le_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard \u2264 t.ncard \u2194 (s \\ t).ncard \u2264 (t \\ s).ncard", "start": [913, 1], "end": [916, 37], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_lt_ncard_iff_ncard_diff_lt_ncard_diff", "code": "theorem ncard_lt_ncard_iff_ncard_diff_lt_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard < t.ncard \u2194 (s \\ t).ncard < (t \\ s).ncard", "start": [919, 1], "end": [922, 37], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_add_ncard_compl", "code": "theorem ncard_add_ncard_compl (s : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n    (hsc : s\u1d9c.Finite := by toFinite_tac) : s.ncard + s\u1d9c.ncard = Nat.card \u03b1", "start": [925, 1], "end": [927, 93], "kind": "commanddeclaration"}, {"full_name": "Set.exists_intermediate_Set", "code": "theorem exists_intermediate_Set (i : \u2115) (h\u2081 : i + s.ncard \u2264 t.ncard) (h\u2082 : s \u2286 t) :\n    \u2203 r : Set \u03b1, s \u2286 r \u2227 r \u2286 t \u2227 r.ncard = i + s.ncard", "start": [932, 1], "end": [945, 40], "kind": "commanddeclaration"}, {"full_name": "Set.exists_intermediate_set'", "code": "theorem exists_intermediate_set' {m : \u2115} (hs : s.ncard \u2264 m) (ht : m \u2264 t.ncard) (h : s \u2286 t) :\n    \u2203 r : Set \u03b1, s \u2286 r \u2227 r \u2286 t \u2227 r.ncard = m", "start": [948, 1], "end": [953, 26], "kind": "commanddeclaration"}, {"full_name": "Set.exists_smaller_set", "code": "theorem exists_smaller_set (s : Set \u03b1) (i : \u2115) (h\u2081 : i \u2264 s.ncard) :\n    \u2203 t : Set \u03b1, t \u2286 s \u2227 t.ncard = i", "start": [956, 1], "end": [960, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_subset_ncard_eq", "code": "theorem Infinite.exists_subset_ncard_eq {s : Set \u03b1} (hs : s.Infinite) (k : \u2115) :\n    \u2203 t, t \u2286 s \u2227 t.Finite \u2227 t.ncard = k", "start": [963, 1], "end": [969, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_superset_ncard_eq", "code": "theorem Infinite.exists_superset_ncard_eq {s t : Set \u03b1} (ht : t.Infinite) (hst : s \u2286 t)\n    (hs : s.Finite) {k : \u2115} (hsk : s.ncard \u2264 k) : \u2203 s', s \u2286 s' \u2227 s' \u2286 t \u2227 s'.ncard = k", "start": [972, 1], "end": [977, 27], "kind": "commanddeclaration"}, {"full_name": "Set.exists_subset_or_subset_of_two_mul_lt_ncard", "code": "theorem exists_subset_or_subset_of_two_mul_lt_ncard {n : \u2115} (hst : 2 * n < (s \u222a t).ncard) :\n    \u2203 r : Set \u03b1, n < r.ncard \u2227 (r \u2286 s \u2228 r \u2286 t)", "start": [980, 1], "end": [988, 43], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_one", "code": "@[simp] theorem ncard_eq_one : s.ncard = 1 \u2194 \u2203 a, s = {a}", "start": [994, 1], "end": [1001, 11], "kind": "commanddeclaration"}, {"full_name": "Set.exists_eq_insert_iff_ncard", "code": "theorem exists_eq_insert_iff_ncard (hs : s.Finite := by toFinite_tac) :\n    (\u2203 (a : \u03b1) (_ : a \u2209 s), insert a s = t) \u2194 s \u2286 t \u2227 s.ncard + 1 = t.ncard", "start": [1004, 1], "end": [1015, 25], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_one", "code": "theorem ncard_le_one (hs : s.Finite := by toFinite_tac) :\n    s.ncard \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b", "start": [1018, 1], "end": [1020, 81], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_one_iff", "code": "theorem ncard_le_one_iff (hs : s.Finite := by toFinite_tac) :\n    s.ncard \u2264 1 \u2194 \u2200 {a b}, a \u2208 s \u2192 b \u2208 s \u2192 a = b", "start": [1023, 1], "end": [1026, 8], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_one_iff_eq", "code": "theorem ncard_le_one_iff_eq (hs : s.Finite := by toFinite_tac) :\n    s.ncard \u2264 1 \u2194 s = \u2205 \u2228 \u2203 a, s = {a}", "start": [1029, 1], "end": [1038, 62], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_one_iff_subset_singleton", "code": "theorem ncard_le_one_iff_subset_singleton [Nonempty \u03b1]\n    (hs : s.Finite := by toFinite_tac) :\n    s.ncard \u2264 1 \u2194 \u2203 x : \u03b1, s \u2286 {x}", "start": [1041, 1], "end": [1045, 50], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_le_one_of_subsingleton", "code": "theorem ncard_le_one_of_subsingleton [Subsingleton \u03b1] (s : Set \u03b1) : s.ncard \u2264 1", "start": [1048, 1], "end": [1051, 45], "kind": "commanddeclaration"}, {"full_name": "Set.one_lt_ncard", "code": "theorem one_lt_ncard (hs : s.Finite := by toFinite_tac) :\n    1 < s.ncard \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, a \u2260 b", "start": [1054, 1], "end": [1056, 81], "kind": "commanddeclaration"}, {"full_name": "Set.one_lt_ncard_iff", "code": "theorem one_lt_ncard_iff (hs : s.Finite := by toFinite_tac) :\n    1 < s.ncard \u2194 \u2203 a b, a \u2208 s \u2227 b \u2208 s \u2227 a \u2260 b", "start": [1059, 1], "end": [1062, 43], "kind": "commanddeclaration"}, {"full_name": "Set.two_lt_ncard_iff", "code": "theorem two_lt_ncard_iff (hs : s.Finite := by toFinite_tac) :\n    2 < s.ncard \u2194 \u2203 a b c, a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "start": [1065, 1], "end": [1067, 85], "kind": "commanddeclaration"}, {"full_name": "Set.two_lt_ncard", "code": "theorem two_lt_ncard (hs : s.Finite := by toFinite_tac) :\n    2 < s.ncard \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, \u2203 c \u2208 s, a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "start": [1070, 1], "end": [1072, 64], "kind": "commanddeclaration"}, {"full_name": "Set.exists_ne_of_one_lt_ncard", "code": "theorem exists_ne_of_one_lt_ncard (hs : 1 < s.ncard) (a : \u03b1) : \u2203 b, b \u2208 s \u2227 b \u2260 a", "start": [1075, 1], "end": [1078, 78], "kind": "commanddeclaration"}, {"full_name": "Set.eq_insert_of_ncard_eq_succ", "code": "theorem eq_insert_of_ncard_eq_succ {n : \u2115} (h : s.ncard = n + 1) :\n    \u2203 a t, a \u2209 t \u2227 insert a t = s \u2227 t.ncard = n", "start": [1081, 1], "end": [1091, 7], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_succ", "code": "theorem ncard_eq_succ {n : \u2115} (hs : s.Finite := by toFinite_tac) :\n    s.ncard = n + 1 \u2194 \u2203 a t, a \u2209 t \u2227 insert a t = s \u2227 t.ncard = n", "start": [1094, 1], "end": [1098, 85], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_two", "code": "theorem ncard_eq_two : s.ncard = 2 \u2194 \u2203 x y, x \u2260 y \u2227 s = {x, y}", "start": [1101, 1], "end": [1105, 14], "kind": "commanddeclaration"}, {"full_name": "Set.ncard_eq_three", "code": "theorem ncard_eq_three : s.ncard = 3 \u2194 \u2203 x y z, x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z \u2227 s = {x, y, z}", "start": [1108, 1], "end": [1112, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Free.lean", "imports": ["Mathlib/Algebra/FreeNonUnitalNonAssocAlgebra.lean", "Mathlib/Algebra/Lie/NonUnitalNonAssocAlgebra.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Lie/UniversalEnveloping.lean", "Mathlib/Algebra/Lie/OfAssociative.lean"], "premises": [{"full_name": "FreeLieAlgebra.Rel", "code": "inductive Rel : lib R X \u2192 lib R X \u2192 Prop\n  | lie_self (a : lib R X) : Rel (a * a) 0\n  | leibniz_lie (a b c : lib R X) : Rel (a * (b * c)) (a * b * c + b * (a * c))\n  | smul (t : R) {a b : lib R X} : Rel a b \u2192 Rel (t \u2022 a) (t \u2022 b)\n  | add_right {a b : lib R X} (c : lib R X) : Rel a b \u2192 Rel (a + c) (b + c)\n  | mul_left (a : lib R X) {b c : lib R X} : Rel b c \u2192 Rel (a * b) (a * c)\n  | mul_right {a b : lib R X} (c : lib R X) : Rel a b \u2192 Rel (a * c) (b * c)", "start": [79, 1], "end": [87, 76], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.Rel.addLeft", "code": "theorem Rel.addLeft (a : lib R X) {b c : lib R X} (h : Rel R X b c) : Rel R X (a + b) (a + c)", "start": [92, 1], "end": [93, 55], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.Rel.neg", "code": "theorem Rel.neg {a b : lib R X} (h : Rel R X a b) : Rel R X (-a) (-b)", "start": [96, 1], "end": [97, 46], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.Rel.subLeft", "code": "theorem Rel.subLeft (a : lib R X) {b c : lib R X} (h : Rel R X b c) : Rel R X (a - b) (a - c)", "start": [100, 1], "end": [101, 52], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.Rel.subRight", "code": "theorem Rel.subRight {a b : lib R X} (c : lib R X) (h : Rel R X a b) : Rel R X (a - c) (b - c)", "start": [104, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.Rel.smulOfTower", "code": "theorem Rel.smulOfTower {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (t : S)\n    (a b : lib R X) (h : Rel R X a b) : Rel R X (t \u2022 a) (t \u2022 b)", "start": [108, 1], "end": [111, 17], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra", "code": "def FreeLieAlgebra :=\n  Quot (FreeLieAlgebra.Rel R X)", "start": [116, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.of", "code": "def of : X \u2192 FreeLieAlgebra R X := fun x => Quot.mk _ (lib.of R x)", "start": [175, 1], "end": [177, 67], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.liftAux", "code": "def liftAux (f : X \u2192 CommutatorRing L) :=\n  lib.lift R f", "start": [182, 1], "end": [184, 15], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.liftAux_map_smul", "code": "theorem liftAux_map_smul (f : X \u2192 L) (t : R) (a : lib R X) :\n    liftAux R f (t \u2022 a) = t \u2022 liftAux R f a", "start": [187, 1], "end": [189, 33], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.liftAux_map_add", "code": "theorem liftAux_map_add (f : X \u2192 L) (a b : lib R X) :\n    liftAux R f (a + b) = liftAux R f a + liftAux R f b", "start": [192, 1], "end": [194, 32], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.liftAux_map_mul", "code": "theorem liftAux_map_mul (f : X \u2192 L) (a b : lib R X) :\n    liftAux R f (a * b) = \u2045liftAux R f a, liftAux R f b\u2046", "start": [197, 1], "end": [199, 32], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.liftAux_spec", "code": "theorem liftAux_spec (f : X \u2192 L) (a b : lib R X) (h : FreeLieAlgebra.Rel R X a b) :\n    liftAux R f a = liftAux R f b", "start": [202, 1], "end": [211, 66], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.mk", "code": "def mk : lib R X \u2192\u2099\u2090[R] CommutatorRing (FreeLieAlgebra R X) where\n  toFun := Quot.mk (Rel R X)\n  map_smul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [214, 1], "end": [220, 22], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.lift", "code": "def lift : (X \u2192 L) \u2243 (FreeLieAlgebra R X \u2192\u2097\u2045R\u2046 L) where\n  toFun f :=\n    { toFun := fun c => Quot.liftOn c (liftAux R f) (liftAux_spec R f)\n      map_add' := by rintro \u27e8a\u27e9 \u27e8b\u27e9; rw [\u2190 liftAux_map_add]; rfl\n      map_smul' := by rintro t \u27e8a\u27e9; rw [\u2190 liftAux_map_smul]; rfl\n      map_lie' := by rintro \u27e8a\u27e9 \u27e8b\u27e9; rw [\u2190 liftAux_map_mul]; rfl }\n  invFun F := F \u2218 of R\n  left_inv f := by\n    ext x;\n    simp only [liftAux, of, Quot.liftOn_mk, LieHom.coe_mk, Function.comp_apply, lib.lift_of_apply]\n  right_inv F := by\n    ext \u27e8a\u27e9\n    let F' := F.toNonUnitalAlgHom.comp (mk R)\n    exact NonUnitalAlgHom.congr_fun (lib.lift_comp_of R F') a", "start": [223, 1], "end": [238, 62], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : FreeLieAlgebra R X \u2192\u2097\u2045R\u2046 L) : (lift R).symm F = F \u2218 of R", "start": [241, 1], "end": [242, 93], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.of_comp_lift", "code": "@[simp]\ntheorem of_comp_lift (f : X \u2192 L) : lift R f \u2218 of R = f", "start": [247, 1], "end": [248, 78], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.lift_unique", "code": "@[simp]\ntheorem lift_unique (f : X \u2192 L) (g : FreeLieAlgebra R X \u2192\u2097\u2045R\u2046 L) : g \u2218 of R = f \u2194 g = lift R f", "start": [251, 1], "end": [253, 25], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.lift_of_apply", "code": "@[simp]\ntheorem lift_of_apply (f : X \u2192 L) (x) : lift R f (of R x) = f x", "start": [256, 1], "end": [258, 70], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.lift_comp_of", "code": "@[simp]\ntheorem lift_comp_of (F : FreeLieAlgebra R X \u2192\u2097\u2045R\u2046 L) : lift R (F \u2218 of R) = F", "start": [261, 1], "end": [263, 60], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.hom_ext", "code": "@[ext]\ntheorem hom_ext {F\u2081 F\u2082 : FreeLieAlgebra R X \u2192\u2097\u2045R\u2046 L} (h : \u2200 x, F\u2081 (of R x) = F\u2082 (of R x)) :\n    F\u2081 = F\u2082", "start": [266, 1], "end": [270, 29], "kind": "commanddeclaration"}, {"full_name": "FreeLieAlgebra.universalEnvelopingEquivFreeAlgebra", "code": "@[simps!]\ndef universalEnvelopingEquivFreeAlgebra :\n    UniversalEnvelopingAlgebra R (FreeLieAlgebra R X) \u2243\u2090[R] FreeAlgebra R X :=\n  AlgEquiv.ofAlgHom (UniversalEnvelopingAlgebra.lift R <| FreeLieAlgebra.lift R <| FreeAlgebra.\u03b9 R)\n    (FreeAlgebra.lift R <| UniversalEnvelopingAlgebra.\u03b9 R \u2218 FreeLieAlgebra.of R) (by ext; simp)\n    (by ext; simp)", "start": [275, 1], "end": [282, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Sub/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Algebra/Order/Sub/Defs.lean"], "premises": [{"full_name": "AddHom.le_map_tsub", "code": "theorem AddHom.le_map_tsub [Preorder \u03b2] [Add \u03b2] [Sub \u03b2] [OrderedSub \u03b2] (f : AddHom \u03b1 \u03b2)\n    (hf : Monotone f) (a b : \u03b1) : f a - f b \u2264 f (a - b)", "start": [25, 1], "end": [28, 23], "kind": "commanddeclaration"}, {"full_name": "le_mul_tsub", "code": "theorem le_mul_tsub {R : Type*} [Distrib R] [Preorder R] [Sub R] [OrderedSub R]\n    [CovariantClass R R (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : R} : a * b - a * c \u2264 a * (b - c)", "start": [31, 1], "end": [33, 64], "kind": "commanddeclaration"}, {"full_name": "le_tsub_mul", "code": "theorem le_tsub_mul {R : Type*} [CommSemiring R] [Preorder R] [Sub R] [OrderedSub R]\n    [CovariantClass R R (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : R} : a * c - b * c \u2264 (a - b) * c", "start": [36, 1], "end": [38, 46], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_tsub", "code": "theorem OrderIso.map_tsub {M N : Type*} [Preorder M] [Add M] [Sub M] [OrderedSub M]\n    [PartialOrder N] [Add N] [Sub N] [OrderedSub N] (e : M \u2243o N)\n    (h_add : \u2200 a b, e (a + b) = e a + e b) (a b : M) : e (a - b) = e a - e b", "start": [43, 1], "end": [51, 73], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.le_map_tsub", "code": "theorem AddMonoidHom.le_map_tsub [Preorder \u03b2] [AddCommMonoid \u03b2] [Sub \u03b2] [OrderedSub \u03b2] (f : \u03b1 \u2192+ \u03b2)\n    (hf : Monotone f) (a b : \u03b1) : f a - f b \u2264 f (a - b)", "start": [63, 1], "end": [65, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Endofunctor/Algebra.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Endofunctor.Algebra", "code": "structure Algebra (F : C \u2964 C) where\n  \n  a : C\n  \n  str : F.obj a \u27f6 a", "start": [36, 1], "end": [41, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Hom", "code": "@[ext]\nstructure Hom (A\u2080 A\u2081 : Algebra F) where\n  \n  f : A\u2080.1 \u27f6 A\u2081.1\n  \n  h : F.map f \u226b A\u2081.str = A\u2080.str \u226b f := by aesop_cat", "start": [62, 1], "end": [68, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Hom.id", "code": "def id : Hom A A where f := \ud835\udfd9 _", "start": [79, 1], "end": [80, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Hom.comp", "code": "def comp (f : Hom A\u2080 A\u2081) (g : Hom A\u2081 A\u2082) : Hom A\u2080 A\u2082 where f := f.1 \u226b g.1", "start": [86, 1], "end": [87, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.ext", "code": "@[ext]\nlemma ext {A B : Algebra F} {f g : A \u27f6 B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext _ _ w", "start": [97, 1], "end": [99, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.id_eq_id", "code": "@[simp]\ntheorem id_eq_id : Algebra.Hom.id A = \ud835\udfd9 A", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.id_f", "code": "@[simp]\ntheorem id_f : (\ud835\udfd9 _ : A \u27f6 A).1 = \ud835\udfd9 A.1", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.comp_eq_comp", "code": "@[simp]\ntheorem comp_eq_comp : Algebra.Hom.comp f g = f \u226b g", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.comp_f", "code": "@[simp]\ntheorem comp_f : (f \u226b g).1 = f.1 \u226b g.1", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.isoMk", "code": "@[simps!]\ndef isoMk (h : A\u2080.1 \u2245 A\u2081.1) (w : F.map h.hom \u226b A\u2081.str = A\u2080.str \u226b h.hom := by aesop_cat) :\n    A\u2080 \u2245 A\u2081 where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, \u2190 w, \u2190 Functor.map_comp_assoc]\n        simp }", "start": [126, 1], "end": [137, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.forget", "code": "@[simps]\ndef forget (F : C \u2964 C) : Algebra F \u2964 C where\n  obj A := A.1\n  map := Hom.f", "start": [140, 1], "end": [144, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.iso_of_iso", "code": "theorem iso_of_iso (f : A\u2080 \u27f6 A\u2081) [IsIso f.1] : IsIso f", "start": [147, 1], "end": [152, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.forget_reflects_iso", "code": "instance forget_reflects_iso : ReflectsIsomorphisms (forget F) where reflects := iso_of_iso", "start": [155, 1], "end": [155, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.forget_faithful", "code": "instance forget_faithful : Faithful (forget F) := { }", "start": [158, 1], "end": [158, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.epi_of_epi", "code": "theorem epi_of_epi {X Y : Algebra F} (f : X \u27f6 Y) [h : Epi f.1] : Epi f", "start": [161, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.mono_of_mono", "code": "theorem mono_of_mono {X Y : Algebra F} (f : X \u27f6 Y) [h : Mono f.1] : Mono f", "start": [166, 1], "end": [168, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.functorOfNatTrans", "code": "@[simps]\ndef functorOfNatTrans {F G : C \u2964 C} (\u03b1 : G \u27f6 F) : Algebra F \u2964 Algebra G where\n  obj A :=\n    { a := A.1\n      str := \u03b1.app _ \u226b A.str }\n  map f := { f := f.1 }", "start": [171, 1], "end": [179, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.functorOfNatTransId", "code": "@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (\ud835\udfd9 F) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [182, 1], "end": [186, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.functorOfNatTransComp", "code": "@[simps!]\ndef functorOfNatTransComp {F\u2080 F\u2081 F\u2082 : C \u2964 C} (\u03b1 : F\u2080 \u27f6 F\u2081) (\u03b2 : F\u2081 \u27f6 F\u2082) :\n    functorOfNatTrans (\u03b1 \u226b \u03b2) \u2245 functorOfNatTrans \u03b2 \u22d9 functorOfNatTrans \u03b1 :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [189, 1], "end": [194, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.functorOfNatTransEq", "code": "@[simps!]\ndef functorOfNatTransEq {F G : C \u2964 C} {\u03b1 \u03b2 : F \u27f6 G} (h : \u03b1 = \u03b2) :\n    functorOfNatTrans \u03b1 \u2245 functorOfNatTrans \u03b2 :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [197, 1], "end": [207, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.equivOfNatIso", "code": "@[simps]\ndef equivOfNatIso {F G : C \u2964 C} (\u03b1 : F \u2245 G) : Algebra F \u224c Algebra G where\n  functor := functorOfNatTrans \u03b1.inv\n  inverse := functorOfNatTrans \u03b1.hom\n  unitIso := functorOfNatTransId.symm \u226a\u226b functorOfNatTransEq (by simp) \u226a\u226b functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm \u226a\u226b functorOfNatTransEq (by simp) \u226a\u226b functorOfNatTransId", "start": [210, 1], "end": [220, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Initial.strInv", "code": "@[simp]\ndef strInv : A.1 \u27f6 F.obj A.1 :=\n  (h.to \u27e8F.obj A.a, F.map A.str\u27e9).f", "start": [226, 1], "end": [229, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Initial.left_inv'", "code": "theorem left_inv' : \u27e8strInv h \u226b A.str, by rw [\u2190Category.assoc, F.map_comp, strInv, \u2190Hom.h]\u27e9 = \ud835\udfd9 A", "start": [233, 1], "end": [234, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Initial.left_inv", "code": "theorem left_inv : strInv h \u226b A.str = \ud835\udfd9 _", "start": [237, 1], "end": [238, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Initial.right_inv", "code": "theorem right_inv : A.str \u226b strInv h = \ud835\udfd9 _", "start": [241, 1], "end": [244, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Algebra.Initial.str_isIso", "code": "theorem str_isIso (h : Limits.IsInitial A) : IsIso A.str", "start": [247, 1], "end": [251, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra", "code": "structure Coalgebra (F : C \u2964 C) where\n  \n  V : C\n  \n  str : V \u27f6 F.obj V", "start": [258, 1], "end": [263, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.Hom", "code": "@[ext]\nstructure Hom (V\u2080 V\u2081 : Coalgebra F) where\n  \n  f : V\u2080.1 \u27f6 V\u2081.1\n  \n  h : V\u2080.str \u226b F.map f = f \u226b V\u2081.str := by aesop_cat", "start": [284, 1], "end": [290, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.Hom.id", "code": "def id : Hom V V where f := \ud835\udfd9 _", "start": [301, 1], "end": [302, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.Hom.comp", "code": "def comp (f : Hom V\u2080 V\u2081) (g : Hom V\u2081 V\u2082) : Hom V\u2080 V\u2082 where f := f.1 \u226b g.1", "start": [308, 1], "end": [309, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.ext", "code": "@[ext]\nlemma ext {A B : Coalgebra F} {f g : A \u27f6 B} (w : f.f = g.f := by aesop_cat) : f = g :=\n  Hom.ext _ _ w", "start": [319, 1], "end": [321, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.id_eq_id", "code": "@[simp]\ntheorem id_eq_id : Coalgebra.Hom.id V = \ud835\udfd9 V", "start": [323, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.id_f", "code": "@[simp]\ntheorem id_f : (\ud835\udfd9 _ : V \u27f6 V).1 = \ud835\udfd9 V.1", "start": [328, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.comp_eq_comp", "code": "@[simp]\ntheorem comp_eq_comp : Coalgebra.Hom.comp f g = f \u226b g", "start": [335, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.comp_f", "code": "@[simp]\ntheorem comp_f : (f \u226b g).1 = f.1 \u226b g.1", "start": [340, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.isoMk", "code": "@[simps]\ndef isoMk (h : V\u2080.1 \u2245 V\u2081.1) (w : V\u2080.str \u226b F.map h.hom = h.hom \u226b V\u2081.str := by aesop_cat) :\n    V\u2080 \u2245 V\u2081 where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, \u2190Category.assoc, \u2190 w, Category.assoc, \u2190 F.map_comp]\n        simp only [Iso.hom_inv_id, Functor.map_id, Category.comp_id] }", "start": [348, 1], "end": [359, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.forget", "code": "@[simps]\ndef forget (F : C \u2964 C) : Coalgebra F \u2964 C where\n  obj A := A.1\n  map f := f.1", "start": [362, 1], "end": [366, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.iso_of_iso", "code": "theorem iso_of_iso (f : V\u2080 \u27f6 V\u2081) [IsIso f.1] : IsIso f", "start": [369, 1], "end": [374, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.forget_reflects_iso", "code": "instance forget_reflects_iso : ReflectsIsomorphisms (forget F) where reflects := iso_of_iso", "start": [377, 1], "end": [377, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.forget_faithful", "code": "instance forget_faithful : Faithful (forget F) := { }", "start": [380, 1], "end": [380, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.epi_of_epi", "code": "theorem epi_of_epi {X Y : Coalgebra F} (f : X \u27f6 Y) [h : Epi f.1] : Epi f", "start": [383, 1], "end": [385, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.mono_of_mono", "code": "theorem mono_of_mono {X Y : Coalgebra F} (f : X \u27f6 Y) [h : Mono f.1] : Mono f", "start": [388, 1], "end": [390, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.functorOfNatTrans", "code": "@[simps]\ndef functorOfNatTrans {F G : C \u2964 C} (\u03b1 : F \u27f6 G) : Coalgebra F \u2964 Coalgebra G where\n  obj V :=\n    { V := V.1\n      str := V.str \u226b \u03b1.app V.1 }\n  map f :=\n    { f := f.1\n      h := by rw [Category.assoc, \u2190 \u03b1.naturality, \u2190 Category.assoc, f.h, Category.assoc] }", "start": [393, 1], "end": [403, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransId", "code": "@[simps!]\ndef functorOfNatTransId : functorOfNatTrans (\ud835\udfd9 F) \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [406, 1], "end": [410, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransComp", "code": "@[simps!]\ndef functorOfNatTransComp {F\u2080 F\u2081 F\u2082 : C \u2964 C} (\u03b1 : F\u2080 \u27f6 F\u2081) (\u03b2 : F\u2081 \u27f6 F\u2082) :\n    functorOfNatTrans (\u03b1 \u226b \u03b2) \u2245 functorOfNatTrans \u03b1 \u22d9 functorOfNatTrans \u03b2 :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [414, 1], "end": [419, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.functorOfNatTransEq", "code": "@[simps!]\ndef functorOfNatTransEq {F G : C \u2964 C} {\u03b1 \u03b2 : F \u27f6 G} (h : \u03b1 = \u03b2) :\n    functorOfNatTrans \u03b1 \u2245 functorOfNatTrans \u03b2 :=\n  NatIso.ofComponents fun X => isoMk (Iso.refl _)", "start": [422, 1], "end": [431, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Coalgebra.equivOfNatIso", "code": "@[simps]\ndef equivOfNatIso {F G : C \u2964 C} (\u03b1 : F \u2245 G) : Coalgebra F \u224c Coalgebra G where\n  functor := functorOfNatTrans \u03b1.hom\n  inverse := functorOfNatTrans \u03b1.inv\n  unitIso := functorOfNatTransId.symm \u226a\u226b functorOfNatTransEq (by simp) \u226a\u226b functorOfNatTransComp _ _\n  counitIso :=\n    (functorOfNatTransComp _ _).symm \u226a\u226b functorOfNatTransEq (by simp) \u226a\u226b functorOfNatTransId", "start": [434, 1], "end": [444, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.Algebra.homEquiv_naturality_str", "code": "theorem Algebra.homEquiv_naturality_str (adj : F \u22a3 G) (A\u2081 A\u2082 : Algebra F) (f : A\u2081 \u27f6 A\u2082) :\n    (adj.homEquiv A\u2081.a A\u2081.a) A\u2081.str \u226b G.map f.f = f.f \u226b (adj.homEquiv A\u2082.a A\u2082.a) A\u2082.str", "start": [453, 1], "end": [455, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.Coalgebra.homEquiv_naturality_str_symm", "code": "theorem Coalgebra.homEquiv_naturality_str_symm (adj : F \u22a3 G) (V\u2081 V\u2082 : Coalgebra G) (f : V\u2081 \u27f6 V\u2082) :\n    F.map f.f \u226b (adj.homEquiv V\u2082.V V\u2082.V).symm V\u2082.str =\n    (adj.homEquiv V\u2081.V V\u2081.V).symm V\u2081.str \u226b f.f", "start": [458, 1], "end": [462, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.Algebra.toCoalgebraOf", "code": "def Algebra.toCoalgebraOf (adj : F \u22a3 G) : Algebra F \u2964 Coalgebra G where\n  obj A :=\n    { V := A.1\n      str := (adj.homEquiv A.1 A.1).toFun A.2 }\n  map f :=\n    { f := f.1\n      h := Algebra.homEquiv_naturality_str adj _ _ f }", "start": [465, 1], "end": [473, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.Coalgebra.toAlgebraOf", "code": "def Coalgebra.toAlgebraOf (adj : F \u22a3 G) : Coalgebra G \u2964 Algebra F where\n  obj V :=\n    { a := V.1\n      str := (adj.homEquiv V.1 V.1).invFun V.2 }\n  map f :=\n    { f := f.1\n      h := Coalgebra.homEquiv_naturality_str_symm adj _ _ f }", "start": [476, 1], "end": [484, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.AlgCoalgEquiv.unitIso", "code": "def AlgCoalgEquiv.unitIso (adj : F \u22a3 G) :\n    \ud835\udfed (Algebra F) \u2245 Algebra.toCoalgebraOf adj \u22d9 Coalgebra.toAlgebraOf adj where\n  hom :=\n    { app := fun A =>\n        { f := \ud835\udfd9 A.1\n          h := by\n            erw [F.map_id, Category.id_comp, Category.comp_id]\n            apply (adj.homEquiv _ _).left_inv A.str } }\n  inv :=\n    { app := fun A =>\n        { f := \ud835\udfd9 A.1\n          h := by\n            erw [F.map_id, Category.id_comp, Category.comp_id]\n            apply ((adj.homEquiv _ _).left_inv A.str).symm }\n      naturality := fun A\u2081 A\u2082 f => by\n        ext\n        dsimp\n        erw [Category.comp_id, Category.id_comp]\n        rfl }", "start": [487, 1], "end": [507, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.AlgCoalgEquiv.counitIso", "code": "def AlgCoalgEquiv.counitIso (adj : F \u22a3 G) :\n    Coalgebra.toAlgebraOf adj \u22d9 Algebra.toCoalgebraOf adj \u2245 \ud835\udfed (Coalgebra G) where\n  hom :=\n    { app := fun V =>\n        { f := \ud835\udfd9 V.1\n          h := by\n            dsimp\n            erw [G.map_id, Category.id_comp, Category.comp_id]\n            apply (adj.homEquiv _ _).right_inv V.str }\n      naturality := fun V\u2081 V\u2082 f => by\n        ext\n        dsimp\n        erw [Category.comp_id, Category.id_comp]\n        rfl }\n  inv :=\n    { app := fun V =>\n        { f := \ud835\udfd9 V.1\n          h := by\n            dsimp\n            rw [G.map_id, Category.comp_id, Category.id_comp]\n            apply ((adj.homEquiv _ _).right_inv V.str).symm } }", "start": [510, 1], "end": [532, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Endofunctor.Adjunction.algebraCoalgebraEquiv", "code": "def algebraCoalgebraEquiv (adj : F \u22a3 G) : Algebra F \u224c Coalgebra G where\n  functor := Algebra.toCoalgebraOf adj\n  inverse := Coalgebra.toAlgebraOf adj\n  unitIso := AlgCoalgEquiv.unitIso adj\n  counitIso := AlgCoalgEquiv.counitIso adj\n  functor_unitIso_comp A := by\n    ext\n    exact Category.comp_id _", "start": [535, 1], "end": [545, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Chebyshev.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "Mathlib/Data/Polynomial/Derivative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.Chebyshev.T", "code": "noncomputable def T : \u2115 \u2192 R[X]\n  | 0 => 1\n  | 1 => X\n  | n + 2 => 2 * X * T (n + 1) - T n", "start": [66, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_zero", "code": "@[simp]\ntheorem T_zero : T R 0 = 1", "start": [73, 1], "end": [74, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_one", "code": "@[simp]\ntheorem T_one : T R 1 = X", "start": [77, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_add_two", "code": "@[simp]\ntheorem T_add_two (n : \u2115) : T R (n + 2) = 2 * X * T R (n + 1) - T R n", "start": [81, 1], "end": [82, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_two", "code": "theorem T_two : T R 2 = 2 * X ^ 2 - 1", "start": [85, 1], "end": [85, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_of_two_le", "code": "theorem T_of_two_le (n : \u2115) (h : 2 \u2264 n) : T R n = 2 * X * T R (n - 1) - T R (n - 2)", "start": [88, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U", "code": "noncomputable def U : \u2115 \u2192 R[X]\n  | 0 => 1\n  | 1 => 2 * X\n  | n + 2 => 2 * X * U (n + 1) - U n", "start": [94, 1], "end": [98, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_zero", "code": "@[simp]\ntheorem U_zero : U R 0 = 1", "start": [101, 1], "end": [102, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_one", "code": "@[simp]\ntheorem U_one : U R 1 = 2 * X", "start": [105, 1], "end": [106, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_add_two", "code": "@[simp]\ntheorem U_add_two (n : \u2115) : U R (n + 2) = 2 * X * U R (n + 1) - U R n", "start": [109, 1], "end": [110, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_two", "code": "theorem U_two : U R 2 = 4 * X ^ 2 - 1", "start": [113, 1], "end": [115, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_of_two_le", "code": "theorem U_of_two_le (n : \u2115) (h : 2 \u2264 n) : U R n = 2 * X * U R (n - 1) - U R (n - 2)", "start": [118, 1], "end": [121, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.U_eq_X_mul_U_add_T", "code": "theorem U_eq_X_mul_U_add_T : \u2200 n : \u2115, U R (n + 1) = X * U R n + T R (n + 1)", "start": [124, 1], "end": [132, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_eq_U_sub_X_mul_U", "code": "theorem T_eq_U_sub_X_mul_U (n : \u2115) : T R (n + 1) = U R (n + 1) - X * U R n", "start": [135, 1], "end": [136, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_eq_X_mul_T_sub_pol_U", "code": "theorem T_eq_X_mul_T_sub_pol_U : \u2200 n : \u2115, T R (n + 2) = X * T R (n + 1) - (1 - X ^ 2) * U R n", "start": [139, 1], "end": [150, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.one_sub_X_sq_mul_U_eq_pol_in_T", "code": "theorem one_sub_X_sq_mul_U_eq_pol_in_T (n : \u2115) :\n    (1 - X ^ 2) * U R n = X * T R (n + 1) - T R (n + 2)", "start": [153, 1], "end": [155, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.map_T", "code": "@[simp]\ntheorem map_T (f : R \u2192+* S) : \u2200 n : \u2115, map f (T R n) = T S n", "start": [160, 1], "end": [166, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.map_U", "code": "@[simp]\ntheorem map_U (f : R \u2192+* S) : \u2200 n : \u2115, map f (U R n) = U S n", "start": [169, 1], "end": [177, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_derivative_eq_U", "code": "theorem T_derivative_eq_U : \u2200 n : \u2115, derivative (T R (n + 1)) = (n + 1) * U R n", "start": [180, 1], "end": [197, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.one_sub_X_sq_mul_derivative_T_eq_poly_in_T", "code": "theorem one_sub_X_sq_mul_derivative_T_eq_poly_in_T (n : \u2115) :\n    (1 - X ^ 2) * derivative (T R (n + 1)) = (n + 1 : R[X]) * (T R n - X * T R (n + 1))", "start": [200, 1], "end": [208, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.add_one_mul_T_eq_poly_in_U", "code": "theorem add_one_mul_T_eq_poly_in_U (n : \u2115) :\n    ((n : R[X]) + 1) * T R (n + 1) = X * U R n - (1 - X ^ 2) * derivative (U R n)", "start": [211, 1], "end": [233, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.mul_T", "code": "theorem mul_T : \u2200 m k, 2 * T R m * T R (m + k) = T R (2 * m + k) + T R k", "start": [238, 1], "end": [265, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Chebyshev.T_mul", "code": "theorem T_mul : \u2200 m n, T R (m * n) = (T R m).comp (T R n)", "start": [268, 1], "end": [276, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/ConformalLinearMap.lean", "imports": ["Mathlib/Analysis/NormedSpace/ConformalLinearMap.lean", "Mathlib/Analysis/InnerProductSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isConformalMap_iff", "code": "theorem isConformalMap_iff (f : E \u2192L[\u211d] F) :\n    IsConformalMap f \u2194 \u2203 c : \u211d, 0 < c \u2227 \u2200 u v : E, \u27eaf u, f v\u27eb = c * \u27eau, v\u27eb", "start": [28, 1], "end": [45, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/FundamentalGroup.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "Mathlib/Topology/Connected/PathConnected.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "Mathlib/Topology/Homotopy/Path.lean"], "premises": [{"full_name": "FundamentalGroup", "code": "def FundamentalGroup (X : Type u) [TopologicalSpace X] (x : X) :=\n  @Aut (FundamentalGroupoid X) _ x", "start": [32, 1], "end": [35, 35], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.fundamentalGroupMulEquivOfPath", "code": "def fundamentalGroupMulEquivOfPath (p : Path x\u2080 x\u2081) :\n    FundamentalGroup X x\u2080 \u2243* FundamentalGroup X x\u2081 :=\n  Aut.autMulEquivOfIso (asIso \u27e6p\u27e7)", "start": [53, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.fundamentalGroupMulEquivOfPathConnected", "code": "def fundamentalGroupMulEquivOfPathConnected [PathConnectedSpace X] :\n    FundamentalGroup X x\u2080 \u2243* FundamentalGroup X x\u2081 :=\n  fundamentalGroupMulEquivOfPath (PathConnectedSpace.somePath x\u2080 x\u2081)", "start": [61, 1], "end": [64, 69], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.toArrow", "code": "abbrev toArrow {X : TopCat} {x : X} (p : FundamentalGroup X x) : x \u27f6 x :=\n  p.hom", "start": [67, 1], "end": [69, 8], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.toPath", "code": "abbrev toPath {X : TopCat} {x : X} (p : FundamentalGroup X x) : Path.Homotopic.Quotient x x :=\n  toArrow p", "start": [72, 1], "end": [74, 12], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.fromArrow", "code": "abbrev fromArrow {X : TopCat} {x : X} (p : x \u27f6 x) : FundamentalGroup X x where\n  hom := p\n  inv := CategoryTheory.Groupoid.inv p", "start": [77, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroup.fromPath", "code": "abbrev fromPath {X : TopCat} {x : X} (p : Path.Homotopic.Quotient x x) : FundamentalGroup X x :=\n  fromArrow p", "start": [83, 1], "end": [85, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/EckmannHilton.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EckmannHilton.IsUnital", "code": "structure IsUnital (m : X \u2192 X \u2192 X) (e : X) extends IsLeftId _ m e, IsRightId _ m e : Prop", "start": [35, 1], "end": [37, 90], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.MulOneClass.isUnital", "code": "@[to_additive EckmannHilton.AddZeroClass.IsUnital]\ntheorem MulOneClass.isUnital [_G : MulOneClass X] : IsUnital (\u00b7 * \u00b7) (1 : X)", "start": [40, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.one", "code": "theorem one : e\u2081 = e\u2082", "start": [52, 1], "end": [58, 90], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.mul", "code": "theorem mul : m\u2081 = m\u2082", "start": [61, 1], "end": [70, 91], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.mul_comm", "code": "theorem mul_comm : IsCommutative _ m\u2082", "start": [73, 1], "end": [78, 93], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.mul_assoc", "code": "theorem mul_assoc : IsAssociative _ m\u2082", "start": [81, 1], "end": [86, 94], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.commMonoid", "code": "@[to_additive (attr := reducible)\n      \"If a type carries a unital additive magma structure that distributes over a unital binary\n      operation, then the additive magma structure is a commutative additive monoid.\"]\ndef commMonoid [h : MulOneClass X]\n    (distrib : \u2200 a b c d, ((a * b) <m\u2081> c * d) = (a <m\u2081> c) * b <m\u2081> d) : CommMonoid X :=\n  { h with\n      mul_comm := (mul_comm h\u2081 MulOneClass.isUnital distrib).comm,\n      mul_assoc := (mul_assoc h\u2081 MulOneClass.isUnital distrib).assoc }", "start": [89, 1], "end": [98, 71], "kind": "commanddeclaration"}, {"full_name": "EckmannHilton.commGroup", "code": "@[to_additive (attr := reducible)\n      \"If a type carries an additive group structure that distributes over a unital binary\n      operation, then the additive group is commutative.\"]\ndef commGroup [G : Group X]\n    (distrib : \u2200 a b c d, ((a * b) <m\u2081> c * d) = (a <m\u2081> c) * b <m\u2081> d) : CommGroup X :=\n  { EckmannHilton.commMonoid h\u2081 distrib, G with .. }", "start": [102, 1], "end": [109, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/QuasiCompact.lean", "imports": ["Mathlib/AlgebraicGeometry/Limits.lean", "Mathlib/Topology/Spectral/Hom.lean", "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.QuasiCompact", "code": "@[mk_iff]\nclass QuasiCompact (f : X \u27f6 Y) : Prop where\n  \n  isCompact_preimage : \u2200 U : Set Y.carrier, IsOpen U \u2192 IsCompact U \u2192 IsCompact (f.1.base \u207b\u00b9' U)", "start": [36, 1], "end": [43, 96], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_iff_spectral", "code": "theorem quasiCompact_iff_spectral : QuasiCompact f \u2194 IsSpectralMap f.1.base", "start": [46, 1], "end": [47, 50], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affineProperty", "code": "def QuasiCompact.affineProperty : AffineTargetMorphismProperty := fun X _ _ _ =>\n  CompactSpace X.carrier", "start": [50, 1], "end": [53, 25], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompactOfIsIso", "code": "instance (priority := 900) quasiCompactOfIsIso {X Y : Scheme} (f : X \u27f6 Y) [IsIso f] :\n    QuasiCompact f := by\n  constructor\n  intro U _ hU'\n  convert hU'.image (inv f.1.base).continuous_toFun using 1\n  rw [Set.image_eq_preimage_of_inverse]\n  delta Function.LeftInverse\n  exacts [IsIso.inv_hom_id_apply f.1.base, IsIso.hom_inv_id_apply f.1.base]", "start": [56, 1], "end": [63, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompactComp", "code": "instance quasiCompactComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [QuasiCompact f]\n    [QuasiCompact g] : QuasiCompact (f \u226b g) := by\n  constructor\n  intro U hU hU'\n  rw [Scheme.comp_val_base, coe_comp, Set.preimage_comp]\n  apply QuasiCompact.isCompact_preimage\n  \u00b7 exact Continuous.isOpen_preimage (by\n    exact Scheme.Hom.continuous g) _ hU\n  apply QuasiCompact.isCompact_preimage <;> assumption", "start": [66, 1], "end": [76, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isCompact_open_iff_eq_finset_affine_union", "code": "theorem isCompact_open_iff_eq_finset_affine_union {X : Scheme} (U : Set X.carrier) :\n    IsCompact U \u2227 IsOpen U \u2194\n      \u2203 s : Set X.affineOpens, s.Finite \u2227 U = \u22c3 (i : X.affineOpens) (_ : i \u2208 s), i", "start": [79, 1], "end": [85, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isCompact_open_iff_eq_basicOpen_union", "code": "theorem isCompact_open_iff_eq_basicOpen_union {X : Scheme} [IsAffine X] (U : Set X.carrier) :\n    IsCompact U \u2227 IsOpen U \u2194\n      \u2203 s : Set (X.presheaf.obj (op \u22a4)),\n        s.Finite \u2227 U = \u22c3 (i : X.presheaf.obj (op \u22a4)) (_ : i \u2208 s), X.basicOpen i", "start": [88, 1], "end": [93, 69], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_iff_forall_affine", "code": "theorem quasiCompact_iff_forall_affine :\n    QuasiCompact f \u2194\n      \u2200 U : Opens Y.carrier, IsAffineOpen U \u2192 IsCompact (f.1.base \u207b\u00b9' (U : Set Y.carrier))", "start": [96, 1], "end": [104, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affineProperty_toProperty", "code": "@[simp]\ntheorem QuasiCompact.affineProperty_toProperty {X Y : Scheme} (f : X \u27f6 Y) :\n    (QuasiCompact.affineProperty : _).toProperty f \u2194 IsAffine Y \u2227 CompactSpace X.carrier", "start": [107, 1], "end": [110, 82], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_iff_affineProperty", "code": "theorem quasiCompact_iff_affineProperty :\n    QuasiCompact f \u2194 targetAffineLocally QuasiCompact.affineProperty f", "start": [113, 1], "end": [119, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_eq_affineProperty", "code": "theorem quasiCompact_eq_affineProperty :\n    @QuasiCompact = targetAffineLocally QuasiCompact.affineProperty", "start": [122, 1], "end": [125, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isCompact_basicOpen", "code": "theorem isCompact_basicOpen (X : Scheme) {U : Opens X.carrier} (hU : IsCompact (U : Set X.carrier))\n    (f : X.presheaf.obj (op U)) : IsCompact (X.basicOpen f : Set X.carrier)", "start": [128, 1], "end": [157, 25], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affineProperty_isLocal", "code": "theorem QuasiCompact.affineProperty_isLocal : (QuasiCompact.affineProperty : _).IsLocal", "start": [160, 1], "end": [181, 25], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affine_openCover_tfae", "code": "theorem QuasiCompact.affine_openCover_tfae {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    List.TFAE\n      [QuasiCompact f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, CompactSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          CompactSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          CompactSpace (pullback f g).carrier,\n        \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4) (_ : \u2200 i, IsAffineOpen (U i)),\n          \u2200 i, CompactSpace (f.1.base \u207b\u00b9' (U i).1)]", "start": [184, 1], "end": [195, 100], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.is_local_at_target", "code": "theorem QuasiCompact.is_local_at_target : PropertyIsLocalAtTarget @QuasiCompact", "start": [198, 1], "end": [200, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.openCover_tfae", "code": "theorem QuasiCompact.openCover_tfae {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    List.TFAE\n      [QuasiCompact f,\n        \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} Y,\n          \u2200 i : \ud835\udcb0.J, QuasiCompact (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (i : \ud835\udcb0.J),\n          QuasiCompact (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 U : Opens Y.carrier, QuasiCompact (f \u2223_ U),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsOpenImmersion g],\n          QuasiCompact (pullback.snd : pullback f g \u27f6 _),\n        \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4), \u2200 i, QuasiCompact (f \u2223_ U i)]", "start": [203, 1], "end": [215, 84], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_over_affine_iff", "code": "theorem quasiCompact_over_affine_iff {X Y : Scheme} (f : X \u27f6 Y) [IsAffine Y] :\n    QuasiCompact f \u2194 CompactSpace X.carrier", "start": [218, 1], "end": [220, 96], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.compactSpace_iff_quasiCompact", "code": "theorem compactSpace_iff_quasiCompact (X : Scheme) :\n    CompactSpace X.carrier \u2194 QuasiCompact (terminal.from X)", "start": [223, 1], "end": [225, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affine_openCover_iff", "code": "theorem QuasiCompact.affine_openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (f : X \u27f6 Y) :\n    QuasiCompact f \u2194 \u2200 i, CompactSpace (pullback f (\ud835\udcb0.map i)).carrier", "start": [228, 1], "end": [231, 101], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.openCover_iff", "code": "theorem QuasiCompact.openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (f : X \u27f6 Y) :\n    QuasiCompact f \u2194 \u2200 i, QuasiCompact (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [234, 1], "end": [237, 85], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_respectsIso", "code": "theorem quasiCompact_respectsIso : MorphismProperty.RespectsIso @QuasiCompact", "start": [240, 1], "end": [242, 74], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_stableUnderComposition", "code": "theorem quasiCompact_stableUnderComposition :\n    MorphismProperty.StableUnderComposition @QuasiCompact", "start": [245, 1], "end": [246, 96], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.QuasiCompact.affineProperty_stableUnderBaseChange", "code": "theorem QuasiCompact.affineProperty_stableUnderBaseChange :\n    QuasiCompact.affineProperty.StableUnderBaseChange", "start": [249, 1], "end": [256, 23], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.quasiCompact_stableUnderBaseChange", "code": "theorem quasiCompact_stableUnderBaseChange : MorphismProperty.StableUnderBaseChange @QuasiCompact", "start": [259, 1], "end": [262, 56], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.compact_open_induction_on", "code": "@[elab_as_elim]\ntheorem compact_open_induction_on {P : Opens X.carrier \u2192 Prop} (S : Opens X.carrier)\n    (hS : IsCompact S.1) (h\u2081 : P \u22a5)\n    (h\u2082 : \u2200 (S : Opens X.carrier) (_ : IsCompact S.1) (U : X.affineOpens), P S \u2192 P (S \u2294 U)) :\n    P S", "start": [275, 1], "end": [292, 22], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen", "code": "theorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isAffineOpen (X : Scheme)\n    {U : Opens X} (hU : IsAffineOpen U) (x f : X.presheaf.obj (op U))\n    (H : x |_ X.basicOpen f = 0) : \u2203 n : \u2115, f ^ n * x = 0", "start": [295, 1], "end": [300, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact", "code": "theorem exists_pow_mul_eq_zero_of_res_basicOpen_eq_zero_of_isCompact (X : Scheme.{u})\n    {U : Opens X.carrier} (hU : IsCompact U.1) (x f : X.presheaf.obj (op U))\n    (H : x |_ X.basicOpen f = 0) : \u2203 n : \u2115, f ^ n * x = 0", "start": [303, 1], "end": [344, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Connected.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "Mathlib/CategoryTheory/IsConnected.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean"], "premises": [{"full_name": "CategoryTheory.widePullbackShape_connected", "code": "instance widePullbackShape_connected (J : Type v\u2081) : IsConnected (WidePullbackShape J) := by\n  apply IsConnected.of_induct\n  introv hp t\n  cases j\n  \u00b7 exact hp\n  \u00b7 rwa [t (WidePullbackShape.Hom.term _)]", "start": [35, 1], "end": [40, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.widePushoutShape_connected", "code": "instance widePushoutShape_connected (J : Type v\u2081) : IsConnected (WidePushoutShape J) := by\n  apply IsConnected.of_induct\n  introv hp t\n  cases j\n  \u00b7 exact hp\n  \u00b7 rwa [\u2190 t (WidePushoutShape.Hom.init _)]", "start": [43, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.parallelPairInhabited", "code": "instance parallelPairInhabited : Inhabited WalkingParallelPair :=\n  \u27e8WalkingParallelPair.one\u27e9", "start": [51, 1], "end": [52, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.parallel_pair_connected", "code": "instance parallel_pair_connected : IsConnected WalkingParallelPair := by\n  apply IsConnected.of_induct\n  introv _ t\n  cases j\n  \u00b7 rwa [t WalkingParallelPairHom.left]\n  \u00b7 assumption", "start": [55, 1], "end": [60, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProdPreservesConnectedLimits.\u03b3\u2082", "code": "@[simps]\ndef \u03b3\u2082 {K : J \u2964 C} (X : C) : K \u22d9 prod.functor.obj X \u27f6 K where app Y := Limits.prod.snd", "start": [73, 1], "end": [75, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProdPreservesConnectedLimits.\u03b3\u2081", "code": "@[simps]\ndef \u03b3\u2081 {K : J \u2964 C} (X : C) : K \u22d9 prod.functor.obj X \u27f6 (Functor.const J).obj X where\n  app Y := Limits.prod.fst", "start": [78, 1], "end": [81, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProdPreservesConnectedLimits.forgetCone", "code": "@[simps]\ndef forgetCone {X : C} {K : J \u2964 C} (s : Cone (K \u22d9 prod.functor.obj X)) : Cone K\n    where\n  pt := s.pt\n  \u03c0 := s.\u03c0 \u226b \u03b3\u2082 X", "start": [84, 1], "end": [90, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodPreservesConnectedLimits", "code": "noncomputable def prodPreservesConnectedLimits [IsConnected J] (X : C) :\n    PreservesLimitsOfShape J (prod.functor.obj X) where\n  preservesLimit {K} :=\n    {\n      preserves := fun {c} l =>\n        { lift := fun s =>\n            prod.lift (s.\u03c0.app (Classical.arbitrary _) \u226b Limits.prod.fst) (l.lift (forgetCone s))\n          fac := fun s j => by\n            apply prod.hom_ext\n            \u00b7 erw [assoc, limMap_\u03c0, comp_id, limit.lift_\u03c0]\n              exact (nat_trans_from_is_connected (s.\u03c0 \u226b \u03b3\u2081 X) j (Classical.arbitrary _)).symm\n            \u00b7 simp [\u2190 l.fac (forgetCone s) j]\n          uniq := fun s m L => by\n            apply prod.hom_ext\n            \u00b7 erw [limit.lift_\u03c0, \u2190 L (Classical.arbitrary J), assoc, limMap_\u03c0, comp_id]\n              rfl\n            \u00b7 rw [limit.lift_\u03c0]\n              apply l.uniq (forgetCone s)\n              intro j\n              simp [\u2190 L j] } }", "start": [97, 1], "end": [121, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/Over/Connected.lean", "imports": ["Mathlib/CategoryTheory/IsConnected.lean", "Mathlib/CategoryTheory/Limits/Creates.lean", "Mathlib/CategoryTheory/Over.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Over.CreatesConnected.natTransInOver", "code": "def natTransInOver {B : C} (F : J \u2964 Over B) :\n    F \u22d9 forget B \u27f6 (CategoryTheory.Functor.const J).obj B where\n  app j := (F.obj j).hom", "start": [37, 1], "end": [42, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.CreatesConnected.raiseCone", "code": "@[simps]\ndef raiseCone [IsConnected J] {B : C} {F : J \u2964 Over B} (c : Cone (F \u22d9 forget B)) :\n    Cone F where\n  pt := Over.mk (c.\u03c0.app (Classical.arbitrary J) \u226b (F.obj (Classical.arbitrary J)).hom)\n  \u03c0 :=\n    { app := fun j =>\n        Over.homMk (c.\u03c0.app j) (nat_trans_from_is_connected (c.\u03c0 \u226b natTransInOver F) j _)\n      naturality := by\n        intro X Y f\n        apply CommaMorphism.ext\n        \u00b7 simpa using (c.w f).symm\n        \u00b7 simp }", "start": [45, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.CreatesConnected.raised_cone_lowers_to_original", "code": "theorem raised_cone_lowers_to_original [IsConnected J] {B : C} {F : J \u2964 Over B}\n    (c : Cone (F \u22d9 forget B)) :\n    (forget B).mapCone (raiseCone c) = c", "start": [62, 1], "end": [64, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.CreatesConnected.raisedConeIsLimit", "code": "def raisedConeIsLimit [IsConnected J] {B : C} {F : J \u2964 Over B} {c : Cone (F \u22d9 forget B)}\n    (t : IsLimit c) : IsLimit (raiseCone c) where\n  lift s :=\n    Over.homMk (t.lift ((forget B).mapCone s))\n  uniq s m K := by\n    ext1\n    apply t.hom_ext\n    intro j\n    simp [\u2190 K j]", "start": [67, 1], "end": [76, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.forgetCreatesConnectedLimits", "code": "instance forgetCreatesConnectedLimits [IsConnected J] {B : C} :\n    CreatesLimitsOfShape J (forget B) where\n  CreatesLimit :=\n    createsLimitOfReflectsIso fun c t =>\n      { liftedCone := CreatesConnected.raiseCone c\n        validLift := eqToIso (CreatesConnected.raised_cone_lowers_to_original c)\n        makesLimit := CreatesConnected.raisedConeIsLimit t }", "start": [81, 1], "end": [88, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.has_connected_limits", "code": "instance has_connected_limits {B : C} [IsConnected J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (Over B) where\n  has_limit F := hasLimit_of_created F (forget B)", "start": [91, 1], "end": [94, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Constructions/Over/Products.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "Mathlib/CategoryTheory/Over.lean"], "premises": [{"full_name": "CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver", "code": "@[reducible]\ndef widePullbackDiagramOfDiagramOver (B : C) {J : Type w} (F : Discrete J \u2964 Over B) :\n    WidePullbackShape J \u2964 C :=\n  WidePullbackShape.wideCospan B (fun j => (F.obj \u27e8j\u27e9).left) fun j => (F.obj \u27e8j\u27e9).hom", "start": [36, 1], "end": [43, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquivInverseObj", "code": "@[simps]\ndef conesEquivInverseObj (B : C) {J : Type w} (F : Discrete J \u2964 Over B) (c : Cone F) :\n    Cone (widePullbackDiagramOfDiagramOver B F) where\n  pt := c.pt.left\n  \u03c0 :=\n    { app := fun X => Option.casesOn X c.pt.hom fun j : J => (c.\u03c0.app \u27e8j\u27e9).left\n      naturality := fun X Y f => by\n        dsimp; cases X <;> cases Y <;> cases f\n        \u00b7 rw [Category.id_comp, Category.comp_id]\n        \u00b7 rw [Over.w, Category.id_comp]\n        \u00b7 rw [Category.id_comp, Category.comp_id] }", "start": [46, 1], "end": [58, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquivInverse", "code": "@[simps]\ndef conesEquivInverse (B : C) {J : Type w} (F : Discrete J \u2964 Over B) :\n    Cone F \u2964 Cone (widePullbackDiagramOfDiagramOver B F) where\n  obj := conesEquivInverseObj B F\n  map f :=\n    { hom := f.hom.left\n      w := fun j => by\n        cases' j with j\n        \u00b7 simp\n        \u00b7 dsimp\n          rw [\u2190 f.w \u27e8j\u27e9]\n          rfl }", "start": [61, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquivFunctor", "code": "@[simps]\ndef conesEquivFunctor (B : C) {J : Type w} (F : Discrete J \u2964 Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) \u2964 Cone F where\n  obj c :=\n    { pt := Over.mk (c.\u03c0.app none)\n      \u03c0 :=\n        { app := fun \u27e8j\u27e9 => Over.homMk (c.\u03c0.app (some j)) (c.w (WidePullbackShape.Hom.term j))\n          naturality := fun \u27e8X\u27e9 \u27e8Y\u27e9 \u27e8\u27e8f\u27e9\u27e9 => by dsimp at f \u22a2; aesop_cat } }\n  map f := { hom := Over.homMk f.hom }", "start": [80, 1], "end": [90, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquivUnitIso", "code": "@[simp]\ndef conesEquivUnitIso (B : C) (F : Discrete J \u2964 Over B) :\n    \ud835\udfed (Cone (widePullbackDiagramOfDiagramOver B F)) \u2245\n      conesEquivFunctor B F \u22d9 conesEquivInverse B F :=\n  NatIso.ofComponents fun _ => Cones.ext\n    { hom := \ud835\udfd9 _\n      inv := \ud835\udfd9 _ }\n    (by rintro (j | j) <;> aesop_cat)", "start": [98, 1], "end": [106, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquivCounitIso", "code": "@[simp]\ndef conesEquivCounitIso (B : C) (F : Discrete J \u2964 Over B) :\n    conesEquivInverse B F \u22d9 conesEquivFunctor B F \u2245 \ud835\udfed (Cone F) :=\n  NatIso.ofComponents fun _ => Cones.ext\n    { hom := Over.homMk (\ud835\udfd9 _)\n      inv := Over.homMk (\ud835\udfd9 _) }", "start": [111, 1], "end": [117, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.conesEquiv", "code": "@[simps]\ndef conesEquiv (B : C) (F : Discrete J \u2964 Over B) :\n    Cone (widePullbackDiagramOfDiagramOver B F) \u224c Cone F where\n  functor := conesEquivFunctor B F\n  inverse := conesEquivInverse B F\n  unitIso := conesEquivUnitIso B F\n  counitIso := conesEquivCounitIso B F", "start": [120, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.has_over_limit_discrete_of_widePullback_limit", "code": "theorem has_over_limit_discrete_of_widePullback_limit {B : C} (F : Discrete J \u2964 Over B)\n    [HasLimit (widePullbackDiagramOfDiagramOver B F)] : HasLimit F", "start": [131, 1], "end": [137, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.over_product_of_widePullback", "code": "theorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\n    HasLimitsOfShape (Discrete J) (Over B)", "start": [140, 1], "end": [143, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.over_binaryProduct_of_pullback", "code": "theorem over_binaryProduct_of_pullback [HasPullbacks C] {B : C} : HasBinaryProducts (Over B)", "start": [146, 1], "end": [148, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.over_products_of_widePullbacks", "code": "theorem over_products_of_widePullbacks [HasWidePullbacks.{w} C] {B : C} :\n    HasProducts.{w} (Over B)", "start": [151, 1], "end": [154, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.ConstructProducts.over_finiteProducts_of_finiteWidePullbacks", "code": "theorem over_finiteProducts_of_finiteWidePullbacks [HasFiniteWidePullbacks C] {B : C} :\n    HasFiniteProducts (Over B)", "start": [157, 1], "end": [160, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Over.over_hasTerminal", "code": "theorem over_hasTerminal (B : C) : HasTerminal (Over B) where", "start": [165, 1], "end": [185, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/FDeriv/Star.lean", "imports": ["Mathlib/Analysis/NormedSpace/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Calculus/FDeriv/Comp.lean", "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "Mathlib/Analysis/Calculus/FDeriv/Linear.lean"], "premises": [{"full_name": "HasStrictFDerivAt.star", "code": "theorem HasStrictFDerivAt.star (h : HasStrictFDerivAt f f' x) :\n    HasStrictFDerivAt (fun x => star (f x)) (((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L f') x", "start": [36, 1], "end": [38, 74], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAtFilter.star", "code": "theorem HasFDerivAtFilter.star (h : HasFDerivAtFilter f f' x L) :\n    HasFDerivAtFilter (fun x => star (f x)) (((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L f') x L", "start": [41, 1], "end": [43, 93], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.star", "code": "nonrec theorem HasFDerivWithinAt.star (h : HasFDerivWithinAt f f' s x) :\n    HasFDerivWithinAt (fun x => star (f x)) (((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L f') s x", "start": [46, 1], "end": [48, 9], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.star", "code": "nonrec theorem HasFDerivAt.star (h : HasFDerivAt f f' x) :\n    HasFDerivAt (fun x => star (f x)) (((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L f') x", "start": [51, 1], "end": [53, 9], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.star", "code": "theorem DifferentiableWithinAt.star (h : DifferentiableWithinAt \ud835\udd5c f s x) :\n    DifferentiableWithinAt \ud835\udd5c (fun y => star (f y)) s x", "start": [56, 1], "end": [58, 50], "kind": "commanddeclaration"}, {"full_name": "differentiableWithinAt_star_iff", "code": "@[simp]\ntheorem differentiableWithinAt_star_iff :\n    DifferentiableWithinAt \ud835\udd5c (fun y => star (f y)) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x", "start": [61, 1], "end": [64, 57], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.star", "code": "theorem DifferentiableAt.star (h : DifferentiableAt \ud835\udd5c f x) :\n    DifferentiableAt \ud835\udd5c (fun y => star (f y)) x", "start": [67, 1], "end": [69, 38], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_star_iff", "code": "@[simp]\ntheorem differentiableAt_star_iff :\n    DifferentiableAt \ud835\udd5c (fun y => star (f y)) x \u2194 DifferentiableAt \ud835\udd5c f x", "start": [72, 1], "end": [75, 51], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.star", "code": "theorem DifferentiableOn.star (h : DifferentiableOn \ud835\udd5c f s) :\n    DifferentiableOn \ud835\udd5c (fun y => star (f y)) s", "start": [78, 1], "end": [79, 76], "kind": "commanddeclaration"}, {"full_name": "differentiableOn_star_iff", "code": "@[simp]\ntheorem differentiableOn_star_iff :\n    DifferentiableOn \ud835\udd5c (fun y => star (f y)) s \u2194 DifferentiableOn \ud835\udd5c f s", "start": [82, 1], "end": [85, 51], "kind": "commanddeclaration"}, {"full_name": "Differentiable.star", "code": "theorem Differentiable.star (h : Differentiable \ud835\udd5c f) : Differentiable \ud835\udd5c fun y => star (f y)", "start": [88, 1], "end": [89, 22], "kind": "commanddeclaration"}, {"full_name": "differentiable_star_iff", "code": "@[simp]\ntheorem differentiable_star_iff : (Differentiable \ud835\udd5c fun y => star (f y)) \u2194 Differentiable \ud835\udd5c f", "start": [92, 1], "end": [94, 49], "kind": "commanddeclaration"}, {"full_name": "fderivWithin_star", "code": "theorem fderivWithin_star (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (fun y => star (f y)) s x =\n      ((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L fderivWithin \ud835\udd5c f s x", "start": [97, 1], "end": [100, 47], "kind": "commanddeclaration"}, {"full_name": "fderiv_star", "code": "@[simp]\ntheorem fderiv_star :\n    fderiv \ud835\udd5c (fun y => star (f y)) x = ((starL' \ud835\udd5c : F \u2243L[\ud835\udd5c] F) : F \u2192L[\ud835\udd5c] F) \u2218L fderiv \ud835\udd5c f x", "start": [103, 1], "end": [106, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/TietzeExtension.lean", "imports": ["Mathlib/Data/Set/Intervals/IsoIoo.lean", "Mathlib/Topology/UrysohnsBounded.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean"], "premises": [{"full_name": "BoundedContinuousFunction.tietze_extension_step", "code": "theorem tietze_extension_step (f : X \u2192\u1d47 \u211d) (e : C(X, Y)) (he : ClosedEmbedding e) :\n    \u2203 g : Y \u2192\u1d47 \u211d, \u2016g\u2016 \u2264 \u2016f\u2016 / 3 \u2227 dist (g.compContinuous e) f \u2264 2 / 3 * \u2016f\u2016", "start": [48, 1], "end": [96, 41], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding'", "code": "theorem exists_extension_norm_eq_of_closedEmbedding' (f : X \u2192\u1d47 \u211d) (e : C(X, Y))\n    (he : ClosedEmbedding e) : \u2203 g : Y \u2192\u1d47 \u211d, \u2016g\u2016 = \u2016f\u2016 \u2227 g.compContinuous e = f", "start": [99, 1], "end": [145, 37], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_extension_norm_eq_of_closedEmbedding", "code": "theorem exists_extension_norm_eq_of_closedEmbedding (f : X \u2192\u1d47 \u211d) {e : X \u2192 Y}\n    (he : ClosedEmbedding e) : \u2203 g : Y \u2192\u1d47 \u211d, \u2016g\u2016 = \u2016f\u2016 \u2227 g \u2218 e = f", "start": [148, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_norm_eq_restrict_eq_of_closed", "code": "theorem exists_norm_eq_restrict_eq_of_closed {s : Set Y} (f : s \u2192\u1d47 \u211d) (hs : IsClosed s) :\n    \u2203 g : Y \u2192\u1d47 \u211d, \u2016g\u2016 = \u2016f\u2016 \u2227 g.restrict s = f", "start": [158, 1], "end": [165, 37], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_extension_forall_mem_Icc_of_closedEmbedding", "code": "theorem exists_extension_forall_mem_Icc_of_closedEmbedding (f : X \u2192\u1d47 \u211d) {a b : \u211d} {e : X \u2192 Y}\n    (hf : \u2200 x, f x \u2208 Icc a b) (hle : a \u2264 b) (he : ClosedEmbedding e) :\n    \u2203 g : Y \u2192\u1d47 \u211d, (\u2200 y, g y \u2208 Icc a b) \u2227 g \u2218 e = f", "start": [168, 1], "end": [189, 16], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding", "code": "theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X \u2192\u1d47 \u211d)\n    {e : X \u2192 Y} (he : ClosedEmbedding e) :\n    \u2203 g : Y \u2192\u1d47 \u211d, (\u2200 y, \u2203 x\u2081 x\u2082, g y \u2208 Icc (f x\u2081) (f x\u2082)) \u2227 g \u2218 e = f", "start": [192, 1], "end": [302, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_extension_forall_mem_of_closedEmbedding", "code": "theorem exists_extension_forall_mem_of_closedEmbedding (f : X \u2192\u1d47 \u211d) {t : Set \u211d} {e : X \u2192 Y}\n    [hs : OrdConnected t] (hf : \u2200 x, f x \u2208 t) (hne : t.Nonempty) (he : ClosedEmbedding e) :\n    \u2203 g : Y \u2192\u1d47 \u211d, (\u2200 y, g y \u2208 t) \u2227 g \u2218 e = f", "start": [305, 1], "end": [321, 31], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.exists_forall_mem_restrict_eq_of_closed", "code": "theorem exists_forall_mem_restrict_eq_of_closed {s : Set Y} (f : s \u2192\u1d47 \u211d) (hs : IsClosed s)\n    {t : Set \u211d} [OrdConnected t] (hf : \u2200 x, f x \u2208 t) (hne : t.Nonempty) :\n    \u2203 g : Y \u2192\u1d47 \u211d, (\u2200 y, g y \u2208 t) \u2227 g.restrict s = f", "start": [324, 1], "end": [336, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_extension_forall_mem_of_closedEmbedding", "code": "theorem exists_extension_forall_mem_of_closedEmbedding (f : C(X, \u211d)) {t : Set \u211d} {e : X \u2192 Y}\n    [hs : OrdConnected t] (hf : \u2200 x, f x \u2208 t) (hne : t.Nonempty) (he : ClosedEmbedding e) :\n    \u2203 g : C(Y, \u211d), (\u2200 y, g y \u2208 t) \u2227 g \u2218 e = f", "start": [343, 1], "end": [380, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_extension_of_closedEmbedding", "code": "theorem exists_extension_of_closedEmbedding (f : C(X, \u211d)) (e : X \u2192 Y) (he : ClosedEmbedding e) :\n    \u2203 g : C(Y, \u211d), g \u2218 e = f", "start": [383, 1], "end": [390, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_restrict_eq_forall_mem_of_closed", "code": "theorem exists_restrict_eq_forall_mem_of_closed {s : Set Y} (f : C(s, \u211d)) {t : Set \u211d}\n    [OrdConnected t] (ht : \u2200 x, f x \u2208 t) (hne : t.Nonempty) (hs : IsClosed s) :\n    \u2203 g : C(Y, \u211d), (\u2200 y, g y \u2208 t) \u2227 g.restrict s = f", "start": [393, 1], "end": [404, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_restrict_eq_of_closed", "code": "theorem exists_restrict_eq_of_closed {s : Set Y} (f : C(s, \u211d)) (hs : IsClosed s) :\n    \u2203 g : C(Y, \u211d), g.restrict s = f", "start": [407, 1], "end": [415, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Clique.lean", "Mathlib/Data/Setoid/Partition.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Lattice.lean", "Mathlib/Order/Antichain.lean"], "premises": [{"full_name": "SimpleGraph.Coloring", "code": "abbrev Coloring (\u03b1 : Type v) := G \u2192g (\u22a4 : SimpleGraph \u03b1)", "start": [63, 1], "end": [66, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.valid", "code": "theorem Coloring.valid {v w : V} (h : G.Adj v w) : C v \u2260 C w", "start": [71, 1], "end": [72, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.mk", "code": "@[match_pattern]\ndef Coloring.mk (color : V \u2192 \u03b1) (valid : \u2200 {v w : V}, G.Adj v w \u2192 color v \u2260 color w) :\n    G.Coloring \u03b1 :=\n  \u27e8color, @valid\u27e9", "start": [75, 1], "end": [84, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.colorClass", "code": "def Coloring.colorClass (c : \u03b1) : Set V := { v : V | C v = c }", "start": [87, 1], "end": [89, 63], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.colorClasses", "code": "def Coloring.colorClasses : Set (Set V) := (Setoid.ker C).classes", "start": [92, 1], "end": [93, 66], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.mem_colorClass", "code": "theorem Coloring.mem_colorClass (v : V) : v \u2208 C.colorClass (C v)", "start": [96, 1], "end": [96, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.colorClasses_isPartition", "code": "theorem Coloring.colorClasses_isPartition : Setoid.IsPartition C.colorClasses", "start": [99, 1], "end": [100, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.mem_colorClasses", "code": "theorem Coloring.mem_colorClasses {v : V} : C.colorClass (C v) \u2208 C.colorClasses", "start": [103, 1], "end": [104, 11], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.colorClasses_finite", "code": "theorem Coloring.colorClasses_finite [Finite \u03b1] : C.colorClasses.Finite", "start": [107, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.card_colorClasses_le", "code": "theorem Coloring.card_colorClasses_le [Fintype \u03b1] [Fintype C.colorClasses] :\n    Fintype.card C.colorClasses \u2264 Fintype.card \u03b1", "start": [111, 1], "end": [116, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.not_adj_of_mem_colorClass", "code": "theorem Coloring.not_adj_of_mem_colorClass {c : \u03b1} {v w : V} (hv : v \u2208 C.colorClass c)\n    (hw : w \u2208 C.colorClass c) : \u00acG.Adj v w", "start": [119, 1], "end": [120, 92], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.color_classes_independent", "code": "theorem Coloring.color_classes_independent (c : \u03b1) : IsAntichain G.Adj (C.colorClass c)", "start": [123, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable", "code": "def Colorable (n : \u2115) : Prop := Nonempty (G.Coloring (Fin n))", "start": [135, 1], "end": [136, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.coloringOfIsEmpty", "code": "def coloringOfIsEmpty [IsEmpty V] : G.Coloring \u03b1 :=\n  Coloring.mk isEmptyElim fun {v} => isEmptyElim v", "start": [139, 1], "end": [141, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_of_isEmpty", "code": "theorem colorable_of_isEmpty [IsEmpty V] (n : \u2115) : G.Colorable n", "start": [144, 1], "end": [145, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isEmpty_of_colorable_zero", "code": "theorem isEmpty_of_colorable_zero (h : G.Colorable 0) : IsEmpty V", "start": [148, 1], "end": [152, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.selfColoring", "code": "def selfColoring : G.Coloring V := Coloring.mk id fun {_ _} => G.ne_of_adj", "start": [155, 1], "end": [156, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber", "code": "noncomputable def chromaticNumber : \u2115 :=\n  sInf { n : \u2115 | G.Colorable n }", "start": [159, 1], "end": [162, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.recolorOfEmbedding", "code": "def recolorOfEmbedding {\u03b1 \u03b2 : Type*} (f : \u03b1 \u21aa \u03b2) : G.Coloring \u03b1 \u21aa G.Coloring \u03b2 where\n  toFun C := (Embedding.completeGraph f).toHom.comp C\n  inj' := by intro C C' h\n    dsimp only at h\n    ext v\n    apply (Embedding.completeGraph f).inj'\n    change ((Embedding.completeGraph f).toHom.comp C) v = _\n    rw [h]\n    rfl", "start": [165, 1], "end": [175, 8], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.recolorOfEquiv", "code": "def recolorOfEquiv {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2243 \u03b2) : G.Coloring \u03b1 \u2243 G.Coloring \u03b2 where\n  toFun := G.recolorOfEmbedding f.toEmbedding\n  invFun := G.recolorOfEmbedding f.symm.toEmbedding\n  left_inv C := by\n    ext v\n    apply Equiv.symm_apply_apply\n  right_inv C := by\n    ext v\n    apply Equiv.apply_symm_apply", "start": [178, 1], "end": [187, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.recolorOfCardLE", "code": "noncomputable def recolorOfCardLE {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (hn : Fintype.card \u03b1 \u2264 Fintype.card \u03b2) : G.Coloring \u03b1 \u21aa G.Coloring \u03b2 :=\n  G.recolorOfEmbedding <| (Function.Embedding.nonempty_of_card_le hn).some", "start": [190, 1], "end": [194, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.mono", "code": "theorem Colorable.mono {n m : \u2115} (h : n \u2264 m) (hc : G.Colorable n) : G.Colorable m", "start": [199, 1], "end": [200, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Coloring.to_colorable", "code": "theorem Coloring.to_colorable [Fintype \u03b1] (C : G.Coloring \u03b1) : G.Colorable (Fintype.card \u03b1)", "start": [203, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_of_fintype", "code": "theorem colorable_of_fintype (G : SimpleGraph V) [Fintype V] : G.Colorable (Fintype.card V)", "start": [207, 1], "end": [208, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.toColoring", "code": "noncomputable def Colorable.toColoring [Fintype \u03b1] {n : \u2115} (hc : G.Colorable n)\n    (hn : n \u2264 Fintype.card \u03b1) : G.Coloring \u03b1 := by\n  rw [\u2190 Fintype.card_fin n] at hn\n  exact G.recolorOfCardLE hn hc.some", "start": [211, 1], "end": [215, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.of_embedding", "code": "theorem Colorable.of_embedding {V' : Type*} {G' : SimpleGraph V'} (f : G \u21aag G') {n : \u2115}\n    (h : G'.Colorable n) : G.Colorable n", "start": [218, 1], "end": [220, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_iff_exists_bdd_nat_coloring", "code": "theorem colorable_iff_exists_bdd_nat_coloring (n : \u2115) :\n    G.Colorable n \u2194 \u2203 C : G.Coloring \u2115, \u2200 v, C v < n", "start": [223, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_set_nonempty_of_colorable", "code": "theorem colorable_set_nonempty_of_colorable {n : \u2115} (hc : G.Colorable n) :\n    { n : \u2115 | G.Colorable n }.Nonempty", "start": [241, 1], "end": [243, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_bddBelow", "code": "theorem chromaticNumber_bddBelow : BddBelow { n : \u2115 | G.Colorable n }", "start": [246, 1], "end": [247, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_le_of_colorable", "code": "theorem chromaticNumber_le_of_colorable {n : \u2115} (hc : G.Colorable n) : G.chromaticNumber \u2264 n", "start": [250, 1], "end": [254, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_le_card", "code": "theorem chromaticNumber_le_card [Fintype \u03b1] (C : G.Coloring \u03b1) :\n    G.chromaticNumber \u2264 Fintype.card \u03b1", "start": [257, 1], "end": [259, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_chromaticNumber", "code": "theorem colorable_chromaticNumber {m : \u2115} (hc : G.Colorable m) : G.Colorable G.chromaticNumber", "start": [262, 1], "end": [267, 47], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_chromaticNumber_of_fintype", "code": "theorem colorable_chromaticNumber_of_fintype (G : SimpleGraph V) [Finite V] :\n    G.Colorable G.chromaticNumber", "start": [270, 1], "end": [273, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_le_one_of_subsingleton", "code": "theorem chromaticNumber_le_one_of_subsingleton (G : SimpleGraph V) [Subsingleton V] :\n    G.chromaticNumber \u2264 1", "start": [276, 1], "end": [284, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_eq_zero_of_isempty", "code": "theorem chromaticNumber_eq_zero_of_isempty (G : SimpleGraph V) [IsEmpty V] :\n    G.chromaticNumber = 0", "start": [287, 1], "end": [291, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isEmpty_of_chromaticNumber_eq_zero", "code": "theorem isEmpty_of_chromaticNumber_eq_zero (G : SimpleGraph V) [Finite V]\n    (h : G.chromaticNumber = 0) : IsEmpty V", "start": [294, 1], "end": [298, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_pos", "code": "theorem chromaticNumber_pos [Nonempty V] {n : \u2115} (hc : G.Colorable n) : 0 < G.chromaticNumber", "start": [301, 1], "end": [308, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.colorable_of_chromaticNumber_pos", "code": "theorem colorable_of_chromaticNumber_pos (h : 0 < G.chromaticNumber) :\n    G.Colorable G.chromaticNumber", "start": [311, 1], "end": [314, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.mono_left", "code": "theorem Colorable.mono_left {G' : SimpleGraph V} (h : G \u2264 G') {n : \u2115} (hc : G'.Colorable n) :\n    G.Colorable n", "start": [317, 1], "end": [319, 46], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.chromaticNumber_le_of_forall_imp", "code": "theorem Colorable.chromaticNumber_le_of_forall_imp {V' : Type*} {G' : SimpleGraph V'} {m : \u2115}\n    (hc : G'.Colorable m) (h : \u2200 n, G'.Colorable n \u2192 G.Colorable n) :\n    G.chromaticNumber \u2264 G'.chromaticNumber", "start": [322, 1], "end": [327, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.chromaticNumber_mono", "code": "theorem Colorable.chromaticNumber_mono (G' : SimpleGraph V) {m : \u2115} (hc : G'.Colorable m)\n    (h : G \u2264 G') : G.chromaticNumber \u2264 G'.chromaticNumber", "start": [330, 1], "end": [332, 69], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.chromaticNumber_mono_of_embedding", "code": "theorem Colorable.chromaticNumber_mono_of_embedding {V' : Type*} {G' : SimpleGraph V'} {n : \u2115}\n    (h : G'.Colorable n) (f : G \u21aag G') : G.chromaticNumber \u2264 G'.chromaticNumber", "start": [335, 1], "end": [337, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_eq_card_of_forall_surj", "code": "theorem chromaticNumber_eq_card_of_forall_surj [Fintype \u03b1] (C : G.Coloring \u03b1)\n    (h : \u2200 C' : G.Coloring \u03b1, Function.Surjective C') : G.chromaticNumber = Fintype.card \u03b1", "start": [340, 1], "end": [354, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_bot", "code": "theorem chromaticNumber_bot [Nonempty V] : (\u22a5 : SimpleGraph V).chromaticNumber = 1", "start": [357, 1], "end": [362, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_top", "code": "@[simp]\ntheorem chromaticNumber_top [Fintype V] : (\u22a4 : SimpleGraph V).chromaticNumber = Fintype.card V", "start": [365, 1], "end": [373, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.chromaticNumber_top_eq_zero_of_infinite", "code": "theorem chromaticNumber_top_eq_zero_of_infinite (V : Type*) [Infinite V] :\n    (\u22a4 : SimpleGraph V).chromaticNumber = 0", "start": [376, 1], "end": [387, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CompleteBipartiteGraph.bicoloring", "code": "def CompleteBipartiteGraph.bicoloring (V W : Type*) : (completeBipartiteGraph V W).Coloring Bool :=\n  Coloring.mk (fun v => v.isRight)\n    (by\n      intro v w\n      cases v <;> cases w <;> simp)", "start": [390, 1], "end": [396, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CompleteBipartiteGraph.chromaticNumber", "code": "theorem CompleteBipartiteGraph.chromaticNumber {V W : Type*} [Nonempty V] [Nonempty W] :\n    (completeBipartiteGraph V W).chromaticNumber = 2", "start": [399, 1], "end": [415, 22], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.card_le_of_coloring", "code": "theorem IsClique.card_le_of_coloring {s : Finset V} (h : G.IsClique s) [Fintype \u03b1]\n    (C : G.Coloring \u03b1) : s.card \u2264 Fintype.card \u03b1", "start": [421, 1], "end": [427, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.card_le_of_colorable", "code": "theorem IsClique.card_le_of_colorable {s : Finset V} (h : G.IsClique s) {n : \u2115}\n    (hc : G.Colorable n) : s.card \u2264 n", "start": [430, 1], "end": [433, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.card_le_chromaticNumber", "code": "theorem IsClique.card_le_chromaticNumber [Finite V] {s : Finset V} (h : G.IsClique s) :\n    s.card \u2264 G.chromaticNumber", "start": [438, 1], "end": [441, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Colorable.cliqueFree", "code": "protected theorem Colorable.cliqueFree {n m : \u2115} (hc : G.Colorable n) (hm : n < m) :\n    G.CliqueFree m", "start": [444, 1], "end": [449, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_of_chromaticNumber_lt", "code": "theorem cliqueFree_of_chromaticNumber_lt [Finite V] {n : \u2115} (hc : G.chromaticNumber < n) :\n    G.CliqueFree n", "start": [454, 1], "end": [456, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean", "Mathlib/Data/Polynomial/Degree/CardPowDegree.lean"], "premises": [{"full_name": "Polynomial.exists_eq_polynomial", "code": "theorem exists_eq_polynomial [Semiring Fq] {d : \u2115} {m : \u2115} (hm : Fintype.card Fq ^ d \u2264 m)\n    (b : Fq[X]) (hb : natDegree b \u2264 d) (A : Fin m.succ \u2192 Fq[X])\n    (hA : \u2200 i, degree (A i) < degree b) : \u2203 i\u2080 i\u2081, i\u2080 \u2260 i\u2081 \u2227 A i\u2081 = A i\u2080", "start": [34, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_approx_polynomial_aux", "code": "theorem exists_approx_polynomial_aux [Ring Fq] {d : \u2115} {m : \u2115} (hm : Fintype.card Fq ^ d \u2264 m)\n    (b : Fq[X]) (A : Fin m.succ \u2192 Fq[X]) (hA : \u2200 i, degree (A i) < degree b) :\n    \u2203 i\u2080 i\u2081, i\u2080 \u2260 i\u2081 \u2227 degree (A i\u2081 - A i\u2080) < \u2191(natDegree b - d)", "start": [60, 1], "end": [98, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_approx_polynomial", "code": "theorem exists_approx_polynomial {b : Fq[X]} (hb : b \u2260 0) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5)\n    (A : Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a).succ \u2192 Fq[X]) :\n    \u2203 i\u2080 i\u2081, i\u2080 \u2260 i\u2081 \u2227 (cardPowDegree (A i\u2081 % b - A i\u2080 % b) : \u211d) < cardPowDegree b \u2022 \u03b5", "start": [103, 1], "end": [149, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegree_anti_archimedean", "code": "theorem cardPowDegree_anti_archimedean {x y z : Fq[X]} {a : \u2124} (hxy : cardPowDegree (x - y) < a)\n    (hyz : cardPowDegree (y - z) < a) : cardPowDegree (x - z) < a", "start": [152, 1], "end": [172, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_partition_polynomial_aux", "code": "theorem exists_partition_polynomial_aux (n : \u2115) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : Fq[X]} (hb : b \u2260 0)\n    (A : Fin n \u2192 Fq[X]) : \u2203 t : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a),\n      \u2200 i\u2080 i\u2081 : Fin n, t i\u2080 = t i\u2081 \u2194\n        (cardPowDegree (A i\u2081 % b - A i\u2080 % b) : \u211d) < cardPowDegree b \u2022 \u03b5", "start": [175, 1], "end": [244, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_partition_polynomial", "code": "theorem exists_partition_polynomial (n : \u2115) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : Fq[X]} (hb : b \u2260 0)\n    (A : Fin n \u2192 Fq[X]) : \u2203 t : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a),\n      \u2200 i\u2080 i\u2081 : Fin n, t i\u2080 = t i\u2081 \u2192\n        (cardPowDegree (A i\u2081 % b - A i\u2080 % b) : \u211d) < cardPowDegree b \u2022 \u03b5", "start": [247, 1], "end": [254, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegreeIsAdmissible", "code": "noncomputable def cardPowDegreeIsAdmissible :\n    IsAdmissible (cardPowDegree : AbsoluteValue Fq[X] \u2124) :=\n  { @cardPowDegree_isEuclidean Fq _\n      _ with\n    card := fun \u03b5 => Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a\n    exists_partition' := fun n _ h\u03b5 _ hb => exists_partition_polynomial n h\u03b5 hb }", "start": [257, 1], "end": [264, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/FunctionField.lean", "imports": ["Mathlib/Topology/Algebra/ValuedField.lean", "Mathlib/RingTheory/IntegrallyClosed.lean", "Mathlib/Algebra/Order/Group/TypeTags.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean", "Mathlib/FieldTheory/RatFunc.lean"], "premises": [{"full_name": "FunctionField", "code": "abbrev FunctionField [Algebra (RatFunc Fq) F] : Prop :=\n  FiniteDimensional (RatFunc Fq) F", "start": [51, 1], "end": [57, 35], "kind": "commanddeclaration"}, {"full_name": "functionField_iff", "code": "theorem functionField_iff (Fqt : Type*) [Field Fqt] [Algebra Fq[X] Fqt]\n    [IsFractionRing Fq[X] Fqt] [Algebra (RatFunc Fq) F] [Algebra Fqt F] [Algebra Fq[X] F]\n    [IsScalarTower Fq[X] Fqt F] [IsScalarTower Fq[X] (RatFunc Fq) F] :\n    FunctionField Fq F \u2194 FiniteDimensional Fqt F", "start": [61, 1], "end": [80, 80], "kind": "commanddeclaration"}, {"full_name": "algebraMap_injective", "code": "theorem algebraMap_injective [Algebra Fq[X] F] [Algebra (RatFunc Fq) F]\n    [IsScalarTower Fq[X] (RatFunc Fq) F] : Function.Injective (\u21d1(algebraMap Fq[X] F))", "start": [83, 1], "end": [86, 97], "kind": "commanddeclaration"}, {"full_name": "FunctionField.ringOfIntegers", "code": "def ringOfIntegers [Algebra Fq[X] F] :=\n  integralClosure Fq[X] F", "start": [91, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "FunctionField.ringOfIntegers.algebraMap_injective", "code": "theorem algebraMap_injective : Function.Injective (\u21d1(algebraMap Fq[X] (ringOfIntegers Fq F)))", "start": [113, 1], "end": [121, 18], "kind": "commanddeclaration"}, {"full_name": "FunctionField.ringOfIntegers.not_isField", "code": "theorem not_isField : \u00acIsField (ringOfIntegers Fq F)", "start": [124, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuationDef", "code": "def inftyValuationDef (r : RatFunc Fq) : \u2124\u2098\u2080 :=\n  if r = 0 then 0 else Multiplicative.ofAdd r.intDegree", "start": [153, 1], "end": [157, 56], "kind": "commanddeclaration"}, {"full_name": "FunctionField.InftyValuation.map_zero'", "code": "theorem InftyValuation.map_zero' : inftyValuationDef Fq 0 = 0", "start": [160, 1], "end": [161, 13], "kind": "commanddeclaration"}, {"full_name": "FunctionField.InftyValuation.map_one'", "code": "theorem InftyValuation.map_one' : inftyValuationDef Fq 1 = 1", "start": [164, 1], "end": [165, 92], "kind": "commanddeclaration"}, {"full_name": "FunctionField.InftyValuation.map_mul'", "code": "theorem InftyValuation.map_mul' (x y : RatFunc Fq) :\n    inftyValuationDef Fq (x * y) = inftyValuationDef Fq x * inftyValuationDef Fq y", "start": [168, 1], "end": [176, 50], "kind": "commanddeclaration"}, {"full_name": "FunctionField.InftyValuation.map_add_le_max'", "code": "theorem InftyValuation.map_add_le_max' (x y : RatFunc Fq) :\n    inftyValuationDef Fq (x + y) \u2264 max (inftyValuationDef Fq x) (inftyValuationDef Fq y)", "start": [179, 1], "end": [195, 46], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation_of_nonzero", "code": "@[simp]\ntheorem inftyValuation_of_nonzero {x : RatFunc Fq} (hx : x \u2260 0) :\n    inftyValuationDef Fq x = Multiplicative.ofAdd x.intDegree", "start": [198, 1], "end": [201, 36], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation", "code": "def inftyValuation : Valuation (RatFunc Fq) \u2124\u2098\u2080 where\n  toFun := inftyValuationDef Fq\n  map_zero' := InftyValuation.map_zero' Fq\n  map_one' := InftyValuation.map_one' Fq\n  map_mul' := InftyValuation.map_mul' Fq\n  map_add_le_max' := InftyValuation.map_add_le_max' Fq", "start": [204, 1], "end": [210, 55], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation_apply", "code": "@[simp]\ntheorem inftyValuation_apply {x : RatFunc Fq} : inftyValuation Fq x = inftyValuationDef Fq x", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation.C", "code": "@[simp]\ntheorem inftyValuation.C {k : Fq} (hk : k \u2260 0) :\n    inftyValuationDef Fq (RatFunc.C k) = Multiplicative.ofAdd (0 : \u2124)", "start": [218, 1], "end": [222, 58], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation.X", "code": "@[simp]\ntheorem inftyValuation.X : inftyValuationDef Fq RatFunc.X = Multiplicative.ofAdd (1 : \u2124)", "start": [226, 1], "end": [228, 72], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuation.polynomial", "code": "@[simp]\ntheorem inftyValuation.polynomial {p : Fq[X]} (hp : p \u2260 0) :\n    inftyValuationDef Fq (algebraMap Fq[X] (RatFunc Fq) p) =\n      Multiplicative.ofAdd (p.natDegree : \u2124)", "start": [232, 1], "end": [238, 67], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuedFqt", "code": "def inftyValuedFqt : Valued (RatFunc Fq) \u2124\u2098\u2080 :=\n  Valued.mk' <| inftyValuation Fq", "start": [241, 1], "end": [243, 34], "kind": "commanddeclaration"}, {"full_name": "FunctionField.inftyValuedFqt.def", "code": "theorem inftyValuedFqt.def {x : RatFunc Fq} :\n    @Valued.v (RatFunc Fq) _ _ _ (inftyValuedFqt Fq) x = inftyValuationDef Fq x", "start": [247, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "FunctionField.FqtInfty", "code": "def FqtInfty :=\n  @UniformSpace.Completion (RatFunc Fq) <| (inftyValuedFqt Fq).toUniformSpace", "start": [253, 1], "end": [255, 78], "kind": "commanddeclaration"}, {"full_name": "FunctionField.valuedFqtInfty", "code": "instance valuedFqtInfty : Valued (FqtInfty Fq) \u2124\u2098\u2080 :=\n  @Valued.valuedCompletion _ _ _ _ (inftyValuedFqt Fq)", "start": [266, 1], "end": [268, 55], "kind": "commanddeclaration"}, {"full_name": "FunctionField.valuedFqtInfty.def", "code": "theorem valuedFqtInfty.def {x : FqtInfty Fq} :\n    Valued.v x = @Valued.extension (RatFunc Fq) _ _ _ (inftyValuedFqt Fq) x", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bitvec/Defs.lean", "imports": ["lake-packages/lean4/src/lean/Init/Data/Format/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Data/Nat/Pow.lean", "Mathlib/Data/Vector/Basic.lean"], "premises": [{"full_name": "Bitvec", "code": "@[reducible]\ndef Bitvec (n : \u2115) :=\n  Vector Bool n", "start": [21, 1], "end": [24, 16], "kind": "commanddeclaration"}, {"full_name": "Bitvec.zero", "code": "@[reducible]\nprotected def zero (n : \u2115) : Bitvec n :=\n  replicate n false", "start": [36, 1], "end": [39, 20], "kind": "commanddeclaration"}, {"full_name": "Bitvec.one", "code": "@[reducible]\nprotected def one : \u2200 n : \u2115, Bitvec n\n  | 0 => nil\n  | succ n => replicate n false++\u209ctrue ::\u1d65 nil", "start": [42, 1], "end": [46, 47], "kind": "commanddeclaration"}, {"full_name": "Bitvec.cong", "code": "protected def cong {a b : \u2115} : a = b \u2192 Bitvec a \u2192 Bitvec b :=\n  Vector.congr", "start": [49, 1], "end": [51, 15], "kind": "commanddeclaration"}, {"full_name": "Bitvec.append", "code": "def append {m n} : Bitvec m \u2192 Bitvec n \u2192 Bitvec (m + n) :=\n  Vector.append", "start": [54, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Bitvec.shl", "code": "def shl (x : Bitvec n) (i : \u2115) : Bitvec n :=\n  shiftLeftFill x i false", "start": [66, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ushr", "code": "def ushr (x : Bitvec n) (i : \u2115) : Bitvec n :=\n  shiftRightFill x i false", "start": [74, 1], "end": [76, 27], "kind": "commanddeclaration"}, {"full_name": "Bitvec.sshr", "code": "def sshr : \u2200 {m : \u2115}, Bitvec m \u2192 \u2115 \u2192 Bitvec m\n  | 0, _, _ => nil\n  | succ _, x, i => head x ::\u1d65 shiftRightFill (tail x) i (head x)", "start": [79, 1], "end": [82, 66], "kind": "commanddeclaration"}, {"full_name": "Bitvec.not", "code": "protected def not (bv : Bitvec n) : Bitvec n :=\n  map not bv", "start": [95, 1], "end": [97, 13], "kind": "commanddeclaration"}, {"full_name": "Bitvec.and", "code": "protected def and : Bitvec n \u2192 Bitvec n \u2192 Bitvec n :=\n  map\u2082 and", "start": [101, 1], "end": [103, 11], "kind": "commanddeclaration"}, {"full_name": "Bitvec.or", "code": "protected def or : Bitvec n \u2192 Bitvec n \u2192 Bitvec n :=\n  map\u2082 or", "start": [107, 1], "end": [109, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.xor", "code": "protected def xor : Bitvec n \u2192 Bitvec n \u2192 Bitvec n :=\n  map\u2082 xor", "start": [113, 1], "end": [115, 11], "kind": "commanddeclaration"}, {"full_name": "Bitvec.neg", "code": "protected def neg (x : Bitvec n) : Bitvec n :=\n  let f y c := (y || c, xor y c)\n  Prod.snd (mapAccumr f x false)", "start": [139, 1], "end": [142, 33], "kind": "commanddeclaration"}, {"full_name": "Bitvec.adc", "code": "def adc (x y : Bitvec n) (c : Bool) : Bitvec (n + 1) :=\n  let f x y c := (Bool.carry x y c, Bool.xor3 x y c)\n  let \u27e8c, z\u27e9 := Vector.mapAccumr\u2082 f x y c\n  c ::\u1d65 z", "start": [145, 1], "end": [149, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.add", "code": "protected def add (x y : Bitvec n) : Bitvec n :=\n  tail (adc x y false)", "start": [152, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "Bitvec.sbb", "code": "def sbb (x y : Bitvec n) (b : Bool) : Bool \u00d7 Bitvec n :=\n  let f x y c := (Bool.carry (not x) y c, Bool.xor3 x y c)\n  Vector.mapAccumr\u2082 f x y b", "start": [157, 1], "end": [160, 28], "kind": "commanddeclaration"}, {"full_name": "Bitvec.sub", "code": "protected def sub (x y : Bitvec n) : Bitvec n :=\n  Prod.snd (sbb x y false)", "start": [163, 1], "end": [165, 27], "kind": "commanddeclaration"}, {"full_name": "Bitvec.mul", "code": "protected def mul (x y : Bitvec n) : Bitvec n :=\n  let f r b := cond b (r + r + y) (r + r)\n  (toList x).foldl f 0", "start": [183, 1], "end": [186, 23], "kind": "commanddeclaration"}, {"full_name": "Bitvec.uborrow", "code": "def uborrow (x y : Bitvec n) : Bool :=\n  Prod.fst (sbb x y false)", "start": [201, 1], "end": [204, 27], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Ult", "code": "def Ult (x y : Bitvec n) : Prop :=\n  uborrow x y", "start": [207, 1], "end": [209, 14], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Ugt", "code": "def Ugt (x y : Bitvec n) : Prop :=\n  Ult y x", "start": [212, 1], "end": [214, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Ule", "code": "def Ule (x y : Bitvec n) : Prop :=\n  \u00acUlt y x", "start": [217, 1], "end": [219, 11], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Uge", "code": "def Uge (x y : Bitvec n) : Prop :=\n  Ule y x", "start": [222, 1], "end": [224, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.sborrow", "code": "def sborrow : \u2200 {n : \u2115}, Bitvec n \u2192 Bitvec n \u2192 Bool\n  | 0, _, _ => false\n  | succ _, x, y =>\n    match (head x, head y) with\n    | (true, false) => true\n    | (false, true) => false\n    | _ => uborrow (tail x) (tail y)", "start": [227, 1], "end": [234, 37], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Slt", "code": "def Slt (x y : Bitvec n) : Prop :=\n  sborrow x y", "start": [237, 1], "end": [239, 14], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Sgt", "code": "def Sgt (x y : Bitvec n) : Prop :=\n  Slt y x", "start": [242, 1], "end": [244, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Sle", "code": "def Sle (x y : Bitvec n) : Prop :=\n  \u00acSlt y x", "start": [247, 1], "end": [249, 11], "kind": "commanddeclaration"}, {"full_name": "Bitvec.Sge", "code": "def Sge (x y : Bitvec n) : Prop :=\n  Sle y x", "start": [252, 1], "end": [254, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofNat", "code": "protected def ofNat : \u2200 n : \u2115, Nat \u2192 Bitvec n\n  | 0, _ => nil\n  | succ n, x => Bitvec.ofNat n (x / 2)++\u209cdecide (x % 2 = 1) ::\u1d65 nil", "start": [266, 1], "end": [269, 69], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofInt", "code": "protected def ofInt : \u2200 n : \u2115, Int \u2192 Bitvec n\n  | n, Int.ofNat m => Bitvec.ofNat n m\n  | n, Int.negSucc m => (Bitvec.ofNat n m).not", "start": [272, 1], "end": [275, 47], "kind": "commanddeclaration"}, {"full_name": "Bitvec.addLsb", "code": "def addLsb (r : \u2115) (b : Bool) :=\n  r + r + cond b 1 0", "start": [277, 1], "end": [279, 21], "kind": "commanddeclaration"}, {"full_name": "Bitvec.bitsToNat", "code": "def bitsToNat (v : List Bool) : Nat :=\n  v.foldl addLsb 0", "start": [282, 1], "end": [284, 19], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toNat", "code": "protected def toNat {n : Nat} (v : Bitvec n) : Nat :=\n  bitsToNat (toList v)", "start": [287, 1], "end": [289, 23], "kind": "commanddeclaration"}, {"full_name": "Bitvec.ofFin", "code": "def ofFin {n : \u2115} (i : Fin <| 2 ^ n) : Bitvec n :=\n  Bitvec.ofNat _ i.val", "start": [295, 1], "end": [297, 23], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toFin", "code": "def toFin {n : \u2115} (i : Bitvec n) : Fin (2 ^ n) :=\n  i.toNat", "start": [300, 1], "end": [302, 10], "kind": "commanddeclaration"}, {"full_name": "Bitvec.toInt", "code": "protected def toInt : \u2200 {n : Nat}, Bitvec n \u2192 Int\n  | 0, _ => 0\n  | succ _, v =>\n    cond (head v) (Int.negSucc <| Bitvec.toNat <| Bitvec.not <| tail v)\n      (Int.ofNat <| Bitvec.toNat <| tail v)", "start": [306, 1], "end": [311, 44], "kind": "commanddeclaration"}, {"full_name": "Bitvec.repr", "code": "private def repr {n : Nat} : Bitvec n \u2192 String\n  | \u27e8bs, _\u27e9 => \"0b\" ++ (bs.map fun b : Bool => if b then '1' else '0').asString", "start": [319, 1], "end": [320, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Semiquot.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Semiquot", "code": "structure Semiquot (\u03b1 : Type*) where mk' ::\n  \n  s : Set \u03b1\n  \n  val : Trunc s", "start": [21, 1], "end": [32, 16], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mk", "code": "def mk {a : \u03b1} {s : Set \u03b1} (h : a \u2208 s) : Semiquot \u03b1 :=\n  \u27e8s, Trunc.mk \u27e8a, h\u27e9\u27e9", "start": [42, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "Semiquot.ext_s", "code": "theorem ext_s {q\u2081 q\u2082 : Semiquot \u03b1} : q\u2081 = q\u2082 \u2194 q\u2081.s = q\u2082.s", "start": [47, 1], "end": [50, 72], "kind": "commanddeclaration"}, {"full_name": "Semiquot.ext", "code": "theorem ext {q\u2081 q\u2082 : Semiquot \u03b1} : q\u2081 = q\u2082 \u2194 \u2200 a, a \u2208 q\u2081 \u2194 a \u2208 q\u2082", "start": [53, 1], "end": [54, 26], "kind": "commanddeclaration"}, {"full_name": "Semiquot.exists_mem", "code": "theorem exists_mem (q : Semiquot \u03b1) : \u2203 a, a \u2208 q", "start": [57, 1], "end": [59, 9], "kind": "commanddeclaration"}, {"full_name": "Semiquot.eq_mk_of_mem", "code": "theorem eq_mk_of_mem {q : Semiquot \u03b1} {a : \u03b1} (h : a \u2208 q) : q = @mk _ a q.1 h", "start": [62, 1], "end": [63, 14], "kind": "commanddeclaration"}, {"full_name": "Semiquot.nonempty", "code": "theorem nonempty (q : Semiquot \u03b1) : q.s.Nonempty", "start": [66, 1], "end": [67, 15], "kind": "commanddeclaration"}, {"full_name": "Semiquot.pure", "code": "protected def pure (a : \u03b1) : Semiquot \u03b1 :=\n  mk (Set.mem_singleton a)", "start": [70, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_pure'", "code": "@[simp]\ntheorem mem_pure' {a b : \u03b1} : a \u2208 Semiquot.pure b \u2194 a = b", "start": [75, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Semiquot.blur'", "code": "def blur' (q : Semiquot \u03b1) {s : Set \u03b1} (h : q.s \u2286 s) : Semiquot \u03b1 :=\n  \u27e8s, Trunc.lift (fun a : q.s => Trunc.mk \u27e8a.1, h a.2\u27e9) (fun _ _ => Trunc.eq _ _) q.2\u27e9", "start": [80, 1], "end": [82, 87], "kind": "commanddeclaration"}, {"full_name": "Semiquot.blur", "code": "def blur (s : Set \u03b1) (q : Semiquot \u03b1) : Semiquot \u03b1 :=\n  blur' q (Set.subset_union_right s q.s)", "start": [85, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "Semiquot.blur_eq_blur'", "code": "theorem blur_eq_blur' (q : Semiquot \u03b1) (s : Set \u03b1) (h : q.s \u2286 s) : blur s q = blur' q h", "start": [90, 1], "end": [91, 64], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_blur'", "code": "@[simp]\ntheorem mem_blur' (q : Semiquot \u03b1) {s : Set \u03b1} (h : q.s \u2286 s) {a : \u03b1} : a \u2208 blur' q h \u2194 a \u2208 s", "start": [94, 1], "end": [96, 10], "kind": "commanddeclaration"}, {"full_name": "Semiquot.ofTrunc", "code": "def ofTrunc (q : Trunc \u03b1) : Semiquot \u03b1 :=\n  \u27e8Set.univ, q.map fun a => \u27e8a, trivial\u27e9\u27e9", "start": [99, 1], "end": [101, 42], "kind": "commanddeclaration"}, {"full_name": "Semiquot.toTrunc", "code": "def toTrunc (q : Semiquot \u03b1) : Trunc \u03b1 :=\n  q.2.map Subtype.val", "start": [104, 1], "end": [106, 22], "kind": "commanddeclaration"}, {"full_name": "Semiquot.liftOn", "code": "def liftOn (q : Semiquot \u03b1) (f : \u03b1 \u2192 \u03b2) (h : \u2200 (a) (_ : a \u2208 q) (b) (_ : b \u2208 q), f a = f b) : \u03b2 :=\n  Trunc.liftOn q.2 (fun x => f x.1) fun x y => h _ x.2 _ y.2", "start": [111, 1], "end": [114, 61], "kind": "commanddeclaration"}, {"full_name": "Semiquot.liftOn_ofMem", "code": "theorem liftOn_ofMem (q : Semiquot \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 (a) (_ : a \u2208 q) (b) (_ : b \u2208 q), f a = f b) (a : \u03b1) (aq : a \u2208 q) : liftOn q f h = f a", "start": [119, 1], "end": [121, 48], "kind": "commanddeclaration"}, {"full_name": "Semiquot.map", "code": "def map (f : \u03b1 \u2192 \u03b2) (q : Semiquot \u03b1) : Semiquot \u03b2 :=\n  \u27e8f '' q.1, q.2.map fun x => \u27e8f x.1, Set.mem_image_of_mem _ x.2\u27e9\u27e9", "start": [124, 1], "end": [126, 67], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_map", "code": "@[simp]\ntheorem mem_map (f : \u03b1 \u2192 \u03b2) (q : Semiquot \u03b1) (b : \u03b2) : b \u2208 map f q \u2194 \u2203 a, a \u2208 q \u2227 f a = b", "start": [129, 1], "end": [131, 22], "kind": "commanddeclaration"}, {"full_name": "Semiquot.bind", "code": "def bind (q : Semiquot \u03b1) (f : \u03b1 \u2192 Semiquot \u03b2) : Semiquot \u03b2 :=\n  \u27e8\u22c3 a \u2208 q.1, (f a).1, q.2.bind fun a => (f a.1).2.map fun b => \u27e8b.1, Set.mem_biUnion a.2 b.2\u27e9\u27e9", "start": [134, 1], "end": [136, 96], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_bind", "code": "@[simp]\ntheorem mem_bind (q : Semiquot \u03b1) (f : \u03b1 \u2192 Semiquot \u03b2) (b : \u03b2) : b \u2208 bind q f \u2194 \u2203 a \u2208 q, b \u2208 f a", "start": [139, 1], "end": [141, 52], "kind": "commanddeclaration"}, {"full_name": "Semiquot.map_def", "code": "@[simp]\ntheorem map_def {\u03b2} : ((\u00b7 <$> \u00b7) : (\u03b1 \u2192 \u03b2) \u2192 Semiquot \u03b1 \u2192 Semiquot \u03b2) = map", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "Semiquot.bind_def", "code": "@[simp]\ntheorem bind_def {\u03b2} : ((\u00b7 >>= \u00b7) : Semiquot \u03b1 \u2192 (\u03b1 \u2192 Semiquot \u03b2) \u2192 Semiquot \u03b2) = bind", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_pure", "code": "@[simp]\ntheorem mem_pure {a b : \u03b1} : a \u2208 (pure b : Semiquot \u03b1) \u2194 a = b", "start": [159, 1], "end": [161, 24], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_pure_self", "code": "theorem mem_pure_self (a : \u03b1) : a \u2208 (pure a : Semiquot \u03b1)", "start": [164, 1], "end": [165, 22], "kind": "commanddeclaration"}, {"full_name": "Semiquot.pure_inj", "code": "@[simp]\ntheorem pure_inj {a b : \u03b1} : (pure a : Semiquot \u03b1) = pure b \u2194 a = b", "start": [168, 1], "end": [170, 45], "kind": "commanddeclaration"}, {"full_name": "Semiquot.partialOrder", "code": "instance partialOrder : PartialOrder (Semiquot \u03b1) where\n  le s t := \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 t\n  le_refl s := Set.Subset.refl _\n  le_trans s t u := Set.Subset.trans\n  le_antisymm s t h\u2081 h\u2082 := ext_s.2 (Set.Subset.antisymm h\u2081 h\u2082)", "start": [186, 1], "end": [190, 63], "kind": "commanddeclaration"}, {"full_name": "Semiquot.pure_le", "code": "@[simp]\ntheorem pure_le {a : \u03b1} {s : Semiquot \u03b1} : pure a \u2264 s \u2194 a \u2208 s", "start": [199, 1], "end": [201, 27], "kind": "commanddeclaration"}, {"full_name": "Semiquot.IsPure", "code": "def IsPure (q : Semiquot \u03b1) : Prop :=\n  \u2200 (a) (_ : a \u2208 q) (b) (_ : b \u2208 q), a = b", "start": [206, 1], "end": [208, 43], "kind": "commanddeclaration"}, {"full_name": "Semiquot.get", "code": "def get (q : Semiquot \u03b1) (h : q.IsPure) : \u03b1 :=\n  liftOn q id h", "start": [211, 1], "end": [213, 16], "kind": "commanddeclaration"}, {"full_name": "Semiquot.get_mem", "code": "theorem get_mem {q : Semiquot \u03b1} (p) : get q p \u2208 q", "start": [216, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "Semiquot.eq_pure", "code": "theorem eq_pure {q : Semiquot \u03b1} (p) : q = pure (get q p)", "start": [221, 1], "end": [222, 92], "kind": "commanddeclaration"}, {"full_name": "Semiquot.pure_isPure", "code": "@[simp]\ntheorem pure_isPure (a : \u03b1) : IsPure (pure a)", "start": [225, 1], "end": [229, 20], "kind": "commanddeclaration"}, {"full_name": "Semiquot.isPure_iff", "code": "theorem isPure_iff {s : Semiquot \u03b1} : IsPure s \u2194 \u2203 a, s = pure a", "start": [232, 1], "end": [233, 66], "kind": "commanddeclaration"}, {"full_name": "Semiquot.IsPure.mono", "code": "theorem IsPure.mono {s t : Semiquot \u03b1} (st : s \u2264 t) (h : IsPure t) : IsPure s", "start": [236, 1], "end": [237, 42], "kind": "commanddeclaration"}, {"full_name": "Semiquot.IsPure.min", "code": "theorem IsPure.min {s t : Semiquot \u03b1} (h : IsPure t) : s \u2264 t \u2194 s = t", "start": [240, 1], "end": [244, 14], "kind": "commanddeclaration"}, {"full_name": "Semiquot.isPure_of_subsingleton", "code": "theorem isPure_of_subsingleton [Subsingleton \u03b1] (q : Semiquot \u03b1) : IsPure q", "start": [247, 1], "end": [248, 40], "kind": "commanddeclaration"}, {"full_name": "Semiquot.univ", "code": "def univ [Inhabited \u03b1] : Semiquot \u03b1 :=\n  mk <| Set.mem_univ default", "start": [251, 1], "end": [253, 29], "kind": "commanddeclaration"}, {"full_name": "Semiquot.mem_univ", "code": "@[simp]\ntheorem mem_univ [Inhabited \u03b1] : \u2200 a, a \u2208 @univ \u03b1 _", "start": [259, 1], "end": [261, 18], "kind": "commanddeclaration"}, {"full_name": "Semiquot.univ_unique", "code": "@[congr]\ntheorem univ_unique (I J : Inhabited \u03b1) : @univ _ I = @univ _ J", "start": [264, 1], "end": [266, 36], "kind": "commanddeclaration"}, {"full_name": "Semiquot.isPure_univ", "code": "@[simp]\ntheorem isPure_univ [Inhabited \u03b1] : @IsPure \u03b1 univ \u2194 Subsingleton \u03b1", "start": [269, 1], "end": [271, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Locale.lean", "imports": ["Mathlib/Order/Category/Frm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Locale", "code": "def Locale :=\n  Frm\u1d52\u1d56 deriving LargeCategory", "start": [23, 1], "end": [25, 31], "kind": "commanddeclaration"}, {"full_name": "Locale.of", "code": "def of (\u03b1 : Type*) [Frame \u03b1] : Locale :=\n  op <| Frm.of \u03b1", "start": [36, 1], "end": [38, 17], "kind": "commanddeclaration"}, {"full_name": "Locale.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [Frame \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "topToLocale", "code": "@[simps!]\ndef topToLocale : TopCat \u2964 Locale :=\n  topCatOpToFrm.rightOp", "start": [51, 1], "end": [55, 24], "kind": "commanddeclaration"}, {"full_name": "CompHausToLocale.faithful", "code": "instance CompHausToLocale.faithful : Faithful (compHausToTop \u22d9 topToLocale.{u}) :=\n  \u27e8fun h => by\n    dsimp at h\n    exact Opens.comap_injective (Quiver.Hom.op_inj h)\u27e9", "start": [59, 1], "end": [62, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Norm.lean", "imports": ["Mathlib/RingTheory/Norm.lean", "Mathlib/LinearAlgebra/FreeModule/IdealQuotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "associated_norm_prod_smith", "code": "theorem associated_norm_prod_smith [Fintype \u03b9] (b : Basis \u03b9 R S) {f : S} (hf : f \u2260 0) :\n    Associated (Algebra.norm R f) (\u220f i, smithCoeffs b _ (span_singleton_eq_bot.not.2 hf) i)", "start": [27, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "finrank_quotient_span_eq_natDegree_norm", "code": "theorem finrank_quotient_span_eq_natDegree_norm [Algebra F S] [IsScalarTower F F[X] S]\n    (b : Basis \u03b9 F[X] S) {f : S} (hf : f \u2260 0) :\n    FiniteDimensional.finrank F (S \u29f8 span ({f} : Set S)) = (Algebra.norm F[X] f).natDegree", "start": [72, 1], "end": [84, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/EllipticCurve/Weierstrass.lean", "imports": ["Mathlib/Algebra/CubicDiscriminant.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/RingTheory/Norm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WeierstrassCurve", "code": "@[ext]\nstructure WeierstrassCurve (R : Type u) where\n  (a\u2081 a\u2082 a\u2083 a\u2084 a\u2086 : R)", "start": [98, 1], "end": [101, 23], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.instInhabitedWeierstrassCurve", "code": "instance instInhabitedWeierstrassCurve [Inhabited R] : Inhabited <| WeierstrassCurve R :=\n  \u27e8\u27e8default, default, default, default, default\u27e9\u27e9", "start": [121, 1], "end": [122, 50], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.b\u2082", "code": "def b\u2082 : R :=\n  W.a\u2081 ^ 2 + 4 * W.a\u2082", "start": [132, 1], "end": [134, 22], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.b\u2084", "code": "def b\u2084 : R :=\n  2 * W.a\u2084 + W.a\u2081 * W.a\u2083", "start": [138, 1], "end": [140, 25], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.b\u2086", "code": "def b\u2086 : R :=\n  W.a\u2083 ^ 2 + 4 * W.a\u2086", "start": [144, 1], "end": [146, 22], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.b\u2088", "code": "def b\u2088 : R :=\n  W.a\u2081 ^ 2 * W.a\u2086 + 4 * W.a\u2082 * W.a\u2086 - W.a\u2081 * W.a\u2083 * W.a\u2084 + W.a\u2082 * W.a\u2083 ^ 2 - W.a\u2084 ^ 2", "start": [150, 1], "end": [152, 86], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.b_relation", "code": "lemma b_relation : 4 * W.b\u2088 = W.b\u2082 * W.b\u2086 - W.b\u2084 ^ 2 := by\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088]\n  ring1", "start": [155, 1], "end": [157, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.c\u2084", "code": "def c\u2084 : R :=\n  W.b\u2082 ^ 2 - 24 * W.b\u2084", "start": [161, 1], "end": [163, 23], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.c\u2086", "code": "def c\u2086 : R :=\n  -W.b\u2082 ^ 3 + 36 * W.b\u2082 * W.b\u2084 - 216 * W.b\u2086", "start": [167, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.\u0394", "code": "def \u0394 : R :=\n  -W.b\u2082 ^ 2 * W.b\u2088 - 8 * W.b\u2084 ^ 3 - 27 * W.b\u2086 ^ 2 + 9 * W.b\u2082 * W.b\u2084 * W.b\u2086", "start": [173, 1], "end": [178, 75], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.c_relation", "code": "lemma c_relation : 1728 * W.\u0394 = W.c\u2084 ^ 3 - W.c\u2086 ^ 2 := by\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088, c\u2084, c\u2086, \u0394]\n  ring1", "start": [181, 1], "end": [183, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ0", "code": "def ofJ0 : WeierstrassCurve R :=\n  \u27e80, 0, 1, 0, 0\u27e9", "start": [192, 1], "end": [195, 18], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.ofJ0_c\u2084", "code": "lemma ofJ0_c\u2084 : (ofJ0 R).c\u2084 = 0 := by\n  rw [ofJ0, c\u2084, b\u2082, b\u2084]\n  norm_num1", "start": [197, 1], "end": [199, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ0_\u0394", "code": "lemma ofJ0_\u0394 : (ofJ0 R).\u0394 = -27 := by\n  rw [ofJ0, \u0394, b\u2082, b\u2084, b\u2086, b\u2088]\n  norm_num1", "start": [201, 1], "end": [203, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ1728", "code": "def ofJ1728 : WeierstrassCurve R :=\n  \u27e80, 0, 0, 1, 0\u27e9", "start": [205, 1], "end": [208, 18], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.ofJ1728_c\u2084", "code": "lemma ofJ1728_c\u2084 : (ofJ1728 R).c\u2084 = -48 := by\n  rw [ofJ1728, c\u2084, b\u2082, b\u2084]\n  norm_num1", "start": [210, 1], "end": [212, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ1728_\u0394", "code": "lemma ofJ1728_\u0394 : (ofJ1728 R).\u0394 = -64 := by\n  rw [ofJ1728, \u0394, b\u2082, b\u2084, b\u2086, b\u2088]\n  norm_num1", "start": [214, 1], "end": [216, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ", "code": "def ofJ : WeierstrassCurve R :=\n  \u27e8j - 1728, 0, 0, -36 * (j - 1728) ^ 3, -(j - 1728) ^ 5\u27e9", "start": [220, 1], "end": [223, 58], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.ofJ_c\u2084", "code": "lemma ofJ_c\u2084 : (ofJ j).c\u2084 = j * (j - 1728) ^ 3 := by\n  simp only [ofJ, c\u2084, b\u2082, b\u2084]\n  ring1", "start": [225, 1], "end": [227, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.ofJ_\u0394", "code": "lemma ofJ_\u0394 : (ofJ j).\u0394 = j ^ 2 * (j - 1728) ^ 9 := by\n  simp only [ofJ, \u0394, b\u2082, b\u2084, b\u2086, b\u2088]\n  ring1", "start": [229, 1], "end": [231, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange", "code": "@[ext]\nstructure VariableChange (R : Type u) [CommRing R] where\n  (u : R\u02e3)\n  (r s t : R)", "start": [239, 1], "end": [249, 14], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.id", "code": "def id : VariableChange R :=\n  \u27e81, 0, 0, 0\u27e9", "start": [267, 1], "end": [269, 15], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.comp", "code": "def comp : VariableChange R where\n  u := C.u * C'.u\n  r := C.r * \u2191C'.u ^ 2 + C'.r\n  s := \u2191C'.u * C.s + C'.s\n  t := C.t * \u2191C'.u ^ 3 + C.r * C'.s * \u2191C'.u ^ 2 + C'.t", "start": [271, 1], "end": [277, 55], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.inv", "code": "def inv : VariableChange R where\n  u := C.u\u207b\u00b9\n  r := -C.r * \u2191C.u\u207b\u00b9 ^ 2\n  s := -C.s * \u2191C.u\u207b\u00b9\n  t := (C.r * C.s - C.t) * \u2191C.u\u207b\u00b9 ^ 3", "start": [279, 1], "end": [284, 38], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.id_comp", "code": "lemma id_comp (C : VariableChange R) : comp id C = C := by\n  simp only [comp, id, zero_add, zero_mul, mul_zero, one_mul]", "start": [286, 1], "end": [287, 62], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.comp_id", "code": "lemma comp_id (C : VariableChange R) : comp C id = C := by\n  simp only [comp, id, add_zero, mul_zero, one_mul, mul_one, one_pow, Units.val_one]", "start": [289, 1], "end": [290, 85], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.comp_left_inv", "code": "lemma comp_left_inv (C : VariableChange R) : comp (inv C) C = id := by\n  rw [comp, id, inv]\n  ext <;> dsimp only\n  \u00b7 exact C.u.inv_mul\n  \u00b7 linear_combination (norm := ring1) -C.r * pow_mul_pow_eq_one 2 C.u.inv_mul\n  \u00b7 linear_combination (norm := ring1) -C.s * C.u.inv_mul\n  \u00b7 linear_combination (norm := ring1)\n      (C.r * C.s - C.t) * pow_mul_pow_eq_one 3 C.u.inv_mul\n        + -C.r * C.s * pow_mul_pow_eq_one 2 C.u.inv_mul", "start": [292, 1], "end": [300, 56], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.comp_assoc", "code": "lemma comp_assoc (C C' C'' : VariableChange R) : comp (comp C C') C'' = comp C (comp C' C'') := by\n  ext <;> simp only [comp, Units.val_mul] <;> ring1", "start": [302, 1], "end": [303, 52], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.instGroupVariableChange", "code": "instance instGroupVariableChange : Group (VariableChange R) where\n  one := id\n  inv := inv\n  mul := comp\n  one_mul := id_comp\n  mul_one := comp_id\n  mul_left_inv := comp_left_inv\n  mul_assoc := comp_assoc", "start": [305, 1], "end": [312, 26], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.variableChange", "code": "@[simps]\ndef variableChange : WeierstrassCurve R where\n  a\u2081 := \u2191C.u\u207b\u00b9 * (W.a\u2081 + 2 * C.s)\n  a\u2082 := \u2191C.u\u207b\u00b9 ^ 2 * (W.a\u2082 - C.s * W.a\u2081 + 3 * C.r - C.s ^ 2)\n  a\u2083 := \u2191C.u\u207b\u00b9 ^ 3 * (W.a\u2083 + C.r * W.a\u2081 + 2 * C.t)\n  a\u2084 := \u2191C.u\u207b\u00b9 ^ 4 * (W.a\u2084 - C.s * W.a\u2083 + 2 * C.r * W.a\u2082 - (C.t + C.r * C.s) * W.a\u2081 + 3 * C.r ^ 2\n    - 2 * C.s * C.t)\n  a\u2086 := \u2191C.u\u207b\u00b9 ^ 6 * (W.a\u2086 + C.r * W.a\u2084 + C.r ^ 2 * W.a\u2082 + C.r ^ 3 - C.t * W.a\u2083 - C.t ^ 2\n    - C.r * C.t * W.a\u2081)", "start": [318, 1], "end": [328, 24], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.variableChange_id", "code": "lemma variableChange_id : W.variableChange VariableChange.id = W := by\n  rw [VariableChange.id, variableChange, inv_one, Units.val_one]\n  ext <;> (dsimp only; ring1)", "start": [331, 1], "end": [333, 30], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_comp", "code": "lemma variableChange_comp (C C' : VariableChange R) (W : WeierstrassCurve R) :\n    W.variableChange (C.comp C') = (W.variableChange C').variableChange C := by\n  simp only [VariableChange.comp, variableChange]\n  ext <;> simp only [mul_inv, Units.val_mul]\n  \u00b7 linear_combination (norm := ring1) \u2191C.u\u207b\u00b9 * C.s * 2 * C'.u.inv_mul\n  \u00b7 linear_combination (norm := ring1)\n      C.s * (-C'.s * 2 - W.a\u2081) * (\u2191C.u\u207b\u00b9 : R) ^ 2 * \u2191C'.u\u207b\u00b9 * C'.u.inv_mul\n        + (C.r * 3 - C.s ^ 2) * (\u2191C.u\u207b\u00b9 : R) ^ 2 * pow_mul_pow_eq_one 2 C'.u.inv_mul\n  \u00b7 linear_combination (norm := ring1)\n      C.r * (C'.s * 2 + W.a\u2081) * (\u2191C.u\u207b\u00b9 : R) ^ 3 * \u2191C'.u\u207b\u00b9 * pow_mul_pow_eq_one 2 C'.u.inv_mul\n        + C.t * 2 * (\u2191C.u\u207b\u00b9 : R) ^ 3 * pow_mul_pow_eq_one 3 C'.u.inv_mul\n  \u00b7 linear_combination (norm := ring1)\n      C.s * (-W.a\u2083 - C'.r * W.a\u2081 - C'.t * 2) * (\u2191C.u\u207b\u00b9 : R) ^ 4 * (\u2191C'.u\u207b\u00b9 : R) ^ 3 * C'.u.inv_mul\n        + (\u2191C.u\u207b\u00b9 : R) ^ 4 * (\u2191C'.u\u207b\u00b9 : R) ^ 2\n          * (C.r * C'.r * 6 + C.r * W.a\u2082 * 2 - C'.s * C.r * W.a\u2081 * 2 - C'.s ^ 2 * C.r * 2)\n          * pow_mul_pow_eq_one 2 C'.u.inv_mul\n        + -(\u2191C.u\u207b\u00b9 : R) ^ 4\n          * \u2191C'.u\u207b\u00b9 * (C.s * C'.s * C.r * 2 + C.s * C.r * W.a\u2081 + C'.s * C.t * 2 + C.t * W.a\u2081)\n          * pow_mul_pow_eq_one 3 C'.u.inv_mul\n        + (\u2191C.u\u207b\u00b9 : R) ^ 4 * (C.r ^ 2 * 3 - C.s * C.t * 2) * pow_mul_pow_eq_one 4 C'.u.inv_mul\n  \u00b7 linear_combination (norm := ring1)\n      C.r * (\u2191C.u\u207b\u00b9 : R) ^ 6 * (\u2191C'.u\u207b\u00b9 : R) ^ 4 * (C'.r * W.a\u2082 * 2 - C'.r * C'.s * W.a\u2081\n          + C'.r ^ 2 * 3 + W.a\u2084 - C'.s * C'.t * 2 - C'.s * W.a\u2083 - C'.t * W.a\u2081)\n          * pow_mul_pow_eq_one 2 C'.u.inv_mul\n        + -(\u2191C.u\u207b\u00b9 : R) ^ 6 * (\u2191C'.u\u207b\u00b9 : R) ^ 3 * C.t * (C'.r * W.a\u2081 + C'.t * 2 + W.a\u2083)\n          * pow_mul_pow_eq_one 3 C'.u.inv_mul\n        + C.r ^ 2 * (\u2191C.u\u207b\u00b9 : R) ^ 6 * (\u2191C'.u\u207b\u00b9 : R) ^ 2\n          * (C'.r * 3 + W.a\u2082 - C'.s * W.a\u2081 - C'.s ^ 2) * pow_mul_pow_eq_one 4 C'.u.inv_mul\n        + -C.r * C.t * (\u2191C.u\u207b\u00b9 : R) ^ 6 * \u2191C'.u\u207b\u00b9 * (C'.s * 2 + W.a\u2081)\n          * pow_mul_pow_eq_one 5 C'.u.inv_mul\n        + (\u2191C.u\u207b\u00b9 : R) ^ 6 * (C.r ^ 3 - C.t ^ 2) * pow_mul_pow_eq_one 6 C'.u.inv_mul", "start": [335, 1], "end": [365, 85], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.instMulActionVariableChange", "code": "instance instMulActionVariableChange : MulAction (VariableChange R) (WeierstrassCurve R) where\n  smul := fun C W => W.variableChange C\n  one_smul := variableChange_id\n  mul_smul := variableChange_comp", "start": [367, 1], "end": [370, 34], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.variableChange_b\u2082", "code": "@[simp]\nlemma variableChange_b\u2082 : (W.variableChange C).b\u2082 = (\u2191C.u\u207b\u00b9 : R) ^ 2 * (W.b\u2082 + 12 * C.r) := by\n  simp only [b\u2082, variableChange_a\u2081, variableChange_a\u2082]\n  ring1", "start": [372, 1], "end": [375, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_b\u2084", "code": "@[simp]\nlemma variableChange_b\u2084 :\n    (W.variableChange C).b\u2084 = (\u2191C.u\u207b\u00b9 : R) ^ 4 * (W.b\u2084 + C.r * W.b\u2082 + 6 * C.r ^ 2) := by\n  simp only [b\u2082, b\u2084, variableChange_a\u2081, variableChange_a\u2083, variableChange_a\u2084]\n  ring1", "start": [378, 1], "end": [382, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_b\u2086", "code": "@[simp]\nlemma variableChange_b\u2086 :\n    (W.variableChange C).b\u2086 =\n      (\u2191C.u\u207b\u00b9 : R) ^ 6 * (W.b\u2086 + 2 * C.r * W.b\u2084 + C.r ^ 2 * W.b\u2082 + 4 * C.r ^ 3) := by\n  simp only [b\u2082, b\u2084, b\u2086, variableChange_a\u2083, variableChange_a\u2086]\n  ring1", "start": [385, 1], "end": [390, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_b\u2088", "code": "@[simp]\nlemma variableChange_b\u2088 :\n    (W.variableChange C).b\u2088 =\n      (\u2191C.u\u207b\u00b9 : R) ^ 8 * (W.b\u2088 + 3 * C.r * W.b\u2086 + 3 * C.r ^ 2 * W.b\u2084 + C.r ^ 3 * W.b\u2082\n        + 3 * C.r ^ 4) := by\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088, variableChange_a\u2081, variableChange_a\u2082, variableChange_a\u2083,\n    variableChange_a\u2084, variableChange_a\u2086]\n  ring1", "start": [393, 1], "end": [400, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_c\u2084", "code": "@[simp]\nlemma variableChange_c\u2084 : (W.variableChange C).c\u2084 = (\u2191C.u\u207b\u00b9 : R) ^ 4 * W.c\u2084 := by\n  simp only [c\u2084, variableChange_b\u2082, variableChange_b\u2084]\n  ring1", "start": [403, 1], "end": [406, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_c\u2086", "code": "@[simp]\nlemma variableChange_c\u2086 : (W.variableChange C).c\u2086 = (\u2191C.u\u207b\u00b9 : R) ^ 6 * W.c\u2086 := by\n  simp only [c\u2086, variableChange_b\u2082, variableChange_b\u2084, variableChange_b\u2086]\n  ring1", "start": [409, 1], "end": [412, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.variableChange_\u0394", "code": "@[simp]\nlemma variableChange_\u0394 : (W.variableChange C).\u0394 = (\u2191C.u\u207b\u00b9 : R) ^ 12 * W.\u0394 := by\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088, \u0394, variableChange_a\u2081, variableChange_a\u2082, variableChange_a\u2083,\n    variableChange_a\u2084, variableChange_a\u2086]\n  ring1", "start": [415, 1], "end": [419, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange", "code": "@[simps]\ndef baseChange : WeierstrassCurve A :=\n  \u27e8algebraMap R A W.a\u2081, algebraMap R A W.a\u2082, algebraMap R A W.a\u2083, algebraMap R A W.a\u2084,\n    algebraMap R A W.a\u2086\u27e9", "start": [431, 1], "end": [435, 25], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.baseChange_b\u2082", "code": "@[simp]\nlemma baseChange_b\u2082 : (W.baseChange A).b\u2082 = algebraMap R A W.b\u2082 := by\n  simp only [b\u2082, baseChange_a\u2081, baseChange_a\u2082]\n  map_simp", "start": [438, 1], "end": [441, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_b\u2084", "code": "@[simp]\nlemma baseChange_b\u2084 : (W.baseChange A).b\u2084 = algebraMap R A W.b\u2084 := by\n  simp only [b\u2084, baseChange_a\u2081, baseChange_a\u2083, baseChange_a\u2084]\n  map_simp", "start": [444, 1], "end": [447, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_b\u2086", "code": "@[simp]\nlemma baseChange_b\u2086 : (W.baseChange A).b\u2086 = algebraMap R A W.b\u2086 := by\n  simp only [b\u2086, baseChange_a\u2083, baseChange_a\u2086]\n  map_simp", "start": [450, 1], "end": [453, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_b\u2088", "code": "@[simp]\nlemma baseChange_b\u2088 : (W.baseChange A).b\u2088 = algebraMap R A W.b\u2088 := by\n  simp only [b\u2088, baseChange_a\u2081, baseChange_a\u2082, baseChange_a\u2083, baseChange_a\u2084, baseChange_a\u2086]\n  map_simp", "start": [456, 1], "end": [459, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_c\u2084", "code": "@[simp]\nlemma baseChange_c\u2084 : (W.baseChange A).c\u2084 = algebraMap R A W.c\u2084 := by\n  simp only [c\u2084, baseChange_b\u2082, baseChange_b\u2084]\n  map_simp", "start": [462, 1], "end": [465, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_c\u2086", "code": "@[simp]\nlemma baseChange_c\u2086 : (W.baseChange A).c\u2086 = algebraMap R A W.c\u2086 := by\n  simp only [c\u2086, baseChange_b\u2082, baseChange_b\u2084, baseChange_b\u2086]\n  map_simp", "start": [468, 1], "end": [471, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_\u0394", "code": "@[simp]\nlemma baseChange_\u0394 : (W.baseChange A).\u0394 = algebraMap R A W.\u0394 := by\n  simp only [\u0394, baseChange_b\u2082, baseChange_b\u2084, baseChange_b\u2086, baseChange_b\u2088]\n  map_simp", "start": [474, 1], "end": [477, 11], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_self", "code": "lemma baseChange_self : W.baseChange R = W := by\n  ext <;> rfl", "start": [480, 1], "end": [481, 14], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_baseChange", "code": "lemma baseChange_baseChange : (W.baseChange A).baseChange B = W.baseChange B := by\n  ext <;> exact (IsScalarTower.algebraMap_apply R A B _).symm", "start": [484, 1], "end": [485, 62], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_injective", "code": "lemma baseChange_injective (h : Function.Injective <| algebraMap R A) :\n    Function.Injective <| baseChange (R := R) (A := A) := fun W W' h1 => by\n  rcases mk.inj h1 with \u27e8_, _, _, _, _\u27e9\n  ext <;> apply_fun _ using h <;> assumption", "start": [488, 1], "end": [491, 45], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange", "code": "@[simps]\ndef baseChange : VariableChange A :=\n  \u27e8Units.map (algebraMap R A) C.u, algebraMap R A C.r, algebraMap R A C.s, algebraMap R A C.t\u27e9", "start": [497, 1], "end": [500, 95], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange_id", "code": "lemma baseChange_id : baseChange A (id : VariableChange R) = id := by\n  simp only [id, baseChange]\n  ext <;> simp only [map_one, Units.val_one, map_zero]", "start": [502, 1], "end": [504, 55], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange_comp", "code": "lemma baseChange_comp (C' : VariableChange R) :\n    baseChange A (C.comp C') = (baseChange A C).comp (baseChange A C') := by\n  simp only [comp, baseChange]\n  ext <;> simp only [Units.coe_map, Units.coe_map_inv, MonoidHom.coe_coe,\n    map_ofNat, map_neg, map_add, map_sub, map_mul, map_pow]", "start": [506, 1], "end": [510, 60], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.baseChangeMap", "code": "def baseChangeMap : VariableChange R \u2192* VariableChange A where\n  toFun := baseChange A\n  map_one' := baseChange_id A\n  map_mul' := baseChange_comp A", "start": [512, 1], "end": [516, 32], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange_self", "code": "lemma baseChange_self : C.baseChange R = C :=\n  rfl", "start": [518, 1], "end": [519, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange_baseChange", "code": "lemma baseChange_baseChange : (C.baseChange A).baseChange B = C.baseChange B := by\n  ext <;> exact (IsScalarTower.algebraMap_apply R A B _).symm", "start": [521, 1], "end": [522, 62], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.VariableChange.baseChange_injective", "code": "lemma baseChange_injective (h : Function.Injective <| algebraMap R A) :\n    Function.Injective <| baseChange (R := R) A := fun C C' h1 => by\n  rcases mk.inj h1 with \u27e8h1, _, _, _\u27e9\n  replace h1 := (Units.mk.inj h1).left\n  ext <;> apply_fun _ using h <;> assumption", "start": [524, 1], "end": [528, 45], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.baseChange_variableChange", "code": "lemma baseChange_variableChange (C : VariableChange R) :\n    (W.baseChange A).variableChange (C.baseChange A) = (W.variableChange C).baseChange A := by\n  simp only [baseChange, variableChange, VariableChange.baseChange]\n  ext <;> simp only [Units.coe_map, Units.coe_map_inv, MonoidHom.coe_coe,\n    map_ofNat, map_neg, map_add, map_sub, map_mul, map_pow]", "start": [532, 1], "end": [536, 60], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.twoTorsionPolynomial", "code": "def twoTorsionPolynomial : Cubic R :=\n  \u27e84, W.b\u2082, 2 * W.b\u2084, W.b\u2086\u27e9", "start": [544, 1], "end": [548, 28], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.twoTorsionPolynomial_disc", "code": "lemma twoTorsionPolynomial_disc : W.twoTorsionPolynomial.disc = 16 * W.\u0394 := by\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088, \u0394, twoTorsionPolynomial, Cubic.disc]\n  ring1", "start": [551, 1], "end": [553, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.twoTorsionPolynomial_disc_isUnit", "code": "lemma twoTorsionPolynomial_disc_isUnit [Invertible (2 : R)] :\n    IsUnit W.twoTorsionPolynomial.disc \u2194 IsUnit W.\u0394 := by\n  rw [twoTorsionPolynomial_disc, IsUnit.mul_iff, show (16 : R) = 2 ^ 4 by norm_num1]\n  exact and_iff_right <| isUnit_of_invertible <| 2 ^ 4", "start": [556, 1], "end": [559, 55], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.twoTorsionPolynomial_disc_ne_zero", "code": "lemma twoTorsionPolynomial_disc_ne_zero [Nontrivial R] [Invertible (2 : R)] (h\u0394 : IsUnit W.\u0394) :\n    W.twoTorsionPolynomial.disc \u2260 0 :=\n  (W.twoTorsionPolynomial_disc_isUnit.mpr h\u0394).ne_zero", "start": [562, 1], "end": [564, 54], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.polynomial", "code": "protected noncomputable def polynomial : R[X][Y] :=\n  Y ^ 2 + C (C W.a\u2081 * X + C W.a\u2083) * Y - C (X ^ 3 + C W.a\u2082 * X ^ 2 + C W.a\u2084 * X + C W.a\u2086)", "start": [591, 1], "end": [597, 89], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.polynomial_eq", "code": "lemma polynomial_eq :\n    W.polynomial =\n      Cubic.toPoly\n        \u27e80, 1, Cubic.toPoly \u27e80, 0, W.a\u2081, W.a\u2083\u27e9, Cubic.toPoly \u27e8-1, -W.a\u2082, -W.a\u2084, -W.a\u2086\u27e9\u27e9 := by\n  simp only [WeierstrassCurve.polynomial, Cubic.toPoly]\n  C_simp\n  ring1", "start": [600, 1], "end": [606, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.polynomial_ne_zero", "code": "lemma polynomial_ne_zero [Nontrivial R] : W.polynomial \u2260 0 := by\n  rw [polynomial_eq]\n  exact Cubic.ne_zero_of_b_ne_zero one_ne_zero", "start": [609, 1], "end": [611, 47], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.degree_polynomial", "code": "@[simp]\nlemma degree_polynomial [Nontrivial R] : W.polynomial.degree = 2 := by\n  rw [polynomial_eq]\n  exact Cubic.degree_of_b_ne_zero' one_ne_zero", "start": [614, 1], "end": [617, 47], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.natDegree_polynomial", "code": "@[simp]\nlemma natDegree_polynomial [Nontrivial R] : W.polynomial.natDegree = 2 := by\n  rw [polynomial_eq]\n  exact Cubic.natDegree_of_b_ne_zero' one_ne_zero", "start": [620, 1], "end": [623, 50], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.monic_polynomial", "code": "lemma monic_polynomial : W.polynomial.Monic := by\n  nontriviality R\n  simpa only [polynomial_eq] using Cubic.monic_of_b_eq_one'", "start": [626, 1], "end": [628, 60], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.irreducible_polynomial", "code": "lemma irreducible_polynomial [IsDomain R] : Irreducible W.polynomial := by\n  by_contra h\n  rcases (W.monic_polynomial.not_irreducible_iff_exists_add_mul_eq_coeff W.natDegree_polynomial).mp\n    h with \u27e8f, g, h0, h1\u27e9\n  simp only [polynomial_eq, Cubic.coeff_eq_c, Cubic.coeff_eq_d] at h0 h1\n  apply_fun degree at h0 h1\n  rw [Cubic.degree_of_a_ne_zero' <| neg_ne_zero.mpr <| one_ne_zero' R, degree_mul] at h0\n  apply (h1.symm.le.trans Cubic.degree_of_b_eq_zero').not_lt\n  rcases Nat.WithBot.add_eq_three_iff.mp h0.symm with h | h | h | h\n  iterate 2 rw [degree_add_eq_right_of_degree_lt] <;> simp only [h]\n  iterate 2 rw [degree_add_eq_left_of_degree_lt] <;> simp only [h]", "start": [631, 1], "end": [642, 67], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.eval_polynomial", "code": "lemma eval_polynomial (x y : R) :\n    (W.polynomial.eval <| C y).eval x =\n      y ^ 2 + W.a\u2081 * x * y + W.a\u2083 * y - (x ^ 3 + W.a\u2082 * x ^ 2 + W.a\u2084 * x + W.a\u2086) := by\n  simp only [WeierstrassCurve.polynomial]\n  eval_simp\n  rw [add_mul, \u2190 add_assoc]", "start": [646, 1], "end": [651, 28], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.eval_polynomial_zero", "code": "@[simp]\nlemma eval_polynomial_zero : (W.polynomial.eval 0).eval 0 = -W.a\u2086 := by\n  simp only [\u2190 C_0, eval_polynomial, zero_add, zero_sub, mul_zero, zero_pow <| Nat.zero_lt_succ _]", "start": [654, 1], "end": [656, 99], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation", "code": "protected def equation (x y : R) : Prop :=\n  (W.polynomial.eval <| C y).eval x = 0", "start": [660, 1], "end": [662, 40], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.equation_iff'", "code": "lemma equation_iff' (x y : R) :\n    W.equation x y \u2194\n      y ^ 2 + W.a\u2081 * x * y + W.a\u2083 * y - (x ^ 3 + W.a\u2082 * x ^ 2 + W.a\u2084 * x + W.a\u2086) = 0 := by\n  rw [WeierstrassCurve.equation, eval_polynomial]", "start": [665, 1], "end": [668, 50], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_iff", "code": "lemma equation_iff (x y : R) :\n    W.equation x y \u2194 y ^ 2 + W.a\u2081 * x * y + W.a\u2083 * y = x ^ 3 + W.a\u2082 * x ^ 2 + W.a\u2084 * x + W.a\u2086 := by\n  rw [equation_iff', sub_eq_zero]", "start": [672, 1], "end": [674, 34], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_zero", "code": "@[simp]\nlemma equation_zero : W.equation 0 0 \u2194 W.a\u2086 = 0 := by\n  rw [WeierstrassCurve.equation, C_0, eval_polynomial_zero, neg_eq_zero]", "start": [677, 1], "end": [679, 73], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_iff_variableChange", "code": "lemma equation_iff_variableChange (x y : R) :\n    W.equation x y \u2194 (W.variableChange \u27e81, x, 0, y\u27e9).equation 0 0 := by\n  rw [equation_iff', \u2190 neg_eq_zero, equation_zero, variableChange_a\u2086, inv_one, Units.val_one]\n  congr! 1\n  ring1", "start": [682, 1], "end": [686, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_iff_baseChange", "code": "lemma equation_iff_baseChange [Nontrivial A] [NoZeroSMulDivisors R A] (x y : R) :\n    W.equation x y \u2194 (W.baseChange A).equation (algebraMap R A x) (algebraMap R A y) := by\n  simp only [equation_iff]\n  exact\n    \u27e8fun h => by convert congr_arg (algebraMap R A) h <;> map_simp <;> rfl,\n      fun h => by apply NoZeroSMulDivisors.algebraMap_injective R A; map_simp; exact h\u27e9", "start": [689, 1], "end": [694, 88], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.equation_iff_baseChange_of_baseChange", "code": "lemma equation_iff_baseChange_of_baseChange [Nontrivial B] [NoZeroSMulDivisors A B] (x y : A) :\n    (W.baseChange A).equation x y \u2194\n      (W.baseChange B).equation (algebraMap A B x) (algebraMap A B y) := by\n  rw [equation_iff_baseChange (W.baseChange A) B, baseChange_baseChange]", "start": [697, 1], "end": [700, 73], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.polynomialX", "code": "protected noncomputable def polynomialX : R[X][Y] :=\n  C (C W.a\u2081) * Y - C (C 3 * X ^ 2 + C (2 * W.a\u2082) * X + C W.a\u2084)", "start": [706, 1], "end": [710, 63], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.eval_polynomialX", "code": "lemma eval_polynomialX (x y : R) :\n    (W.polynomialX.eval <| C y).eval x = W.a\u2081 * y - (3 * x ^ 2 + 2 * W.a\u2082 * x + W.a\u2084) := by\n  simp only [WeierstrassCurve.polynomialX]\n  eval_simp", "start": [715, 1], "end": [718, 12], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.eval_polynomialX_zero", "code": "@[simp]\nlemma eval_polynomialX_zero : (W.polynomialX.eval 0).eval 0 = -W.a\u2084 := by\n  simp only [\u2190 C_0, eval_polynomialX, zero_add, zero_sub, mul_zero, zero_pow zero_lt_two]", "start": [722, 1], "end": [724, 90], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.polynomialY", "code": "protected noncomputable def polynomialY : R[X][Y] :=\n  C (C 2) * Y + C (C W.a\u2081 * X + C W.a\u2083)", "start": [729, 1], "end": [733, 40], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.eval_polynomialY", "code": "lemma eval_polynomialY (x y : R) :\n    (W.polynomialY.eval <| C y).eval x = 2 * y + W.a\u2081 * x + W.a\u2083 := by\n  simp only [WeierstrassCurve.polynomialY]\n  eval_simp\n  rw [\u2190 add_assoc]", "start": [738, 1], "end": [742, 19], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.eval_polynomialY_zero", "code": "@[simp]\nlemma eval_polynomialY_zero : (W.polynomialY.eval 0).eval 0 = W.a\u2083 := by\n  simp only [\u2190 C_0, eval_polynomialY, zero_add, mul_zero]", "start": [746, 1], "end": [748, 58], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular", "code": "protected def nonsingular (x y : R) : Prop :=\n  W.equation x y \u2227 ((W.polynomialX.eval <| C y).eval x \u2260 0 \u2228 (W.polynomialY.eval <| C y).eval x \u2260 0)", "start": [753, 1], "end": [756, 101], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.nonsingular_iff'", "code": "lemma nonsingular_iff' (x y : R) :\n    W.nonsingular x y \u2194\n      W.equation x y \u2227\n        (W.a\u2081 * y - (3 * x ^ 2 + 2 * W.a\u2082 * x + W.a\u2084) \u2260 0 \u2228 2 * y + W.a\u2081 * x + W.a\u2083 \u2260 0) := by\n  rw [WeierstrassCurve.nonsingular, equation_iff', eval_polynomialX, eval_polynomialY]", "start": [759, 1], "end": [763, 87], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_iff", "code": "lemma nonsingular_iff (x y : R) :\n    W.nonsingular x y \u2194\n      W.equation x y \u2227 (W.a\u2081 * y \u2260 3 * x ^ 2 + 2 * W.a\u2082 * x + W.a\u2084 \u2228 y \u2260 -y - W.a\u2081 * x - W.a\u2083) := by\n  rw [nonsingular_iff', sub_ne_zero, \u2190 @sub_ne_zero _ _ y]\n  congr! 3\n  ring1", "start": [767, 1], "end": [772, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_zero", "code": "@[simp]\nlemma nonsingular_zero : W.nonsingular 0 0 \u2194 W.a\u2086 = 0 \u2227 (W.a\u2083 \u2260 0 \u2228 W.a\u2084 \u2260 0) := by\n  rw [WeierstrassCurve.nonsingular, equation_zero, C_0, eval_polynomialX_zero, neg_ne_zero,\n    eval_polynomialY_zero, or_comm]", "start": [775, 1], "end": [778, 36], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_iff_variableChange", "code": "lemma nonsingular_iff_variableChange (x y : R) :\n    W.nonsingular x y \u2194 (W.variableChange \u27e81, x, 0, y\u27e9).nonsingular 0 0 := by\n  rw [nonsingular_iff', equation_iff_variableChange, equation_zero, \u2190 neg_ne_zero, or_comm,\n    nonsingular_zero, variableChange_a\u2083, variableChange_a\u2084, inv_one, Units.val_one]\n  simp only [variableChange]\n  congr! 3 <;> ring1", "start": [781, 1], "end": [786, 21], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_iff_baseChange", "code": "lemma nonsingular_iff_baseChange [Nontrivial A] [NoZeroSMulDivisors R A] (x y : R) :\n    W.nonsingular x y \u2194 (W.baseChange A).nonsingular (algebraMap R A x) (algebraMap R A y) := by\n  rw [nonsingular_iff, nonsingular_iff, and_congr <| W.equation_iff_baseChange A x y]\n  refine\n    \u27e8Or.imp (not_imp_not.mpr fun h => ?_) (not_imp_not.mpr fun h => ?_),\n      Or.imp (not_imp_not.mpr fun h => ?_) (not_imp_not.mpr fun h => ?_)\u27e9\n  any_goals apply NoZeroSMulDivisors.algebraMap_injective R A; map_simp; exact h\n  any_goals convert congr_arg (algebraMap R A) h <;> map_simp <;> rfl", "start": [789, 1], "end": [796, 70], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_iff_baseChange_of_baseChange", "code": "lemma nonsingular_iff_baseChange_of_baseChange [Nontrivial B] [NoZeroSMulDivisors A B] (x y : A) :\n    (W.baseChange A).nonsingular x y \u2194\n      (W.baseChange B).nonsingular (algebraMap A B x) (algebraMap A B y) := by\n  rw [nonsingular_iff_baseChange (W.baseChange A) B, baseChange_baseChange]", "start": [799, 1], "end": [802, 76], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_zero_of_\u0394_ne_zero", "code": "lemma nonsingular_zero_of_\u0394_ne_zero (h : W.equation 0 0) (h\u0394 : W.\u0394 \u2260 0) : W.nonsingular 0 0 := by\n  simp only [equation_zero, nonsingular_zero] at *\n  contrapose! h\u0394\n  simp only [b\u2082, b\u2084, b\u2086, b\u2088, \u0394, h, h\u0394]\n  ring1", "start": [805, 1], "end": [809, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.nonsingular_of_\u0394_ne_zero", "code": "lemma nonsingular_of_\u0394_ne_zero {x y : R} (h : W.equation x y) (h\u0394 : W.\u0394 \u2260 0) : W.nonsingular x y :=\n  (W.nonsingular_iff_variableChange x y).mpr <|\n    nonsingular_zero_of_\u0394_ne_zero _ ((W.equation_iff_variableChange x y).mp h) <| by\n      rwa [variableChange_\u0394, inv_one, Units.val_one, one_pow, one_mul]", "start": [812, 1], "end": [816, 71], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing", "code": "abbrev CoordinateRing : Type u :=\n  AdjoinRoot W.polynomial", "start": [828, 1], "end": [830, 26], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.FunctionField", "code": "abbrev FunctionField : Type u :=\n  FractionRing W.CoordinateRing", "start": [833, 1], "end": [835, 32], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.mk", "code": "noncomputable abbrev mk : R[X][Y] \u2192+* W.CoordinateRing :=\n  AdjoinRoot.mk W.polynomial", "start": [841, 1], "end": [843, 29], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instIsDomainCoordinateRing", "code": "instance instIsDomainCoordinateRing [IsDomain R] [NormalizedGCDMonoid R] :\n    IsDomain W.CoordinateRing :=\n  (Quotient.isDomain_iff_prime _).mpr <| by\n    simpa only [span_singleton_prime W.polynomial_ne_zero, \u2190 GCDMonoid.irreducible_iff_prime] using\n      W.irreducible_polynomial", "start": [847, 1], "end": [851, 31], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instIsDomainCoordinateRing_of_Field", "code": "instance instIsDomainCoordinateRing_of_Field {F : Type u} [Field F] (W : WeierstrassCurve F) :\n    IsDomain W.CoordinateRing := by\n  classical exact instIsDomainCoordinateRing W", "start": [854, 1], "end": [856, 47], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.XClass", "code": "noncomputable def XClass : W.CoordinateRing :=\n  mk W <| C <| X - C x", "start": [862, 1], "end": [864, 23], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.XClass_ne_zero", "code": "lemma XClass_ne_zero [Nontrivial R] : XClass W x \u2260 0 :=\n  AdjoinRoot.mk_ne_zero_of_natDegree_lt W.monic_polynomial (C_ne_zero.mpr <| X_sub_C_ne_zero x) <|\n    by rw [natDegree_polynomial, natDegree_C]; norm_num1", "start": [868, 1], "end": [870, 57], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.YClass", "code": "noncomputable def YClass : W.CoordinateRing :=\n  mk W <| Y - C y", "start": [875, 1], "end": [877, 18], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.YClass_ne_zero", "code": "lemma YClass_ne_zero [Nontrivial R] : YClass W y \u2260 0 :=\n  AdjoinRoot.mk_ne_zero_of_natDegree_lt W.monic_polynomial (X_sub_C_ne_zero y) <|\n    by rw [natDegree_polynomial, natDegree_X_sub_C]; norm_num1", "start": [881, 1], "end": [883, 63], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.XIdeal", "code": "noncomputable def XIdeal : Ideal W.CoordinateRing :=\n  span {XClass W x}", "start": [888, 1], "end": [890, 20], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.YIdeal", "code": "noncomputable def YIdeal : Ideal W.CoordinateRing :=\n  span {YClass W y}", "start": [895, 1], "end": [897, 20], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.XYIdeal", "code": "noncomputable def XYIdeal (x : R) (y : R[X]) : Ideal W.CoordinateRing :=\n  span {XClass W x, YClass W y}", "start": [902, 1], "end": [904, 32], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instAlgebraCoordinateRing", "code": "noncomputable instance instAlgebraCoordinateRing : Algebra R[X] W.CoordinateRing :=\n  Quotient.algebra R[X]", "start": [910, 1], "end": [911, 24], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instAlgebraCoordinateRing'", "code": "noncomputable instance instAlgebraCoordinateRing' : Algebra R W.CoordinateRing :=\n  Quotient.algebra R", "start": [914, 1], "end": [915, 21], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instIsScalarTowerCoordinateRing", "code": "instance instIsScalarTowerCoordinateRing : IsScalarTower R R[X] W.CoordinateRing :=\n  Quotient.isScalarTower R R[X] _", "start": [918, 1], "end": [919, 34], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.instSubsingletonCoordinateRing", "code": "instance instSubsingletonCoordinateRing [Subsingleton R] : Subsingleton W.CoordinateRing :=\n  Module.subsingleton R[X] _", "start": [922, 1], "end": [923, 29], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.quotientXYIdealEquiv'", "code": "noncomputable def quotientXYIdealEquiv' {x : R} {y : R[X]} (h : (W.polynomial.eval y).eval x = 0) :\n    (W.CoordinateRing \u29f8 XYIdeal W x y) \u2243\u2090[R]\n      R[X][Y] \u29f8 (span {C (X - C x), Y - C y} : Ideal <| R[X][Y]) :=\n  (quotientEquivAlgOfEq R <| by\n    simp only [XYIdeal, XClass, YClass, \u2190 Set.image_pair, \u2190 map_span]; rfl).trans <|\n    DoubleQuot.quotQuotEquivQuotOfLE\u2090 R <| (span_singleton_le_iff_mem _).mpr <|\n      mem_span_C_X_sub_C_X_sub_C_iff_eval_eval_eq_zero.mpr h", "start": [926, 1], "end": [934, 61], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.quotientXYIdealEquiv", "code": "noncomputable def quotientXYIdealEquiv {x : R} {y : R[X]} (h : (W.polynomial.eval y).eval x = 0) :\n    (W.CoordinateRing \u29f8 XYIdeal W x y) \u2243\u2090[R] R :=\n  (quotientXYIdealEquiv' W h).trans quotientSpanCXSubCXSubCAlgEquiv", "start": [937, 1], "end": [941, 68], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.basis", "code": "protected noncomputable def basis : Basis (Fin 2) R[X] W.CoordinateRing := by\n  classical exact (subsingleton_or_nontrivial R).by_cases (fun _ => default) fun _ =>\n    (AdjoinRoot.powerBasis' W.monic_polynomial).basis.reindex <| finCongr W.natDegree_polynomial", "start": [946, 1], "end": [949, 97], "kind": "commanddeclaration"}, {"full_name": "WeierstrassCurve.CoordinateRing.basis_apply", "code": "lemma basis_apply (n : Fin 2) :\n    CoordinateRing.basis W n = (AdjoinRoot.powerBasis' W.monic_polynomial).gen ^ (n : \u2115) := by\n  classical\n  nontriviality R\n  rw [CoordinateRing.basis, Or.by_cases, dif_neg <| not_subsingleton R, Basis.reindex_apply,\n    PowerBasis.basis_eq_pow]\n  rfl", "start": [952, 1], "end": [958, 6], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.basis_zero", "code": "@[simp]\nlemma basis_zero : CoordinateRing.basis W 0 = 1 := by\n  simpa only [basis_apply] using pow_zero _", "start": [962, 1], "end": [964, 44], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.basis_one", "code": "@[simp]\nlemma basis_one : CoordinateRing.basis W 1 = mk W Y := by\n  simpa only [basis_apply] using pow_one _", "start": [968, 1], "end": [970, 43], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.coe_basis", "code": "lemma coe_basis : (CoordinateRing.basis W : Fin 2 \u2192 W.CoordinateRing) = ![1, mk W Y] := by\n  ext n\n  fin_cases n\n  exacts [basis_zero W, basis_one W]", "start": [974, 1], "end": [977, 37], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.smul", "code": "lemma smul (x : R[X]) (y : W.CoordinateRing) : x \u2022 y = mk W (C x) * y :=\n  (algebraMap_smul W.CoordinateRing x y).symm", "start": [982, 1], "end": [983, 46], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.smul_basis_eq_zero", "code": "lemma smul_basis_eq_zero {p q : R[X]} (hpq : p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y = 0) :\n    p = 0 \u2227 q = 0 := by\n  have h := Fintype.linearIndependent_iff.mp (CoordinateRing.basis W).linearIndependent ![p, q]\n  erw [Fin.sum_univ_succ, basis_zero, Fin.sum_univ_one, basis_one] at h\n  exact \u27e8h hpq 0, h hpq 1\u27e9", "start": [986, 1], "end": [990, 27], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.exists_smul_basis_eq", "code": "lemma exists_smul_basis_eq (x : W.CoordinateRing) :\n    \u2203 p q : R[X], p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y = x := by\n  have h := (CoordinateRing.basis W).sum_equivFun x\n  erw [Fin.sum_univ_succ, Fin.sum_univ_one, basis_zero, basis_one] at h\n  exact \u27e8_, _, h\u27e9", "start": [993, 1], "end": [997, 18], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.smul_basis_mul_C", "code": "lemma smul_basis_mul_C (p q : R[X]) :\n    (p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y) * mk W (C y) =\n      (p * y) \u2022 (1 : W.CoordinateRing) + (q * y) \u2022 mk W Y := by\n  simp only [smul, _root_.map_mul]\n  ring1", "start": [1002, 1], "end": [1006, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.smul_basis_mul_Y", "code": "lemma smul_basis_mul_Y (p q : R[X]) :\n    (p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y) * mk W Y =\n      (q * (X ^ 3 + C W.a\u2082 * X ^ 2 + C W.a\u2084 * X + C W.a\u2086)) \u2022 (1 : W.CoordinateRing) +\n        (p - q * (C W.a\u2081 * X + C W.a\u2083)) \u2022 mk W Y := by\n  have Y_sq :\n    mk W Y ^ 2 =\n      mk W (C (X ^ 3 + C W.a\u2082 * X ^ 2 + C W.a\u2084 * X + C W.a\u2086) - C (C W.a\u2081 * X + C W.a\u2083) * Y) := by\n    exact AdjoinRoot.mk_eq_mk.mpr \u27e81, by rw [WeierstrassCurve.polynomial]; ring1\u27e9\n  simp_rw [smul, add_mul, mul_assoc, \u2190 sq, Y_sq, C_sub, map_sub, C_mul, _root_.map_mul]\n  ring1", "start": [1010, 1], "end": [1019, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.norm_smul_basis", "code": "lemma norm_smul_basis (p q : R[X]) :\n    Algebra.norm R[X] (p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y) =\n      p ^ 2 - p * q * (C W.a\u2081 * X + C W.a\u2083) -\n        q ^ 2 * (X ^ 3 + C W.a\u2082 * X ^ 2 + C W.a\u2084 * X + C W.a\u2086) := by\n  simp_rw [Algebra.norm_eq_matrix_det <| CoordinateRing.basis W, Matrix.det_fin_two,\n    Algebra.leftMulMatrix_eq_repr_mul, basis_zero, mul_one, basis_one, smul_basis_mul_Y, map_add,\n    Finsupp.add_apply, map_smul, Finsupp.smul_apply, \u2190 basis_zero, \u2190 basis_one,\n    Basis.repr_self_apply, if_pos, if_neg, smul_eq_mul]\n  ring1", "start": [1025, 1], "end": [1033, 8], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.coe_norm_smul_basis", "code": "lemma coe_norm_smul_basis (p q : R[X]) :\n    \u2191(Algebra.norm R[X] <| p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y) =\n      mk W ((C p + C q * X) * (C p + C q * (-Y - C (C W.a\u2081 * X + C W.a\u2083)))) :=\n  AdjoinRoot.mk_eq_mk.mpr\n    \u27e8C q ^ 2, by simp only [norm_smul_basis, WeierstrassCurve.polynomial]; C_simp; ring1\u27e9", "start": [1036, 1], "end": [1040, 90], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.degree_norm_smul_basis", "code": "lemma degree_norm_smul_basis [IsDomain R] (p q : R[X]) :\n    (Algebra.norm R[X] <| p \u2022 (1 : W.CoordinateRing) + q \u2022 mk W Y).degree =\n      max (2 \u2022 p.degree) (2 \u2022 q.degree + 3) := by\n  have hdp : (p ^ 2).degree = 2 \u2022 p.degree := degree_pow p 2\n  have hdpq : (p * q * (C W.a\u2081 * X + C W.a\u2083)).degree \u2264 p.degree + q.degree + 1 := by\n    simpa only [degree_mul] using add_le_add_left degree_linear_le (p.degree + q.degree)\n  have hdq :\n      (q ^ 2 * (X ^ 3 + C W.a\u2082 * X ^ 2 + C W.a\u2084 * X + C W.a\u2086)).degree = 2 \u2022 q.degree + 3 := by\n    rw [degree_mul, degree_pow, \u2190 one_mul <| X ^ 3, \u2190 C_1, degree_cubic <| one_ne_zero' R]\n  rw [norm_smul_basis]\n  by_cases hp : p = 0\n  \u00b7 simpa only [hp, hdq, neg_zero, zero_sub, zero_mul, zero_pow zero_lt_two, degree_neg] using\n      (max_bot_left _).symm\n  \u00b7 by_cases hq : q = 0\n    \u00b7 simpa only [hq, hdp, sub_zero, zero_mul, mul_zero, zero_pow zero_lt_two] using\n        (max_bot_right _).symm\n    \u00b7 rw [\u2190 not_congr degree_eq_bot] at hp hq\n      rcases hp' : p.degree with _ | dp \u00b7 exact (hp hp').elim \u00b7 rw [hp'] at hdp hdpq rcases hq' : q.degree with _ | dq \u00b7 exact (hq hq').elim \u00b7 rw [hq'] at hdpq hdq rcases le_or_lt dp (dq + 1) with hpq | hpq\n          \u00b7 convert (degree_sub_eq_right_of_degree_lt <| (degree_sub_le _ _).trans_lt <|\n                      max_lt_iff.mpr \u27e8hdp.trans_lt _, hdpq.trans_lt _\u27e9).trans\n              (max_eq_right_of_lt _).symm <;> rw [hdq] <;>\n              exact WithBot.coe_lt_coe.mpr <| by linarith only [hpq]\n          \u00b7 rw [sub_sub]\n            convert (degree_sub_eq_left_of_degree_lt <| (degree_add_le _ _).trans_lt <|\n                      max_lt_iff.mpr \u27e8hdpq.trans_lt _, hdq.trans_lt _\u27e9).trans\n              (max_eq_left_of_lt _).symm <;> rw [hdp] <;>\n              exact WithBot.coe_lt_coe.mpr <| by linarith only [hpq]", "start": [1043, 1], "end": [1076, 69], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.degree_norm_ne_one", "code": "lemma degree_norm_ne_one [IsDomain R] (x : W.CoordinateRing) :\n    (Algebra.norm R[X] x).degree \u2260 1 := by\n  rcases exists_smul_basis_eq x with \u27e8p, q, rfl\u27e9\n  rw [degree_norm_smul_basis]\n  rcases p.degree with (_ | _ | _ | _) <;> cases q.degree\n  any_goals rintro (_ | _)\n  apply (lt_max_of_lt_right _).ne'\n  exact (cmp_eq_lt_iff _ _).mp rfl", "start": [1081, 1], "end": [1089, 35], "kind": "mathlibtacticlemma"}, {"full_name": "WeierstrassCurve.CoordinateRing.natDegree_norm_ne_one", "code": "lemma natDegree_norm_ne_one [IsDomain R] (x : W.CoordinateRing) :\n    (Algebra.norm R[X] x).natDegree \u2260 1 :=\n  mt (degree_eq_iff_natDegree_eq_of_pos zero_lt_one).mpr <| degree_norm_ne_one x", "start": [1092, 1], "end": [1094, 81], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve", "code": "@[ext]\nstructure EllipticCurve (R : Type u) [CommRing R] extends WeierstrassCurve R where\n  \u0394' : R\u02e3\n  coe_\u0394' : \u2191\u0394' = toWeierstrassCurve.\u0394", "start": [1105, 1], "end": [1110, 38], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.j", "code": "def j : R :=\n  \u2191E.\u0394'\u207b\u00b9 * E.c\u2084 ^ 3", "start": [1124, 1], "end": [1126, 21], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.twoTorsionPolynomial_disc_ne_zero", "code": "lemma twoTorsionPolynomial_disc_ne_zero [Nontrivial R] [Invertible (2 : R)] :\n    E.twoTorsionPolynomial.disc \u2260 0 :=\n  E.toWeierstrassCurve.twoTorsionPolynomial_disc_ne_zero <| E.coe_\u0394' \u25b8 E.\u0394'.isUnit", "start": [1129, 1], "end": [1131, 83], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.nonsingular", "code": "lemma nonsingular [Nontrivial R] {x y : R} (h : E.equation x y) : E.nonsingular x y :=\n  E.nonsingular_of_\u0394_ne_zero h <| E.coe_\u0394' \u25b8 E.\u0394'.ne_zero", "start": [1134, 1], "end": [1135, 58], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ0", "code": "def ofJ0 [Invertible (3 : R)] : EllipticCurve R :=\n  have := invertibleNeg (3 ^ 3 : R)\n  \u27e8WeierstrassCurve.ofJ0 R, unitOfInvertible (-3 ^ 3 : R),\n    by rw [val_unitOfInvertible, WeierstrassCurve.ofJ0_\u0394 R]; norm_num1\u27e9", "start": [1142, 1], "end": [1147, 72], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.ofJ0_j", "code": "lemma ofJ0_j [Invertible (3 : R)] : (ofJ0 R).j = 0 := by\n  simp only [j, ofJ0, WeierstrassCurve.ofJ0_c\u2084]\n  ring1", "start": [1149, 1], "end": [1151, 8], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ1728", "code": "def ofJ1728 [Invertible (2 : R)] : EllipticCurve R :=\n  have := invertibleNeg (2 ^ 6 : R)\n  \u27e8WeierstrassCurve.ofJ1728 R, unitOfInvertible (-2 ^ 6 : R),\n    by rw [val_unitOfInvertible, WeierstrassCurve.ofJ1728_\u0394 R]; norm_num1\u27e9", "start": [1153, 1], "end": [1158, 75], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.ofJ1728_j", "code": "lemma ofJ1728_j [Invertible (2 : R)] : (ofJ1728 R).j = 1728 := by\n  field_simp [j, ofJ1728, @val_unitOfInvertible _ _ _ <| invertibleNeg _,\n    WeierstrassCurve.ofJ1728_c\u2084]\n  norm_num1", "start": [1160, 1], "end": [1163, 12], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ'", "code": "def ofJ' (j : R) [Invertible j] [Invertible (j - 1728)] : EllipticCurve R :=\n  have := invertibleMul (j ^ 2) ((j - 1728) ^ 9)\n  \u27e8WeierstrassCurve.ofJ j, unitOfInvertible <| j ^ 2 * (j - 1728) ^ 9,\n    (WeierstrassCurve.ofJ_\u0394 j).symm\u27e9", "start": [1167, 1], "end": [1173, 37], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.ofJ'_j", "code": "lemma ofJ'_j (j : R) [Invertible j] [Invertible (j - 1728)] : (ofJ' j).j = j := by\n  field_simp [EllipticCurve.j, ofJ', @val_unitOfInvertible _ _ _ <| invertibleMul _ _,\n    WeierstrassCurve.ofJ_c\u2084]\n  ring1", "start": [1175, 1], "end": [1178, 8], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.two_or_three_ne_zero", "code": "private lemma two_or_three_ne_zero : (2 : F) \u2260 0 \u2228 (3 : F) \u2260 0 :=\n  ne_zero_or_ne_zero_of_nat_coprime (show Nat.Coprime 2 3 by norm_num1)", "start": [1182, 1], "end": [1183, 72], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ", "code": "def ofJ : EllipticCurve F :=\n  if h0 : j = 0 then\n    if h3 : (3 : F) = 0 then @ofJ1728 _ _ <| invertibleOfNonzero <|\n      two_or_three_ne_zero.neg_resolve_right h3\n    else @ofJ0 _ _ <| invertibleOfNonzero h3\n  else if h1728 : j = 1728 then\n    @ofJ1728 _ _ <| invertibleOfNonzero fun h => h0 <|\n    by rw [h1728, show (1728 : F) = 2 * 864 by norm_num1, h, zero_mul]\n  else @ofJ' _ _ j (invertibleOfNonzero h0) (invertibleOfNonzero <| sub_ne_zero_of_ne h1728)", "start": [1187, 1], "end": [1199, 93], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.ofJ_0_of_three_ne_zero", "code": "lemma ofJ_0_of_three_ne_zero [h3 : NeZero (3 : F)] :\n    ofJ 0 = @ofJ0 _ _ (invertibleOfNonzero h3.out) := by\n  rw [ofJ, dif_pos rfl, dif_neg h3.out]", "start": [1201, 1], "end": [1203, 40], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_0_of_three_eq_zero", "code": "lemma ofJ_0_of_three_eq_zero (h3 : (3 : F) = 0) :\n    ofJ 0 = @ofJ1728 _ _ (invertibleOfNonzero <| two_or_three_ne_zero.neg_resolve_right h3) := by\n  rw [ofJ, dif_pos rfl, dif_pos h3]", "start": [1205, 1], "end": [1207, 36], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_0_of_two_eq_zero", "code": "lemma ofJ_0_of_two_eq_zero (h2 : (2 : F) = 0) :\n    ofJ 0 = @ofJ0 _ _ (invertibleOfNonzero <| two_or_three_ne_zero.neg_resolve_left h2) :=\n  have := neZero_iff.2 <| two_or_three_ne_zero.neg_resolve_left h2\n  ofJ_0_of_three_ne_zero", "start": [1209, 1], "end": [1212, 25], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_1728_of_three_eq_zero", "code": "lemma ofJ_1728_of_three_eq_zero (h3 : (3 : F) = 0) :\n    ofJ 1728 = @ofJ1728 _ _ (invertibleOfNonzero <| two_or_three_ne_zero.neg_resolve_right h3) := by\n  rw [ofJ, dif_pos <| by rw [show (1728 : F) = 3 * 576 by norm_num1, h3, zero_mul], dif_pos h3]", "start": [1214, 1], "end": [1216, 96], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_1728_of_two_ne_zero", "code": "lemma ofJ_1728_of_two_ne_zero [h2 : NeZero (2 : F)] :\n    ofJ 1728 = @ofJ1728 _ _ (invertibleOfNonzero h2.out) := by\n  by_cases h3 : (3 : F) = 0\n  \u00b7 exact ofJ_1728_of_three_eq_zero h3\n  \u00b7 have h : (1728 : F) \u2260 0 := fun h => or_iff_not_and_not.mp\n      (mul_eq_zero.mp <| by rwa [show 2 ^ 6 * 3 ^ 3 = (1728 : F) by norm_num1])\n      \u27e8pow_ne_zero 6 h2.out, pow_ne_zero 3 h3\u27e9\n    rw [ofJ, dif_neg h, dif_pos rfl]", "start": [1218, 1], "end": [1225, 37], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_1728_of_two_eq_zero", "code": "lemma ofJ_1728_of_two_eq_zero (h2 : (2 : F) = 0) :\n    ofJ 1728 = @ofJ0 _ _ (invertibleOfNonzero <| two_or_three_ne_zero.neg_resolve_left h2) := by\n  rw [ofJ, dif_pos <| by rw [show (1728 : F) = 2 * 864 by norm_num1, h2, zero_mul], dif_neg]", "start": [1227, 1], "end": [1229, 93], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_ne_0_ne_1728", "code": "lemma ofJ_ne_0_ne_1728 (h0 : j \u2260 0) (h1728 : j \u2260 1728) :\n    ofJ j =\n      @ofJ' _ _ j (invertibleOfNonzero h0) (invertibleOfNonzero <| sub_ne_zero_of_ne h1728) := by\n  rw [ofJ, dif_neg h0, dif_neg h1728]", "start": [1231, 1], "end": [1234, 38], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.ofJ_j", "code": "lemma ofJ_j : (ofJ j).j = j := by\n  by_cases h0 : j = 0\n  \u00b7 by_cases h3 : (3 : F) = 0\n    \u00b7 rw [h0, ofJ_0_of_three_eq_zero h3,\n        @ofJ1728_j _ _ <| invertibleOfNonzero <| two_or_three_ne_zero.neg_resolve_right h3,\n        show (1728 : F) = 3 * 576 by norm_num1, h3, zero_mul]\n    \u00b7 rw [h0, ofJ_0_of_three_ne_zero (h3 := neZero_iff.2 h3), @ofJ0_j _ _ <| invertibleOfNonzero h3]\n  \u00b7 by_cases h1728 : j = 1728\n    \u00b7 have h2 : (2 : F) \u2260 0 :=\n        fun h => h0 <| by rw [h1728, show (1728 : F) = 2 * 864 by norm_num1, h, zero_mul]\n      rw [h1728, ofJ_1728_of_two_ne_zero (h2 := neZero_iff.2 h2),\n        @ofJ1728_j _ _ <| invertibleOfNonzero h2]\n    \u00b7 rw [ofJ_ne_0_ne_1728 j h0 h1728,\n        @ofJ'_j _ _ _ (invertibleOfNonzero h0) (invertibleOfNonzero <| sub_ne_zero_of_ne h1728)]", "start": [1236, 1], "end": [1249, 97], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.instInhabitedEllipticCurve", "code": "instance instInhabitedEllipticCurve : Inhabited <| EllipticCurve F :=\n  \u27e8ofJ 37\u27e9", "start": [1251, 1], "end": [1252, 11], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.variableChange", "code": "@[simps (config := { rhsMd := .default }) a\u2081 a\u2082 a\u2083 a\u2084 a\u2086 \u0394' toWeierstrassCurve]\ndef variableChange : EllipticCurve R :=\n  \u27e8E.toWeierstrassCurve.variableChange C, C.u\u207b\u00b9 ^ 12 * E.\u0394', by\n    rw [Units.val_mul, Units.val_pow_eq_pow_val, coe_\u0394', E.variableChange_\u0394]\u27e9", "start": [1264, 1], "end": [1270, 78], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.variableChange_id", "code": "lemma variableChange_id : E.variableChange WeierstrassCurve.VariableChange.id = E := by\n  simp only [variableChange, WeierstrassCurve.variableChange_id]\n  simp only [WeierstrassCurve.VariableChange.id, inv_one, one_pow, one_mul]", "start": [1273, 1], "end": [1275, 76], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.variableChange_comp", "code": "lemma variableChange_comp (C C' : WeierstrassCurve.VariableChange R) (E : EllipticCurve R) :\n    E.variableChange (C.comp C') = (E.variableChange C').variableChange C := by\n  simp only [variableChange, WeierstrassCurve.variableChange_comp]\n  simp only [WeierstrassCurve.VariableChange.comp, mul_inv, mul_pow, \u2190 mul_assoc]", "start": [1277, 1], "end": [1280, 82], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.instMulActionVariableChange", "code": "instance instMulActionVariableChange :\n    MulAction (WeierstrassCurve.VariableChange R) (EllipticCurve R) where\n  smul := fun C E => E.variableChange C\n  one_smul := variableChange_id\n  mul_smul := variableChange_comp", "start": [1282, 1], "end": [1286, 34], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.coe_variableChange_\u0394'", "code": "lemma coe_variableChange_\u0394' : (\u2191(E.variableChange C).\u0394' : R) = (\u2191C.u\u207b\u00b9 : R) ^ 12 * E.\u0394' := by\n  rw [variableChange_\u0394', Units.val_mul, Units.val_pow_eq_pow_val]", "start": [1288, 1], "end": [1289, 66], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.coe_inv_variableChange_\u0394'", "code": "lemma coe_inv_variableChange_\u0394' :\n    (\u2191(E.variableChange C).\u0394'\u207b\u00b9 : R) = (C.u : R) ^ 12 * \u2191E.\u0394'\u207b\u00b9 := by\n  rw [variableChange_\u0394', mul_inv, inv_pow, inv_inv, Units.val_mul, Units.val_pow_eq_pow_val]", "start": [1292, 1], "end": [1294, 93], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.variableChange_j", "code": "@[simp]\nlemma variableChange_j : (E.variableChange C).j = E.j := by\n  rw [j, coe_inv_variableChange_\u0394']\n  have hu : (C.u * \u2191C.u\u207b\u00b9 : R) ^ 12 = 1 := by rw [C.u.mul_inv, one_pow]\n  linear_combination (norm := (rw [variableChange_toWeierstrassCurve,\n    WeierstrassCurve.variableChange_c\u2084, j]; ring1)) E.j * hu", "start": [1297, 1], "end": [1302, 61], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.baseChange", "code": "@[simps (config := { rhsMd := .default }) a\u2081 a\u2082 a\u2083 a\u2084 a\u2086 \u0394' toWeierstrassCurve]\ndef baseChange : EllipticCurve A :=\n  \u27e8E.toWeierstrassCurve.baseChange A, Units.map (\u2191(algebraMap R A)) E.\u0394',\n    by simp only [Units.coe_map, coe_\u0394', E.baseChange_\u0394]; rfl\u27e9", "start": [1314, 1], "end": [1318, 63], "kind": "commanddeclaration"}, {"full_name": "EllipticCurve.coeBaseChange_\u0394'", "code": "lemma coeBaseChange_\u0394' : \u2191(E.baseChange A).\u0394' = algebraMap R A E.\u0394' :=\n  rfl", "start": [1321, 1], "end": [1322, 6], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.coe_inv_baseChange_\u0394'", "code": "lemma coe_inv_baseChange_\u0394' : \u2191(E.baseChange A).\u0394'\u207b\u00b9 = algebraMap R A \u2191E.\u0394'\u207b\u00b9 :=\n  rfl", "start": [1325, 1], "end": [1326, 6], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.baseChange_j", "code": "@[simp]\nlemma baseChange_j : (E.baseChange A).j = algebraMap R A E.j := by\n  simp only [j, baseChange, E.baseChange_c\u2084]\n  map_simp\n  rfl", "start": [1329, 1], "end": [1333, 6], "kind": "mathlibtacticlemma"}, {"full_name": "EllipticCurve.baseChange_injective", "code": "lemma baseChange_injective (h : Function.Injective <| algebraMap R A) :\n    Function.Injective <| baseChange (R := R) (A := A) := fun E E' h1 => by\n  rcases mk.inj h1 with \u27e8h1, h2\u27e9\n  replace h2 := (Units.mk.inj h2).left\n  rcases WeierstrassCurve.mk.inj h1 with \u27e8_, _, _, _, _\u27e9\n  ext <;> apply_fun _ using h <;> assumption", "start": [1336, 1], "end": [1341, 45], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/ModelTheory/DirectLimit.lean", "imports": ["Mathlib/Data/Fintype/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/ModelTheory/Quotients.lean", "Mathlib/ModelTheory/FinitelyGenerated.lean", "Mathlib/Algebra/DirectLimit.lean"], "premises": [{"full_name": "FirstOrder.Language.DirectedSystem.map_self", "code": "nonrec theorem map_self [DirectedSystem G fun i j h => f i j h] (i x h) : f i i h x = x", "start": [41, 1], "end": [44, 55], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectedSystem.map_map", "code": "nonrec theorem map_map [DirectedSystem G fun i j h => f i j h] {i j k} (hij hjk x) :\n    f j k hjk (f i j hij x) = f i k (le_trans hij hjk) x", "start": [47, 1], "end": [51, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectedSystem.natLERec", "code": "def natLERec (m n : \u2115) (h : m \u2264 n) : G' m \u21aa[L] G' n :=\n  Nat.leRecOn h (@fun k g => (f' k).comp g) (Embedding.refl L _)", "start": [56, 1], "end": [59, 65], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectedSystem.coe_natLERec", "code": "@[simp]\ntheorem coe_natLERec (m n : \u2115) (h : m \u2264 n) :\n    (natLERec f' m n h : G' m \u2192 G' n) = Nat.leRecOn h (@fun k => f' k)", "start": [62, 1], "end": [72, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectedSystem.natLERec.directedSystem", "code": "instance natLERec.directedSystem : DirectedSystem G' fun i j h => natLERec f' i j h :=\n  \u27e8fun i x h => congr (congr rfl (Nat.leRecOn_self _)) rfl,\n   fun hij hjk => by simp [Nat.leRecOn_trans hij hjk]\u27e9", "start": [75, 1], "end": [77, 55], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.Sigma", "code": "@[nolint unusedArguments]\nprotected abbrev Structure.Sigma (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j) := \u03a3 i, G i", "start": [88, 1], "end": [90, 79], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.Sigma.mk", "code": "abbrev Structure.Sigma.mk (i : \u03b9) (x : G i) : \u03a3\u02e3 f := \u27e8i, x\u27e9", "start": [95, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.unify", "code": "def unify {\u03b1 : Type*} (x : \u03b1 \u2192 \u03a3\u02e3 f) (i : \u03b9) (h : i \u2208 upperBounds (range (Sigma.fst \u2218 x)))\n    (a : \u03b1) : G i :=\n  f (x a).1 i (h (mem_range_self a)) (x a).2", "start": [100, 1], "end": [103, 45], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.unify_sigma_mk_self", "code": "@[simp]\ntheorem unify_sigma_mk_self {\u03b1 : Type*} {i : \u03b9} {x : \u03b1 \u2192 G i} :\n    (unify f (fun a => .mk f i (x a)) i fun j \u27e8a, hj\u27e9 =>\n      _root_.trans (le_of_eq hj.symm) (refl _)) = x", "start": [108, 1], "end": [114, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.comp_unify", "code": "theorem comp_unify {\u03b1 : Type*} {x : \u03b1 \u2192 \u03a3\u02e3 f} {i j : \u03b9} (ij : i \u2264 j)\n    (h : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    f i j ij \u2218 unify f x i h = unify f x j\n      fun k hk => _root_.trans (mem_upperBounds.1 h k hk) ij", "start": [117, 1], "end": [122, 39], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.setoid", "code": "def setoid [DirectedSystem G fun i j h => f i j h] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] : Setoid (\u03a3\u02e3 f) where\n  r := fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 => \u2203 (k : \u03b9) (ik : i \u2264 k) (jk : j \u2264 k), f i k ik x = f j k jk y\n  iseqv :=\n    \u27e8fun \u27e8i, x\u27e9 => \u27e8i, refl i, refl i, rfl\u27e9, @fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 \u27e8k, ik, jk, h\u27e9 =>\n      \u27e8k, jk, ik, h.symm\u27e9,\n      @fun \u27e8i, x\u27e9 \u27e8j, y\u27e9 \u27e8k, z\u27e9 \u27e8ij, hiij, hjij, hij\u27e9 \u27e8jk, hjjk, hkjk, hjk\u27e9 => by\n        obtain \u27e8ijk, hijijk, hjkijk\u27e9 := directed_of (\u00b7 \u2264 \u00b7) ij jk\n        refine' \u27e8ijk, le_trans hiij hijijk, le_trans hkjk hjkijk, _\u27e9\n        rw [\u2190 DirectedSystem.map_map, hij, DirectedSystem.map_map]\n        symm\n        rw [\u2190 DirectedSystem.map_map, \u2190 hjk, DirectedSystem.map_map] <;> assumption\u27e9", "start": [131, 1], "end": [142, 85], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.sigmaStructure", "code": "noncomputable def sigmaStructure [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9] : L.Structure (\u03a3\u02e3 f) where\n  funMap F x :=\n    \u27e8_,\n      funMap F\n        (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n          (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))\u27e9\n  RelMap R x :=\n    RelMap R\n      (unify f x (Classical.choose (Fintype.bddAbove_range fun a => (x a).1))\n        (Classical.choose_spec (Fintype.bddAbove_range fun a => (x a).1)))", "start": [145, 1], "end": [156, 75], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit", "code": "def DirectLimit [DirectedSystem G fun i j h => f i j h] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] :=\n  Quotient (DirectLimit.setoid G f)", "start": [161, 1], "end": [163, 36], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.equiv_iff", "code": "theorem equiv_iff {x y : \u03a3\u02e3 f} {i : \u03b9} (hx : x.1 \u2264 i) (hy : y.1 \u2264 i) :\n    x \u2248 y \u2194 (f x.1 i hx) x.2 = (f y.1 i hy) y.2", "start": [180, 1], "end": [190, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.funMap_unify_equiv", "code": "theorem funMap_unify_equiv {n : \u2115} (F : L.Functions n) (x : Fin n \u2192 \u03a3\u02e3 f) (i j : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) (hj : j \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    Structure.Sigma.mk f i (funMap F (unify f x i hi)) \u2248 .mk f j (funMap F (unify f x j hj))", "start": [193, 1], "end": [198, 70], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.relMap_unify_equiv", "code": "theorem relMap_unify_equiv {n : \u2115} (R : L.Relations n) (x : Fin n \u2192 \u03a3\u02e3 f) (i j : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) (hj : j \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    RelMap R (unify f x i hi) = RelMap R (unify f x j hj)", "start": [201, 1], "end": [205, 74], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.exists_unify_eq", "code": "theorem exists_unify_eq {\u03b1 : Type*} [Fintype \u03b1] {x y : \u03b1 \u2192 \u03a3\u02e3 f} (xy : x \u2248 y) :\n    \u2203 (i : \u03b9)(hx : i \u2208 upperBounds (range (Sigma.fst \u2218 x)))(hy :\n      i \u2208 upperBounds (range (Sigma.fst \u2218 y))), unify f x i hx = unify f y i hy", "start": [210, 1], "end": [216, 70], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.funMap_equiv_unify", "code": "theorem funMap_equiv_unify {n : \u2115} (F : L.Functions n) (x : Fin n \u2192 \u03a3\u02e3 f) (i : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    funMap F x \u2248 .mk f _ (funMap F (unify f x i hi))", "start": [219, 1], "end": [222, 97], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.relMap_equiv_unify", "code": "theorem relMap_equiv_unify {n : \u2115} (R : L.Relations n) (x : Fin n \u2192 \u03a3\u02e3 f) (i : \u03b9)\n    (hi : i \u2208 upperBounds (range (Sigma.fst \u2218 x))) :\n    RelMap R x = RelMap R (unify f x i hi)", "start": [225, 1], "end": [228, 97], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.prestructure", "code": "noncomputable instance prestructure : L.Prestructure (DirectLimit.setoid G f) where\n  toStructure := sigmaStructure G f\n  fun_equiv {n} {F} x y xy := by\n    obtain \u27e8i, hx, hy, h\u27e9 := exists_unify_eq G f xy\n    refine'\n      Setoid.trans (funMap_equiv_unify G f F x i hx)\n        (Setoid.trans _ (Setoid.symm (funMap_equiv_unify G f F y i hy)))\n    rw [h]\n  rel_equiv {n} {R} x y xy := by\n    obtain \u27e8i, hx, hy, h\u27e9 := exists_unify_eq G f xy\n    refine' _root_.trans (relMap_equiv_unify G f R x i hx)\n      (_root_.trans _ (symm (relMap_equiv_unify G f R y i hy)))\n    rw [h]", "start": [231, 1], "end": [245, 11], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.instStructureDirectLimit", "code": "noncomputable instance instStructureDirectLimit : L.Structure (DirectLimit G f) :=\n  Language.quotientStructure", "start": [248, 1], "end": [250, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.funMap_quotient_mk'_sigma_mk'", "code": "@[simp]\ntheorem funMap_quotient_mk'_sigma_mk' {n : \u2115} {F : L.Functions n} {i : \u03b9} {x : Fin n \u2192 G i} :\n    funMap F (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) = \u27e6.mk f i (funMap F x)\u27e7", "start": [254, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.relMap_quotient_mk'_sigma_mk'", "code": "@[simp]\ntheorem relMap_quotient_mk'_sigma_mk' {n : \u2115} {R : L.Relations n} {i : \u03b9} {x : Fin n \u2192 G i} :\n    RelMap R (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) = RelMap R x", "start": [265, 1], "end": [272, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.exists_quotient_mk'_sigma_mk'_eq", "code": "theorem exists_quotient_mk'_sigma_mk'_eq {\u03b1 : Type*} [Fintype \u03b1] (x : \u03b1 \u2192 DirectLimit G f) :\n    \u2203 (i : \u03b9) (y : \u03b1 \u2192 G i), x = fun a => \u27e6.mk f i (y a)\u27e7", "start": [275, 1], "end": [287, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.of", "code": "def of (i : \u03b9) : G i \u21aa[L] DirectLimit G f where\n  toFun := fun a => \u27e6.mk f i a\u27e7\n  inj' x y h := by\n    rw [Quotient.eq] at h\n    obtain \u27e8j, h1, _, h3\u27e9 := h\n    exact (f i j h1).injective h3\n  map_fun' F x := by\n    simp only\n    rw [\u2190 funMap_quotient_mk'_sigma_mk']\n    rfl\n  map_rel' := by\n    intro n R x\n    change RelMap R (fun a => (\u27e6.mk f i (x a)\u27e7 : DirectLimit G f)) \u2194 _\n    simp only [relMap_quotient_mk'_sigma_mk']", "start": [292, 1], "end": [306, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.of_apply", "code": "@[simp]\ntheorem of_apply {i : \u03b9} {x : G i} : of L \u03b9 G f i x = \u27e6.mk f i x\u27e7", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.of_f", "code": "theorem of_f {i j : \u03b9} {hij : i \u2264 j} {x : G i} : of L \u03b9 G f j (f i j hij x) = of L \u03b9 G f i x", "start": [320, 1], "end": [323, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.exists_of", "code": "theorem exists_of (z : DirectLimit G f) : \u2203 i x, of L \u03b9 G f i x = z", "start": [326, 1], "end": [329, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.inductionOn", "code": "@[elab_as_elim]\nprotected theorem inductionOn {C : DirectLimit G f \u2192 Prop} (z : DirectLimit G f)\n    (ih : \u2200 i x, C (of L \u03b9 G f i x)) : C z", "start": [332, 1], "end": [336, 13], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.lift", "code": "def lift : DirectLimit G f \u21aa[L] P where\n  toFun :=\n    Quotient.lift (fun x : \u03a3\u02e3 f => (g x.1) x.2) fun x y xy => by\n      simp only\n      obtain \u27e8i, hx, hy\u27e9 := directed_of (\u00b7 \u2264 \u00b7) x.1 y.1\n      rw [\u2190 Hg x.1 i hx, \u2190 Hg y.1 i hy]\n      exact congr_arg _ ((equiv_iff ..).1 xy)\n  inj' x y xy := by\n    rw [\u2190 Quotient.out_eq x, \u2190 Quotient.out_eq y, Quotient.lift_mk, Quotient.lift_mk] at xy\n    obtain \u27e8i, hx, hy\u27e9 := directed_of (\u00b7 \u2264 \u00b7) x.out.1 y.out.1\n    rw [\u2190 Hg x.out.1 i hx, \u2190 Hg y.out.1 i hy] at xy\n    rw [\u2190 Quotient.out_eq x, \u2190 Quotient.out_eq y, Quotient.eq, equiv_iff G f hx hy]\n    exact (g i).injective xy\n  map_fun' F x := by\n    obtain \u27e8i, y, rfl\u27e9 := exists_quotient_mk'_sigma_mk'_eq G f x\n    change _ = funMap F (Quotient.lift _ _ \u2218 Quotient.mk _ \u2218 Structure.Sigma.mk f i \u2218 y)\n    rw [funMap_quotient_mk'_sigma_mk', \u2190 Function.comp.assoc, Quotient.lift_comp_mk]\n    simp only [Quotient.lift_mk, Embedding.map_fun]\n    rfl\n  map_rel' R x := by\n    obtain \u27e8i, y, rfl\u27e9 := exists_quotient_mk'_sigma_mk'_eq G f x\n    change RelMap R (Quotient.lift _ _ \u2218 Quotient.mk _ \u2218 Structure.Sigma.mk f i \u2218 y) \u2194 _\n    rw [relMap_quotient_mk'_sigma_mk' G f, \u2190 (g i).map_rel R y, \u2190 Function.comp.assoc,\n      Quotient.lift_comp_mk]\n    rfl", "start": [345, 1], "end": [372, 8], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.lift_quotient_mk'_sigma_mk'", "code": "@[simp]\ntheorem lift_quotient_mk'_sigma_mk' {i} (x : G i) : lift L \u03b9 G f g Hg \u27e6.mk f i x\u27e7 = (g i) x", "start": [377, 1], "end": [380, 37], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.lift_of", "code": "theorem lift_of {i} (x : G i) : lift L \u03b9 G f g Hg (of L \u03b9 G f i x) = g i x", "start": [383, 1], "end": [383, 86], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.lift_unique", "code": "theorem lift_unique (F : DirectLimit G f \u21aa[L] P) (x) :\n    F x =\n      lift L \u03b9 G f (fun i => F.comp <| of L \u03b9 G f i)\n        (fun i j hij x => by rw [F.comp_apply, F.comp_apply, of_f]) x", "start": [386, 1], "end": [390, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.cg", "code": "theorem cg {\u03b9 : Type*} [Encodable \u03b9] [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9]\n    {G : \u03b9 \u2192 Type w} [\u2200 i, L.Structure (G i)] (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n    (h : \u2200 i, Structure.CG L (G i)) [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f)", "start": [393, 1], "end": [408, 88], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.DirectLimit.cg'", "code": "instance cg' {\u03b9 : Type*} [Encodable \u03b9] [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b9]\n    {G : \u03b9 \u2192 Type w} [\u2200 i, L.Structure (G i)] (f : \u2200 i j, i \u2264 j \u2192 G i \u21aa[L] G j)\n    [h : \u2200 i, Structure.CG L (G i)] [DirectedSystem G fun i j h => f i j h] :\n    Structure.CG L (DirectLimit G f) :=\n  cg f h", "start": [411, 1], "end": [415, 9], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/FinBddDistLat.lean", "imports": ["Mathlib/Order/Category/BddDistLat.lean", "Mathlib/Data/Fintype/Order.lean", "Mathlib/Order/Category/FinPartOrd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FinBddDistLat", "code": "structure FinBddDistLat where\n  toBddDistLat : BddDistLat\n  [isFintype : Fintype toBddDistLat]", "start": [25, 1], "end": [28, 37], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.of", "code": "def of (\u03b1 : Type*) [DistribLattice \u03b1] [BoundedOrder \u03b1] [Fintype \u03b1] : FinBddDistLat :=\n  \u27e8\u27e8{\u03b1 := \u03b1}\u27e9\u27e9", "start": [44, 1], "end": [48, 15], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.of'", "code": "def of' (\u03b1 : Type*) [DistribLattice \u03b1] [Fintype \u03b1] [Nonempty \u03b1] : FinBddDistLat :=\n  haveI := Fintype.toBoundedOrder \u03b1\n  \u27e8\u27e8{\u03b1 := \u03b1}\u27e9\u27e9", "start": [51, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.largeCategory", "code": "instance largeCategory : LargeCategory FinBddDistLat :=\n  InducedCategory.category toBddDistLat", "start": [62, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.concreteCategory", "code": "instance concreteCategory : ConcreteCategory FinBddDistLat :=\n  InducedCategory.concreteCategory toBddDistLat", "start": [66, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.hasForgetToBddDistLat", "code": "instance hasForgetToBddDistLat : HasForget\u2082 FinBddDistLat BddDistLat :=\n  InducedCategory.hasForget\u2082 FinBddDistLat.toBddDistLat", "start": [70, 1], "end": [71, 56], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.hasForgetToFinPartOrd", "code": "instance hasForgetToFinPartOrd : HasForget\u2082 FinBddDistLat FinPartOrd where\n  forget\u2082.obj X := FinPartOrd.of X\n  forget\u2082.map {X Y} f := (show BoundedLatticeHom X Y from f : X \u2192o Y)", "start": [74, 1], "end": [76, 70], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : FinBddDistLat.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : BoundedLatticeHom \u03b1 \u03b2)\n  inv := (e.symm : BoundedLatticeHom \u03b2 \u03b1)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [79, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.dual", "code": "@[simps]\ndef dual : FinBddDistLat \u2964 FinBddDistLat where\n  obj X := of X\u1d52\u1d48\n  map {X Y} := BoundedLatticeHom.dual", "start": [92, 1], "end": [96, 38], "kind": "commanddeclaration"}, {"full_name": "FinBddDistLat.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : FinBddDistLat \u224c FinBddDistLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [99, 1], "end": [105, 74], "kind": "commanddeclaration"}, {"full_name": "finBddDistLat_dual_comp_forget_to_bddDistLat", "code": "theorem finBddDistLat_dual_comp_forget_to_bddDistLat :\n    FinBddDistLat.dual \u22d9 forget\u2082 FinBddDistLat BddDistLat =\n      forget\u2082 FinBddDistLat BddDistLat \u22d9 BddDistLat.dual", "start": [110, 1], "end": [113, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Sheaf/Basic.lean", "imports": ["Mathlib/Topology/Sheaves/LocalPredicate.lean", "Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.of.chartedSpace", "code": "instance TopCat.of.chartedSpace : ChartedSpace H (TopCat.of M) :=\n  (inferInstance : ChartedSpace H M)", "start": [45, 1], "end": [46, 37], "kind": "commanddeclaration"}, {"full_name": "TopCat.of.hasGroupoid", "code": "instance TopCat.of.hasGroupoid [HasGroupoid M G] : HasGroupoid (TopCat.of M) G :=\n  (inferInstance : HasGroupoid M G)", "start": [50, 1], "end": [51, 36], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.LocalInvariantProp.localPredicate", "code": "def StructureGroupoid.LocalInvariantProp.localPredicate (hG : LocalInvariantProp G G' P) :\n    TopCat.LocalPredicate fun _ : TopCat.of M => M' where\n  pred {U : Opens (TopCat.of M)} := fun f : U \u2192 M' => ChartedSpace.LiftProp P f\n  res := by\n    intro U V i f h x\n    have hUV : U \u2264 V := CategoryTheory.leOfHom i\n    show ChartedSpace.LiftPropAt P (f \u2218 Set.inclusion hUV) x\n    rw [\u2190 hG.liftPropAt_iff_comp_inclusion hUV]\n    apply h\n  locality := by\n    intro V f h x\n    obtain \u27e8U, hxU, i, hU : ChartedSpace.LiftProp P (f \u2218 i)\u27e9 := h x\n    let x' : U := \u27e8x, hxU\u27e9\n    have hUV : U \u2264 V := CategoryTheory.leOfHom i\n    have : ChartedSpace.LiftPropAt P f (inclusion hUV x') := by\n      rw [hG.liftPropAt_iff_comp_inclusion hUV]\n      exact hU x'\n    convert this", "start": [55, 1], "end": [75, 17], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.LocalInvariantProp.sheaf", "code": "def StructureGroupoid.LocalInvariantProp.sheaf (hG : LocalInvariantProp G G' P) :\n    TopCat.Sheaf (Type u) (TopCat.of M) :=\n  TopCat.subsheafToTypes (hG.localPredicate M M')", "start": [78, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.LocalInvariantProp.sheafHasCoeToFun", "code": "instance StructureGroupoid.LocalInvariantProp.sheafHasCoeToFun (hG : LocalInvariantProp G G' P)\n    (U : (Opens (TopCat.of M))\u1d52\u1d56) : CoeFun ((hG.sheaf M M').val.obj U) fun _ => \u2191(unop U) \u2192 M' where\n  coe a := a.1", "start": [87, 1], "end": [89, 15], "kind": "commanddeclaration"}, {"full_name": "StructureGroupoid.LocalInvariantProp.section_spec", "code": "theorem StructureGroupoid.LocalInvariantProp.section_spec (hG : LocalInvariantProp G G' P)\n    (U : (Opens (TopCat.of M))\u1d52\u1d56) (f : (hG.sheaf M M').val.obj U) : ChartedSpace.LiftProp P f", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Array/Basic.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/std/Std/Tactic/HaveI.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.toArray_data", "code": "alias List.toArray_data := Array.data_toArray", "start": [6, 1], "end": [6, 46], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/RingTheory/GradedAlgebra/Radical.lean", "imports": ["Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem", "code": "theorem Ideal.IsHomogeneous.isPrime_of_homogeneous_mem_or_mem {I : Ideal A} (hI : I.IsHomogeneous \ud835\udc9c)\n    (I_ne_top : I \u2260 \u22a4)\n    (homogeneous_mem_or_mem :\n      \u2200 {x y : A}, Homogeneous \ud835\udc9c x \u2192 Homogeneous \ud835\udc9c y \u2192 x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I) :\n    Ideal.IsPrime I", "start": [52, 1], "end": [142, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.isPrime_iff", "code": "theorem Ideal.IsHomogeneous.isPrime_iff {I : Ideal A} (h : I.IsHomogeneous \ud835\udc9c) :\n    I.IsPrime \u2194\n      I \u2260 \u22a4 \u2227\n        \u2200 {x y : A},\n          SetLike.Homogeneous \ud835\udc9c x \u2192 SetLike.Homogeneous \ud835\udc9c y \u2192 x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [145, 1], "end": [152, 74], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.homogeneousCore", "code": "theorem Ideal.IsPrime.homogeneousCore {I : Ideal A} (h : I.IsPrime) :\n    (I.homogeneousCore \ud835\udc9c).toIdeal.IsPrime", "start": [155, 1], "end": [163, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.radical_eq", "code": "theorem Ideal.IsHomogeneous.radical_eq {I : Ideal A} (hI : I.IsHomogeneous \ud835\udc9c) :\n    I.radical = InfSet.sInf { J | Ideal.IsHomogeneous \ud835\udc9c J \u2227 I \u2264 J \u2227 J.IsPrime }", "start": [166, 1], "end": [175, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.radical", "code": "theorem Ideal.IsHomogeneous.radical {I : Ideal A} (h : I.IsHomogeneous \ud835\udc9c) :\n    I.radical.IsHomogeneous \ud835\udc9c", "start": [178, 1], "end": [181, 51], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.radical", "code": "def HomogeneousIdeal.radical (I : HomogeneousIdeal \ud835\udc9c) : HomogeneousIdeal \ud835\udc9c :=\n  \u27e8I.toIdeal.radical, I.isHomogeneous.radical\u27e9", "start": [184, 1], "end": [186, 47], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.coe_radical", "code": "@[simp]\ntheorem HomogeneousIdeal.coe_radical (I : HomogeneousIdeal \ud835\udc9c) :\n    I.radical.toIdeal = I.toIdeal.radical", "start": [189, 1], "end": [191, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/StructureSheaf.lean", "imports": ["Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Topology.lean", "Mathlib/Topology/Sheaves/LocalPredicate.lean", "Mathlib/Geometry/RingedSpace/LocallyRingedSpace.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean"], "premises": [{"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.IsFraction", "code": "def IsFraction {U : Opens (ProjectiveSpectrum.top \ud835\udc9c)} (f : \u2200 x : U, at x.1) : Prop :=\n  \u2203 (i : \u2115) (r s : \ud835\udc9c i),\n    \u2200 x : U, \u2203 s_nin : s.1 \u2209 x.1.asHomogeneousIdeal, f x = Quotient.mk'' \u27e8i, r, s, s_nin\u27e9", "start": [73, 1], "end": [78, 90], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.isFractionPrelocal", "code": "def isFractionPrelocal : PrelocalPredicate fun x : ProjectiveSpectrum.top \ud835\udc9c => at x where\n  pred f := IsFraction f\n  res := by rintro V U i f \u27e8j, r, s, w\u27e9; exact \u27e8j, r, s, fun y => w (i y)\u27e9", "start": [82, 1], "end": [88, 75], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.isLocallyFraction", "code": "def isLocallyFraction : LocalPredicate fun x : ProjectiveSpectrum.top \ud835\udc9c => at x :=\n  (isFractionPrelocal \ud835\udc9c).sheafify", "start": [91, 1], "end": [95, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.SectionSubring.zeroMem'", "code": "theorem zeroMem' (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) :\n    (isLocallyFraction \ud835\udc9c).pred (0 : \u2200 x : U.unop, at x.1)", "start": [104, 1], "end": [106, 92], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.SectionSubring.oneMem'", "code": "theorem oneMem' (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) :\n    (isLocallyFraction \ud835\udc9c).pred (1 : \u2200 x : U.unop, at x.1)", "start": [109, 1], "end": [111, 98], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.SectionSubring.addMem'", "code": "theorem addMem' (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) (a b : \u2200 x : U.unop, at x.1)\n    (ha : (isLocallyFraction \ud835\udc9c).pred a) (hb : (isLocallyFraction \ud835\udc9c).pred b) :\n    (isLocallyFraction \ud835\udc9c).pred (a + b)", "start": [114, 1], "end": [134, 8], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.SectionSubring.negMem'", "code": "theorem negMem' (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) (a : \u2200 x : U.unop, at x.1)\n    (ha : (isLocallyFraction \ud835\udc9c).pred a) : (isLocallyFraction \ud835\udc9c).pred (-a)", "start": [137, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.SectionSubring.mulMem'", "code": "theorem mulMem' (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) (a b : \u2200 x : U.unop, at x.1)\n    (ha : (isLocallyFraction \ud835\udc9c).pred a) (hb : (isLocallyFraction \ud835\udc9c).pred b) :\n    (isLocallyFraction \ud835\udc9c).pred (a * b)", "start": [146, 1], "end": [164, 8], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.sectionsSubring", "code": "def sectionsSubring (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) : Subring (\u2200 x : U.unop, at x.1)\n    where\n  carrier := {f | (isLocallyFraction \ud835\udc9c).pred f}\n  zero_mem' := zeroMem' U\n  one_mem' := oneMem' U\n  add_mem' := addMem' U _ _\n  neg_mem' := negMem' U _\n  mul_mem' := mulMem' U _ _", "start": [175, 1], "end": [184, 28], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType", "code": "def structureSheafInType : Sheaf (Type _) (ProjectiveSpectrum.top \ud835\udc9c) :=\n  subsheafToTypes (isLocallyFraction \ud835\udc9c)", "start": [189, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.commRingStructureSheafInTypeObj", "code": "instance commRingStructureSheafInTypeObj (U : (Opens (ProjectiveSpectrum.top \ud835\udc9c))\u1d52\u1d56) :\n    CommRing ((structureSheafInType \ud835\udc9c).1.obj U) :=\n  (sectionsSubring U).toCommRing", "start": [195, 1], "end": [197, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing", "code": "@[simps]\ndef structurePresheafInCommRing : Presheaf CommRingCat (ProjectiveSpectrum.top \ud835\udc9c) where\n  obj U := CommRingCat.of ((structureSheafInType \ud835\udc9c).1.obj U)\n  map i :=\n    { toFun := (structureSheafInType \ud835\udc9c).1.map i\n      map_zero' := rfl\n      map_add' := fun x y => rfl\n      map_one' := rfl\n      map_mul' := fun x y => rfl }", "start": [200, 1], "end": [210, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafCompForget", "code": "def structurePresheafCompForget :\n    structurePresheafInCommRing \ud835\udc9c \u22d9 forget CommRingCat \u2245 (structureSheafInType \ud835\udc9c).1 :=\n  NatIso.ofComponents (fun U => Iso.refl _) (by aesop_cat)", "start": [218, 1], "end": [222, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.ProjectiveSpectrum.Proj.structureSheaf", "code": "def Proj.structureSheaf : Sheaf CommRingCat (ProjectiveSpectrum.top \ud835\udc9c) :=\n  \u27e8structurePresheafInCommRing \ud835\udc9c,\n    (isSheaf_iff_isSheaf_comp\n          _ _).mpr\n      (isSheaf_of_iso (structurePresheafCompForget \ud835\udc9c).symm (structureSheafInType \ud835\udc9c).cond)\u27e9", "start": [231, 1], "end": [237, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.res_apply", "code": "@[simp]\ntheorem res_apply (U V : Opens (ProjectiveSpectrum.top \ud835\udc9c)) (i : V \u27f6 U)\n    (s : (Proj.structureSheaf \ud835\udc9c).1.obj (op U)) (x : V) :\n    ((Proj.structureSheaf \ud835\udc9c).1.map i.op s).1 x = (s.1 (i x) : _)", "start": [247, 1], "end": [251, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Proj.toSheafedSpace", "code": "def Proj.toSheafedSpace : SheafedSpace CommRingCat where\n  carrier := TopCat.of (ProjectiveSpectrum \ud835\udc9c)\n  presheaf := (Proj.structureSheaf \ud835\udc9c).1\n  IsSheaf := (Proj.structureSheaf \ud835\udc9c).2", "start": [254, 1], "end": [258, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.openToLocalization", "code": "def openToLocalization (U : Opens (ProjectiveSpectrum.top \ud835\udc9c)) (x : ProjectiveSpectrum.top \ud835\udc9c)\n    (hx : x \u2208 U) : (Proj.structureSheaf \ud835\udc9c).1.obj (op U) \u27f6 CommRingCat.of (at x) where\n  toFun s := (s.1 \u27e8x, hx\u27e9 : _)\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [262, 1], "end": [271, 22], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.stalkToFiberRingHom", "code": "def stalkToFiberRingHom (x : ProjectiveSpectrum.top \ud835\udc9c) :\n    (Proj.structureSheaf \ud835\udc9c).presheaf.stalk x \u27f6 CommRingCat.of (at x) :=\n  Limits.colimit.desc ((OpenNhds.inclusion x).op \u22d9 (Proj.structureSheaf \ud835\udc9c).1)\n    { pt := _\n      \u03b9 :=\n        { app := fun U =>\n            openToLocalization \ud835\udc9c ((OpenNhds.inclusion _).obj U.unop) x U.unop.2\n          naturality := fun _ _ _ => rfl } }", "start": [274, 1], "end": [285, 45], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.germ_comp_stalkToFiberRingHom", "code": "@[simp]\ntheorem germ_comp_stalkToFiberRingHom (U : Opens (ProjectiveSpectrum.top \ud835\udc9c)) (x : U) :\n    (Proj.structureSheaf \ud835\udc9c).presheaf.germ x \u226b stalkToFiberRingHom \ud835\udc9c x =\n      openToLocalization \ud835\udc9c U x x.2", "start": [288, 1], "end": [292, 28], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.stalkToFiberRingHom_germ'", "code": "@[simp]\ntheorem stalkToFiberRingHom_germ' (U : Opens (ProjectiveSpectrum.top \ud835\udc9c))\n    (x : ProjectiveSpectrum.top \ud835\udc9c) (hx : x \u2208 U) (s : (Proj.structureSheaf \ud835\udc9c).1.obj (op U)) :\n    stalkToFiberRingHom \ud835\udc9c x ((Proj.structureSheaf \ud835\udc9c).presheaf.germ \u27e8x, hx\u27e9 s) = (s.1 \u27e8x, hx\u27e9 : _)", "start": [295, 1], "end": [299, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.stalkToFiberRingHom_germ", "code": "@[simp]\ntheorem stalkToFiberRingHom_germ (U : Opens (ProjectiveSpectrum.top \ud835\udc9c)) (x : U)\n    (s : (Proj.structureSheaf \ud835\udc9c).1.obj (op U)) :\n    stalkToFiberRingHom \ud835\udc9c x ((Proj.structureSheaf \ud835\udc9c).presheaf.germ x s) = s.1 x", "start": [302, 1], "end": [306, 38], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.HomogeneousLocalization.mem_basicOpen", "code": "theorem HomogeneousLocalization.mem_basicOpen (x : ProjectiveSpectrum.top \ud835\udc9c) (f : at x) :\n    x \u2208 ProjectiveSpectrum.basicOpen \ud835\udc9c f.den", "start": [309, 1], "end": [312, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.sectionInBasicOpen", "code": "def sectionInBasicOpen (x : ProjectiveSpectrum.top \ud835\udc9c) :\n    \u2200 f : at x, (Proj.structureSheaf \ud835\udc9c).1.obj (op (ProjectiveSpectrum.basicOpen \ud835\udc9c f.den)) :=\n  fun f =>\n  \u27e8fun y => Quotient.mk'' \u27e8f.deg, \u27e8f.num, f.num_mem_deg\u27e9, \u27e8f.den, f.den_mem_deg\u27e9, y.2\u27e9, fun y =>\n    \u27e8ProjectiveSpectrum.basicOpen \ud835\udc9c f.den, y.2,\n      \u27e8\ud835\udfd9 _, \u27e8f.deg, \u27e8\u27e8f.num, f.num_mem_deg\u27e9, \u27e8f.den, f.den_mem_deg\u27e9, fun z => \u27e8z.2, rfl\u27e9\u27e9\u27e9\u27e9\u27e9\u27e9", "start": [315, 1], "end": [323, 94], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.homogeneousLocalizationToStalk", "code": "def homogeneousLocalizationToStalk (x : ProjectiveSpectrum.top \ud835\udc9c) :\n    (at x) \u2192 (Proj.structureSheaf \ud835\udc9c).presheaf.stalk x := fun f =>\n  (Proj.structureSheaf \ud835\udc9c).presheaf.germ\n    (\u27e8x, HomogeneousLocalization.mem_basicOpen _ x f\u27e9 : ProjectiveSpectrum.basicOpen _ f.den)\n    (sectionInBasicOpen _ x f)", "start": [326, 1], "end": [333, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Proj.stalkIso'", "code": "def Proj.stalkIso' (x : ProjectiveSpectrum.top \ud835\udc9c) :\n    (Proj.structureSheaf \ud835\udc9c).presheaf.stalk x \u2243+* CommRingCat.of (at x) :=\n  RingEquiv.ofBijective (stalkToFiberRingHom _ x)\n    \u27e8fun z1 z2 eq1 => by\n      obtain \u27e8u1, memu1, s1, rfl\u27e9 := (Proj.structureSheaf \ud835\udc9c).presheaf.germ_exist x z1\n      obtain \u27e8u2, memu2, s2, rfl\u27e9 := (Proj.structureSheaf \ud835\udc9c).presheaf.germ_exist x z2\n      obtain \u27e8v1, memv1, i1, \u27e8j1, \u27e8a1, a1_mem\u27e9, \u27e8b1, b1_mem\u27e9, hs1\u27e9\u27e9 := s1.2 \u27e8x, memu1\u27e9\n      obtain \u27e8v2, memv2, i2, \u27e8j2, \u27e8a2, a2_mem\u27e9, \u27e8b2, b2_mem\u27e9, hs2\u27e9\u27e9 := s2.2 \u27e8x, memu2\u27e9\n      obtain \u27e8b1_nin_x, eq2\u27e9 := hs1 \u27e8x, memv1\u27e9\n      obtain \u27e8b2_nin_x, eq3\u27e9 := hs2 \u27e8x, memv2\u27e9\n      dsimp only at eq1 eq2 eq3\n      erw [stalkToFiberRingHom_germ \ud835\udc9c u1 \u27e8x, memu1\u27e9 s1,\n        stalkToFiberRingHom_germ \ud835\udc9c u2 \u27e8x, memu2\u27e9 s2] at eq1\n      erw [eq1] at eq2\n      erw [eq2, Quotient.eq''] at eq3\n      change Localization.mk _ _ = Localization.mk _ _ at eq3\n      rw [Localization.mk_eq_mk', IsLocalization.eq] at eq3\n      obtain \u27e8\u27e8c, hc\u27e9, eq3\u27e9 := eq3\n      have eq3' :\n        \u2200 (y : ProjectiveSpectrum.top \ud835\udc9c)\n          (hy : y \u2208 ProjectiveSpectrum.basicOpen \ud835\udc9c b1 \u2293 ProjectiveSpectrum.basicOpen \ud835\udc9c b2 \u2293\n                ProjectiveSpectrum.basicOpen \ud835\udc9c c), (Localization.mk a1 \u27e8b1,\n                  show b1 \u2209 y.asHomogeneousIdeal by\n                    rw [\u2190 ProjectiveSpectrum.mem_basicOpen]\n                    exact leOfHom (Opens.infLELeft _ _ \u226b Opens.infLELeft _ _) hy\u27e9 :\n              Localization.AtPrime y.1.toIdeal) = Localization.mk a2\n              \u27e8b2, by\n                change b2 \u2209 y.asHomogeneousIdeal\n                rw [\u2190 ProjectiveSpectrum.mem_basicOpen]\n                exact leOfHom (Opens.infLELeft _ _ \u226b Opens.infLERight _ _) hy\u27e9 := by\n        intro y hy\n        rw [Localization.mk_eq_mk', IsLocalization.eq]\n        exact\n          \u27e8\u27e8c, show c \u2209 y.asHomogeneousIdeal by\n                  rw [\u2190 ProjectiveSpectrum.mem_basicOpen]\n                  exact leOfHom (Opens.infLERight _ _) hy\u27e9, eq3\u27e9\n      refine'\n        Presheaf.germ_ext (Proj.structureSheaf \ud835\udc9c).1\n          (ProjectiveSpectrum.basicOpen _ b1 \u2293 ProjectiveSpectrum.basicOpen _ b2 \u2293\n                ProjectiveSpectrum.basicOpen _ c \u2293 v1 \u2293 v2)\n          \u27e8\u27e8\u27e8\u27e8b1_nin_x, b2_nin_x\u27e9, hc\u27e9, memv1\u27e9, memv2\u27e9\n          (Opens.infLELeft _ _ \u226b Opens.infLERight _ _ \u226b i1) (Opens.infLERight _ _ \u226b i2) _\n      rw [Subtype.ext_iff_val]\n      ext1 y\n      simp only [res_apply]\n      obtain \u27e8b1_nin_y, eq6\u27e9 :=\n        hs1 \u27e8_, leOfHom (Opens.infLELeft _ _ \u226b Opens.infLERight _ _) y.2\u27e9\n      obtain \u27e8b2_nin_y, eq7\u27e9 := hs2 \u27e8_, leOfHom (Opens.infLERight _ _) y.2\u27e9\n      simp only at eq6 eq7\n      erw [eq6, eq7, Quotient.eq'']\n      change Localization.mk _ _ = Localization.mk _ _\n      exact eq3' _\n          \u27e8\u27e8leOfHom\n                (Opens.infLELeft _ _ \u226b\n                  Opens.infLELeft _ _ \u226b Opens.infLELeft _ _ \u226b Opens.infLELeft _ _) y.2,\n              leOfHom\n                (Opens.infLELeft _ _ \u226b\n                  Opens.infLELeft _ _ \u226b Opens.infLELeft _ _ \u226b Opens.infLERight _ _) y.2\u27e9,\n            leOfHom (Opens.infLELeft _ _ \u226b Opens.infLELeft _ _ \u226b Opens.infLERight _ _) y.2\u27e9,\n      Function.surjective_iff_hasRightInverse.mpr\n        \u27e8homogeneousLocalizationToStalk \ud835\udc9c x, fun f => by\n          rw [homogeneousLocalizationToStalk]\n          erw [stalkToFiberRingHom_germ \ud835\udc9c (ProjectiveSpectrum.basicOpen \ud835\udc9c f.den) \u27e8x, _\u27e9\n              (sectionInBasicOpen _ x f)]\n          rw [sectionInBasicOpen, HomogeneousLocalization.ext_iff_val, f.eq_num_div_den]\n          simp only [unop_op, HomogeneousLocalization.val_mk'', mk_eq_monoidOf_mk'] \u27e9\u27e9", "start": [336, 1], "end": [403, 87], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Proj.toLocallyRingedSpace", "code": "def Proj.toLocallyRingedSpace : LocallyRingedSpace :=\n  { Proj.toSheafedSpace \ud835\udc9c with\n    localRing := fun x =>\n      @RingEquiv.localRing _ _ _ (show LocalRing (at x) from inferInstance) _\n        (Proj.stalkIso' \ud835\udc9c x).symm }", "start": [407, 1], "end": [412, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Ideal.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/Algebra/MonoidAlgebra/Division.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonoidAlgebra.mem_ideal_span_of_image", "code": "theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}\n    {x : MonoidAlgebra k G} :\n    x \u2208 Ideal.span (MonoidAlgebra.of k G '' s) \u2194 \u2200 m \u2208 x.support, \u2203 m' \u2208 s, \u2203 d, m = d * m'", "start": [18, 1], "end": [60, 82], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_ideal_span_of'_image", "code": "theorem AddMonoidAlgebra.mem_ideal_span_of'_image [AddMonoid A] [Semiring k] {s : Set A}\n    {x : AddMonoidAlgebra k A} :\n    x \u2208 Ideal.span (AddMonoidAlgebra.of' k A '' s) \u2194 \u2200 m \u2208 x.support, \u2203 m' \u2208 s, \u2203 d, m = d + m'", "start": [63, 1], "end": [69, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Division.lean", "imports": ["Mathlib/Data/MvPolynomial/Basic.lean", "Mathlib/Algebra/MonoidAlgebra/Division.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.divMonomial", "code": "noncomputable def divMonomial (p : MvPolynomial \u03c3 R) (s : \u03c3 \u2192\u2080 \u2115) : MvPolynomial \u03c3 R :=\n  AddMonoidAlgebra.divOf p s", "start": [43, 1], "end": [45, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_divMonomial", "code": "@[simp]\ntheorem coeff_divMonomial (s : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) (s' : \u03c3 \u2192\u2080 \u2115) :\n    coeff s' (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s) = coeff (s + s') x", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_divMonomial", "code": "@[simp]\ntheorem support_divMonomial (s : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s).support = x.support.preimage _ ((add_right_injective s).injOn _)", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zero_divMonomial", "code": "@[simp]\ntheorem zero_divMonomial (s : \u03c3 \u2192\u2080 \u2115) : (0 : MvPolynomial \u03c3 R) /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = 0", "start": [62, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_zero", "code": "theorem divMonomial_zero (x : MvPolynomial \u03c3 R) : x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 0 = x", "start": [67, 1], "end": [68, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.add_divMonomial", "code": "theorem add_divMonomial (x y : MvPolynomial \u03c3 R) (s : \u03c3 \u2192\u2080 \u2115) :\n    (x + y) /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s + y /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s", "start": [71, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_add", "code": "theorem divMonomial_add (a b : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 (a + b) = x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 a /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 b", "start": [76, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_monomial_mul", "code": "@[simp]\ntheorem divMonomial_monomial_mul (a : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    monomial a 1 * x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 a = x", "start": [81, 1], "end": [84, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_mul_monomial", "code": "@[simp]\ntheorem divMonomial_mul_monomial (a : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    x * monomial a 1 /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 a = x", "start": [87, 1], "end": [90, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_monomial", "code": "@[simp]\ntheorem divMonomial_monomial (a : \u03c3 \u2192\u2080 \u2115) : monomial a 1 /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 a = (1 : MvPolynomial \u03c3 R)", "start": [93, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.modMonomial", "code": "noncomputable def modMonomial (x : MvPolynomial \u03c3 R) (s : \u03c3 \u2192\u2080 \u2115) : MvPolynomial \u03c3 R :=\n  x.modOf s", "start": [98, 1], "end": [100, 12], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_modMonomial_of_not_le", "code": "@[simp]\ntheorem coeff_modMonomial_of_not_le {s' s : \u03c3 \u2192\u2080 \u2115} (x : MvPolynomial \u03c3 R) (h : \u00acs \u2264 s') :\n    coeff s' (x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s) = coeff s' x", "start": [105, 1], "end": [111, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_modMonomial_of_le", "code": "@[simp]\ntheorem coeff_modMonomial_of_le {s' s : \u03c3 \u2192\u2080 \u2115} (x : MvPolynomial \u03c3 R) (h : s \u2264 s') :\n    coeff s' (x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s) = 0", "start": [114, 1], "end": [117, 56], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_mul_modMonomial", "code": "@[simp]\ntheorem monomial_mul_modMonomial (s : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    monomial s 1 * x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = 0", "start": [120, 1], "end": [123, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mul_monomial_modMonomial", "code": "@[simp]\ntheorem mul_monomial_modMonomial (s : \u03c3 \u2192\u2080 \u2115) (x : MvPolynomial \u03c3 R) :\n    x * monomial s 1 %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = 0", "start": [126, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_modMonomial", "code": "@[simp]\ntheorem monomial_modMonomial (s : \u03c3 \u2192\u2080 \u2115) : monomial s (1 : R) %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = 0", "start": [132, 1], "end": [134, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_add_modMonomial", "code": "theorem divMonomial_add_modMonomial (x : MvPolynomial \u03c3 R) (s : \u03c3 \u2192\u2080 \u2115) :\n    monomial s 1 * (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s) + x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s = x", "start": [137, 1], "end": [139, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.modMonomial_add_divMonomial", "code": "theorem modMonomial_add_divMonomial (x : MvPolynomial \u03c3 R) (s : \u03c3 \u2192\u2080 \u2115) :\n    x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s + monomial s 1 * (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 s) = x", "start": [142, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_one_dvd_iff_modMonomial_eq_zero", "code": "theorem monomial_one_dvd_iff_modMonomial_eq_zero {i : \u03c3 \u2192\u2080 \u2115} {x : MvPolynomial \u03c3 R} :\n    monomial i (1 : R) \u2223 x \u2194 x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 i = 0", "start": [147, 1], "end": [149, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_mul_divMonomial", "code": "@[simp]\ntheorem X_mul_divMonomial (i : \u03c3) (x : MvPolynomial \u03c3 R) :\n    X i * x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = x", "start": [160, 1], "end": [163, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_divMonomial", "code": "@[simp]\ntheorem X_divMonomial (i : \u03c3) : (X i : MvPolynomial \u03c3 R) /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 1", "start": [167, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mul_X_divMonomial", "code": "@[simp]\ntheorem mul_X_divMonomial (x : MvPolynomial \u03c3 R) (i : \u03c3) :\n    x * X i /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = x", "start": [173, 1], "end": [176, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_mul_modMonomial", "code": "@[simp]\ntheorem X_mul_modMonomial (i : \u03c3) (x : MvPolynomial \u03c3 R) :\n    X i * x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 0", "start": [180, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mul_X_modMonomial", "code": "@[simp]\ntheorem mul_X_modMonomial (x : MvPolynomial \u03c3 R) (i : \u03c3) :\n    x * X i %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 0", "start": [187, 1], "end": [190, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.modMonomial_X", "code": "@[simp]\ntheorem modMonomial_X (i : \u03c3) : (X i : MvPolynomial \u03c3 R) %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 0", "start": [194, 1], "end": [196, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.divMonomial_add_modMonomial_single", "code": "theorem divMonomial_add_modMonomial_single (x : MvPolynomial \u03c3 R) (i : \u03c3) :\n    X i * (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1) + x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = x", "start": [200, 1], "end": [202, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.modMonomial_add_divMonomial_single", "code": "theorem modMonomial_add_divMonomial_single (x : MvPolynomial \u03c3 R) (i : \u03c3) :\n    x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 + X i * (x /\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1) = x", "start": [205, 1], "end": [207, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_dvd_iff_modMonomial_eq_zero", "code": "theorem X_dvd_iff_modMonomial_eq_zero {i : \u03c3} {x : MvPolynomial \u03c3 R} :\n    X i \u2223 x \u2194 x %\u1d50\u1d52\u207f\u1d52\u1d50\u2071\u1d43\u02e1 Finsupp.single i 1 = 0", "start": [210, 1], "end": [212, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_dvd_monomial", "code": "theorem monomial_dvd_monomial {r s : R} {i j : \u03c3 \u2192\u2080 \u2115} :\n    monomial i r \u2223 monomial j s \u2194 (s = 0 \u2228 i \u2264 j) \u2227 r \u2223 s", "start": [221, 1], "end": [240, 51], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_one_dvd_monomial_one", "code": "@[simp]\ntheorem monomial_one_dvd_monomial_one [Nontrivial R] {i j : \u03c3 \u2192\u2080 \u2115} :\n    monomial i (1 : R) \u2223 monomial j 1 \u2194 i \u2264 j", "start": [243, 1], "end": [247, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_dvd_X", "code": "@[simp]\ntheorem X_dvd_X [Nontrivial R] {i j : \u03c3} :\n    (X i : MvPolynomial \u03c3 R) \u2223 (X j : MvPolynomial \u03c3 R) \u2194 i = j", "start": [250, 1], "end": [255, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_dvd_monomial", "code": "@[simp]\ntheorem X_dvd_monomial {i : \u03c3} {j : \u03c3 \u2192\u2080 \u2115} {r : R} :\n    (X i : MvPolynomial \u03c3 R) \u2223 monomial j r \u2194 r = 0 \u2228 j i \u2260 0", "start": [259, 1], "end": [263, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupPower/Identities.lean", "imports": ["Mathlib/Tactic/Ring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sq_add_sq_mul_sq_add_sq", "code": "theorem sq_add_sq_mul_sq_add_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2) = (x\u2081 * y\u2081 - x\u2082 * y\u2082) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2", "start": [19, 1], "end": [26, 7], "kind": "commanddeclaration"}, {"full_name": "sq_add_mul_sq_mul_sq_add_mul_sq", "code": "theorem sq_add_mul_sq_mul_sq_add_mul_sq :\n    (x\u2081 ^ 2 + n * x\u2082 ^ 2) * (y\u2081 ^ 2 + n * y\u2082 ^ 2) =\n    (x\u2081 * y\u2081 - n * x\u2082 * y\u2082) ^ 2 + n * (x\u2081 * y\u2082 + x\u2082 * y\u2081) ^ 2", "start": [29, 1], "end": [34, 7], "kind": "commanddeclaration"}, {"full_name": "pow_four_add_four_mul_pow_four", "code": "theorem pow_four_add_four_mul_pow_four :\n    a ^ 4 + 4 * b ^ 4 = ((a - b) ^ 2 + b ^ 2) * ((a + b) ^ 2 + b ^ 2)", "start": [37, 1], "end": [41, 7], "kind": "commanddeclaration"}, {"full_name": "pow_four_add_four_mul_pow_four'", "code": "theorem pow_four_add_four_mul_pow_four' :\n    a ^ 4 + 4 * b ^ 4 = (a ^ 2 - 2 * a * b + 2 * b ^ 2) * (a ^ 2 + 2 * a * b + 2 * b ^ 2)", "start": [44, 1], "end": [48, 7], "kind": "commanddeclaration"}, {"full_name": "sum_four_sq_mul_sum_four_sq", "code": "theorem sum_four_sq_mul_sum_four_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2) * (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2) =\n      (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084) ^ 2 + (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083) ^ 2 +\n          (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082) ^ 2 +\n        (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081) ^ 2", "start": [51, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "sum_eight_sq_mul_sum_eight_sq", "code": "theorem sum_eight_sq_mul_sum_eight_sq :\n    (x\u2081 ^ 2 + x\u2082 ^ 2 + x\u2083 ^ 2 + x\u2084 ^ 2 + x\u2085 ^ 2 + x\u2086 ^ 2 + x\u2087 ^ 2 + x\u2088 ^ 2) *\n      (y\u2081 ^ 2 + y\u2082 ^ 2 + y\u2083 ^ 2 + y\u2084 ^ 2 + y\u2085 ^ 2 + y\u2086 ^ 2 + y\u2087 ^ 2 + y\u2088 ^ 2) =\n    (x\u2081 * y\u2081 - x\u2082 * y\u2082 - x\u2083 * y\u2083 - x\u2084 * y\u2084 - x\u2085 * y\u2085 - x\u2086 * y\u2086 - x\u2087 * y\u2087 - x\u2088 * y\u2088) ^ 2 +\n      (x\u2081 * y\u2082 + x\u2082 * y\u2081 + x\u2083 * y\u2084 - x\u2084 * y\u2083 + x\u2085 * y\u2086 - x\u2086 * y\u2085 - x\u2087 * y\u2088 + x\u2088 * y\u2087) ^ 2 +\n      (x\u2081 * y\u2083 - x\u2082 * y\u2084 + x\u2083 * y\u2081 + x\u2084 * y\u2082 + x\u2085 * y\u2087 + x\u2086 * y\u2088 - x\u2087 * y\u2085 - x\u2088 * y\u2086) ^ 2 +\n      (x\u2081 * y\u2084 + x\u2082 * y\u2083 - x\u2083 * y\u2082 + x\u2084 * y\u2081 + x\u2085 * y\u2088 - x\u2086 * y\u2087 + x\u2087 * y\u2086 - x\u2088 * y\u2085) ^ 2 +\n      (x\u2081 * y\u2085 - x\u2082 * y\u2086 - x\u2083 * y\u2087 - x\u2084 * y\u2088 + x\u2085 * y\u2081 + x\u2086 * y\u2082 + x\u2087 * y\u2083 + x\u2088 * y\u2084) ^ 2 +\n      (x\u2081 * y\u2086 + x\u2082 * y\u2085 - x\u2083 * y\u2088 + x\u2084 * y\u2087 - x\u2085 * y\u2082 + x\u2086 * y\u2081 - x\u2087 * y\u2084 + x\u2088 * y\u2083) ^ 2 +\n      (x\u2081 * y\u2087 + x\u2082 * y\u2088 + x\u2083 * y\u2085 - x\u2084 * y\u2086 - x\u2085 * y\u2083 + x\u2086 * y\u2084 + x\u2087 * y\u2081 - x\u2088 * y\u2082) ^ 2 +\n      (x\u2081 * y\u2088 - x\u2082 * y\u2087 + x\u2083 * y\u2086 + x\u2084 * y\u2085 - x\u2085 * y\u2084 - x\u2086 * y\u2083 + x\u2087 * y\u2082 + x\u2088 * y\u2081) ^ 2", "start": [63, 1], "end": [78, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PFunctor/Multivariate/M.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "Mathlib/Data/PFunctor/Univariate/M.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPFunctor.M.Path", "code": "inductive M.Path : P.last.M \u2192 Fin2 n \u2192 Type u\n  | root  (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a \u2192 P.last.M)\n          (h : PFunctor.M.dest x = \u27e8a, f\u27e9)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a \u2192 P.last.M)\n          (h : PFunctor.M.dest x = \u27e8a, f\u27e9)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i", "start": [62, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.Path.inhabited", "code": "instance M.Path.inhabited (x : P.last.M) {i} [Inhabited (P.drop.B x.head i)] :\n    Inhabited (M.Path P x i) :=\n  let a := PFunctor.M.head x\n  let f := PFunctor.M.children x\n  \u27e8M.Path.root _ a f\n      (PFunctor.M.casesOn' x\n        (r := fun _ => PFunctor.M.dest x = \u27e8a, f\u27e9)\n        <| by\n        intros; simp [PFunctor.M.dest_mk, PFunctor.M.children_mk]; rfl)\n      _ default\u27e9", "start": [79, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.mp", "code": "def mp : MvPFunctor n where\n  A := P.last.M\n  B := M.Path P", "start": [91, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M", "code": "def M (\u03b1 : TypeVec n) : Type _ :=\n  P.mp \u03b1", "start": [100, 1], "end": [102, 9], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.mvfunctorM", "code": "instance mvfunctorM : MvFunctor P.M := by delta M; infer_instance", "start": [105, 1], "end": [105, 66], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.inhabitedM", "code": "instance inhabitedM {\u03b1 : TypeVec _} [I : Inhabited P.A] [\u2200 i : Fin2 n, Inhabited (\u03b1 i)] :\n    Inhabited (P.M \u03b1) :=\n  @Obj.inhabited _ (mp P) _ (@PFunctor.M.inhabited P.last I) _", "start": [108, 1], "end": [110, 63], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.corecShape", "code": "def M.corecShape {\u03b2 : Type u} (g\u2080 : \u03b2 \u2192 P.A) (g\u2082 : \u2200 b : \u03b2, P.last.B (g\u2080 b) \u2192 \u03b2) :\n    \u03b2 \u2192 P.last.M :=\n  PFunctor.M.corec fun b => \u27e8g\u2080 b, g\u2082 b\u27e9", "start": [113, 1], "end": [117, 41], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.castDropB", "code": "def castDropB {a a' : P.A} (h : a = a') : P.drop.B a \u27f9 P.drop.B a' := fun _i b => Eq.recOn h b", "start": [120, 1], "end": [121, 95], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.castLastB", "code": "def castLastB {a a' : P.A} (h : a = a') : P.last.B a \u2192 P.last.B a' := fun b => Eq.recOn h b", "start": [124, 1], "end": [125, 92], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.corecContents", "code": "def M.corecContents {\u03b1 : TypeVec.{u} n}\n    {\u03b2 : Type u}\n    (g\u2080 : \u03b2 \u2192 P.A)\n    (g\u2081 : \u2200 b : \u03b2, P.drop.B (g\u2080 b) \u27f9 \u03b1)\n    (g\u2082 : \u2200 b : \u03b2, P.last.B (g\u2080 b) \u2192 \u03b2)\n    (x : _)\n    (b : \u03b2)\n    (h: x = M.corecShape P g\u2080 g\u2082 b) :\n    M.Path P x \u27f9 \u03b1\n  | _, M.Path.root x a f h' i c =>\n    have : a = g\u2080 b := by\n      rw [h, M.corecShape, PFunctor.M.dest_corec] at h'\n      cases h'\n      rfl\n    g\u2081 b i (P.castDropB this i c)\n  | _, M.Path.child x a f h' j i c =>\n    have h\u2080 : a = g\u2080 b := by\n      rw [h, M.corecShape, PFunctor.M.dest_corec] at h'\n      cases h'\n      rfl\n    have h\u2081 : f j = M.corecShape P g\u2080 g\u2082 (g\u2082 b (castLastB P h\u2080 j)) := by\n      rw [h, M.corecShape, PFunctor.M.dest_corec] at h'\n      cases h'\n      rfl\n    M.corecContents g\u2080 g\u2081 g\u2082 (f j) (g\u2082 b (P.castLastB h\u2080 j)) h\u2081 i c", "start": [128, 1], "end": [153, 68], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.corec'", "code": "def M.corec' {\u03b1 : TypeVec n} {\u03b2 : Type u} (g\u2080 : \u03b2 \u2192 P.A) (g\u2081 : \u2200 b : \u03b2, P.drop.B (g\u2080 b) \u27f9 \u03b1)\n    (g\u2082 : \u2200 b : \u03b2, P.last.B (g\u2080 b) \u2192 \u03b2) : \u03b2 \u2192 P.M \u03b1 := fun b =>\n  \u27e8M.corecShape P g\u2080 g\u2082 b, M.corecContents P g\u2080 g\u2081 g\u2082 _ _ rfl\u27e9", "start": [156, 1], "end": [159, 63], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.corec", "code": "def M.corec {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 P (\u03b1.append1 \u03b2)) : \u03b2 \u2192 P.M \u03b1 :=\n  M.corec' P (fun b => (g b).fst) (fun b => dropFun (g b).snd) fun b => lastFun (g b).snd", "start": [162, 1], "end": [164, 90], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.pathDestLeft", "code": "def M.pathDestLeft {\u03b1 : TypeVec n} {x : P.last.M} {a : P.A} {f : P.last.B a \u2192 P.last.M}\n    (h : PFunctor.M.dest x = \u27e8a, f\u27e9) (f' : M.Path P x \u27f9 \u03b1) : P.drop.B a \u27f9 \u03b1 := fun i c =>\n  f' i (M.Path.root x a f h i c)", "start": [167, 1], "end": [170, 33], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.pathDestRight", "code": "def M.pathDestRight {\u03b1 : TypeVec n} {x : P.last.M} {a : P.A} {f : P.last.B a \u2192 P.last.M}\n    (h : PFunctor.M.dest x = \u27e8a, f\u27e9) (f' : M.Path P x \u27f9 \u03b1) :\n    \u2200 j : P.last.B a, M.Path P (f j) \u27f9 \u03b1 := fun j i c => f' i (M.Path.child x a f h j i c)", "start": [173, 1], "end": [176, 91], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest'", "code": "def M.dest' {\u03b1 : TypeVec n} {x : P.last.M} {a : P.A} {f : P.last.B a \u2192 P.last.M}\n    (h : PFunctor.M.dest x = \u27e8a, f\u27e9) (f' : M.Path P x \u27f9 \u03b1) : P (\u03b1.append1 (P.M \u03b1)) :=\n  \u27e8a, splitFun (M.pathDestLeft P h f') fun x => \u27e8f x, M.pathDestRight P h f' x\u27e9\u27e9", "start": [179, 1], "end": [182, 81], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest", "code": "def M.dest {\u03b1 : TypeVec n} (x : P.M \u03b1) : P (\u03b1 ::: P.M \u03b1) :=\n  M.dest' P (Sigma.eta <| PFunctor.M.dest x.fst).symm x.snd", "start": [185, 1], "end": [187, 60], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.mk", "code": "def M.mk {\u03b1 : TypeVec n} : P (\u03b1.append1 (P.M \u03b1)) \u2192 P.M \u03b1 :=\n  M.corec _ fun i => appendFun id (M.dest P) <$$> i", "start": [190, 1], "end": [192, 52], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest'_eq_dest'", "code": "theorem M.dest'_eq_dest' {\u03b1 : TypeVec n} {x : P.last.M} {a\u2081 : P.A}\n    {f\u2081 : P.last.B a\u2081 \u2192 P.last.M} (h\u2081 : PFunctor.M.dest x = \u27e8a\u2081, f\u2081\u27e9) {a\u2082 : P.A}\n    {f\u2082 : P.last.B a\u2082 \u2192 P.last.M} (h\u2082 : PFunctor.M.dest x = \u27e8a\u2082, f\u2082\u27e9) (f' : M.Path P x \u27f9 \u03b1) :\n    M.dest' P h\u2081 f' = M.dest' P h\u2082 f'", "start": [195, 1], "end": [198, 72], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest_eq_dest'", "code": "theorem M.dest_eq_dest' {\u03b1 : TypeVec n} {x : P.last.M} {a : P.A}\n    {f : P.last.B a \u2192 P.last.M} (h : PFunctor.M.dest x = \u27e8a, f\u27e9) (f' : M.Path P x \u27f9 \u03b1) :\n    M.dest P \u27e8x, f'\u27e9 = M.dest' P h f'", "start": [201, 1], "end": [204, 27], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest_corec'", "code": "theorem M.dest_corec' {\u03b1 : TypeVec.{u} n} {\u03b2 : Type u} (g\u2080 : \u03b2 \u2192 P.A)\n    (g\u2081 : \u2200 b : \u03b2, P.drop.B (g\u2080 b) \u27f9 \u03b1) (g\u2082 : \u2200 b : \u03b2, P.last.B (g\u2080 b) \u2192 \u03b2) (x : \u03b2) :\n    M.dest P (M.corec' P g\u2080 g\u2081 g\u2082 x) = \u27e8g\u2080 x, splitFun (g\u2081 x) (M.corec' P g\u2080 g\u2081 g\u2082 \u2218 g\u2082 x)\u27e9", "start": [207, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest_corec", "code": "theorem M.dest_corec {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : \u03b2 \u2192 P (\u03b1.append1 \u03b2)) (x : \u03b2) :\n    M.dest P (M.corec P g x) = appendFun id (M.corec P g) <$$> g x", "start": [213, 1], "end": [221, 60], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.bisim_lemma", "code": "theorem M.bisim_lemma {\u03b1 : TypeVec n} {a\u2081 : (mp P).A} {f\u2081 : (mp P).B a\u2081 \u27f9 \u03b1} {a' : P.A}\n    {f' : (P.B a').drop \u27f9 \u03b1} {f\u2081' : (P.B a').last \u2192 M P \u03b1}\n    (e\u2081 : M.dest P \u27e8a\u2081, f\u2081\u27e9 = \u27e8a', splitFun f' f\u2081'\u27e9) :\n    \u2203 (g\u2081' : _)(e\u2081' : PFunctor.M.dest a\u2081 = \u27e8a', g\u2081'\u27e9),\n      f' = M.pathDestLeft P e\u2081' f\u2081 \u2227\n        f\u2081' = fun x : (last P).B a' => \u27e8g\u2081' x, M.pathDestRight P e\u2081' f\u2081 x\u27e9", "start": [224, 1], "end": [234, 44], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.bisim", "code": "theorem M.bisim {\u03b1 : TypeVec n} (R : P.M \u03b1 \u2192 P.M \u03b1 \u2192 Prop)\n    (h :\n      \u2200 x y,\n        R x y \u2192\n          \u2203 a f f\u2081 f\u2082,\n            M.dest P x = \u27e8a, splitFun f f\u2081\u27e9 \u2227\n              M.dest P y = \u27e8a, splitFun f f\u2082\u27e9 \u2227 \u2200 i, R (f\u2081 i) (f\u2082 i))\n    (x y) (r : R x y) : x = y", "start": [237, 1], "end": [268, 25], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.bisim\u2080", "code": "theorem M.bisim\u2080 {\u03b1 : TypeVec n} (R : P.M \u03b1 \u2192 P.M \u03b1 \u2192 Prop) (h\u2080 : Equivalence R)\n    (h : \u2200 x y, R x y \u2192 (id ::: Quot.mk R) <$$> M.dest _ x = (id ::: Quot.mk R) <$$> M.dest _ y)\n    (x y) (r : R x y) : x = y", "start": [271, 1], "end": [300, 11], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.bisim'", "code": "theorem M.bisim' {\u03b1 : TypeVec n} (R : P.M \u03b1 \u2192 P.M \u03b1 \u2192 Prop)\n    (h : \u2200 x y, R x y \u2192 (id ::: Quot.mk R) <$$> M.dest _ x = (id ::: Quot.mk R) <$$> M.dest _ y)\n    (x y) (r : R x y) : x = y", "start": [303, 1], "end": [316, 20], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.dest_map", "code": "theorem M.dest_map {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (x : P.M \u03b1) :\n    M.dest P (g <$$> x) = (appendFun g fun x => g <$$> x) <$$> M.dest P x", "start": [319, 1], "end": [325, 58], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.M.map_dest", "code": "theorem M.map_dest {\u03b1 \u03b2 : TypeVec n} (g : (\u03b1 ::: P.M \u03b1) \u27f9 (\u03b2 ::: P.M \u03b2)) (x : P.M \u03b1)\n    (h : \u2200 x : P.M \u03b1, lastFun g x = (dropFun g <$$> x : P.M \u03b2)) :\n    g <$$> M.dest P x = M.dest P (dropFun g <$$> x)", "start": [328, 1], "end": [333, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/InjectiveResolution.lean", "imports": ["Mathlib/Algebra/Homology/HomotopyCategory.lean", "Mathlib/Algebra/Homology/QuasiIso.lean", "Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.InjectiveResolution.descFZero", "code": "def descFZero {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.cocomplex.X 0 \u27f6 I.cocomplex.X 0 :=\n  factorThru (f \u226b I.\u03b9.f 0) (J.\u03b9.f 0)", "start": [53, 1], "end": [56, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descFOne", "code": "def descFOne {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.cocomplex.X 1 \u27f6 I.cocomplex.X 1 :=\n  Exact.desc (descFZero f I J \u226b I.cocomplex.d 0 1) (J.\u03b9.f 0) (J.cocomplex.d 0 1)\n    (Abelian.Exact.op _ _ J.exact\u2080) (by simp [\u2190 Category.assoc, descFZero])", "start": [65, 1], "end": [69, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descFOne_zero_comm", "code": "@[simp]\ntheorem descFOne_zero_comm {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) :\n    J.cocomplex.d 0 1 \u226b descFOne f I J = descFZero f I J \u226b I.cocomplex.d 0 1", "start": [72, 1], "end": [76, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descFSucc", "code": "def descFSucc {Y Z : C} (I : InjectiveResolution Y) (J : InjectiveResolution Z) (n : \u2115)\n    (g : J.cocomplex.X n \u27f6 I.cocomplex.X n) (g' : J.cocomplex.X (n + 1) \u27f6 I.cocomplex.X (n + 1))\n    (w : J.cocomplex.d n (n + 1) \u226b g' = g \u226b I.cocomplex.d n (n + 1)) :\n    \u03a3'g'' : J.cocomplex.X (n + 2) \u27f6 I.cocomplex.X (n + 2),\n      J.cocomplex.d (n + 1) (n + 2) \u226b g'' = g' \u226b I.cocomplex.d (n + 1) (n + 2) :=\n  \u27e8@Exact.desc C _ _ _ _ _ _ _ _ _ (g' \u226b I.cocomplex.d (n + 1) (n + 2)) (J.cocomplex.d n (n + 1))\n      (J.cocomplex.d (n + 1) (n + 2)) (Abelian.Exact.op _ _ (J.exact _))\n      (by simp [\u2190 Category.assoc, w]),\n    by simp\u27e9", "start": [79, 1], "end": [88, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.desc", "code": "def desc {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y) (J : InjectiveResolution Z) :\n    J.cocomplex \u27f6 I.cocomplex :=\n  CochainComplex.mkHom _ _ (descFZero f _ _) (descFOne f _ _) (descFOne_zero_comm f I J).symm\n    fun n \u27e8g, g', w\u27e9 => \u27e8(descFSucc I J n g g' w.symm).1, (descFSucc I J n g g' w.symm).2.symm\u27e9", "start": [91, 1], "end": [95, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.desc_commutes", "code": "@[reassoc (attr := simp)]\ntheorem desc_commutes {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y)\n    (J : InjectiveResolution Z) : J.\u03b9 \u226b desc f I J = (CochainComplex.single\u2080 C).map f \u226b I.\u03b9", "start": [98, 1], "end": [103, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descHomotopyZeroZero", "code": "def descHomotopyZeroZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex \u27f6 J.cocomplex) (comm : I.\u03b9 \u226b f = 0) : I.cocomplex.X 1 \u27f6 J.cocomplex.X 0 :=\n  Exact.desc (f.f 0) (I.\u03b9.f 0) (I.cocomplex.d 0 1) (Abelian.Exact.op _ _ I.exact\u2080)\n    (congr_fun (congr_arg HomologicalComplex.Hom.f comm) 0)", "start": [107, 1], "end": [111, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descHomotopyZeroOne", "code": "def descHomotopyZeroOne {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex \u27f6 J.cocomplex) (comm : I.\u03b9 \u226b f = (0 : _ \u27f6 J.cocomplex)) :\n    I.cocomplex.X 2 \u27f6 J.cocomplex.X 1 :=\n  Exact.desc (f.f 1 - descHomotopyZeroZero f comm \u226b J.cocomplex.d 0 1) (I.cocomplex.d 0 1)\n    (I.cocomplex.d 1 2) (Abelian.Exact.op _ _ (I.exact _))\n    (by simp [descHomotopyZeroZero, \u2190 Category.assoc])", "start": [114, 1], "end": [120, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descHomotopyZeroSucc", "code": "def descHomotopyZeroSucc {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex \u27f6 J.cocomplex) (n : \u2115) (g : I.cocomplex.X (n + 1) \u27f6 J.cocomplex.X n)\n    (g' : I.cocomplex.X (n + 2) \u27f6 J.cocomplex.X (n + 1))\n    (w : f.f (n + 1) = I.cocomplex.d (n + 1) (n + 2) \u226b g' + g \u226b J.cocomplex.d n (n + 1)) :\n    I.cocomplex.X (n + 3) \u27f6 J.cocomplex.X (n + 2) :=\n  Exact.desc (f.f (n + 2) - g' \u226b J.cocomplex.d _ _) (I.cocomplex.d (n + 1) (n + 2))\n    (I.cocomplex.d (n + 2) (n + 3)) (Abelian.Exact.op _ _ (I.exact _))\n    (by\n      simp [Preadditive.comp_sub, \u2190 Category.assoc, Preadditive.sub_comp,\n        show I.cocomplex.d (n + 1) (n + 2) \u226b g' = f.f (n + 1) - g \u226b J.cocomplex.d n (n + 1) by\n          rw [w]\n          simp only [add_sub_cancel]])", "start": [123, 1], "end": [135, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descHomotopyZero", "code": "def descHomotopyZero {Y Z : C} {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (f : I.cocomplex \u27f6 J.cocomplex) (comm : I.\u03b9 \u226b f = 0) : Homotopy f 0 :=\n  Homotopy.mkCoinductive _ (descHomotopyZeroZero f comm) (by simp [descHomotopyZeroZero])\n    (descHomotopyZeroOne f comm) (by simp [descHomotopyZeroOne]) fun n \u27e8g, g', w\u27e9 =>\n    \u27e8descHomotopyZeroSucc f n g g' (by simp only [w, add_comm]), by simp [descHomotopyZeroSucc, w]\u27e9", "start": [138, 1], "end": [143, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descHomotopy", "code": "def descHomotopy {Y Z : C} (f : Y \u27f6 Z) {I : InjectiveResolution Y} {J : InjectiveResolution Z}\n    (g h : I.cocomplex \u27f6 J.cocomplex) (g_comm : I.\u03b9 \u226b g = (CochainComplex.single\u2080 C).map f \u226b J.\u03b9)\n    (h_comm : I.\u03b9 \u226b h = (CochainComplex.single\u2080 C).map f \u226b J.\u03b9) : Homotopy g h :=\n  Homotopy.equivSubZero.invFun (descHomotopyZero _ (by simp [g_comm, h_comm]))", "start": [146, 1], "end": [150, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descIdHomotopy", "code": "def descIdHomotopy (X : C) (I : InjectiveResolution X) :\n    Homotopy (desc (\ud835\udfd9 X) I I) (\ud835\udfd9 I.cocomplex) := by\n  apply descHomotopy (\ud835\udfd9 X) <;> simp", "start": [153, 1], "end": [156, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.descCompHomotopy", "code": "def descCompHomotopy {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) (I : InjectiveResolution X)\n    (J : InjectiveResolution Y) (K : InjectiveResolution Z) :\n    Homotopy (desc (f \u226b g) K I) (desc f J I \u226b desc g K J) := by\n  apply descHomotopy (f \u226b g) <;> simp", "start": [159, 1], "end": [163, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.homotopyEquiv", "code": "def homotopyEquiv {X : C} (I J : InjectiveResolution X) :\n    HomotopyEquiv I.cocomplex J.cocomplex where\n  hom := desc (\ud835\udfd9 X) J I\n  inv := desc (\ud835\udfd9 X) I J\n  homotopyHomInvId := (descCompHomotopy (\ud835\udfd9 X) (\ud835\udfd9 X) I J I).symm.trans <| by\n    simpa [Category.id_comp] using descIdHomotopy _ _\n  homotopyInvHomId := (descCompHomotopy (\ud835\udfd9 X) (\ud835\udfd9 X) J I J).symm.trans <| by\n    simpa [Category.id_comp] using descIdHomotopy _ _", "start": [167, 1], "end": [175, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.homotopyEquiv_hom_\u03b9", "code": "@[reassoc (attr := simp)] theorem homotopyEquiv_hom_\u03b9 {X : C} (I J : InjectiveResolution X) :\n    I.\u03b9 \u226b (homotopyEquiv I J).hom = J.\u03b9", "start": [178, 1], "end": [180, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.homotopyEquiv_inv_\u03b9", "code": "@[reassoc (attr := simp)] theorem homotopyEquiv_inv_\u03b9 {X : C} (I J : InjectiveResolution X) :\n    J.\u03b9 \u226b (homotopyEquiv I J).inv = I.\u03b9", "start": [183, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injectiveResolution", "code": "abbrev injectiveResolution (Z : C) [HasInjectiveResolution Z] : CochainComplex C \u2115 :=\n  (HasInjectiveResolution.out (Z := Z)).some.cocomplex", "start": [196, 1], "end": [198, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injectiveResolution.\u03b9", "code": "abbrev injectiveResolution.\u03b9 (Z : C) [HasInjectiveResolution Z] :\n    (CochainComplex.single\u2080 C).obj Z \u27f6 injectiveResolution Z :=\n  (HasInjectiveResolution.out (Z := Z)).some.\u03b9", "start": [201, 1], "end": [205, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injectiveResolution.desc", "code": "abbrev injectiveResolution.desc {X Y : C} (f : X \u27f6 Y) [HasInjectiveResolution X]\n    [HasInjectiveResolution Y] : injectiveResolution X \u27f6 injectiveResolution Y :=\n  InjectiveResolution.desc f _ _", "start": [208, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injectiveResolutions", "code": "def injectiveResolutions : C \u2964 HomotopyCategory C (ComplexShape.up \u2115) where\n  obj X := (HomotopyCategory.quotient _ _).obj (injectiveResolution X)\n  map f := (HomotopyCategory.quotient _ _).map (injectiveResolution.desc f)\n  map_id X := by\n    rw [\u2190 (HomotopyCategory.quotient _ _).map_id]\n    apply HomotopyCategory.eq_of_homotopy\n    apply InjectiveResolution.descIdHomotopy\n  map_comp f g := by\n    rw [\u2190 (HomotopyCategory.quotient _ _).map_comp]\n    apply HomotopyCategory.eq_of_homotopy\n    apply InjectiveResolution.descCompHomotopy", "start": [218, 1], "end": [232, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exact_f_d", "code": "theorem exact_f_d {X Y : C} (f : X \u27f6 Y) : Exact f (d f)", "start": [241, 1], "end": [243, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.ofCocomplex", "code": "@[simps!]\ndef ofCocomplex (Z : C) : CochainComplex C \u2115 :=\n  CochainComplex.mk' (Injective.under Z) (Injective.syzygies (Injective.\u03b9 Z))\n    (Injective.d (Injective.\u03b9 Z)) fun \u27e8_, _, f\u27e9 =>\n    \u27e8Injective.syzygies f, Injective.d f, (exact_f_d f).w\u27e9", "start": [262, 1], "end": [267, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.ofCocomplex_sq_01_comm", "code": "theorem ofCocomplex_sq_01_comm (Z : C) :\n    Injective.\u03b9 Z \u226b HomologicalComplex.d (ofCocomplex Z) 0 1 =\n    HomologicalComplex.d ((CochainComplex.single\u2080 C).obj Z) 0 1 \u226b 0", "start": [274, 1], "end": [279, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.exact_ofCocomplex", "code": "theorem exact_ofCocomplex (Z : C) (n : \u2115) :\n    Exact (HomologicalComplex.d (ofCocomplex Z) n (n + 1))\n    (HomologicalComplex.d (ofCocomplex Z) (n + 1) (n + 2))", "start": [283, 1], "end": [293, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.of", "code": "irreducible_def of (Z : C) : InjectiveResolution Z :=\n  { cocomplex := ofCocomplex Z\n    \u03b9 :=\n      CochainComplex.mkHom\n        ((CochainComplex.single\u2080 C).obj Z) (ofCocomplex Z) (Injective.\u03b9 Z) 0\n          (ofCocomplex_sq_01_comm Z) fun n _ => by\n          use 0\n            apply HasZeroObject.from_zero_ext\n    injective := by rintro (_ | _ | _ | n) <;> \u00b7 apply Injective.injective_under\n    exact\u2080 := by simpa using exact_f_d (Injective.\u03b9 Z)\n    exact := exact_ofCocomplex Z\n    mono := Injective.\u03b9_mono Z }", "start": [297, 1], "end": [312, 33], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "HomologicalComplex.Hom.HomologicalComplex.Hom.fromSingle\u2080InjectiveResolution", "code": "def HomologicalComplex.Hom.fromSingle\u2080InjectiveResolution (X : CochainComplex C \u2115) (Y : C)\n    (f : (CochainComplex.single\u2080 C).obj Y \u27f6 X) [QuasiIso f] (H : \u2200 n, Injective (X.X n)) :\n    InjectiveResolution Y where\n  cocomplex := X\n  \u03b9 := f\n  injective := H\n  exact\u2080 := from_single\u2080_exact_f_d_at_zero f\n  exact := from_single\u2080_exact_at_succ f\n  mono := from_single\u2080_mono_at_zero f", "start": [329, 1], "end": [339, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/Sort.lean", "imports": ["Mathlib/Data/Fin/Interval.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Prod/Lex.lean", "Mathlib/Data/List/FinRange.lean", "Mathlib/GroupTheory/Perm/Basic.lean"], "premises": [{"full_name": "Tuple.graph", "code": "def graph (f : Fin n \u2192 \u03b1) : Finset (\u03b1 \u00d7\u2097 Fin n) :=\n  Finset.univ.image fun i => (f i, i)", "start": [37, 1], "end": [41, 38], "kind": "commanddeclaration"}, {"full_name": "Tuple.graph.proj", "code": "def graph.proj {f : Fin n \u2192 \u03b1} : graph f \u2192 \u03b1 := fun p => p.1.1", "start": [44, 1], "end": [47, 63], "kind": "commanddeclaration"}, {"full_name": "Tuple.graph.card", "code": "@[simp]\ntheorem graph.card (f : Fin n \u2192 \u03b1) : (graph f).card = n", "start": [50, 1], "end": [58, 9], "kind": "commanddeclaration"}, {"full_name": "Tuple.graphEquiv\u2081", "code": "def graphEquiv\u2081 (f : Fin n \u2192 \u03b1) : Fin n \u2243 graph f where\n  toFun i := \u27e8(f i, i), by simp [graph]\u27e9\n  invFun p := p.1.2\n  left_inv i := by simp\n  right_inv := fun \u27e8\u27e8x, i\u27e9, h\u27e9 => by\n    simp only [graph, Finset.mem_image, Finset.mem_univ, true_and] at h\n    obtain \u27e8i', hi'\u27e9 := h\n    obtain \u27e8-, rfl\u27e9 := Prod.mk.inj_iff.mp hi'\n    simpa", "start": [61, 1], "end": [72, 10], "kind": "commanddeclaration"}, {"full_name": "Tuple.proj_equiv\u2081'", "code": "@[simp]\ntheorem proj_equiv\u2081' (f : Fin n \u2192 \u03b1) : graph.proj \u2218 graphEquiv\u2081 f = f", "start": [75, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "Tuple.graphEquiv\u2082", "code": "def graphEquiv\u2082 (f : Fin n \u2192 \u03b1) : Fin n \u2243o graph f :=\n  Finset.orderIsoOfFin _ (by simp)", "start": [80, 1], "end": [83, 35], "kind": "commanddeclaration"}, {"full_name": "Tuple.sort", "code": "def sort (f : Fin n \u2192 \u03b1) : Equiv.Perm (Fin n) :=\n  (graphEquiv\u2082 f).toEquiv.trans (graphEquiv\u2081 f).symm", "start": [86, 1], "end": [88, 53], "kind": "commanddeclaration"}, {"full_name": "Tuple.graphEquiv\u2082_apply", "code": "theorem graphEquiv\u2082_apply (f : Fin n \u2192 \u03b1) (i : Fin n) :\n    graphEquiv\u2082 f i = graphEquiv\u2081 f (sort f i)", "start": [91, 1], "end": [93, 44], "kind": "commanddeclaration"}, {"full_name": "Tuple.self_comp_sort", "code": "theorem self_comp_sort (f : Fin n \u2192 \u03b1) : f \u2218 sort f = graph.proj \u2218 graphEquiv\u2082 f", "start": [96, 1], "end": [97, 97], "kind": "commanddeclaration"}, {"full_name": "Tuple.monotone_proj", "code": "theorem monotone_proj (f : Fin n \u2192 \u03b1) : Monotone (graph.proj : graph f \u2192 \u03b1)", "start": [100, 1], "end": [103, 22], "kind": "commanddeclaration"}, {"full_name": "Tuple.monotone_sort", "code": "theorem monotone_sort (f : Fin n \u2192 \u03b1) : Monotone (f \u2218 sort f)", "start": [106, 1], "end": [108, 56], "kind": "commanddeclaration"}, {"full_name": "Tuple.lt_card_le_iff_apply_le_of_monotone", "code": "theorem lt_card_le_iff_apply_le_of_monotone [PartialOrder \u03b1] [DecidableRel (\u03b1 := \u03b1) LE.le]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i \u2264 a} \u2194 f j \u2264 a", "start": [119, 1], "end": [146, 48], "kind": "commanddeclaration"}, {"full_name": "Tuple.lt_card_ge_iff_apply_ge_of_antitone", "code": "theorem lt_card_ge_iff_apply_ge_of_antitone [PartialOrder \u03b1] [DecidableRel (\u03b1 := \u03b1) LE.le]\n    {m : \u2115} (f : Fin m \u2192 \u03b1) (a : \u03b1) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a \u2264 f i} \u2194 a \u2264 f j", "start": [148, 1], "end": [151, 83], "kind": "commanddeclaration"}, {"full_name": "Tuple.unique_monotone", "code": "theorem unique_monotone [PartialOrder \u03b1] {f : Fin n \u2192 \u03b1} {\u03c3 \u03c4 : Equiv.Perm (Fin n)}\n    (hf\u03c3 : Monotone (f \u2218 \u03c3)) (hf\u03c4 : Monotone (f \u2218 \u03c4)) : f \u2218 \u03c3 = f \u2218 \u03c4", "start": [153, 1], "end": [158, 38], "kind": "commanddeclaration"}, {"full_name": "Tuple.eq_sort_iff'", "code": "theorem eq_sort_iff' : \u03c3 = sort f \u2194 StrictMono (\u03c3.trans <| graphEquiv\u2081 f)", "start": [163, 1], "end": [171, 87], "kind": "commanddeclaration"}, {"full_name": "Tuple.eq_sort_iff", "code": "theorem eq_sort_iff :\n    \u03c3 = sort f \u2194 Monotone (f \u2218 \u03c3) \u2227 \u2200 i j, i < j \u2192 f (\u03c3 i) = f (\u03c3 j) \u2192 \u03c3 i < \u03c3 j", "start": [174, 1], "end": [183, 52], "kind": "commanddeclaration"}, {"full_name": "Tuple.sort_eq_refl_iff_monotone", "code": "theorem sort_eq_refl_iff_monotone : sort f = Equiv.refl _ \u2194 Monotone f", "start": [186, 1], "end": [190, 31], "kind": "commanddeclaration"}, {"full_name": "Tuple.comp_sort_eq_comp_iff_monotone", "code": "theorem comp_sort_eq_comp_iff_monotone : f \u2218 \u03c3 = f \u2218 sort f \u2194 Monotone (f \u2218 \u03c3)", "start": [193, 1], "end": [195, 84], "kind": "commanddeclaration"}, {"full_name": "Tuple.comp_perm_comp_sort_eq_comp_sort", "code": "theorem comp_perm_comp_sort_eq_comp_sort : (f \u2218 \u03c3) \u2218 sort (f \u2218 \u03c3) = f \u2218 sort f", "start": [198, 1], "end": [201, 66], "kind": "commanddeclaration"}, {"full_name": "Tuple.antitone_pair_of_not_sorted'", "code": "theorem antitone_pair_of_not_sorted' (h : f \u2218 \u03c3 \u2260 f \u2218 sort f) :\n    \u2203 i j, i < j \u2227 (f \u2218 \u03c3) j < (f \u2218 \u03c3) i", "start": [204, 1], "end": [209, 74], "kind": "commanddeclaration"}, {"full_name": "Tuple.antitone_pair_of_not_sorted", "code": "theorem antitone_pair_of_not_sorted (h : f \u2260 f \u2218 sort f) : \u2203 i j, i < j \u2227 f j < f i", "start": [212, 1], "end": [215, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/LinearRecurrence.lean", "imports": ["Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/Data/Polynomial/Eval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearRecurrence", "code": "structure LinearRecurrence (\u03b1 : Type*) [CommSemiring \u03b1] where\n  order : \u2115\n  coeffs : Fin order \u2192 \u03b1", "start": [47, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.IsSolution", "code": "def IsSolution (u : \u2115 \u2192 \u03b1) :=\n  \u2200 n, u (n + E.order) = \u2211 i, E.coeffs i * u (n + i)", "start": [63, 1], "end": [66, 53], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.mkSol", "code": "def mkSol (init : Fin E.order \u2192 \u03b1) : \u2115 \u2192 \u03b1\n  | n =>\n    if h : n < E.order then init \u27e8n, h\u27e9\n    else\n      \u2211 k : Fin E.order,\n        have _ : n - E.order + k < n := by\n          rw [add_comm, \u2190 add_tsub_assoc_of_le (not_lt.mp h), tsub_lt_iff_left]\n          \u00b7 exact add_lt_add_right k.is_lt n\n          \u00b7 convert add_le_add (zero_le (k : \u2115)) (not_lt.mp h)\n            simp only [zero_add]\n        E.coeffs k * mkSol init (n - E.order + k)", "start": [69, 1], "end": [81, 50], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.is_sol_mkSol", "code": "theorem is_sol_mkSol (init : Fin E.order \u2192 \u03b1) : E.IsSolution (E.mkSol init)", "start": [84, 1], "end": [88, 7], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.mkSol_eq_init", "code": "theorem mkSol_eq_init (init : Fin E.order \u2192 \u03b1) : \u2200 n : Fin E.order, E.mkSol init n = init n", "start": [91, 1], "end": [95, 52], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.eq_mk_of_is_sol_of_eq_init", "code": "theorem eq_mk_of_is_sol_of_eq_init {u : \u2115 \u2192 \u03b1} {init : Fin E.order \u2192 \u03b1} (h : E.IsSolution u)\n    (heq : \u2200 n : Fin E.order, u n = init n) : \u2200 n, u n = E.mkSol init n", "start": [98, 1], "end": [115, 7], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.eq_mk_of_is_sol_of_eq_init'", "code": "theorem eq_mk_of_is_sol_of_eq_init' {u : \u2115 \u2192 \u03b1} {init : Fin E.order \u2192 \u03b1} (h : E.IsSolution u)\n    (heq : \u2200 n : Fin E.order, u n = init n) : u = E.mkSol init", "start": [118, 1], "end": [123, 46], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.solSpace", "code": "def solSpace : Submodule \u03b1 (\u2115 \u2192 \u03b1) where\n  carrier := { u | E.IsSolution u }\n  zero_mem' n := by simp\n  add_mem' {u v} hu hv n := by simp [mul_add, sum_add_distrib, hu n, hv n]\n  smul_mem' a u hu n := by simp [hu n, mul_sum]; congr; ext; ac_rfl", "start": [126, 1], "end": [131, 68], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.is_sol_iff_mem_solSpace", "code": "theorem is_sol_iff_mem_solSpace (u : \u2115 \u2192 \u03b1) : E.IsSolution u \u2194 u \u2208 E.solSpace", "start": [134, 1], "end": [137, 10], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.toInit", "code": "def toInit : E.solSpace \u2243\u2097[\u03b1] Fin E.order \u2192 \u03b1 where\n  toFun u x := (u : \u2115 \u2192 \u03b1) x\n  map_add' u v := by\n    ext\n    simp\n  map_smul' a u := by\n    ext\n    simp\n  invFun u := \u27e8E.mkSol u, E.is_sol_mkSol u\u27e9\n  left_inv u := by ext n; symm; apply E.eq_mk_of_is_sol_of_eq_init u.2; intro k; rfl\n  right_inv u := Function.funext_iff.mpr fun n \u21a6 E.mkSol_eq_init u n", "start": [140, 1], "end": [152, 69], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.sol_eq_of_eq_init", "code": "theorem sol_eq_of_eq_init (u v : \u2115 \u2192 \u03b1) (hu : E.IsSolution u) (hv : E.IsSolution v) :\n    u = v \u2194 Set.EqOn u v \u2191(range E.order)", "start": [155, 1], "end": [166, 39], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.tupleSucc", "code": "def tupleSucc : (Fin E.order \u2192 \u03b1) \u2192\u2097[\u03b1] Fin E.order \u2192 \u03b1 where\n  toFun X i := if h : (i : \u2115) + 1 < E.order then X \u27e8i + 1, h\u27e9 else \u2211 i, E.coeffs i * X i\n  map_add' x y := by\n    ext i\n    simp only\n    split_ifs with h <;> simp [h, mul_add, sum_add_distrib]\n  map_smul' x y := by\n    ext i\n    simp only\n    split_ifs with h <;> simp [h, mul_sum]\n    exact sum_congr rfl fun x _ \u21a6 by ac_rfl", "start": [174, 1], "end": [186, 44], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.solSpace_rank", "code": "theorem solSpace_rank : Module.rank \u03b1 E.solSpace = E.order", "start": [197, 1], "end": [200, 49], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.charPoly", "code": "def charPoly : \u03b1[X] :=\n  Polynomial.monomial E.order 1 - \u2211 i : Fin E.order, Polynomial.monomial i (E.coeffs i)", "start": [209, 1], "end": [212, 88], "kind": "commanddeclaration"}, {"full_name": "LinearRecurrence.geom_sol_iff_root_charPoly", "code": "theorem geom_sol_iff_root_charPoly (q : \u03b1) :\n    (E.IsSolution fun n \u21a6 q ^ n) \u2194 E.charPoly.IsRoot q", "start": [215, 1], "end": [227, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sigma/Basic.lean", "imports": ["Mathlib/CategoryTheory/NatIso.lean", "Mathlib/CategoryTheory/Whiskering.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Sigma.SigmaHom", "code": "inductive SigmaHom : (\u03a3i, C i) \u2192 (\u03a3i, C i) \u2192 Type max w\u2081 v\u2081 u\u2081\n  | mk : \u2200 {i : I} {X Y : C i}, (X \u27f6 Y) \u2192 SigmaHom \u27e8i, X\u27e9 \u27e8i, Y\u27e9", "start": [27, 1], "end": [31, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.id", "code": "def id : \u2200 X : \u03a3i, C i, SigmaHom X X\n  | \u27e8_, _\u27e9 => mk (\ud835\udfd9 _)", "start": [36, 1], "end": [38, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.comp", "code": "def comp : \u2200 {X Y Z : \u03a3i, C i}, SigmaHom X Y \u2192 SigmaHom Y Z \u2192 SigmaHom X Z\n  | _, _, _, mk f, mk g => mk (f \u226b g)", "start": [45, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.comp_def", "code": "@[simp]\nlemma comp_def (i : I) (X Y Z : C i) (f : X \u27f6 Y) (g : Y \u27f6 Z) : comp (mk f) (mk g) = mk (f \u226b g) :=\n  rfl", "start": [56, 1], "end": [58, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.assoc", "code": "lemma assoc : \u2200 {X Y Z W : \u03a3i, C i} (f : X \u27f6 Y) (g : Y \u27f6 Z) (h : Z \u27f6 W), (f \u226b g) \u226b h = f \u226b g \u226b h\n  | _, _, _, _, mk _, mk _, mk _ => congr_arg mk (Category.assoc _ _ _)", "start": [61, 1], "end": [62, 72], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.id_comp", "code": "lemma id_comp : \u2200 {X Y : \u03a3i, C i} (f : X \u27f6 Y), \ud835\udfd9 X \u226b f = f\n  | _, _, mk _ => congr_arg mk (Category.id_comp _)", "start": [65, 1], "end": [66, 52], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.SigmaHom.comp_id", "code": "lemma comp_id : \u2200 {X Y : \u03a3i, C i} (f : X \u27f6 Y), f \u226b \ud835\udfd9 Y = f\n  | _, _, mk _ => congr_arg mk (Category.comp_id _)", "start": [69, 1], "end": [70, 52], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.sigma", "code": "instance sigma : Category (\u03a3i, C i) where\n  id_comp := SigmaHom.id_comp\n  comp_id := SigmaHom.comp_id\n  assoc := SigmaHom.assoc", "start": [75, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.incl", "code": "@[simps map]\ndef incl (i : I) : C i \u2964 \u03a3i, C i where\n  obj X := \u27e8i, X\u27e9\n  map := SigmaHom.mk", "start": [81, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.incl_obj", "code": "@[simp]\nlemma incl_obj {i : I} (X : C i) : (incl i).obj X = \u27e8i, X\u27e9 :=\n  rfl", "start": [88, 1], "end": [90, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.natTrans", "code": "def natTrans {F G : (\u03a3i, C i) \u2964 D} (h : \u2200 i : I, incl i \u22d9 F \u27f6 incl i \u22d9 G) : F \u27f6 G where\n  app := fun \u27e8j, X\u27e9 => (h j).app X\n  naturality := by\n    rintro \u27e8j, X\u27e9 \u27e8_, _\u27e9 \u27e8f\u27e9\n    apply (h j).naturality", "start": [105, 1], "end": [113, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.natTrans_app", "code": "@[simp]\nlemma natTrans_app {F G : (\u03a3i, C i) \u2964 D} (h : \u2200 i : I, incl i \u22d9 F \u27f6 incl i \u22d9 G) (i : I)\n    (X : C i) : (natTrans h).app \u27e8i, X\u27e9 = (h i).app X :=\n  rfl", "start": [116, 1], "end": [119, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.descMap", "code": "def descMap : \u2200 X Y : \u03a3i, C i, (X \u27f6 Y) \u2192 ((F X.1).obj X.2 \u27f6 (F Y.1).obj Y.2)\n  | _, _, SigmaHom.mk g => (F _).map g", "start": [122, 1], "end": [124, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.desc", "code": "@[simps obj]\ndef desc : (\u03a3i, C i) \u2964 D where\n  obj X := (F X.1).obj X.2\n  map g := descMap F _ _ g\n  map_id := by\n    rintro \u27e8i, X\u27e9\n    apply (F i).map_id\n  map_comp := by\n    rintro \u27e8i, X\u27e9 \u27e8_, Y\u27e9 \u27e8_, Z\u27e9 \u27e8f\u27e9 \u27e8g\u27e9\n    apply (F i).map_comp", "start": [128, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.desc_map_mk", "code": "@[simp]\nlemma desc_map_mk {i : I} (X Y : C i) (f : X \u27f6 Y) : (desc F).map (SigmaHom.mk f) = (F i).map f :=\n  rfl", "start": [148, 1], "end": [150, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.inclDesc", "code": "def inclDesc (i : I) : incl i \u22d9 desc F \u2245 F i :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [154, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.inclDesc_hom_app", "code": "@[simp]\nlemma inclDesc_hom_app (i : I) (X : C i) : (inclDesc F i).hom.app X = \ud835\udfd9 ((F i).obj X) :=\n  rfl", "start": [161, 1], "end": [163, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.inclDesc_inv_app", "code": "@[simp]\nlemma inclDesc_inv_app (i : I) (X : C i) : (inclDesc F i).inv.app X = \ud835\udfd9 ((F i).obj X) :=\n  rfl", "start": [166, 1], "end": [168, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.descUniq", "code": "def descUniq (q : (\u03a3i, C i) \u2964 D) (h : \u2200 i, incl i \u22d9 q \u2245 F i) : q \u2245 desc F :=\n  NatIso.ofComponents (fun \u27e8i, X\u27e9 => (h i).app X) <| by\n    rintro \u27e8i, X\u27e9 \u27e8_, _\u27e9 \u27e8f\u27e9\n    apply (h i).hom.naturality f", "start": [171, 1], "end": [177, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.descUniq_hom_app", "code": "@[simp]\nlemma descUniq_hom_app (q : (\u03a3i, C i) \u2964 D) (h : \u2200 i, incl i \u22d9 q \u2245 F i) (i : I) (X : C i) :\n    (descUniq F q h).hom.app \u27e8i, X\u27e9 = (h i).hom.app X :=\n  rfl", "start": [180, 1], "end": [183, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.descUniq_inv_app", "code": "@[simp]\nlemma descUniq_inv_app (q : (\u03a3i, C i) \u2964 D) (h : \u2200 i, incl i \u22d9 q \u2245 F i) (i : I) (X : C i) :\n    (descUniq F q h).inv.app \u27e8i, X\u27e9 = (h i).inv.app X :=\n  rfl", "start": [186, 1], "end": [189, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.natIso", "code": "@[simps]\ndef natIso {q\u2081 q\u2082 : (\u03a3i, C i) \u2964 D} (h : \u2200 i, incl i \u22d9 q\u2081 \u2245 incl i \u22d9 q\u2082) : q\u2081 \u2245 q\u2082 where\n  hom := natTrans fun i => (h i).hom\n  inv := natTrans fun i => (h i).inv", "start": [192, 1], "end": [198, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.map", "code": "def map : (\u03a3j : J, C (g j)) \u2964 \u03a3i : I, C i :=\n  desc fun j => incl (g j)", "start": [207, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.map_obj", "code": "@[simp]\nlemma map_obj (j : J) (X : C (g j)) : (Sigma.map C g).obj \u27e8j, X\u27e9 = \u27e8g j, X\u27e9 :=\n  rfl", "start": [212, 1], "end": [214, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.map_map", "code": "@[simp]\nlemma map_map {j : J} {X Y : C (g j)} (f : X \u27f6 Y) :\n    (Sigma.map C g).map (SigmaHom.mk f) = SigmaHom.mk f :=\n  rfl", "start": [217, 1], "end": [220, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Sigma.inclCompMap", "code": "@[simps!]\ndef inclCompMap (j : J) : incl j \u22d9 map C g \u2245 incl (g j) :=\n  Iso.refl _", "start": [223, 1], "end": [227, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.mapId", "code": "@[simps!]\ndef mapId : map C (id : I \u2192 I) \u2245 \ud835\udfed (\u03a3i, C i) :=\n  natIso fun i => NatIso.ofComponents fun X => Iso.refl _", "start": [232, 1], "end": [235, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.mapComp", "code": "@[simps!]\ndef mapComp (f : K \u2192 J) (g : J \u2192 I) : map (fun x => C (g x)) f \u22d9 (map C g : _) \u2245 map C (g \u2218 f) :=\n  (descUniq _ _) fun k =>\n    (isoWhiskerRight (inclCompMap (fun i => C (g i)) f k) (map C g : _) : _) \u226a\u226b inclCompMap _ _ _", "start": [242, 1], "end": [246, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.Functor.sigma", "code": "def sigma (F : \u2200 i, C i \u2964 D i) : (\u03a3i, C i) \u2964 \u03a3i, D i :=\n  desc fun i => F i \u22d9 incl i", "start": [257, 1], "end": [260, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sigma.natTrans.sigma", "code": "def sigma (\u03b1 : \u2200 i, F i \u27f6 G i) : Functor.sigma F \u27f6 Functor.sigma G where\n  app f := SigmaHom.mk ((\u03b1 f.1).app _)\n  naturality := by\n    rintro \u27e8i, X\u27e9 \u27e8_, _\u27e9 \u27e8f\u27e9\n    change SigmaHom.mk _ = SigmaHom.mk _\n    rw [(\u03b1 i).naturality]", "start": [271, 1], "end": [278, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/Pi.lean", "imports": ["Mathlib/Algebra/Order/Field/Basic.lean", "Mathlib/Data/Fintype/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.exists_forall_pos_add_lt", "code": "theorem Pi.exists_forall_pos_add_lt [ExistsAddOfLE \u03b1] [Finite \u03b9] {x y : \u03b9 \u2192 \u03b1}\n    (h : \u2200 i, x i < y i) : \u2203 \u03b5, 0 < \u03b5 \u2227 \u2200 i, x i + \u03b5 < y i", "start": [20, 1], "end": [30, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/UpperLower.lean", "imports": ["Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Algebra/Order/UpperLower.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasUpperLowerClosure", "code": "class HasUpperLowerClosure (\u03b1 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  isUpperSet_closure : \u2200 s : Set \u03b1, IsUpperSet s \u2192 IsUpperSet (closure s)\n  isLowerSet_closure : \u2200 s : Set \u03b1, IsLowerSet s \u2192 IsLowerSet (closure s)\n  isOpen_upperClosure : \u2200 s : Set \u03b1, IsOpen s \u2192 IsOpen (upperClosure s : Set \u03b1)\n  isOpen_lowerClosure : \u2200 s : Set \u03b1, IsOpen s \u2192 IsOpen (lowerClosure s : Set \u03b1)", "start": [29, 1], "end": [36, 80], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup.to_hasUpperLowerClosure", "code": "@[to_additive]\ninstance (priority := 100) OrderedCommGroup.to_hasUpperLowerClosure [OrderedCommGroup \u03b1]\n    [ContinuousConstSMul \u03b1 \u03b1] : HasUpperLowerClosure \u03b1 where\n  isUpperSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| one_le_div'.2 hxy) <| by\n      rw [closure_smul]\n      exact \u27e8x, hx, div_mul_cancel' _ _\u27e9\n  isLowerSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| div_le_one'.2 hxy) <| by\n      rw [closure_smul]\n      exact \u27e8x, hx, div_mul_cancel' _ _\u27e9\n  isOpen_upperClosure s hs := by\n    rw [\u2190 mul_one s, \u2190 mul_upperClosure]\n    exact hs.mul_right\n  isOpen_lowerClosure s hs := by\n    rw [\u2190 mul_one s, \u2190 mul_lowerClosure]\n    exact hs.mul_right", "start": [42, 1], "end": [58, 23], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.closure", "code": "protected theorem IsUpperSet.closure : IsUpperSet s \u2192 IsUpperSet (closure s)", "start": [64, 1], "end": [65, 44], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.closure", "code": "protected theorem IsLowerSet.closure : IsLowerSet s \u2192 IsLowerSet (closure s)", "start": [68, 1], "end": [69, 44], "kind": "commanddeclaration"}, {"full_name": "IsOpen.upperClosure", "code": "protected theorem IsOpen.upperClosure : IsOpen s \u2192 IsOpen (upperClosure s : Set \u03b1)", "start": [72, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "IsOpen.lowerClosure", "code": "protected theorem IsOpen.lowerClosure : IsOpen s \u2192 IsOpen (lowerClosure s : Set \u03b1)", "start": [76, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.interior", "code": "protected theorem IsUpperSet.interior (h : IsUpperSet s) : IsUpperSet (interior s)", "start": [101, 1], "end": [103, 24], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.interior", "code": "protected theorem IsLowerSet.interior (h : IsLowerSet s) : IsLowerSet (interior s)", "start": [106, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.interior", "code": "protected theorem Set.OrdConnected.interior (h : s.OrdConnected) : (interior s).OrdConnected", "start": [110, 1], "end": [113, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/Subobject.lean", "imports": ["Mathlib/CategoryTheory/Abelian/Basic.lean", "Mathlib/CategoryTheory/Subobject/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Abelian.subobjectIsoSubobjectOp", "code": "@[simps!]\ndef subobjectIsoSubobjectOp [Abelian C] (X : C) : Subobject X \u2243o (Subobject (op X))\u1d52\u1d48 := by\n  refine' OrderIso.ofHomInv (cokernelOrderHom X) (kernelOrderHom X) _ _\n  \u00b7 change (cokernelOrderHom X).comp (kernelOrderHom X) = _\n    refine' OrderHom.ext _ _ (funext (Subobject.ind _ _))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, kernelOrderHom_coe, Subobject.lift_mk,\n      cokernelOrderHom_coe, OrderHom.id_coe, id.def]\n    refine' Subobject.mk_eq_mk_of_comm _ _ \u27e8_, _, Quiver.Hom.unop_inj _, Quiver.Hom.unop_inj _\u27e9 _\n    \u00b7 exact (Abelian.epiDesc f.unop _ (cokernel.condition (kernel.\u03b9 f.unop))).op\n    \u00b7 exact (cokernel.desc _ _ (kernel.condition f.unop)).op\n    \u00b7 rw [\u2190 cancel_epi (cokernel.\u03c0 (kernel.\u03b9 f.unop))]\n      simp only [unop_comp, Quiver.Hom.unop_op, unop_id_op, cokernel.\u03c0_desc_assoc,\n        comp_epiDesc, Category.comp_id]\n    \u00b7 simp only [\u2190 cancel_epi f.unop, unop_comp, Quiver.Hom.unop_op, unop_id, comp_epiDesc_assoc,\n        cokernel.\u03c0_desc, Category.comp_id]\n    \u00b7 exact Quiver.Hom.unop_inj (by simp only [unop_comp, Quiver.Hom.unop_op, comp_epiDesc])\n  \u00b7 change (kernelOrderHom X).comp (cokernelOrderHom X) = _\n    refine' OrderHom.ext _ _ (funext (Subobject.ind _ _))\n    intro A f hf\n    dsimp only [OrderHom.comp_coe, Function.comp_apply, cokernelOrderHom_coe, Subobject.lift_mk,\n      kernelOrderHom_coe, OrderHom.id_coe, id.def, unop_op, Quiver.Hom.unop_op]\n    refine' Subobject.mk_eq_mk_of_comm _ _ \u27e8_, _, _, _\u27e9 _\n    \u00b7 exact Abelian.monoLift f _ (kernel.condition (cokernel.\u03c0 f))\n    \u00b7 exact kernel.lift _ _ (cokernel.condition f)\n    \u00b7 simp only [\u2190 cancel_mono (kernel.\u03b9 (cokernel.\u03c0 f)), Category.assoc, image.fac, monoLift_comp,\n        Category.id_comp]\n    \u00b7 simp only [\u2190 cancel_mono f, Category.assoc, monoLift_comp, image.fac, Category.id_comp]\n    \u00b7 simp only [monoLift_comp]", "start": [27, 1], "end": [59, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Abelian.wellPowered_opposite", "code": "instance wellPowered_opposite [Abelian C] [WellPowered C] : WellPowered C\u1d52\u1d56 where\n  subobject_small X :=\n    (small_congr (subobjectIsoSubobjectOp (unop X)).toEquiv).1 inferInstance", "start": [62, 1], "end": [65, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Generator.lean", "imports": ["Mathlib/CategoryTheory/Generator.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Preadditive.isSeparating_iff", "code": "theorem Preadditive.isSeparating_iff (\ud835\udca2 : Set C) :\n    IsSeparating \ud835\udca2 \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : G \u27f6 X), h \u226b f = 0) \u2192 f = 0", "start": [28, 1], "end": [31, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isCoseparating_iff", "code": "theorem Preadditive.isCoseparating_iff (\ud835\udca2 : Set C) :\n    IsCoseparating \ud835\udca2 \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : Y \u27f6 G), f \u226b h = 0) \u2192 f = 0", "start": [34, 1], "end": [37, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isSeparator_iff", "code": "theorem Preadditive.isSeparator_iff (G : C) :\n    IsSeparator G \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : G \u27f6 X, h \u226b f = 0) \u2192 f = 0", "start": [40, 1], "end": [44, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.isCoseparator_iff", "code": "theorem Preadditive.isCoseparator_iff (G : C) :\n    IsCoseparator G \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : Y \u27f6 G, f \u226b h = 0) \u2192 f = 0", "start": [47, 1], "end": [51, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_iff_faithful_preadditiveCoyoneda", "code": "theorem isSeparator_iff_faithful_preadditiveCoyoneda (G : C) :\n    IsSeparator G \u2194 Faithful (preadditiveCoyoneda.obj (op G))", "start": [54, 1], "end": [58, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_iff_faithful_preadditiveCoyonedaObj", "code": "theorem isSeparator_iff_faithful_preadditiveCoyonedaObj (G : C) :\n    IsSeparator G \u2194 Faithful (preadditiveCoyonedaObj (op G))", "start": [61, 1], "end": [64, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_iff_faithful_preadditiveYoneda", "code": "theorem isCoseparator_iff_faithful_preadditiveYoneda (G : C) :\n    IsCoseparator G \u2194 Faithful (preadditiveYoneda.obj G)", "start": [67, 1], "end": [71, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_iff_faithful_preadditiveYonedaObj", "code": "theorem isCoseparator_iff_faithful_preadditiveYonedaObj (G : C) :\n    IsCoseparator G \u2194 Faithful (preadditiveYonedaObj G)", "start": [74, 1], "end": [77, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Diffeomorph.lean", "imports": ["Mathlib/Geometry/Manifold/ContMDiffMap.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Diffeomorph", "code": "structure Diffeomorph extends M \u2243 M' where\n  protected contMDiff_toFun : ContMDiff I I' n toEquiv\n  protected contMDiff_invFun : ContMDiff I' I n toEquiv.symm", "start": [68, 1], "end": [74, 61], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toEquiv_injective", "code": "theorem toEquiv_injective : Injective (Diffeomorph.toEquiv : (M \u2243\u2098^n\u27eeI, I'\u27ef M') \u2192 M \u2243 M')", "start": [93, 1], "end": [94, 37], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toContMDiffMap", "code": "@[coe]\ndef toContMDiffMap (\u03a6 : M \u2243\u2098^n\u27eeI, I'\u27ef M') : C^n\u27eeI, M; I', M'\u27ef :=\n  \u27e8\u03a6, \u03a6.contMDiff_toFun\u27e9", "start": [104, 1], "end": [107, 25], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.continuous", "code": "@[continuity]\nprotected theorem continuous (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : Continuous h", "start": [112, 1], "end": [114, 31], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiff", "code": "protected theorem contMDiff (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : ContMDiff I I' n h", "start": [117, 1], "end": [118, 20], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffAt", "code": "protected theorem contMDiffAt (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') {x} : ContMDiffAt I I' n h x", "start": [121, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffWithinAt", "code": "protected theorem contMDiffWithinAt (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') {s x} : ContMDiffWithinAt I I' n h s x", "start": [125, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contDiff", "code": "protected theorem contDiff (h : E \u2243\u2098^n\u27ee\ud835\udcd8(\ud835\udd5c, E), \ud835\udcd8(\ud835\udd5c, E')\u27ef E') : ContDiff \ud835\udd5c n h", "start": [130, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.smooth", "code": "protected theorem smooth (h : M \u2243\u2098\u27eeI, I'\u27ef M') : Smooth I I' h", "start": [134, 1], "end": [134, 77], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.mdifferentiable", "code": "protected theorem mdifferentiable (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') (hn : 1 \u2264 n) : MDifferentiable I I' h", "start": [137, 1], "end": [138, 33], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.mdifferentiableOn", "code": "protected theorem mdifferentiableOn (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') (s : Set M) (hn : 1 \u2264 n) :\n    MDifferentiableOn I I' h s", "start": [141, 1], "end": [143, 43], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : \u21d1h.toEquiv = h", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : \u21d1(h : C^n\u27eeI, M; I', M'\u27ef) = h", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toEquiv_inj", "code": "@[simp]\ntheorem toEquiv_inj {h h' : M \u2243\u2098^n\u27eeI, I'\u27ef M'} : h.toEquiv = h'.toEquiv \u2194 h = h'", "start": [156, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coeFn_injective", "code": "theorem coeFn_injective : Injective ((\u2191) : (M \u2243\u2098^n\u27eeI, I'\u27ef M') \u2192 (M \u2192 M'))", "start": [161, 1], "end": [163, 24], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.ext", "code": "@[ext]\ntheorem ext {h h' : M \u2243\u2098^n\u27eeI, I'\u27ef M'} (Heq : \u2200 x, h x = h' x) : h = h'", "start": [166, 1], "end": [168, 32], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.refl", "code": "protected def refl : M \u2243\u2098^n\u27eeI, I\u27ef M where\n  contMDiff_toFun := contMDiff_id\n  contMDiff_invFun := contMDiff_id\n  toEquiv := Equiv.refl M", "start": [178, 1], "end": [182, 26], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.refl_toEquiv", "code": "@[simp]\ntheorem refl_toEquiv : (Diffeomorph.refl I M n).toEquiv = Equiv.refl _", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(Diffeomorph.refl I M n) = id", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.trans", "code": "protected def trans (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : M' \u2243\u2098^n\u27eeI', J\u27ef N) : M \u2243\u2098^n\u27eeI, J\u27ef N where\n  contMDiff_toFun := h\u2082.contMDiff.comp h\u2081.contMDiff\n  contMDiff_invFun := h\u2081.contMDiff_invFun.comp h\u2082.contMDiff_invFun\n  toEquiv := h\u2081.toEquiv.trans h\u2082.toEquiv", "start": [197, 1], "end": [201, 41], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.trans_refl", "code": "@[simp]\ntheorem trans_refl (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : h.trans (Diffeomorph.refl I' M' n) = h", "start": [204, 1], "end": [206, 19], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.refl_trans", "code": "@[simp]\ntheorem refl_trans (h : M \u2243\u2098^n\u27eeI, I'\u27ef M') : (Diffeomorph.refl I M n).trans h = h", "start": [209, 1], "end": [211, 19], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_trans", "code": "@[simp]\ntheorem coe_trans (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : M' \u2243\u2098^n\u27eeI', J\u27ef N) : \u21d1(h\u2081.trans h\u2082) = h\u2082 \u2218 h\u2081", "start": [214, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm", "code": "@[pp_dot]\nprotected def symm (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : N \u2243\u2098^n\u27eeJ, I\u27ef M where\n  contMDiff_toFun := h.contMDiff_invFun\n  contMDiff_invFun := h.contMDiff_toFun\n  toEquiv := h.toEquiv.symm", "start": [219, 1], "end": [224, 28], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (x : N) : h (h.symm x) = x", "start": [227, 1], "end": [229, 31], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (x : M) : h.symm (h x) = x", "start": [232, 1], "end": [234, 31], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_refl", "code": "@[simp]\ntheorem symm_refl : (Diffeomorph.refl I M n).symm = Diffeomorph.refl I M n", "start": [237, 1], "end": [239, 19], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : h.trans h.symm = Diffeomorph.refl I M n", "start": [242, 1], "end": [244, 25], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : h.symm.trans h = Diffeomorph.refl J N n", "start": [247, 1], "end": [249, 25], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_trans'", "code": "@[simp]\ntheorem symm_trans' (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : M' \u2243\u2098^n\u27eeI', J\u27ef N) :\n    (h\u2081.trans h\u2082).symm = h\u2082.symm.trans h\u2081.symm", "start": [252, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_toEquiv", "code": "@[simp]\ntheorem symm_toEquiv (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : h.symm.toEquiv = h.toEquiv.symm", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toEquiv_coe_symm", "code": "@[simp, mfld_simps]\ntheorem toEquiv_coe_symm (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : \u21d1h.toEquiv.symm = h.symm", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.image_eq_preimage", "code": "theorem image_eq_preimage (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (s : Set M) : h '' s = h.symm \u207b\u00b9' s", "start": [268, 1], "end": [269, 32], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_image_eq_preimage", "code": "theorem symm_image_eq_preimage (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (s : Set N) : h.symm '' s = h \u207b\u00b9' s", "start": [272, 1], "end": [273, 29], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.range_comp", "code": "@[simp, mfld_simps]\nnonrec theorem range_comp {\u03b1} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (f : \u03b1 \u2192 M) :\n    range (h \u2218 f) = h.symm \u207b\u00b9' range f", "start": [276, 1], "end": [279, 37], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.image_symm_image", "code": "@[simp]\ntheorem image_symm_image (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (s : Set N) : h '' (h.symm '' s) = s", "start": [282, 1], "end": [284, 31], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_image_image", "code": "@[simp]\ntheorem symm_image_image (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (s : Set M) : h.symm '' (h '' s) = s", "start": [287, 1], "end": [289, 31], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toHomeomorph", "code": "def toHomeomorph (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : M \u2243\u209c N :=\n  \u27e8h.toEquiv, h.continuous, h.symm.continuous\u27e9", "start": [292, 1], "end": [294, 47], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toHomeomorph_toEquiv", "code": "@[simp]\ntheorem toHomeomorph_toEquiv (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : h.toHomeomorph.toEquiv = h.toEquiv", "start": [297, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.symm_toHomeomorph", "code": "@[simp]\ntheorem symm_toHomeomorph (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : h.symm.toHomeomorph = h.toHomeomorph.symm", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : \u21d1h.toHomeomorph = h", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_toHomeomorph_symm", "code": "@[simp]\ntheorem coe_toHomeomorph_symm (h : M \u2243\u2098^n\u27eeI, J\u27ef N) : \u21d1h.toHomeomorph.symm = h.symm", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffWithinAt_comp_diffeomorph_iff", "code": "@[simp]\ntheorem contMDiffWithinAt_comp_diffeomorph_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : N \u2192 M'} {s x}\n    (hm : m \u2264 n) :\n    ContMDiffWithinAt I I' m (f \u2218 h) s x \u2194 ContMDiffWithinAt J I' m f (h.symm \u207b\u00b9' s) (h x)", "start": [317, 1], "end": [327, 80], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffOn_comp_diffeomorph_iff", "code": "@[simp]\ntheorem contMDiffOn_comp_diffeomorph_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : N \u2192 M'} {s} (hm : m \u2264 n) :\n    ContMDiffOn I I' m (f \u2218 h) s \u2194 ContMDiffOn J I' m f (h.symm \u207b\u00b9' s)", "start": [330, 1], "end": [335, 20], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffAt_comp_diffeomorph_iff", "code": "@[simp]\ntheorem contMDiffAt_comp_diffeomorph_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : N \u2192 M'} {x} (hm : m \u2264 n) :\n    ContMDiffAt I I' m (f \u2218 h) x \u2194 ContMDiffAt J I' m f (h x)", "start": [338, 1], "end": [341, 46], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiff_comp_diffeomorph_iff", "code": "@[simp]\ntheorem contMDiff_comp_diffeomorph_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : N \u2192 M'} (hm : m \u2264 n) :\n    ContMDiff I I' m (f \u2218 h) \u2194 ContMDiff J I' m f", "start": [344, 1], "end": [347, 66], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffWithinAt_diffeomorph_comp_iff", "code": "@[simp]\ntheorem contMDiffWithinAt_diffeomorph_comp_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : M' \u2192 M} (hm : m \u2264 n)\n    {s x} : ContMDiffWithinAt I' J m (h \u2218 f) s x \u2194 ContMDiffWithinAt I' I m f s x", "start": [350, 1], "end": [356, 68], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffAt_diffeomorph_comp_iff", "code": "@[simp]\ntheorem contMDiffAt_diffeomorph_comp_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : M' \u2192 M} (hm : m \u2264 n) {x} :\n    ContMDiffAt I' J m (h \u2218 f) x \u2194 ContMDiffAt I' I m f x", "start": [359, 1], "end": [362, 46], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffOn_diffeomorph_comp_iff", "code": "@[simp]\ntheorem contMDiffOn_diffeomorph_comp_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : M' \u2192 M} (hm : m \u2264 n) {s} :\n    ContMDiffOn I' J m (h \u2218 f) s \u2194 ContMDiffOn I' I m f s", "start": [365, 1], "end": [368, 71], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiff_diffeomorph_comp_iff", "code": "@[simp]\ntheorem contMDiff_diffeomorph_comp_iff {m} (h : M \u2243\u2098^n\u27eeI, J\u27ef N) {f : M' \u2192 M} (hm : m \u2264 n) :\n    ContMDiff I' J m (h \u2218 f) \u2194 ContMDiff I' I m f", "start": [371, 1], "end": [374, 69], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toLocalHomeomorph_mdifferentiable", "code": "theorem toLocalHomeomorph_mdifferentiable (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (hn : 1 \u2264 n) :\n    h.toHomeomorph.toLocalHomeomorph.MDifferentiable I J", "start": [377, 1], "end": [379, 60], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.prodCongr", "code": "def prodCongr (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : N \u2243\u2098^n\u27eeJ, J'\u27ef N') :\n    (M \u00d7 N) \u2243\u2098^n\u27eeI.prod J, I'.prod J'\u27ef M' \u00d7 N' where\n  contMDiff_toFun := (h\u2081.contMDiff.comp contMDiff_fst).prod_mk (h\u2082.contMDiff.comp contMDiff_snd)\n  contMDiff_invFun :=\n    (h\u2081.symm.contMDiff.comp contMDiff_fst).prod_mk (h\u2082.symm.contMDiff.comp contMDiff_snd)\n  toEquiv := h\u2081.toEquiv.prodCongr h\u2082.toEquiv", "start": [384, 1], "end": [390, 45], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.prodCongr_symm", "code": "@[simp]\ntheorem prodCongr_symm (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : N \u2243\u2098^n\u27eeJ, J'\u27ef N') :\n    (h\u2081.prodCongr h\u2082).symm = h\u2081.symm.prodCongr h\u2082.symm", "start": [393, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_prodCongr", "code": "@[simp]\ntheorem coe_prodCongr (h\u2081 : M \u2243\u2098^n\u27eeI, I'\u27ef M') (h\u2082 : N \u2243\u2098^n\u27eeJ, J'\u27ef N') :\n    \u21d1(h\u2081.prodCongr h\u2082) = Prod.map h\u2081 h\u2082", "start": [399, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.prodComm", "code": "def prodComm : (M \u00d7 N) \u2243\u2098^n\u27eeI.prod J, J.prod I\u27ef N \u00d7 M where\n  contMDiff_toFun := contMDiff_snd.prod_mk contMDiff_fst\n  contMDiff_invFun := contMDiff_snd.prod_mk contMDiff_fst\n  toEquiv := Equiv.prodComm M N", "start": [409, 1], "end": [413, 32], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.prodComm_symm", "code": "@[simp]\ntheorem prodComm_symm : (prodComm I J M N n).symm = prodComm J I N M n", "start": [416, 1], "end": [418, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm : \u21d1(prodComm I J M N n) = Prod.swap", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.prodAssoc", "code": "def prodAssoc : ((M \u00d7 N) \u00d7 N') \u2243\u2098^n\u27ee(I.prod J).prod J', I.prod (J.prod J')\u27ef M \u00d7 N \u00d7 N' where\n  contMDiff_toFun :=\n    (contMDiff_fst.comp contMDiff_fst).prod_mk\n      ((contMDiff_snd.comp contMDiff_fst).prod_mk contMDiff_snd)\n  contMDiff_invFun :=\n    (contMDiff_fst.prod_mk (contMDiff_fst.comp contMDiff_snd)).prod_mk\n      (contMDiff_snd.comp contMDiff_snd)\n  toEquiv := Equiv.prodAssoc M N N'", "start": [426, 1], "end": [434, 36], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.uniqueMDiffOn_image_aux", "code": "theorem uniqueMDiffOn_image_aux (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (hn : 1 \u2264 n) {s : Set M}\n    (hs : UniqueMDiffOn I s) : UniqueMDiffOn J (h '' s)", "start": [443, 1], "end": [446, 29], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.uniqueMDiffOn_image", "code": "@[simp]\ntheorem uniqueMDiffOn_image (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (hn : 1 \u2264 n) {s : Set M} :\n    UniqueMDiffOn J (h '' s) \u2194 UniqueMDiffOn I s", "start": [449, 1], "end": [453, 34], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.uniqueMDiffOn_preimage", "code": "@[simp]\ntheorem uniqueMDiffOn_preimage (h : M \u2243\u2098^n\u27eeI, J\u27ef N) (hn : 1 \u2264 n) {s : Set N} :\n    UniqueMDiffOn I (h \u207b\u00b9' s) \u2194 UniqueMDiffOn J s", "start": [456, 1], "end": [459, 61], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.uniqueDiffOn_image", "code": "@[simp]\ntheorem uniqueDiffOn_image (h : E \u2243\u2098^n\u27ee\ud835\udcd8(\ud835\udd5c, E), \ud835\udcd8(\ud835\udd5c, F)\u27ef F) (hn : 1 \u2264 n) {s : Set E} :\n    UniqueDiffOn \ud835\udd5c (h '' s) \u2194 UniqueDiffOn \ud835\udd5c s", "start": [463, 1], "end": [466, 72], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.uniqueDiffOn_preimage", "code": "@[simp]\ntheorem uniqueDiffOn_preimage (h : E \u2243\u2098^n\u27ee\ud835\udcd8(\ud835\udd5c, E), \ud835\udcd8(\ud835\udd5c, F)\u27ef F) (hn : 1 \u2264 n) {s : Set F} :\n    UniqueDiffOn \ud835\udd5c (h \u207b\u00b9' s) \u2194 UniqueDiffOn \ud835\udd5c s", "start": [469, 1], "end": [473, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toDiffeomorph", "code": "def toDiffeomorph : E \u2243\u2098[\ud835\udd5c] E' where\n  contMDiff_toFun := e.contDiff.contMDiff\n  contMDiff_invFun := e.symm.contDiff.contMDiff\n  toEquiv := e.toLinearEquiv.toEquiv", "start": [482, 1], "end": [486, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_toDiffeomorph", "code": "@[simp]\ntheorem coe_toDiffeomorph : \u21d1e.toDiffeomorph = e", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_toDiffeomorph", "code": "@[simp]\ntheorem symm_toDiffeomorph : e.symm.toDiffeomorph = e.toDiffeomorph.symm", "start": [494, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_toDiffeomorph_symm", "code": "@[simp]\ntheorem coe_toDiffeomorph_symm : \u21d1e.toDiffeomorph.symm = e.symm", "start": [499, 1], "end": [501, 6], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.transDiffeomorph", "code": "def transDiffeomorph (I : ModelWithCorners \ud835\udd5c E H) (e : E \u2243\u2098[\ud835\udd5c] E') : ModelWithCorners \ud835\udd5c E' H where\n  toLocalEquiv := I.toLocalEquiv.trans e.toEquiv.toLocalEquiv\n  source_eq := by simp\n  unique_diff' := by simp [range_comp e, I.unique_diff]\n  continuous_toFun := e.continuous.comp I.continuous\n  continuous_invFun := I.continuous_symm.comp e.symm.continuous", "start": [510, 1], "end": [516, 64], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.coe_transDiffeomorph", "code": "@[simp, mfld_simps]\ntheorem coe_transDiffeomorph : \u21d1(I.transDiffeomorph e) = e \u2218 I", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.coe_transDiffeomorph_symm", "code": "@[simp, mfld_simps]\ntheorem coe_transDiffeomorph_symm : \u21d1(I.transDiffeomorph e).symm = I.symm \u2218 e.symm", "start": [524, 1], "end": [526, 6], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.transDiffeomorph_range", "code": "theorem transDiffeomorph_range : range (I.transDiffeomorph e) = e '' range I", "start": [529, 1], "end": [530, 17], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.coe_extChartAt_transDiffeomorph", "code": "theorem coe_extChartAt_transDiffeomorph (x : M) :\n    \u21d1(extChartAt (I.transDiffeomorph e) x) = e \u2218 extChartAt I x", "start": [533, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.coe_extChartAt_transDiffeomorph_symm", "code": "theorem coe_extChartAt_transDiffeomorph_symm (x : M) :\n    \u21d1(extChartAt (I.transDiffeomorph e) x).symm = (extChartAt I x).symm \u2218 e.symm", "start": [538, 1], "end": [540, 6], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.extChartAt_transDiffeomorph_target", "code": "theorem extChartAt_transDiffeomorph_target (x : M) :\n    (extChartAt (I.transDiffeomorph e) x).target = e.symm \u207b\u00b9' (extChartAt I x).target", "start": [543, 1], "end": [545, 63], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.smoothManifoldWithCorners_transDiffeomorph", "code": "instance smoothManifoldWithCorners_transDiffeomorph [SmoothManifoldWithCorners I M] :\n    SmoothManifoldWithCorners (I.transDiffeomorph e) M := by\n  refine smoothManifoldWithCorners_of_contDiffOn (I.transDiffeomorph e) M fun e\u2081 e\u2082 h\u2081 h\u2082 => ?_\n  refine' e.contDiff.comp_contDiffOn\n      (((contDiffGroupoid \u22a4 I).compatible h\u2081 h\u2082).1.comp e.symm.contDiff.contDiffOn _)\n  mfld_set_tac", "start": [554, 1], "end": [559, 15], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.toTransDiffeomorph", "code": "def toTransDiffeomorph (e : E \u2243\u2098[\ud835\udd5c] F) : M \u2243\u2098\u27eeI, I.transDiffeomorph e\u27ef M where\n  toEquiv := Equiv.refl M\n  contMDiff_toFun x := by\n    refine' contMDiffWithinAt_iff'.2 \u27e8continuousWithinAt_id, _\u27e9\n    refine' e.contDiff.contDiffWithinAt.congr' (fun y hy => _) _\n    \u00b7 simp only [Equiv.coe_refl, id, (\u00b7 \u2218 \u00b7), I.coe_extChartAt_transDiffeomorph]\n      rw [(extChartAt I x).right_inv hy.1]\n    exact\n      \u27e8(extChartAt I x).map_source (mem_extChartAt_source I x), trivial, by simp only [mfld_simps]\u27e9\n  contMDiff_invFun x := by\n    refine' contMDiffWithinAt_iff'.2 \u27e8continuousWithinAt_id, _\u27e9\n    refine' e.symm.contDiff.contDiffWithinAt.congr' (fun y hy => _) _\n    \u00b7 simp only [mem_inter_iff, I.extChartAt_transDiffeomorph_target] at hy\n      simp only [Equiv.coe_refl, Equiv.refl_symm, id, (\u00b7 \u2218 \u00b7),\n        I.coe_extChartAt_transDiffeomorph_symm, (extChartAt I x).right_inv hy.1]\n    exact \u27e8(extChartAt _ x).map_source (mem_extChartAt_source _ x), trivial, by\n      simp only [e.symm_apply_apply, Equiv.refl_symm, Equiv.coe_refl, mfld_simps]\u27e9", "start": [564, 1], "end": [583, 83], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffWithinAt_transDiffeomorph_right", "code": "@[simp]\ntheorem contMDiffWithinAt_transDiffeomorph_right {f : M' \u2192 M} {x s} :\n    ContMDiffWithinAt I' (I.transDiffeomorph e) n f s x \u2194 ContMDiffWithinAt I' I n f s x", "start": [588, 1], "end": [591, 75], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffAt_transDiffeomorph_right", "code": "@[simp]\ntheorem contMDiffAt_transDiffeomorph_right {f : M' \u2192 M} {x} :\n    ContMDiffAt I' (I.transDiffeomorph e) n f x \u2194 ContMDiffAt I' I n f x", "start": [594, 1], "end": [597, 69], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffOn_transDiffeomorph_right", "code": "@[simp]\ntheorem contMDiffOn_transDiffeomorph_right {f : M' \u2192 M} {s} :\n    ContMDiffOn I' (I.transDiffeomorph e) n f s \u2194 ContMDiffOn I' I n f s", "start": [600, 1], "end": [603, 69], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiff_transDiffeomorph_right", "code": "@[simp]\ntheorem contMDiff_transDiffeomorph_right {f : M' \u2192 M} :\n    ContMDiff I' (I.transDiffeomorph e) n f \u2194 ContMDiff I' I n f", "start": [606, 1], "end": [609, 67], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.smooth_transDiffeomorph_right", "code": "theorem smooth_transDiffeomorph_right {f : M' \u2192 M} :\n    Smooth I' (I.transDiffeomorph e) f \u2194 Smooth I' I f", "start": [613, 1], "end": [615, 37], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffWithinAt_transDiffeomorph_left", "code": "@[simp]\ntheorem contMDiffWithinAt_transDiffeomorph_left {f : M \u2192 M'} {x s} :\n    ContMDiffWithinAt (I.transDiffeomorph e) I' n f s x \u2194 ContMDiffWithinAt I I' n f s x", "start": [618, 1], "end": [621, 82], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffAt_transDiffeomorph_left", "code": "@[simp]\ntheorem contMDiffAt_transDiffeomorph_left {f : M \u2192 M'} {x} :\n    ContMDiffAt (I.transDiffeomorph e) I' n f x \u2194 ContMDiffAt I I' n f x", "start": [624, 1], "end": [627, 76], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiffOn_transDiffeomorph_left", "code": "@[simp]\ntheorem contMDiffOn_transDiffeomorph_left {f : M \u2192 M'} {s} :\n    ContMDiffOn (I.transDiffeomorph e) I' n f s \u2194 ContMDiffOn I I' n f s", "start": [630, 1], "end": [633, 76], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.contMDiff_transDiffeomorph_left", "code": "@[simp]\ntheorem contMDiff_transDiffeomorph_left {f : M \u2192 M'} :\n    ContMDiff (I.transDiffeomorph e) I' n f \u2194 ContMDiff I I' n f", "start": [636, 1], "end": [639, 74], "kind": "commanddeclaration"}, {"full_name": "Diffeomorph.smooth_transDiffeomorph_left", "code": "theorem smooth_transDiffeomorph_left {f : M \u2192 M'} :\n    Smooth (I.transDiffeomorph e) I' f \u2194 Smooth I I' f", "start": [643, 1], "end": [645, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/PFilter.lean", "imports": ["Mathlib/Order/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.PFilter", "code": "structure PFilter (P) [Preorder P] where\n  dual : Ideal P\u1d52\u1d48", "start": [45, 1], "end": [50, 19], "kind": "commanddeclaration"}, {"full_name": "Order.IsPFilter", "code": "def IsPFilter [Preorder P] (F : Set P) : Prop :=\n  IsIdeal (OrderDual.ofDual \u207b\u00b9' F)", "start": [53, 1], "end": [55, 35], "kind": "commanddeclaration"}, {"full_name": "Order.IsPFilter.of_def", "code": "theorem IsPFilter.of_def [Preorder P] {F : Set P} (nonempty : F.Nonempty)\n    (directed : DirectedOn (\u00b7 \u2265 \u00b7) F) (mem_of_le : \u2200 {x y : P}, x \u2264 y \u2192 x \u2208 F \u2192 y \u2208 F) :\n    IsPFilter F", "start": [58, 1], "end": [61, 57], "kind": "commanddeclaration"}, {"full_name": "Order.IsPFilter.toPFilter", "code": "def IsPFilter.toPFilter [Preorder P] {F : Set P} (h : IsPFilter F) : PFilter P :=\n  \u27e8h.toIdeal\u27e9", "start": [64, 1], "end": [67, 14], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.isPFilter", "code": "theorem isPFilter : IsPFilter (F : Set P)", "start": [84, 1], "end": [84, 60], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.nonempty", "code": "protected theorem nonempty : (F : Set P).Nonempty", "start": [87, 1], "end": [87, 69], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.directed", "code": "theorem directed : DirectedOn (\u00b7 \u2265 \u00b7) (F : Set P)", "start": [90, 1], "end": [90, 69], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.mem_of_le", "code": "theorem mem_of_le {F : PFilter P} : x \u2264 y \u2192 x \u2208 F \u2192 y \u2208 F", "start": [93, 1], "end": [93, 85], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.ext", "code": "@[ext]\ntheorem ext (h : (s : Set P) = t) : s = t", "start": [96, 1], "end": [98, 60], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.mem_of_mem_of_le", "code": "@[trans]\ntheorem mem_of_mem_of_le {F G : PFilter P} (hx : x \u2208 F) (hle : F \u2264 G) : x \u2208 G", "start": [101, 1], "end": [103, 9], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.principal", "code": "def principal (p : P) : PFilter P :=\n  \u27e8Ideal.principal (toDual p)\u27e9", "start": [106, 1], "end": [108, 31], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.mem_mk", "code": "@[simp]\ntheorem mem_mk (x : P) (I : Ideal P\u1d52\u1d48) : x \u2208 (\u27e8I\u27e9 : PFilter P) \u2194 toDual x \u2208 I", "start": [111, 1], "end": [113, 10], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.principal_le_iff", "code": "@[simp]\ntheorem principal_le_iff {F : PFilter P} : principal x \u2264 F \u2194 x \u2208 F", "start": [116, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.mem_principal", "code": "@[simp] theorem mem_principal : x \u2208 principal y \u2194 y \u2264 x", "start": [121, 1], "end": [121, 67], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.principal_le_principal_iff", "code": "theorem principal_le_principal_iff {p q : P} : principal q \u2264 principal p \u2194 p \u2264 q", "start": [124, 1], "end": [124, 92], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.antitone_principal", "code": "theorem antitone_principal : Antitone (principal : P \u2192 PFilter P)", "start": [128, 1], "end": [129, 31], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.top_mem", "code": "@[simp] theorem top_mem : \u22a4 \u2208 F", "start": [138, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.inf_mem", "code": "theorem inf_mem (hx : x \u2208 F) (hy : y \u2208 F) : x \u2293 y \u2208 F", "start": [158, 1], "end": [160, 22], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.inf_mem_iff", "code": "@[simp]\ntheorem inf_mem_iff : x \u2293 y \u2208 F \u2194 x \u2208 F \u2227 y \u2208 F", "start": [163, 1], "end": [165, 20], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.sInf_gc", "code": "theorem sInf_gc :\n    GaloisConnection (fun x => toDual (principal x)) fun F => sInf (ofDual F : PFilter P)", "start": [174, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Order.PFilter.infGi", "code": "def infGi :\n    GaloisCoinsertion (fun x => toDual (principal x)) fun F => sInf (ofDual F : PFilter P) :=\n  sInf_gc.toGaloisCoinsertion fun _ => sInf_le <| mem_principal.2 le_rfl", "start": [181, 1], "end": [184, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/LocalizerMorphism.lean", "imports": ["Mathlib/CategoryTheory/Localization/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.LocalizerMorphism", "code": "structure LocalizerMorphism where\n  \n  functor : C\u2081 \u2964 C\u2082\n  \n  map : W\u2081 \u2286 W\u2082.inverseImage functor", "start": [39, 1], "end": [45, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.id", "code": "@[simps]\ndef id : LocalizerMorphism W\u2081 W\u2081 where\n  functor := \ud835\udfed C\u2081\n  map _ _ _ hf := hf", "start": [49, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.comp", "code": "@[simps]\ndef comp (\u03a6 : LocalizerMorphism W\u2081 W\u2082) (\u03a8 : LocalizerMorphism W\u2082 W\u2083) :\n    LocalizerMorphism W\u2081 W\u2083 where\n  functor := \u03a6.functor \u22d9 \u03a8.functor\n  map _ _ _ hf := \u03a8.map _ (\u03a6.map _ hf)", "start": [57, 1], "end": [62, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.inverts", "code": "lemma inverts : W\u2081.IsInvertedBy (\u03a6.functor \u22d9 L\u2082) :=\n  fun _ _ _ hf => Localization.inverts L\u2082 W\u2082 _ (\u03a6.map _ hf)", "start": [67, 1], "end": [68, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.LocalizerMorphism.localizedFunctor", "code": "noncomputable def localizedFunctor : D\u2081 \u2964 D\u2082 :=\n  lift (\u03a6.functor \u22d9 L\u2082) (\u03a6.inverts _) L\u2081", "start": [70, 1], "end": [74, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.catCommSq", "code": "noncomputable instance catCommSq : CatCommSq \u03a6.functor L\u2081 L\u2082 (\u03a6.localizedFunctor L\u2081 L\u2082) :=\n  CatCommSq.mk (Lifting.iso _ W\u2081 _ _).symm", "start": [80, 1], "end": [83, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.isEquivalence_imp", "code": "noncomputable def isEquivalence_imp [IsEquivalence G] :\n  IsEquivalence G' := by\n    let E\u2081 := Localization.uniq L\u2081 L\u2081' W\u2081\n    let E\u2082 := Localization.uniq L\u2082 L\u2082' W\u2082\n    let e : L\u2081 \u22d9 G \u22d9 E\u2082.functor \u2245 L\u2081 \u22d9 E\u2081.functor \u22d9 G' :=\n      calc\n        L\u2081 \u22d9 G \u22d9 E\u2082.functor \u2245 \u03a6.functor \u22d9 L\u2082 \u22d9 E\u2082.functor :=\n            (Functor.associator _ _ _).symm \u226a\u226b\n              isoWhiskerRight (CatCommSq.iso \u03a6.functor L\u2081 L\u2082 G).symm E\u2082.functor \u226a\u226b\n              Functor.associator _ _ _\n        _ \u2245 \u03a6.functor \u22d9 L\u2082' := isoWhiskerLeft \u03a6.functor (compUniqFunctor L\u2082 L\u2082' W\u2082)\n        _ \u2245 L\u2081' \u22d9 G' := CatCommSq.iso \u03a6.functor L\u2081' L\u2082' G'\n        _ \u2245 L\u2081 \u22d9 E\u2081.functor \u22d9 G' :=\n              isoWhiskerRight (compUniqFunctor L\u2081 L\u2081' W\u2081).symm G' \u226a\u226b Functor.associator _ _ _\n    exact IsEquivalence.cancelCompLeft E\u2081.functor G' inferInstance\n      (IsEquivalence.ofIso\n        (liftNatIso L\u2081 W\u2081 _ _ (G \u22d9 E\u2082.functor) (E\u2081.functor \u22d9 G') e) inferInstance)", "start": [95, 1], "end": [113, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.nonempty_isEquivalence_iff", "code": "lemma nonempty_isEquivalence_iff : Nonempty (IsEquivalence G) \u2194 Nonempty (IsEquivalence G') := by\n  constructor\n  \u00b7 rintro \u27e8e\u27e9\n    exact \u27e8\u03a6.isEquivalence_imp L\u2081 L\u2082 G L\u2081' L\u2082' G'\u27e9\n  \u00b7 rintro \u27e8e'\u27e9\n    exact \u27e8\u03a6.isEquivalence_imp L\u2081' L\u2082' G' L\u2081 L\u2082 G\u27e9", "start": [115, 1], "end": [120, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence", "code": "class IsLocalizedEquivalence : Prop :=\n  \n  nonempty_isEquivalence : Nonempty (IsEquivalence (\u03a6.localizedFunctor W\u2081.Q W\u2082.Q))", "start": [124, 1], "end": [127, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.mk'", "code": "lemma IsLocalizedEquivalence.mk' [CatCommSq \u03a6.functor L\u2081 L\u2082 G] [IsEquivalence G] :\n    \u03a6.IsLocalizedEquivalence where\n  nonempty_isEquivalence := by\n    rw [\u03a6.nonempty_isEquivalence_iff W\u2081.Q W\u2082.Q (\u03a6.localizedFunctor W\u2081.Q W\u2082.Q) L\u2081 L\u2082 G]\n    exact \u27e8inferInstance\u27e9", "start": [129, 1], "end": [133, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.LocalizerMorphism.isEquivalence", "code": "noncomputable def isEquivalence [h : \u03a6.IsLocalizedEquivalence] [CatCommSq \u03a6.functor L\u2081 L\u2082 G] :\n    IsEquivalence G := Nonempty.some (by\n  rw [\u03a6.nonempty_isEquivalence_iff L\u2081 L\u2082 G W\u2081.Q W\u2082.Q (\u03a6.localizedFunctor W\u2081.Q W\u2082.Q)]\n  exact h.nonempty_isEquivalence)", "start": [135, 1], "end": [140, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.localizedFunctor_isEquivalence", "code": "noncomputable instance localizedFunctor_isEquivalence [\u03a6.IsLocalizedEquivalence] :\n    IsEquivalence (\u03a6.localizedFunctor L\u2081 L\u2082) :=\n  \u03a6.isEquivalence L\u2081 L\u2082 _", "start": [142, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.of_isLocalization_of_isLocalization", "code": "lemma IsLocalizedEquivalence.of_isLocalization_of_isLocalization\n    [(\u03a6.functor \u22d9 L\u2082).IsLocalization W\u2081] :\n    IsLocalizedEquivalence \u03a6 := by\n  have : CatCommSq \u03a6.functor (\u03a6.functor \u22d9 L\u2082) L\u2082 (\ud835\udfed D\u2082) :=\n    CatCommSq.mk (Functor.rightUnitor _).symm\n  exact IsLocalizedEquivalence.mk' \u03a6 (\u03a6.functor \u22d9 L\u2082) L\u2082 (\ud835\udfed D\u2082)", "start": [148, 1], "end": [155, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.LocalizerMorphism.IsLocalizedEquivalence.of_equivalence", "code": "lemma IsLocalizedEquivalence.of_equivalence [IsEquivalence \u03a6.functor]\n    (h : W\u2082 \u2286 W\u2081.map \u03a6.functor) : IsLocalizedEquivalence \u03a6 := by\n  haveI : Functor.IsLocalization (\u03a6.functor \u22d9 MorphismProperty.Q W\u2082) W\u2081 := by\n    refine' Functor.IsLocalization.of_equivalence_source W\u2082.Q W\u2082 (\u03a6.functor \u22d9 W\u2082.Q) W\u2081\n      (Functor.asEquivalence \u03a6.functor).symm _ (\u03a6.inverts W\u2082.Q)\n      ((Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight ((Equivalence.unitIso _).symm) _ \u226a\u226b\n        Functor.leftUnitor _)\n    erw [W\u2081.isoClosure.inverseImage_equivalence_functor_eq_map_inverse\n      W\u2081.isoClosure_respectsIso \u03a6.functor.asEquivalence]\n    rw [MorphismProperty.map_isoClosure]\n    exact h\n  exact IsLocalizedEquivalence.of_isLocalization_of_isLocalization \u03a6 W\u2082.Q", "start": [157, 1], "end": [171, 74], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/NormedSpace/ProdLp.lean", "imports": ["Mathlib/Analysis/MeanInequalities.lean", "Mathlib/Analysis/NormedSpace/WithLp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithLp.zero_fst", "code": "@[simp]\ntheorem zero_fst : (0 : WithLp p (\u03b1 \u00d7 \u03b2)).fst = 0", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.zero_snd", "code": "@[simp]\ntheorem zero_snd : (0 : WithLp p (\u03b1 \u00d7 \u03b2)).snd = 0", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.add_fst", "code": "@[simp]\ntheorem add_fst : (x + y).fst = x.fst + y.fst", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.add_snd", "code": "@[simp]\ntheorem add_snd : (x + y).snd = x.snd + y.snd", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.sub_fst", "code": "@[simp]\ntheorem sub_fst : (x - y).fst = x.fst - y.fst", "start": [75, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.sub_snd", "code": "@[simp]\ntheorem sub_snd : (x - y).snd = x.snd - y.snd", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.neg_fst", "code": "@[simp]\ntheorem neg_fst : (-x).fst = -x.fst", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.neg_snd", "code": "@[simp]\ntheorem neg_snd : (-x).snd = -x.snd", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.smul_fst", "code": "@[simp]\ntheorem smul_fst : (c \u2022 x).fst = c \u2022 x.fst", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.smul_snd", "code": "@[simp]\ntheorem smul_snd : (c \u2022 x).snd = c \u2022 x.snd", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.equiv_fst", "code": "@[simp]\ntheorem equiv_fst (x : WithLp p (\u03b1 \u00d7 \u03b2)) : (WithLp.equiv p (\u03b1 \u00d7 \u03b2) x).fst = x.fst", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.equiv_snd", "code": "@[simp]\ntheorem equiv_snd (x : WithLp p (\u03b1 \u00d7 \u03b2)) : (WithLp.equiv p (\u03b1 \u00d7 \u03b2) x).snd = x.snd", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.equiv_symm_fst", "code": "@[simp]\ntheorem equiv_symm_fst (x : \u03b1 \u00d7 \u03b2) : ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm x).fst = x.fst", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.equiv_symm_snd", "code": "@[simp]\ntheorem equiv_symm_snd (x : \u03b1 \u00d7 \u03b2) : ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm x).snd = x.snd", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdEDist", "code": "instance instProdEDist : EDist (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  edist f g :=\n    if _hp : p = 0 then\n      (if edist f.fst g.fst = 0 then 0 else 1) + (if edist f.snd g.snd = 0 then 0 else 1)\n    else if p = \u221e then\n      edist f.fst g.fst \u2294 edist f.snd g.snd\n    else\n      (edist f.fst g.fst ^ p.toReal + edist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal)", "start": [144, 1], "end": [158, 85], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_eq_card", "code": "@[simp]\ntheorem prod_edist_eq_card (f g : WithLp 0 (\u03b1 \u00d7 \u03b2)) :\n    edist f g =\n      (if edist f.fst g.fst = 0 then 0 else 1) + (if edist f.snd g.snd = 0 then 0 else 1)", "start": [163, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_eq_add", "code": "theorem prod_edist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    edist f g = (edist f.fst g.fst ^ p.toReal + edist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal)", "start": [169, 1], "end": [172, 45], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_eq_sup", "code": "theorem prod_edist_eq_sup (f g : WithLp \u221e (\u03b1 \u00d7 \u03b2)) :\n    edist f g = edist f.fst g.fst \u2294 edist f.snd g.snd", "start": [174, 1], "end": [177, 35], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_self", "code": "theorem prod_edist_self (f : WithLp p (\u03b1 \u00d7 \u03b2)) : edist f f = 0", "start": [186, 1], "end": [196, 49], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_comm", "code": "theorem prod_edist_comm (f g : WithLp p (\u03b1 \u00d7 \u03b2)) : edist f g = edist g f", "start": [198, 1], "end": [207, 48], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdDist", "code": "instance instProdDist : Dist (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  dist f g :=\n    if _hp : p = 0 then\n      (if dist f.fst g.fst = 0 then 0 else 1) + (if dist f.snd g.snd = 0 then 0 else 1)\n    else if p = \u221e then\n      dist f.fst g.fst \u2294 dist f.snd g.snd\n    else\n      (dist f.fst g.fst ^ p.toReal + dist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal)", "start": [216, 1], "end": [230, 83], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_dist_eq_card", "code": "theorem prod_dist_eq_card (f g : WithLp 0 (\u03b1 \u00d7 \u03b2)) : dist f g =\n    (if dist f.fst g.fst = 0 then 0 else 1) + (if dist f.snd g.snd = 0 then 0 else 1)", "start": [234, 1], "end": [236, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_dist_eq_add", "code": "theorem prod_dist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    dist f g = (dist f.fst g.fst ^ p.toReal + dist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal)", "start": [238, 1], "end": [241, 45], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_dist_eq_sup", "code": "theorem prod_dist_eq_sup (f g : WithLp \u221e (\u03b1 \u00d7 \u03b2)) :\n    dist f g = dist f.fst g.fst \u2294 dist f.snd g.snd", "start": [243, 1], "end": [246, 35], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdNorm", "code": "instance instProdNorm : Norm (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  norm f :=\n    if _hp : p = 0 then\n      (if \u2016f.fst\u2016 = 0 then 0 else 1) + (if \u2016f.snd\u2016 = 0 then 0 else 1)\n    else if p = \u221e then\n      \u2016f.fst\u2016 \u2294 \u2016f.snd\u2016\n    else\n      (\u2016f.fst\u2016 ^ p.toReal + \u2016f.snd\u2016 ^ p.toReal) ^ (1 / p.toReal)", "start": [255, 1], "end": [268, 65], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_eq_card", "code": "@[simp]\ntheorem prod_norm_eq_card (f : WithLp 0 (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016 = (if \u2016f.fst\u2016 = 0 then 0 else 1) + (if \u2016f.snd\u2016 = 0 then 0 else 1)", "start": [272, 1], "end": [275, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_eq_sup", "code": "theorem prod_norm_eq_sup (f : WithLp \u221e (\u03b1 \u00d7 \u03b2)) : \u2016f\u2016 = \u2016f.fst\u2016 \u2294 \u2016f.snd\u2016", "start": [277, 1], "end": [279, 35], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_eq_add", "code": "theorem prod_norm_eq_add (hp : 0 < p.toReal) (f : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016 = (\u2016f.fst\u2016 ^ p.toReal + \u2016f.snd\u2016 ^ p.toReal) ^ (1 / p.toReal)", "start": [281, 1], "end": [284, 45], "kind": "commanddeclaration"}, {"full_name": "WithLp.prodPseudoEMetricAux", "code": "def prodPseudoEMetricAux [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    PseudoEMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  edist_self := prod_edist_self p\n  edist_comm := prod_edist_comm p\n  edist_triangle f g h := by\n    rcases p.dichotomy with (rfl | hp)\n    \u00b7 simp only [prod_edist_eq_sup]\n      exact sup_le ((edist_triangle _ g.fst _).trans <| add_le_add le_sup_left le_sup_left)\n        ((edist_triangle _ g.snd _).trans <| add_le_add le_sup_right le_sup_right)\n    \u00b7 simp only [prod_edist_eq_add (zero_lt_one.trans_le hp)]\n      calc\n        (edist f.fst h.fst ^ p.toReal + edist f.snd h.snd ^ p.toReal) ^ (1 / p.toReal) \u2264\n            ((edist f.fst g.fst + edist g.fst h.fst) ^ p.toReal +\n              (edist f.snd g.snd + edist g.snd h.snd) ^ p.toReal) ^ (1 / p.toReal) := by\n          apply ENNReal.rpow_le_rpow _ (one_div_nonneg.2 <| zero_le_one.trans hp)\n          exact add_le_add (ENNReal.rpow_le_rpow (edist_triangle _ _ _) (zero_le_one.trans hp))\n            (ENNReal.rpow_le_rpow (edist_triangle _ _ _) (zero_le_one.trans hp))\n        _ \u2264\n            (edist f.fst g.fst ^ p.toReal + edist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal) +\n              (edist g.fst h.fst ^ p.toReal + edist g.snd h.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          have := ENNReal.Lp_add_le {0, 1}\n            (if \u00b7 = 0 then edist f.fst g.fst else edist f.snd g.snd)\n            (if \u00b7 = 0 then edist g.fst h.fst else edist g.snd h.snd) hp\n          simp only [Finset.mem_singleton, not_false_eq_true, Finset.sum_insert,\n            Finset.sum_singleton] at this\n          exact this", "start": [309, 1], "end": [340, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_sup_edist_ne_top_aux", "code": "theorem prod_sup_edist_ne_top_aux [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    (f g : WithLp \u221e (\u03b1 \u00d7 \u03b2)) :\n    edist f.fst g.fst \u2294 edist f.snd g.snd \u2260 \u22a4", "start": [346, 1], "end": [351, 60], "kind": "commanddeclaration"}, {"full_name": "WithLp.prodPseudoMetricAux", "code": "@[reducible]\ndef prodPseudoMetricAux [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] :\n    PseudoMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  PseudoEMetricSpace.toPseudoMetricSpaceOfDist dist\n    (fun f g => by\n      rcases p.dichotomy with (rfl | h)\n      \u00b7 exact prod_sup_edist_ne_top_aux f g\n      \u00b7 rw [prod_edist_eq_add (zero_lt_one.trans_le h)]\n        refine ENNReal.rpow_ne_top_of_nonneg (by positivity) (ne_of_lt ?_)\n        simp [ENNReal.add_lt_top, ENNReal.rpow_lt_top_of_nonneg, edist_ne_top] )\n    fun f g => by\n    rcases p.dichotomy with (rfl | h)\n    \u00b7 rw [prod_edist_eq_sup, prod_dist_eq_sup]\n      refine' le_antisymm (sup_le _ _) _\n      \u00b7 rw [\u2190 ENNReal.ofReal_le_iff_le_toReal (prod_sup_edist_ne_top_aux f g),\n          \u2190 PseudoMetricSpace.edist_dist]\n        exact le_sup_left\n      \u00b7 rw [\u2190 ENNReal.ofReal_le_iff_le_toReal (prod_sup_edist_ne_top_aux f g),\n          \u2190 PseudoMetricSpace.edist_dist]\n        exact le_sup_right\n      \u00b7 refine ENNReal.toReal_le_of_le_ofReal ?_ ?_\n        \u00b7 simp only [ge_iff_le, le_sup_iff, dist_nonneg]\n        \u00b7 simp [edist, PseudoMetricSpace.edist_dist, ENNReal.ofReal_le_ofReal]\n    \u00b7 have h1 : edist f.fst g.fst ^ p.toReal \u2260 \u22a4 :=\n        ENNReal.rpow_ne_top_of_nonneg (zero_le_one.trans h) (edist_ne_top _ _)\n      have h2 : edist f.snd g.snd ^ p.toReal \u2260 \u22a4 :=\n        ENNReal.rpow_ne_top_of_nonneg (zero_le_one.trans h) (edist_ne_top _ _)\n      simp only [prod_edist_eq_add (zero_lt_one.trans_le h), dist_edist, ENNReal.toReal_rpow,\n        prod_dist_eq_add (zero_lt_one.trans_le h), \u2190 ENNReal.toReal_add h1 h2]", "start": [355, 1], "end": [392, 79], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_lipschitzWith_equiv_aux", "code": "theorem prod_lipschitzWith_equiv_aux [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    LipschitzWith 1 (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [396, 1], "end": [416, 39], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_antilipschitzWith_equiv_aux", "code": "theorem prod_antilipschitzWith_equiv_aux [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    AntilipschitzWith ((2 : \u211d\u22650) ^ (1 / p).toReal) (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [418, 1], "end": [439, 78], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_aux_uniformity_eq", "code": "theorem prod_aux_uniformity_eq [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    \ud835\udce4 (WithLp p (\u03b1 \u00d7 \u03b2)) = \ud835\udce4[instUniformSpaceProd]", "start": [441, 1], "end": [449, 44], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_aux_cobounded_eq", "code": "theorem prod_aux_cobounded_eq [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] :\n    cobounded (WithLp p (\u03b1 \u00d7 \u03b2)) = @cobounded _ Prod.instBornology", "start": [451, 1], "end": [457, 22], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdTopologicalSpace", "code": "instance instProdTopologicalSpace : TopologicalSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  instTopologicalSpaceProd", "start": [467, 1], "end": [468, 27], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_continuous_equiv", "code": "@[continuity]\ntheorem prod_continuous_equiv : Continuous (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [470, 1], "end": [472, 16], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_continuous_equiv_symm", "code": "@[continuity]\ntheorem prod_continuous_equiv_symm : Continuous (WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm", "start": [474, 1], "end": [476, 16], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdT0Space", "code": "instance instProdT0Space : T0Space (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  Prod.instT0Space", "start": [480, 1], "end": [481, 19], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdUniformSpace", "code": "instance instProdUniformSpace : UniformSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  instUniformSpaceProd", "start": [489, 1], "end": [490, 23], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_uniformContinuous_equiv", "code": "theorem prod_uniformContinuous_equiv : UniformContinuous (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [492, 1], "end": [493, 23], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_uniformContinuous_equiv_symm", "code": "theorem prod_uniformContinuous_equiv_symm : UniformContinuous (WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm", "start": [495, 1], "end": [496, 23], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdCompleteSpace", "code": "instance instProdCompleteSpace : CompleteSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  CompleteSpace.prod", "start": [500, 1], "end": [501, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdBornology", "code": "instance instProdBornology [Bornology \u03b1] [Bornology \u03b2] : Bornology (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  Prod.instBornology", "start": [505, 1], "end": [506, 21], "kind": "commanddeclaration"}, {"full_name": "WithLp.prodContinuousLinearEquiv", "code": "@[simps! (config := { fullyApplied := false }) apply symm_apply]\nprotected def prodContinuousLinearEquiv : WithLp p (\u03b1 \u00d7 \u03b2) \u2243L[\ud835\udd5c] \u03b1 \u00d7 \u03b2 where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := prod_continuous_equiv _ _ _\n  continuous_invFun := prod_continuous_equiv_symm _ _ _", "start": [514, 1], "end": [519, 56], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdPseudoEMetricSpace", "code": "instance instProdPseudoEMetricSpace [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    PseudoEMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  (prodPseudoEMetricAux p \u03b1 \u03b2).replaceUniformity (prod_aux_uniformity_eq p \u03b1 \u03b2).symm", "start": [526, 1], "end": [530, 85], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdEMetricSpace", "code": "instance instProdEMetricSpace [EMetricSpace \u03b1] [EMetricSpace \u03b2] : EMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  EMetricSpace.ofT0PseudoEMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2))", "start": [532, 1], "end": [535, 57], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdPseudoMetricSpace", "code": "instance instProdPseudoMetricSpace [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] :\n    PseudoMetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  ((prodPseudoMetricAux p \u03b1 \u03b2).replaceUniformity\n    (prod_aux_uniformity_eq p \u03b1 \u03b2).symm).replaceBornology\n    fun s => Filter.ext_iff.1 (prod_aux_cobounded_eq p \u03b1 \u03b2).symm s\u1d9c", "start": [537, 1], "end": [543, 68], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdMetricSpace", "code": "instance instProdMetricSpace [MetricSpace \u03b1] [MetricSpace \u03b2] : MetricSpace (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  MetricSpace.ofT0PseudoMetricSpace _", "start": [545, 1], "end": [548, 38], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nndist_eq_add", "code": "theorem prod_nndist_eq_add [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    (hp : p \u2260 \u221e) (x y : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    nndist x y = (nndist x.fst y.fst ^ p.toReal + nndist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal)", "start": [552, 1], "end": [557, 64], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nndist_eq_sup", "code": "theorem prod_nndist_eq_sup [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (x y : WithLp \u221e (\u03b1 \u00d7 \u03b2)) :\n    nndist x y = nndist x.fst y.fst \u2294 nndist x.snd y.snd", "start": [559, 1], "end": [563, 31], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_lipschitzWith_equiv", "code": "theorem prod_lipschitzWith_equiv [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    LipschitzWith 1 (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [567, 1], "end": [569, 37], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_antilipschitzWith_equiv", "code": "theorem prod_antilipschitzWith_equiv [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    AntilipschitzWith ((2 : \u211d\u22650) ^ (1 / p).toReal) (WithLp.equiv p (\u03b1 \u00d7 \u03b2))", "start": [571, 1], "end": [573, 41], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_infty_equiv_isometry", "code": "theorem prod_infty_equiv_isometry [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    Isometry (WithLp.equiv \u221e (\u03b1 \u00d7 \u03b2))", "start": [575, 1], "end": [581, 63], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdSeminormedAddCommGroup", "code": "instance instProdSeminormedAddCommGroup [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] :\n    SeminormedAddCommGroup (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  dist_eq x y := by\n    rcases p.dichotomy with (rfl | h)\n    \u00b7 simp only [prod_dist_eq_sup, prod_norm_eq_sup, dist_eq_norm]\n      rfl\n    \u00b7 simp only [prod_dist_eq_add (zero_lt_one.trans_le h),\n        prod_norm_eq_add (zero_lt_one.trans_le h), dist_eq_norm]\n      rfl", "start": [583, 1], "end": [593, 10], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdNormedAddCommGroup", "code": "instance instProdNormedAddCommGroup [NormedAddCommGroup \u03b1] [NormedAddCommGroup \u03b2] :\n    NormedAddCommGroup (WithLp p (\u03b1 \u00d7 \u03b2)) :=\n  { instProdSeminormedAddCommGroup p \u03b1 \u03b2 with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [595, 1], "end": [599, 47], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_eq_of_nat", "code": "theorem prod_norm_eq_of_nat [Norm \u03b1] [Norm \u03b2] (n : \u2115) (h : p = n) (f : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016 = (\u2016f.fst\u2016 ^ n + \u2016f.snd\u2016 ^ n) ^ (1 / (n : \u211d))", "start": [618, 1], "end": [622, 27], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nnnorm_eq_add", "code": "theorem prod_nnnorm_eq_add (hp : p \u2260 \u221e) (f : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016\u208a = (\u2016f.fst\u2016\u208a ^ p.toReal + \u2016f.snd\u2016\u208a ^ p.toReal) ^ (1 / p.toReal)", "start": [626, 1], "end": [629, 59], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nnnorm_eq_sup", "code": "theorem prod_nnnorm_eq_sup (f : WithLp \u221e (\u03b1 \u00d7 \u03b2)) : \u2016f\u2016\u208a = \u2016f.fst\u2016\u208a \u2294  \u2016f.snd\u2016\u208a", "start": [631, 1], "end": [633, 12], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_eq_of_L2", "code": "theorem prod_norm_eq_of_L2 (x : WithLp 2 (\u03b1 \u00d7 \u03b2)) : \u2016x\u2016 = sqrt (\u2016x.fst\u2016 ^ 2 + \u2016x.snd\u2016 ^ 2)", "start": [635, 1], "end": [637, 12], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nnnorm_eq_of_L2", "code": "theorem prod_nnnorm_eq_of_L2 (x : WithLp 2 (\u03b1 \u00d7 \u03b2)) :\n    \u2016x\u2016\u208a = NNReal.sqrt (\u2016x.fst\u2016\u208a ^ 2 + \u2016x.snd\u2016\u208a ^ 2)", "start": [639, 1], "end": [643, 31], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_norm_sq_eq_of_L2", "code": "theorem prod_norm_sq_eq_of_L2 (x : WithLp 2 (\u03b1 \u00d7 \u03b2)) : \u2016x\u2016 ^ 2 = \u2016x.fst\u2016 ^ 2 + \u2016x.snd\u2016 ^ 2", "start": [645, 1], "end": [648, 44], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_dist_eq_of_L2", "code": "theorem prod_dist_eq_of_L2 (x y : WithLp 2 (\u03b1 \u00d7 \u03b2)) :\n    dist x y = (dist x.fst y.fst ^ 2 + dist x.snd y.snd ^ 2).sqrt", "start": [650, 1], "end": [653, 6], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_nndist_eq_of_L2", "code": "theorem prod_nndist_eq_of_L2 (x y : WithLp 2 (\u03b1 \u00d7 \u03b2)) :\n    nndist x y = NNReal.sqrt (nndist x.fst y.fst ^ 2 + nndist x.snd y.snd ^ 2)", "start": [655, 1], "end": [659, 33], "kind": "commanddeclaration"}, {"full_name": "WithLp.prod_edist_eq_of_L2", "code": "theorem prod_edist_eq_of_L2 (x y : WithLp 2 (\u03b1 \u00d7 \u03b2)) :\n    edist x y = (edist x.fst y.fst ^ 2 + edist x.snd y.snd ^ 2) ^ (1 / 2 : \u211d)", "start": [661, 1], "end": [663, 27], "kind": "commanddeclaration"}, {"full_name": "WithLp.nnnorm_equiv_symm_fst", "code": "@[simp]\ntheorem nnnorm_equiv_symm_fst (x : \u03b1) :\n    \u2016(WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x, 0)\u2016\u208a = \u2016x\u2016\u208a", "start": [671, 1], "end": [680, 91], "kind": "commanddeclaration"}, {"full_name": "WithLp.nnnorm_equiv_symm_snd", "code": "@[simp]\ntheorem nnnorm_equiv_symm_snd (y : \u03b2) :\n    \u2016(WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y)\u2016\u208a = \u2016y\u2016\u208a", "start": [682, 1], "end": [691, 91], "kind": "commanddeclaration"}, {"full_name": "WithLp.norm_equiv_symm_fst", "code": "@[simp]\ntheorem norm_equiv_symm_fst (x : \u03b1) : \u2016(WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x, 0)\u2016 = \u2016x\u2016", "start": [693, 1], "end": [695, 61], "kind": "commanddeclaration"}, {"full_name": "WithLp.norm_equiv_symm_snd", "code": "@[simp]\ntheorem norm_equiv_symm_snd (y : \u03b2) : \u2016(WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y)\u2016 = \u2016y\u2016", "start": [697, 1], "end": [699, 61], "kind": "commanddeclaration"}, {"full_name": "WithLp.nndist_equiv_symm_fst", "code": "@[simp]\ntheorem nndist_equiv_symm_fst (x\u2081 x\u2082 : \u03b1) :\n    nndist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2081, 0)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2082, 0)) =\n      nndist x\u2081 x\u2082", "start": [701, 1], "end": [706, 27], "kind": "commanddeclaration"}, {"full_name": "WithLp.nndist_equiv_symm_snd", "code": "@[simp]\ntheorem nndist_equiv_symm_snd (y\u2081 y\u2082 : \u03b2) :\n    nndist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2081)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2082)) =\n      nndist y\u2081 y\u2082", "start": [708, 1], "end": [713, 27], "kind": "commanddeclaration"}, {"full_name": "WithLp.dist_equiv_symm_fst", "code": "@[simp]\ntheorem dist_equiv_symm_fst (x\u2081 x\u2082 : \u03b1) :\n    dist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2081, 0)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2082, 0)) =\n      dist x\u2081 x\u2082", "start": [715, 1], "end": [719, 65], "kind": "commanddeclaration"}, {"full_name": "WithLp.dist_equiv_symm_snd", "code": "@[simp]\ntheorem dist_equiv_symm_snd (y\u2081 y\u2082 : \u03b2) :\n    dist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2081)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2082)) =\n      dist y\u2081 y\u2082", "start": [721, 1], "end": [725, 65], "kind": "commanddeclaration"}, {"full_name": "WithLp.edist_equiv_symm_fst", "code": "@[simp]\ntheorem edist_equiv_symm_fst (x\u2081 x\u2082 : \u03b1) :\n    edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2081, 0)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (x\u2082, 0)) =\n      edist x\u2081 x\u2082", "start": [727, 1], "end": [731, 62], "kind": "commanddeclaration"}, {"full_name": "WithLp.edist_equiv_symm_snd", "code": "@[simp]\ntheorem edist_equiv_symm_snd (y\u2081 y\u2082 : \u03b2) :\n    edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2081)) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)).symm (0, y\u2082)) =\n      edist y\u2081 y\u2082", "start": [733, 1], "end": [737, 62], "kind": "commanddeclaration"}, {"full_name": "WithLp.instProdNormedSpace", "code": "instance instProdNormedSpace : NormedSpace \ud835\udd5c (WithLp p (\u03b1 \u00d7 \u03b2)) where\n  norm_smul_le c f := by\n    rcases p.dichotomy with (rfl | hp)\n    \u00b7 suffices \u2016c \u2022 f\u2016\u208a = \u2016c\u2016\u208a * \u2016f\u2016\u208a by exact_mod_cast NNReal.coe_mono this.le\n      simp only [prod_nnnorm_eq_sup, NNReal.mul_sup, \u2190 nnnorm_smul]\n      rfl\n    \u00b7 have : p.toReal * (1 / p.toReal) = 1 := mul_div_cancel' 1 (zero_lt_one.trans_le hp).ne'\n      have smul_fst : (c \u2022 f).fst = c \u2022 f.fst := rfl\n      have smul_snd : (c \u2022 f).snd = c \u2022 f.snd := rfl\n      simp only [prod_norm_eq_add (zero_lt_one.trans_le hp), norm_smul, Real.mul_rpow,\n        norm_nonneg, smul_fst, smul_snd]\n      rw [\u2190 mul_add, mul_rpow (rpow_nonneg_of_nonneg (norm_nonneg _) _),\n        \u2190 rpow_mul (norm_nonneg _), this, Real.rpow_one]\n      positivity", "start": [745, 1], "end": [759, 17], "kind": "commanddeclaration"}, {"full_name": "WithLp.prodEquiv\u2097\u1d62", "code": "def prodEquiv\u2097\u1d62 : WithLp \u221e (\u03b1 \u00d7 \u03b2) \u2243\u2097\u1d62[\ud835\udd5c] \u03b1 \u00d7 \u03b2 where\n  __ := WithLp.equiv \u221e (\u03b1 \u00d7 \u03b2)\n  map_add' f g := rfl\n  map_smul' c f := rfl\n  norm_map' f := by simp [Norm.norm]", "start": [763, 1], "end": [769, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/SalemSpencer.lean", "imports": ["Mathlib/Analysis/Convex/StrictConvexSpace.lean", "Mathlib/Algebra/Hom/Freiman.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulSalemSpencer", "code": "@[to_additive \"A Salem-Spencer, aka non averaging, set `s` in an additive monoid\nis a set such that the average of any two distinct elements is not in the set.\"]\ndef MulSalemSpencer : Prop :=\n  \u2200 \u2983a b c\u2984, a \u2208 s \u2192 b \u2208 s \u2192 c \u2208 s \u2192 a * b = c * c \u2192 a = b", "start": [58, 1], "end": [63, 59], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.mono", "code": "@[to_additive]\ntheorem MulSalemSpencer.mono (h : t \u2286 s) (hs : MulSalemSpencer s) : MulSalemSpencer t", "start": [76, 1], "end": [78, 48], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_empty", "code": "@[to_additive (attr := simp)]\ntheorem mulSalemSpencer_empty : MulSalemSpencer (\u2205 : Set \u03b1)", "start": [82, 1], "end": [83, 87], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.mulSalemSpencer", "code": "@[to_additive]\ntheorem Set.Subsingleton.mulSalemSpencer (hs : s.Subsingleton) : MulSalemSpencer s", "start": [87, 1], "end": [89, 34], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_singleton", "code": "@[to_additive (attr := simp)]\ntheorem mulSalemSpencer_singleton (a : \u03b1) : MulSalemSpencer ({a} : Set \u03b1)", "start": [93, 1], "end": [95, 41], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.prod", "code": "@[to_additive AddSalemSpencer.prod]\ntheorem MulSalemSpencer.prod {t : Set \u03b2} (hs : MulSalemSpencer s) (ht : MulSalemSpencer t) :\n    MulSalemSpencer (s \u00d7\u02e2 t)", "start": [99, 1], "end": [102, 93], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_pi", "code": "@[to_additive]\ntheorem mulSalemSpencer_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Monoid (\u03b1 i)] {s : \u2200 i, Set (\u03b1 i)}\n    (hs : \u2200 i, MulSalemSpencer (s i)) : MulSalemSpencer ((univ : Set \u03b9).pi s)", "start": [106, 1], "end": [110, 85], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.of_image", "code": "@[to_additive]\ntheorem MulSalemSpencer.of_image [FunLike F \u03b1 fun _ => \u03b2] [FreimanHomClass F s \u03b2 2] (f : F)\n    (hf : s.InjOn f) (h : MulSalemSpencer (f '' s)) : MulSalemSpencer s", "start": [120, 1], "end": [125, 52], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.image", "code": "@[to_additive]\ntheorem MulSalemSpencer.image [MulHomClass F \u03b1 \u03b2] (f : F) (hf : (s * s).InjOn f)\n    (h : MulSalemSpencer s) : MulSalemSpencer (f '' s)", "start": [130, 1], "end": [134, 92], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_insert", "code": "@[to_additive]\ntheorem mulSalemSpencer_insert : MulSalemSpencer (insert a s) \u2194 MulSalemSpencer s \u2227\n    (\u2200 \u2983b c\u2984, b \u2208 s \u2192 c \u2208 s \u2192 a * b = c * c \u2192 a = b) \u2227\n    \u2200 \u2983b c\u2984, b \u2208 s \u2192 c \u2208 s \u2192 b * c = a * a \u2192 b = c", "start": [144, 1], "end": [161, 24], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_pair", "code": "@[to_additive (attr := simp)]\ntheorem mulSalemSpencer_pair (a b : \u03b1) : MulSalemSpencer ({a, b} : Set \u03b1)", "start": [165, 1], "end": [172, 8], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.mul_left", "code": "@[to_additive]\ntheorem MulSalemSpencer.mul_left (hs : MulSalemSpencer s) : MulSalemSpencer ((\u00b7 * \u00b7) a '' s)", "start": [176, 1], "end": [180, 39], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.mul_right", "code": "@[to_additive]\ntheorem MulSalemSpencer.mul_right (hs : MulSalemSpencer s) : MulSalemSpencer ((\u00b7 * a) '' s)", "start": [184, 1], "end": [188, 40], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_mul_left_iff", "code": "@[to_additive]\ntheorem mulSalemSpencer_mul_left_iff : MulSalemSpencer ((\u00b7 * \u00b7) a '' s) \u2194 MulSalemSpencer s", "start": [192, 1], "end": [198, 30], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_mul_right_iff", "code": "@[to_additive]\ntheorem mulSalemSpencer_mul_right_iff : MulSalemSpencer ((\u00b7 * a) '' s) \u2194 MulSalemSpencer s", "start": [202, 1], "end": [208, 31], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_insert_of_lt", "code": "@[to_additive]\ntheorem mulSalemSpencer_insert_of_lt (hs : \u2200 i \u2208 s, i < a) :\n    MulSalemSpencer (insert a s) \u2194\n      MulSalemSpencer s \u2227 \u2200 \u2983b c\u2984, b \u2208 s \u2192 c \u2208 s \u2192 a * b = c * c \u2192 a = b", "start": [218, 1], "end": [224, 97], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.mul_left\u2080", "code": "theorem MulSalemSpencer.mul_left\u2080 (hs : MulSalemSpencer s) (ha : a \u2260 0) :\n    MulSalemSpencer ((\u00b7 * \u00b7) a '' s)", "start": [234, 1], "end": [238, 60], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.mul_right\u2080", "code": "theorem MulSalemSpencer.mul_right\u2080 (hs : MulSalemSpencer s) (ha : a \u2260 0) :\n    MulSalemSpencer ((\u00b7 * a) '' s)", "start": [241, 1], "end": [245, 61], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_mul_left_iff\u2080", "code": "theorem mulSalemSpencer_mul_left_iff\u2080 (ha : a \u2260 0) :\n    MulSalemSpencer ((\u00b7 * \u00b7) a '' s) \u2194 MulSalemSpencer s", "start": [248, 1], "end": [254, 31], "kind": "commanddeclaration"}, {"full_name": "mulSalemSpencer_mul_right_iff\u2080", "code": "theorem mulSalemSpencer_mul_right_iff\u2080 (ha : a \u2260 0) :\n    MulSalemSpencer ((\u00b7 * a) '' s) \u2194 MulSalemSpencer s", "start": [257, 1], "end": [263, 32], "kind": "commanddeclaration"}, {"full_name": "addSalemSpencer_iff_eq_right", "code": "theorem addSalemSpencer_iff_eq_right {s : Set \u2115} :\n    AddSalemSpencer s \u2194 \u2200 \u2983a b c\u2984, a \u2208 s \u2192 b \u2208 s \u2192 c \u2208 s \u2192 a + b = c + c \u2192 a = c", "start": [270, 1], "end": [277, 38], "kind": "commanddeclaration"}, {"full_name": "addSalemSpencer_frontier", "code": "theorem addSalemSpencer_frontier [LinearOrderedField \ud835\udd5c] [TopologicalSpace E] [AddCommMonoid E]\n    [Module \ud835\udd5c E] {s : Set E} (hs\u2080 : IsClosed s) (hs\u2081 : StrictConvex \ud835\udd5c s) :\n    AddSalemSpencer (frontier s)", "start": [282, 1], "end": [293, 26], "kind": "commanddeclaration"}, {"full_name": "addSalemSpencer_sphere", "code": "theorem addSalemSpencer_sphere [NormedAddCommGroup E] [NormedSpace \u211d E] [StrictConvexSpace \u211d E]\n    (x : E) (r : \u211d) : AddSalemSpencer (sphere x r)", "start": [296, 1], "end": [302, 42], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber", "code": "@[to_additive \"The additive Roth number of a finset is the cardinality of its biggest additive\nSalem-Spencer subset. The usual Roth number corresponds to `addRothNumber (Finset.range n)`, see\n`rothNumberNat`. \"]\ndef mulRothNumber : Finset \u03b1 \u2192o \u2115 :=\n  \u27e8fun s =>\n    Nat.findGreatest (fun m => \u2203 (t : _) (_ : t \u2286 s), t.card = m \u2227 MulSalemSpencer (t : Set \u03b1))\n      s.card, by\n    rintro t u htu\n    refine' Nat.findGreatest_mono (fun m => _) (card_le_of_subset htu)\n    rintro \u27e8v, hvt, hv\u27e9\n    exact \u27e8v, hvt.trans htu, hv\u27e9\u27e9", "start": [317, 1], "end": [329, 34], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_le", "code": "@[to_additive]\ntheorem mulRothNumber_le : mulRothNumber s \u2264 s.card", "start": [333, 1], "end": [334, 82], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_spec", "code": "@[to_additive]\ntheorem mulRothNumber_spec :\n    \u2203 (t : _) (_ : t \u2286 s), t.card = mulRothNumber s \u2227 MulSalemSpencer (t : Set \u03b1)", "start": [338, 1], "end": [343, 79], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.le_mulRothNumber", "code": "@[to_additive]\ntheorem MulSalemSpencer.le_mulRothNumber (hs : MulSalemSpencer (s : Set \u03b1)) (h : s \u2286 t) :\n    s.card \u2264 mulRothNumber t", "start": [349, 1], "end": [352, 56], "kind": "commanddeclaration"}, {"full_name": "MulSalemSpencer.roth_number_eq", "code": "@[to_additive]\ntheorem MulSalemSpencer.roth_number_eq (hs : MulSalemSpencer (s : Set \u03b1)) :\n    mulRothNumber s = s.card", "start": [356, 1], "end": [359, 72], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_empty", "code": "@[to_additive (attr := simp)]\ntheorem mulRothNumber_empty : mulRothNumber (\u2205 : Finset \u03b1) = 0", "start": [363, 1], "end": [365, 69], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_singleton", "code": "@[to_additive (attr := simp)]\ntheorem mulRothNumber_singleton (a : \u03b1) : mulRothNumber ({a} : Finset \u03b1) = 1", "start": [369, 1], "end": [373, 36], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_union_le", "code": "@[to_additive]\ntheorem mulRothNumber_union_le (s t : Finset \u03b1) :\n    mulRothNumber (s \u222a t) \u2264 mulRothNumber s + mulRothNumber t", "start": [377, 1], "end": [387, 86], "kind": "commanddeclaration"}, {"full_name": "le_mulRothNumber_product", "code": "@[to_additive]\ntheorem le_mulRothNumber_product (s : Finset \u03b1) (t : Finset \u03b2) :\n    mulRothNumber s * mulRothNumber t \u2264 mulRothNumber (s \u00d7\u02e2 t)", "start": [391, 1], "end": [399, 19], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_lt_of_forall_not_mulSalemSpencer", "code": "@[to_additive]\ntheorem mulRothNumber_lt_of_forall_not_mulSalemSpencer\n    (h : \u2200 t \u2208 powersetCard n s, \u00acMulSalemSpencer ((t : Finset \u03b1) : Set \u03b1)) :\n    mulRothNumber s < n", "start": [403, 1], "end": [411, 68], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_map_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_left :\n    mulRothNumber (s.map <| mulLeftEmbedding a) = mulRothNumber s", "start": [421, 1], "end": [436, 25], "kind": "commanddeclaration"}, {"full_name": "mulRothNumber_map_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_right :\n    mulRothNumber (s.map <| mulRightEmbedding a) = mulRothNumber s", "start": [440, 1], "end": [443, 79], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat", "code": "def rothNumberNat : \u2115 \u2192o \u2115 :=\n  \u27e8fun n => addRothNumber (range n), addRothNumber.mono.comp range_mono\u27e9", "start": [455, 1], "end": [463, 73], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_def", "code": "theorem rothNumberNat_def (n : \u2115) : rothNumberNat n = addRothNumber (range n)", "start": [466, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_le", "code": "theorem rothNumberNat_le (N : \u2115) : rothNumberNat N \u2264 N", "start": [470, 1], "end": [471, 47], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_spec", "code": "theorem rothNumberNat_spec (n : \u2115) :\n    \u2203 (t : _) (_ : t \u2286 range n), t.card = rothNumberNat n \u2227 AddSalemSpencer (t : Set \u2115)", "start": [474, 1], "end": [476, 23], "kind": "commanddeclaration"}, {"full_name": "AddSalemSpencer.le_rothNumberNat", "code": "theorem AddSalemSpencer.le_rothNumberNat (s : Finset \u2115) (hs : AddSalemSpencer (s : Set \u2115))\n    (hsn : \u2200 x \u2208 s, x < n) (hsk : s.card = k) : k \u2264 rothNumberNat n", "start": [479, 1], "end": [483, 74], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_add_le", "code": "theorem rothNumberNat_add_le (M N : \u2115) :\n    rothNumberNat (M + N) \u2264 rothNumberNat M + rothNumberNat N", "start": [486, 1], "end": [493, 35], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_zero", "code": "@[simp]\ntheorem rothNumberNat_zero : rothNumberNat 0 = 0", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "addRothNumber_Ico", "code": "theorem addRothNumber_Ico (a b : \u2115) : addRothNumber (Ico a b) = rothNumberNat (b - a)", "start": [501, 1], "end": [507, 39], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_isBigOWith_id", "code": "theorem rothNumberNat_isBigOWith_id :\n    IsBigOWith 1 atTop (fun N => (rothNumberNat N : \u211d)) fun N => (N : \u211d)", "start": [512, 1], "end": [514, 94], "kind": "commanddeclaration"}, {"full_name": "rothNumberNat_isBigO_id", "code": "theorem rothNumberNat_isBigO_id : (fun N => (rothNumberNat N : \u211d)) =O[atTop] fun N => (N : \u211d)", "start": [518, 1], "end": [520, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/ExponentialBounds.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "Mathlib/Data/Complex/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.exp_one_near_10", "code": "theorem exp_one_near_10 : |exp 1 - 2244083 / 825552| \u2264 1 / 10 ^ 10", "start": [20, 1], "end": [25, 48], "kind": "commanddeclaration"}, {"full_name": "Real.exp_one_near_20", "code": "theorem exp_one_near_20 : |exp 1 - 363916618873 / 133877442384| \u2264 1 / 10 ^ 20", "start": [28, 1], "end": [33, 48], "kind": "commanddeclaration"}, {"full_name": "Real.exp_one_gt_d9", "code": "theorem exp_one_gt_d9 : 2.7182818283 < exp 1", "start": [36, 1], "end": [37, 84], "kind": "commanddeclaration"}, {"full_name": "Real.exp_one_lt_d9", "code": "theorem exp_one_lt_d9 : exp 1 < 2.7182818286", "start": [40, 1], "end": [41, 90], "kind": "commanddeclaration"}, {"full_name": "Real.exp_neg_one_gt_d9", "code": "theorem exp_neg_one_gt_d9 : 0.36787944116 < exp (-1)", "start": [44, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Real.exp_neg_one_lt_d9", "code": "theorem exp_neg_one_lt_d9 : exp (-1) < 0.3678794412", "start": [50, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Real.log_two_near_10", "code": "theorem log_two_near_10 : |log 2 - 287209 / 414355| \u2264 1 / 10 ^ 10", "start": [56, 1], "end": [68, 31], "kind": "commanddeclaration"}, {"full_name": "Real.log_two_gt_d9", "code": "theorem log_two_gt_d9 : 0.6931471803 < log 2", "start": [71, 1], "end": [72, 85], "kind": "commanddeclaration"}, {"full_name": "Real.log_two_lt_d9", "code": "theorem log_two_lt_d9 : log 2 < 0.6931471808", "start": [75, 1], "end": [76, 90], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Data/Svg.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Data/Html.lean", "lake-packages/proofwidgets/ProofWidgets/Data/Json.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Float.toInt", "code": "private def _root_.Float.toInt (x : Float) : Int :=\n  if x >= 0 then\n    x.toUInt64.toNat\n  else\n    -((-x).toUInt64.toNat)", "start": [7, 1], "end": [11, 27], "kind": "commanddeclaration"}, {"full_name": "Int.toFloat", "code": "private def _root_.Int.toFloat (i : Int) : Float :=\n  if i >= 0 then\n    i.toNat.toFloat\n  else\n    -((-i).toNat.toFloat)", "start": [13, 1], "end": [17, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Frame", "code": "structure Frame where\n  (xmin ymin : Float)\n  (xSize : Float)\n  (width height : Nat)\nderiving ToJson, FromJson", "start": [21, 1], "end": [25, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Frame.ySize", "code": "def Frame.ySize (frame : Frame) : Float := frame.height.toFloat * (frame.xSize / frame.width.toFloat)", "start": [27, 1], "end": [27, 102], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Frame.xmax", "code": "def Frame.xmax (frame : Frame) : Float := frame.xmin + frame.xSize", "start": [29, 1], "end": [29, 67], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Frame.ymax", "code": "def Frame.ymax (frame : Frame) : Float := frame.ymin + frame.ySize", "start": [30, 1], "end": [30, 67], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Frame.pixelSize", "code": "def Frame.pixelSize (frame : Frame) : Float := frame.xSize / frame.width.toFloat", "start": [31, 1], "end": [31, 81], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Color", "code": "structure Color where\n  (r := 0.0)\n  (g := 0.0)\n  (b := 0.0)\nderiving ToJson, FromJson", "start": [33, 1], "end": [37, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Color.toStringRGB", "code": "def Color.toStringRGB (c : Color) : String := s!\"rgb({255*c.r}, {255*c.g}, {255*c.b})\"", "start": [41, 1], "end": [42, 87], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Point", "code": "inductive Point (f : Frame) where\n| px   (i j : Int)\n| abs  (x y : Float)\nderiving Inhabited, ToJson, FromJson", "start": [44, 1], "end": [47, 37], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Point.toPixels", "code": "def Point.toPixels {f : Frame} (p : Point f) : Int \u00d7 Int :=\n  match p with\n  | .px x y => (x,y)\n  | .abs x y =>\n    let \u0394x := f.pixelSize\n    let i := ((x - f.xmin) / \u0394x).floor.toInt\n    let j := ((f.ymax - y) / \u0394x).floor.toInt\n    (i, j)", "start": [52, 1], "end": [59, 11], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Point.toAbsolute", "code": "def Point.toAbsolute {f : Frame} (p : Point f) : Float \u00d7 Float :=\n  match p with\n  | .abs x y => (x,y)\n  | .px  i j =>\n    let \u0394x := f.pixelSize\n    let x := f.xmin + (i.toFloat + 0.5) * \u0394x\n    let y := f.ymax - (j.toFloat + 0.5) * \u0394x\n    (x,y)", "start": [61, 1], "end": [68, 10], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Size", "code": "inductive Size (f : Frame) where\n| px   (size : Nat)   : Size f\n| abs  (size : Float) : Size f\nderiving ToJson, FromJson", "start": [70, 1], "end": [73, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Size.toPixels", "code": "def Size.toPixels {f : Frame} (s : Size f) : Nat :=\n  match s with\n  | .px  x => x\n  | .abs x => (x / f.pixelSize).ceil.toUInt64.toNat", "start": [75, 1], "end": [78, 52], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Shape", "code": "inductive Shape (f : Frame) where\n| line     (src trg : Point f)\n| circle   (center : Point f) (radius : Size f)\n| polyline (points : Array (Point f)) | polygon  (points : Array (Point f))\nderiving ToJson, FromJson", "start": [82, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Shape.toHtmlData", "code": "def Shape.toHtmlData {f : Frame} : Shape f \u2192 String \u00d7 Array (String \u00d7 Json)\n| .line src trg =>\n  let (x1,y1) := src.toPixels\n  let (x2,y2) := trg.toPixels\n  (\"line\", #[(\"x1\", x1), (\"y1\", y1), (\"x2\", x2), (\"y2\", y2)])\n| .circle center radius =>\n  let (cx,cy) := center.toPixels\n  let r := radius.toPixels\n  (\"circle\", #[(\"cx\", cx), (\"cy\", cy), (\"r\", r)])\n| .polyline points =>\n  let pts := points\n      |>.map (\u03bb p => let (x,y) := p.toPixels; s!\"{x},{y}\")\n      |>.foldl (init := \"\") (\u03bb s p => s ++ \" \" ++ p)\n  (\"polyline\", #[(\"points\", pts)])\n| .polygon points =>\n  let pts := points\n      |>.map (\u03bb p => let (x,y) := p.toPixels; s!\"{x},{y}\")\n      |>.foldl (init := \"\") (\u03bb s p => s ++ \" \" ++ p)\n  (\"polygon\", #[(\"fillRule\", \"nonzero\"), (\"points\", pts)])", "start": [89, 1], "end": [107, 59], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element", "code": "structure Element (f : Frame) where\n  shape : Shape f\n  strokeColor := (none : Option Color)\n  strokeWidth := (none : Option (Size f))\n  fillColor   := (none : Option Color)\n  id          := (none : Option String)\n  data        := (none : Option Json)\nderiving ToJson, FromJson", "start": [110, 1], "end": [117, 26], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element.setStroke", "code": "def Element.setStroke {f} (elem : Element f) (color : Color) (width : Size f) :=\n  { elem with strokeColor := some color, strokeWidth := some width }", "start": [119, 1], "end": [120, 69], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element.setFill", "code": "def Element.setFill {f} (elem : Element f) (color : Color) :=\n  { elem with fillColor := some color }", "start": [122, 1], "end": [123, 40], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element.setId", "code": "def Element.setId {f} (elem : Element f) (id : String) :=\n  { elem with id := some id }", "start": [125, 1], "end": [126, 30], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element.setData", "code": "def Element.setData {\u03b1 : Type} {f} (elem : Element f) (a : \u03b1) [ToJson \u03b1] :=\n  { elem with data := some (toJson a) }", "start": [128, 1], "end": [129, 40], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.Element.toHtml", "code": "def Element.toHtml {f : Frame} (e : Element f) : Html := Id.run do\n  let mut (tag, args) := e.shape.toHtmlData\n\n  if let .some color := e.strokeColor then\n    args := args.push (\"stroke\", color.toStringRGB)\n\n  if let .some width := e.strokeWidth then\n    args := args.push (\"strokeWidth\", width.toPixels)\n\n  if let .some color := e.fillColor then\n    args := args.push (\"fill\", color.toStringRGB)\n  else\n    args := args.push (\"fill\", \"none\")\n\n  if let .some id := e.id then\n    args := args.push (\"id\", id)\n\n  if let .some data := e.data then\n    args := args.push (\"data\", data)\n\n  return .element tag args #[]", "start": [131, 1], "end": [151, 31], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.line", "code": "def line {f} (p q : Point f) : Element f := { shape := .line p q }", "start": [153, 3], "end": [153, 69], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.circle", "code": "def circle {f} (c : Point f) (r : Size f) : Element f := { shape := .circle c r }", "start": [154, 3], "end": [154, 84], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.polyline", "code": "def polyline {f} (pts : Array (Point f)) : Element f := { shape := .polyline pts }", "start": [155, 3], "end": [155, 85], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.polygon", "code": "def polygon {f} (pts : Array (Point f)) : Element f := { shape := .polygon pts }", "start": [156, 3], "end": [156, 83], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.mkIdToIdx", "code": "def mkIdToIdx {f} (elements : Array (Svg.Element f)) : HashMap String (Fin elements.size) :=\n  let idToIdx := (elements\n    |>.mapIdx (\u03bb idx el => (idx,el))) |>.filterMap (\u03bb (idx,el) => el.id.map (\u03bb id => (id,idx))) |>.toList\n    |> HashMap.ofList\n  idToIdx", "start": [160, 1], "end": [166, 10], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg", "code": "structure Svg (f : Svg.Frame) where\n  elements : Array (Svg.Element f)\n  idToIdx := mkIdToIdx elements", "start": [168, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.toHtml", "code": "def toHtml {f : Frame} (svg : Svg f) : Html :=\n  .element \"svg\"\n    #[(\"xmlns\", \"http://www.w3.org/2000/svg\"),\n      (\"version\", \"1.1\"),\n      (\"width\", f.width),\n      (\"height\", f.height)]\n    (svg.elements.map \u03bb e => e.toHtml)", "start": [174, 1], "end": [180, 39], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.idToDataList", "code": "def idToDataList {f} (svg : Svg f) : List (String \u00d7 Json) :=\n  svg.elements.foldr (init := []) (\u03bb e l =>\n    match e.id, e.data with\n    | some id, some data => (id,data)::l\n    | _, _ => l)", "start": [182, 1], "end": [186, 17], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.idToData", "code": "def idToData {f} (svg : Svg f) : HashMap String Json :=\n  HashMap.ofList svg.idToDataList", "start": [188, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.Svg.getData", "code": "def getData {f} (svg : Svg f) (id : String) : Option Json :=\n  match svg[id] with\n  | none => none\n  | some elem => elem.data", "start": [197, 1], "end": [200, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/OrderSynonym.lean", "imports": ["Mathlib/Algebra/Group/OrderSynonym.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/RingTheory/MvPolynomial/NewtonIdentities.lean", "imports": ["Mathlib/Data/MvPolynomial/Rename.lean", "Mathlib/RingTheory/MvPolynomial/Symmetric.lean", "Mathlib/Data/Finset/Card.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "Mathlib/RingTheory/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "Mathlib/Data/MvPolynomial/CommRing.lean", "Mathlib/Data/Fintype/Basic.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "MvPolynomial.NewtonIdentities.pairs", "code": "private def pairs (k : \u2115) : Finset (Finset \u03c3 \u00d7 \u03c3) :=\n  univ.filter (fun t \u21a6 card t.fst \u2264 k \u2227 (card t.fst = k \u2192 t.snd \u2208 t.fst))", "start": [60, 1], "end": [61, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.mem_pairs", "code": "@[simp]\nprivate lemma mem_pairs (k : \u2115) (t : Finset \u03c3 \u00d7 \u03c3) :\n    t \u2208 pairs \u03c3 k \u2194 card t.fst \u2264 k \u2227 (card t.fst = k \u2192 t.snd \u2208 t.fst) := by\n  simp [pairs]", "start": [63, 1], "end": [66, 15], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.NewtonIdentities.weight", "code": "private def weight (k : \u2115) (t : Finset \u03c3 \u00d7 \u03c3) : MvPolynomial \u03c3 R :=\n  (-1) ^ card t.fst * ((\u220f a in t.fst, X a) * X t.snd ^ (k - card t.fst))", "start": [68, 1], "end": [69, 73], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap", "code": "private def pairMap (t : Finset \u03c3 \u00d7 \u03c3) : Finset \u03c3 \u00d7 \u03c3 :=\n  if h : t.snd \u2208 t.fst then (t.fst.erase t.snd, t.snd) else (t.fst.cons t.snd h, t.snd)", "start": [71, 1], "end": [72, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap_ne_self", "code": "private lemma pairMap_ne_self (t : Finset \u03c3 \u00d7 \u03c3) : pairMap \u03c3 t \u2260 t := by\n  rw [pairMap]\n  split_ifs with h1\n  all_goals by_contra ht; rw [\u2190 ht] at h1; simp_all", "start": [74, 1], "end": [77, 52], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap_of_snd_mem_fst", "code": "private lemma pairMap_of_snd_mem_fst {t : Finset \u03c3 \u00d7 \u03c3} (h : t.snd \u2208 t.fst) :\n    pairMap \u03c3 t = (t.fst.erase t.snd, t.snd) := by\n  simp [pairMap, h]", "start": [79, 1], "end": [81, 20], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap_of_snd_nmem_fst", "code": "private lemma pairMap_of_snd_nmem_fst {t : Finset \u03c3 \u00d7 \u03c3} (h : t.snd \u2209 t.fst) :\n    pairMap \u03c3 t = (t.fst.cons t.snd h, t.snd) := by\n  simp [pairMap, h]", "start": [83, 1], "end": [85, 20], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap_mem_pairs", "code": "private theorem pairMap_mem_pairs {k : \u2115} (t : Finset \u03c3 \u00d7 \u03c3) (h : t \u2208 pairs \u03c3 k) :\n    pairMap \u03c3 t \u2208 pairs \u03c3 k", "start": [87, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.pairMap_involutive", "code": "@[simp]\nprivate theorem pairMap_involutive : (pairMap \u03c3).Involutive", "start": [103, 1], "end": [111, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.weight_add_weight_pairMap", "code": "private theorem weight_add_weight_pairMap {k : \u2115} (t : Finset \u03c3 \u00d7 \u03c3) (h : t \u2208 pairs \u03c3 k) :\n    weight \u03c3 R k t + weight \u03c3 R k (pairMap \u03c3 t) = 0", "start": [113, 1], "end": [134, 9], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.weight_sum", "code": "private theorem weight_sum (k : \u2115) : \u2211 t in pairs \u03c3 k, weight \u03c3 R k t = 0", "start": [136, 1], "end": [139, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.sum_filter_pairs_eq_sum_powersetCard_sum", "code": "private theorem sum_filter_pairs_eq_sum_powersetCard_sum (k : \u2115)\n    (f : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R) :\n    (\u2211 t in filter (fun t \u21a6 card t.fst = k) (pairs \u03c3 k), f t) =\n    \u2211 A in powersetCard k univ, (\u2211 j in A, f (A, j))", "start": [141, 1], "end": [146, 8], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.sum_filter_pairs_eq_sum_powersetCard_mem_filter_antidiagonal_sum", "code": "private theorem sum_filter_pairs_eq_sum_powersetCard_mem_filter_antidiagonal_sum (k : \u2115) (a : \u2115 \u00d7 \u2115)\n    (ha : a \u2208 (antidiagonal k).filter (fun a \u21a6 a.fst < k)) (f : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R) :\n    (\u2211 t in filter (fun t \u21a6 card t.fst = a.fst) (pairs \u03c3 k), f t) =\n    \u2211 A in powersetCard a.fst univ, (\u2211 j, f (A, j))", "start": [148, 1], "end": [156, 8], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.sum_filter_pairs_eq_sum_filter_antidiagonal_powersetCard_sum", "code": "private theorem sum_filter_pairs_eq_sum_filter_antidiagonal_powersetCard_sum (k : \u2115)\n    (f : Finset \u03c3 \u00d7 \u03c3 \u2192 MvPolynomial \u03c3 R) :\n    (\u2211 t in filter (fun t \u21a6 card t.fst < k) (pairs \u03c3 k), f t) =\n    \u2211 a in (antidiagonal k).filter (fun a \u21a6 a.fst < k),\n    \u2211 A in powersetCard a.fst univ, (\u2211 j, f (A, j))", "start": [158, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.disjoint_filter_pairs_lt_filter_pairs_eq", "code": "private theorem disjoint_filter_pairs_lt_filter_pairs_eq (k : \u2115) :\n    Disjoint (filter (fun t \u21a6 card t.fst < k) (pairs \u03c3 k))\n    (filter (fun t \u21a6 card t.fst = k) (pairs \u03c3 k))", "start": [191, 1], "end": [195, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.disjUnion_filter_pairs_eq_pairs", "code": "private theorem disjUnion_filter_pairs_eq_pairs (k : \u2115) :\n    disjUnion (filter (fun t \u21a6 card t.fst < k) (pairs \u03c3 k))\n    (filter (fun t \u21a6 card t.fst = k) (pairs \u03c3 k)) (disjoint_filter_pairs_lt_filter_pairs_eq \u03c3 k) =\n    pairs \u03c3 k", "start": [197, 1], "end": [206, 8], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.esymm_summand_to_weight", "code": "private theorem esymm_summand_to_weight (k : \u2115) (A : Finset \u03c3) (h : A \u2208 powersetCard k univ) :\n    \u2211 j in A, weight \u03c3 R k (A, j) = k * (-1) ^ k * (\u220f i in A, X i : MvPolynomial \u03c3 R)", "start": [208, 1], "end": [210, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.esymm_to_weight", "code": "private theorem esymm_to_weight (k : \u2115) : k * esymm \u03c3 R k =\n    (-1) ^ k * \u2211 t in filter (fun t \u21a6 card t.fst = k) (pairs \u03c3 k), weight \u03c3 R k t", "start": [212, 1], "end": [216, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.esymm_mul_psum_summand_to_weight", "code": "private theorem esymm_mul_psum_summand_to_weight (k : \u2115) (a : \u2115 \u00d7 \u2115) (ha : a \u2208 antidiagonal k) :\n    \u2211 A in powersetCard a.fst univ, \u2211 j, weight \u03c3 R k (A, j) =\n    (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd", "start": [218, 1], "end": [226, 80], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.NewtonIdentities.esymm_mul_psum_to_weight", "code": "private theorem esymm_mul_psum_to_weight (k : \u2115) :\n    \u2211 a in (antidiagonal k).filter (fun a \u21a6 a.fst < k),\n    (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd =\n    \u2211 t in filter (fun t \u21a6 card t.fst < k) (pairs \u03c3 k), weight \u03c3 R k t", "start": [228, 1], "end": [233, 72], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mul_esymm_eq_sum", "code": "theorem mul_esymm_eq_sum (k : \u2115) : k * esymm \u03c3 R k =\n    (-1) ^ (k + 1) * \u2211 a in (antidiagonal k).filter (fun a \u21a6 a.fst < k),\n    (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd", "start": [237, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_antidiagonal_card_esymm_psum_eq_zero", "code": "theorem sum_antidiagonal_card_esymm_psum_eq_zero :\n    \u2211 a in antidiagonal (Fintype.card \u03c3), (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd = 0", "start": [251, 1], "end": [258, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.psum_eq_mul_esymm_sub_sum", "code": "theorem psum_eq_mul_esymm_sub_sum (k : \u2115) (h : 0 < k) : psum \u03c3 R k =\n    (-1) ^ (k + 1) * k * esymm \u03c3 R k -\n    \u2211 a in (antidiagonal k).filter (fun a \u21a6 a.fst \u2208 Set.Ioo 0 k),\n    (-1) ^ a.fst * esymm \u03c3 R a.fst * psum \u03c3 R a.snd", "start": [260, 1], "end": [286, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/AlgebraCat/Symmetric.lean", "imports": ["Mathlib/Algebra/Category/AlgebraCat/Monoidal.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraCat.toModuleCatBraidedFunctor", "code": "@[simps toMonoidalFunctor]\ndef toModuleCatBraidedFunctor : BraidedFunctor (AlgebraCat.{u} R) (ModuleCat.{u} R) where\n  toMonoidalFunctor := toModuleCatMonoidalFunctor R", "start": [33, 1], "end": [36, 52], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instSymmetricCategory", "code": "instance instSymmetricCategory : SymmetricCategory (AlgebraCat.{u} R) :=\n  symmetricCategoryOfFaithful (toModuleCatBraidedFunctor R)", "start": [41, 1], "end": [42, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/SumTwoSquares.lean", "imports": ["Mathlib/NumberTheory/Zsqrtd/QuadraticReciprocity.lean", "Mathlib/Tactic/LinearCombination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Prime.sq_add_sq", "code": "theorem Nat.Prime.sq_add_sq {p : \u2115} [Fact p.Prime] (hp : p % 4 \u2260 3) :\n    \u2203 a b : \u2115, a ^ 2 + b ^ 2 = p", "start": [30, 1], "end": [35, 93], "kind": "commanddeclaration"}, {"full_name": "sq_add_sq_mul", "code": "theorem sq_add_sq_mul {R} [CommRing R] {a b x y u v : R} (ha : a = x ^ 2 + y ^ 2)\n    (hb : b = u ^ 2 + v ^ 2) : \u2203 r s : R, a * b = r ^ 2 + s ^ 2", "start": [47, 1], "end": [51, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.sq_add_sq_mul", "code": "theorem Nat.sq_add_sq_mul {a b x y u v : \u2115} (ha : a = x ^ 2 + y ^ 2) (hb : b = u ^ 2 + v ^ 2) :\n    \u2203 r s : \u2115, a * b = r ^ 2 + s ^ 2", "start": [54, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_of_dvd", "code": "theorem ZMod.isSquare_neg_one_of_dvd {m n : \u2115} (hd : m \u2223 n) (hs : IsSquare (-1 : ZMod n)) :\n    IsSquare (-1 : ZMod m)", "start": [75, 1], "end": [80, 17], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_mul", "code": "theorem ZMod.isSquare_neg_one_mul {m n : \u2115} (hc : m.Coprime n) (hm : IsSquare (-1 : ZMod m))\n    (hn : IsSquare (-1 : ZMod n)) : IsSquare (-1 : ZMod (m * n))", "start": [83, 1], "end": [93, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.mod_four_ne_three_of_dvd_isSquare_neg_one", "code": "theorem Nat.Prime.mod_four_ne_three_of_dvd_isSquare_neg_one {p n : \u2115} (hpp : p.Prime) (hp : p \u2223 n)\n    (hs : IsSquare (-1 : ZMod n)) : p % 4 \u2260 3", "start": [96, 1], "end": [102, 62], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_iff", "code": "theorem ZMod.isSquare_neg_one_iff {n : \u2115} (hn : Squarefree n) :\n    IsSquare (-1 : ZMod n) \u2194 \u2200 {q : \u2115}, q.Prime \u2192 q \u2223 n \u2192 q % 4 \u2260 3", "start": [105, 1], "end": [119, 78], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_iff'", "code": "theorem ZMod.isSquare_neg_one_iff' {n : \u2115} (hn : Squarefree n) :\n    IsSquare (-1 : ZMod n) \u2194 \u2200 {q : \u2115}, q \u2223 n \u2192 q % 4 \u2260 3", "start": [122, 1], "end": [137, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_sq_add_sq_of_isSquare_mod_neg_one", "code": "theorem Nat.eq_sq_add_sq_of_isSquare_mod_neg_one {n : \u2115} (h : IsSquare (-1 : ZMod n)) :\n    \u2203 x y : \u2115, n = x ^ 2 + y ^ 2", "start": [145, 1], "end": [155, 41], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime", "code": "theorem ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_isCoprime {n x y : \u2124} (h : n = x ^ 2 + y ^ 2)\n    (hc : IsCoprime x y) : IsSquare (-1 : ZMod n.natAbs)", "start": [158, 1], "end": [171, 86], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime", "code": "theorem ZMod.isSquare_neg_one_of_eq_sq_add_sq_of_coprime {n x y : \u2115} (h : n = x ^ 2 + y ^ 2)\n    (hc : x.Coprime y) : IsSquare (-1 : ZMod n)", "start": [174, 1], "end": [179, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_sq_add_sq_iff_eq_sq_mul", "code": "theorem Nat.eq_sq_add_sq_iff_eq_sq_mul {n : \u2115} :\n    (\u2203 x y : \u2115, n = x ^ 2 + y ^ 2) \u2194 \u2203 a b : \u2115, n = a ^ 2 * b \u2227 IsSquare (-1 : ZMod b)", "start": [182, 1], "end": [197, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_sq_add_sq_iff", "code": "theorem Nat.eq_sq_add_sq_iff {n : \u2115} :\n    (\u2203 x y : \u2115, n = x ^ 2 + y ^ 2) \u2194 \u2200 {q : \u2115}, q.Prime \u2192 q % 4 = 3 \u2192 Even (padicValNat q n)", "start": [209, 1], "end": [239, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Lifting.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "Mathlib/CategoryTheory/Monad/Coequalizer.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "Mathlib/CategoryTheory/Monad/Adjunction.lean"], "premises": [{"full_name": "CategoryTheory.LiftAdjoint.counitCoequalises", "code": "def counitCoequalises [\u2200 X : B, RegularEpi (adj\u2081.counit.app X)] (X : B) :\n    IsColimit (Cofork.of\u03c0 (adj\u2081.counit.app X) (adj\u2081.counit_naturality _)) :=\n  Cofork.IsColimit.mk' _ fun s => by\n    refine' \u27e8(RegularEpi.desc' (adj\u2081.counit.app X) s.\u03c0 _).1, _, _\u27e9\n    \u00b7 rw [\u2190 cancel_epi (adj\u2081.counit.app (RegularEpi.W (adj\u2081.counit.app X)))]\n      rw [\u2190 adj\u2081.counit_naturality_assoc RegularEpi.left]\n      dsimp only [Functor.comp_obj]\n      rw [\u2190 s.condition, \u2190 F.map_comp_assoc, \u2190 U.map_comp, RegularEpi.w, U.map_comp,\n        F.map_comp_assoc, s.condition, \u2190 adj\u2081.counit_naturality_assoc RegularEpi.right]\n    \u00b7 apply (RegularEpi.desc' (adj\u2081.counit.app X) s.\u03c0 _).2\n    \u00b7 intro m hm\n      rw [\u2190 cancel_epi (adj\u2081.counit.app X)]\n      apply hm.trans (RegularEpi.desc' (adj\u2081.counit.app X) s.\u03c0 _).2.symm", "start": [73, 1], "end": [88, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftAdjoint.otherMap", "code": "def otherMap (X) : F'.obj (U.obj (F.obj (U.obj X))) \u27f6 F'.obj (U.obj X) :=\n  F'.map (U.map (F.map (adj\u2082.unit.app _) \u226b adj\u2081.counit.app _)) \u226b adj\u2082.counit.app _", "start": [91, 1], "end": [101, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftAdjoint.constructLeftAdjointObj", "code": "noncomputable def constructLeftAdjointObj (Y : B) : A :=\n  coequalizer (F'.map (U.map (adj\u2081.counit.app Y))) (otherMap _ _ adj\u2081 adj\u2082 Y)", "start": [120, 1], "end": [124, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftAdjoint.constructLeftAdjointEquiv", "code": "@[simps!] noncomputable def constructLeftAdjointEquiv [\u2200 X : B, RegularEpi (adj\u2081.counit.app X)] (Y : A)\n    (X : B) : (constructLeftAdjointObj _ _ adj\u2081 adj\u2082 X \u27f6 Y) \u2243 (X \u27f6 R.obj Y) :=\n  calc\n    (constructLeftAdjointObj _ _ adj\u2081 adj\u2082 X \u27f6 Y) \u2243\n        { f : F'.obj (U.obj X) \u27f6 Y //\n          F'.map (U.map (adj\u2081.counit.app X)) \u226b f = otherMap _ _ adj\u2081 adj\u2082 _ \u226b f } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) _\n    _ \u2243 { g : U.obj X \u27f6 U.obj (R.obj Y) //\n          U.map (F.map g \u226b adj\u2081.counit.app _) = U.map (adj\u2081.counit.app _) \u226b g } := by\n      apply (adj\u2082.homEquiv _ _).subtypeEquiv _\n      intro f\n      rw [\u2190 (adj\u2082.homEquiv _ _).injective.eq_iff, eq_comm, adj\u2082.homEquiv_naturality_left,\n        otherMap, assoc, adj\u2082.homEquiv_naturality_left, \u2190 adj\u2082.counit_naturality,\n        adj\u2082.homEquiv_naturality_left, adj\u2082.homEquiv_unit, adj\u2082.right_triangle_components,\n        comp_id, Functor.comp_map, \u2190 U.map_comp, assoc, \u2190 adj\u2081.counit_naturality,\n        adj\u2082.homEquiv_unit, adj\u2082.homEquiv_unit, F.map_comp, assoc]\n      rfl\n    _ \u2243 { z : F.obj (U.obj X) \u27f6 R.obj Y // _ } := by\n      apply (adj\u2081.homEquiv _ _).symm.subtypeEquiv\n      intro g\n      rw [\u2190 (adj\u2081.homEquiv _ _).symm.injective.eq_iff, adj\u2081.homEquiv_counit,\n        adj\u2081.homEquiv_counit, adj\u2081.homEquiv_counit, F.map_comp, assoc, U.map_comp, F.map_comp,\n        assoc, adj\u2081.counit_naturality, adj\u2081.counit_naturality_assoc]\n      apply eq_comm\n    _ \u2243 (X \u27f6 R.obj Y) := (Cofork.IsColimit.homIso (counitCoequalises adj\u2081 X) _).symm", "start": [127, 1], "end": [153, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LiftAdjoint.constructLeftAdjoint", "code": "noncomputable def constructLeftAdjoint [\u2200 X : B, RegularEpi (adj\u2081.counit.app X)] : B \u2964 A := by\n  refine' Adjunction.leftAdjointOfEquiv (fun X Y => constructLeftAdjointEquiv R _ adj\u2081 adj\u2082 Y X) _\n  intro X Y Y' g h\n  rw [constructLeftAdjointEquiv_apply, constructLeftAdjointEquiv_apply,\n    Equiv.symm_apply_eq, Subtype.ext_iff]\n  dsimp\n  erw [Cofork.IsColimit.homIso_natural, Cofork.IsColimit.homIso_natural]\n  erw [adj\u2082.homEquiv_naturality_right]\n  simp_rw [Functor.comp_map]\n  aesop_cat", "start": [156, 1], "end": [168, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.adjointTriangleLift", "code": "noncomputable def adjointTriangleLift {U : B \u2964 C} {F : C \u2964 B} (R : A \u2964 B) (adj\u2081 : F \u22a3 U)\n    [\u2200 X : B, RegularEpi (adj\u2081.counit.app X)] [HasReflexiveCoequalizers A]\n    [IsRightAdjoint (R \u22d9 U)] : IsRightAdjoint R where\n  left := LiftAdjoint.constructLeftAdjoint R _ adj\u2081 (Adjunction.ofRightAdjoint _)\n  adj := Adjunction.adjunctionOfEquivLeft _ _", "start": [173, 1], "end": [184, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monadicAdjointTriangleLift", "code": "noncomputable def monadicAdjointTriangleLift (U : B \u2964 C) [MonadicRightAdjoint U] {R : A \u2964 B}\n    [HasReflexiveCoequalizers A] [IsRightAdjoint (R \u22d9 U)] : IsRightAdjoint R := by\n  let R' : A \u2964 _ := R \u22d9 Monad.comparison (Adjunction.ofRightAdjoint U)\n  rsuffices : IsRightAdjoint R'\n  \u00b7 let this : IsRightAdjoint (R' \u22d9 (Monad.comparison (Adjunction.ofRightAdjoint U)).inv) := by\n      infer_instance\n    \u00b7 let this : R' \u22d9 (Monad.comparison (Adjunction.ofRightAdjoint U)).inv \u2245 R :=\n        (isoWhiskerLeft R (Monad.comparison _).asEquivalence.unitIso.symm : _) \u226a\u226b R.rightUnitor\n      exact Adjunction.rightAdjointOfNatIso this\n  let this : IsRightAdjoint (R' \u22d9 Monad.forget (Adjunction.ofRightAdjoint U).toMonad) :=\n    Adjunction.rightAdjointOfNatIso\n      (isoWhiskerLeft R (Monad.comparisonForget (Adjunction.ofRightAdjoint U)).symm : _)\n  let this : \u2200 X, RegularEpi ((Monad.adj (Adjunction.ofRightAdjoint U).toMonad).counit.app X) := by\n    intro X\n    simp only [Monad.adj_counit]\n    exact \u27e8_, _, _, _, Monad.beckAlgebraCoequalizer X\u27e9\n  exact adjointTriangleLift R' (Monad.adj _)", "start": [187, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.adjointSquareLift", "code": "noncomputable def adjointSquareLift (Q : A \u2964 B) (V : B \u2964 D) (U : A \u2964 C) (R : C \u2964 D)\n    (comm : U \u22d9 R \u2245 Q \u22d9 V) [IsRightAdjoint U] [IsRightAdjoint V] [IsRightAdjoint R]\n    [\u2200 X, RegularEpi ((Adjunction.ofRightAdjoint V).counit.app X)] [HasReflexiveCoequalizers A] :\n    IsRightAdjoint Q :=\n  letI := Adjunction.rightAdjointOfNatIso comm\n  adjointTriangleLift Q (Adjunction.ofRightAdjoint V)", "start": [214, 1], "end": [233, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monadicAdjointSquareLift", "code": "noncomputable def monadicAdjointSquareLift (Q : A \u2964 B) (V : B \u2964 D) (U : A \u2964 C) (R : C \u2964 D)\n    (comm : U \u22d9 R \u2245 Q \u22d9 V) [IsRightAdjoint U] [MonadicRightAdjoint V] [IsRightAdjoint R]\n    [HasReflexiveCoequalizers A] : IsRightAdjoint Q :=\n  letI := Adjunction.rightAdjointOfNatIso comm\n  monadicAdjointTriangleLift V", "start": [236, 1], "end": [253, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Pi/Bounds.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.pi_gt_sqrtTwoAddSeries", "code": "theorem pi_gt_sqrtTwoAddSeries (n : \u2115) :\n    (2 : \u211d) ^ (n + 1) * sqrt (2 - sqrtTwoAddSeries 0 n) < \u03c0", "start": [30, 1], "end": [36, 75], "kind": "commanddeclaration"}, {"full_name": "Real.pi_lt_sqrtTwoAddSeries", "code": "theorem pi_lt_sqrtTwoAddSeries (n : \u2115) :\n    \u03c0 < (2 : \u211d) ^ (n + 1) * sqrt (2 - sqrtTwoAddSeries 0 n) + 1 / (4 : \u211d) ^ n", "start": [39, 1], "end": [67, 40], "kind": "commanddeclaration"}, {"full_name": "Real.pi_lower_bound_start", "code": "theorem pi_lower_bound_start (n : \u2115) {a}\n    (h : sqrtTwoAddSeries ((0 : \u2115) / (1 : \u2115)) n \u2264 (2 : \u211d) - (a / (2 : \u211d) ^ (n + 1)) ^ 2) :\n    a < \u03c0", "start": [70, 1], "end": [78, 86], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_step_up", "code": "theorem sqrtTwoAddSeries_step_up (c d : \u2115) {a b n : \u2115} {z : \u211d} (hz : sqrtTwoAddSeries (c / d) n \u2264 z)\n    (hb : 0 < b) (hd : 0 < d) (h : (2 * b + a) * d ^ 2 \u2264 c ^ 2 * b) :\n    sqrtTwoAddSeries (a / b) (n + 1) \u2264 z", "start": [81, 1], "end": [89, 19], "kind": "commanddeclaration"}, {"full_name": "Real.numDen", "code": "private def numDen : Syntax \u2192 Option (Syntax.Term \u00d7 Syntax.Term)\n  | `($a / $b) => some (a, b)\n  | _          => none", "start": [96, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "Real.pi_upper_bound_start", "code": "theorem pi_upper_bound_start (n : \u2115) {a}\n    (h : (2 : \u211d) - ((a - 1 / (4 : \u211d) ^ n) / (2 : \u211d) ^ (n + 1)) ^ 2 \u2264\n        sqrtTwoAddSeries ((0 : \u2115) / (1 : \u2115)) n)\n    (h\u2082 : (1 : \u211d) / (4 : \u211d) ^ n \u2264 a) : \u03c0 < a", "start": [121, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtTwoAddSeries_step_down", "code": "theorem sqrtTwoAddSeries_step_down (a b : \u2115) {c d n : \u2115} {z : \u211d}\n    (hz : z \u2264 sqrtTwoAddSeries (a / b) n) (hb : 0 < b) (hd : 0 < d)\n    (h : a ^ 2 * d \u2264 (2 * d + c) * b ^ 2) : z \u2264 sqrtTwoAddSeries (c / d) (n + 1)", "start": [135, 1], "end": [143, 19], "kind": "commanddeclaration"}, {"full_name": "Real.pi_gt_three", "code": "theorem pi_gt_three : 3 < \u03c0", "start": [167, 1], "end": [168, 25], "kind": "commanddeclaration"}, {"full_name": "Real.pi_gt_314", "code": "theorem pi_gt_314 : 3.14 < \u03c0", "start": [171, 1], "end": [172, 62], "kind": "commanddeclaration"}, {"full_name": "Real.pi_lt_315", "code": "theorem pi_lt_315 : \u03c0 < 3.15", "start": [175, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "Real.pi_gt_31415", "code": "theorem pi_gt_31415 : 3.1415 < \u03c0", "start": [179, 1], "end": [181, 93], "kind": "commanddeclaration"}, {"full_name": "Real.pi_lt_31416", "code": "theorem pi_lt_31416 : \u03c0 < 3.1416", "start": [184, 1], "end": [187, 78], "kind": "commanddeclaration"}, {"full_name": "Real.pi_gt_3141592", "code": "theorem pi_gt_3141592 : 3.141592 < \u03c0", "start": [190, 1], "end": [193, 101], "kind": "commanddeclaration"}, {"full_name": "Real.pi_lt_3141593", "code": "theorem pi_lt_3141593 : \u03c0 < 3.141593", "start": [196, 1], "end": [200, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Darboux.lean", "imports": ["Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "Mathlib/Analysis/Calculus/Deriv/Mul.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "exists_hasDerivWithinAt_eq_of_gt_of_lt", "code": "theorem exists_hasDerivWithinAt_eq_of_gt_of_lt (hab : a \u2264 b)\n    (hf : \u2200 x \u2208 Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x) {m : \u211d} (hma : f' a < m)\n    (hmb : m < f' b) : m \u2208 f' '' Ioo a b", "start": [26, 1], "end": [61, 78], "kind": "commanddeclaration"}, {"full_name": "exists_hasDerivWithinAt_eq_of_lt_of_gt", "code": "theorem exists_hasDerivWithinAt_eq_of_lt_of_gt (hab : a \u2264 b)\n    (hf : \u2200 x \u2208 Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x) {m : \u211d} (hma : m < f' a)\n    (hmb : f' b < m) : m \u2208 f' '' Ioo a b", "start": [64, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_hasDerivWithinAt", "code": "theorem Set.OrdConnected.image_hasDerivWithinAt {s : Set \u211d} (hs : OrdConnected s)\n    (hf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) : OrdConnected (f' '' s)", "start": [75, 1], "end": [91, 52], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_derivWithin", "code": "theorem Set.OrdConnected.image_derivWithin {s : Set \u211d} (hs : OrdConnected s)\n    (hf : DifferentiableOn \u211d f s) : OrdConnected (derivWithin f s '' s)", "start": [94, 1], "end": [98, 67], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_deriv", "code": "theorem Set.OrdConnected.image_deriv {s : Set \u211d} (hs : OrdConnected s)\n    (hf : \u2200 x \u2208 s, DifferentiableAt \u211d f x) : OrdConnected (deriv f '' s)", "start": [101, 1], "end": [105, 78], "kind": "commanddeclaration"}, {"full_name": "Convex.image_hasDerivWithinAt", "code": "theorem Convex.image_hasDerivWithinAt {s : Set \u211d} (hs : Convex \u211d s)\n    (hf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) : Convex \u211d (f' '' s)", "start": [108, 1], "end": [112, 53], "kind": "commanddeclaration"}, {"full_name": "Convex.image_derivWithin", "code": "theorem Convex.image_derivWithin {s : Set \u211d} (hs : Convex \u211d s) (hf : DifferentiableOn \u211d f s) :\n    Convex \u211d (derivWithin f s '' s)", "start": [115, 1], "end": [119, 48], "kind": "commanddeclaration"}, {"full_name": "Convex.image_deriv", "code": "theorem Convex.image_deriv {s : Set \u211d} (hs : Convex \u211d s) (hf : \u2200 x \u2208 s, DifferentiableAt \u211d f x) :\n    Convex \u211d (deriv f '' s)", "start": [122, 1], "end": [126, 42], "kind": "commanddeclaration"}, {"full_name": "exists_hasDerivWithinAt_eq_of_ge_of_le", "code": "theorem exists_hasDerivWithinAt_eq_of_ge_of_le (hab : a \u2264 b)\n    (hf : \u2200 x \u2208 Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x) {m : \u211d} (hma : f' a \u2264 m)\n    (hmb : m \u2264 f' b) : m \u2208 f' '' Icc a b", "start": [129, 1], "end": [135, 58], "kind": "commanddeclaration"}, {"full_name": "exists_hasDerivWithinAt_eq_of_le_of_ge", "code": "theorem exists_hasDerivWithinAt_eq_of_le_of_ge (hab : a \u2264 b)\n    (hf : \u2200 x \u2208 Icc a b, HasDerivWithinAt f (f' x) (Icc a b) x) {m : \u211d} (hma : f' a \u2264 m)\n    (hmb : m \u2264 f' b) : m \u2208 f' '' Icc a b", "start": [138, 1], "end": [144, 58], "kind": "commanddeclaration"}, {"full_name": "hasDerivWithinAt_forall_lt_or_forall_gt_of_forall_ne", "code": "theorem hasDerivWithinAt_forall_lt_or_forall_gt_of_forall_ne {s : Set \u211d} (hs : Convex \u211d s)\n    (hf : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) {m : \u211d} (hf' : \u2200 x \u2208 s, f' x \u2260 m) :\n    (\u2200 x \u2208 s, f' x < m) \u2228 \u2200 x \u2208 s, m < f' x", "start": [147, 1], "end": [155, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Limits.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Algebra/Homology/Homotopy.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/NegOnePow.lean"], "premises": [{"full_name": "CochainComplex.HomComplex.Triplet", "code": "structure Triplet (n : \u2124) where\n  \n  p : \u2124\n  \n  q : \u2124\n  \n  hpq : p + n = q", "start": [51, 1], "end": [60, 18], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain", "code": "def Cochain := \u2200 (T : Triplet n), F.X T.p \u27f6 G.X T.q", "start": [64, 1], "end": [67, 52], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.mk", "code": "def mk (v : \u2200 (p q : \u2124) (_ : p + n = q), F.X p \u27f6 G.X q) : Cochain F G n :=\n  fun \u27e8p, q, hpq\u27e9 => v p q hpq", "start": [77, 1], "end": [79, 31], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.v", "code": "@[pp_dot]\ndef v (\u03b3 : Cochain F G n) (p q : \u2124) (hpq : p + n = q) :\n    F.X p \u27f6 G.X q := \u03b3 \u27e8p, q, hpq\u27e9", "start": [81, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.mk_v", "code": "@[simp]\nlemma mk_v (v : \u2200 (p q : \u2124) (_ : p + n = q), F.X p \u27f6 G.X q) (p q : \u2124) (hpq : p + n = q) :\n    (Cochain.mk v).v p q hpq = v p q hpq := rfl", "start": [86, 1], "end": [88, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.congr_v", "code": "lemma congr_v {z\u2081 z\u2082 : Cochain F G n} (h : z\u2081 = z\u2082) (p q : \u2124) (hpq : p + n = q) :\n    z\u2081.v p q hpq = z\u2082.v p q hpq := by subst h; rfl", "start": [90, 1], "end": [91, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ext", "code": "@[ext]\nlemma ext (z\u2081 z\u2082 : Cochain F G n)\n    (h : \u2200 (p q hpq), z\u2081.v p q hpq = z\u2082.v p q hpq) : z\u2081 = z\u2082 := by\n  funext \u27e8p, q, hpq\u27e9\n  apply h", "start": [93, 1], "end": [97, 10], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ext\u2080", "code": "@[ext 1100]\nlemma ext\u2080 (z\u2081 z\u2082 : Cochain F G 0)\n    (h : \u2200 (p : \u2124), z\u2081.v p p (add_zero p) = z\u2082.v p p (add_zero p)) : z\u2081 = z\u2082 := by\n  ext p q hpq\n  obtain rfl : q = p := by rw [\u2190 hpq, add_zero]\n  exact h q", "start": [99, 1], "end": [104, 12], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.zero_v", "code": "@[simp]\nlemma zero_v {n : \u2124} (p q : \u2124) (hpq : p + n = q) :\n    (0 : Cochain F G n).v p q hpq = 0 := rfl", "start": [106, 1], "end": [108, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.add_v", "code": "@[simp]\nlemma add_v {n : \u2124} (z\u2081 z\u2082 : Cochain F G n) (p q : \u2124) (hpq : p + n = q) :\n    (z\u2081 + z\u2082).v p q hpq = z\u2081.v p q hpq + z\u2082.v p q hpq := rfl", "start": [110, 1], "end": [112, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.sub_v", "code": "@[simp]\nlemma sub_v {n : \u2124} (z\u2081 z\u2082 : Cochain F G n) (p q : \u2124) (hpq : p + n = q) :\n    (z\u2081 - z\u2082).v p q hpq = z\u2081.v p q hpq - z\u2082.v p q hpq := rfl", "start": [114, 1], "end": [116, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.neg_v", "code": "@[simp]\nlemma neg_v {n : \u2124} (z : Cochain F G n) (p q : \u2124) (hpq : p + n = q) :\n    (-z).v p q hpq = - (z.v p q hpq) := rfl", "start": [118, 1], "end": [120, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.zsmul_v", "code": "@[simp]\nlemma zsmul_v {n k : \u2124} (z : Cochain F G n) (p q : \u2124) (hpq : p + n = q) :\n    (k \u2022 z).v p q hpq = k \u2022 (z.v p q hpq) := rfl", "start": [122, 1], "end": [124, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHoms", "code": "def ofHoms (\u03c8 : \u2200 (p : \u2124), F.X p \u27f6 G.X p) : Cochain F G 0 :=\n  Cochain.mk (fun p q hpq => \u03c8 p \u226b eqToHom (by rw [\u2190 hpq, add_zero]))", "start": [126, 1], "end": [129, 70], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHoms_v", "code": "@[simp]\nlemma ofHoms_v (\u03c8 : \u2200 (p : \u2124), F.X p \u27f6 G.X p) (p : \u2124) :\n    (ofHoms \u03c8).v p p (add_zero p) = \u03c8 p := by\n  simp only [ofHoms, mk_v, eqToHom_refl, comp_id]", "start": [131, 1], "end": [134, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHoms_zero", "code": "@[simp]\nlemma ofHoms_zero : ofHoms (fun p => (0 : F.X p \u27f6 G.X p)) = 0 := by aesop_cat", "start": [136, 1], "end": [137, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHoms_v_comp_d", "code": "@[simp]\nlemma ofHoms_v_comp_d (\u03c8 : \u2200 (p : \u2124), F.X p \u27f6 G.X p) (p q q' : \u2124) (hpq : p + 0 = q) :\n    (ofHoms \u03c8).v p q hpq \u226b G.d q q' = \u03c8 p \u226b G.d p q' := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]", "start": [139, 1], "end": [144, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.d_comp_ofHoms_v", "code": "@[simp]\nlemma d_comp_ofHoms_v (\u03c8 : \u2200 (p : \u2124), F.X p \u27f6 G.X p) (p' p q : \u2124) (hpq : p + 0 = q) :\n    F.d p' p \u226b (ofHoms \u03c8).v p q hpq = F.d p' q \u226b \u03c8 q := by\n  rw [add_zero] at hpq\n  subst hpq\n  rw [ofHoms_v]", "start": [146, 1], "end": [151, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom", "code": "def ofHom (\u03c6 : F \u27f6 G) : Cochain F G 0 := ofHoms (fun p => \u03c6.f p)", "start": [153, 1], "end": [154, 65], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_zero", "code": "@[simp]\nlemma ofHom_zero : ofHom (0 : F \u27f6 G) = 0 := by\n  simp only [ofHom, HomologicalComplex.zero_f_apply, ofHoms_zero]", "start": [158, 1], "end": [160, 66], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_v", "code": "@[simp]\nlemma ofHom_v (\u03c6 : F \u27f6 G) (p : \u2124) : (ofHom \u03c6).v p p (add_zero p) = \u03c6.f p := by\n  simp only [ofHom, ofHoms_v]", "start": [164, 1], "end": [166, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_v_comp_d", "code": "@[simp]\nlemma ofHom_v_comp_d (\u03c6 : F \u27f6 G) (p q q' : \u2124) (hpq : p + 0 = q) :\n    (ofHom \u03c6).v p q hpq \u226b G.d q q' = \u03c6.f p \u226b G.d p q' :=\nby simp only [ofHom, ofHoms_v_comp_d]", "start": [168, 1], "end": [171, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.d_comp_ofHom_v", "code": "@[simp]\nlemma d_comp_ofHom_v (\u03c6 : F \u27f6 G) (p' p q : \u2124) (hpq : p + 0 = q) :\n    F.d p' p \u226b (ofHom \u03c6).v p q hpq = F.d p' q \u226b \u03c6.f q := by\n  simp only [ofHom, d_comp_ofHoms_v]", "start": [173, 1], "end": [176, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_add", "code": "@[simp]\nlemma ofHom_add (\u03c6\u2081 \u03c6\u2082 : F \u27f6 G) :\n    Cochain.ofHom (\u03c6\u2081 + \u03c6\u2082) = Cochain.ofHom \u03c6\u2081 + Cochain.ofHom \u03c6\u2082 := by aesop_cat", "start": [178, 1], "end": [180, 82], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_sub", "code": "@[simp]\nlemma ofHom_sub (\u03c6\u2081 \u03c6\u2082 : F \u27f6 G) :\n    Cochain.ofHom (\u03c6\u2081 - \u03c6\u2082) = Cochain.ofHom \u03c6\u2081 - Cochain.ofHom \u03c6\u2082 := by aesop_cat", "start": [182, 1], "end": [184, 82], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_neg", "code": "@[simp]\nlemma ofHom_neg (\u03c6 : F \u27f6 G) :\n    Cochain.ofHom (-\u03c6) = -Cochain.ofHom \u03c6 := by aesop_cat", "start": [186, 1], "end": [188, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHomotopy", "code": "def ofHomotopy {\u03c6\u2081 \u03c6\u2082 : F \u27f6 G} (ho : Homotopy \u03c6\u2081 \u03c6\u2082) : Cochain F G (-1) :=\n  Cochain.mk (fun p q _ => ho.hom p q)", "start": [190, 1], "end": [192, 39], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHomotopy_ofEq", "code": "@[simp]\nlemma ofHomotopy_ofEq {\u03c6\u2081 \u03c6\u2082 : F \u27f6 G} (h : \u03c6\u2081 = \u03c6\u2082) :\n    ofHomotopy (Homotopy.ofEq h) = 0 := rfl", "start": [194, 1], "end": [196, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHomotopy_refl", "code": "@[simp]\nlemma ofHomotopy_refl (\u03c6 : F \u27f6 G) :\n    ofHomotopy (Homotopy.refl \u03c6) = 0 := rfl", "start": [198, 1], "end": [200, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_hom", "code": "@[reassoc]\nlemma v_comp_XIsoOfEq_hom\n    (\u03b3 : Cochain F G n) (p q q' : \u2124) (hpq : p + n = q) (hq' : q = q') :\n    \u03b3.v p q hpq \u226b (HomologicalComplex.XIsoOfEq G hq').hom = \u03b3.v p q' (by rw [\u2190 hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_hom, comp_id]", "start": [202, 1], "end": [207, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.v_comp_XIsoOfEq_inv", "code": "@[reassoc]\nlemma v_comp_XIsoOfEq_inv\n    (\u03b3 : Cochain F G n) (p q q' : \u2124) (hpq : p + n = q) (hq' : q' = q) :\n    \u03b3.v p q hpq \u226b (HomologicalComplex.XIsoOfEq G hq').inv = \u03b3.v p q' (by rw [hq', hpq]) := by\n  subst hq'\n  simp only [HomologicalComplex.XIsoOfEq, eqToIso_refl, Iso.refl_inv, comp_id]", "start": [209, 1], "end": [214, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp", "code": "@[pp_dot]\ndef comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (h : n\u2081 + n\u2082 = n\u2081\u2082) :\n    Cochain F K n\u2081\u2082 :=\n  Cochain.mk (fun p q hpq => z\u2081.v p (p + n\u2081) rfl \u226b z\u2082.v (p + n\u2081) q (by linarith))", "start": [216, 1], "end": [220, 82], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_v", "code": "lemma comp_v {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (h : n\u2081 + n\u2082 = n\u2081\u2082)\n    (p\u2081 p\u2082 p\u2083 : \u2124) (h\u2081 : p\u2081 + n\u2081 = p\u2082) (h\u2082 : p\u2082 + n\u2082 = p\u2083) :\n    (z\u2081.comp z\u2082 h).v p\u2081 p\u2083 (by rw [\u2190 h\u2082, \u2190 h\u2081, \u2190 h, add_assoc]) =\n      z\u2081.v p\u2081 p\u2082 h\u2081 \u226b z\u2082.v p\u2082 p\u2083 h\u2082 := by\n  subst h\u2081; rfl", "start": [235, 1], "end": [239, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_zero_cochain_v", "code": "@[simp]\nlemma comp_zero_cochain_v (z\u2081 : Cochain F G n) (z\u2082 : Cochain G K 0) (p q : \u2124) (hpq : p + n = q) :\n    (z\u2081.comp z\u2082 (add_zero n)).v p q hpq = z\u2081.v p q hpq \u226b z\u2082.v q q (add_zero q) :=\n  comp_v z\u2081 z\u2082 (add_zero n) p q q hpq (add_zero q)", "start": [241, 1], "end": [244, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.zero_cochain_comp_v", "code": "@[simp]\nlemma zero_cochain_comp_v (z\u2081 : Cochain F G 0) (z\u2082 : Cochain G K n) (p q : \u2124) (hpq : p + n = q) :\n    (z\u2081.comp z\u2082 (zero_add n)).v p q hpq = z\u2081.v p p (add_zero p) \u226b z\u2082.v p q hpq :=\n  comp_v z\u2081 z\u2082 (zero_add n) p p q (add_zero p) hpq", "start": [246, 1], "end": [249, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_assoc", "code": "lemma comp_assoc {n\u2081 n\u2082 n\u2083 n\u2081\u2082 n\u2082\u2083 n\u2081\u2082\u2083 : \u2124}\n    (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (z\u2083 : Cochain K L n\u2083)\n    (h\u2081\u2082 : n\u2081 + n\u2082 = n\u2081\u2082) (h\u2082\u2083 : n\u2082 + n\u2083 = n\u2082\u2083) (h\u2081\u2082\u2083 : n\u2081 + n\u2082 + n\u2083 = n\u2081\u2082\u2083) :\n    (z\u2081.comp z\u2082 h\u2081\u2082).comp z\u2083 (show n\u2081\u2082 + n\u2083 = n\u2081\u2082\u2083 by rw [\u2190 h\u2081\u2082, h\u2081\u2082\u2083]) =\n      z\u2081.comp (z\u2082.comp z\u2083 h\u2082\u2083) (by rw [\u2190 h\u2082\u2083, \u2190 h\u2081\u2082\u2083, add_assoc]) := by\n  substs h\u2081\u2082 h\u2082\u2083 h\u2081\u2082\u2083\n  ext p q hpq\n  rw [comp_v _ _ rfl p (p + n\u2081 + n\u2082) q (by linarith) (by linarith),\n    comp_v z\u2081 z\u2082 rfl p (p + n\u2081) (p + n\u2081 + n\u2082) (by linarith) (by linarith),\n    comp_v z\u2081 (z\u2082.comp z\u2083 rfl) (add_assoc n\u2081 n\u2082 n\u2083).symm p (p + n\u2081) q (by linarith) (by linarith),\n    comp_v z\u2082 z\u2083 rfl (p + n\u2081) (p + n\u2081 + n\u2082) q (by linarith) (by linarith), assoc]", "start": [251, 1], "end": [262, 82], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_assoc_of_first_is_zero_cochain", "code": "@[simp]\nlemma comp_assoc_of_first_is_zero_cochain {n\u2082 n\u2083 n\u2082\u2083 : \u2124}\n    (z\u2081 : Cochain F G 0) (z\u2082 : Cochain G K n\u2082) (z\u2083 : Cochain K L n\u2083)\n    (h\u2082\u2083 : n\u2082 + n\u2083 = n\u2082\u2083) :\n    (z\u2081.comp z\u2082 (zero_add n\u2082)).comp z\u2083 h\u2082\u2083 = z\u2081.comp (z\u2082.comp z\u2083 h\u2082\u2083) (zero_add n\u2082\u2083) :=\n  comp_assoc _ _ _ _ _ (by linarith)", "start": [269, 1], "end": [274, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_assoc_of_second_is_zero_cochain", "code": "@[simp]\nlemma comp_assoc_of_second_is_zero_cochain {n\u2081 n\u2083 n\u2081\u2083 : \u2124}\n    (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K 0) (z\u2083 : Cochain K L n\u2083) (h\u2081\u2083 : n\u2081 + n\u2083 = n\u2081\u2083) :\n    (z\u2081.comp z\u2082 (add_zero n\u2081)).comp z\u2083 h\u2081\u2083 = z\u2081.comp (z\u2082.comp z\u2083 (zero_add n\u2083)) h\u2081\u2083 :=\n  comp_assoc _ _ _ _ _ (by linarith)", "start": [276, 1], "end": [280, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_assoc_of_third_is_zero_cochain", "code": "@[simp]\nlemma comp_assoc_of_third_is_zero_cochain {n\u2081 n\u2082 n\u2081\u2082 : \u2124}\n    (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (z\u2083 : Cochain K L 0) (h\u2081\u2082 : n\u2081 + n\u2082 = n\u2081\u2082) :\n    (z\u2081.comp z\u2082 h\u2081\u2082).comp z\u2083 (add_zero n\u2081\u2082) = z\u2081.comp (z\u2082.comp z\u2083 (add_zero n\u2082)) h\u2081\u2082 :=\n  comp_assoc _ _ _ _ _ (by linarith)", "start": [282, 1], "end": [286, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_assoc_of_second_degree_eq_neg_third_degree", "code": "@[simp]\nlemma comp_assoc_of_second_degree_eq_neg_third_degree {n\u2081 n\u2082 n\u2081\u2082 : \u2124}\n    (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K (-n\u2082)) (z\u2083 : Cochain K L n\u2082) (h\u2081\u2082 : n\u2081 + (-n\u2082) = n\u2081\u2082) :\n    (z\u2081.comp z\u2082 h\u2081\u2082).comp z\u2083\n      (show n\u2081\u2082 + n\u2082 = n\u2081 by rw [\u2190 h\u2081\u2082, add_assoc, neg_add_self, add_zero]) =\n      z\u2081.comp (z\u2082.comp z\u2083 (neg_add_self n\u2082)) (add_zero n\u2081) :=\n  comp_assoc _ _ _ _ _ (by linarith)", "start": [288, 1], "end": [294, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.zero_comp", "code": "@[simp]\nprotected lemma zero_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : (0 : Cochain F G n\u2081).comp z\u2082 h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), zero_v, zero_comp]", "start": [296, 1], "end": [300, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.add_comp", "code": "@[simp]\nprotected lemma add_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 z\u2081' : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : (z\u2081 + z\u2081').comp z\u2082 h = z\u2081.comp z\u2082 h + z\u2081'.comp z\u2082 h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), add_v, add_comp]", "start": [302, 1], "end": [306, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.sub_comp", "code": "@[simp]\nprotected lemma sub_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 z\u2081' : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : (z\u2081 - z\u2081').comp z\u2082 h = z\u2081.comp z\u2082 h - z\u2081'.comp z\u2082 h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), sub_v, sub_comp]", "start": [308, 1], "end": [312, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.neg_comp", "code": "@[simp]\nprotected lemma neg_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : (-z\u2081).comp z\u2082 h = -z\u2081.comp z\u2082 h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), neg_v, neg_comp]", "start": [314, 1], "end": [318, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.zsmul_comp", "code": "@[simp]\nprotected lemma zsmul_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (k : \u2124) (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : (k \u2022 z\u2081).comp z\u2082 h = k \u2022 (z\u2081.comp z\u2082 h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), zsmul_v, zsmul_comp]", "start": [320, 1], "end": [324, 72], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.id_comp", "code": "@[simp]\nprotected lemma id_comp {n : \u2124} (z\u2082 : Cochain F G n) :\n    (Cochain.ofHom (\ud835\udfd9 F)).comp z\u2082 (zero_add n) = z\u2082 := by\n  ext p q hpq\n  simp only [zero_cochain_comp_v, ofHom_v, HomologicalComplex.id_f, id_comp]", "start": [326, 1], "end": [330, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_zero", "code": "@[simp]\nprotected lemma comp_zero {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : z\u2081.comp (0 : Cochain G K n\u2082) h = 0 := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), zero_v, comp_zero]", "start": [332, 1], "end": [336, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_add", "code": "@[simp]\nprotected lemma comp_add {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 z\u2082' : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : z\u2081.comp (z\u2082 + z\u2082') h = z\u2081.comp z\u2082 h + z\u2081.comp z\u2082' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), add_v, comp_add]", "start": [338, 1], "end": [342, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_sub", "code": "@[simp]\nprotected lemma comp_sub {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 z\u2082' : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : z\u2081.comp (z\u2082 - z\u2082') h = z\u2081.comp z\u2082 h - z\u2081.comp z\u2082' h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), sub_v, comp_sub]", "start": [344, 1], "end": [348, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_neg", "code": "@[simp]\nprotected lemma comp_neg {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082) : z\u2081.comp (-z\u2082) h = -z\u2081.comp z\u2082 h := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), neg_v, comp_neg]", "start": [350, 1], "end": [354, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_zsmul", "code": "@[simp]\nprotected lemma comp_zsmul {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (k : \u2124) (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082)\n    (h : n\u2081 + n\u2082 = n\u2081\u2082 ) : z\u2081.comp (k \u2022 z\u2082) h = k \u2022 (z\u2081.comp z\u2082 h) := by\n  ext p q hpq\n  simp only [comp_v _ _ h p _ q rfl (by linarith), zsmul_v, comp_zsmul]", "start": [356, 1], "end": [360, 72], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.comp_id", "code": "@[simp]\nprotected lemma comp_id {n : \u2124} (z\u2081 : Cochain F G n) :\n    z\u2081.comp (Cochain.ofHom (\ud835\udfd9 G)) (add_zero n) = z\u2081 := by\n  ext p q hpq\n  simp only [comp_zero_cochain_v, ofHom_v, HomologicalComplex.id_f, comp_id]", "start": [362, 1], "end": [366, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHoms_comp", "code": "@[simp]\nlemma ofHoms_comp (\u03c6 : \u2200 (p : \u2124), F.X p \u27f6 G.X p) (\u03c8 : \u2200 (p : \u2124), G.X p \u27f6 K.X p) :\n    (ofHoms \u03c6).comp (ofHoms \u03c8) (zero_add 0) = ofHoms (fun p => \u03c6 p \u226b \u03c8 p) := by aesop_cat", "start": [368, 1], "end": [370, 90], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_comp", "code": "@[simp]\nlemma ofHom_comp (f : F \u27f6 G) (g : G \u27f6 K) :\n    ofHom (f \u226b g) = (ofHom f).comp (ofHom g) (zero_add 0) := by\n  simp only [ofHom, HomologicalComplex.comp_f, ofHoms_comp]", "start": [372, 1], "end": [375, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.diff", "code": "def diff : Cochain K K 1 := Cochain.mk (fun p q _ => K.d p q)", "start": [379, 1], "end": [380, 62], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.diff_v", "code": "@[simp]\nlemma diff_v (p q : \u2124) (hpq : p + 1 = q) : (diff K).v p q hpq = K.d p q := rfl", "start": [382, 1], "end": [383, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4", "code": "def \u03b4 (z : Cochain F G n) : Cochain F G m :=\n  Cochain.mk (fun p q hpq => z.v p (p + n) rfl \u226b G.d (p + n) q +\n    m.negOnePow \u2022 F.d p (p + m - n) \u226b z.v (p + m - n) q (by rw [hpq, sub_add_cancel]))", "start": [389, 1], "end": [392, 87], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.\u03b4_v", "code": "lemma \u03b4_v (hnm : n + 1 = m) (z : Cochain F G n) (p q : \u2124) (hpq : p + m = q) (q\u2081 q\u2082 : \u2124)\n    (hq\u2081 : q\u2081 = q - 1) (hq\u2082 : p + 1 = q\u2082) : (\u03b4 n m z).v p q hpq =\n    z.v p q\u2081 (by rw [hq\u2081, \u2190 hpq, \u2190 hnm, \u2190 add_assoc, add_sub_cancel]) \u226b G.d q\u2081 q\n      + m.negOnePow \u2022 F.d p q\u2082 \u226b z.v q\u2082 q\n          (by rw [\u2190 hq\u2082, add_assoc, add_comm 1, hnm, hpq]) := by\n  obtain rfl : q\u2081 = p + n := by linarith\n  obtain rfl : q\u2082 = p + m - n := by linarith\n  rfl", "start": [400, 1], "end": [407, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_shape", "code": "lemma \u03b4_shape (hnm : \u00ac n + 1 = m) (z : Cochain F G n) : \u03b4 n m z = 0 := by\n  ext p q hpq\n  dsimp only [\u03b4]\n  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]\n  all_goals\n    simp only [ComplexShape.up_Rel]\n    exact fun _ => hnm (by linarith)", "start": [409, 1], "end": [415, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_hom", "code": "@[simps!]\ndef \u03b4_hom : Cochain F G n \u2192+ Cochain F G m :=\n  AddMonoidHom.mk' (\u03b4 n m) (fun \u03b1 \u03b2 => by\n    by_cases n + 1 = m\n    \u00b7 ext p q hpq\n      dsimp\n      simp only [\u03b4_v n m h _ p q hpq _ _ rfl rfl, Cochain.add_v, add_comp, comp_add, zsmul_add]\n      abel\n    \u00b7 simp only [\u03b4_shape _ _ h, add_zero])", "start": [419, 1], "end": [429, 43], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.\u03b4_add", "code": "@[simp] lemma \u03b4_add (z\u2081 z\u2082 : Cochain F G n) : \u03b4 n m (z\u2081 + z\u2082) = \u03b4 n m z\u2081 + \u03b4 n m z\u2082 :=\n  (\u03b4_hom F G n m).map_add z\u2081 z\u2082", "start": [433, 1], "end": [434, 32], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_sub", "code": "@[simp] lemma \u03b4_sub (z\u2081 z\u2082 : Cochain F G n) : \u03b4 n m (z\u2081 - z\u2082) = \u03b4 n m z\u2081 - \u03b4 n m z\u2082 :=\n  (\u03b4_hom F G n m).map_sub z\u2081 z\u2082", "start": [436, 1], "end": [437, 32], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_zero", "code": "@[simp] lemma \u03b4_zero : \u03b4 n m (0 : Cochain F G n) = 0 := (\u03b4_hom F G n m).map_zero", "start": [439, 1], "end": [439, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_neg", "code": "@[simp] lemma \u03b4_neg (z : Cochain F G n) : \u03b4 n m (-z) = - \u03b4 n m z :=\n  (\u03b4_hom F G n m).map_neg z", "start": [441, 1], "end": [442, 28], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_zsmul", "code": "@[simp] lemma \u03b4_zsmul (k : \u2124) (z : Cochain F G n) : \u03b4 n m (k \u2022 z) = k \u2022 \u03b4 n m z :=\n  (\u03b4_hom F G n m).map_zsmul z k", "start": [444, 1], "end": [445, 32], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_\u03b4", "code": "lemma \u03b4_\u03b4 (n\u2080 n\u2081 n\u2082 : \u2124) (z : Cochain F G n\u2080) : \u03b4 n\u2081 n\u2082 (\u03b4 n\u2080 n\u2081 z) = 0 := by\n  by_cases h\u2081\u2082 : n\u2081 + 1 = n\u2082; swap; rw [\u03b4_shape _ _ h\u2081\u2082]\n  by_cases h\u2080\u2081 : n\u2080 + 1 = n\u2081; swap; rw [\u03b4_shape _ _ h\u2080\u2081, \u03b4_zero]\n  ext p q hpq\n  dsimp\n  simp only [\u03b4_v n\u2081 n\u2082 h\u2081\u2082 _ p q hpq _ _ rfl rfl,\n    \u03b4_v n\u2080 n\u2081 h\u2080\u2081 z p (q-1) (by linarith) (q-2) _ (by linarith) rfl,\n    \u03b4_v n\u2080 n\u2081 h\u2080\u2081 z (p+1) q (by linarith) _ (p+2) rfl (by linarith),\n    \u2190 h\u2081\u2082, Int.negOnePow_succ, sub_add_cancel, add_comp, assoc,\n    HomologicalComplex.d_comp_d, comp_zero, zsmul_comp, zero_add, comp_add,\n    comp_zsmul, HomologicalComplex.d_comp_d_assoc, zero_comp, smul_zero,\n    add_zero, neg_smul, add_right_neg]", "start": [447, 1], "end": [458, 39], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_comp", "code": "lemma \u03b4_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (h : n\u2081 + n\u2082 = n\u2081\u2082)\n    (m\u2081 m\u2082 m\u2081\u2082 : \u2124) (h\u2081\u2082 : n\u2081\u2082 + 1 = m\u2081\u2082) (h\u2081 : n\u2081 + 1 = m\u2081) (h\u2082 : n\u2082 + 1 = m\u2082) :\n    \u03b4 n\u2081\u2082 m\u2081\u2082 (z\u2081.comp z\u2082 h) = z\u2081.comp (\u03b4 n\u2082 m\u2082 z\u2082) (by rw [\u2190 h\u2081\u2082, \u2190 h\u2082, \u2190 h, add_assoc]) +\n      n\u2082.negOnePow \u2022 (\u03b4 n\u2081 m\u2081 z\u2081).comp z\u2082\n        (by rw [\u2190 h\u2081\u2082, \u2190 h\u2081, \u2190 h, add_assoc, add_comm 1, add_assoc]) := by\n  subst h\u2081\u2082 h\u2081 h\u2082 h\n  ext p q hpq\n  dsimp\n  rw [z\u2081.comp_v _ (add_assoc n\u2081 n\u2082 1).symm p _ q rfl (by linarith),\n    Cochain.comp_v _ _ (show n\u2081 + 1 + n\u2082 = n\u2081 + n\u2082 + 1 by linarith) p (p+n\u2081+1) q\n      (by linarith) (by linarith),\n    \u03b4_v (n\u2081 + n\u2082) _ rfl (z\u2081.comp z\u2082 rfl) p q hpq (p + n\u2081 + n\u2082) _ (by linarith) rfl,\n    z\u2081.comp_v z\u2082 rfl p _ _ rfl rfl,\n    z\u2081.comp_v z\u2082 rfl (p+1) (p+n\u2081+1) q (by linarith) (by linarith),\n    \u03b4_v n\u2082 (n\u2082+1) rfl z\u2082 (p+n\u2081) q (by linarith) (p+n\u2081+n\u2082) _ (by linarith) rfl,\n    \u03b4_v n\u2081 (n\u2081+1) rfl z\u2081 p (p+n\u2081+1) (by linarith) (p+n\u2081) _ (by linarith) rfl]\n  simp only [assoc, comp_add, add_comp, Int.negOnePow_succ, Int.negOnePow_add n\u2081 n\u2082,\n    neg_smul, comp_neg, neg_comp, comp_zsmul, zsmul_comp, zsmul_add, smul_neg, smul_smul,\n    mul_comm n\u2081.negOnePow n\u2082.negOnePow]\n  abel", "start": [460, 1], "end": [479, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_zero_cochain_comp", "code": "lemma \u03b4_zero_cochain_comp {n\u2082 : \u2124} (z\u2081 : Cochain F G 0) (z\u2082 : Cochain G K n\u2082)\n    (m\u2082 : \u2124) (h\u2082 : n\u2082 + 1 = m\u2082) :\n    \u03b4 n\u2082 m\u2082 (z\u2081.comp z\u2082 (zero_add n\u2082)) =\n      z\u2081.comp (\u03b4 n\u2082 m\u2082 z\u2082) (zero_add m\u2082) +\n      n\u2082.negOnePow \u2022 ((\u03b4 0 1 z\u2081).comp z\u2082 (by rw [add_comm, h\u2082])) :=\n  \u03b4_comp z\u2081 z\u2082 (zero_add n\u2082) 1 m\u2082 m\u2082 h\u2082 (zero_add 1) h\u2082", "start": [481, 1], "end": [486, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_comp_zero_cochain", "code": "lemma \u03b4_comp_zero_cochain {n\u2081 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K 0)\n    (m\u2081 : \u2124) (h\u2081 : n\u2081 + 1 = m\u2081) :\n    \u03b4 n\u2081 m\u2081 (z\u2081.comp z\u2082 (add_zero n\u2081)) =\n      z\u2081.comp (\u03b4 0 1 z\u2082) h\u2081 + (\u03b4 n\u2081 m\u2081 z\u2081).comp z\u2082 (add_zero m\u2081) := by\n  simp only [\u03b4_comp z\u2081 z\u2082 (add_zero n\u2081) m\u2081 1 m\u2081 h\u2081 h\u2081 (zero_add 1), one_zsmul,\n    Int.negOnePow_zero]", "start": [488, 1], "end": [493, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_zero_cochain_v", "code": "@[simp]\nlemma \u03b4_zero_cochain_v (z : Cochain F G 0) (p q : \u2124) (hpq : p + 1 = q) :\n    (\u03b4 0 1 z).v p q hpq = z.v p p (add_zero p) \u226b G.d p q - F.d p q \u226b z.v q q (add_zero q) := by\n  simp only [\u03b4_v 0 1 (zero_add 1) z p q hpq p q (by linarith) hpq, zero_add,\n    Int.negOnePow_one, neg_smul, one_smul, sub_eq_add_neg]", "start": [495, 1], "end": [499, 59], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_ofHom", "code": "@[simp]\nlemma \u03b4_ofHom {p : \u2124} (\u03c6 : F \u27f6 G) : \u03b4 0 p (Cochain.ofHom \u03c6) = 0 := by\n  by_cases p = 1\n  \u00b7 subst h\n    ext\n    simp\n  \u00b7 rw [\u03b4_shape]\n    intro\n    exact h (by linarith)", "start": [501, 1], "end": [509, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_ofHomotopy", "code": "@[simp]\nlemma \u03b4_ofHomotopy {\u03c6\u2081 \u03c6\u2082 : F \u27f6 G} (h : Homotopy \u03c6\u2081 \u03c6\u2082) :\n    \u03b4 (-1) 0 (Cochain.ofHomotopy h) = Cochain.ofHom \u03c6\u2081 - Cochain.ofHom \u03c6\u2082 := by\n  ext p\n  have eq := h.comm p\n  rw [dNext_eq h.hom (show (ComplexShape.up \u2124).Rel p (p+1) by simp),\n    prevD_eq h.hom (show (ComplexShape.up \u2124).Rel (p-1) p by simp)] at eq\n  rw [Cochain.ofHomotopy, \u03b4_v (-1) 0 (neg_add_self 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [Cochain.mk_v, add_left_neg, one_zsmul, Int.negOnePow_zero,\n    Cochain.sub_v, Cochain.ofHom_v, eq]\n  abel", "start": [512, 1], "end": [522, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_neg_one_cochain", "code": "lemma \u03b4_neg_one_cochain (z : Cochain F G (-1)) :\n    \u03b4 (-1) 0 z = Cochain.ofHom (Homotopy.nullHomotopicMap'\n      (fun i j hij => z.v i j (by dsimp at hij; rw [\u2190 hij, add_neg_cancel_right]))) := by\n  ext p\n  rw [\u03b4_v (-1) 0 (neg_add_self 1) _ p p (add_zero p) (p-1) (p+1) rfl rfl]\n  simp only [neg_add_self, one_smul, Cochain.ofHom_v, Int.negOnePow_zero]\n  rw [Homotopy.nullHomotopicMap'_f (show (ComplexShape.up \u2124).Rel (p-1) p by simp)\n    (show (ComplexShape.up \u2124).Rel p (p+1) by simp)]\n  abel", "start": [524, 1], "end": [532, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex", "code": "@[simps! X d_apply]\ndef HomComplex : CochainComplex AddCommGroupCat \u2124 where\n  X i := AddCommGroupCat.of (Cochain F G i)\n  d i j := AddCommGroupCat.ofHom (\u03b4_hom F G i j)\n  shape _ _ hij := by ext; apply \u03b4_shape _ _ hij\n  d_comp_d' _ _ _ _ _  := by ext; apply \u03b4_\u03b4", "start": [539, 1], "end": [546, 44], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.cocycle", "code": "def cocycle : AddSubgroup (Cochain F G n) :=\n  AddMonoidHom.ker (\u03b4_hom F G n (n+1))", "start": [550, 1], "end": [552, 39], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle", "code": "def Cocycle : Type v := cocycle F G n", "start": [554, 1], "end": [555, 38], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle.ext", "code": "@[ext]\nlemma ext (z\u2081 z\u2082 : Cocycle F G n) (h : (z\u2081 : Cochain F G n) = z\u2082) : z\u2081 = z\u2082 :=\n  Subtype.ext h", "start": [568, 1], "end": [570, 16], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.ext_iff", "code": "lemma ext_iff (z\u2081 z\u2082 : Cocycle F G n) : z\u2081 = z\u2082 \u2194 (z\u2081 : Cochain F G n) = z\u2082 :=\n  Subtype.ext_iff", "start": [572, 1], "end": [573, 18], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.coe_zero", "code": "@[simp]\nlemma coe_zero : (\u2191(0 : Cocycle F G n) : Cochain F G n) = 0 := by rfl", "start": [577, 1], "end": [578, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.coe_add", "code": "@[simp]\nlemma coe_add (z\u2081 z\u2082 : Cocycle F G n) :\n    (\u2191(z\u2081 + z\u2082) : Cochain F G n) = (z\u2081 : Cochain F G n) + (z\u2082 : Cochain F G n) := rfl", "start": [582, 1], "end": [584, 86], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.coe_neg", "code": "@[simp]\nlemma coe_neg (z : Cocycle F G n) :\n    (\u2191(-z) : Cochain F G n) = -(z : Cochain F G n) := rfl", "start": [586, 1], "end": [588, 58], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.coe_zsmul", "code": "@[simp]\nlemma coe_zsmul (z : Cocycle F G n) (x : \u2124) :\n    (\u2191(x \u2022 z) : Cochain F G n) = x \u2022 (z : Cochain F G n) := rfl", "start": [590, 1], "end": [592, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.coe_sub", "code": "@[simp]\nlemma coe_sub (z\u2081 z\u2082 : Cocycle F G n) :\n    (\u2191(z\u2081 - z\u2082) : Cochain F G n) = (z\u2081 : Cochain F G n) - (z\u2082 : Cochain F G n) := rfl", "start": [594, 1], "end": [596, 86], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.mem_iff", "code": "lemma mem_iff (hnm : n + 1 = m) (z : Cochain F G n) :\n    z \u2208 cocycle F G n \u2194 \u03b4 n m z = 0 := by subst hnm; rfl", "start": [600, 1], "end": [601, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.mk", "code": "@[simps]\ndef mk (z : Cochain F G n) (m : \u2124) (hnm : n + 1 = m) (h : \u03b4 n m z = 0) : Cocycle F G n :=\n  \u27e8z, by simpa only [mem_iff n m hnm z] using h\u27e9", "start": [605, 1], "end": [609, 49], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle.\u03b4_eq_zero", "code": "@[simp]\nlemma \u03b4_eq_zero {n : \u2124} (z : Cocycle F G n) (m : \u2124) : \u03b4 n m (z : Cochain F G n) = 0 := by\n  by_cases h : n + 1 = m\n  \u00b7 rw [\u2190 mem_iff n m h]\n    exact z.2\n  \u00b7 exact \u03b4_shape n m h _", "start": [611, 1], "end": [616, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.ofHom", "code": "@[simps!]\ndef ofHom (\u03c6 : F \u27f6 G) : Cocycle F G 0 := mk (Cochain.ofHom \u03c6) 1 (zero_add 1) (by simp)", "start": [618, 1], "end": [620, 87], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle.homOf", "code": "@[simps]\ndef homOf (z : Cocycle F G 0) : F \u27f6 G where\n  f i := (z : Cochain _ _ _).v i i (add_zero i)\n  comm' := by\n    rintro i j rfl\n    rcases z with \u27e8z, hz\u27e9\n    dsimp\n    rw [mem_iff 0 1 (zero_add 1)] at hz\n    simpa only [\u03b4_zero_cochain_v, Cochain.zero_v, sub_eq_zero]\n      using Cochain.congr_v hz i (i + 1) rfl", "start": [622, 1], "end": [632, 45], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle.homOf_ofHom_eq_self", "code": "@[simp]\nlemma homOf_ofHom_eq_self (\u03c6 : F \u27f6 G) : homOf (ofHom \u03c6) = \u03c6 := by aesop_cat", "start": [634, 1], "end": [635, 76], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.ofHom_homOf_eq_self", "code": "@[simp]\nlemma ofHom_homOf_eq_self (z : Cocycle F G 0) : ofHom (homOf z) = z := by aesop_cat", "start": [637, 1], "end": [638, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.cochain_ofHom_homOf_eq_coe", "code": "@[simp]\nlemma cochain_ofHom_homOf_eq_coe (z : Cocycle F G 0) :\n    Cochain.ofHom (homOf z) = (z : Cochain F G 0) := by\n  simpa only [ext_iff] using ofHom_homOf_eq_self z", "start": [640, 1], "end": [643, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cocycle.equivHom", "code": "@[simps]\ndef equivHom : (F \u27f6 G) \u2243+ Cocycle F G 0 where\n  toFun := ofHom\n  invFun := homOf\n  left_inv := homOf_ofHom_eq_self\n  right_inv := ofHom_homOf_eq_self\n  map_add' := by aesop_cat", "start": [647, 1], "end": [654, 27], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cocycle.diff", "code": "@[simps!]\ndef diff : Cocycle K K 1 :=\n  Cocycle.mk (Cochain.diff K) 2 rfl (by\n    ext p q hpq\n    simp only [Cochain.zero_v, \u03b4_v 1 2 rfl _ p q hpq _ _ rfl rfl, Cochain.diff_v,\n      HomologicalComplex.d_comp_d, smul_zero, add_zero])", "start": [658, 1], "end": [664, 57], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.equivHomotopy", "code": "@[simps]\ndef equivHomotopy (\u03c6\u2081 \u03c6\u2082 : F \u27f6 G) :\n    Homotopy \u03c6\u2081 \u03c6\u2082 \u2243\n      { z : Cochain F G (-1) // Cochain.ofHom \u03c6\u2081 = \u03b4 (-1) 0 z + Cochain.ofHom \u03c6\u2082 } where\n  toFun ho := \u27e8Cochain.ofHomotopy ho, by simp only [\u03b4_ofHomotopy, sub_add_cancel]\u27e9\n  invFun z :=\n    { hom := fun i j => if hij : i + (-1) = j then z.1.v i j hij else 0\n      zero := fun i j (hij : j + 1 \u2260 i) => dif_neg (fun _ => hij (by linarith))\n      comm := fun p => by\n        have eq := Cochain.congr_v z.2 p p (add_zero p)\n        have h\u2081 : (ComplexShape.up \u2124).Rel (p - 1) p := by simp\n        have h\u2082 : (ComplexShape.up \u2124).Rel p (p + 1) := by simp\n        simp only [\u03b4_neg_one_cochain, Cochain.ofHom_v, ComplexShape.up_Rel, Cochain.add_v,\n          Homotopy.nullHomotopicMap'_f h\u2081 h\u2082] at eq\n        rw [dNext_eq _ h\u2082, prevD_eq _ h\u2081, eq, dif_pos, dif_pos] }\n  left_inv := fun ho => by\n    ext i j\n    dsimp\n    split_ifs with h\n    \u00b7 rfl\n    \u00b7 rw [ho.zero i j (fun h' => h (by dsimp at h'; linarith))]\n  right_inv := fun z => by\n    ext p q hpq\n    dsimp [Cochain.ofHomotopy]\n    rw [dif_pos hpq]", "start": [672, 1], "end": [699, 21], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.equivHomotopy_apply_of_eq", "code": "@[simp]\nlemma equivHomotopy_apply_of_eq {\u03c6\u2081 \u03c6\u2082 : F \u27f6 G} (h : \u03c6\u2081 = \u03c6\u2082) :\n    (equivHomotopy _ _ (Homotopy.ofEq h)).1 = 0 := rfl", "start": [701, 1], "end": [703, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.ofHom_injective", "code": "lemma ofHom_injective {f\u2081 f\u2082 : F \u27f6 G} (h : ofHom f\u2081 = ofHom f\u2082) : f\u2081 = f\u2082 :=\n  (Cocycle.equivHom F G).injective (by ext1; exact h)", "start": [705, 1], "end": [706, 54], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map", "code": "def map : Cochain ((\u03a6.mapHomologicalComplex _).obj K) ((\u03a6.mapHomologicalComplex _).obj L) n :=\n  Cochain.mk (fun p q hpq => \u03a6.map (z.v p q hpq))", "start": [717, 1], "end": [722, 50], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_v", "code": "@[simp]\nlemma map_v (p q : \u2124) (hpq : p + n = q) : (z.map \u03a6).v p q hpq = \u03a6.map (z.v p q hpq) := rfl", "start": [724, 1], "end": [725, 91], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_add", "code": "@[simp]\nlemma map_add : (z + z').map \u03a6 = z.map \u03a6 + z'.map \u03a6 := by aesop_cat", "start": [727, 1], "end": [728, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_neg", "code": "@[simp]\nlemma map_neg : (-z).map \u03a6 = -z.map \u03a6 := by aesop_cat", "start": [730, 1], "end": [731, 54], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_sub", "code": "@[simp]\nlemma map_sub : (z - z').map \u03a6 = z.map \u03a6 - z'.map \u03a6 := by aesop_cat", "start": [733, 1], "end": [734, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_zero", "code": "@[simp]\nlemma map_zero : (0 : Cochain K L n).map \u03a6 = 0 := by aesop_cat", "start": [738, 1], "end": [739, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_comp", "code": "@[simp]\nlemma map_comp {n\u2081 n\u2082 n\u2081\u2082 : \u2124} (z\u2081 : Cochain F G n\u2081) (z\u2082 : Cochain G K n\u2082) (h : n\u2081 + n\u2082 = n\u2081\u2082)\n    (\u03a6 : C \u2964 D) [\u03a6.Additive] :\n    (Cochain.comp z\u2081 z\u2082 h).map \u03a6 = Cochain.comp (z\u2081.map \u03a6) (z\u2082.map \u03a6) h := by\n  ext p q hpq\n  dsimp\n  simp only [map_v, comp_v _ _ h p _ q rfl (by linarith), \u03a6.map_comp]", "start": [741, 1], "end": [747, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.Cochain.map_ofHom", "code": "@[simp]\nlemma map_ofHom :\n    (Cochain.ofHom f).map \u03a6 = Cochain.ofHom ((\u03a6.mapHomologicalComplex _).map f) := by aesop_cat", "start": [749, 1], "end": [751, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CochainComplex.HomComplex.\u03b4_map", "code": "@[simp]\nlemma \u03b4_map : \u03b4 n m (z.map \u03a6) = (\u03b4 n m z).map \u03a6 := by\n  by_cases hnm : n + 1 = m\n  \u00b7 ext p q hpq\n    dsimp\n    simp only [\u03b4_v n m hnm _ p q hpq (q-1) (p+1) rfl rfl,\n      Functor.map_add, Functor.map_comp, Functor.map_zsmul,\n      Cochain.map_v, Functor.mapHomologicalComplex_obj_d]\n  \u00b7 simp only [\u03b4_shape _ _ hnm, Cochain.map_zero]", "start": [757, 1], "end": [765, 50], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Homology/ModuleCat.lean", "imports": ["Mathlib/CategoryTheory/Limits/ConcreteCategory.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/Algebra/Homology/Homotopy.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Subobject.lean"], "premises": [{"full_name": "ModuleCat.homology_ext", "code": "theorem homology_ext {L M N K : ModuleCat R} {f : L \u27f6 M} {g : M \u27f6 N} (w : f \u226b g = 0)\n    {h k : homology f g w \u27f6 K}\n    (w :\n      \u2200 x : LinearMap.ker g,\n        h (cokernel.\u03c0 (imageToKernel _ _ w) (toKernelSubobject x)) =\n          k (cokernel.\u03c0 (imageToKernel _ _ w) (toKernelSubobject x))) :\n    h = k", "start": [35, 1], "end": [50, 12], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.toCycles", "code": "abbrev toCycles {C : HomologicalComplex (ModuleCat.{u} R) c} {i : \u03b9}\n    (x : LinearMap.ker (C.dFrom i)) : (C.cycles i : Type u) :=\n  toKernelSubobject x", "start": [54, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.cycles_ext", "code": "@[ext]\ntheorem cycles_ext {C : HomologicalComplex (ModuleCat.{u} R) c} {i : \u03b9}\n    {x y : (C.cycles i : Type u)}\n    (w : (C.cycles i).arrow x = (C.cycles i).arrow y) : x = y", "start": [61, 1], "end": [66, 10], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.cyclesMap_toCycles", "code": "@[simp]\ntheorem cyclesMap_toCycles (f : C \u27f6 D) {i : \u03b9} (x : LinearMap.ker (C.dFrom i)) :\n    (cyclesMap f i) (toCycles x) = toCycles \u27e8f.f i x.1, by\n      rw [LinearMap.mem_ker]; erw [Hom.comm_from_apply, x.2, map_zero]\u27e9", "start": [72, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.toHomology", "code": "abbrev toHomology {C : HomologicalComplex (ModuleCat.{u} R) c} {i : \u03b9}\n    (x : LinearMap.ker (C.dFrom i)) : C.homology i :=\n  homology.\u03c0 (C.dTo i) (C.dFrom i) _ (toCycles x)", "start": [84, 1], "end": [87, 50], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.homology_ext'", "code": "@[ext]\ntheorem homology_ext' {M : ModuleCat R} (i : \u03b9) {h k : C.homology i \u27f6 M}\n    (w : \u2200 x : LinearMap.ker (C.dFrom i), h (toHomology x) = k (toHomology x)) : h = k", "start": [91, 1], "end": [94, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/HomOrthogonal.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/InvariantBasisNumber.lean", "Mathlib/CategoryTheory/Preadditive/Biproducts.lean", "Mathlib/CategoryTheory/Linear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.HomOrthogonal", "code": "def HomOrthogonal {\u03b9 : Type*} (s : \u03b9 \u2192 C) : Prop :=\n  \u2200 i j, i \u2260 j \u2192 Subsingleton (s i \u27f6 s j)", "start": [48, 1], "end": [53, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.eq_zero", "code": "theorem eq_zero [HasZeroMorphisms C] (o : HomOrthogonal s) {i j : \u03b9} (w : i \u2260 j) (f : s i \u27f6 s j) :\n    f = 0", "start": [60, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.matrixDecomposition", "code": "@[simps]\nnoncomputable def matrixDecomposition (o : HomOrthogonal s) {\u03b1 \u03b2 : Type} [Fintype \u03b1] [Fintype \u03b2]\n    {f : \u03b1 \u2192 \u03b9} {g : \u03b2 \u2192 \u03b9} :\n    ((\u2a01 fun a => s (f a)) \u27f6 \u2a01 fun b => s (g b)) \u2243\n      \u2200 i : \u03b9, Matrix (g \u207b\u00b9' {i}) (f \u207b\u00b9' {i}) (End (s i)) where\n  toFun z i j k :=\n    eqToHom\n        (by\n          rcases k with \u27e8k, \u27e8\u27e9\u27e9\n          simp) \u226b\n      biproduct.components z k j \u226b\n        eqToHom\n          (by\n            rcases j with \u27e8j, \u27e8\u27e9\u27e9\n            simp)\n  invFun z :=\n    biproduct.matrix fun j k =>\n      if h : f j = g k then z (f j) \u27e8k, by simp [h]\u27e9 \u27e8j, by simp\u27e9 \u226b eqToHom (by simp [h]) else 0\n  left_inv z := by\n    ext j k\n    simp only [biproduct.matrix_\u03c0, biproduct.\u03b9_desc]\n    split_ifs with h\n    \u00b7 simp\n      rfl\n    \u00b7 symm\n      apply o.eq_zero h\n  right_inv z := by\n    ext i \u27e8j, w\u27e9 \u27e8k, \u27e8\u27e9\u27e9\n    simp only [eqToHom_refl, biproduct.matrix_components, Category.id_comp]\n    split_ifs with h\n    \u00b7 simp\n    \u00b7 exfalso\n      exact h w.symm", "start": [70, 1], "end": [106, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.matrixDecompositionAddEquiv", "code": "@[simps]\nnoncomputable def matrixDecompositionAddEquiv (o : HomOrthogonal s) {\u03b1 \u03b2 : Type} [Fintype \u03b1]\n    [Fintype \u03b2] {f : \u03b1 \u2192 \u03b9} {g : \u03b2 \u2192 \u03b9} :\n    ((\u2a01 fun a => s (f a)) \u27f6 \u2a01 fun b => s (g b)) \u2243+\n      \u2200 i : \u03b9, Matrix (g \u207b\u00b9' {i}) (f \u207b\u00b9' {i}) (End (s i)) :=\n  { o.matrixDecomposition with\n    map_add' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }", "start": [115, 1], "end": [125, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.matrixDecomposition_id", "code": "@[simp]\ntheorem matrixDecomposition_id (o : HomOrthogonal s) {\u03b1 : Type} [Fintype \u03b1] {f : \u03b1 \u2192 \u03b9} (i : \u03b9) :\n    o.matrixDecomposition (\ud835\udfd9 (\u2a01 fun a => s (f a))) i = 1", "start": [128, 1], "end": [142, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.matrixDecomposition_comp", "code": "theorem matrixDecomposition_comp (o : HomOrthogonal s) {\u03b1 \u03b2 \u03b3 : Type} [Fintype \u03b1] [Fintype \u03b2]\n    [Fintype \u03b3] {f : \u03b1 \u2192 \u03b9} {g : \u03b2 \u2192 \u03b9} {h : \u03b3 \u2192 \u03b9} (z : (\u2a01 fun a => s (f a)) \u27f6 \u2a01 fun b => s (g b))\n    (w : (\u2a01 fun b => s (g b)) \u27f6 \u2a01 fun c => s (h c)) (i : \u03b9) :\n    o.matrixDecomposition (z \u226b w) i = o.matrixDecomposition w i * o.matrixDecomposition z i", "start": [145, 1], "end": [165, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.matrixDecompositionLinearEquiv", "code": "@[simps]\nnoncomputable def matrixDecompositionLinearEquiv (o : HomOrthogonal s) {\u03b1 \u03b2 : Type} [Fintype \u03b1]\n    [Fintype \u03b2] {f : \u03b1 \u2192 \u03b9} {g : \u03b2 \u2192 \u03b9} :\n    ((\u2a01 fun a => s (f a)) \u27f6 \u2a01 fun b => s (g b)) \u2243\u2097[R]\n      \u2200 i : \u03b9, Matrix (g \u207b\u00b9' {i}) (f \u207b\u00b9' {i}) (End (s i)) :=\n  { o.matrixDecompositionAddEquiv with\n    map_smul' := fun w z => by\n      ext\n      dsimp [biproduct.components]\n      simp }", "start": [172, 1], "end": [182, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HomOrthogonal.equiv_of_iso", "code": "theorem equiv_of_iso (o : HomOrthogonal s) {\u03b1 \u03b2 : Type} [Fintype \u03b1] [Fintype \u03b2] {f : \u03b1 \u2192 \u03b9}\n    {g : \u03b2 \u2192 \u03b9} (i : (\u2a01 fun a => s (f a)) \u2245 \u2a01 fun b => s (g b)) :\n    \u2203 e : \u03b1 \u2243 \u03b2, \u2200 a, g (e a) = f a", "start": [195, 1], "end": [214, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Grothendieck.lean", "imports": ["Mathlib/CategoryTheory/Category/Cat.lean", "Mathlib/CategoryTheory/Elements.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Grothendieck", "code": "structure Grothendieck where\n  \n  base : C\n  \n  fiber : F.obj base", "start": [47, 1], "end": [61, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.Hom", "code": "structure Hom (X Y : Grothendieck F) where\n  \n  base : X.base \u27f6 Y.base\n  \n  fiber : (F.map base).obj X.fiber \u27f6 Y.fiber", "start": [68, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.ext", "code": "@[ext]\ntheorem ext {X Y : Grothendieck F} (f g : Hom X Y) (w_base : f.base = g.base)\n    (w_fiber : eqToHom (by rw [w_base]) \u226b f.fiber = g.fiber) : f = g", "start": [78, 1], "end": [84, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.id", "code": "@[simps]\ndef id (X : Grothendieck F) : Hom X X where\n  base := \ud835\udfd9 X.base\n  fiber := eqToHom (by erw [CategoryTheory.Functor.map_id, Functor.id_obj X.fiber])", "start": [87, 1], "end": [92, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.comp", "code": "@[simps]\ndef comp {X Y Z : Grothendieck F} (f : Hom X Y) (g : Hom Y Z) : Hom X Z where\n  base := f.base \u226b g.base\n  fiber :=\n    eqToHom (by erw [Functor.map_comp, Functor.comp_obj]) \u226b (F.map g.base).map f.fiber \u226b g.fiber", "start": [98, 1], "end": [104, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.id_fiber'", "code": "@[simp]\ntheorem id_fiber' (X : Grothendieck F) :\n    Hom.fiber (\ud835\udfd9 X) = eqToHom (by erw [CategoryTheory.Functor.map_id, Functor.id_obj X.fiber])", "start": [127, 1], "end": [130, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.congr", "code": "theorem congr {X Y : Grothendieck F} {f g : X \u27f6 Y} (h : f = g) :\n    f.fiber = eqToHom (by subst h; rfl) \u226b g.fiber", "start": [133, 1], "end": [137, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.forget", "code": "@[simps!]\ndef forget : Grothendieck F \u2964 C where\n  obj X := X.1\n  map := @fun X Y f => f.1", "start": [144, 1], "end": [148, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.grothendieckTypeToCatFunctor", "code": "@[simps!]\ndef grothendieckTypeToCatFunctor : Grothendieck (G \u22d9 typeToCat) \u2964 G.Elements where\n  obj X := \u27e8X.1, X.2.as\u27e9\n  map := @fun X Y f => \u27e8f.1, f.2.1.1\u27e9", "start": [157, 1], "end": [161, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.grothendieckTypeToCatInverse", "code": "@[simps! obj_base obj_fiber_as map_base]\ndef grothendieckTypeToCatInverse : G.Elements \u2964 Grothendieck (G \u22d9 typeToCat) where\n  obj X := \u27e8X.1, \u27e8X.2\u27e9\u27e9\n  map f := \u27e8f.1, \u27e8\u27e8f.2\u27e9\u27e9\u27e9", "start": [165, 1], "end": [173, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Grothendieck.grothendieckTypeToCat", "code": "@[simps! functor_obj_fst functor_obj_snd functor_map_coe inverse_obj_base inverse_obj_fiber_as\n  inverse_map_base unitIso_hom_app_base unitIso_hom_app_fiber unitIso_inv_app_base\n  unitIso_inv_app_fiber counitIso_hom_app_coe counitIso_inv_app_coe]\ndef grothendieckTypeToCat : Grothendieck (G \u22d9 typeToCat) \u224c G.Elements where\n  functor := grothendieckTypeToCatFunctor G\n  inverse := grothendieckTypeToCatInverse G\n  unitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        rcases X with \u27e8_, \u27e8\u27e9\u27e9\n        exact Iso.refl _)\n      (by\n        rintro \u27e8_, \u27e8\u27e9\u27e9 \u27e8_, \u27e8\u27e9\u27e9 \u27e8base, \u27e8\u27e8f\u27e9\u27e9\u27e9\n        dsimp at *\n        simp\n        rfl)\n  counitIso :=\n    NatIso.ofComponents\n      (fun X => by\n        cases X\n        exact Iso.refl _)\n      (by\n        rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8f, e\u27e9\n        dsimp at *\n        simp\n        rfl)\n  functor_unitIso_comp := by\n    rintro \u27e8_, \u27e8\u27e9\u27e9\n    dsimp\n    simp\n    rfl", "start": [177, 1], "end": [214, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean", "imports": ["Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "Mathlib/Algebra/Homology/HomologicalComplex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HomologicalComplex.shortComplexFunctor'", "code": "@[simps]\ndef shortComplexFunctor' (i j k : \u03b9) : HomologicalComplex C c \u2964 ShortComplex C where\n  obj K := ShortComplex.mk (K.d i j) (K.d j k) (K.d_comp_d i j k)\n  map f :=\n    { \u03c4\u2081 := f.f i\n      \u03c4\u2082 := f.f j\n      \u03c4\u2083 := f.f k }", "start": [30, 1], "end": [38, 20], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.shortComplexFunctor", "code": "@[simps!]\nnoncomputable def shortComplexFunctor (i : \u03b9) :=\n  shortComplexFunctor' C c (c.prev i) i (c.next i)", "start": [40, 1], "end": [44, 51], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.natIsoSc'", "code": "@[simps!]\nnoncomputable def natIsoSc' (i j k : \u03b9) (hi : c.prev j = i) (hk : c.next j = k) :\n    shortComplexFunctor C c j \u2245 shortComplexFunctor' C c i j k :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk (K.XIsoOfEq hi) (Iso.refl _) (K.XIsoOfEq hk)\n    (by aesop_cat) (by aesop_cat)) (by aesop_cat)", "start": [46, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.sc'", "code": "abbrev sc' (i j k : \u03b9) := (shortComplexFunctor' C c i j k).obj K", "start": [57, 1], "end": [58, 65], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.sc", "code": "noncomputable abbrev sc (i : \u03b9) := (shortComplexFunctor C c i).obj K", "start": [60, 1], "end": [61, 69], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.isoSc'", "code": "noncomputable abbrev isoSc' (i j k : \u03b9) (hi : c.prev j = i) (hk : c.next j = k) :\n    K.sc j \u2245 K.sc' i j k := (natIsoSc' C c i j k hi hk).app K", "start": [63, 1], "end": [65, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/WellApproximable.lean", "imports": ["Mathlib/MeasureTheory/Covering/LiminfLimsup.lean", "Mathlib/Dynamics/Ergodic/AddCircle.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "approxOrderOf", "code": "@[to_additive \"In a seminormed additive group `A`, given `n : \u2115` and `\u03b4 : \u211d`,\n`approxAddOrderOf A n \u03b4` is the set of elements within a distance `\u03b4` of a point of order `n`.\"]\ndef approxOrderOf (A : Type*) [SeminormedGroup A] (n : \u2115) (\u03b4 : \u211d) : Set A :=\n  thickening \u03b4 {y | orderOf y = n}", "start": [67, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "mem_approxOrderOf_iff", "code": "@[to_additive mem_approx_add_orderOf_iff]\ntheorem mem_approxOrderOf_iff {A : Type*} [SeminormedGroup A] {n : \u2115} {\u03b4 : \u211d} {a : A} :\n    a \u2208 approxOrderOf A n \u03b4 \u2194 \u2203 b : A, orderOf b = n \u2227 a \u2208 ball b \u03b4", "start": [76, 1], "end": [79, 96], "kind": "commanddeclaration"}, {"full_name": "wellApproximable", "code": "@[to_additive addWellApproximable \"In a seminormed additive group `A`, given a sequence of\ndistances `\u03b4\u2081, \u03b4\u2082, ...`, `addWellApproximable A \u03b4` is the limsup as `n \u2192 \u221e` of the sets\n`approxAddOrderOf A n \u03b4\u2099`. Thus, it is the set of points that lie in infinitely many of the sets\n`approxAddOrderOf A n \u03b4\u2099`.\"]\ndef wellApproximable (A : Type*) [SeminormedGroup A] (\u03b4 : \u2115 \u2192 \u211d) : Set A :=\n  blimsup (fun n => approxOrderOf A n (\u03b4 n)) atTop fun n => 0 < n", "start": [83, 1], "end": [91, 66], "kind": "commanddeclaration"}, {"full_name": "mem_wellApproximable_iff", "code": "@[to_additive mem_add_wellApproximable_iff]\ntheorem mem_wellApproximable_iff {A : Type*} [SeminormedGroup A] {\u03b4 : \u2115 \u2192 \u211d} {a : A} :\n    a \u2208 wellApproximable A \u03b4 \u2194\n      a \u2208 blimsup (fun n => approxOrderOf A n (\u03b4 n)) atTop fun n => 0 < n", "start": [95, 1], "end": [99, 10], "kind": "commanddeclaration"}, {"full_name": "approxOrderOf.image_pow_subset_of_coprime", "code": "@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A n \u03b4 \u2286 approxOrderOf A n (m * \u03b4)", "start": [107, 1], "end": [116, 51], "kind": "commanddeclaration"}, {"full_name": "approxOrderOf.image_pow_subset", "code": "@[to_additive]\ntheorem image_pow_subset (n : \u2115) (hm : 0 < m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A (n * m) \u03b4 \u2286 approxOrderOf A n (m * \u03b4)", "start": [120, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "approxOrderOf.smul_subset_of_coprime", "code": "@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :\n    a \u2022 approxOrderOf A n \u03b4 \u2286 approxOrderOf A (orderOf a * n) \u03b4", "start": [133, 1], "end": [142, 68], "kind": "commanddeclaration"}, {"full_name": "approxOrderOf.smul_eq_of_mul_dvd", "code": "@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 \u2223 n) :\n    a \u2022 approxOrderOf A n \u03b4 = approxOrderOf A n \u03b4", "start": [146, 1], "end": [166, 43], "kind": "commanddeclaration"}, {"full_name": "UnitAddCircle.mem_approxAddOrderOf_iff", "code": "theorem mem_approxAddOrderOf_iff {\u03b4 : \u211d} {x : UnitAddCircle} {n : \u2115} (hn : 0 < n) :\n    x \u2208 approxAddOrderOf UnitAddCircle n \u03b4 \u2194 \u2203 m < n, gcd m n = 1 \u2227 \u2016x - \u2191((m : \u211d) / n)\u2016 < \u03b4", "start": [174, 1], "end": [181, 77], "kind": "commanddeclaration"}, {"full_name": "UnitAddCircle.mem_addWellApproximable_iff", "code": "theorem mem_addWellApproximable_iff (\u03b4 : \u2115 \u2192 \u211d) (x : UnitAddCircle) :\n    x \u2208 addWellApproximable UnitAddCircle \u03b4 \u2194\n      {n : \u2115 | \u2203 m < n, gcd m n = 1 \u2227 \u2016x - \u2191((m : \u211d) / n)\u2016 < \u03b4 n}.Infinite", "start": [184, 1], "end": [192, 51], "kind": "commanddeclaration"}, {"full_name": "AddCircle.addWellApproximable_ae_empty_or_univ", "code": "theorem addWellApproximable_ae_empty_or_univ (\u03b4 : \u2115 \u2192 \u211d) (h\u03b4 : Tendsto \u03b4 atTop (\ud835\udcdd 0)) :\n    (\u2200\u1d50 x, \u00acaddWellApproximable \ud835\udd4a \u03b4 x) \u2228 \u2200\u1d50 x, addWellApproximable \ud835\udd4a \u03b4 x", "start": [207, 1], "end": [336, 65], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.exists_norm_nsmul_le", "code": "lemma _root_.NormedAddCommGroup.exists_norm_nsmul_le {A : Type*}\n    [NormedAddCommGroup A] [CompactSpace A] [ConnectedSpace A]\n    [MeasurableSpace A] [BorelSpace A] {\u03bc : Measure A} [\u03bc.IsAddHaarMeasure]\n    (\u03be : A) {n : \u2115} (hn : 0 < n) (\u03b4 : \u211d) (h\u03b4 : \u03bc univ \u2264 (n + 1) \u2022 \u03bc (closedBall (0 : A) (\u03b4/2))) :\n    \u2203 j \u2208 Icc 1 n, \u2016j \u2022 \u03be\u2016 \u2264 \u03b4 := by\n  have : IsFiniteMeasure \u03bc := CompactSpace.isFiniteMeasure\n  let B : Icc 0 n \u2192 Set A := fun j \u21a6 closedBall ((j : \u2115) \u2022 \u03be) (\u03b4/2)\n  have hB : \u2200 j, IsClosed (B j) := fun j \u21a6 isClosed_ball\n  suffices : \u00ac Pairwise (Disjoint on B)\n  \u00b7 obtain \u27e8i, j, hij, x, hx\u27e9 := exists_lt_mem_inter_of_not_pairwise_disjoint this\n    refine' \u27e8j - i, \u27e8le_tsub_of_add_le_left hij, _\u27e9, _\u27e9\n    \u00b7 simpa only [tsub_le_iff_right] using j.property.2.trans le_self_add\n    \u00b7 rw [sub_nsmul _ (Subtype.coe_le_coe.mpr hij.le), \u2190 sub_eq_add_neg, \u2190 dist_eq_norm]\n      refine' (dist_triangle (\u2191j \u2022 \u03be) x (\u2191i \u2022 \u03be)).trans _\n      linarith [mem_closedBall.mp hx.1, mem_closedBall'.mp hx.2]\n  by_contra h\n  apply hn.ne'\n  have h' : \u22c3 j, B j = univ := by\n    rw [\u2190 (isClosed_iUnion_of_finite hB).measure_eq_univ_iff_eq (\u03bc := \u03bc)]\n    refine' le_antisymm (\u03bc.mono (subset_univ _)) _\n    simp_rw [measure_iUnion h (fun _ \u21a6 measurableSet_closedBall), tsum_fintype,\n      \u03bc.addHaar_closedBall_center, Finset.sum_const, Finset.card_univ, Nat.card_fintypeIcc,\n      tsub_zero]\n    exact h\u03b4\n  replace h\u03b4 : 0 \u2264 \u03b4/2 := by\n    by_contra contra\n    suffices : \u03bc (closedBall 0 (\u03b4/2)) = 0\n    \u00b7 apply isOpen_univ.measure_ne_zero \u03bc univ_nonempty $ le_zero_iff.mp $ le_trans h\u03b4 _\n      simp [this]\n    rw [not_le, \u2190 closedBall_eq_empty (x := (0 : A))] at contra\n    simp [contra]\n  have h'' : \u2200 j, (B j).Nonempty := by intro j; rwa [nonempty_closedBall]\n  simpa using subsingleton_of_disjoint_isClosed_iUnion_eq_univ h'' h hB h'", "start": [339, 1], "end": [374, 75], "kind": "mathlibtacticlemma"}, {"full_name": "AddCircle.exists_norm_nsmul_le", "code": "lemma exists_norm_nsmul_le (\u03be : \ud835\udd4a) {n : \u2115} (hn : 0 < n) :\n    \u2203 j \u2208 Icc 1 n, \u2016j \u2022 \u03be\u2016 \u2264 T / \u2191(n + 1) := by\n  apply NormedAddCommGroup.exists_norm_nsmul_le (\u03bc := volume) \u03be hn\n  rw [AddCircle.measure_univ, volume_closedBall, \u2190 ENNReal.ofReal_nsmul,\n    mul_div_cancel' _ two_ne_zero, min_eq_right (div_le_self hT.out.le $ by simp), nsmul_eq_mul,\n    mul_div_cancel' _ (Nat.cast_ne_zero.mpr n.succ_ne_zero)]", "start": [376, 1], "end": [384, 61], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Order/Category/AlexDisc.lean", "imports": ["Mathlib/Topology/Specialization.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlexandrovDiscreteSpace", "code": "class AlexandrovDiscreteSpace (\u03b1 : Type*) extends TopologicalSpace \u03b1, AlexandrovDiscrete \u03b1", "start": [17, 1], "end": [19, 91], "kind": "commanddeclaration"}, {"full_name": "AlexDisc", "code": "def AlexDisc := Bundled AlexandrovDiscreteSpace", "start": [21, 1], "end": [22, 48], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.instCoeSort", "code": "instance instCoeSort : CoeSort AlexDisc Type* := Bundled.coeSort", "start": [26, 1], "end": [26, 65], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.instTopologicalSpace", "code": "instance instTopologicalSpace (\u03b1 : AlexDisc) : TopologicalSpace \u03b1 := \u03b1.2.1", "start": [27, 1], "end": [27, 75], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.instAlexandrovDiscrete", "code": "instance instAlexandrovDiscrete (\u03b1 : AlexDisc) : AlexandrovDiscrete \u03b1 := \u03b1.2.2", "start": [28, 1], "end": [28, 79], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.instConcreteCategory", "code": "instance instConcreteCategory : ConcreteCategory AlexDisc := BundledHom.concreteCategory _", "start": [34, 1], "end": [34, 91], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.instHasForgetToTop", "code": "instance instHasForgetToTop : HasForget\u2082 AlexDisc TopCat := BundledHom.forget\u2082 _ _", "start": [35, 1], "end": [35, 83], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.ForgetToTop.instFull", "code": "instance ForgetToTop.instFull : Full (forget\u2082 AlexDisc TopCat) := BundledHom.forget\u2082Full _ _", "start": [36, 1], "end": [36, 93], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.ForgetToTop.instFaithful", "code": "instance ForgetToTop.instFaithful : Faithful (forget\u2082 AlexDisc TopCat) where", "start": [37, 1], "end": [37, 77], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.coe_forgetToTop", "code": "@[simp] lemma coe_forgetToTop (X : AlexDisc) : \u21a5((forget\u2082 _ TopCat).obj X) = X := rfl", "start": [39, 1], "end": [39, 86], "kind": "mathlibtacticlemma"}, {"full_name": "AlexDisc.of", "code": "def of (\u03b1 : Type*) [TopologicalSpace \u03b1] [AlexandrovDiscrete \u03b1] : AlexDisc := \u27e8\u03b1, \u27e8\u27e9\u27e9", "start": [41, 1], "end": [42, 85], "kind": "commanddeclaration"}, {"full_name": "AlexDisc.coe_of", "code": "@[simp] lemma coe_of (\u03b1 : Type*) [TopologicalSpace \u03b1] [AlexandrovDiscrete \u03b1] : \u21a5(of \u03b1) = \u03b1 := rfl", "start": [44, 1], "end": [44, 98], "kind": "mathlibtacticlemma"}, {"full_name": "AlexDisc.forgetToTop_of", "code": "@[simp] lemma forgetToTop_of (\u03b1 : Type*) [TopologicalSpace \u03b1] [AlexandrovDiscrete \u03b1] :\n  (forget\u2082 AlexDisc TopCat).obj (of \u03b1) = TopCat.of \u03b1 := rfl", "start": [45, 1], "end": [46, 60], "kind": "mathlibtacticlemma"}, {"full_name": "AlexDisc.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : AlexDisc} (e : \u03b1 \u2243\u209c \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : ContinuousMap \u03b1 \u03b2)\n  inv := (e.symm : ContinuousMap \u03b2 \u03b1)\n  hom_inv_id := FunLike.ext _ _ e.symm_apply_apply\n  inv_hom_id := FunLike.ext _ _ e.apply_symm_apply", "start": [48, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "alexDiscEquivPreord", "code": "@[simps]\ndef alexDiscEquivPreord : AlexDisc \u224c Preord where\n  functor := forget\u2082 _ _ \u22d9 topToPreord\n  inverse := { obj := \u03bb X \u21a6 AlexDisc.of (WithUpperSet X), map := WithUpperSet.map }\n  unitIso := NatIso.ofComponents \u03bb X \u21a6 AlexDisc.Iso.mk $ by\n    dsimp; exact homeoWithUpperSetTopologyorderIso X\n  counitIso := NatIso.ofComponents \u03bb X \u21a6 Preord.Iso.mk $ by\n    dsimp; exact (orderIsoSpecializationWithUpperSetTopology X).symm", "start": [58, 1], "end": [66, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Embedding.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/GroupTheory/GroupAction/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Embedding.smul", "code": "@[to_additive]\ninstance smul [Group G] [MulAction G \u03b2] : SMul G (\u03b1 \u21aa \u03b2) :=\n  \u27e8fun g f => f.trans (MulAction.toPerm g).toEmbedding\u27e9", "start": [27, 1], "end": [29, 56], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.smul_def", "code": "@[to_additive]\ntheorem smul_def [Group G] [MulAction G \u03b2] (g : G) (f : \u03b1 \u21aa \u03b2) :\n    g \u2022 f = f.trans (MulAction.toPerm g).toEmbedding", "start": [31, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.smul_apply", "code": "@[to_additive (attr := simp)]\ntheorem smul_apply [Group G] [MulAction G \u03b2] (g : G) (f : \u03b1 \u21aa \u03b2) (a : \u03b1) : (g \u2022 f) a = g \u2022 f a", "start": [38, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_smul", "code": "@[to_additive]\ntheorem coe_smul [Group G] [MulAction G \u03b2] (g : G) (f : \u03b1 \u21aa \u03b2) : \u21d1(g \u2022 f) = g \u2022 \u21d1f", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Sections.lean", "imports": ["Mathlib/Data/Multiset/Bind.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.Sections", "code": "def Sections (s : Multiset (Multiset \u03b1)) : Multiset (Multiset \u03b1) :=\n  Multiset.recOn s {0} (fun s _ c => s.bind fun a => c.map (Multiset.cons a)) fun a\u2080 a\u2081 _ pi => by\n    simp [map_bind, bind_bind a\u2080 a\u2081, cons_swap]", "start": [21, 1], "end": [27, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.sections_zero", "code": "@[simp]\ntheorem sections_zero : Sections (0 : Multiset (Multiset \u03b1)) = {0}", "start": [30, 1], "end": [32, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.sections_cons", "code": "@[simp]\ntheorem sections_cons (s : Multiset (Multiset \u03b1)) (m : Multiset \u03b1) :\n    Sections (m ::\u2098 s) = m.bind fun a => (Sections s).map (Multiset.cons a)", "start": [35, 1], "end": [38, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_sections", "code": "theorem coe_sections :\n    \u2200 l : List (List \u03b1),\n      Sections (l.map fun l : List \u03b1 => (l : Multiset \u03b1) : Multiset (Multiset \u03b1)) =\n        (l.sections.map fun l : List \u03b1 => (l : Multiset \u03b1) : Multiset (Multiset \u03b1))", "start": [41, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.sections_add", "code": "@[simp]\ntheorem sections_add (s t : Multiset (Multiset \u03b1)) :\n    Sections (s + t) = (Sections s).bind fun m => (Sections t).map ((\u00b7 + \u00b7) m)", "start": [52, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sections", "code": "theorem mem_sections {s : Multiset (Multiset \u03b1)} :\n    \u2200 {a}, a \u2208 Sections s \u2194 s.Rel (fun s a => a \u2208 s) a", "start": [59, 1], "end": [63, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_sections", "code": "theorem card_sections {s : Multiset (Multiset \u03b1)} : card (Sections s) = prod (s.map card)", "start": [66, 1], "end": [67, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_sum", "code": "theorem prod_map_sum [CommSemiring \u03b1] {s : Multiset (Multiset \u03b1)} :\n    prod (s.map sum) = sum ((Sections s).map prod)", "start": [70, 1], "end": [73, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Basis.lean", "Mathlib/LinearAlgebra/Charpoly/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.charpoly_toMatrix", "code": "@[simp]\ntheorem charpoly_toMatrix {\u03b9 : Type w} [DecidableEq \u03b9] [Fintype \u03b9] (b : Basis \u03b9 R M) :\n    (toMatrix b b f).charpoly = f.charpoly", "start": [40, 1], "end": [80, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/InformationTheory/Hamming.lean", "imports": ["Mathlib/Analysis/Normed/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hammingDist", "code": "def hammingDist (x y : \u2200 i, \u03b2 i) : \u2115 :=\n  (univ.filter fun i => x i \u2260 y i).card", "start": [39, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "hammingDist_self", "code": "@[simp]\ntheorem hammingDist_self (x : \u2200 i, \u03b2 i) : hammingDist x x = 0", "start": [44, 1], "end": [48, 27], "kind": "commanddeclaration"}, {"full_name": "hammingDist_nonneg", "code": "theorem hammingDist_nonneg {x y : \u2200 i, \u03b2 i} : 0 \u2264 hammingDist x y", "start": [51, 1], "end": [53, 12], "kind": "commanddeclaration"}, {"full_name": "hammingDist_comm", "code": "theorem hammingDist_comm (x y : \u2200 i, \u03b2 i) : hammingDist x y = hammingDist y x", "start": [56, 1], "end": [58, 33], "kind": "commanddeclaration"}, {"full_name": "hammingDist_triangle", "code": "theorem hammingDist_triangle (x y z : \u2200 i, \u03b2 i) :\n    hammingDist x z \u2264 hammingDist x y + hammingDist y z", "start": [61, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "hammingDist_triangle_left", "code": "theorem hammingDist_triangle_left (x y z : \u2200 i, \u03b2 i) :\n    hammingDist x y \u2264 hammingDist z x + hammingDist z y", "start": [71, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "hammingDist_triangle_right", "code": "theorem hammingDist_triangle_right (x y z : \u2200 i, \u03b2 i) :\n    hammingDist x y \u2264 hammingDist x z + hammingDist y z", "start": [78, 1], "end": [82, 35], "kind": "commanddeclaration"}, {"full_name": "swap_hammingDist", "code": "theorem swap_hammingDist : swap (@hammingDist _ \u03b2 _ _) = hammingDist", "start": [85, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "eq_of_hammingDist_eq_zero", "code": "theorem eq_of_hammingDist_eq_zero {x y : \u2200 i, \u03b2 i} : hammingDist x y = 0 \u2192 x = y", "start": [91, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "hammingDist_eq_zero", "code": "@[simp]\ntheorem hammingDist_eq_zero {x y : \u2200 i, \u03b2 i} : hammingDist x y = 0 \u2194 x = y", "start": [97, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "hamming_zero_eq_dist", "code": "@[simp]\ntheorem hamming_zero_eq_dist {x y : \u2200 i, \u03b2 i} : 0 = hammingDist x y \u2194 x = y", "start": [105, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "hammingDist_ne_zero", "code": "theorem hammingDist_ne_zero {x y : \u2200 i, \u03b2 i} : hammingDist x y \u2260 0 \u2194 x \u2260 y", "start": [111, 1], "end": [113, 26], "kind": "commanddeclaration"}, {"full_name": "hammingDist_pos", "code": "@[simp]\ntheorem hammingDist_pos {x y : \u2200 i, \u03b2 i} : 0 < hammingDist x y \u2194 x \u2260 y", "start": [116, 1], "end": [119, 64], "kind": "commanddeclaration"}, {"full_name": "hammingDist_lt_one", "code": "theorem hammingDist_lt_one {x y : \u2200 i, \u03b2 i} : hammingDist x y < 1 \u2194 x = y", "start": [123, 1], "end": [124, 43], "kind": "commanddeclaration"}, {"full_name": "hammingDist_le_card_fintype", "code": "theorem hammingDist_le_card_fintype {x y : \u2200 i, \u03b2 i} : hammingDist x y \u2264 Fintype.card \u03b9", "start": [127, 1], "end": [128, 17], "kind": "commanddeclaration"}, {"full_name": "hammingDist_comp_le_hammingDist", "code": "theorem hammingDist_comp_le_hammingDist (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x y : \u2200 i, \u03b3 i} :\n    (hammingDist (fun i => f i (x i)) fun i => f i (y i)) \u2264 hammingDist x y", "start": [131, 1], "end": [133, 78], "kind": "commanddeclaration"}, {"full_name": "hammingDist_comp", "code": "theorem hammingDist_comp (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x y : \u2200 i, \u03b3 i} (hf : \u2200 i, Injective (f i)) :\n    (hammingDist (fun i => f i (x i)) fun i => f i (y i)) = hammingDist x y", "start": [136, 1], "end": [139, 69], "kind": "commanddeclaration"}, {"full_name": "hammingDist_smul_le_hammingDist", "code": "theorem hammingDist_smul_le_hammingDist [\u2200 i, SMul \u03b1 (\u03b2 i)] {k : \u03b1} {x y : \u2200 i, \u03b2 i} :\n    hammingDist (k \u2022 x) (k \u2022 y) \u2264 hammingDist x y", "start": [142, 1], "end": [144, 63], "kind": "commanddeclaration"}, {"full_name": "hammingDist_smul", "code": "theorem hammingDist_smul [\u2200 i, SMul \u03b1 (\u03b2 i)] {k : \u03b1} {x y : \u2200 i, \u03b2 i}\n    (hk : \u2200 i, IsSMulRegular (\u03b2 i) k) : hammingDist (k \u2022 x) (k \u2022 y) = hammingDist x y", "start": [147, 1], "end": [150, 53], "kind": "commanddeclaration"}, {"full_name": "hammingNorm", "code": "def hammingNorm (x : \u2200 i, \u03b2 i) : \u2115 :=\n  (univ.filter (x \u00b7 \u2260 0)).card", "start": [157, 1], "end": [159, 31], "kind": "commanddeclaration"}, {"full_name": "hammingDist_zero_right", "code": "@[simp]\ntheorem hammingDist_zero_right (x : \u2200 i, \u03b2 i) : hammingDist x 0 = hammingNorm x", "start": [162, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "hammingDist_zero_left", "code": "@[simp]\ntheorem hammingDist_zero_left : hammingDist (0 : \u2200 i, \u03b2 i) = hammingNorm", "start": [168, 1], "end": [171, 67], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_nonneg", "code": "theorem hammingNorm_nonneg {x : \u2200 i, \u03b2 i} : 0 \u2264 hammingNorm x", "start": [174, 1], "end": [177, 12], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_zero", "code": "@[simp]\ntheorem hammingNorm_zero : hammingNorm (0 : \u2200 i, \u03b2 i) = 0", "start": [180, 1], "end": [183, 21], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_eq_zero", "code": "@[simp]\ntheorem hammingNorm_eq_zero {x : \u2200 i, \u03b2 i} : hammingNorm x = 0 \u2194 x = 0", "start": [186, 1], "end": [189, 22], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_ne_zero_iff", "code": "theorem hammingNorm_ne_zero_iff {x : \u2200 i, \u03b2 i} : hammingNorm x \u2260 0 \u2194 x \u2260 0", "start": [192, 1], "end": [194, 26], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_pos_iff", "code": "@[simp]\ntheorem hammingNorm_pos_iff {x : \u2200 i, \u03b2 i} : 0 < hammingNorm x \u2194 x \u2260 0", "start": [197, 1], "end": [200, 18], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_lt_one", "code": "theorem hammingNorm_lt_one {x : \u2200 i, \u03b2 i} : hammingNorm x < 1 \u2194 x = 0", "start": [204, 1], "end": [205, 21], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_le_card_fintype", "code": "theorem hammingNorm_le_card_fintype {x : \u2200 i, \u03b2 i} : hammingNorm x \u2264 Fintype.card \u03b9", "start": [208, 1], "end": [209, 30], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_comp_le_hammingNorm", "code": "theorem hammingNorm_comp_le_hammingNorm (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x : \u2200 i, \u03b3 i} (hf : \u2200 i, f i 0 = 0) :\n    (hammingNorm fun i => f i (x i)) \u2264 hammingNorm x", "start": [212, 1], "end": [214, 101], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_comp", "code": "theorem hammingNorm_comp (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x : \u2200 i, \u03b3 i} (hf\u2081 : \u2200 i, Injective (f i))\n    (hf\u2082 : \u2200 i, f i 0 = 0) : (hammingNorm fun i => f i (x i)) = hammingNorm x", "start": [217, 1], "end": [219, 91], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_smul_le_hammingNorm", "code": "theorem hammingNorm_smul_le_hammingNorm [Zero \u03b1] [\u2200 i, SMulWithZero \u03b1 (\u03b2 i)] {k : \u03b1}\n    {x : \u2200 i, \u03b2 i} : hammingNorm (k \u2022 x) \u2264 hammingNorm x", "start": [222, 1], "end": [224, 93], "kind": "commanddeclaration"}, {"full_name": "hammingNorm_smul", "code": "theorem hammingNorm_smul [Zero \u03b1] [\u2200 i, SMulWithZero \u03b1 (\u03b2 i)] {k : \u03b1}\n    (hk : \u2200 i, IsSMulRegular (\u03b2 i) k) (x : \u2200 i, \u03b2 i) : hammingNorm (k \u2022 x) = hammingNorm x", "start": [227, 1], "end": [229, 81], "kind": "commanddeclaration"}, {"full_name": "hammingDist_eq_hammingNorm", "code": "theorem hammingDist_eq_hammingNorm [\u2200 i, AddGroup (\u03b2 i)] (x y : \u2200 i, \u03b2 i) :\n    hammingDist x y = hammingNorm (x - y)", "start": [234, 1], "end": [237, 64], "kind": "commanddeclaration"}, {"full_name": "Hamming", "code": "def Hamming {\u03b9 : Type*} (\u03b2 : \u03b9 \u2192 Type*) : Type _ :=\n  \u2200 i, \u03b2 i", "start": [245, 1], "end": [248, 11], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming", "code": "@[match_pattern]\ndef toHamming : (\u2200 i, \u03b2 i) \u2243 Hamming \u03b2 :=\n  Equiv.refl _", "start": [303, 1], "end": [306, 15], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming", "code": "@[match_pattern]\ndef ofHamming : Hamming \u03b2 \u2243 \u2200 i, \u03b2 i :=\n  Equiv.refl _", "start": [309, 1], "end": [312, 15], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_symm_eq", "code": "@[simp]\ntheorem toHamming_symm_eq : (@toHamming _ \u03b2).symm = ofHamming", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_symm_eq", "code": "@[simp]\ntheorem ofHamming_symm_eq : (@ofHamming _ \u03b2).symm = toHamming", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_ofHamming", "code": "@[simp]\ntheorem toHamming_ofHamming (x : Hamming \u03b2) : toHamming (ofHamming x) = x", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_toHamming", "code": "@[simp]\ntheorem ofHamming_toHamming (x : \u2200 i, \u03b2 i) : ofHamming (toHamming x) = x", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_inj", "code": "theorem toHamming_inj {x y : \u2200 i, \u03b2 i} : toHamming x = toHamming y \u2194 x = y", "start": [336, 1], "end": [337, 10], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_inj", "code": "theorem ofHamming_inj {x y : Hamming \u03b2} : ofHamming x = ofHamming y \u2194 x = y", "start": [341, 1], "end": [342, 10], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_zero", "code": "@[simp]\ntheorem toHamming_zero [\u2200 i, Zero (\u03b2 i)] : toHamming (0 : \u2200 i, \u03b2 i) = 0", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_zero", "code": "@[simp]\ntheorem ofHamming_zero [\u2200 i, Zero (\u03b2 i)] : ofHamming (0 : Hamming \u03b2) = 0", "start": [350, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_neg", "code": "@[simp]\ntheorem toHamming_neg [\u2200 i, Neg (\u03b2 i)] {x : \u2200 i, \u03b2 i} : toHamming (-x) = -toHamming x", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_neg", "code": "@[simp]\ntheorem ofHamming_neg [\u2200 i, Neg (\u03b2 i)] {x : Hamming \u03b2} : ofHamming (-x) = -ofHamming x", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_add", "code": "@[simp]\ntheorem toHamming_add [\u2200 i, Add (\u03b2 i)] {x y : \u2200 i, \u03b2 i} :\n    toHamming (x + y) = toHamming x + toHamming y", "start": [365, 1], "end": [368, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_add", "code": "@[simp]\ntheorem ofHamming_add [\u2200 i, Add (\u03b2 i)] {x y : Hamming \u03b2} :\n    ofHamming (x + y) = ofHamming x + ofHamming y", "start": [371, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_sub", "code": "@[simp]\ntheorem toHamming_sub [\u2200 i, Sub (\u03b2 i)] {x y : \u2200 i, \u03b2 i} :\n    toHamming (x - y) = toHamming x - toHamming y", "start": [377, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_sub", "code": "@[simp]\ntheorem ofHamming_sub [\u2200 i, Sub (\u03b2 i)] {x y : Hamming \u03b2} :\n    ofHamming (x - y) = ofHamming x - ofHamming y", "start": [383, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.toHamming_smul", "code": "@[simp]\ntheorem toHamming_smul [\u2200 i, SMul \u03b1 (\u03b2 i)] {r : \u03b1} {x : \u2200 i, \u03b2 i} :\n    toHamming (r \u2022 x) = r \u2022 toHamming x", "start": [389, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.ofHamming_smul", "code": "@[simp]\ntheorem ofHamming_smul [\u2200 i, SMul \u03b1 (\u03b2 i)] {r : \u03b1} {x : Hamming \u03b2} :\n    ofHamming (r \u2022 x) = r \u2022 ofHamming x", "start": [395, 1], "end": [398, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.dist_eq_hammingDist", "code": "@[simp, push_cast]\ntheorem dist_eq_hammingDist (x y : Hamming \u03b2) :\n    dist x y = hammingDist (ofHamming x) (ofHamming y)", "start": [410, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.nndist_eq_hammingDist", "code": "@[simp, push_cast]\ntheorem nndist_eq_hammingDist (x y : Hamming \u03b2) :\n    nndist x y = hammingDist (ofHamming x) (ofHamming y)", "start": [447, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.norm_eq_hammingNorm", "code": "@[simp, push_cast]\ntheorem norm_eq_hammingNorm [\u2200 i, Zero (\u03b2 i)] (x : Hamming \u03b2) : \u2016x\u2016 = hammingNorm (ofHamming x)", "start": [461, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "Hamming.nnnorm_eq_hammingNorm", "code": "@[simp, push_cast]\ntheorem nnnorm_eq_hammingNorm [\u2200 i, AddCommGroup (\u03b2 i)] (x : Hamming \u03b2) :\n    \u2016x\u2016\u208a = hammingNorm (ofHamming x)", "start": [471, 1], "end": [474, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Subobject/Types.lean", "imports": ["Mathlib/CategoryTheory/Subobject/WellPowered.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "subtype_val_mono", "code": "theorem subtype_val_mono {\u03b1 : Type u} (s : Set \u03b1) : Mono (\u21be(Subtype.val : s \u2192 \u03b1))", "start": [32, 1], "end": [33, 51], "kind": "commanddeclaration"}, {"full_name": "Types.monoOverEquivalenceSet", "code": "@[simps]\nnoncomputable def Types.monoOverEquivalenceSet (\u03b1 : Type u) : MonoOver \u03b1 \u224c Set \u03b1 where\n  functor :=\n    { obj := fun f => Set.range f.1.hom\n      map := fun {f g} t =>\n        homOfLE\n          (by\n            rintro a \u27e8x, rfl\u27e9\n            exact \u27e8t.1 x, congr_fun t.w x\u27e9) }\n  inverse :=\n    { obj := fun s => MonoOver.mk' (Subtype.val : s \u2192 \u03b1)\n      map := fun {s t} b => MonoOver.homMk (fun w => \u27e8w.1, Set.mem_of_mem_of_subset w.2 b.le\u27e9) }\n  unitIso :=\n    NatIso.ofComponents fun f =>\n      MonoOver.isoMk (Equiv.ofInjective f.1.hom ((mono_iff_injective _).mp f.2)).toIso\n  counitIso := NatIso.ofComponents fun s => eqToIso Subtype.range_val", "start": [38, 1], "end": [55, 70], "kind": "commanddeclaration"}, {"full_name": "Types.subobjectEquivSet", "code": "noncomputable def Types.subobjectEquivSet (\u03b1 : Type u) : Subobject \u03b1 \u2243o Set \u03b1 :=\n  (Types.monoOverEquivalenceSet \u03b1).thinSkeletonOrderIso", "start": [62, 1], "end": [65, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Game/Nim.lean", "imports": ["Mathlib/Data/Nat/Bitwise.lean", "Mathlib/SetTheory/Game/Birthday.lean", "Mathlib/SetTheory/Game/Impartial.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.nim", "code": "noncomputable def nim : Ordinal.{u} \u2192 PGame.{u}\n  | o\u2081 =>\n    let f o\u2082 :=\n      have _ : Ordinal.typein o\u2081.out.r o\u2082 < o\u2081 := Ordinal.typein_lt_self o\u2082\n      nim (Ordinal.typein o\u2081.out.r o\u2082)\n    \u27e8o\u2081.out.\u03b1, o\u2081.out.\u03b1, f, f\u27e9\ntermination_by nim o => o", "start": [46, 1], "end": [54, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_def", "code": "theorem nim_def (o : Ordinal) :\n    have : IsWellOrder (Quotient.out o).\u03b1 (\u00b7 < \u00b7) := inferInstance\n    nim o =\n      PGame.mk o.out.\u03b1 o.out.\u03b1 (fun o\u2082 => nim (Ordinal.typein (\u00b7 < \u00b7) o\u2082)) fun o\u2082 =>\n        nim (Ordinal.typein (\u00b7 < \u00b7) o\u2082)", "start": [59, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leftMoves_nim", "code": "theorem leftMoves_nim (o : Ordinal) : (nim o).LeftMoves = o.out.\u03b1", "start": [67, 1], "end": [67, 90], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.rightMoves_nim", "code": "theorem rightMoves_nim (o : Ordinal) : (nim o).RightMoves = o.out.\u03b1", "start": [70, 1], "end": [70, 92], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveLeft_nim_hEq", "code": "theorem moveLeft_nim_hEq (o : Ordinal) :\n    have : IsWellOrder (Quotient.out o).\u03b1 (\u00b7 < \u00b7) := inferInstance\n    HEq (nim o).moveLeft fun i : o.out.\u03b1 => nim (typein (\u00b7 < \u00b7) i)", "start": [73, 1], "end": [75, 91], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveRight_nim_hEq", "code": "theorem moveRight_nim_hEq (o : Ordinal) :\n    have : IsWellOrder (Quotient.out o).\u03b1 (\u00b7 < \u00b7) := inferInstance\n    HEq (nim o).moveRight fun i : o.out.\u03b1 => nim (typein (\u00b7 < \u00b7) i)", "start": [78, 1], "end": [80, 92], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toLeftMovesNim", "code": "noncomputable def toLeftMovesNim {o : Ordinal} : Set.Iio o \u2243 (nim o).LeftMoves :=\n  (enumIsoOut o).toEquiv.trans (Equiv.cast (leftMoves_nim o).symm)", "start": [83, 1], "end": [85, 67], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toRightMovesNim", "code": "noncomputable def toRightMovesNim {o : Ordinal} : Set.Iio o \u2243 (nim o).RightMoves :=\n  (enumIsoOut o).toEquiv.trans (Equiv.cast (rightMoves_nim o).symm)", "start": [88, 1], "end": [90, 68], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toLeftMovesNim_symm_lt", "code": "@[simp]\ntheorem toLeftMovesNim_symm_lt {o : Ordinal} (i : (nim o).LeftMoves) :\n    \u2191(toLeftMovesNim.symm i) < o", "start": [93, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toRightMovesNim_symm_lt", "code": "@[simp]\ntheorem toRightMovesNim_symm_lt {o : Ordinal} (i : (nim o).RightMoves) :\n    \u2191(toRightMovesNim.symm i) < o", "start": [99, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveLeft_nim'", "code": "@[simp]\ntheorem moveLeft_nim' {o : Ordinal.{u}} (i) :\n    (nim o).moveLeft i = nim (toLeftMovesNim.symm i).val", "start": [105, 1], "end": [108, 60], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveLeft_nim", "code": "theorem moveLeft_nim {o : Ordinal} (i) : (nim o).moveLeft (toLeftMovesNim i) = nim i", "start": [111, 1], "end": [111, 96], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveRight_nim'", "code": "@[simp]\ntheorem moveRight_nim' {o : Ordinal} (i) : (nim o).moveRight i = nim (toRightMovesNim.symm i).val", "start": [114, 1], "end": [116, 61], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveRight_nim", "code": "theorem moveRight_nim {o : Ordinal} (i) : (nim o).moveRight (toRightMovesNim i) = nim i", "start": [119, 1], "end": [119, 99], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leftMovesNimRecOn", "code": "@[elab_as_elim]\ndef leftMovesNimRecOn {o : Ordinal} {P : (nim o).LeftMoves \u2192 Sort*} (i : (nim o).LeftMoves)\n    (H : \u2200 a (H : a < o), P <| toLeftMovesNim \u27e8a, H\u27e9) : P i := by\n  rw [\u2190 toLeftMovesNim.apply_symm_apply i]; apply H", "start": [122, 1], "end": [126, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.rightMovesNimRecOn", "code": "@[elab_as_elim]\ndef rightMovesNimRecOn {o : Ordinal} {P : (nim o).RightMoves \u2192 Sort*} (i : (nim o).RightMoves)\n    (H : \u2200 a (H : a < o), P <| toRightMovesNim \u27e8a, H\u27e9) : P i := by\n  rw [\u2190 toRightMovesNim.apply_symm_apply i]; apply H", "start": [129, 1], "end": [133, 53], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.isEmpty_nim_zero_leftMoves", "code": "instance isEmpty_nim_zero_leftMoves : IsEmpty (nim 0).LeftMoves := by\n  rw [nim_def]\n  exact Ordinal.isEmpty_out_zero", "start": [136, 1], "end": [138, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.isEmpty_nim_zero_rightMoves", "code": "instance isEmpty_nim_zero_rightMoves : IsEmpty (nim 0).RightMoves := by\n  rw [nim_def]\n  exact Ordinal.isEmpty_out_zero", "start": [141, 1], "end": [143, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nimZeroRelabelling", "code": "def nimZeroRelabelling : nim 0 \u2261r 0 :=\n  Relabelling.isEmpty _", "start": [146, 1], "end": [148, 24], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_zero_equiv", "code": "theorem nim_zero_equiv : nim 0 \u2248 0", "start": [151, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.uniqueNimOneLeftMoves", "code": "noncomputable instance uniqueNimOneLeftMoves : Unique (nim 1).LeftMoves :=\n  (Equiv.cast <| leftMoves_nim 1).unique", "start": [155, 1], "end": [156, 41], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.uniqueNimOneRightMoves", "code": "noncomputable instance uniqueNimOneRightMoves : Unique (nim 1).RightMoves :=\n  (Equiv.cast <| rightMoves_nim 1).unique", "start": [159, 1], "end": [160, 42], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.default_nim_one_leftMoves_eq", "code": "@[simp]\ntheorem default_nim_one_leftMoves_eq :\n    (default : (nim 1).LeftMoves) = @toLeftMovesNim 1 \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9", "start": [163, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.default_nim_one_rightMoves_eq", "code": "@[simp]\ntheorem default_nim_one_rightMoves_eq :\n    (default : (nim 1).RightMoves) = @toRightMovesNim 1 \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toLeftMovesNim_one_symm", "code": "@[simp]\ntheorem toLeftMovesNim_one_symm (i) :\n    (@toLeftMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9", "start": [175, 1], "end": [177, 77], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.toRightMovesNim_one_symm", "code": "@[simp]\ntheorem toRightMovesNim_one_symm (i) :\n    (@toRightMovesNim 1).symm i = \u27e80, Set.mem_Iio.mpr zero_lt_one\u27e9", "start": [180, 1], "end": [182, 78], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_one_moveLeft", "code": "theorem nim_one_moveLeft (x) : (nim 1).moveLeft x = nim 0", "start": [185, 1], "end": [185, 69], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_one_moveRight", "code": "theorem nim_one_moveRight (x) : (nim 1).moveRight x = nim 0", "start": [188, 1], "end": [188, 71], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nimOneRelabelling", "code": "def nimOneRelabelling : nim 1 \u2261r star := by\n  rw [nim_def]\n  refine' \u27e8_, _, fun i => _, fun j => _\u27e9\n  any_goals dsimp; apply Equiv.equivOfUnique\n  all_goals simp; exact nimZeroRelabelling", "start": [191, 1], "end": [196, 43], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_one_equiv", "code": "theorem nim_one_equiv : nim 1 \u2248 star", "start": [199, 1], "end": [200, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_birthday", "code": "@[simp]\ntheorem nim_birthday (o : Ordinal) : (nim o).birthday = o", "start": [203, 1], "end": [210, 32], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.neg_nim", "code": "@[simp]\ntheorem neg_nim (o : Ordinal) : -nim o = nim o", "start": [213, 1], "end": [216, 84], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_impartial", "code": "instance nim_impartial (o : Ordinal) : Impartial (nim o) := by\n  induction' o using Ordinal.induction with o IH\n  rw [impartial_def, neg_nim]\n  refine' \u27e8equiv_rfl, fun i => _, fun i => _\u27e9 <;> simpa using IH _ (typein_lt_self _)", "start": [219, 1], "end": [222, 86], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_fuzzy_zero_of_ne_zero", "code": "theorem nim_fuzzy_zero_of_ne_zero {o : Ordinal} (ho : o \u2260 0) : nim o \u2016 0", "start": [225, 1], "end": [228, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_add_equiv_zero_iff", "code": "@[simp]\ntheorem nim_add_equiv_zero_iff (o\u2081 o\u2082 : Ordinal) : (nim o\u2081 + nim o\u2082 \u2248 0) \u2194 o\u2081 = o\u2082", "start": [231, 1], "end": [244, 38], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_add_fuzzy_zero_iff", "code": "@[simp]\ntheorem nim_add_fuzzy_zero_iff {o\u2081 o\u2082 : Ordinal} : nim o\u2081 + nim o\u2082 \u2016 0 \u2194 o\u2081 \u2260 o\u2082", "start": [247, 1], "end": [249, 74], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_equiv_iff_eq", "code": "@[simp]\ntheorem nim_equiv_iff_eq {o\u2081 o\u2082 : Ordinal} : (nim o\u2081 \u2248 nim o\u2082) \u2194 o\u2081 = o\u2082", "start": [252, 1], "end": [254, 66], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue", "code": "noncomputable def grundyValue : \u2200 _ : PGame.{u}, Ordinal.{u}\n  | G => Ordinal.mex.{u, u} fun i => grundyValue (G.moveLeft i)\ntermination_by grundyValue G => G\ndecreasing_by pgame_wf_tac", "start": [257, 1], "end": [262, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_eq_mex_left", "code": "theorem grundyValue_eq_mex_left (G : PGame) :\n    grundyValue G = Ordinal.mex.{u, u} fun i => grundyValue (G.moveLeft i)", "start": [265, 1], "end": [266, 98], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.equiv_nim_grundyValue", "code": "theorem equiv_nim_grundyValue : \u2200 (G : PGame.{u}) [G.Impartial], G \u2248 nim (grundyValue G)", "start": [269, 1], "end": [307, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_eq_iff_equiv_nim", "code": "theorem grundyValue_eq_iff_equiv_nim {G : PGame} [G.Impartial] {o : Ordinal} :\n    grundyValue G = o \u2194 (G \u2248 nim o)", "start": [310, 1], "end": [313, 100], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_grundyValue", "code": "@[simp]\ntheorem nim_grundyValue (o : Ordinal.{u}) : grundyValue (nim o) = o", "start": [316, 1], "end": [318, 49], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_eq_iff_equiv", "code": "theorem grundyValue_eq_iff_equiv (G H : PGame) [G.Impartial] [H.Impartial] :\n    grundyValue G = grundyValue H \u2194 (G \u2248 H)", "start": [321, 1], "end": [323, 91], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_zero", "code": "@[simp]\ntheorem grundyValue_zero : grundyValue 0 = 0", "start": [326, 1], "end": [328, 61], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_iff_equiv_zero", "code": "theorem grundyValue_iff_equiv_zero (G : PGame) [G.Impartial] : grundyValue G = 0 \u2194 (G \u2248 0)", "start": [331, 1], "end": [332, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_star", "code": "@[simp]\ntheorem grundyValue_star : grundyValue star = 1", "start": [335, 1], "end": [337, 60], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_neg", "code": "@[simp]\ntheorem grundyValue_neg (G : PGame) [G.Impartial] : grundyValue (-G) = grundyValue G", "start": [340, 1], "end": [342, 92], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_eq_mex_right", "code": "theorem grundyValue_eq_mex_right :\n    \u2200 (G : PGame) [G.Impartial],\n      grundyValue G = Ordinal.mex.{u, u} fun i => grundyValue (G.moveRight i)", "start": [345, 1], "end": [353, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_nim_add_nim", "code": "@[simp]\ntheorem grundyValue_nim_add_nim (n m : \u2115) :\n    grundyValue (nim.{u} n + nim.{u} m) = n ^^^ m", "start": [358, 1], "end": [397, 32], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.nim_add_nim_equiv", "code": "theorem nim_add_nim_equiv {n m : \u2115} : nim n + nim m \u2248 nim (n ^^^ m)", "start": [400, 1], "end": [401, 63], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.grundyValue_add", "code": "theorem grundyValue_add (G H : PGame) [G.Impartial] [H.Impartial] {n m : \u2115} (hG : grundyValue G = n)\n    (hH : grundyValue H = m) : grundyValue (G + H) = n ^^^ m", "start": [404, 1], "end": [408, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Sections.lean", "imports": ["Mathlib/Data/List/Forall2.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.mem_sections", "code": "theorem mem_sections {L : List (List \u03b1)} {f} : f \u2208 sections L \u2194 Forall\u2082 (\u00b7 \u2208 \u00b7) f L", "start": [23, 1], "end": [34, 30], "kind": "commanddeclaration"}, {"full_name": "List.mem_sections_length", "code": "theorem mem_sections_length {L : List (List \u03b1)} {f} (h : f \u2208 sections L) : length f = length L", "start": [37, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "List.rel_sections", "code": "theorem rel_sections {r : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    (Forall\u2082 (Forall\u2082 r) \u21d2 Forall\u2082 (Forall\u2082 r)) sections sections", "start": [41, 1], "end": [45, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/ODE/PicardLindelof.lean", "imports": ["Mathlib/Topology/MetricSpace/Contracting.lean", "Mathlib/Analysis/SpecialFunctions/Integrals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPicardLindelof", "code": "structure IsPicardLindelof {E : Type*} [NormedAddCommGroup E] (v : \u211d \u2192 E \u2192 E) (tMin t\u2080 tMax : \u211d)\n    (x\u2080 : E) (L : \u211d\u22650) (R C : \u211d) : Prop where\n  ht\u2080 : t\u2080 \u2208 Icc tMin tMax\n  hR : 0 \u2264 R\n  lipschitz : \u2200 t \u2208 Icc tMin tMax, LipschitzOnWith L (v t) (closedBall x\u2080 R)\n  cont : \u2200 x \u2208 closedBall x\u2080 R, ContinuousOn (fun t : \u211d => v t x) (Icc tMin tMax)\n  norm_le : \u2200 t \u2208 Icc tMin tMax, \u2200 x \u2208 closedBall x\u2080 R, \u2016v t x\u2016 \u2264 C\n  C_mul_le_R : (C : \u211d) * max (tMax - t\u2080) (t\u2080 - tMin) \u2264 R", "start": [47, 1], "end": [58, 57], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof", "code": "structure PicardLindelof (E : Type*) [NormedAddCommGroup E] [NormedSpace \u211d E] where\n  toFun : \u211d \u2192 E \u2192 E\n  (tMin tMax : \u211d)\n  t\u2080 : Icc tMin tMax\n  x\u2080 : E\n  (C R L : \u211d\u22650)\n  isPicardLindelof : IsPicardLindelof toFun tMin t\u2080 tMax x\u2080 L R C", "start": [61, 1], "end": [75, 66], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.tMin_le_tMax", "code": "theorem tMin_le_tMax : v.tMin \u2264 v.tMax", "start": [94, 1], "end": [95, 26], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.nonempty_Icc", "code": "protected theorem nonempty_Icc : (Icc v.tMin v.tMax).Nonempty", "start": [98, 1], "end": [99, 32], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.lipschitzOnWith", "code": "protected theorem lipschitzOnWith {t} (ht : t \u2208 Icc v.tMin v.tMax) :\n    LipschitzOnWith v.L (v t) (closedBall v.x\u2080 v.R)", "start": [102, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.continuousOn", "code": "protected theorem continuousOn :\n    ContinuousOn (uncurry v) (Icc v.tMin v.tMax \u00d7\u02e2 closedBall v.x\u2080 v.R)", "start": [107, 1], "end": [112, 78], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.norm_le", "code": "theorem norm_le {t : \u211d} (ht : t \u2208 Icc v.tMin v.tMax) {x : E} (hx : x \u2208 closedBall v.x\u2080 v.R) :\n    \u2016v t x\u2016 \u2264 v.C", "start": [115, 1], "end": [117, 39], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.tDist", "code": "def tDist : \u211d :=\n  max (v.tMax - v.t\u2080) (v.t\u2080 - v.tMin)", "start": [120, 1], "end": [122, 38], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.tDist_nonneg", "code": "theorem tDist_nonneg : 0 \u2264 v.tDist", "start": [125, 1], "end": [126, 50], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.dist_t\u2080_le", "code": "theorem dist_t\u2080_le (t : Icc v.tMin v.tMax) : dist t v.t\u2080 \u2264 v.tDist", "start": [129, 1], "end": [135, 61], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.proj", "code": "def proj : \u211d \u2192 Icc v.tMin v.tMax :=\n  projIcc v.tMin v.tMax v.tMin_le_tMax", "start": [138, 1], "end": [141, 39], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.proj_coe", "code": "theorem proj_coe (t : Icc v.tMin v.tMax) : v.proj t = t", "start": [144, 1], "end": [145, 18], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.proj_of_mem", "code": "theorem proj_of_mem {t : \u211d} (ht : t \u2208 Icc v.tMin v.tMax) : \u2191(v.proj t) = t", "start": [148, 1], "end": [149, 53], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.continuous_proj", "code": "@[continuity]\ntheorem continuous_proj : Continuous v.proj", "start": [152, 1], "end": [154, 21], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace", "code": "structure FunSpace where\n  toFun : Icc v.tMin v.tMax \u2192 E\n  map_t\u2080' : toFun v.t\u2080 = v.x\u2080\n  lipschitz' : LipschitzWith v.C toFun", "start": [157, 1], "end": [164, 39], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.lipschitz", "code": "protected theorem lipschitz : LipschitzWith v.C f", "start": [177, 1], "end": [178, 15], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.continuous", "code": "protected theorem continuous : Continuous f", "start": [181, 1], "end": [182, 25], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.toContinuousMap", "code": "def toContinuousMap : v.FunSpace \u21aa C(Icc v.tMin v.tMax, E) :=\n  \u27e8fun f => \u27e8f, f.continuous\u27e9, fun f g h => by cases f; cases g; simpa using h\u27e9", "start": [185, 1], "end": [187, 80], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.uniformInducing_toContinuousMap", "code": "theorem uniformInducing_toContinuousMap : UniformInducing (@toContinuousMap _ _ _ v)", "start": [193, 1], "end": [194, 8], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.range_toContinuousMap", "code": "theorem range_toContinuousMap :\n    range toContinuousMap =\n      {f : C(Icc v.tMin v.tMax, E) | f v.t\u2080 = v.x\u2080 \u2227 LipschitzWith v.C f}", "start": [197, 1], "end": [202, 79], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.map_t\u2080", "code": "theorem map_t\u2080 : f v.t\u2080 = v.x\u2080", "start": [205, 1], "end": [206, 12], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.mem_closedBall", "code": "protected theorem mem_closedBall (t : Icc v.tMin v.tMax) : f t \u2208 closedBall v.x\u2080 v.R", "start": [209, 1], "end": [214, 45], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.vComp", "code": "def vComp (t : \u211d) : E :=\n  v (v.proj t) (f (v.proj t))", "start": [217, 1], "end": [221, 30], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.vComp_apply_coe", "code": "theorem vComp_apply_coe (t : Icc v.tMin v.tMax) : f.vComp t = v t (f t)", "start": [224, 1], "end": [225, 30], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.continuous_vComp", "code": "theorem continuous_vComp : Continuous f.vComp", "start": [228, 1], "end": [231, 43], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.norm_vComp_le", "code": "theorem norm_vComp_le (t : \u211d) : \u2016f.vComp t\u2016 \u2264 v.C", "start": [234, 1], "end": [235, 47], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.dist_apply_le_dist", "code": "theorem dist_apply_le_dist (f\u2081 f\u2082 : FunSpace v) (t : Icc v.tMin v.tMax) :\n    dist (f\u2081 t) (f\u2082 t) \u2264 dist f\u2081 f\u2082", "start": [238, 1], "end": [240, 90], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.dist_le_of_forall", "code": "theorem dist_le_of_forall {f\u2081 f\u2082 : FunSpace v} {d : \u211d} (h : \u2200 t, dist (f\u2081 t) (f\u2082 t) \u2264 d) :\n    dist f\u2081 f\u2082 \u2264 d", "start": [243, 1], "end": [246, 35], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.intervalIntegrable_vComp", "code": "theorem intervalIntegrable_vComp (t\u2081 t\u2082 : \u211d) : IntervalIntegrable f.vComp volume t\u2081 t\u2082", "start": [258, 1], "end": [259, 44], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.next", "code": "def next (f : FunSpace v) : FunSpace v where\n  toFun t := v.x\u2080 + \u222b \u03c4 : \u211d in v.t\u2080..t, f.vComp \u03c4\n  map_t\u2080' := by simp only [integral_same, add_zero]\n  lipschitz' := LipschitzWith.of_dist_le_mul fun t\u2081 t\u2082 => by\n    rw [dist_add_left, dist_eq_norm,\n      integral_interval_sub_left (f.intervalIntegrable_vComp _ _) (f.intervalIntegrable_vComp _ _)]\n    exact norm_integral_le_of_norm_le_const fun t _ => f.norm_vComp_le _", "start": [264, 1], "end": [274, 73], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.next_apply", "code": "theorem next_apply (t : Icc v.tMin v.tMax) : f.next t = v.x\u2080 + \u222b \u03c4 : \u211d in v.t\u2080..t, f.vComp \u03c4", "start": [277, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.hasDerivWithinAt_next", "code": "theorem hasDerivWithinAt_next (t : Icc v.tMin v.tMax) :\n    HasDerivWithinAt (f.next \u2218 v.proj) (v t (f t)) (Icc v.tMin v.tMax) t", "start": [281, 1], "end": [293, 25], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.dist_next_apply_le_of_le", "code": "theorem dist_next_apply_le_of_le {f\u2081 f\u2082 : FunSpace v} {n : \u2115} {d : \u211d}\n    (h : \u2200 t, dist (f\u2081 t) (f\u2082 t) \u2264 (v.L * |t.1 - v.t\u2080|) ^ n / n ! * d) (t : Icc v.tMin v.tMax) :\n    dist (next f\u2081 t) (next f\u2082 t) \u2264 (v.L * |t.1 - v.t\u2080|) ^ (n + 1) / (n + 1)! * d", "start": [296, 1], "end": [319, 97], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.dist_iterate_next_apply_le", "code": "theorem dist_iterate_next_apply_le (f\u2081 f\u2082 : FunSpace v) (n : \u2115) (t : Icc v.tMin v.tMax) :\n    dist (next^[n] f\u2081 t) (next^[n] f\u2082 t) \u2264 (v.L * |t.1 - v.t\u2080|) ^ n / n ! * dist f\u2081 f\u2082", "start": [322, 1], "end": [328, 41], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.FunSpace.dist_iterate_next_le", "code": "theorem dist_iterate_next_le (f\u2081 f\u2082 : FunSpace v) (n : \u2115) :\n    dist (next^[n] f\u2081) (next^[n] f\u2082) \u2264 (v.L * v.tDist) ^ n / n ! * dist f\u2081 f\u2082", "start": [331, 1], "end": [335, 9], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.exists_contracting_iterate", "code": "theorem exists_contracting_iterate :\n    \u2203 (N : \u2115) (K : _), ContractingWith K (FunSpace.next : v.FunSpace \u2192 v.FunSpace)^[N]", "start": [344, 1], "end": [351, 41], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.exists_fixed", "code": "theorem exists_fixed : \u2203 f : v.FunSpace, f.next = f", "start": [354, 1], "end": [356, 39], "kind": "commanddeclaration"}, {"full_name": "PicardLindelof.exists_solution", "code": "theorem exists_solution :\n    \u2203 f : \u211d \u2192 E, f v.t\u2080 = v.x\u2080 \u2227 \u2200 t \u2208 Icc v.tMin v.tMax,\n      HasDerivWithinAt f (v t (f t)) (Icc v.tMin v.tMax) t", "start": [361, 1], "end": [371, 64], "kind": "commanddeclaration"}, {"full_name": "IsPicardLindelof.norm_le\u2080", "code": "theorem IsPicardLindelof.norm_le\u2080 {E : Type*} [NormedAddCommGroup E] {v : \u211d \u2192 E \u2192 E}\n    {tMin t\u2080 tMax : \u211d} {x\u2080 : E} {C R : \u211d} {L : \u211d\u22650}\n    (hpl : IsPicardLindelof v tMin t\u2080 tMax x\u2080 L R C) : \u2016v t\u2080 x\u2080\u2016 \u2264 C", "start": [376, 1], "end": [379, 58], "kind": "commanddeclaration"}, {"full_name": "IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq", "code": "theorem IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq [CompleteSpace E] {v : \u211d \u2192 E \u2192 E}\n    {tMin t\u2080 tMax : \u211d} (x\u2080 : E) {C R : \u211d} {L : \u211d\u22650}\n    (hpl : IsPicardLindelof v tMin t\u2080 tMax x\u2080 L R C) :\n    \u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227\n      \u2200 t \u2208 Icc tMin tMax, HasDerivWithinAt f (v t (f t)) (Icc tMin tMax) t", "start": [382, 1], "end": [391, 80], "kind": "commanddeclaration"}, {"full_name": "exists_isPicardLindelof_const_of_contDiffOn_nhds", "code": "theorem exists_isPicardLindelof_const_of_contDiffOn_nhds {s : Set E} (hv : ContDiffOn \u211d 1 v s)\n    (hs : s \u2208 \ud835\udcdd x\u2080) :\n    \u2203 \u03b5 > (0 : \u211d), \u2203 L R C, IsPicardLindelof (fun _ => v) (t\u2080 - \u03b5) t\u2080 (t\u2080 + \u03b5) x\u2080 L R C", "start": [396, 1], "end": [432, 49], "kind": "commanddeclaration"}, {"full_name": "exists_forall_deriv_at_Ioo_eq_of_contDiffOn_nhds", "code": "theorem exists_forall_deriv_at_Ioo_eq_of_contDiffOn_nhds {s : Set E} (hv : ContDiffOn \u211d 1 v s)\n    (hs : s \u2208 \ud835\udcdd x\u2080) :\n    \u2203 \u03b5 > (0 : \u211d),\n      \u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227 \u2200 t \u2208 Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5), f t \u2208 s \u2227 HasDerivAt f (v (f t)) t", "start": [435, 1], "end": [459, 50], "kind": "commanddeclaration"}, {"full_name": "exists_forall_hasDerivAt_Ioo_eq_of_contDiff", "code": "theorem exists_forall_hasDerivAt_Ioo_eq_of_contDiff (hv : ContDiff \u211d 1 v) :\n    \u2203 \u03b5 > (0 : \u211d), \u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227 \u2200 t \u2208 Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5), HasDerivAt f (v (f t)) t", "start": [462, 1], "end": [468, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/LocallyFinite.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.nodup_Icc", "code": "theorem nodup_Icc : (Icc a b).Nodup", "start": [28, 1], "end": [29, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_Ico", "code": "theorem nodup_Ico : (Ico a b).Nodup", "start": [32, 1], "end": [33, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_Ioc", "code": "theorem nodup_Ioc : (Ioc a b).Nodup", "start": [36, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_Ioo", "code": "theorem nodup_Ioo : (Ioo a b).Nodup", "start": [40, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.Icc_eq_zero_iff", "code": "@[simp]\ntheorem Icc_eq_zero_iff : Icc a b = 0 \u2194 \u00aca \u2264 b", "start": [44, 1], "end": [46, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_eq_zero_iff", "code": "@[simp]\ntheorem Ico_eq_zero_iff : Ico a b = 0 \u2194 \u00aca < b", "start": [49, 1], "end": [51, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioc_eq_zero_iff", "code": "@[simp]\ntheorem Ioc_eq_zero_iff : Ioc a b = 0 \u2194 \u00aca < b", "start": [54, 1], "end": [56, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioo_eq_zero_iff", "code": "@[simp]\ntheorem Ioo_eq_zero_iff [DenselyOrdered \u03b1] : Ioo a b = 0 \u2194 \u00aca < b", "start": [59, 1], "end": [61, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Icc_eq_zero", "code": "alias \u27e8_, Icc_eq_zero\u27e9 := Icc_eq_zero_iff", "start": [64, 1], "end": [64, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.Ico_eq_zero", "code": "alias \u27e8_, Ico_eq_zero\u27e9 := Ico_eq_zero_iff", "start": [67, 1], "end": [67, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.Ioc_eq_zero", "code": "alias \u27e8_, Ioc_eq_zero\u27e9 := Ioc_eq_zero_iff", "start": [70, 1], "end": [70, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.Ioo_eq_zero", "code": "@[simp]\ntheorem Ioo_eq_zero (h : \u00aca < b) : Ioo a b = 0", "start": [73, 1], "end": [75, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.Icc_eq_zero_of_lt", "code": "@[simp]\ntheorem Icc_eq_zero_of_lt (h : b < a) : Icc a b = 0", "start": [78, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_eq_zero_of_le", "code": "@[simp]\ntheorem Ico_eq_zero_of_le (h : b \u2264 a) : Ico a b = 0", "start": [83, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioc_eq_zero_of_le", "code": "@[simp]\ntheorem Ioc_eq_zero_of_le (h : b \u2264 a) : Ioc a b = 0", "start": [88, 1], "end": [90, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioo_eq_zero_of_le", "code": "@[simp]\ntheorem Ioo_eq_zero_of_le (h : b \u2264 a) : Ioo a b = 0", "start": [93, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_self", "code": "theorem Ico_self : Ico a a = 0", "start": [101, 1], "end": [101, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioc_self", "code": "theorem Ioc_self : Ioc a a = 0", "start": [105, 1], "end": [105, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioo_self", "code": "theorem Ioo_self : Ioo a a = 0", "start": [109, 1], "end": [109, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.left_mem_Icc", "code": "theorem left_mem_Icc : a \u2208 Icc a b \u2194 a \u2264 b", "start": [114, 1], "end": [115, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.left_mem_Ico", "code": "theorem left_mem_Ico : a \u2208 Ico a b \u2194 a < b", "start": [118, 1], "end": [119, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.right_mem_Icc", "code": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b", "start": [122, 1], "end": [123, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.right_mem_Ioc", "code": "theorem right_mem_Ioc : b \u2208 Ioc a b \u2194 a < b", "start": [126, 1], "end": [127, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.left_not_mem_Ioc", "code": "theorem left_not_mem_Ioc : a \u2209 Ioc a b", "start": [131, 1], "end": [132, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.left_not_mem_Ioo", "code": "theorem left_not_mem_Ioo : a \u2209 Ioo a b", "start": [136, 1], "end": [137, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.right_not_mem_Ico", "code": "theorem right_not_mem_Ico : b \u2209 Ico a b", "start": [141, 1], "end": [142, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.right_not_mem_Ioo", "code": "theorem right_not_mem_Ioo : b \u2209 Ioo a b", "start": [146, 1], "end": [147, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_lt_of_le_left", "code": "theorem Ico_filter_lt_of_le_left [DecidablePred (\u00b7 < c)] (hca : c \u2264 a) :\n    ((Ico a b).filter fun x => x < c) = \u2205", "start": [150, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_lt_of_right_le", "code": "theorem Ico_filter_lt_of_right_le [DecidablePred (\u00b7 < c)] (hbc : b \u2264 c) :\n    ((Ico a b).filter fun x => x < c) = Ico a b", "start": [156, 1], "end": [158, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_lt_of_le_right", "code": "theorem Ico_filter_lt_of_le_right [DecidablePred (\u00b7 < c)] (hcb : c \u2264 b) :\n    ((Ico a b).filter fun x => x < c) = Ico a c", "start": [161, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_le_of_le_left", "code": "theorem Ico_filter_le_of_le_left [DecidablePred ((\u00b7 \u2264 \u00b7) c)] (hca : c \u2264 a) :\n    ((Ico a b).filter fun x => c \u2264 x) = Ico a b", "start": [167, 1], "end": [169, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_le_of_right_le", "code": "theorem Ico_filter_le_of_right_le [DecidablePred ((\u00b7 \u2264 \u00b7) b)] :\n    ((Ico a b).filter fun x => b \u2264 x) = \u2205", "start": [172, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_le_of_left_le", "code": "theorem Ico_filter_le_of_left_le [DecidablePred ((\u00b7 \u2264 \u00b7) c)] (hac : a \u2264 c) :\n    ((Ico a b).filter fun x => c \u2264 x) = Ico c b", "start": [178, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Icc_self", "code": "@[simp]\ntheorem Icc_self (a : \u03b1) : Icc a a = {a}", "start": [190, 1], "end": [191, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_cons_right", "code": "theorem Ico_cons_right (h : a \u2264 b) : b ::\u2098 Ico a b = Icc a b", "start": [194, 1], "end": [197, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioo_cons_left", "code": "theorem Ioo_cons_left (h : a < b) : a ::\u2098 Ioo a b = Ico a b", "start": [200, 1], "end": [203, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_disjoint_Ico", "code": "theorem Ico_disjoint_Ico {a b c d : \u03b1} (h : b \u2264 c) : (Ico a b).Disjoint (Ico c d)", "start": [206, 1], "end": [209, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_inter_Ico_of_le", "code": "@[simp]\ntheorem Ico_inter_Ico_of_le [DecidableEq \u03b1] {a b c d : \u03b1} (h : b \u2264 c) : Ico a b \u2229 Ico c d = 0", "start": [212, 1], "end": [214, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_le_left", "code": "theorem Ico_filter_le_left {a b : \u03b1} [DecidablePred (\u00b7 \u2264 a)] (hab : a < b) :\n    ((Ico a b).filter fun x => x \u2264 a) = {a}", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ico_eq_card_Icc_sub_one", "code": "theorem card_Ico_eq_card_Icc_sub_one (a b : \u03b1) : card (Ico a b) = card (Icc a b) - 1", "start": [223, 1], "end": [224, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ioc_eq_card_Icc_sub_one", "code": "theorem card_Ioc_eq_card_Icc_sub_one (a b : \u03b1) : card (Ioc a b) = card (Icc a b) - 1", "start": [227, 1], "end": [228, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ioo_eq_card_Ico_sub_one", "code": "theorem card_Ioo_eq_card_Ico_sub_one (a b : \u03b1) : card (Ioo a b) = card (Ico a b) - 1", "start": [231, 1], "end": [232, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_Ioo_eq_card_Icc_sub_two", "code": "theorem card_Ioo_eq_card_Icc_sub_two (a b : \u03b1) : card (Ioo a b) = card (Icc a b) - 2", "start": [235, 1], "end": [236, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_subset_Ico_iff", "code": "theorem Ico_subset_Ico_iff {a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1} (h : a\u2081 < b\u2081) :\n    Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [245, 1], "end": [247, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_add_Ico_eq_Ico", "code": "theorem Ico_add_Ico_eq_Ico {a b c : \u03b1} (hab : a \u2264 b) (hbc : b \u2264 c) :\n    Ico a b + Ico b c = Ico a c", "start": [250, 1], "end": [253, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_inter_Ico", "code": "theorem Ico_inter_Ico : Ico a b \u2229 Ico c d = Ico (max a c) (min b d)", "start": [256, 1], "end": [257, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_lt", "code": "@[simp]\ntheorem Ico_filter_lt (a b c : \u03b1) : ((Ico a b).filter fun x => x < c) = Ico a (min b c)", "start": [260, 1], "end": [262, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_filter_le", "code": "@[simp]\ntheorem Ico_filter_le (a b c : \u03b1) : ((Ico a b).filter fun x => c \u2264 x) = Ico (max a c) b", "start": [265, 1], "end": [267, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_sub_Ico_left", "code": "@[simp]\ntheorem Ico_sub_Ico_left (a b c : \u03b1) : Ico a b - Ico a c = Ico (max a c) b", "start": [270, 1], "end": [272, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico_sub_Ico_right", "code": "@[simp]\ntheorem Ico_sub_Ico_right (a b c : \u03b1) : Ico a b - Ico c b = Ico a (min b c)", "start": [275, 1], "end": [277, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_left_Icc", "code": "theorem map_add_left_Icc (a b c : \u03b1) : (Icc a b).map ((\u00b7 + \u00b7) c) = Icc (c + a) (c + b)", "start": [286, 1], "end": [288, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_left_Ico", "code": "theorem map_add_left_Ico (a b c : \u03b1) : (Ico a b).map ((\u00b7 + \u00b7) c) = Ico (c + a) (c + b)", "start": [291, 1], "end": [293, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_left_Ioc", "code": "theorem map_add_left_Ioc (a b c : \u03b1) : (Ioc a b).map ((\u00b7 + \u00b7) c) = Ioc (c + a) (c + b)", "start": [296, 1], "end": [298, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_left_Ioo", "code": "theorem map_add_left_Ioo (a b c : \u03b1) : (Ioo a b).map ((\u00b7 + \u00b7) c) = Ioo (c + a) (c + b)", "start": [301, 1], "end": [303, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_right_Icc", "code": "theorem map_add_right_Icc (a b c : \u03b1) : ((Icc a b).map fun x => x + c) = Icc (a + c) (b + c)", "start": [306, 1], "end": [308, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_right_Ico", "code": "theorem map_add_right_Ico (a b c : \u03b1) : ((Ico a b).map fun x => x + c) = Ico (a + c) (b + c)", "start": [311, 1], "end": [313, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_right_Ioc", "code": "theorem map_add_right_Ioc (a b c : \u03b1) : ((Ioc a b).map fun x => x + c) = Ioc (a + c) (b + c)", "start": [316, 1], "end": [318, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add_right_Ioo", "code": "theorem map_add_right_Ioo (a b c : \u03b1) : ((Ioo a b).map fun x => x + c) = Ioo (a + c) (b + c)", "start": [321, 1], "end": [323, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/DedekindDomain/SInteger.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/AdicValuation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.integer", "code": "@[simps!]\ndef integer : Subalgebra R K :=\n  {\n    (\u2a05 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation.valuationSubring.toSubring).copy\n        {x : K | \u2200 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation x \u2264 1} <|\n      Set.ext fun _ => by simp [SetLike.mem_coe, Subring.mem_iInf] with\n    algebraMap_mem' := fun x v _ => v.valuation_le_one x }", "start": [62, 1], "end": [69, 59], "kind": "commanddeclaration"}, {"full_name": "Set.integer_eq", "code": "theorem integer_eq :\n    (S.integer K).toSubring =\n      \u2a05 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation.valuationSubring.toSubring", "start": [72, 1], "end": [77, 14], "kind": "commanddeclaration"}, {"full_name": "Set.integer_valuation_le_one", "code": "theorem integer_valuation_le_one (x : S.integer K) {v : HeightOneSpectrum R} (hv : v \u2209 S) :\n    v.valuation (x : K) \u2264 1", "start": [80, 1], "end": [82, 18], "kind": "commanddeclaration"}, {"full_name": "Set.unit", "code": "@[simps!]\ndef unit : Subgroup K\u02e3 :=\n  (\u2a05 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation.valuationSubring.unitGroup).copy\n      {x : K\u02e3 | \u2200 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation (x : K) = 1} <|\n    Set.ext fun _ => by\n      simp only [mem_setOf, SetLike.mem_coe, Subgroup.mem_iInf, Valuation.mem_unitGroup_iff]", "start": [88, 1], "end": [96, 93], "kind": "commanddeclaration"}, {"full_name": "Set.unit_eq", "code": "theorem unit_eq :\n    S.unit K = \u2a05 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuation.valuationSubring.unitGroup", "start": [99, 1], "end": [101, 25], "kind": "commanddeclaration"}, {"full_name": "Set.unit_valuation_eq_one", "code": "theorem unit_valuation_eq_one (x : S.unit K) {v : HeightOneSpectrum R} (hv : v \u2209 S) :\n    v.valuation ((x : K\u02e3) : K) = 1", "start": [104, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "Set.unitEquivUnitsInteger", "code": "@[simps apply_val_coe symm_apply_coe]\ndef unitEquivUnitsInteger : S.unit K \u2243* (S.integer K)\u02e3 where\n  toFun x :=\n    \u27e8\u27e8((x : K\u02e3) : K), fun v hv => (x.property v hv).le\u27e9,\n      \u27e8((x\u207b\u00b9 : K\u02e3) : K), fun v hv => (x\u207b\u00b9.property v hv).le\u27e9,\n      Subtype.ext x.val.val_inv, Subtype.ext x.val.inv_val\u27e9\n  invFun x :=\n    \u27e8Units.mk0 x fun hx => x.ne_zero (ZeroMemClass.coe_eq_zero.mp hx),\n    fun v hv =>\n      eq_one_of_one_le_mul_left (x.val.property v hv) (x.inv.property v hv) <|\n        Eq.ge <| by\n          rw [Units.val_mk0, \u2190 map_mul, Subtype.mk_eq_mk.mp x.val_inv, v.valuation.map_one]\u27e9\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' _ _ := by ext; rfl", "start": [110, 1], "end": [127, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/FilteredColimits.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/FilteredColimits.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.FilteredColimits.M", "code": "abbrev M : AddCommGroupCat :=\n  AddCommGroupCat.FilteredColimits.colimit.{v, u}\n    (F \u22d9 forget\u2082 (ModuleCat R) AddCommGroupCat.{max v u})", "start": [46, 1], "end": [51, 58], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.M.mk", "code": "abbrev M.mk : (\u03a3 j, F.obj j) \u2192 M F :=\n  Quot.mk (Types.Quot.Rel (F \u22d9 forget (ModuleCat R)))", "start": [55, 1], "end": [57, 54], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.M.mk_eq", "code": "theorem M.mk_eq (x y : \u03a3 j, F.obj j)\n    (h : \u2203 (k : J) (f : x.1 \u27f6 k) (g : y.1 \u27f6 k), F.map f x.2 = F.map g y.2) : M.mk F x = M.mk F y", "start": [61, 1], "end": [63, 100], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitSMulAux", "code": "def colimitSMulAux (r : R) (x : \u03a3 j, F.obj j) : M F :=\n  M.mk F \u27e8x.1, r \u2022 x.2\u27e9", "start": [67, 1], "end": [69, 24], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitSMulAux_eq_of_rel", "code": "theorem colimitSMulAux_eq_of_rel (r : R) (x y : \u03a3 j, F.obj j)\n    (h : Types.FilteredColimit.Rel.{v, u} (F \u22d9 forget (ModuleCat R)) x y) :\n    colimitSMulAux F r x = colimitSMulAux F r y", "start": [73, 1], "end": [80, 13], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitHasSmul", "code": "instance colimitHasSmul : SMul R (M F) where\n  smul r x := by\n    refine' Quot.lift (colimitSMulAux F r) _ x\n    intro x y h\n    apply colimitSMulAux_eq_of_rel\n    apply Types.FilteredColimit.rel_of_quot_rel\n    exact h", "start": [84, 1], "end": [91, 12], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimit_smul_mk_eq", "code": "@[simp]\ntheorem colimit_smul_mk_eq (r : R) (x : \u03a3 j, F.obj j) : r \u2022 M.mk F x = M.mk F \u27e8x.1, r \u2022 x.2\u27e9", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitModule.one_smul", "code": "private theorem colimitModule.one_smul (x : (M F)) : (1 : R) \u2022 x = x", "start": [101, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitMulAction", "code": "instance colimitMulAction : MulAction R (M F) where\n  one_smul x := by\n    refine' Quot.inductionOn x _; clear x; intro x; cases' x with j x\n    erw [colimit_smul_mk_eq F 1 \u27e8j, x\u27e9, one_smul]\n    rfl\n  mul_smul r s x := by\n    refine' Quot.inductionOn x _; clear x; intro x; cases' x with j x\n    erw [colimit_smul_mk_eq F (r * s) \u27e8j, x\u27e9, colimit_smul_mk_eq F s \u27e8j, x\u27e9,\n      colimit_smul_mk_eq F r \u27e8j, _\u27e9, mul_smul]", "start": [108, 1], "end": [116, 47], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitSMulWithZero", "code": "instance colimitSMulWithZero : SMulWithZero R (M F) :=\n{ colimitMulAction F with\n  smul_zero := fun r => by\n    erw [colimit_zero_eq _ (IsFiltered.Nonempty.some : J), colimit_smul_mk_eq, smul_zero]\n    rfl\n  zero_smul := fun x => by\n    refine' Quot.inductionOn x _; clear x; intro x; cases' x with j x\n    erw [colimit_smul_mk_eq, zero_smul, colimit_zero_eq _ j]\n    rfl }", "start": [118, 1], "end": [126, 10], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitModule.add_smul", "code": "private theorem colimitModule.add_smul (r s : R) (x : (M F)) : (r + s) \u2022 x = r \u2022 x + s \u2022 x", "start": [128, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitModule", "code": "instance colimitModule : Module R (M F) :=\n{ colimitMulAction F,\n  colimitSMulWithZero F with\n  smul_add := fun r x y => by\n    refine' Quot.induction_on\u2082 x y _; clear x y; intro x y; cases' x with i x; cases' y with j y\n    erw [colimit_add_mk_eq _ \u27e8i, _\u27e9 \u27e8j, _\u27e9 (max' i j) (IsFiltered.leftToMax i j)\n      (IsFiltered.rightToMax i j), colimit_smul_mk_eq, smul_add, colimit_smul_mk_eq,\n      colimit_smul_mk_eq, colimit_add_mk_eq _ \u27e8i, _\u27e9 \u27e8j, _\u27e9 (max' i j) (IsFiltered.leftToMax i j)\n      (IsFiltered.rightToMax i j), LinearMap.map_smul, LinearMap.map_smul]\n    rfl\n  add_smul := colimitModule.add_smul F }", "start": [135, 1], "end": [145, 41], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimit", "code": "def colimit : ModuleCatMax.{v, u, u} R :=\n  ModuleCat.of R (M F)", "start": [150, 1], "end": [152, 23], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.coconeMorphism", "code": "def coconeMorphism (j : J) : F.obj j \u27f6 colimit F :=\n  { (AddCommGroupCat.FilteredColimits.colimitCocone\n      (F \u22d9 forget\u2082 (ModuleCat R) AddCommGroupCat.{max v u})).\u03b9.app j with\n    map_smul' := fun r x => by erw [colimit_smul_mk_eq F r \u27e8j, x\u27e9]; rfl }", "start": [156, 1], "end": [160, 74], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitCocone", "code": "def colimitCocone : Cocone F where\n  pt := colimit F\n  \u03b9 :=\n    { app := coconeMorphism F\n      naturality := fun _ _' f =>\n        LinearMap.coe_injective ((Types.colimitCocone (F \u22d9 forget (ModuleCat R))).\u03b9.naturality f) }", "start": [164, 1], "end": [170, 100], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitDesc", "code": "def colimitDesc (t : Cocone F) : colimit F \u27f6 t.pt :=\n  { (AddCommGroupCat.FilteredColimits.colimitCoconeIsColimit\n          (F \u22d9 forget\u2082 (ModuleCatMax.{v, u} R) AddCommGroupCat.{max v u})).desc\n      ((forget\u2082 (ModuleCat R) AddCommGroupCat.{max v u}).mapCocone t) with\n    map_smul' := fun r x => by\n      refine' Quot.inductionOn x _; clear x; intro x; cases' x with j x\n      erw [colimit_smul_mk_eq]\n      exact LinearMap.map_smul (t.\u03b9.app j) r x }", "start": [174, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.colimitCoconeIsColimit", "code": "def colimitCoconeIsColimit : IsColimit (colimitCocone F) where\n  desc := colimitDesc F\n  fac t j :=\n    LinearMap.coe_injective <|\n      (Types.colimitCoconeIsColimit.{v, u} (F \u22d9 forget (ModuleCat R))).fac\n        ((forget (ModuleCat R)).mapCocone t) j\n  uniq t _ h :=\n    LinearMap.coe_injective <|\n      (Types.colimitCoconeIsColimit (F \u22d9 forget (ModuleCat R))).uniq\n        ((forget (ModuleCat R)).mapCocone t) _ fun j => funext fun x => LinearMap.congr_fun (h j) x", "start": [189, 1], "end": [199, 100], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.forget\u2082AddCommGroupPreservesFilteredColimits", "code": "instance forget\u2082AddCommGroupPreservesFilteredColimits :\n    PreservesFilteredColimits (forget\u2082 (ModuleCat.{u} R) AddCommGroupCat.{u}) where\n  preserves_filtered_colimits J _ _ :=\n  { preservesColimit := fun {F : J \u2964 ModuleCat.{u} R} =>\n      preservesColimitOfPreservesColimitCocone (colimitCoconeIsColimit F)\n        (AddCommGroupCat.FilteredColimits.colimitCoconeIsColimit\n          (F \u22d9 forget\u2082 (ModuleCat.{u} R) AddCommGroupCat.{u})) }", "start": [203, 1], "end": [211, 65], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.FilteredColimits.forgetPreservesFilteredColimits", "code": "instance forgetPreservesFilteredColimits : PreservesFilteredColimits (forget (ModuleCat.{u} R)) :=\n  Limits.compPreservesFilteredColimits (forget\u2082 (ModuleCat R) AddCommGroupCat)\n    (forget AddCommGroupCat)", "start": [215, 1], "end": [217, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/OperatorNorm.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/Complex/Basic.lean", "Mathlib/Data/Complex/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.det_conjLie", "code": "@[simp]\ntheorem det_conjLie : LinearMap.det (conjLie.toLinearEquiv : \u2102 \u2192\u2097[\u211d] \u2102) = -1", "start": [25, 1], "end": [28, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.linearEquiv_det_conjLie", "code": "@[simp]\ntheorem linearEquiv_det_conjLie : LinearEquiv.det conjLie.toLinearEquiv = -1", "start": [31, 1], "end": [34, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.reClm_norm", "code": "@[simp]\ntheorem reClm_norm : \u2016reClm\u2016 = 1", "start": [37, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.reClm_nnnorm", "code": "@[simp]\ntheorem reClm_nnnorm : \u2016reClm\u2016\u208a = 1", "start": [45, 1], "end": [47, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.imClm_norm", "code": "@[simp]\ntheorem imClm_norm : \u2016imClm\u2016 = 1", "start": [50, 1], "end": [55, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.imClm_nnnorm", "code": "@[simp]\ntheorem imClm_nnnorm : \u2016imClm\u2016\u208a = 1", "start": [58, 1], "end": [60, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.conjCle_norm", "code": "@[simp]\ntheorem conjCle_norm : \u2016(conjCle : \u2102 \u2192L[\u211d] \u2102)\u2016 = 1", "start": [63, 1], "end": [65, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.conjCle_nnorm", "code": "@[simp]\ntheorem conjCle_nnorm : \u2016(conjCle : \u2102 \u2192L[\u211d] \u2102)\u2016\u208a = 1", "start": [68, 1], "end": [70, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealClm_norm", "code": "@[simp]\ntheorem ofRealClm_norm : \u2016ofRealClm\u2016 = 1", "start": [73, 1], "end": [75, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealClm_nnnorm", "code": "@[simp]\ntheorem ofRealClm_nnnorm : \u2016ofRealClm\u2016\u208a = 1", "start": [78, 1], "end": [80, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/FinEnum.lean", "imports": ["Mathlib/Data/List/ProdSigma.lean", "Mathlib/Control/Monad/Basic.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FinEnum", "code": "class FinEnum (\u03b1 : Sort*) where\n  \n  card : \u2115\n  \n  equiv : \u03b1 \u2243 Fin card\n  [decEq : DecidableEq \u03b1]", "start": [25, 1], "end": [33, 26], "kind": "commanddeclaration"}, {"full_name": "FinEnum.ofEquiv", "code": "def ofEquiv (\u03b1) {\u03b2} [FinEnum \u03b1] (h : \u03b2 \u2243 \u03b1) : FinEnum \u03b2\n    where\n  card := card \u03b1\n  equiv := h.trans (equiv)\n  decEq := (h.trans (equiv)).decidableEq", "start": [42, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "FinEnum.ofNodupList", "code": "def ofNodupList [DecidableEq \u03b1] (xs : List \u03b1) (h : \u2200 x : \u03b1, x \u2208 xs) (h' : List.Nodup xs) : FinEnum \u03b1\n    where\n  card := xs.length\n  equiv :=\n    \u27e8fun x => \u27e8xs.indexOf x, by rw [List.indexOf_lt_length]; apply h\u27e9, fun \u27e8i, h\u27e9 =>\n      xs.nthLe _ h, fun x => by simp, fun \u27e8i, h\u27e9 => by\n      simp [*]\u27e9", "start": [50, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "FinEnum.ofList", "code": "def ofList [DecidableEq \u03b1] (xs : List \u03b1) (h : \u2200 x : \u03b1, x \u2208 xs) : FinEnum \u03b1 :=\n  ofNodupList xs.dedup (by simp [*]) (List.nodup_dedup _)", "start": [60, 1], "end": [62, 58], "kind": "commanddeclaration"}, {"full_name": "FinEnum.toList", "code": "def toList (\u03b1) [FinEnum \u03b1] : List \u03b1 :=\n  (List.finRange (card \u03b1)).map (equiv).symm", "start": [65, 1], "end": [67, 44], "kind": "commanddeclaration"}, {"full_name": "FinEnum.mem_toList", "code": "@[simp]\ntheorem mem_toList [FinEnum \u03b1] (x : \u03b1) : x \u2208 toList \u03b1", "start": [72, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "FinEnum.nodup_toList", "code": "@[simp]\ntheorem nodup_toList [FinEnum \u03b1] : List.Nodup (toList \u03b1)", "start": [77, 1], "end": [79, 93], "kind": "commanddeclaration"}, {"full_name": "FinEnum.ofSurjective", "code": "def ofSurjective {\u03b2} (f : \u03b2 \u2192 \u03b1) [DecidableEq \u03b1] [FinEnum \u03b2] (h : Surjective f) : FinEnum \u03b1 :=\n  ofList ((toList \u03b2).map f) (by intro; simp; exact h _)", "start": [82, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "FinEnum.ofInjective", "code": "noncomputable def ofInjective {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) [DecidableEq \u03b1] [FinEnum \u03b2] (h : Injective f) :\n    FinEnum \u03b1 :=\n  ofList ((toList \u03b2).filterMap (partialInv f))\n    (by\n      intro x\n      simp only [mem_toList, true_and_iff, List.mem_filterMap]\n      use f x\n      simp only [h, Function.partialInv_left])", "start": [87, 1], "end": [95, 47], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pempty", "code": "instance pempty : FinEnum PEmpty :=\n  ofList [] fun x => PEmpty.elim x", "start": [98, 1], "end": [99, 35], "kind": "commanddeclaration"}, {"full_name": "FinEnum.empty", "code": "instance empty : FinEnum Empty :=\n  ofList [] fun x => Empty.elim x", "start": [102, 1], "end": [103, 34], "kind": "commanddeclaration"}, {"full_name": "FinEnum.punit", "code": "instance punit : FinEnum PUnit :=\n  ofList [PUnit.unit] fun x => by cases x; simp", "start": [106, 1], "end": [107, 48], "kind": "commanddeclaration"}, {"full_name": "FinEnum.prod", "code": "instance prod {\u03b2} [FinEnum \u03b1] [FinEnum \u03b2] : FinEnum (\u03b1 \u00d7 \u03b2) :=\n  ofList (toList \u03b1 \u00d7\u02e2 toList \u03b2) fun x => by cases x; simp", "start": [111, 1], "end": [112, 58], "kind": "commanddeclaration"}, {"full_name": "FinEnum.sum", "code": "instance sum {\u03b2} [FinEnum \u03b1] [FinEnum \u03b2] : FinEnum (Sum \u03b1 \u03b2) :=\n  ofList ((toList \u03b1).map Sum.inl ++ (toList \u03b2).map Sum.inr) fun x => by cases x <;> simp", "start": [115, 1], "end": [116, 89], "kind": "commanddeclaration"}, {"full_name": "FinEnum.fin", "code": "instance fin {n} : FinEnum (Fin n) :=\n  ofList (List.finRange _) (by simp)", "start": [119, 1], "end": [120, 37], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Quotient.enum", "code": "instance Quotient.enum [FinEnum \u03b1] (s : Setoid \u03b1) [DecidableRel ((\u00b7 \u2248 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] :\n    FinEnum (Quotient s) :=\n  FinEnum.ofSurjective Quotient.mk'' fun x => Quotient.inductionOn x fun x => \u27e8x, rfl\u27e9", "start": [123, 1], "end": [125, 87], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Finset.enum", "code": "def Finset.enum [DecidableEq \u03b1] : List \u03b1 \u2192 List (Finset \u03b1)\n  | [] => [\u2205]\n  | x :: xs => do\n    let r \u2190 Finset.enum xs\n    [r, {x} \u222a r]", "start": [128, 1], "end": [133, 17], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Finset.mem_enum", "code": "@[simp]\ntheorem Finset.mem_enum [DecidableEq \u03b1] (s : Finset \u03b1) (xs : List \u03b1) :\n    s \u2208 Finset.enum xs \u2194 \u2200 x \u2208 s, x \u2208 xs", "start": [136, 1], "end": [168, 26], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Finset.finEnum", "code": "instance Finset.finEnum [FinEnum \u03b1] : FinEnum (Finset \u03b1) :=\n  ofList (Finset.enum (toList \u03b1)) (by intro; simp)", "start": [171, 1], "end": [172, 51], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Subtype.finEnum", "code": "instance Subtype.finEnum [FinEnum \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] : FinEnum { x // p x } :=\n  ofList ((toList \u03b1).filterMap fun x => if h : p x then some \u27e8_, h\u27e9 else none)\n    (by rintro \u27e8x, h\u27e9; simp; exists x; simp [*])", "start": [175, 1], "end": [177, 49], "kind": "commanddeclaration"}, {"full_name": "FinEnum.PSigma.finEnum", "code": "instance PSigma.finEnum [FinEnum \u03b1] [\u2200 a, FinEnum (\u03b2 a)] : FinEnum (\u03a3'a, \u03b2 a) :=\n  FinEnum.ofEquiv _ (Equiv.psigmaEquivSigma _)", "start": [184, 1], "end": [185, 47], "kind": "commanddeclaration"}, {"full_name": "FinEnum.PSigma.finEnumPropLeft", "code": "instance PSigma.finEnumPropLeft {\u03b1 : Prop} {\u03b2 : \u03b1 \u2192 Type v} [\u2200 a, FinEnum (\u03b2 a)] [Decidable \u03b1] :\n    FinEnum (\u03a3'a, \u03b2 a) :=\n  if h : \u03b1 then ofList ((toList (\u03b2 h)).map <| PSigma.mk h) fun \u27e8a, Ba\u27e9 => by simp\n  else ofList [] fun \u27e8a, Ba\u27e9 => (h a).elim", "start": [188, 1], "end": [191, 43], "kind": "commanddeclaration"}, {"full_name": "FinEnum.PSigma.finEnumPropRight", "code": "instance PSigma.finEnumPropRight {\u03b2 : \u03b1 \u2192 Prop} [FinEnum \u03b1] [\u2200 a, Decidable (\u03b2 a)] :\n    FinEnum (\u03a3'a, \u03b2 a) :=\n  FinEnum.ofEquiv { a // \u03b2 a }\n    \u27e8fun \u27e8x, y\u27e9 => \u27e8x, y\u27e9, fun \u27e8x, y\u27e9 => \u27e8x, y\u27e9, fun \u27e8_, _\u27e9 => rfl, fun \u27e8_, _\u27e9 => rfl\u27e9", "start": [194, 1], "end": [197, 87], "kind": "commanddeclaration"}, {"full_name": "FinEnum.PSigma.finEnumPropProp", "code": "instance PSigma.finEnumPropProp {\u03b1 : Prop} {\u03b2 : \u03b1 \u2192 Prop} [Decidable \u03b1] [\u2200 a, Decidable (\u03b2 a)] :\n    FinEnum (\u03a3'a, \u03b2 a) :=\n  if h : \u2203 a, \u03b2 a then ofList [\u27e8h.fst, h.snd\u27e9] (by rintro \u27e8\u27e9; simp)\n  else ofList [] fun a => (h \u27e8a.fst, a.snd\u27e9).elim", "start": [200, 1], "end": [203, 50], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Pi.cons", "code": "def Pi.cons [DecidableEq \u03b1] (x : \u03b1) (xs : List \u03b1) (y : \u03b2 x) (f : \u2200 a, a \u2208 xs \u2192 \u03b2 a) :\n    \u2200 a, a \u2208 (x :: xs : List \u03b1) \u2192 \u03b2 a\n  | b, h => if h' : b = x then cast (by rw [h']) y else f b (List.mem_of_ne_of_mem h' h)", "start": [210, 1], "end": [214, 89], "kind": "commanddeclaration"}, {"full_name": "FinEnum.Pi.tail", "code": "def Pi.tail {x : \u03b1} {xs : List \u03b1} (f : \u2200 a, a \u2208 (x :: xs : List \u03b1) \u2192 \u03b2 a) : \u2200 a, a \u2208 xs \u2192 \u03b2 a\n  | a, h => f a (List.mem_cons_of_mem _ h)", "start": [217, 1], "end": [220, 43], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pi", "code": "def pi {\u03b2 : \u03b1 \u2192 Type max u v} [DecidableEq \u03b1] :\n    \u2200 xs : List \u03b1, (\u2200 a, List (\u03b2 a)) \u2192 List (\u2200 a, a \u2208 xs \u2192 \u03b2 a)\n  | [], _ => [fun x h => (List.not_mem_nil x h).elim]\n  | x :: xs, fs => FinEnum.Pi.cons x xs <$> fs x <*> pi xs fs", "start": [223, 1], "end": [227, 62], "kind": "commanddeclaration"}, {"full_name": "FinEnum.mem_pi", "code": "theorem mem_pi {\u03b2 : \u03b1 \u2192 Type _} [FinEnum \u03b1] [\u2200 a, FinEnum (\u03b2 a)] (xs : List \u03b1)\n    (f : \u2200 a, a \u2208 xs \u2192 \u03b2 a) : f \u2208 pi xs fun x => toList (\u03b2 x)", "start": [230, 1], "end": [245, 12], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pi.enum", "code": "def pi.enum (\u03b2 : \u03b1 \u2192 Type (max u v)) [FinEnum \u03b1] [\u2200 a, FinEnum (\u03b2 a)] : List (\u2200 a, \u03b2 a) :=\n  (pi.{u, v} (toList \u03b1) fun x => toList (\u03b2 x)).map (fun f x => f x (mem_toList _))", "start": [248, 1], "end": [250, 83], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pi.mem_enum", "code": "theorem pi.mem_enum {\u03b2 : \u03b1 \u2192 Type (max u v)} [FinEnum \u03b1] [\u2200 a, FinEnum (\u03b2 a)] (f : \u2200 a, \u03b2 a) :\n    f \u2208 pi.enum.{u, v} \u03b2", "start": [253, 1], "end": [254, 89], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pi.finEnum", "code": "instance pi.finEnum {\u03b2 : \u03b1 \u2192 Type (max u v)} [FinEnum \u03b1] [\u2200 a, FinEnum (\u03b2 a)] :\n    FinEnum (\u2200 a, \u03b2 a) :=\n  ofList (pi.enum.{u, v} _) fun _ => pi.mem_enum _", "start": [257, 1], "end": [259, 51], "kind": "commanddeclaration"}, {"full_name": "FinEnum.pfunFinEnum", "code": "instance pfunFinEnum (p : Prop) [Decidable p] (\u03b1 : p \u2192 Type) [\u2200 hp, FinEnum (\u03b1 hp)] :\n    FinEnum (\u2200 hp : p, \u03b1 hp) :=\n  if hp : p then\n    ofList ((toList (\u03b1 hp)).map fun x _ => x) (by intro x; simp; exact \u27e8x hp, rfl\u27e9)\n  else ofList [fun hp' => (hp hp').elim] (by intro; simp; ext hp'; cases hp hp')", "start": [262, 1], "end": [266, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/Projective.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Projective.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/Topology/StoneCech.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Profinite.projective_ultrafilter", "code": "instance projective_ultrafilter (X : Type u) : Projective (of <| Ultrafilter X) where\n  factors {Y Z} f g hg := by\n    rw [epi_iff_surjective] at hg\n    obtain \u27e8g', hg'\u27e9 := hg.hasRightInverse\n    let t : X \u2192 Y := g' \u2218 f \u2218 (pure : X \u2192 Ultrafilter X)\n    let h : Ultrafilter X \u2192 Y := Ultrafilter.extend t\n    have hh : Continuous h := continuous_ultrafilter_extend _\n    use \u27e8h, hh\u27e9\n    apply Faithful.map_injective (F := forget Profinite)\n    simp only [ContinuousMap.coe_mk, coe_comp]\n    convert denseRange_pure.equalizer (g.continuous.comp hh) f.continuous _\n     let g'' : ContinuousMap Y Z := g\n    have : g'' \u2218 g' = id := hg'.comp_eq_id\n    erw [comp.assoc, ultrafilter_extend_extends, \u2190 comp.assoc, this, comp.left_id]", "start": [38, 1], "end": [53, 83], "kind": "commanddeclaration"}, {"full_name": "Profinite.projectivePresentation", "code": "def projectivePresentation (X : Profinite.{u}) : ProjectivePresentation X where\n  p := of <| Ultrafilter X\n  f := \u27e8_, continuous_ultrafilter_extend id\u27e9\n  projective := Profinite.projective_ultrafilter X\n  epi := ConcreteCategory.epi_of_surjective _ fun x =>\n    \u27e8(pure x : Ultrafilter X), congr_fun (ultrafilter_extend_extends (\ud835\udfd9 X)) x\u27e9", "start": [56, 1], "end": [62, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Instances/Sphere.lean", "imports": ["Mathlib/Analysis/NormedSpace/BallAction.lean", "Mathlib/Analysis/Calculus/Deriv/Inv.lean", "Mathlib/Analysis/InnerProductSpace/Calculus.lean", "Mathlib/Geometry/Manifold/Instances/Real.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean", "Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean"], "premises": [{"full_name": "stereoToFun", "code": "def stereoToFun (x : E) : (\u211d \u2219 v)\u15ee :=\n  (2 / ((1 : \u211d) - innerSL \u211d v x)) \u2022 orthogonalProjection (\u211d \u2219 v)\u15ee x", "start": [84, 1], "end": [89, 68], "kind": "commanddeclaration"}, {"full_name": "stereoToFun_apply", "code": "@[simp]\ntheorem stereoToFun_apply (x : E) :\n    stereoToFun v x = (2 / ((1 : \u211d) - innerSL \u211d v x)) \u2022 orthogonalProjection (\u211d \u2219 v)\u15ee x", "start": [94, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "contDiffOn_stereoToFun", "code": "theorem contDiffOn_stereoToFun :\n    ContDiffOn \u211d \u22a4 (stereoToFun v) {x : E | innerSL _ v x \u2260 (1 : \u211d)}", "start": [100, 1], "end": [106, 37], "kind": "commanddeclaration"}, {"full_name": "continuousOn_stereoToFun", "code": "theorem continuousOn_stereoToFun :\n    ContinuousOn (stereoToFun v) {x : E | innerSL _ v x \u2260 (1 : \u211d)}", "start": [109, 1], "end": [111, 38], "kind": "commanddeclaration"}, {"full_name": "stereoInvFunAux", "code": "def stereoInvFunAux (w : E) : E :=\n  (\u2016w\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 ((4 : \u211d) \u2022 w + (\u2016w\u2016 ^ 2 - 4) \u2022 v)", "start": [116, 1], "end": [122, 54], "kind": "commanddeclaration"}, {"full_name": "stereoInvFunAux_apply", "code": "@[simp]\ntheorem stereoInvFunAux_apply (w : E) :\n    stereoInvFunAux v w = (\u2016w\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 ((4 : \u211d) \u2022 w + (\u2016w\u2016 ^ 2 - 4) \u2022 v)", "start": [127, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "stereoInvFunAux_mem", "code": "theorem stereoInvFunAux_mem (hv : \u2016v\u2016 = 1) {w : E} (hw : w \u2208 (\u211d \u2219 v)\u15ee) :\n    stereoInvFunAux v w \u2208 sphere (0 : E) 1", "start": [133, 1], "end": [144, 7], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_stereoInvFunAux", "code": "theorem hasFDerivAt_stereoInvFunAux (v : E) :\n    HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id \u211d E) 0", "start": [147, 1], "end": [162, 7], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_stereoInvFunAux_comp_coe", "code": "theorem hasFDerivAt_stereoInvFunAux_comp_coe (v : E) :\n    HasFDerivAt (stereoInvFunAux v \u2218 ((\u2191) : (\u211d \u2219 v)\u15ee \u2192 E)) (\u211d \u2219 v)\u15ee.subtypeL 0", "start": [165, 1], "end": [169, 78], "kind": "commanddeclaration"}, {"full_name": "contDiff_stereoInvFunAux", "code": "theorem contDiff_stereoInvFunAux : ContDiff \u211d \u22a4 (stereoInvFunAux v)", "start": [172, 1], "end": [181, 19], "kind": "commanddeclaration"}, {"full_name": "stereoInvFun", "code": "def stereoInvFun (hv : \u2016v\u2016 = 1) (w : (\u211d \u2219 v)\u15ee) : sphere (0 : E) 1 :=\n  \u27e8stereoInvFunAux v (w : E), stereoInvFunAux_mem hv w.2\u27e9", "start": [184, 1], "end": [187, 58], "kind": "commanddeclaration"}, {"full_name": "stereoInvFun_apply", "code": "@[simp]\ntheorem stereoInvFun_apply (hv : \u2016v\u2016 = 1) (w : (\u211d \u2219 v)\u15ee) :\n    (stereoInvFun hv w : E) = (\u2016w\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 ((4 : \u211d) \u2022 w + (\u2016w\u2016 ^ 2 - 4) \u2022 v)", "start": [190, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "stereoInvFun_ne_north_pole", "code": "theorem stereoInvFun_ne_north_pole (hv : \u2016v\u2016 = 1) (w : (\u211d \u2219 v)\u15ee) :\n    stereoInvFun hv w \u2260 (\u27e8v, by simp [hv]\u27e9 : sphere (0 : E) 1)", "start": [196, 1], "end": [207, 43], "kind": "commanddeclaration"}, {"full_name": "continuous_stereoInvFun", "code": "theorem continuous_stereoInvFun (hv : \u2016v\u2016 = 1) : Continuous (stereoInvFun hv)", "start": [210, 1], "end": [211, 93], "kind": "commanddeclaration"}, {"full_name": "stereo_left_inv", "code": "theorem stereo_left_inv (hv : \u2016v\u2016 = 1) {x : sphere (0 : E) 1} (hx : (x : E) \u2260 v) :\n    stereoInvFun hv (stereoToFun v x) = x", "start": [214, 1], "end": [267, 18], "kind": "commanddeclaration"}, {"full_name": "stereo_right_inv", "code": "theorem stereo_right_inv (hv : \u2016v\u2016 = 1) (w : (\u211d \u2219 v)\u15ee) : stereoToFun v (stereoInvFun hv w) = w", "start": [270, 1], "end": [281, 9], "kind": "commanddeclaration"}, {"full_name": "stereographic", "code": "def stereographic (hv : \u2016v\u2016 = 1) : LocalHomeomorph (sphere (0 : E) 1) (\u211d \u2219 v)\u15ee where\n  toFun := stereoToFun v \u2218 (\u2191)\n  invFun := stereoInvFun hv\n  source := {\u27e8v, by simp [hv]\u27e9}\u1d9c\n  target := Set.univ\n  map_source' := by simp\n  map_target' {w} _ := fun h => (stereoInvFun_ne_north_pole hv w) (Set.eq_of_mem_singleton h)\n  left_inv' x hx := stereo_left_inv hv fun h => hx (by\n    rw [\u2190h] at hv\n    apply Subtype.ext\n    dsimp\n    exact h)\n  right_inv' w _ := stereo_right_inv hv w\n  open_source := isOpen_compl_singleton\n  open_target := isOpen_univ\n  continuous_toFun :=\n    continuousOn_stereoToFun.comp continuous_subtype_val.continuousOn fun w h => by\n      dsimp\n      exact\n        h \u2218 Subtype.ext \u2218 Eq.symm \u2218 (inner_eq_one_iff_of_norm_one hv (by simp)).mp\n  continuous_invFun := (continuous_stereoInvFun hv).continuousOn", "start": [284, 1], "end": [306, 65], "kind": "commanddeclaration"}, {"full_name": "stereographic_apply", "code": "theorem stereographic_apply (hv : \u2016v\u2016 = 1) (x : sphere (0 : E) 1) :\n    stereographic hv x = (2 / ((1 : \u211d) - inner v x)) \u2022 orthogonalProjection (\u211d \u2219 v)\u15ee x", "start": [309, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "stereographic_source", "code": "@[simp]\ntheorem stereographic_source (hv : \u2016v\u2016 = 1) : (stereographic hv).source = {\u27e8v, by simp [hv]\u27e9}\u1d9c", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "stereographic_target", "code": "@[simp]\ntheorem stereographic_target (hv : \u2016v\u2016 = 1) : (stereographic hv).target = Set.univ", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "stereographic_apply_neg", "code": "@[simp]\ntheorem stereographic_apply_neg (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere v) (-v) = 0", "start": [324, 1], "end": [327, 90], "kind": "commanddeclaration"}, {"full_name": "stereographic_neg_apply", "code": "@[simp]\ntheorem stereographic_neg_apply (v : sphere (0 : E) 1) :\n    stereographic (norm_eq_of_mem_sphere (-v)) v = 0", "start": [330, 1], "end": [335, 7], "kind": "commanddeclaration"}, {"full_name": "findim", "code": "private theorem findim (n : \u2115) [Fact (finrank \u211d E = n + 1)] : FiniteDimensional \u211d E", "start": [361, 1], "end": [362, 46], "kind": "commanddeclaration"}, {"full_name": "stereographic'", "code": "def stereographic' (n : \u2115) [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1) :\n    LocalHomeomorph (sphere (0 : E) 1) (EuclideanSpace \u211d (Fin n)) :=\n  stereographic (norm_eq_of_mem_sphere v) \u226b\u2095\n    (OrthonormalBasis.fromOrthogonalSpanSingleton n\n            (ne_zero_of_mem_unit_sphere v)).repr.toHomeomorph.toLocalHomeomorph", "start": [364, 1], "end": [372, 80], "kind": "commanddeclaration"}, {"full_name": "stereographic'_source", "code": "@[simp]\ntheorem stereographic'_source {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).source = {v}\u1d9c", "start": [375, 1], "end": [377, 67], "kind": "commanddeclaration"}, {"full_name": "stereographic'_target", "code": "@[simp]\ntheorem stereographic'_target {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1) :\n    (stereographic' n v).target = Set.univ", "start": [380, 1], "end": [382, 71], "kind": "commanddeclaration"}, {"full_name": "chartedSpace", "code": "instance chartedSpace {n : \u2115} [Fact (finrank \u211d E = n + 1)] :\n    ChartedSpace (EuclideanSpace \u211d (Fin n)) (sphere (0 : E) 1) where\n  atlas := {f | \u2203 v : sphere (0 : E) 1, f = stereographic' n v}\n  chartAt v := stereographic' n (-v)\n  mem_chart_source v := by simpa using ne_neg_of_mem_unit_sphere \u211d v\n  chart_mem_atlas v := \u27e8-v, rfl\u27e9", "start": [385, 1], "end": [392, 33], "kind": "commanddeclaration"}, {"full_name": "sphere_ext_iff", "code": "theorem sphere_ext_iff (u v : sphere (0 : E) 1) : u = v \u2194 \u27ea(u : E), v\u27eb_\u211d = 1", "start": [398, 1], "end": [399, 55], "kind": "commanddeclaration"}, {"full_name": "stereographic'_symm_apply", "code": "theorem stereographic'_symm_apply {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1)\n    (x : EuclideanSpace \u211d (Fin n)) :\n    ((stereographic' n v).symm x : E) =\n      let U : (\u211d \u2219 (v : E))\u15ee \u2243\u2097\u1d62[\u211d] EuclideanSpace \u211d (Fin n) :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton n (ne_zero_of_mem_unit_sphere v)).repr\n      (\u2016(U.symm x : E)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (4 : \u211d) \u2022 (U.symm x : E) +\n        (\u2016(U.symm x : E)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (\u2016(U.symm x : E)\u2016 ^ 2 - 4) \u2022 v.val", "start": [402, 1], "end": [409, 81], "kind": "commanddeclaration"}, {"full_name": "smoothMfldWithCorners", "code": "instance smoothMfldWithCorners {n : \u2115} [Fact (finrank \u211d E = n + 1)] :\n    SmoothManifoldWithCorners (\ud835\udce1 n) (sphere (0 : E) 1) :=\n  smoothManifoldWithCorners_of_contDiffOn (\ud835\udce1 n) (sphere (0 : E) 1)\n    (by\n      rintro _ _ \u27e8v, rfl\u27e9 \u27e8v', rfl\u27e9\n      let U :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton (\ud835\udd5c := \u211d)\n            n (ne_zero_of_mem_unit_sphere v)).repr\n      let U' :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton (\ud835\udd5c := \u211d)\n            n (ne_zero_of_mem_unit_sphere v')).repr\n      have := findim (E := E) n\n      have H\u2081 := U'.contDiff.comp_contDiffOn contDiffOn_stereoToFun\n      have H\u2082 := (contDiff_stereoInvFunAux (v := v.val)|>.comp\n        (\u211d \u2219 (v : E))\u15ee.subtypeL.contDiff).comp U.symm.contDiff\n      convert H\u2081.comp' (H\u2082.contDiffOn : ContDiffOn \u211d \u22a4 _ Set.univ) using 1\n      simp only [LocalHomeomorph.trans_toLocalEquiv, LocalHomeomorph.symm_toLocalEquiv,\n        LocalEquiv.trans_source, LocalEquiv.symm_source, stereographic'_target,\n        stereographic'_source]\n      simp only [modelWithCornersSelf_coe, modelWithCornersSelf_coe_symm, Set.preimage_id,\n        Set.range_id, Set.inter_univ, Set.univ_inter, Set.compl_singleton_eq, Set.preimage_setOf_eq]\n      simp only [id.def, comp_apply, Submodule.subtypeL_apply, LocalHomeomorph.coe_coe_symm,\n        innerSL_apply, Ne.def, sphere_ext_iff, real_inner_comm (v' : E)]\n      rfl)", "start": [414, 1], "end": [444, 11], "kind": "commanddeclaration"}, {"full_name": "contMDiff_coe_sphere", "code": "theorem contMDiff_coe_sphere {n : \u2115} [Fact (finrank \u211d E = n + 1)] :\n    ContMDiff (\ud835\udce1 n) \ud835\udcd8(\u211d, E) \u221e ((\u2191) : sphere (0 : E) 1 \u2192 E)", "start": [446, 1], "end": [461, 38], "kind": "commanddeclaration"}, {"full_name": "ContMDiff.codRestrict_sphere", "code": "theorem ContMDiff.codRestrict_sphere {n : \u2115} [Fact (finrank \u211d E = n + 1)] {m : \u2115\u221e} {f : M \u2192 E}\n    (hf : ContMDiff I \ud835\udcd8(\u211d, E) m f) (hf' : \u2200 x, f x \u2208 sphere (0 : E) 1) :\n    ContMDiff I (\ud835\udce1 n) m (Set.codRestrict _ _ hf' : M \u2192 sphere (0 : E) 1)", "start": [470, 1], "end": [493, 61], "kind": "commanddeclaration"}, {"full_name": "contMDiff_neg_sphere", "code": "theorem contMDiff_neg_sphere {n : \u2115} [Fact (finrank \u211d E = n + 1)] :\n    ContMDiff (\ud835\udce1 n) (\ud835\udce1 n) \u221e fun x : sphere (0 : E) 1 => -x", "start": [496, 1], "end": [502, 29], "kind": "commanddeclaration"}, {"full_name": "range_mfderiv_coe_sphere", "code": "theorem range_mfderiv_coe_sphere {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1) :\n    LinearMap.range (mfderiv (\ud835\udce1 n) \ud835\udcd8(\u211d, E) ((\u2191) : sphere (0 : E) 1 \u2192 E) v :\n    TangentSpace (\ud835\udce1 n) v \u2192L[\u211d] E) = (\u211d \u2219 (v : E))\u15ee", "start": [505, 1], "end": [551, 50], "kind": "commanddeclaration"}, {"full_name": "mfderiv_coe_sphere_injective", "code": "theorem mfderiv_coe_sphere_injective {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1) :\n    Injective (mfderiv (\ud835\udce1 n) \ud835\udcd8(\u211d, E) ((\u2191) : sphere (0 : E) 1 \u2192 E) v)", "start": [554, 1], "end": [578, 36], "kind": "commanddeclaration"}, {"full_name": "finrank_real_complex_fact'", "code": "theorem finrank_real_complex_fact' : Fact (finrank \u211d \u2102 = 1 + 1)", "start": [588, 1], "end": [589, 28], "kind": "commanddeclaration"}, {"full_name": "contMDiff_expMapCircle", "code": "theorem contMDiff_expMapCircle : ContMDiff \ud835\udcd8(\u211d, \u211d) (\ud835\udce1 1) \u221e expMapCircle", "start": [619, 1], "end": [621, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sets/Order.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Topology/Sets/Closeds.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ClopenUpperSet", "code": "structure ClopenUpperSet (\u03b1 : Type*) [TopologicalSpace \u03b1] [LE \u03b1] extends Clopens \u03b1 where\n  upper' : IsUpperSet carrier", "start": [25, 1], "end": [27, 30], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.Simps.coe", "code": "def Simps.coe (s : ClopenUpperSet \u03b1) : Set \u03b1 := s", "start": [39, 1], "end": [40, 50], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.upper", "code": "theorem upper (s : ClopenUpperSet \u03b1) : IsUpperSet (s : Set \u03b1)", "start": [44, 1], "end": [45, 11], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.clopen", "code": "theorem clopen (s : ClopenUpperSet \u03b1) : IsClopen (s : Set \u03b1)", "start": [48, 1], "end": [49, 12], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.toUpperSet", "code": "@[simps]\ndef toUpperSet (s : ClopenUpperSet \u03b1) : UpperSet \u03b1 :=\n  \u27e8s, s.upper\u27e9", "start": [52, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.ext", "code": "@[ext]\nprotected theorem ext {s t : ClopenUpperSet \u03b1} (h : (s : Set \u03b1) = t) : s = t", "start": [58, 1], "end": [60, 17], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Clopens \u03b1) (h) : (mk s h : Set \u03b1) = s", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.coe_sup", "code": "@[simp]\ntheorem coe_sup (s t : ClopenUpperSet \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.coe_inf", "code": "@[simp]\ntheorem coe_inf (s t : ClopenUpperSet \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.coe_top", "code": "@[simp]\ntheorem coe_top : (\u2191(\u22a4 : ClopenUpperSet \u03b1) : Set \u03b1) = univ", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "ClopenUpperSet.coe_bot", "code": "@[simp]\ntheorem coe_bot : (\u2191(\u22a5 : ClopenUpperSet \u03b1) : Set \u03b1) = \u2205", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Array.lean", "imports": ["Mathlib/Data/Fintype/Vector.lean", "Mathlib/Data/Fintype/Pi.lean", "Mathlib/Logic/Equiv/Array.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Category/MonCat/Colimits.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/ConcreteCategory/Elementwise.lean", "Mathlib/Algebra/Category/MonCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonCat.Colimits.Prequotient", "code": "inductive Prequotient\n  | of : \u2200 (j : J) (_ : F.obj j), Prequotient\n  | one : Prequotient\n  | mul : Prequotient \u2192 Prequotient \u2192 Prequotient", "start": [70, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.Relation", "code": "inductive Relation : Prequotient F \u2192 Prequotient F \u2192 Prop| refl : \u2200 x, Relation x x\n  | symm : \u2200 (x y) (_ : Relation x y), Relation y x\n  | trans : \u2200 (x y z) (_ : Relation x y) (_ : Relation y z),\n      Relation x z| map :\n    \u2200 (j j' : J) (f : j \u27f6 j') (x : F.obj j),\n      Relation (Prequotient.of j' ((F.map f) x))\n        (Prequotient.of j x)| mul : \u2200 (j) (x y : F.obj j), Relation (Prequotient.of j (x * y))\n      (mul (Prequotient.of j x) (Prequotient.of j y))\n  | one : \u2200 j, Relation (Prequotient.of j 1) one| mul_1 : \u2200 (x x' y) (_ : Relation x x'), Relation (mul x y) (mul x' y)\n  | mul_2 : \u2200 (x y y') (_ : Relation y y'), Relation (mul x y) (mul x y')\n    | mul_assoc : \u2200 x y z, Relation (mul (mul x y) z) (mul x (mul y z))\n  | one_mul : \u2200 x, Relation (mul one x) x\n  | mul_one : \u2200 x, Relation (mul x one) x", "start": [87, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.colimitSetoid", "code": "def colimitSetoid : Setoid (Prequotient F) where\n  r := Relation F\n  iseqv := \u27e8Relation.refl, Relation.symm _ _, Relation.trans _ _ _\u27e9", "start": [112, 1], "end": [116, 68], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.ColimitType", "code": "def ColimitType : Type v :=\n  Quotient (colimitSetoid F)", "start": [122, 1], "end": [125, 29], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.monoidColimitType", "code": "instance monoidColimitType : Monoid (ColimitType F) where\n  one := Quotient.mk _ one\n  mul := Quotient.map\u2082 mul <| fun x x' rx y y' ry =>\n    Setoid.trans (Relation.mul_1 _ _ y rx) (Relation.mul_2 x' _ _ ry)\n  one_mul := Quotient.ind <| fun _ => Quotient.sound <| Relation.one_mul _\n  mul_one := Quotient.ind <| fun _ => Quotient.sound <| Relation.mul_one _\n  mul_assoc := Quotient.ind <| fun _ => Quotient.ind\u2082 <| fun _ _ =>\n    Quotient.sound <| Relation.mul_assoc _ _ _", "start": [133, 1], "end": [140, 47], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.quot_one", "code": "@[simp]\ntheorem quot_one : Quot.mk Setoid.r one = (1 : ColimitType F)", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.quot_mul", "code": "@[simp]\ntheorem quot_mul (x y : Prequotient F) : Quot.mk Setoid.r (mul x y) =\n    @HMul.hMul (ColimitType F) (ColimitType F) (ColimitType F) _\n      (Quot.mk Setoid.r x) (Quot.mk Setoid.r y)", "start": [150, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.colimit", "code": "def colimit : MonCat :=\n  \u27e8ColimitType F, by infer_instance\u27e9", "start": [158, 1], "end": [160, 37], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.coconeFun", "code": "def coconeFun (j : J) (x : F.obj j) : ColimitType F :=\n  Quot.mk _ (Prequotient.of j x)", "start": [164, 1], "end": [166, 33], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.coconeMorphism", "code": "def coconeMorphism (j : J) : F.obj j \u27f6 colimit F where\n  toFun := coconeFun F j\n  map_one' := Quot.sound (Relation.one _)\n  map_mul' _ _ := Quot.sound (Relation.mul _ _ _)", "start": [170, 1], "end": [174, 50], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.cocone_naturality", "code": "@[simp]\ntheorem cocone_naturality {j j' : J} (f : j \u27f6 j') :\n    F.map f \u226b coconeMorphism F j' = coconeMorphism F j", "start": [178, 1], "end": [183, 21], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.cocone_naturality_components", "code": "@[simp]\ntheorem cocone_naturality_components (j j' : J) (f : j \u27f6 j') (x : F.obj j) :\n    (coconeMorphism F j') (F.map f x) = (coconeMorphism F j) x", "start": [187, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.colimitCocone", "code": "def colimitCocone : Cocone F where\n  pt := colimit F\n  \u03b9 := { app := coconeMorphism F }", "start": [195, 1], "end": [198, 35], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.descFunLift", "code": "@[simp]\ndef descFunLift (s : Cocone F) : Prequotient F \u2192 s.pt\n  | Prequotient.of j x => (s.\u03b9.app j) x\n  | one => 1\n  | mul x y => descFunLift _ x * descFunLift _ y", "start": [202, 1], "end": [207, 49], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.descFun", "code": "def descFun (s : Cocone F) : ColimitType F \u2192 s.pt := by\n  fapply Quot.lift\n  \u00b7 exact descFunLift F s\n  \u00b7 intro x y r\n    induction r with\n    | refl x => rfl\n    | symm x y _ h => exact h.symm\n    | trans x y z _ _ h\u2081 h\u2082 => exact h\u2081.trans h\u2082\n    | map j j' f x => exact s.w_apply f x\n    | mul j x y => exact map_mul _ _ _\n    | one j => exact map_one _\n    | mul_1 x x' y _ h => exact congr_arg (\u00b7 * _) h\n    | mul_2 x y y' _ h => exact congr_arg (_ * \u00b7) h\n    | mul_assoc x y z => exact mul_assoc _ _ _\n    | one_mul x => exact one_mul _\n    | mul_one x => exact mul_one _", "start": [211, 1], "end": [227, 35], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.descMorphism", "code": "def descMorphism (s : Cocone F) : colimit F \u27f6 s.pt where\n  toFun := descFun F s\n  map_one' := rfl\n  map_mul' x y := by\n    induction x using Quot.inductionOn\n    induction y using Quot.inductionOn\n    dsimp [descFun]\n    rw [\u2190 quot_mul]\n    simp only [descFunLift]", "start": [231, 1], "end": [240, 28], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.colimitIsColimit", "code": "def colimitIsColimit : IsColimit (colimitCocone F) where\n  desc s := descMorphism F s\n  uniq s m w := by\n    ext x\n    induction' x using Quot.inductionOn with x\n    induction' x with j x x y hx hy\n    \u00b7 change _ = s.\u03b9.app j _\n      rw [\u2190 w j]\n      rfl\n    \u00b7 rw [quot_one, map_one]\n      rfl\n    \u00b7 rw [quot_mul, map_mul, hx, hy]\n      dsimp [descMorphism, FunLike.coe, descFun]\n      simp only [\u2190 quot_mul, descFunLift]", "start": [244, 1], "end": [258, 42], "kind": "commanddeclaration"}, {"full_name": "MonCat.Colimits.hasColimits_monCat", "code": "instance hasColimits_monCat : HasColimits MonCat where\n  has_colimits_of_shape _ _ :=\n    { has_colimit := fun F =>\n        HasColimit.mk\n          { cocone := colimitCocone F\n            isColimit := colimitIsColimit F } }", "start": [262, 1], "end": [267, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/OptionalSampling.lean", "imports": ["Mathlib/Probability/Martingale/Basic.lean", "Mathlib/Order/SuccPred/LinearLocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DiscreteTopology.secondCountableTopology_of_countable", "code": "instance (priority := 100) DiscreteTopology.secondCountableTopology_of_countable {\u03b1 : Type*}\n    [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] [Countable \u03b1] : SecondCountableTopology \u03b1 :=\n  @DiscreteTopology.secondCountableTopology_of_encodable _ _ _ (Encodable.ofCountable _)", "start": [39, 1], "end": [41, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const", "code": "theorem condexp_stopping_time_ae_eq_restrict_eq_const\n    [(Filter.atTop : Filter \u03b9).IsCountablyGenerated] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) [SigmaFinite (\u03bc.trim h\u03c4.measurableSpace_le)] (hin : i \u2264 n) :\n    \u03bc[f n|h\u03c4.measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] f i", "start": [57, 1], "end": [64, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const", "code": "theorem condexp_stopping_time_ae_eq_restrict_eq_const_of_le_const (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] (i : \u03b9) :\n    \u03bc[f n|h\u03c4.measurableSpace] =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] f i", "start": [67, 1], "end": [80, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq", "code": "theorem stoppedValue_ae_eq_restrict_eq (h : Martingale f \u2131 \u03bc) (h\u03c4 : IsStoppingTime \u2131 \u03c4)\n    (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] (i : \u03b9) :\n    stoppedValue f \u03c4 =\u1d50[\u03bc.restrict {x | \u03c4 x = i}] \u03bc[f n|h\u03c4.measurableSpace]", "start": [83, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_const_of_countable_range", "code": "theorem stoppedValue_ae_eq_condexp_of_le_const_of_countable_range (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) (h_countable_range : (Set.range \u03c4).Countable)\n    [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] :\n    stoppedValue f \u03c4 =\u1d50[\u03bc] \u03bc[f n|h\u03c4.measurableSpace]", "start": [94, 1], "end": [106, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_const", "code": "theorem stoppedValue_ae_eq_condexp_of_le_const [Countable \u03b9] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    [SigmaFinite (\u03bc.trim (h\u03c4.measurableSpace_le_of_le h\u03c4_le))] :\n    stoppedValue f \u03c4 =\u1d50[\u03bc] \u03bc[f n|h\u03c4.measurableSpace]", "start": [109, 1], "end": [115, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le_of_countable_range", "code": "theorem stoppedValue_ae_eq_condexp_of_le_of_countable_range (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c3 : IsStoppingTime \u2131 \u03c3) (h\u03c3_le_\u03c4 : \u03c3 \u2264 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    (h\u03c4_countable_range : (Set.range \u03c4).Countable) (h\u03c3_countable_range : (Set.range \u03c3).Countable)\n    [SigmaFinite (\u03bc.trim (h\u03c3.measurableSpace_le_of_le fun x => (h\u03c3_le_\u03c4 x).trans (h\u03c4_le x)))] :\n    stoppedValue f \u03c3 =\u1d50[\u03bc] \u03bc[stoppedValue f \u03c4|h\u03c3.measurableSpace]", "start": [118, 1], "end": [135, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_ae_eq_condexp_of_le", "code": "theorem stoppedValue_ae_eq_condexp_of_le [Countable \u03b9] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c3 : IsStoppingTime \u2131 \u03c3) (h\u03c3_le_\u03c4 : \u03c3 \u2264 \u03c4) (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    [SigmaFinite (\u03bc.trim h\u03c3.measurableSpace_le)] :\n    stoppedValue f \u03c3 =\u1d50[\u03bc] \u03bc[stoppedValue f \u03c4|h\u03c3.measurableSpace]", "start": [138, 1], "end": [146, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.condexp_stoppedValue_stopping_time_ae_eq_restrict_le", "code": "theorem condexp_stoppedValue_stopping_time_ae_eq_restrict_le (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c3 : IsStoppingTime \u2131 \u03c3) [SigmaFinite (\u03bc.trim h\u03c3.measurableSpace_le)]\n    (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n) :\n    \u03bc[stoppedValue f \u03c4|h\u03c3.measurableSpace] =\u1d50[\u03bc.restrict {x : \u03a9 | \u03c4 x \u2264 \u03c3 x}] stoppedValue f \u03c4", "start": [163, 1], "end": [189, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.stoppedValue_min_ae_eq_condexp", "code": "theorem stoppedValue_min_ae_eq_condexp [SigmaFiniteFiltration \u03bc \u2131] (h : Martingale f \u2131 \u03bc)\n    (h\u03c4 : IsStoppingTime \u2131 \u03c4) (h\u03c3 : IsStoppingTime \u2131 \u03c3) {n : \u03b9} (h\u03c4_le : \u2200 x, \u03c4 x \u2264 n)\n    [h_sf_min : SigmaFinite (\u03bc.trim (h\u03c4.min h\u03c3).measurableSpace_le)] :\n    (stoppedValue f fun x => min (\u03c3 x) (\u03c4 x)) =\u1d50[\u03bc] \u03bc[stoppedValue f \u03c4|h\u03c3.measurableSpace]", "start": [192, 1], "end": [221, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector/Mem.lean", "imports": ["Mathlib/Data/Vector/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector.get_mem", "code": "@[simp]\ntheorem get_mem (i : Fin n) (v : Vector \u03b1 n) : v.get i \u2208 v.toList", "start": [25, 1], "end": [28, 27], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_iff_get", "code": "theorem mem_iff_get (v : Vector \u03b1 n) : a \u2208 v.toList \u2194 \u2203 i, v.get i = a", "start": [31, 1], "end": [35, 38], "kind": "commanddeclaration"}, {"full_name": "Vector.not_mem_nil", "code": "theorem not_mem_nil : a \u2209 (Vector.nil : Vector \u03b1 0).toList", "start": [38, 1], "end": [41, 7], "kind": "commanddeclaration"}, {"full_name": "Vector.not_mem_zero", "code": "theorem not_mem_zero (v : Vector \u03b1 0) : a \u2209 v.toList", "start": [44, 1], "end": [45, 41], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_cons_iff", "code": "theorem mem_cons_iff (v : Vector \u03b1 n) : a' \u2208 (a ::\u1d65 v).toList \u2194 a' = a \u2228 a' \u2208 v.toList", "start": [48, 1], "end": [49, 41], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_succ_iff", "code": "theorem mem_succ_iff (v : Vector \u03b1 (n + 1)) : a \u2208 v.toList \u2194 a = v.head \u2228 a \u2208 v.tail.toList", "start": [52, 1], "end": [54, 71], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_cons_self", "code": "theorem mem_cons_self (v : Vector \u03b1 n) : a \u2208 (a ::\u1d65 v).toList", "start": [57, 1], "end": [58, 67], "kind": "commanddeclaration"}, {"full_name": "Vector.head_mem", "code": "@[simp]\ntheorem head_mem (v : Vector \u03b1 (n + 1)) : v.head \u2208 v.toList", "start": [61, 1], "end": [63, 57], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_cons_of_mem", "code": "theorem mem_cons_of_mem (v : Vector \u03b1 n) (ha' : a' \u2208 v.toList) : a' \u2208 (a ::\u1d65 v).toList", "start": [66, 1], "end": [67, 46], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_of_mem_tail", "code": "theorem mem_of_mem_tail (v : Vector \u03b1 n) (ha : a \u2208 v.tail.toList) : a \u2208 v.toList", "start": [70, 1], "end": [73, 43], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_map_iff", "code": "theorem mem_map_iff (b : \u03b2) (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    b \u2208 (v.map f).toList \u2194 \u2203 a : \u03b1, a \u2208 v.toList \u2227 f a = b", "start": [76, 1], "end": [78, 39], "kind": "commanddeclaration"}, {"full_name": "Vector.not_mem_map_zero", "code": "theorem not_mem_map_zero (b : \u03b2) (v : Vector \u03b1 0) (f : \u03b1 \u2192 \u03b2) : b \u2209 (v.map f).toList", "start": [81, 1], "end": [82, 91], "kind": "commanddeclaration"}, {"full_name": "Vector.mem_map_succ_iff", "code": "theorem mem_map_succ_iff (b : \u03b2) (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) :\n    b \u2208 (v.map f).toList \u2194 f v.head = b \u2228 \u2203 a : \u03b1, a \u2208 v.tail.toList \u2227 f a = b", "start": [85, 1], "end": [87, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Interval.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Option/NAry.lean", "Mathlib/Order/Interval.lean", "Mathlib/Data/Set/Pointwise/Basic.lean"], "premises": [{"full_name": "NonemptyInterval.toProd_one", "code": "@[to_additive (attr := simp) toProd_zero]\ntheorem toProd_one : (1 : NonemptyInterval \u03b1).toProd = 1", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_one", "code": "@[to_additive]\ntheorem fst_one : (1 : NonemptyInterval \u03b1).fst = 1", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_one", "code": "@[to_additive]\ntheorem snd_one : (1 : NonemptyInterval \u03b1).snd = 1", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_one_interval", "code": "@[to_additive (attr := push_cast, simp)]\ntheorem coe_one_interval : ((1 : NonemptyInterval \u03b1) : Interval \u03b1) = 1", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_one", "code": "@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : \u03b1) = 1", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.pure_one", "code": "@[to_additive (attr := simp)]\ntheorem pure_one : pure (1 : \u03b1) = 1", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.one_ne_bot", "code": "@[to_additive (attr := simp)]\ntheorem one_ne_bot : (1 : Interval \u03b1) \u2260 \u22a5", "start": [92, 1], "end": [94, 14], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_ne_one", "code": "@[to_additive (attr := simp)]\ntheorem bot_ne_one : (\u22a5 : Interval \u03b1) \u2260 1", "start": [98, 1], "end": [100, 14], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : NonemptyInterval \u03b1) : Set \u03b1) = 1", "start": [114, 1], "end": [116, 13], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one : (1 : \u03b1) \u2208 (1 : NonemptyInterval \u03b1)", "start": [120, 1], "end": [122, 19], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : Interval \u03b1) : Set \u03b1) = 1", "start": [130, 1], "end": [132, 13], "kind": "commanddeclaration"}, {"full_name": "Interval.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one : (1 : \u03b1) \u2208 (1 : Interval \u03b1)", "start": [136, 1], "end": [138, 19], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toProd_mul", "code": "@[to_additive (attr := simp) toProd_add]\ntheorem toProd_mul : (s * t).toProd = s.toProd * t.toProd", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_mul", "code": "@[to_additive]\ntheorem fst_mul : (s * t).fst = s.fst * t.fst", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_mul", "code": "@[to_additive]\ntheorem snd_mul : (s * t).snd = s.snd * t.snd", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_mul_interval", "code": "@[to_additive (attr := simp)]\ntheorem coe_mul_interval : (\u2191(s * t) : Interval \u03b1) = s * t", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_mul_pure", "code": "@[to_additive (attr := simp)]\ntheorem pure_mul_pure : pure a * pure b = pure (a * b)", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_mul", "code": "@[to_additive (attr := simp)]\ntheorem bot_mul : \u22a5 * t = \u22a5", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.mul_bot", "code": "@[to_additive]\ntheorem mul_bot : s * \u22a5 = \u22a5", "start": [214, 1], "end": [216, 29], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.hasNsmul", "code": "instance NonemptyInterval.hasNsmul [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] : SMul \u2115 (NonemptyInterval \u03b1) :=\n  \u27e8fun n s => \u27e8(n \u2022 s.fst, n \u2022 s.snd), nsmul_le_nsmul_of_le_right s.fst_le_snd _\u27e9\u27e9", "start": [231, 1], "end": [233, 83], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.hasPow", "code": "@[to_additive existing NonemptyInterval.hasNsmul]\ninstance NonemptyInterval.hasPow : Pow (NonemptyInterval \u03b1) \u2115 :=\n  \u27e8fun s n => \u27e8s.toProd ^ n, pow_le_pow_of_le_left' s.fst_le_snd _\u27e9\u27e9", "start": [241, 1], "end": [243, 69], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toProd_pow", "code": "@[to_additive (attr := simp) toProd_nsmul]\ntheorem toProd_pow : (s ^ n).toProd = s.toProd ^ n", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_pow", "code": "@[to_additive]\ntheorem fst_pow : (s ^ n).fst = s.fst ^ n", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_pow", "code": "@[to_additive]\ntheorem snd_pow : (s ^ n).snd = s.snd ^ n", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_pow", "code": "@[to_additive (attr := simp)]\ntheorem pure_pow : pure a ^ n = pure (a ^ n)", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.commMonoid", "code": "@[to_additive]\ninstance commMonoid [OrderedCommMonoid \u03b1] : CommMonoid (NonemptyInterval \u03b1) :=\n  NonemptyInterval.toProd_injective.commMonoid _ toProd_one toProd_mul toProd_pow", "start": [280, 1], "end": [282, 82], "kind": "commanddeclaration"}, {"full_name": "Interval.mulOneClass", "code": "@[to_additive]\ninstance Interval.mulOneClass [OrderedCommMonoid \u03b1] : MulOneClass (Interval \u03b1) where\n  mul := (\u00b7 * \u00b7)\n  one := 1\n  one_mul s :=\n    (Option.map\u2082_coe_left _ _ _).trans <| by\n      simp_rw [NonemptyInterval.pure_one, one_mul, \u2190 id_def, Option.map_id, id]\n  mul_one s :=\n    (Option.map\u2082_coe_right _ _ _).trans <| by\n      simp_rw [NonemptyInterval.pure_one, mul_one, \u2190 id_def, Option.map_id, id]", "start": [286, 1], "end": [295, 80], "kind": "commanddeclaration"}, {"full_name": "Interval.commMonoid", "code": "@[to_additive]\ninstance Interval.commMonoid [OrderedCommMonoid \u03b1] : CommMonoid (Interval \u03b1) :=\n  { Interval.mulOneClass with\n    mul_comm := fun _ _ => Option.map\u2082_comm mul_comm\n    mul_assoc := fun _ _ _ => Option.map\u2082_assoc mul_assoc }", "start": [297, 1], "end": [301, 60], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_pow_interval", "code": "@[to_additive]\ntheorem coe_pow_interval [OrderedCommMonoid \u03b1] (s : NonemptyInterval \u03b1) (n : \u2115) :\n    (s ^ n : Interval \u03b1) = (s : Interval \u03b1) ^ n", "start": [305, 1], "end": [308, 95], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_pow", "code": "@[to_additive]\ntheorem bot_pow : \u2200 {n : \u2115} (_ : n \u2260 0), (\u22a5 : Interval \u03b1) ^ n = \u22a5", "start": [321, 1], "end": [324, 37], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_sub", "code": "@[simp]\ntheorem fst_sub : (s - t).fst = s.fst - t.snd", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_sub", "code": "@[simp]\ntheorem snd_sub : (s - t).snd = s.snd - t.fst", "start": [358, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_sub_interval", "code": "@[simp]\ntheorem coe_sub_interval : (\u2191(s - t) : Interval \u03b1) = s - t", "start": [363, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.sub_mem_sub", "code": "theorem sub_mem_sub (ha : a \u2208 s) (hb : b \u2208 t) : a - b \u2208 s - t", "start": [368, 1], "end": [369, 51], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_sub_pure", "code": "@[simp]\ntheorem pure_sub_pure (a b : \u03b1) : pure a - pure b = pure (a - b)", "start": [372, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_sub", "code": "@[simp]\ntheorem bot_sub : \u22a5 - t = \u22a5", "start": [383, 1], "end": [385, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.sub_bot", "code": "@[simp]\ntheorem sub_bot : s - \u22a5 = \u22a5", "start": [388, 1], "end": [390, 29], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_div", "code": "@[to_additive existing (attr := simp)]\ntheorem fst_div : (s / t).fst = s.fst / t.snd", "start": [420, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_div", "code": "@[to_additive existing (attr := simp)]\ntheorem snd_div : (s / t).snd = s.snd / t.fst", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_div_interval", "code": "@[to_additive existing (attr := simp)]\ntheorem coe_div_interval : (\u2191(s / t) : Interval \u03b1) = s / t", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.div_mem_div", "code": "@[to_additive existing]\ntheorem div_mem_div (ha : a \u2208 s) (hb : b \u2208 t) : a / b \u2208 s / t", "start": [435, 1], "end": [437, 51], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_div_pure", "code": "@[to_additive existing (attr := simp)]\ntheorem pure_div_pure : pure a / pure b = pure (a / b)", "start": [440, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_div", "code": "@[to_additive existing (attr := simp)]\ntheorem bot_div : \u22a5 / t = \u22a5", "start": [451, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.div_bot", "code": "@[to_additive existing (attr := simp)]\ntheorem div_bot : s / \u22a5 = \u22a5", "start": [456, 1], "end": [458, 29], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_inv", "code": "@[to_additive (attr := simp)]\ntheorem fst_inv : s\u207b\u00b9.fst = s.snd\u207b\u00b9", "start": [484, 1], "end": [486, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_inv", "code": "@[to_additive (attr := simp)]\ntheorem snd_inv : s\u207b\u00b9.snd = s.fst\u207b\u00b9", "start": [490, 1], "end": [492, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_inv_interval", "code": "@[to_additive (attr := simp)]\ntheorem coe_inv_interval : (\u2191(s\u207b\u00b9) : Interval \u03b1) = (\u2191s)\u207b\u00b9", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.inv_mem_inv", "code": "@[to_additive]\ntheorem inv_mem_inv (ha : a \u2208 s) : a\u207b\u00b9 \u2208 s\u207b\u00b9", "start": [502, 1], "end": [504, 39], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.inv_pure", "code": "@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a)\u207b\u00b9 = pure a\u207b\u00b9", "start": [508, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.inv_bot", "code": "@[to_additive (attr := simp)]\ntheorem Interval.inv_bot : (\u22a5 : Interval \u03b1)\u207b\u00b9 = \u22a5", "start": [516, 1], "end": [518, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mul_eq_one_iff", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 \u2194 \u2203 a b, s = pure a \u2227 t = pure b \u2227 a * b = 1", "start": [528, 1], "end": [537, 36], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.subtractionCommMonoid", "code": "instance subtractionCommMonoid {\u03b1 : Type u} [OrderedAddCommGroup \u03b1] :\n    SubtractionCommMonoid (NonemptyInterval \u03b1) :=\n  { NonemptyInterval.addCommMonoid with\n    neg := Neg.neg\n    sub := Sub.sub\n    sub_eq_add_neg := fun s t => by\n      refine NonemptyInterval.ext _ _ (Prod.ext ?_ ?_) <;>\n      exact sub_eq_add_neg _ _\n    neg_neg := fun s => by apply NonemptyInterval.ext; exact neg_neg _\n    neg_add_rev := fun s t => by\n      refine NonemptyInterval.ext _ _ (Prod.ext ?_ ?_) <;>\n      exact neg_add_rev _ _\n    neg_eq_of_add := fun s t h => by\n      obtain \u27e8a, b, rfl, rfl, hab\u27e9 := NonemptyInterval.add_eq_zero_iff.1 h\n      rw [neg_pure, neg_eq_of_add_eq_zero_right hab] }", "start": [541, 1], "end": [555, 55], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.divisionCommMonoid", "code": "@[to_additive existing NonemptyInterval.subtractionCommMonoid]\ninstance divisionCommMonoid : DivisionCommMonoid (NonemptyInterval \u03b1) :=\n  { NonemptyInterval.commMonoid with\n    inv := Inv.inv\n    div := (\u00b7 / \u00b7)\n    div_eq_mul_inv := fun s t => by\n      refine NonemptyInterval.ext _ _ (Prod.ext ?_ ?_) <;>\n      exact div_eq_mul_inv _ _\n    inv_inv := fun s => by apply NonemptyInterval.ext; exact inv_inv _\n    mul_inv_rev := fun s t => by\n      refine NonemptyInterval.ext _ _ (Prod.ext ?_ ?_) <;>\n      exact mul_inv_rev _ _\n    inv_eq_of_mul := fun s t h => by\n      obtain \u27e8a, b, rfl, rfl, hab\u27e9 := NonemptyInterval.mul_eq_one_iff.1 h\n      rw [inv_pure, inv_eq_of_mul_eq_one_right hab] }", "start": [557, 1], "end": [571, 54], "kind": "commanddeclaration"}, {"full_name": "Interval.mul_eq_one_iff", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 \u2194 \u2203 a b, s = pure a \u2227 t = pure b \u2227 a * b = 1", "start": [579, 1], "end": [587, 42], "kind": "commanddeclaration"}, {"full_name": "Interval.subtractionCommMonoid", "code": "instance subtractionCommMonoid {\u03b1 : Type u} [OrderedAddCommGroup \u03b1] :\n    SubtractionCommMonoid (Interval \u03b1) :=\n  { Interval.addCommMonoid with\n    neg := Neg.neg\n    sub := Sub.sub\n    sub_eq_add_neg := by\n      rintro (_ | s) (_ | t) <;> first |rfl|exact congr_arg some (sub_eq_add_neg _ _)\n    neg_neg := by rintro (_ | s) <;> first |rfl|exact congr_arg some (neg_neg _)\n    neg_add_rev := by rintro (_ | s) (_ | t) <;> first |rfl|exact congr_arg some (neg_add_rev _ _)\n    neg_eq_of_add := by\n      rintro (_ | s) (_ | t) h <;>\n        first\n          | cases h\n          | exact congr_arg some (neg_eq_of_add_eq_zero_right <| Option.some_injective _ h) }", "start": [591, 1], "end": [604, 94], "kind": "commanddeclaration"}, {"full_name": "Interval.divisionCommMonoid", "code": "@[to_additive existing Interval.subtractionCommMonoid]\ninstance divisionCommMonoid : DivisionCommMonoid (Interval \u03b1) :=\n  { Interval.commMonoid with\n    inv := Inv.inv\n    div := (\u00b7 / \u00b7)\n    div_eq_mul_inv := by\n      rintro (_ | s) (_ | t) <;> first |rfl|exact congr_arg some (div_eq_mul_inv _ _)\n    inv_inv := by rintro (_ | s) <;> first |rfl|exact congr_arg some (inv_inv _)\n    mul_inv_rev := by rintro (_ | s) (_ | t) <;> first |rfl|exact congr_arg some (mul_inv_rev _ _)\n    inv_eq_of_mul := by\n      rintro (_ | s) (_ | t) h <;>\n        first\n          | cases h\n          | exact congr_arg some (inv_eq_of_mul_eq_one_right <| Option.some_injective _ h) }", "start": [606, 1], "end": [619, 93], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length", "code": "def length : \u03b1 :=\n  s.snd - s.fst", "start": [631, 1], "end": [634, 16], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_nonneg", "code": "@[simp]\ntheorem length_nonneg : 0 \u2264 s.length", "start": [637, 1], "end": [639, 32], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_pure", "code": "@[simp]\ntheorem length_pure : (pure a).length = 0", "start": [642, 1], "end": [644, 13], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_zero", "code": "@[simp]\ntheorem length_zero : (0 : NonemptyInterval \u03b1).length = 0", "start": [647, 1], "end": [649, 16], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_neg", "code": "@[simp]\ntheorem length_neg : (-s).length = s.length", "start": [652, 1], "end": [654, 18], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_add", "code": "@[simp]\ntheorem length_add : (s + t).length = s.length + t.length", "start": [657, 1], "end": [659, 27], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_sub", "code": "@[simp]\ntheorem length_sub : (s - t).length = s.length + t.length", "start": [662, 1], "end": [663, 86], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.length_sum", "code": "@[simp]\ntheorem length_sum (f : \u03b9 \u2192 NonemptyInterval \u03b1) (s : Finset \u03b9) :\n    (\u2211 i in s, f i).length = \u2211 i in s, (f i).length", "start": [666, 1], "end": [669, 78], "kind": "commanddeclaration"}, {"full_name": "Interval.length", "code": "def length : Interval \u03b1 \u2192 \u03b1\n  | \u22a5 => 0\n  | (s : NonemptyInterval \u03b1) => s.length", "start": [678, 1], "end": [682, 41], "kind": "commanddeclaration"}, {"full_name": "Interval.length_nonneg", "code": "@[simp]\ntheorem length_nonneg : \u2200 s : Interval \u03b1, 0 \u2264 s.length", "start": [685, 1], "end": [688, 48], "kind": "commanddeclaration"}, {"full_name": "Interval.length_pure", "code": "@[simp]\ntheorem length_pure : (pure a).length = 0", "start": [691, 1], "end": [693, 33], "kind": "commanddeclaration"}, {"full_name": "Interval.length_zero", "code": "@[simp]\ntheorem length_zero : (0 : Interval \u03b1).length = 0", "start": [696, 1], "end": [698, 16], "kind": "commanddeclaration"}, {"full_name": "Interval.length_neg", "code": "@[simp]\ntheorem length_neg : \u2200 s : Interval \u03b1, (-s).length = s.length", "start": [701, 1], "end": [704, 45], "kind": "commanddeclaration"}, {"full_name": "Interval.length_add_le", "code": "theorem length_add_le : \u2200 s t : Interval \u03b1, (s + t).length \u2264 s.length + t.length", "start": [707, 1], "end": [710, 78], "kind": "commanddeclaration"}, {"full_name": "Interval.length_sub_le", "code": "theorem length_sub_le : (s - t).length \u2264 s.length + t.length", "start": [713, 1], "end": [714, 52], "kind": "commanddeclaration"}, {"full_name": "Interval.length_sum_le", "code": "theorem length_sum_le (f : \u03b9 \u2192 Interval \u03b1) (s : Finset \u03b9) :\n    (\u2211 i in s, f i).length \u2264 \u2211 i in s, (f i).length", "start": [717, 1], "end": [722, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNonemptyIntervalLength", "code": "@[positivity NonemptyInterval.length _]\ndef evalNonemptyIntervalLength : PositivityExt where\n  eval {u \u03b1} _ _ e := do\n    let .app (f : Q(NonemptyInterval $\u03b1 \u2192 $\u03b1)) (a : Q(NonemptyInterval $\u03b1)) \u2190\n      withReducible (whnf e) | throwError \"not NonemptyInterval.length\"\n    let _eq : $e =Q $f $a := \u27e8\u27e9\n    let _I \u2190 synthInstanceQ (q(OrderedAddCommGroup $\u03b1) : Q(Type u))\n    assumeInstancesCommute\n    let \u27e8_f_eq\u27e9 \u2190\n      withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(NonemptyInterval.length)\n    return .nonnegative q(NonemptyInterval.length_nonneg $a)", "start": [732, 1], "end": [743, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalIntervalLength", "code": "@[positivity Interval.length _]\ndef evalIntervalLength : PositivityExt where\n  eval {u \u03b1} _ _ e := do\n    let .app (f : Q(Interval $\u03b1 \u2192 $\u03b1)) (a : Q(Interval $\u03b1)) \u2190\n      withReducible (whnf e) | throwError \"not NonemptyInterval.length\"\n    let _eq : $e =Q $f $a := \u27e8\u27e9\n    let _I \u2190 synthInstanceQ (q(OrderedAddCommGroup $\u03b1) : Q(Type u))\n    assumeInstancesCommute\n    let \u27e8_f_eq\u27e9 \u2190\n      withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(Interval.length)\n    return .nonnegative q(Interval.length_nonneg $a)", "start": [745, 1], "end": [756, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Hyperreal.lean", "imports": ["Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Order/Filter/FilterProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Hyperreal", "code": "def Hyperreal : Type :=\n  Germ (hyperfilter \u2115 : Filter \u2115) \u211d deriving Inhabited", "start": [18, 1], "end": [20, 55], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.ofReal", "code": "@[coe] def ofReal : \u211d \u2192 \u211d* := const", "start": [30, 1], "end": [31, 36], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_eq_coe", "code": "@[simp, norm_cast]\ntheorem coe_eq_coe {x y : \u211d} : (x : \u211d*) = y \u2194 x = y", "start": [35, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_ne_coe", "code": "theorem coe_ne_coe {x y : \u211d} : (x : \u211d*) \u2260 y \u2194 x \u2260 y", "start": [40, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_eq_zero {x : \u211d} : (x : \u211d*) = 0 \u2194 x = 0", "start": [44, 1], "end": [46, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_eq_one", "code": "@[simp, norm_cast]\ntheorem coe_eq_one {x : \u211d} : (x : \u211d*) = 1 \u2194 x = 1", "start": [49, 1], "end": [51, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_ne_zero", "code": "@[norm_cast]\ntheorem coe_ne_zero {x : \u211d} : (x : \u211d*) \u2260 0 \u2194 x \u2260 0", "start": [54, 1], "end": [56, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_ne_one", "code": "@[norm_cast]\ntheorem coe_ne_one {x : \u211d} : (x : \u211d*) \u2260 1 \u2194 x \u2260 1", "start": [59, 1], "end": [61, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : \u2191(1 : \u211d) = (1 : \u211d*)", "start": [64, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u2191(0 : \u211d) = (0 : \u211d*)", "start": [69, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv (x : \u211d) : \u2191x\u207b\u00b9 = (x\u207b\u00b9 : \u211d*)", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (x : \u211d) : \u2191(-x) = (-x : \u211d*)", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : \u211d) : \u2191(x + y) = (x + y : \u211d*)", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_ofNat", "code": "@[simp, norm_cast]\ntheorem coe_ofNat (n : \u2115) [n.AtLeastTwo] : ((OfNat.ofNat n : \u211d) : \u211d*) = OfNat.ofNat n", "start": [92, 1], "end": [93, 93], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : \u211d) : \u2191(x * y) = (x * y : \u211d*)", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_div", "code": "@[simp, norm_cast]\ntheorem coe_div (x y : \u211d) : \u2191(x / y) = (x / y : \u211d*)", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (x y : \u211d) : \u2191(x - y) = (x - y : \u211d*)", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {x y : \u211d} : (x : \u211d*) \u2264 y \u2194 x \u2264 y", "start": [110, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe {x y : \u211d} : (x : \u211d*) < y \u2194 x < y", "start": [115, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_nonneg", "code": "@[simp, norm_cast]\ntheorem coe_nonneg {x : \u211d} : 0 \u2264 (x : \u211d*) \u2194 0 \u2264 x", "start": [120, 1], "end": [122, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_pos", "code": "@[simp, norm_cast]\ntheorem coe_pos {x : \u211d} : 0 < (x : \u211d*) \u2194 0 < x", "start": [125, 1], "end": [127, 13], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_abs", "code": "@[simp, norm_cast]\ntheorem coe_abs (x : \u211d) : ((|x| : \u211d) : \u211d*) = |\u2191x|", "start": [130, 1], "end": [132, 14], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max (x y : \u211d) : ((max x y : \u211d) : \u211d*) = max \u2191x \u2191y", "start": [135, 1], "end": [137, 21], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min (x y : \u211d) : ((min x y : \u211d) : \u211d*) = min \u2191x \u2191y", "start": [140, 1], "end": [142, 21], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.ofSeq", "code": "def ofSeq (f : \u2115 \u2192 \u211d) : \u211d* := (\u2191f : Germ (hyperfilter \u2115 : Filter \u2115) \u211d)", "start": [145, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.ofSeq_surjective", "code": "theorem ofSeq_surjective : Function.Surjective ofSeq", "start": [150, 1], "end": [150, 72], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.ofSeq_lt_ofSeq", "code": "theorem ofSeq_lt_ofSeq {f g : \u2115 \u2192 \u211d} : ofSeq f < ofSeq g \u2194 \u2200\u1da0 n in hyperfilter \u2115, f n < g n", "start": [152, 1], "end": [153, 14], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.epsilon", "code": "noncomputable def epsilon : \u211d* :=\n  ofSeq fun n => n\u207b\u00b9", "start": [155, 1], "end": [157, 21], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.omega", "code": "noncomputable def omega : \u211d* := ofSeq Nat.cast", "start": [160, 1], "end": [161, 47], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.inv_omega", "code": "@[simp]\ntheorem inv_omega : \u03c9\u207b\u00b9 = \u03b5", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.inv_epsilon", "code": "@[simp]\ntheorem inv_epsilon : \u03b5\u207b\u00b9 = \u03c9", "start": [172, 1], "end": [174, 17], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.omega_pos", "code": "theorem omega_pos : 0 < \u03c9", "start": [177, 1], "end": [179, 19], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.epsilon_pos", "code": "theorem epsilon_pos : 0 < \u03b5", "start": [182, 1], "end": [183, 27], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.epsilon_ne_zero", "code": "theorem epsilon_ne_zero : \u03b5 \u2260 0", "start": [186, 1], "end": [187, 18], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.omega_ne_zero", "code": "theorem omega_ne_zero : \u03c9 \u2260 0", "start": [190, 1], "end": [191, 16], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.epsilon_mul_omega", "code": "theorem epsilon_mul_omega : \u03b5 * \u03c9 = 1", "start": [194, 1], "end": [195, 38], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.lt_of_tendsto_zero_of_pos", "code": "theorem lt_of_tendsto_zero_of_pos {f : \u2115 \u2192 \u211d} (hf : Tendsto f atTop (\ud835\udcdd 0)) :\n    \u2200 {r : \u211d}, 0 < r \u2192 ofSeq f < (r : \u211d*)", "start": [198, 1], "end": [200, 93], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.neg_lt_of_tendsto_zero_of_pos", "code": "theorem neg_lt_of_tendsto_zero_of_pos {f : \u2115 \u2192 \u211d} (hf : Tendsto f atTop (\ud835\udcdd 0)) :\n    \u2200 {r : \u211d}, 0 < r \u2192 (-r : \u211d*) < ofSeq f", "start": [203, 1], "end": [206, 83], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.gt_of_tendsto_zero_of_neg", "code": "theorem gt_of_tendsto_zero_of_neg {f : \u2115 \u2192 \u211d} (hf : Tendsto f atTop (\ud835\udcdd 0)) :\n    \u2200 {r : \u211d}, r < 0 \u2192 (r : \u211d*) < ofSeq f", "start": [209, 1], "end": [211, 85], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.epsilon_lt_pos", "code": "theorem epsilon_lt_pos (x : \u211d) : 0 < x \u2192 \u03b5 < x", "start": [214, 1], "end": [215, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt", "code": "def IsSt (x : \u211d*) (r : \u211d) :=\n  \u2200 \u03b4 : \u211d, 0 < \u03b4 \u2192 (r - \u03b4 : \u211d*) < x \u2227 x < r + \u03b4", "start": [218, 1], "end": [220, 48], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st", "code": "noncomputable def st : \u211d* \u2192 \u211d := fun x => if h : \u2203 r, IsSt x r then Classical.choose h else 0", "start": [223, 1], "end": [224, 94], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal", "code": "def Infinitesimal (x : \u211d*) :=\n  IsSt x 0", "start": [227, 1], "end": [229, 11], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfinitePos", "code": "def InfinitePos (x : \u211d*) :=\n  \u2200 r : \u211d, \u2191r < x", "start": [232, 1], "end": [234, 18], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfiniteNeg", "code": "def InfiniteNeg (x : \u211d*) :=\n  \u2200 r : \u211d, x < r", "start": [237, 1], "end": [239, 17], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite", "code": "def Infinite (x : \u211d*) :=\n  InfinitePos x \u2228 InfiniteNeg x", "start": [242, 1], "end": [244, 32], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_ofSeq_iff_tendsto", "code": "theorem isSt_ofSeq_iff_tendsto {f : \u2115 \u2192 \u211d} {r : \u211d} :\n    IsSt (ofSeq f) r \u2194 Tendsto f (hyperfilter \u2115) (\ud835\udcdd r)", "start": [251, 1], "end": [254, 50], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_iff_tendsto", "code": "theorem isSt_iff_tendsto {x : \u211d*} {r : \u211d} : IsSt x r \u2194 x.Tendsto (\ud835\udcdd r)", "start": [256, 1], "end": [258, 31], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_of_tendsto", "code": "theorem isSt_of_tendsto {f : \u2115 \u2192 \u211d} {r : \u211d} (hf : Tendsto f atTop (\ud835\udcdd r)) : IsSt (ofSeq f) r", "start": [260, 1], "end": [261, 68], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.lt", "code": "protected theorem IsSt.lt {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) (hrs : r < s) :\n    x < y", "start": [265, 1], "end": [270, 54], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.unique", "code": "theorem IsSt.unique {x : \u211d*} {r s : \u211d} (hr : IsSt x r) (hs : IsSt x s) : r = s", "start": [273, 1], "end": [276, 34], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.st_eq", "code": "theorem IsSt.st_eq {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : st x = r", "start": [279, 1], "end": [282, 45], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.not_infinite", "code": "theorem IsSt.not_infinite {x : \u211d*} {r : \u211d} (h : IsSt x r) : \u00acInfinite x", "start": [285, 1], "end": [287, 42], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_of_exists_st", "code": "theorem not_infinite_of_exists_st {x : \u211d*} : (\u2203 r : \u211d, IsSt x r) \u2192 \u00acInfinite x", "start": [289, 1], "end": [290, 18], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite.st_eq", "code": "theorem Infinite.st_eq {x : \u211d*} (hi : Infinite x) : st x = 0", "start": [293, 1], "end": [294, 47], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_sSup", "code": "theorem isSt_sSup {x : \u211d*} (hni : \u00acInfinite x) : IsSt x (sSup { y : \u211d | (y : \u211d*) < x })", "start": [297, 1], "end": [314, 85], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.exists_st_of_not_infinite", "code": "theorem exists_st_of_not_infinite {x : \u211d*} (hni : \u00acInfinite x) : \u2203 r : \u211d, IsSt x r", "start": [317, 1], "end": [318, 49], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_eq_sSup", "code": "theorem st_eq_sSup {x : \u211d*} : st x = sSup { y : \u211d | (y : \u211d*) < x }", "start": [321, 1], "end": [331, 31], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.exists_st_iff_not_infinite", "code": "theorem exists_st_iff_not_infinite {x : \u211d*} : (\u2203 r : \u211d, IsSt x r) \u2194 \u00acInfinite x", "start": [334, 1], "end": [335, 57], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_iff_not_exists_st", "code": "theorem infinite_iff_not_exists_st {x : \u211d*} : Infinite x \u2194 \u00ac\u2203 r : \u211d, IsSt x r", "start": [338, 1], "end": [339, 45], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.isSt_st", "code": "theorem IsSt.isSt_st {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : IsSt x (st x)", "start": [342, 1], "end": [343, 18], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_st_of_exists_st", "code": "theorem isSt_st_of_exists_st {x : \u211d*} (hx : \u2203 r : \u211d, IsSt x r) : IsSt x (st x)", "start": [346, 1], "end": [347, 33], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_st'", "code": "theorem isSt_st' {x : \u211d*} (hx : \u00acInfinite x) : IsSt x (st x)", "start": [350, 1], "end": [351, 25], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_st", "code": "theorem isSt_st {x : \u211d*} (hx : st x \u2260 0) : IsSt x (st x)", "start": [354, 1], "end": [355, 35], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_refl_real", "code": "theorem isSt_refl_real (r : \u211d) : IsSt r r", "start": [358, 1], "end": [358, 89], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_id_real", "code": "theorem st_id_real (r : \u211d) : st r = r", "start": [361, 1], "end": [361, 66], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.eq_of_isSt_real", "code": "theorem eq_of_isSt_real {r s : \u211d} : IsSt r s \u2192 r = s", "start": [364, 1], "end": [365, 28], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_real_iff_eq", "code": "theorem isSt_real_iff_eq {r s : \u211d} : IsSt r s \u2194 r = s", "start": [368, 1], "end": [369, 55], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_symm_real", "code": "theorem isSt_symm_real {r s : \u211d} : IsSt r s \u2194 IsSt s r", "start": [372, 1], "end": [373, 51], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_trans_real", "code": "theorem isSt_trans_real {r s t : \u211d} : IsSt r s \u2192 IsSt s t \u2192 IsSt r t", "start": [376, 1], "end": [377, 76], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_inj_real", "code": "theorem isSt_inj_real {r\u2081 r\u2082 s : \u211d} (h1 : IsSt r\u2081 s) (h2 : IsSt r\u2082 s) : r\u2081 = r\u2082", "start": [380, 1], "end": [381, 58], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.isSt_iff_abs_sub_lt_delta", "code": "theorem isSt_iff_abs_sub_lt_delta {x : \u211d*} {r : \u211d} : IsSt x r \u2194 \u2200 \u03b4 : \u211d, 0 < \u03b4 \u2192 |x - \u2191r| < \u03b4", "start": [384, 1], "end": [385, 74], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.map", "code": "theorem IsSt.map {x : \u211d*} {r : \u211d} (hxr : IsSt x r) {f : \u211d \u2192 \u211d} (hf : ContinuousAt f r) :\n    IsSt (x.map f) (f r)", "start": [388, 1], "end": [391, 83], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.map\u2082", "code": "theorem IsSt.map\u2082 {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) {f : \u211d \u2192 \u211d \u2192 \u211d}\n    (hf : ContinuousAt (Function.uncurry f) (r, s)) : IsSt (x.map\u2082 f y) (f r s)", "start": [393, 1], "end": [398, 75], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.add", "code": "theorem IsSt.add {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) :\n    IsSt (x + y) (r + s)", "start": [400, 1], "end": [401, 69], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.neg", "code": "theorem IsSt.neg {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : IsSt (-x) (-r)", "start": [404, 1], "end": [405, 38], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.sub", "code": "theorem IsSt.sub {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) : IsSt (x - y) (r - s)", "start": [408, 1], "end": [409, 43], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.le", "code": "theorem IsSt.le {x y : \u211d*} {r s : \u211d} (hrx : IsSt x r) (hsy : IsSt y s) (hxy : x \u2264 y) : r \u2264 s", "start": [412, 1], "end": [413, 49], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_le_of_le", "code": "theorem st_le_of_le {x y : \u211d*} (hix : \u00acInfinite x) (hiy : \u00acInfinite y) : x \u2264 y \u2192 st x \u2264 st y", "start": [416, 1], "end": [417, 35], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.lt_of_st_lt", "code": "theorem lt_of_st_lt {x y : \u211d*} (hix : \u00acInfinite x) (hiy : \u00acInfinite y) : st x < st y \u2192 x < y", "start": [420, 1], "end": [421, 35], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_def", "code": "theorem infinitePos_def {x : \u211d*} : InfinitePos x \u2194 \u2200 r : \u211d, \u2191r < x", "start": [428, 1], "end": [428, 78], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_def", "code": "theorem infiniteNeg_def {x : \u211d*} : InfiniteNeg x \u2194 \u2200 r : \u211d, x < r", "start": [431, 1], "end": [431, 77], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfinitePos.pos", "code": "theorem InfinitePos.pos {x : \u211d*} (hip : InfinitePos x) : 0 < x", "start": [434, 1], "end": [434, 72], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfiniteNeg.lt_zero", "code": "theorem InfiniteNeg.lt_zero {x : \u211d*} : InfiniteNeg x \u2192 x < 0", "start": [437, 1], "end": [437, 81], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite.ne_zero", "code": "theorem Infinite.ne_zero {x : \u211d*} (hI : Infinite x) : x \u2260 0", "start": [440, 1], "end": [441, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_zero", "code": "theorem not_infinite_zero : \u00acInfinite 0", "start": [444, 1], "end": [444, 68], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfiniteNeg.not_infinitePos", "code": "theorem InfiniteNeg.not_infinitePos {x : \u211d*} : InfiniteNeg x \u2192 \u00acInfinitePos x", "start": [447, 1], "end": [448, 23], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfinitePos.not_infiniteNeg", "code": "theorem InfinitePos.not_infiniteNeg {x : \u211d*} (hp : InfinitePos x) : \u00acInfiniteNeg x", "start": [451, 1], "end": [452, 24], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfinitePos.neg", "code": "theorem InfinitePos.neg {x : \u211d*} : InfinitePos x \u2192 InfiniteNeg (-x)", "start": [455, 1], "end": [456, 22], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfiniteNeg.neg", "code": "theorem InfiniteNeg.neg {x : \u211d*} : InfiniteNeg x \u2192 InfinitePos (-x)", "start": [459, 1], "end": [460, 22], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_neg", "code": "@[simp] theorem infiniteNeg_neg {x : \u211d*} : InfiniteNeg (-x) \u2194 InfinitePos x", "start": [464, 1], "end": [465, 52], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_neg", "code": "@[simp] theorem infinitePos_neg {x : \u211d*} : InfinitePos (-x) \u2194 InfiniteNeg x", "start": [469, 1], "end": [470, 52], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_neg", "code": "@[simp] theorem infinite_neg {x : \u211d*} : Infinite (-x) \u2194 Infinite x", "start": [474, 1], "end": [475, 54], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal.not_infinite", "code": "nonrec theorem Infinitesimal.not_infinite {x : \u211d*} (h : Infinitesimal x) : \u00acInfinite x", "start": [478, 1], "end": [479, 17], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite.not_infinitesimal", "code": "theorem Infinite.not_infinitesimal {x : \u211d*} (h : Infinite x) : \u00acInfinitesimal x", "start": [482, 1], "end": [483, 20], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfinitePos.not_infinitesimal", "code": "theorem InfinitePos.not_infinitesimal {x : \u211d*} (h : InfinitePos x) : \u00acInfinitesimal x", "start": [486, 1], "end": [487, 40], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.InfiniteNeg.not_infinitesimal", "code": "theorem InfiniteNeg.not_infinitesimal {x : \u211d*} (h : InfiniteNeg x) : \u00acInfinitesimal x", "start": [490, 1], "end": [491, 40], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_iff_infinite_and_pos", "code": "theorem infinitePos_iff_infinite_and_pos {x : \u211d*} : InfinitePos x \u2194 Infinite x \u2227 0 < x", "start": [494, 1], "end": [496, 81], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_iff_infinite_and_neg", "code": "theorem infiniteNeg_iff_infinite_and_neg {x : \u211d*} : InfiniteNeg x \u2194 Infinite x \u2227 x < 0", "start": [499, 1], "end": [501, 81], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_iff_infinite_of_nonneg", "code": "theorem infinitePos_iff_infinite_of_nonneg {x : \u211d*} (hp : 0 \u2264 x) : InfinitePos x \u2194 Infinite x", "start": [504, 1], "end": [505, 51], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_iff_infinite_of_pos", "code": "theorem infinitePos_iff_infinite_of_pos {x : \u211d*} (hp : 0 < x) : InfinitePos x \u2194 Infinite x", "start": [508, 1], "end": [509, 43], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_iff_infinite_of_neg", "code": "theorem infiniteNeg_iff_infinite_of_neg {x : \u211d*} (hn : x < 0) : InfiniteNeg x \u2194 Infinite x", "start": [512, 1], "end": [513, 48], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_abs_iff_infinite_abs", "code": "theorem infinitePos_abs_iff_infinite_abs {x : \u211d*} : InfinitePos |x| \u2194 Infinite |x|", "start": [516, 1], "end": [517, 52], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_abs_iff", "code": "@[simp] theorem infinite_abs_iff {x : \u211d*} : Infinite |x| \u2194 Infinite x", "start": [521, 1], "end": [522, 78], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_abs_iff_infinite", "code": "@[simp] theorem infinitePos_abs_iff_infinite {x : \u211d*} : InfinitePos |x| \u2194 Infinite x", "start": [526, 1], "end": [527, 58], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_iff_abs_lt_abs", "code": "theorem infinite_iff_abs_lt_abs {x : \u211d*} : Infinite x \u2194 \u2200 r : \u211d, (|r| : \u211d*) < |x|", "start": [530, 1], "end": [532, 37], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_add_not_infiniteNeg", "code": "theorem infinitePos_add_not_infiniteNeg {x y : \u211d*} :\n    InfinitePos x \u2192 \u00acInfiniteNeg y \u2192 InfinitePos (x + y)", "start": [535, 1], "end": [540, 7], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infiniteNeg_add_infinitePos", "code": "theorem not_infiniteNeg_add_infinitePos {x y : \u211d*} :\n    \u00acInfiniteNeg x \u2192 InfinitePos y \u2192 InfinitePos (x + y)", "start": [543, 1], "end": [545, 55], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_add_not_infinitePos", "code": "theorem infiniteNeg_add_not_infinitePos {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinitePos y \u2192 InfiniteNeg (x + y)", "start": [548, 1], "end": [551, 40], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinitePos_add_infiniteNeg", "code": "theorem not_infinitePos_add_infiniteNeg {x y : \u211d*} :\n    \u00acInfinitePos x \u2192 InfiniteNeg y \u2192 InfiniteNeg (x + y)", "start": [554, 1], "end": [556, 55], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_add_infinitePos", "code": "theorem infinitePos_add_infinitePos {x y : \u211d*} :\n    InfinitePos x \u2192 InfinitePos y \u2192 InfinitePos (x + y)", "start": [559, 1], "end": [561, 56], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_add_infiniteNeg", "code": "theorem infiniteNeg_add_infiniteNeg {x y : \u211d*} :\n    InfiniteNeg x \u2192 InfiniteNeg y \u2192 InfiniteNeg (x + y)", "start": [564, 1], "end": [566, 56], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_add_not_infinite", "code": "theorem infinitePos_add_not_infinite {x y : \u211d*} :\n    InfinitePos x \u2192 \u00acInfinite y \u2192 InfinitePos (x + y)", "start": [569, 1], "end": [571, 54], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_add_not_infinite", "code": "theorem infiniteNeg_add_not_infinite {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinite y \u2192 InfiniteNeg (x + y)", "start": [574, 1], "end": [576, 54], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_of_tendsto_top", "code": "theorem infinitePos_of_tendsto_top {f : \u2115 \u2192 \u211d} (hf : Tendsto f atTop atTop) :\n    InfinitePos (ofSeq f)", "start": [579, 1], "end": [587, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_of_tendsto_bot", "code": "theorem infiniteNeg_of_tendsto_bot {f : \u2115 \u2192 \u211d} (hf : Tendsto f atTop atBot) :\n    InfiniteNeg (ofSeq f)", "start": [590, 1], "end": [598, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_neg", "code": "theorem not_infinite_neg {x : \u211d*} : \u00acInfinite x \u2192 \u00acInfinite (-x)", "start": [601, 1], "end": [601, 87], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_add", "code": "theorem not_infinite_add {x y : \u211d*} (hx : \u00acInfinite x) (hy : \u00acInfinite y) : \u00acInfinite (x + y)", "start": [604, 1], "end": [607, 50], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_iff_exist_lt_gt", "code": "theorem not_infinite_iff_exist_lt_gt {x : \u211d*} : \u00acInfinite x \u2194 \u2203 r s : \u211d, (r : \u211d*) < x \u2227 x < s", "start": [610, 1], "end": [612, 93], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_real", "code": "theorem not_infinite_real (r : \u211d) : \u00acInfinite r", "start": [615, 1], "end": [617, 83], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite.ne_real", "code": "theorem Infinite.ne_real {x : \u211d*} : Infinite x \u2192 \u2200 r : \u211d, x \u2260 r", "start": [620, 1], "end": [621, 56], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.mul", "code": "theorem IsSt.mul {x y : \u211d*} {r s : \u211d} (hxr : IsSt x r) (hys : IsSt y s) : IsSt (x * y) (r * s)", "start": [628, 1], "end": [629, 43], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_infinite_mul", "code": "theorem not_infinite_mul {x y : \u211d*} (hx : \u00acInfinite x) (hy : \u00acInfinite y) : \u00acInfinite (x * y)", "start": [633, 1], "end": [636, 27], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_add", "code": "theorem st_add {x y : \u211d*} (hx : \u00acInfinite x) (hy : \u00acInfinite y) : st (x + y) = st x + st y", "start": [640, 1], "end": [641, 79], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_neg", "code": "theorem st_neg (x : \u211d*) : st (-x) = -st x", "start": [644, 1], "end": [647, 63], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_mul", "code": "theorem st_mul {x y : \u211d*} (hx : \u00acInfinite x) (hy : \u00acInfinite y) : st (x * y) = st x * st y", "start": [650, 1], "end": [654, 27], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_def", "code": "theorem infinitesimal_def {x : \u211d*} : Infinitesimal x \u2194 \u2200 r : \u211d, 0 < r \u2192 -(r : \u211d*) < x \u2227 x < r", "start": [661, 1], "end": [662, 29], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.lt_of_pos_of_infinitesimal", "code": "theorem lt_of_pos_of_infinitesimal {x : \u211d*} : Infinitesimal x \u2192 \u2200 r : \u211d, 0 < r \u2192 x < r", "start": [665, 1], "end": [666, 52], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.lt_neg_of_pos_of_infinitesimal", "code": "theorem lt_neg_of_pos_of_infinitesimal {x : \u211d*} : Infinitesimal x \u2192 \u2200 r : \u211d, 0 < r \u2192 -\u2191r < x", "start": [669, 1], "end": [670, 52], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.gt_of_neg_of_infinitesimal", "code": "theorem gt_of_neg_of_infinitesimal {x : \u211d*} (hi : Infinitesimal x) (r : \u211d) (hr : r < 0) : \u2191r < x", "start": [673, 1], "end": [674, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.abs_lt_real_iff_infinitesimal", "code": "theorem abs_lt_real_iff_infinitesimal {x : \u211d*} : Infinitesimal x \u2194 \u2200 r : \u211d, r \u2260 0 \u2192 |x| < |\u2191r|", "start": [677, 1], "end": [679, 98], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_zero", "code": "theorem infinitesimal_zero : Infinitesimal 0", "start": [682, 1], "end": [682, 65], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal.eq_zero", "code": "theorem Infinitesimal.eq_zero {r : \u211d} : Infinitesimal r \u2192 r = 0", "start": [685, 1], "end": [685, 83], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_real_iff", "code": "@[simp] theorem infinitesimal_real_iff {r : \u211d} : Infinitesimal r \u2194 r = 0", "start": [689, 1], "end": [690, 19], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal.add", "code": "nonrec theorem Infinitesimal.add {x y : \u211d*} (hx : Infinitesimal x) (hy : Infinitesimal y) :\n    Infinitesimal (x + y)", "start": [693, 1], "end": [694, 70], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal.neg", "code": "nonrec theorem Infinitesimal.neg {x : \u211d*} (hx : Infinitesimal x) : Infinitesimal (-x)", "start": [697, 1], "end": [698, 37], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_neg", "code": "@[simp] theorem infinitesimal_neg {x : \u211d*} : Infinitesimal (-x) \u2194 Infinitesimal x", "start": [702, 1], "end": [703, 50], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinitesimal.mul", "code": "nonrec theorem Infinitesimal.mul {x y : \u211d*} (hx : Infinitesimal x) (hy : Infinitesimal y) :\n    Infinitesimal (x * y)", "start": [706, 1], "end": [707, 70], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_of_tendsto_zero", "code": "theorem infinitesimal_of_tendsto_zero {f : \u2115 \u2192 \u211d} (h : Tendsto f atTop (\ud835\udcdd 0)) :\n    Infinitesimal (ofSeq f)", "start": [710, 1], "end": [712, 20], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_epsilon", "code": "theorem infinitesimal_epsilon : Infinitesimal \u03b5", "start": [715, 1], "end": [716, 65], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.not_real_of_infinitesimal_ne_zero", "code": "theorem not_real_of_infinitesimal_ne_zero (x : \u211d*) : Infinitesimal x \u2192 x \u2260 0 \u2192 \u2200 r : \u211d, x \u2260 r", "start": [719, 1], "end": [721, 92], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.infinitesimal_sub", "code": "theorem IsSt.infinitesimal_sub {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : Infinitesimal (x - \u2191r)", "start": [724, 1], "end": [725, 57], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_sub_st", "code": "theorem infinitesimal_sub_st {x : \u211d*} (hx : \u00acInfinite x) : Infinitesimal (x - \u2191(st x))", "start": [728, 1], "end": [729, 34], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_iff_infinitesimal_inv_pos", "code": "theorem infinitePos_iff_infinitesimal_inv_pos {x : \u211d*} :\n    InfinitePos x \u2194 Infinitesimal x\u207b\u00b9 \u2227 0 < x\u207b\u00b9", "start": [732, 1], "end": [743, 74], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_iff_infinitesimal_inv_neg", "code": "theorem infiniteNeg_iff_infinitesimal_inv_neg {x : \u211d*} :\n    InfiniteNeg x \u2194 Infinitesimal x\u207b\u00b9 \u2227 x\u207b\u00b9 < 0", "start": [746, 1], "end": [748, 101], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_inv_of_infinite", "code": "theorem infinitesimal_inv_of_infinite {x : \u211d*} : Infinite x \u2192 Infinitesimal x\u207b\u00b9", "start": [751, 1], "end": [753, 53], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_of_infinitesimal_inv", "code": "theorem infinite_of_infinitesimal_inv {x : \u211d*} (h0 : x \u2260 0) (hi : Infinitesimal x\u207b\u00b9) :\n    Infinite x", "start": [756, 1], "end": [760, 82], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_iff_infinitesimal_inv", "code": "theorem infinite_iff_infinitesimal_inv {x : \u211d*} (h0 : x \u2260 0) : Infinite x \u2194 Infinitesimal x\u207b\u00b9", "start": [763, 1], "end": [764, 68], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_pos_iff_infinitePos_inv", "code": "theorem infinitesimal_pos_iff_infinitePos_inv {x : \u211d*} :\n    InfinitePos x\u207b\u00b9 \u2194 Infinitesimal x \u2227 0 < x", "start": [767, 1], "end": [769, 65], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_neg_iff_infiniteNeg_inv", "code": "theorem infinitesimal_neg_iff_infiniteNeg_inv {x : \u211d*} :\n    InfiniteNeg x\u207b\u00b9 \u2194 Infinitesimal x \u2227 x < 0", "start": [772, 1], "end": [774, 65], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitesimal_iff_infinite_inv", "code": "theorem infinitesimal_iff_infinite_inv {x : \u211d*} (h : x \u2260 0) : Infinitesimal x \u2194 Infinite x\u207b\u00b9", "start": [777, 1], "end": [778, 84], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.IsSt.inv", "code": "theorem IsSt.inv {x : \u211d*} {r : \u211d} (hi : \u00acInfinitesimal x) (hr : IsSt x r) : IsSt x\u207b\u00b9 r\u207b\u00b9", "start": [785, 1], "end": [786, 60], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.st_inv", "code": "theorem st_inv (x : \u211d*) : st x\u207b\u00b9 = (st x)\u207b\u00b9", "start": [789, 1], "end": [796, 37], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_omega", "code": "theorem infinitePos_omega : InfinitePos \u03c9", "start": [803, 1], "end": [804, 81], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_omega", "code": "theorem infinite_omega : Infinite \u03c9", "start": [807, 1], "end": [808, 75], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_of_infinitePos_not_infinitesimal_pos", "code": "theorem infinitePos_mul_of_infinitePos_not_infinitesimal_pos {x y : \u211d*} :\n    InfinitePos x \u2192 \u00acInfinitesimal y \u2192 0 < y \u2192 InfinitePos (x * y)", "start": [811, 1], "end": [818, 78], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_of_not_infinitesimal_pos_infinitePos", "code": "theorem infinitePos_mul_of_not_infinitesimal_pos_infinitePos {x y : \u211d*} :\n    \u00acInfinitesimal x \u2192 0 < x \u2192 InfinitePos y \u2192 InfinitePos (x * y)", "start": [821, 1], "end": [823, 79], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg", "code": "theorem infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinitesimal y \u2192 y < 0 \u2192 InfinitePos (x * y)", "start": [826, 1], "end": [829, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_of_not_infinitesimal_neg_infiniteNeg", "code": "theorem infinitePos_mul_of_not_infinitesimal_neg_infiniteNeg {x y : \u211d*} :\n    \u00acInfinitesimal x \u2192 x < 0 \u2192 InfiniteNeg y \u2192 InfinitePos (x * y)", "start": [832, 1], "end": [834, 79], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_of_infinitePos_not_infinitesimal_neg", "code": "theorem infiniteNeg_mul_of_infinitePos_not_infinitesimal_neg {x y : \u211d*} :\n    InfinitePos x \u2192 \u00acInfinitesimal y \u2192 y < 0 \u2192 InfiniteNeg (x * y)", "start": [837, 1], "end": [840, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_of_not_infinitesimal_neg_infinitePos", "code": "theorem infiniteNeg_mul_of_not_infinitesimal_neg_infinitePos {x y : \u211d*} :\n    \u00acInfinitesimal x \u2192 x < 0 \u2192 InfinitePos y \u2192 InfiniteNeg (x * y)", "start": [843, 1], "end": [845, 79], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_of_infiniteNeg_not_infinitesimal_pos", "code": "theorem infiniteNeg_mul_of_infiniteNeg_not_infinitesimal_pos {x y : \u211d*} :\n    InfiniteNeg x \u2192 \u00acInfinitesimal y \u2192 0 < y \u2192 InfiniteNeg (x * y)", "start": [848, 1], "end": [851, 61], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_of_not_infinitesimal_pos_infiniteNeg", "code": "theorem infiniteNeg_mul_of_not_infinitesimal_pos_infiniteNeg {x y : \u211d*} :\n    \u00acInfinitesimal x \u2192 0 < x \u2192 InfiniteNeg y \u2192 InfiniteNeg (x * y)", "start": [854, 1], "end": [856, 85], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_infinitePos", "code": "theorem infinitePos_mul_infinitePos {x y : \u211d*} :\n    InfinitePos x \u2192 InfinitePos y \u2192 InfinitePos (x * y)", "start": [859, 1], "end": [861, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_infiniteNeg", "code": "theorem infiniteNeg_mul_infiniteNeg {x y : \u211d*} :\n    InfiniteNeg x \u2192 InfiniteNeg y \u2192 InfinitePos (x * y)", "start": [864, 1], "end": [866, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinitePos_mul_infiniteNeg", "code": "theorem infinitePos_mul_infiniteNeg {x y : \u211d*} :\n    InfinitePos x \u2192 InfiniteNeg y \u2192 InfiniteNeg (x * y)", "start": [869, 1], "end": [871, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infiniteNeg_mul_infinitePos", "code": "theorem infiniteNeg_mul_infinitePos {x y : \u211d*} :\n    InfiniteNeg x \u2192 InfinitePos y \u2192 InfiniteNeg (x * y)", "start": [874, 1], "end": [876, 86], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_mul_of_infinite_not_infinitesimal", "code": "theorem infinite_mul_of_infinite_not_infinitesimal {x y : \u211d*} :\n    Infinite x \u2192 \u00acInfinitesimal y \u2192 Infinite (x * y)", "start": [879, 1], "end": [888, 91], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.infinite_mul_of_not_infinitesimal_infinite", "code": "theorem infinite_mul_of_not_infinitesimal_infinite {x y : \u211d*} :\n    \u00acInfinitesimal x \u2192 Infinite y \u2192 Infinite (x * y)", "start": [891, 1], "end": [893, 72], "kind": "commanddeclaration"}, {"full_name": "Hyperreal.Infinite.mul", "code": "theorem Infinite.mul {x y : \u211d*} : Infinite x \u2192 Infinite y \u2192 Infinite (x * y)", "start": [896, 1], "end": [897, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/OmegaCompletePartialOrder.lean", "imports": ["Mathlib/Order/OmegaCompletePartialOrder.lean", "Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean"], "premises": [{"full_name": "\u03c9CPO", "code": "def \u03c9CPO : Type (u + 1) :=\n  Bundled OmegaCompletePartialOrder", "start": [35, 1], "end": [37, 36], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.of", "code": "def of (\u03b1 : Type*) [OmegaCompletePartialOrder \u03b1] : \u03c9CPO :=\n  Bundled.of \u03b1", "start": [57, 1], "end": [59, 15], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [OmegaCompletePartialOrder \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.HasProducts.product", "code": "def product {J : Type v} (f : J \u2192 \u03c9CPO.{v}) : Fan f :=\n  Fan.mk (of (\u2200 j, f j)) fun j => .mk (Pi.evalOrderHom j) fun _ => rfl", "start": [79, 1], "end": [81, 71], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.HasProducts.isProduct", "code": "def isProduct (J : Type v) (f : J \u2192 \u03c9CPO) : IsLimit (product f) where\n  lift s :=\n    \u27e8\u27e8fun t j => (s.\u03c0.app \u27e8j\u27e9).toFun t, fun x y h j => (s.\u03c0.app \u27e8j\u27e9).monotone h\u27e9,\n      fun x => funext fun j => (s.\u03c0.app \u27e8j\u27e9).continuous x\u27e9\n  uniq s m w := by\n    ext t; funext j change m.toFun t j = (s.\u03c0.app \u27e8j\u27e9).toFun t\n    rw [\u2190 w \u27e8j\u27e9]\n    rfl\n  fac s j := rfl", "start": [84, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.omegaCompletePartialOrderEqualizer", "code": "instance omegaCompletePartialOrderEqualizer {\u03b1 \u03b2 : Type*} [OmegaCompletePartialOrder \u03b1]\n    [OmegaCompletePartialOrder \u03b2] (f g : \u03b1 \u2192\ud835\udc84 \u03b2) :\n    OmegaCompletePartialOrder { a : \u03b1 // f a = g a } :=\n  OmegaCompletePartialOrder.subtype _ fun c hc => by\n    rw [f.continuous, g.continuous]\n    congr 1\n    apply OrderHom.ext; funext x apply hc _ \u27e8_, rfl\u27e9", "start": [103, 1], "end": [110, 24], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.HasEqualizers.equalizer\u03b9", "code": "def equalizer\u03b9 {\u03b1 \u03b2 : Type*} [OmegaCompletePartialOrder \u03b1] [OmegaCompletePartialOrder \u03b2]\n    (f g : \u03b1 \u2192\ud835\udc84 \u03b2) : { a : \u03b1 // f a = g a } \u2192\ud835\udc84 \u03b1 :=\n  .mk (OrderHom.Subtype.val _) fun _ => rfl", "start": [115, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.HasEqualizers.equalizer", "code": "def equalizer {X Y : \u03c9CPO.{v}} (f g : X \u27f6 Y) : Fork f g :=\n  Fork.of\u03b9 (P := \u03c9CPO.of { a // f.toFun a = g.toFun a }) (equalizer\u03b9 f g)\n    (ContinuousHom.ext _ _ fun x => x.2)", "start": [121, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "\u03c9CPO.HasEqualizers.isEqualizer", "code": "def isEqualizer {X Y : \u03c9CPO.{v}} (f g : X \u27f6 Y) : IsLimit (equalizer f g) :=\n  Fork.IsLimit.mk' _ fun s =>\n    \u27e8{  toFun := fun x => \u27e8s.\u03b9.toFun x, by apply ContinuousHom.congr_fun s.condition\u27e9\n        monotone' := fun x y h => s.\u03b9.monotone h\n        cont := fun x => Subtype.ext (s.\u03b9.continuous x) }, by ext; rfl, fun hm => by\n      apply ContinuousHom.ext _ _ fun x => Subtype.ext ?_ apply ContinuousHom.congr_fun hm\u27e9", "start": [128, 1], "end": [136, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/DedekindDomain/FiniteAdeleRing.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/AdicValuation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DedekindDomain.FiniteIntegralAdeles", "code": "def FiniteIntegralAdeles : Type _ :=\n  \u2200 v : HeightOneSpectrum R, v.adicCompletionIntegers K", "start": [43, 1], "end": [45, 56], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions", "code": "def ProdAdicCompletions :=\n  \u2200 v : HeightOneSpectrum R, v.adicCompletion K", "start": [65, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.FiniteIntegralAdeles.coe_apply", "code": "theorem coe_apply (x : R_hat R K) (v : HeightOneSpectrum R) : (x : K_hat R K) v = \u2191(x v)", "start": [96, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.FiniteIntegralAdeles.Coe.addMonoidHom", "code": "@[simps]\ndef Coe.addMonoidHom : AddMonoidHom (R_hat R K) (K_hat R K) where\n  toFun := (\u2191)\n  map_zero' := rfl\n  map_add' x y := by\n    refine funext fun v => ?_\n    simp only [coe_apply, Pi.add_apply, Subring.coe_add]\n    erw [Pi.add_apply, Pi.add_apply, Subring.coe_add]", "start": [100, 1], "end": [110, 54], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.FiniteIntegralAdeles.Coe.ringHom", "code": "@[simps]\ndef Coe.ringHom : RingHom (R_hat R K) (K_hat R K) :=\n  { Coe.addMonoidHom R K with\n    toFun := (\u2191)\n    map_one' := rfl\n    map_mul' := fun x y => by\n      refine funext fun p => ?_\n      simp only [Pi.mul_apply, Subring.coe_mul]\n      erw [Pi.mul_apply, Pi.mul_apply, Subring.coe_mul] }", "start": [113, 1], "end": [124, 58], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.algebra'", "code": "instance ProdAdicCompletions.algebra' : Algebra R (K_hat R K) :=\n  (by infer_instance : Algebra R <| \u2200 v : HeightOneSpectrum R, v.adicCompletion K)", "start": [134, 1], "end": [135, 83], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.algebraCompletions", "code": "instance ProdAdicCompletions.algebraCompletions : Algebra (R_hat R K) (K_hat R K) :=\n  (FiniteIntegralAdeles.Coe.ringHom R K).toAlgebra", "start": [144, 1], "end": [145, 51], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.isScalarTower_completions", "code": "instance ProdAdicCompletions.isScalarTower_completions : IsScalarTower R (R_hat R K) (K_hat R K) :=\n  (by infer_instance :\n    IsScalarTower R (\u2200 v : HeightOneSpectrum R, v.adicCompletionIntegers K) <|\n      \u2200 v : HeightOneSpectrum R, v.adicCompletion K)", "start": [148, 1], "end": [151, 53], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.FiniteIntegralAdeles.Coe.algHom", "code": "def Coe.algHom : AlgHom R (R_hat R K) (K_hat R K) :=\n  { Coe.ringHom R K with\n    toFun := (\u2191)\n    commutes' := fun _ => rfl }", "start": [158, 1], "end": [162, 32], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.FiniteIntegralAdeles.Coe.algHom_apply", "code": "theorem Coe.algHom_apply (x : R_hat R K) (v : HeightOneSpectrum R) : (Coe.algHom R K) x v = x v", "start": [165, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele", "code": "def IsFiniteAdele (x : K_hat R K) :=\n  \u2200\u1da0 v : HeightOneSpectrum R in Filter.cofinite, x v \u2208 v.adicCompletionIntegers K", "start": [181, 1], "end": [184, 82], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.add", "code": "theorem add {x y : K_hat R K} (hx : x.IsFiniteAdele) (hy : y.IsFiniteAdele) :\n    (x + y).IsFiniteAdele", "start": [189, 1], "end": [204, 38], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.zero", "code": "theorem zero : (0 : K_hat R K).IsFiniteAdele", "start": [207, 1], "end": [218, 23], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.neg", "code": "theorem neg {x : K_hat R K} (hx : x.IsFiniteAdele) : (-x).IsFiniteAdele", "start": [221, 1], "end": [231, 14], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul", "code": "theorem mul {x y : K_hat R K} (hx : x.IsFiniteAdele) (hy : y.IsFiniteAdele) :\n    (x * y).IsFiniteAdele", "start": [234, 1], "end": [253, 38], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.ProdAdicCompletions.IsFiniteAdele.one", "code": "theorem one : (1 : K_hat R K).IsFiniteAdele", "start": [256, 1], "end": [265, 23], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.finiteAdeleRing", "code": "noncomputable def finiteAdeleRing : Subring (K_hat R K) where\n  carrier := {x : K_hat R K | x.IsFiniteAdele}\n  mul_mem' hx hy := mul hx hy\n  one_mem' := one\n  add_mem' hx hy := add hx hy\n  zero_mem' := zero\n  neg_mem' hx := neg hx", "start": [274, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "DedekindDomain.mem_finiteAdeleRing_iff", "code": "@[simp]\ntheorem mem_finiteAdeleRing_iff (x : K_hat R K) : x \u2208 finiteAdeleRing R K \u2194 x.IsFiniteAdele", "start": [287, 1], "end": [289, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ZMod/Coprime.lean", "imports": ["Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZMod.eq_zero_iff_gcd_ne_one", "code": "theorem eq_zero_iff_gcd_ne_one {a : \u2124} {p : \u2115} [pp : Fact p.Prime] :\n    (a : ZMod p) = 0 \u2194 a.gcd p \u2260 1", "start": [21, 1], "end": [27, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.ne_zero_of_gcd_eq_one", "code": "theorem ne_zero_of_gcd_eq_one {a : \u2124} {p : \u2115} (pp : p.Prime) (h : a.gcd p = 1) : (a : ZMod p) \u2260 0", "start": [30, 1], "end": [32, 69], "kind": "commanddeclaration"}, {"full_name": "ZMod.eq_zero_of_gcd_ne_one", "code": "theorem eq_zero_of_gcd_ne_one {a : \u2124} {p : \u2115} (pp : p.Prime) (h : a.gcd p \u2260 1) : (a : ZMod p) = 0", "start": [35, 1], "end": [37, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/GradedModule.lean", "imports": ["Mathlib/Algebra/DirectSum/Decomposition.lean", "Mathlib/Algebra/GradedMulAction.lean", "Mathlib/Algebra/Module/BigOperators.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/GradedAlgebra/Basic.lean"], "premises": [{"full_name": "DirectSum.GdistribMulAction", "code": "class GdistribMulAction [AddMonoid \u03b9A] [VAdd \u03b9A \u03b9B] [GMonoid A] [\u2200 i, AddMonoid (M i)]\n    extends GMulAction A M where\n  smul_add {i j} (a : A i) (b c : M j) : smul a (b + c) = smul a b + smul a c\n  smul_zero {i j} (a : A i) : smul a (0 : M j) = 0", "start": [36, 1], "end": [40, 51], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule", "code": "class Gmodule [AddMonoid \u03b9A] [VAdd \u03b9A \u03b9B] [\u2200 i, AddMonoid (A i)] [\u2200 i, AddMonoid (M i)] [GMonoid A]\n    extends GdistribMulAction A M where\n  add_smul {i j} (a a' : A i) (b : M j) : smul (a + a') b = smul a b + smul a' b\n  zero_smul {i j} (b : M j) : smul (0 : A i) b = 0", "start": [43, 1], "end": [47, 51], "kind": "commanddeclaration"}, {"full_name": "DirectSum.GSemiring.toGmodule", "code": "instance GSemiring.toGmodule [AddMonoid \u03b9A] [\u2200 i : \u03b9A, AddCommMonoid (A i)]\n    [h : GSemiring A] : Gmodule A A :=\n  { GMonoid.toGMulAction A with\n    smul_add := fun _ _ _ => h.mul_add _ _ _\n    smul_zero := fun _ => h.mul_zero _\n    add_smul := fun _ _ => h.add_mul _ _\n    zero_smul := fun _ => h.zero_mul _ }", "start": [50, 1], "end": [57, 41], "kind": "commanddeclaration"}, {"full_name": "DirectSum.gsmulHom", "code": "@[simps]\ndef gsmulHom [GMonoid A] [Gmodule A M] {i j} : A i \u2192+ M j \u2192+ M (i +\u1d65 j) where\n  toFun a :=\n    { toFun := fun b => GSmul.smul a b\n      map_zero' := GdistribMulAction.smul_zero _\n      map_add' := GdistribMulAction.smul_add _ }\n  map_zero' := AddMonoidHom.ext fun a => Gmodule.zero_smul a\n  map_add' _a\u2081 _a\u2082 := AddMonoidHom.ext fun _b => Gmodule.add_smul _ _ _", "start": [62, 1], "end": [70, 72], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.smulAddMonoidHom", "code": "def smulAddMonoidHom [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M] :\n    (\u2a01 i, A i) \u2192+ (\u2a01 i, M i) \u2192+ \u2a01 i, M i :=\n  toAddMonoid fun _i =>\n    AddMonoidHom.flip <|\n      toAddMonoid fun _j => AddMonoidHom.flip <| (of M _).compHom.comp <| gsmulHom A M", "start": [75, 1], "end": [81, 87], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.smul_def", "code": "@[simp]\ntheorem smul_def [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    (x : \u2a01 i, A i) (y : \u2a01 i, M i) :\n    x \u2022 y = smulAddMonoidHom _ _ x y", "start": [92, 1], "end": [95, 44], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.smulAddMonoidHom_apply_of_of", "code": "@[simp]\ntheorem smulAddMonoidHom_apply_of_of [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    {i j} (x : A i) (y : M j) :\n    smulAddMonoidHom A M (DirectSum.of A i x) (of M j y) = of M (i +\u1d65 j) (GSmul.smul x y)", "start": [98, 1], "end": [102, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.of_smul_of", "code": "theorem of_smul_of [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    {i j} (x : A i) (y : M j) :\n    DirectSum.of A i x \u2022 of M j y = of M (i +\u1d65 j) (GSmul.smul x y)", "start": [106, 1], "end": [109, 39], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.one_smul'", "code": "private theorem one_smul' [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    (x : \u2a01 i, M i) :\n    (1 : \u2a01 i, A i) \u2022 x = x", "start": [116, 1], "end": [123, 95], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.mul_smul'", "code": "private theorem mul_smul' [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GSemiring A] [Gmodule A M]\n    (a b : \u2a01 i, A i)\n    (c : \u2a01 i, M i) : (a * b) \u2022 c = a \u2022 b \u2022 c", "start": [127, 1], "end": [145, 89], "kind": "commanddeclaration"}, {"full_name": "DirectSum.Gmodule.module", "code": "instance module [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GSemiring A] [Gmodule A M] :\n    Module (\u2a01 i, A i) (\u2a01 i, M i) where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul := one_smul' _ _\n  mul_smul := mul_smul' _ _\n  smul_add r := (smulAddMonoidHom A M r).map_add\n  smul_zero r := (smulAddMonoidHom A M r).map_zero\n  add_smul r s x := by simp only [smul_def, map_add, AddMonoidHom.add_apply]\n  zero_smul x := by simp only [smul_def, map_zero, AddMonoidHom.zero_apply]", "start": [147, 1], "end": [156, 76], "kind": "commanddeclaration"}, {"full_name": "SetLike.gmulAction", "code": "instance gmulAction [AddMonoid M] [DistribMulAction A M] [SetLike \u03c3 M] [SetLike.GradedMonoid \ud835\udcd0]\n    [SetLike.GradedSmul \ud835\udcd0 \ud835\udcdc] : GradedMonoid.GMulAction (fun i => \ud835\udcd0 i) fun i => \ud835\udcdc i :=\n  { SetLike.toGSmul \ud835\udcd0 \ud835\udcdc with\n    one_smul := fun \u27e8_i, _m\u27e9 => Sigma.subtype_ext (zero_vadd _ _) (one_smul _ _)\n    mul_smul := fun \u27e8_i, _a\u27e9 \u27e8_j, _a'\u27e9 \u27e8_k, _b\u27e9 =>\n      Sigma.subtype_ext (add_vadd _ _ _) (mul_smul _ _ _) }", "start": [179, 1], "end": [184, 60], "kind": "commanddeclaration"}, {"full_name": "SetLike.gdistribMulAction", "code": "instance gdistribMulAction [AddMonoid M] [DistribMulAction A M] [SetLike \u03c3 M]\n    [AddSubmonoidClass \u03c3 M] [SetLike.GradedMonoid \ud835\udcd0] [SetLike.GradedSmul \ud835\udcd0 \ud835\udcdc] :\n    DirectSum.GdistribMulAction (fun i => \ud835\udcd0 i) fun i => \ud835\udcdc i :=\n  { SetLike.gmulAction \ud835\udcd0 \ud835\udcdc with\n    smul_add := fun _a _b _c => Subtype.ext <| smul_add _ _ _\n    smul_zero := fun _a => Subtype.ext <| smul_zero _ }", "start": [187, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "SetLike.gmodule", "code": "instance gmodule : DirectSum.Gmodule (fun i => \ud835\udcd0 i) fun i => \ud835\udcdc i :=\n  { SetLike.gdistribMulAction \ud835\udcd0 \ud835\udcdc with\n    smul := fun x y => \u27e8(x : A) \u2022 (y : M), SetLike.GradedSmul.smul_mem x.2 y.2\u27e9\n    add_smul := fun _a _a' _b => Subtype.ext <| add_smul _ _ _\n    zero_smul := fun _b => Subtype.ext <| zero_smul _ _ }", "start": [198, 1], "end": [204, 58], "kind": "commanddeclaration"}, {"full_name": "GradedModule.isModule", "code": "def isModule [DecidableEq \u03b9A] [DecidableEq \u03b9M] [GradedRing \ud835\udcd0] : Module A (\u2a01 i, \ud835\udcdc i) :=\n  { Module.compHom _ (DirectSum.decomposeRingEquiv \ud835\udcd0 : A \u2243+* \u2a01 i, \ud835\udcd0 i).toRingHom with\n    smul := fun a b => DirectSum.decompose \ud835\udcd0 a \u2022 b }", "start": [215, 1], "end": [220, 53], "kind": "commanddeclaration"}, {"full_name": "GradedModule.linearEquiv", "code": "def linearEquiv [DecidableEq \u03b9A] [DecidableEq \u03b9M] [GradedRing \ud835\udcd0] [DirectSum.Decomposition \ud835\udcdc] :\n    @LinearEquiv A A _ _ (RingHom.id A) (RingHom.id A) _ _ M (\u2a01 i, \ud835\udcdc i) _\n    _ _ (by letI := isModule \ud835\udcd0 \ud835\udcdc; infer_instance) := by\n  letI h := isModule \ud835\udcd0 \ud835\udcdc\n  refine \u27e8\u27e8(DirectSum.decomposeAddEquiv \ud835\udcdc).toAddHom, ?_\u27e9,\n    (DirectSum.decomposeAddEquiv \ud835\udcdc).symm.toFun, (DirectSum.decomposeAddEquiv \ud835\udcdc).left_inv,\n    (DirectSum.decomposeAddEquiv \ud835\udcdc).right_inv\u27e9\n  intro x y\n  classical\n  rw [AddHom.toFun_eq_coe, \u2190 DirectSum.sum_support_decompose \ud835\udcd0 x, map_sum, Finset.sum_smul,\n    AddEquiv.coe_toAddHom, map_sum, Finset.sum_smul]\n  refine Finset.sum_congr rfl (fun i _hi => ?_)\n  rw [RingHom.id_apply, \u2190 DirectSum.sum_support_decompose \ud835\udcdc y, map_sum, Finset.smul_sum, map_sum,\n    Finset.smul_sum]\n  refine Finset.sum_congr rfl (fun j _hj => ?_)\n  rw [show (decompose \ud835\udcd0 x i : A) \u2022 (decomposeAddEquiv \ud835\udcdc \u2191(decompose \ud835\udcdc y j) : (\u2a01 i, \ud835\udcdc i)) =\n    DirectSum.Gmodule.smulAddMonoidHom _ _ (decompose \ud835\udcd0 \u2191(decompose \ud835\udcd0 x i))\n    (decomposeAddEquiv \ud835\udcdc \u2191(decompose \ud835\udcdc y j)) from DirectSum.Gmodule.smul_def _ _ _ _]\n  simp only [decomposeAddEquiv_apply, Equiv.invFun_as_coe, Equiv.symm_symm, decompose_coe,\n    Gmodule.smulAddMonoidHom_apply_of_of]\n  convert DirectSum.decompose_coe \ud835\udcdc _\n  rfl", "start": [223, 1], "end": [247, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/Multiplier.lean", "imports": ["Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/Star/Unitization.lean"], "premises": [{"full_name": "DoubleCentralizer", "code": "structure DoubleCentralizer (\ud835\udd5c : Type u) (A : Type v) [NontriviallyNormedField \ud835\udd5c]\n    [NonUnitalNormedRing A] [NormedSpace \ud835\udd5c A] [SMulCommClass \ud835\udd5c A A] [IsScalarTower \ud835\udd5c A A] extends\n    (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A) where\n  \n  central : \u2200 x y : A, snd x * y = x * fst y", "start": [64, 1], "end": [72, 45], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.ext", "code": "@[ext]\nlemma DoubleCentralizer.ext (\ud835\udd5c : Type u) (A : Type v) [NontriviallyNormedField \ud835\udd5c]\n    [NonUnitalNormedRing A] [NormedSpace \ud835\udd5c A] [SMulCommClass \ud835\udd5c A A] [IsScalarTower \ud835\udd5c A A]\n    (a b : \ud835\udcdc(\ud835\udd5c, A)) (h : a.toProd = b.toProd) : a = b := by\n  cases a\n  cases b\n  simpa using h", "start": [81, 1], "end": [87, 16], "kind": "mathlibtacticlemma"}, {"full_name": "DoubleCentralizer.range_toProd", "code": "theorem range_toProd :\n    Set.range toProd = { lr : (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A) | \u2200 x y, lr.2 x * y = x * lr.1 y }", "start": [107, 1], "end": [112, 49], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instAdd", "code": "instance instAdd : Add \ud835\udcdc(\ud835\udd5c, A) where\n  add a b :=\n    { toProd := a.toProd + b.toProd\n      central := fun x y =>\n        show (a.snd + b.snd) x * y = x * (a.fst + b.fst) y by\n          simp only [ContinuousLinearMap.add_apply, mul_add, add_mul, central] }", "start": [115, 1], "end": [120, 81], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instZero", "code": "instance instZero : Zero \ud835\udcdc(\ud835\udd5c, A) where\n  zero :=\n    { toProd := 0\n      central := fun x y => (zero_mul y).trans (mul_zero x).symm }", "start": [122, 1], "end": [125, 67], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instNeg", "code": "instance instNeg : Neg \ud835\udcdc(\ud835\udd5c, A) where\n  neg a :=\n    { toProd := -a.toProd\n      central := fun x y =>\n        show -a.snd x * y = x * -a.fst y by\n          simp only [ContinuousLinearMap.neg_apply, neg_mul, mul_neg, central] }", "start": [127, 1], "end": [132, 81], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instSub", "code": "instance instSub : Sub \ud835\udcdc(\ud835\udd5c, A) where\n  sub a b :=\n    { toProd := a.toProd - b.toProd\n      central := fun x y =>\n        show (a.snd - b.snd) x * y = x * (a.fst - b.fst) y by\n          simp only [ContinuousLinearMap.sub_apply, _root_.sub_mul, _root_.mul_sub, central] }", "start": [134, 1], "end": [139, 95], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instSMul", "code": "instance instSMul : SMul S \ud835\udcdc(\ud835\udd5c, A) where\n  smul s a :=\n    { toProd := s \u2022 a.toProd\n      central := fun x y =>\n        show (s \u2022 a.snd) x * y = x * (s \u2022 a.fst) y by\n          simp only [ContinuousLinearMap.smul_apply, mul_smul_comm, smul_mul_assoc, central] }", "start": [146, 1], "end": [151, 95], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.smul_toProd", "code": "@[simp]\ntheorem smul_toProd (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).toProd = s \u2022 a.toProd", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.smul_fst", "code": "theorem smul_fst (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).fst = s \u2022 a.fst", "start": [158, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.smul_snd", "code": "theorem smul_snd (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).snd = s \u2022 a.snd", "start": [162, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instIsScalarTower", "code": "instance instIsScalarTower [SMul S T] [IsScalarTower S T A] : IsScalarTower S T \ud835\udcdc(\ud835\udd5c, A) where\n  smul_assoc _ _ a := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <| smul_assoc _ _ a.toProd", "start": [169, 1], "end": [170, 75], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass S T A] : SMulCommClass S T \ud835\udcdc(\ud835\udd5c, A) where\n  smul_comm _ _ a := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <| smul_comm _ _ a.toProd", "start": [172, 1], "end": [173, 73], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instIsCentralScalar", "code": "instance instIsCentralScalar {R : Type*} [Semiring R] [Module R A] [SMulCommClass \ud835\udd5c R A]\n    [ContinuousConstSMul R A] [IsScalarTower R A A] [SMulCommClass R A A] [Module R\u1d50\u1d52\u1d56 A]\n    [IsCentralScalar R A] : IsCentralScalar R \ud835\udcdc(\ud835\udd5c, A) where\n  op_smul_eq_smul _ a := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <| op_smul_eq_smul _ a.toProd", "start": [175, 1], "end": [178, 81], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instOne", "code": "instance instOne : One \ud835\udcdc(\ud835\udd5c, A) :=\n  \u27e8\u27e81, fun _x _y => rfl\u27e9\u27e9", "start": [182, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instMul", "code": "instance instMul : Mul \ud835\udcdc(\ud835\udd5c, A) where\n  mul a b :=\n    { toProd := (a.fst.comp b.fst, b.snd.comp a.snd)\n      central := fun x y => show b.snd (a.snd x) * y = x * a.fst (b.fst y) by simp only [central] }", "start": [185, 1], "end": [188, 100], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instNatCast", "code": "instance instNatCast : NatCast \ud835\udcdc(\ud835\udd5c, A) where\n  natCast n :=\n    \u27e8n, fun x y => by\n      rw [Prod.snd_natCast, Prod.fst_natCast]\n      simp only [\u2190 Nat.smul_one_eq_coe, smul_apply, one_apply, mul_smul_comm, smul_mul_assoc]\u27e9", "start": [190, 1], "end": [194, 95], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instIntCast", "code": "instance instIntCast : IntCast \ud835\udcdc(\ud835\udd5c, A) where\n  intCast n :=\n    \u27e8n, fun x y => by\n      rw [Prod.snd_intCast, Prod.fst_intCast]\n      simp only [\u2190 Int.smul_one_eq_coe, smul_apply, one_apply, mul_smul_comm, smul_mul_assoc]\u27e9", "start": [196, 1], "end": [200, 95], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instPow", "code": "instance instPow : Pow \ud835\udcdc(\ud835\udd5c, A) \u2115 where\n  pow a n :=\n    \u27e8a.toProd ^ n, fun x y => by\n      induction' n with k hk generalizing x y\n      \u00b7 rfl\n      \u00b7 rw [Prod.pow_snd, Prod.pow_fst] at hk \u22a2\n        rw [pow_succ a.snd, mul_apply, a.central, hk, pow_succ' a.fst, mul_apply]\u27e9", "start": [202, 1], "end": [208, 83], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instInhabited", "code": "instance instInhabited : Inhabited \ud835\udcdc(\ud835\udd5c, A) :=\n  \u27e80\u27e9", "start": [210, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.add_toProd", "code": "@[simp]\ntheorem add_toProd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a + b).toProd = a.toProd + b.toProd", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.zero_toProd", "code": "@[simp]\ntheorem zero_toProd : (0 : \ud835\udcdc(\ud835\udd5c, A)).toProd = 0", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.neg_toProd", "code": "@[simp]\ntheorem neg_toProd (a : \ud835\udcdc(\ud835\udd5c, A)) : (-a).toProd = -a.toProd", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.sub_toProd", "code": "@[simp]\ntheorem sub_toProd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a - b).toProd = a.toProd - b.toProd", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.one_toProd", "code": "@[simp]\ntheorem one_toProd : (1 : \ud835\udcdc(\ud835\udd5c, A)).toProd = 1", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nat_cast_toProd", "code": "@[simp]\ntheorem nat_cast_toProd (n : \u2115) : (n : \ud835\udcdc(\ud835\udd5c, A)).toProd = n", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.int_cast_toProd", "code": "@[simp]\ntheorem int_cast_toProd (n : \u2124) : (n : \ud835\udcdc(\ud835\udd5c, A)).toProd = n", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.pow_toProd", "code": "@[simp]\ntheorem pow_toProd (n : \u2115) (a : \ud835\udcdc(\ud835\udd5c, A)) : (a ^ n).toProd = a.toProd ^ n", "start": [248, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.add_fst", "code": "theorem add_fst (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a + b).fst = a.fst + b.fst", "start": [253, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.add_snd", "code": "theorem add_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a + b).snd = a.snd + b.snd", "start": [257, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.zero_fst", "code": "theorem zero_fst : (0 : \ud835\udcdc(\ud835\udd5c, A)).fst = 0", "start": [261, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.zero_snd", "code": "theorem zero_snd : (0 : \ud835\udcdc(\ud835\udd5c, A)).snd = 0", "start": [265, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.neg_fst", "code": "theorem neg_fst (a : \ud835\udcdc(\ud835\udd5c, A)) : (-a).fst = -a.fst", "start": [269, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.neg_snd", "code": "theorem neg_snd (a : \ud835\udcdc(\ud835\udd5c, A)) : (-a).snd = -a.snd", "start": [273, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.sub_fst", "code": "theorem sub_fst (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a - b).fst = a.fst - b.fst", "start": [277, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.sub_snd", "code": "theorem sub_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a - b).snd = a.snd - b.snd", "start": [281, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.one_fst", "code": "theorem one_fst : (1 : \ud835\udcdc(\ud835\udd5c, A)).fst = 1", "start": [285, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.one_snd", "code": "theorem one_snd : (1 : \ud835\udcdc(\ud835\udd5c, A)).snd = 1", "start": [289, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.mul_fst", "code": "@[simp]\ntheorem mul_fst (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a * b).fst = a.fst * b.fst", "start": [293, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.mul_snd", "code": "@[simp]\ntheorem mul_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a * b).snd = b.snd * a.snd", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nat_cast_fst", "code": "theorem nat_cast_fst (n : \u2115) : (n : \ud835\udcdc(\ud835\udd5c, A)).fst = n", "start": [303, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nat_cast_snd", "code": "theorem nat_cast_snd (n : \u2115) : (n : \ud835\udcdc(\ud835\udd5c, A)).snd = n", "start": [307, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.int_cast_fst", "code": "theorem int_cast_fst (n : \u2124) : (n : \ud835\udcdc(\ud835\udd5c, A)).fst = n", "start": [311, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.int_cast_snd", "code": "theorem int_cast_snd (n : \u2124) : (n : \ud835\udcdc(\ud835\udd5c, A)).snd = n", "start": [315, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.pow_fst", "code": "theorem pow_fst (n : \u2115) (a : \ud835\udcdc(\ud835\udd5c, A)) : (a ^ n).fst = a.fst ^ n", "start": [319, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.pow_snd", "code": "theorem pow_snd (n : \u2115) (a : \ud835\udcdc(\ud835\udd5c, A)) : (a ^ n).snd = a.snd ^ n", "start": [323, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.toProdMulOpposite", "code": "def toProdMulOpposite : \ud835\udcdc(\ud835\udd5c, A) \u2192 (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\u1d50\u1d52\u1d56 := fun a =>\n  (a.fst, MulOpposite.op a.snd)", "start": [327, 1], "end": [330, 32], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.toProdMulOpposite_injective", "code": "theorem toProdMulOpposite_injective :\n    Function.Injective (toProdMulOpposite : \ud835\udcdc(\ud835\udd5c, A) \u2192 (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\u1d50\u1d52\u1d56)", "start": [333, 1], "end": [337, 80], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.range_toProdMulOpposite", "code": "theorem range_toProdMulOpposite :\n    Set.range toProdMulOpposite =\n      { lr : (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\u1d50\u1d52\u1d56 | \u2200 x y, unop lr.2 x * y = x * lr.1 y }", "start": [340, 1], "end": [346, 76], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instRing", "code": "instance instRing : Ring \ud835\udcdc(\ud835\udd5c, A) :=\n  toProdMulOpposite_injective.ring _ rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _x _n => Prod.ext rfl <| MulOpposite.op_smul _ _)\n    (fun _x _n => Prod.ext rfl <| MulOpposite.op_smul _ _)\n    (fun _x _n => Prod.ext rfl <| MulOpposite.op_pow _ _) (fun _ => rfl) fun _ => rfl", "start": [349, 1], "end": [355, 86], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.toProdHom", "code": "@[simps]\ndef toProdHom : \ud835\udcdc(\ud835\udd5c, A) \u2192+ (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A) where\n  toFun := toProd\n  map_zero' := rfl\n  map_add' _x _y := rfl", "start": [357, 1], "end": [362, 24], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.toProdMulOppositeHom", "code": "@[simps]\ndef toProdMulOppositeHom : \ud835\udcdc(\ud835\udd5c, A) \u2192+* (A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)\u1d50\u1d52\u1d56 where\n  toFun := toProdMulOpposite\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _x _y := rfl\n  map_mul' _x _y := rfl", "start": [365, 1], "end": [372, 24], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instModule", "code": "instance instModule {S : Type*} [Semiring S] [Module S A] [SMulCommClass \ud835\udd5c S A]\n    [ContinuousConstSMul S A] [IsScalarTower S A A] [SMulCommClass S A A] : Module S \ud835\udcdc(\ud835\udd5c, A) :=\n  Function.Injective.module S toProdHom (ext (\ud835\udd5c := \ud835\udd5c) (A := A)) fun _x _y => rfl", "start": [375, 1], "end": [379, 81], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instAlgebra", "code": "instance instAlgebra : Algebra \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) where\n  toFun k :=\n    { toProd := algebraMap \ud835\udd5c ((A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A)) k\n      central := fun x y => by\n        simp_rw [Prod.algebraMap_apply, Algebra.algebraMap_eq_smul_one, smul_apply, one_apply,\n          mul_smul_comm, smul_mul_assoc] }\n  map_one' := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <| map_one <| algebraMap \ud835\udd5c ((A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A))\n  map_mul' k\u2081 k\u2082 :=\n    ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <|\n      Prod.ext (map_mul (algebraMap \ud835\udd5c (A \u2192L[\ud835\udd5c] A)) _ _)\n        ((map_mul (algebraMap \ud835\udd5c (A \u2192L[\ud835\udd5c] A)) _ _).trans (Algebra.commutes _ _))\n  map_zero' := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <| map_zero <| algebraMap \ud835\udd5c ((A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A))\n  map_add' _ _ := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <|\n    map_add (algebraMap \ud835\udd5c ((A \u2192L[\ud835\udd5c] A) \u00d7 (A \u2192L[\ud835\udd5c] A))) _ _\n  commutes' _ _ := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <|\n    Prod.ext (Algebra.commutes _ _) (Algebra.commutes _ _).symm\n  smul_def' _ _ := ext (\ud835\udd5c := \ud835\udd5c) (A := A) _ _ <|\n    Prod.ext (Algebra.smul_def _ _) ((Algebra.smul_def _ _).trans <| Algebra.commutes _ _)", "start": [382, 1], "end": [399, 91], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.algebraMap_toProd", "code": "@[simp]\ntheorem algebraMap_toProd (k : \ud835\udd5c) : (algebraMap \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) k).toProd = algebraMap \ud835\udd5c _ k", "start": [401, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.algebraMap_fst", "code": "theorem algebraMap_fst (k : \ud835\udd5c) : (algebraMap \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) k).fst = algebraMap \ud835\udd5c _ k", "start": [406, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.algebraMap_snd", "code": "theorem algebraMap_snd (k : \ud835\udd5c) : (algebraMap \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) k).snd = algebraMap \ud835\udd5c _ k", "start": [410, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instStar", "code": "instance instStar : Star \ud835\udcdc(\ud835\udd5c, A) where\n  star a :=\n    { fst :=\n        (((star\u2097\u1d62 \ud835\udd5c : A \u2243\u2097\u1d62\u22c6[\ud835\udd5c] A) : A \u2192L\u22c6[\ud835\udd5c] A).comp a.snd).comp\n          ((star\u2097\u1d62 \ud835\udd5c : A \u2243\u2097\u1d62\u22c6[\ud835\udd5c] A) : A \u2192L\u22c6[\ud835\udd5c] A)\n      snd :=\n        (((star\u2097\u1d62 \ud835\udd5c : A \u2243\u2097\u1d62\u22c6[\ud835\udd5c] A) : A \u2192L\u22c6[\ud835\udd5c] A).comp a.fst).comp\n          ((star\u2097\u1d62 \ud835\udd5c : A \u2243\u2097\u1d62\u22c6[\ud835\udd5c] A) : A \u2192L\u22c6[\ud835\udd5c] A)\n      central := fun x y => by\n        simpa only [star_mul, star_star] using (congr_arg star (a.central (star y) (star x))).symm }", "start": [423, 1], "end": [434, 101], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.star_fst", "code": "@[simp]\ntheorem star_fst (a : \ud835\udcdc(\ud835\udd5c, A)) (b : A) : (star a).fst b = star (a.snd (star b))", "start": [436, 1], "end": [438, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.star_snd", "code": "@[simp]\ntheorem star_snd (a : \ud835\udcdc(\ud835\udd5c, A)) (b : A) : (star a).snd b = star (a.fst (star b))", "start": [441, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instStarAddMonoid", "code": "instance instStarAddMonoid : StarAddMonoid \ud835\udcdc(\ud835\udd5c, A) :=\n  { DoubleCentralizer.instStar with\n    star_involutive := fun x => by ext <;> simp only [star_fst, star_snd, star_star]\n    star_add := fun x y => by\n      ext <;>\n        simp only [star_fst, star_snd, add_fst, add_snd, ContinuousLinearMap.add_apply, star_add] }", "start": [446, 1], "end": [451, 100], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instStarRing", "code": "instance instStarRing : StarRing \ud835\udcdc(\ud835\udd5c, A) :=\n  { DoubleCentralizer.instStarAddMonoid with\n    star_mul := fun a b => by\n      ext <;>\n        simp only [star_fst, star_snd, mul_fst, mul_snd, star_star, ContinuousLinearMap.coe_mul,\n          Function.comp_apply] }", "start": [453, 1], "end": [458, 33], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instStarModule", "code": "instance instStarModule : StarModule \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) :=\n  { DoubleCentralizer.instStarAddMonoid (\ud835\udd5c := \ud835\udd5c) (A := A) with\n    star_smul := fun k a => by ext <;> exact star_smul _ _ }", "start": [460, 1], "end": [462, 61], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.coe", "code": "@[coe]\nprotected noncomputable def coe (a : A) : \ud835\udcdc(\ud835\udd5c, A) :=\n  { fst := ContinuousLinearMap.mul \ud835\udd5c A a\n    snd := (ContinuousLinearMap.mul \ud835\udd5c A).flip a\n    central := fun _x _y => mul_assoc _ _ _ }", "start": [472, 1], "end": [483, 46], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.coe_fst", "code": "@[simp, norm_cast]\ntheorem coe_fst (a : A) : (a : \ud835\udcdc(\ud835\udd5c, A)).fst = ContinuousLinearMap.mul \ud835\udd5c A a", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.coe_snd", "code": "@[simp, norm_cast]\ntheorem coe_snd (a : A) : (a : \ud835\udcdc(\ud835\udd5c, A)).snd = (ContinuousLinearMap.mul \ud835\udd5c A).flip a", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.coe_eq_algebraMap", "code": "theorem coe_eq_algebraMap : (DoubleCentralizer.coe \ud835\udd5c : \ud835\udd5c \u2192 \ud835\udcdc(\ud835\udd5c, \ud835\udd5c)) = algebraMap \ud835\udd5c \ud835\udcdc(\ud835\udd5c, \ud835\udd5c)", "start": [506, 1], "end": [510, 23], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.coeHom", "code": "@[simps]\nnoncomputable def coeHom [StarRing \ud835\udd5c] [StarRing A] [StarModule \ud835\udd5c A] [NormedStarGroup A] :\n    A \u2192\u22c6\u2099\u2090[\ud835\udd5c] \ud835\udcdc(\ud835\udd5c, A) where\n  toFun a := a\n  map_smul' _ _ := ext _ _ _ _ <| Prod.ext (map_smul _ _ _) (map_smul _ _ _)\n  map_zero' := ext _ _ _ _ <| Prod.ext (map_zero _) (map_zero _)\n  map_add' _ _ := ext _ _ _ _ <| Prod.ext (map_add _ _ _) (map_add _ _ _)\n  map_mul' _ _ :=  ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _))\n    (ContinuousLinearMap.ext fun _ => (mul_assoc _ _ _).symm)\n  map_star' _ := ext _ _ _ _ <| Prod.ext\n    (ContinuousLinearMap.ext fun _ => (star_star_mul _ _).symm)\n    (ContinuousLinearMap.ext fun _ => (star_mul_star _ _).symm)", "start": [513, 1], "end": [527, 64], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.norm_def", "code": "theorem norm_def (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a\u2016 = \u2016toProdHom a\u2016", "start": [550, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nnnorm_def", "code": "theorem nnnorm_def (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a\u2016\u208a = \u2016toProdHom a\u2016\u208a", "start": [554, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.norm_def'", "code": "theorem norm_def' (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a\u2016 = \u2016toProdMulOppositeHom a\u2016", "start": [558, 1], "end": [559, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nnnorm_def'", "code": "theorem nnnorm_def' (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a\u2016\u208a = \u2016toProdMulOppositeHom a\u2016\u208a", "start": [562, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instNormedSpace", "code": "instance instNormedSpace : NormedSpace \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) :=\n  { DoubleCentralizer.instModule with\n    norm_smul_le := fun k a => (norm_smul_le k a.toProdMulOpposite : _) }", "start": [566, 1], "end": [568, 74], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instNormedAlgebra", "code": "instance instNormedAlgebra : NormedAlgebra \ud835\udd5c \ud835\udcdc(\ud835\udd5c, A) :=\n  { DoubleCentralizer.instAlgebra, DoubleCentralizer.instNormedSpace with }", "start": [570, 1], "end": [571, 76], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.uniformEmbedding_toProdMulOpposite", "code": "theorem uniformEmbedding_toProdMulOpposite : UniformEmbedding (@toProdMulOpposite \ud835\udd5c A _ _ _ _ _)", "start": [573, 1], "end": [574, 53], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.norm_fst_eq_snd", "code": "theorem norm_fst_eq_snd (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.fst\u2016 = \u2016a.snd\u2016", "start": [589, 1], "end": [629, 44], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nnnorm_fst_eq_snd", "code": "theorem nnnorm_fst_eq_snd (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.fst\u2016\u208a = \u2016a.snd\u2016\u208a", "start": [632, 1], "end": [633, 35], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.norm_fst", "code": "@[simp]\ntheorem norm_fst (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.fst\u2016 = \u2016a\u2016", "start": [636, 1], "end": [638, 93], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.norm_snd", "code": "@[simp]\ntheorem norm_snd (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.snd\u2016 = \u2016a\u2016", "start": [642, 1], "end": [643, 86], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nnnorm_fst", "code": "@[simp]\ntheorem nnnorm_fst (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.fst\u2016\u208a = \u2016a\u2016\u208a", "start": [646, 1], "end": [648, 27], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.nnnorm_snd", "code": "@[simp]\ntheorem nnnorm_snd (a : \ud835\udcdc(\ud835\udd5c, A)) : \u2016a.snd\u2016\u208a = \u2016a\u2016\u208a", "start": [651, 1], "end": [653, 27], "kind": "commanddeclaration"}, {"full_name": "DoubleCentralizer.instCstarRing", "code": "instance instCstarRing : CstarRing \ud835\udcdc(\ud835\udd5c, A) where\n  norm_star_mul_self := @fun (a : \ud835\udcdc(\ud835\udd5c, A)) => congr_arg ((\u2191) : \u211d\u22650 \u2192 \u211d) <|\n    show \u2016star a * a\u2016\u208a = \u2016a\u2016\u208a * \u2016a\u2016\u208a by\n    \n      have hball : (Metric.closedBall (0 : A) 1).Nonempty :=\n        Metric.nonempty_closedBall.2 zero_le_one\n      have key :\n        \u2200 x y, \u2016x\u2016\u208a \u2264 1 \u2192 \u2016y\u2016\u208a \u2264 1 \u2192 \u2016a.snd (star (a.fst (star x))) * y\u2016\u208a \u2264 \u2016a\u2016\u208a * \u2016a\u2016\u208a := by\n        intro x y hx hy\n        rw [a.central]\n        calc\n          \u2016star (a.fst (star x)) * a.fst y\u2016\u208a \u2264 \u2016a.fst (star x)\u2016\u208a * \u2016a.fst y\u2016\u208a :=\n            nnnorm_star (a.fst (star x)) \u25b8 nnnorm_mul_le _ _\n          _ \u2264 \u2016a.fst\u2016\u208a * 1 * (\u2016a.fst\u2016\u208a * 1) :=\n            (mul_le_mul' (a.fst.le_op_norm_of_le ((nnnorm_star x).trans_le hx))\n              (a.fst.le_op_norm_of_le hy))\n          _ \u2264 \u2016a\u2016\u208a * \u2016a\u2016\u208a := by simp only [mul_one, nnnorm_fst, le_rfl]\n      rw [\u2190 nnnorm_snd]\n      simp only [mul_snd, \u2190 sSup_closed_unit_ball_eq_nnnorm, star_snd, mul_apply]\n      simp only [\u2190 @op_nnnorm_mul_apply \ud835\udd5c _ A]\n      simp only [\u2190 sSup_closed_unit_ball_eq_nnnorm, mul_apply']\n      refine' csSup_eq_of_forall_le_of_forall_lt_exists_gt (hball.image _) _ fun r hr => _\n      \u00b7 rintro - \u27e8x, hx, rfl\u27e9\n        refine' csSup_le (hball.image _) _\n        rintro - \u27e8y, hy, rfl\u27e9\n        exact key x y (mem_closedBall_zero_iff.1 hx) (mem_closedBall_zero_iff.1 hy)\n      \u00b7 simp only [Set.mem_image, Set.mem_setOf_eq, exists_prop, exists_exists_and_eq_and]\n        have hr' : NNReal.sqrt r < \u2016a\u2016\u208a := \u2016a\u2016\u208a.sqrt_mul_self \u25b8 NNReal.sqrt_lt_sqrt_iff.2 hr\n        simp_rw [\u2190 nnnorm_fst, \u2190 sSup_closed_unit_ball_eq_nnnorm] at hr'\n        obtain \u27e8_, \u27e8x, hx, rfl\u27e9, hxr\u27e9 := exists_lt_of_lt_csSup (hball.image _) hr'\n        have hx' : \u2016x\u2016\u208a \u2264 1 := mem_closedBall_zero_iff.1 hx\n        refine' \u27e8star x, mem_closedBall_zero_iff.2 ((nnnorm_star x).trans_le hx'), _\u27e9\n        refine' lt_csSup_of_lt _ \u27e8x, hx, rfl\u27e9 _\n        \u00b7 refine' \u27e8\u2016a\u2016\u208a * \u2016a\u2016\u208a, _\u27e9\n          rintro - \u27e8y, hy, rfl\u27e9\n          exact key (star x) y ((nnnorm_star x).trans_le hx') (mem_closedBall_zero_iff.1 hy)\n        \u00b7 simpa only [a.central, star_star, CstarRing.nnnorm_star_mul_self, NNReal.sq_sqrt, \u2190 sq]\n            using pow_lt_pow_of_lt_left hxr zero_le' two_pos", "start": [666, 1], "end": [712, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Lemma.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Regularity/Increment.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "szemeredi_regularity", "code": "theorem szemeredi_regularity (h\u03b5 : 0 < \u03b5) (hl : l \u2264 card \u03b1) :\n    \u2203 P : Finpartition univ,\n      P.IsEquipartition \u2227 l \u2264 P.parts.card \u2227 P.parts.card \u2264 bound \u03b5 l \u2227 P.IsUniform G \u03b5", "start": [75, 1], "end": [154, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/MvPolynomial/Homogeneous.lean", "imports": ["Mathlib/Algebra/DirectSum/Internal.lean", "Mathlib/Data/MvPolynomial/Variables.lean", "Mathlib/Algebra/GradedMonoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.IsHomogeneous", "code": "def IsHomogeneous [CommSemiring R] (\u03c6 : MvPolynomial \u03c3 R) (n : \u2115) :=\n  \u2200 \u2983d\u2984, coeff d \u03c6 \u2260 0 \u2192 \u2211 i in d.support, d i = n", "start": [40, 1], "end": [43, 51], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousSubmodule", "code": "def homogeneousSubmodule [CommSemiring R] (n : \u2115) : Submodule R (MvPolynomial \u03c3 R) where\n  carrier := { x | x.IsHomogeneous n }\n  smul_mem' r a ha c hc := by\n    rw [coeff_smul] at hc\n    apply ha\n    intro h\n    apply hc\n    rw [h]\n    exact smul_zero r\n  zero_mem' d hd := False.elim (hd <| coeff_zero _)\n  add_mem' {a b} ha hb c hc := by\n    rw [coeff_add] at hc\n    obtain h | h : coeff c a \u2260 0 \u2228 coeff c b \u2260 0 := by\n      contrapose! hc\n      simp only [hc, add_zero]\n    \u00b7 exact ha h\n    \u00b7 exact hb h", "start": [48, 1], "end": [65, 17], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_homogeneousSubmodule", "code": "@[simp]\ntheorem mem_homogeneousSubmodule [CommSemiring R] (n : \u2115) (p : MvPolynomial \u03c3 R) :\n    p \u2208 homogeneousSubmodule \u03c3 R n \u2194 p.IsHomogeneous n", "start": [70, 1], "end": [72, 66], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousSubmodule_eq_finsupp_supported", "code": "theorem homogeneousSubmodule_eq_finsupp_supported [CommSemiring R] (n : \u2115) :\n    homogeneousSubmodule \u03c3 R n = Finsupp.supported _ R { d | \u2211 i in d.support, d i = n }", "start": [77, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousSubmodule_mul", "code": "theorem homogeneousSubmodule_mul [CommSemiring R] (m n : \u2115) :\n    homogeneousSubmodule \u03c3 R m * homogeneousSubmodule \u03c3 R n \u2264 homogeneousSubmodule \u03c3 R (m + n)", "start": [88, 1], "end": [108, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_monomial", "code": "theorem isHomogeneous_monomial (d : \u03c3 \u2192\u2080 \u2115) (r : R) (n : \u2115) (hn : \u2211 i in d.support, d i = n) :\n    IsHomogeneous (monomial d r) n", "start": [115, 1], "end": [123, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_of_totalDegree_zero", "code": "theorem isHomogeneous_of_totalDegree_zero {p : MvPolynomial \u03c3 R} (hp : p.totalDegree = 0) :\n    IsHomogeneous p 0", "start": [128, 1], "end": [133, 11], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_C", "code": "theorem isHomogeneous_C (r : R) : IsHomogeneous (C r : MvPolynomial \u03c3 R) 0", "start": [136, 1], "end": [138, 56], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_zero", "code": "theorem isHomogeneous_zero (n : \u2115) : IsHomogeneous (0 : MvPolynomial \u03c3 R) n", "start": [144, 1], "end": [145, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_one", "code": "theorem isHomogeneous_one : IsHomogeneous (1 : MvPolynomial \u03c3 R) 0", "start": [148, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isHomogeneous_X", "code": "theorem isHomogeneous_X (i : \u03c3) : IsHomogeneous (X i : MvPolynomial \u03c3 R) 1", "start": [154, 1], "end": [157, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.coeff_eq_zero", "code": "theorem coeff_eq_zero (h\u03c6 : IsHomogeneous \u03c6 n) (d : \u03c3 \u2192\u2080 \u2115) (hd : \u2211 i in d.support, d i \u2260 n) :\n    coeff d \u03c6 = 0", "start": [167, 1], "end": [171, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.inj_right", "code": "theorem inj_right (hm : IsHomogeneous \u03c6 m) (hn : IsHomogeneous \u03c6 n) (h\u03c6 : \u03c6 \u2260 0) : m = n", "start": [174, 1], "end": [176, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.add", "code": "theorem add (h\u03c6 : IsHomogeneous \u03c6 n) (h\u03c8 : IsHomogeneous \u03c8 n) : IsHomogeneous (\u03c6 + \u03c8) n", "start": [179, 1], "end": [180, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.sum", "code": "theorem sum {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) (n : \u2115)\n    (h : \u2200 i \u2208 s, IsHomogeneous (\u03c6 i) n) : IsHomogeneous (\u2211 i in s, \u03c6 i) n", "start": [183, 1], "end": [185, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.mul", "code": "theorem mul (h\u03c6 : IsHomogeneous \u03c6 m) (h\u03c8 : IsHomogeneous \u03c8 n) : IsHomogeneous (\u03c6 * \u03c8) (m + n)", "start": [188, 1], "end": [189, 62], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.prod", "code": "theorem prod {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) (n : \u03b9 \u2192 \u2115)\n    (h : \u2200 i \u2208 s, IsHomogeneous (\u03c6 i) (n i)) : IsHomogeneous (\u220f i in s, \u03c6 i) (\u2211 i in s, n i)", "start": [192, 1], "end": [203, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.totalDegree", "code": "theorem totalDegree (h\u03c6 : IsHomogeneous \u03c6 n) (h : \u03c6 \u2260 0) : totalDegree \u03c6 = n", "start": [206, 1], "end": [217, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsHomogeneous.HomogeneousSubmodule.gcommSemiring", "code": "instance HomogeneousSubmodule.gcommSemiring : SetLike.GradedMonoid (homogeneousSubmodule \u03c3 R) where\n  one_mem := isHomogeneous_one \u03c3 R\n  mul_mem _ _ _ _ := IsHomogeneous.mul", "start": [220, 1], "end": [224, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent", "code": "def homogeneousComponent [CommSemiring R] (n : \u2115) : MvPolynomial \u03c3 R \u2192\u2097[R] MvPolynomial \u03c3 R :=\n  (Submodule.subtype _).comp <| Finsupp.restrictDom _ _ { d | \u2211 i in d.support, d i = n }", "start": [241, 1], "end": [245, 90], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_homogeneousComponent", "code": "theorem coeff_homogeneousComponent (d : \u03c3 \u2192\u2080 \u2115) :\n    coeff d (homogeneousComponent n \u03c6) = if (\u2211 i in d.support, d i) = n then coeff d \u03c6 else 0", "start": [254, 1], "end": [256, 73], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_apply", "code": "theorem homogeneousComponent_apply :\n    homogeneousComponent n \u03c6 =\n      \u2211 d in \u03c6.support.filter fun d => \u2211 i in d.support, d i = n, monomial d (coeff d \u03c6)", "start": [259, 1], "end": [262, 72], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_isHomogeneous", "code": "theorem homogeneousComponent_isHomogeneous : (homogeneousComponent n \u03c6).IsHomogeneous n", "start": [265, 1], "end": [268, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_zero", "code": "@[simp]\ntheorem homogeneousComponent_zero : homogeneousComponent 0 \u03c6 = C (coeff 0 \u03c6)", "start": [271, 1], "end": [280, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_C_mul", "code": "@[simp]\ntheorem homogeneousComponent_C_mul (n : \u2115) (r : R) :\n    homogeneousComponent n (C r * \u03c6) = C r * homogeneousComponent n \u03c6", "start": [283, 1], "end": [286, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_eq_zero'", "code": "theorem homogeneousComponent_eq_zero'\n    (h : \u2200 d : \u03c3 \u2192\u2080 \u2115, d \u2208 \u03c6.support \u2192 \u2211 i in d.support, d i \u2260 n) :\n    homogeneousComponent n \u03c6 = 0", "start": [290, 1], "end": [295, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_eq_zero", "code": "theorem homogeneousComponent_eq_zero (h : \u03c6.totalDegree < n) : homogeneousComponent n \u03c6 = 0", "start": [298, 1], "end": [303, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_homogeneousComponent", "code": "theorem sum_homogeneousComponent :\n    (\u2211 i in range (\u03c6.totalDegree + 1), homogeneousComponent i \u03c6) = \u03c6", "start": [306, 1], "end": [311, 58], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.homogeneousComponent_homogeneous_polynomial", "code": "theorem homogeneousComponent_homogeneous_polynomial (m n : \u2115) (p : MvPolynomial \u03c3 R)\n    (h : p \u2208 homogeneousSubmodule \u03c3 R n) : homogeneousComponent m p = if m = n then p else 0", "start": [314, 1], "end": [326, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Classical.lean", "imports": ["Mathlib/Data/Matrix/Basis.lean", "Mathlib/LinearAlgebra/Matrix/Trace.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/SymplecticGroup.lean", "Mathlib/Algebra/Lie/Abelian.lean", "Mathlib/Algebra/Lie/SkewAdjoint.lean", "Mathlib/Data/Matrix/DMatrix.lean"], "premises": [{"full_name": "LieAlgebra.matrix_trace_commutator_zero", "code": "@[simp]\ntheorem matrix_trace_commutator_zero [Fintype n] (X Y : Matrix n n R) : Matrix.trace \u2045X, Y\u2046 = 0", "start": [84, 1], "end": [90, 24], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.SpecialLinear.sl", "code": "def sl [Fintype n] : LieSubalgebra R (Matrix n n R) :=\n  { LinearMap.ker (Matrix.traceLinearMap n R R) with\n    lie_mem' := fun _ _ => LinearMap.mem_ker.2 <| matrix_trace_commutator_zero _ _ _ _ }", "start": [95, 1], "end": [98, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.SpecialLinear.sl_bracket", "code": "theorem sl_bracket [Fintype n] (A B : sl n R) : \u2045A, B\u2046.val = A.val * B.val - B.val * A.val", "start": [101, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.SpecialLinear.Eb", "code": "def Eb (h : j \u2260 i) : sl n R :=\n  \u27e8Matrix.stdBasisMatrix i j (1 : R),\n    show Matrix.stdBasisMatrix i j (1 : R) \u2208 LinearMap.ker (Matrix.traceLinearMap n R R) from\n      Matrix.StdBasisMatrix.trace_zero i j (1 : R) h\u27e9", "start": [109, 1], "end": [114, 54], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.SpecialLinear.eb_val", "code": "@[simp]\ntheorem eb_val (h : j \u2260 i) : (Eb R i j h).val = Matrix.stdBasisMatrix i j 1", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.SpecialLinear.sl_non_abelian", "code": "theorem sl_non_abelian [Fintype n] [Nontrivial R] (h : 1 < Fintype.card n) :\n    \u00acIsLieAbelian (sl n R)", "start": [124, 1], "end": [132, 83], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Symplectic.sp", "code": "def sp [Fintype l] : LieSubalgebra R (Matrix (Sum l l) (Sum l l) R) :=\n  skewAdjointMatricesLieSubalgebra (Matrix.J l R)", "start": [139, 1], "end": [142, 50], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.so", "code": "def so [Fintype n] : LieSubalgebra R (Matrix n n R) :=\n  skewAdjointMatricesLieSubalgebra (1 : Matrix n n R)", "start": [149, 1], "end": [152, 54], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.mem_so", "code": "@[simp]\ntheorem mem_so [Fintype n] (A : Matrix n n R) : A \u2208 so n R \u2194 A\u1d40 = -A", "start": [155, 1], "end": [158, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.indefiniteDiagonal", "code": "def indefiniteDiagonal : Matrix (Sum p q) (Sum p q) R :=\n  Matrix.diagonal <| Sum.elim (fun _ => 1) fun _ => -1", "start": [161, 1], "end": [163, 55], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.so'", "code": "def so' [Fintype p] [Fintype q] : LieSubalgebra R (Matrix (Sum p q) (Sum p q) R) :=\n  skewAdjointMatricesLieSubalgebra <| indefiniteDiagonal p q R", "start": [166, 1], "end": [169, 63], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.Pso", "code": "def Pso (i : R) : Matrix (Sum p q) (Sum p q) R :=\n  Matrix.diagonal <| Sum.elim (fun _ => 1) fun _ => i", "start": [172, 1], "end": [175, 54], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.pso_inv", "code": "theorem pso_inv {i : R} (hi : i * i = -1) : Pso p q R i * Pso p q R (-i) = 1", "start": [180, 1], "end": [191, 42], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.invertiblePso", "code": "def invertiblePso {i : R} (hi : i * i = -1) : Invertible (Pso p q R i) :=\n  invertibleOfRightInverse _ _ (pso_inv p q R hi)", "start": [194, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.indefiniteDiagonal_transform", "code": "theorem indefiniteDiagonal_transform {i : R} (hi : i * i = -1) :\n    (Pso p q R i)\u1d40 * indefiniteDiagonal p q R * Pso p q R i = 1", "start": [199, 1], "end": [211, 42], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.soIndefiniteEquiv", "code": "def soIndefiniteEquiv {i : R} (hi : i * i = -1) : so' p q R \u2243\u2097\u2045R\u2046 so (Sum p q) R := by\n  apply\n    (skewAdjointMatricesLieSubalgebraEquiv (indefiniteDiagonal p q R) (Pso p q R i)\n        (invertiblePso p q R hi)).trans\n  apply LieEquiv.ofEq\n  ext A; rw [indefiniteDiagonal_transform p q R hi]; rfl", "start": [214, 1], "end": [221, 57], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.soIndefiniteEquiv_apply", "code": "theorem soIndefiniteEquiv_apply {i : R} (hi : i * i = -1) (A : so' p q R) :\n    (soIndefiniteEquiv p q R hi A : Matrix (Sum p q) (Sum p q) R) =\n      (Pso p q R i)\u207b\u00b9 * (A : Matrix (Sum p q) (Sum p q) R) * Pso p q R i", "start": [224, 1], "end": [229, 52], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.JD", "code": "def JD : Matrix (Sum l l) (Sum l l) R :=\n  Matrix.fromBlocks 0 1 1 0", "start": [232, 1], "end": [240, 28], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.typeD", "code": "def typeD [Fintype l] :=\n  skewAdjointMatricesLieSubalgebra (JD l R)", "start": [243, 1], "end": [246, 44], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.PD", "code": "def PD : Matrix (Sum l l) (Sum l l) R :=\n  Matrix.fromBlocks 1 (-1) 1 1", "start": [249, 1], "end": [258, 31], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.S", "code": "def S :=\n  indefiniteDiagonal l l R", "start": [261, 1], "end": [263, 27], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.s_as_blocks", "code": "theorem s_as_blocks : S l R = Matrix.fromBlocks 1 0 0 (-1)", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.jd_transform", "code": "theorem jd_transform [Fintype l] : (PD l R)\u1d40 * JD l R * PD l R = (2 : R) \u2022 S l R", "start": [271, 1], "end": [276, 18], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.pd_inv", "code": "theorem pd_inv [Fintype l] [Invertible (2 : R)] : PD l R * \u215f (2 : R) \u2022 (PD l R)\u1d40 = 1", "start": [279, 1], "end": [282, 7], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.invertiblePD", "code": "instance invertiblePD [Fintype l] [Invertible (2 : R)] : Invertible (PD l R) :=\n  invertibleOfRightInverse _ _ (pd_inv l R)", "start": [285, 1], "end": [286, 44], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.typeDEquivSo'", "code": "def typeDEquivSo' [Fintype l] [Invertible (2 : R)] : typeD l R \u2243\u2097\u2045R\u2046 so' l l R := by\n  apply (skewAdjointMatricesLieSubalgebraEquiv (JD l R) (PD l R) (by infer_instance)).trans\n  apply LieEquiv.ofEq\n  ext A\n  rw [jd_transform, \u2190 val_unitOfInvertible (2 : R), \u2190 Units.smul_def, LieSubalgebra.mem_coe,\n    mem_skewAdjointMatricesLieSubalgebra_unit_smul]\n  rfl", "start": [289, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.JB", "code": "def JB :=\n  Matrix.fromBlocks ((2 : R) \u2022 (1 : Matrix Unit Unit R)) 0 0 (JD l R)", "start": [299, 1], "end": [314, 70], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.typeB", "code": "def typeB [Fintype l] :=\n  skewAdjointMatricesLieSubalgebra (JB l R)", "start": [317, 1], "end": [320, 44], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.PB", "code": "def PB :=\n  Matrix.fromBlocks (1 : Matrix Unit Unit R) 0 0 (PD l R)", "start": [323, 1], "end": [339, 58], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.pb_inv", "code": "theorem pb_inv [Invertible (2 : R)] : PB l R * Matrix.fromBlocks 1 0 0 (\u215f (PD l R)) = 1", "start": [344, 1], "end": [347, 27], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.invertiblePB", "code": "instance invertiblePB [Invertible (2 : R)] : Invertible (PB l R) :=\n  invertibleOfRightInverse _ _ (pb_inv l R)", "start": [350, 1], "end": [351, 44], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.jb_transform", "code": "theorem jb_transform : (PB l R)\u1d40 * JB l R * PB l R = (2 : R) \u2022 Matrix.fromBlocks 1 0 0 (S l R)", "start": [354, 1], "end": [356, 28], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.indefiniteDiagonal_assoc", "code": "theorem indefiniteDiagonal_assoc :\n    indefiniteDiagonal (Sum Unit l) l R =\n      Matrix.reindexLieEquiv (Equiv.sumAssoc Unit l l).symm\n        (Matrix.fromBlocks 1 0 0 (indefiniteDiagonal l l R))", "start": [359, 1], "end": [371, 12], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.Orthogonal.typeBEquivSo'", "code": "def typeBEquivSo' [Invertible (2 : R)] : typeB l R \u2243\u2097\u2045R\u2046 so' (Sum Unit l) l R := by\n  apply (skewAdjointMatricesLieSubalgebraEquiv (JB l R) (PB l R) (by infer_instance)).trans\n  symm\n  apply\n    (skewAdjointMatricesLieSubalgebraEquivTranspose (indefiniteDiagonal (Sum Unit l) l R)\n        (Matrix.reindexAlgEquiv _ (Equiv.sumAssoc PUnit l l)) (Matrix.transpose_reindex _ _)).trans\n  apply LieEquiv.ofEq\n  ext A\n  rw [jb_transform, \u2190 val_unitOfInvertible (2 : R), \u2190 Units.smul_def, LieSubalgebra.mem_coe,\n    LieSubalgebra.mem_coe, mem_skewAdjointMatricesLieSubalgebra_unit_smul]\n  simp [indefiniteDiagonal_assoc, S]", "start": [374, 1], "end": [385, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/FunctionField.lean", "imports": ["Mathlib/AlgebraicGeometry/Properties.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.Scheme.functionField", "code": "noncomputable abbrev Scheme.functionField [IrreducibleSpace X.carrier] : CommRingCat :=\n  X.presheaf.stalk (genericPoint X.carrier)", "start": [32, 1], "end": [35, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.germToFunctionField", "code": "noncomputable abbrev Scheme.germToFunctionField [IrreducibleSpace X.carrier] (U : Opens X.carrier)\n    [h : Nonempty U] : X.presheaf.obj (op U) \u27f6 X.functionField :=\n  X.presheaf.germ\n    \u27e8genericPoint X.carrier,\n      ((genericPoint_spec X.carrier).mem_open_set_iff U.isOpen).mpr (by simpa using h)\u27e9", "start": [38, 1], "end": [43, 88], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.germ_injective_of_isIntegral", "code": "theorem germ_injective_of_isIntegral [IsIntegral X] {U : Opens X.carrier} (x : U) :\n    Function.Injective (X.presheaf.germ x)", "start": [65, 1], "end": [73, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.germToFunctionField_injective", "code": "theorem Scheme.germToFunctionField_injective [IsIntegral X] (U : Opens X.carrier) [Nonempty U] :\n    Function.Injective (X.germToFunctionField U)", "start": [76, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.genericPoint_eq_of_isOpenImmersion", "code": "theorem genericPoint_eq_of_isOpenImmersion {X Y : Scheme} (f : X \u27f6 Y) [H : IsOpenImmersion f]\n    [hX : IrreducibleSpace X.carrier] [IrreducibleSpace Y.carrier] :\n    f.1.base (genericPoint X.carrier : _) = (genericPoint Y.carrier : _)", "start": [81, 1], "end": [93, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.stalkFunctionFieldAlgebra", "code": "noncomputable instance stalkFunctionFieldAlgebra [IrreducibleSpace X.carrier] (x : X.carrier) :\n    Algebra (X.presheaf.stalk x) X.functionField := by\n  apply RingHom.toAlgebra\n  exact X.presheaf.stalkSpecializes ((genericPoint_spec X.carrier).specializes trivial)", "start": [96, 1], "end": [99, 88], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.functionField_isScalarTower", "code": "instance functionField_isScalarTower [IrreducibleSpace X.carrier] (U : Opens X.carrier) (x : U)\n    [Nonempty U] : IsScalarTower (X.presheaf.obj <| op U) (X.presheaf.stalk x) X.functionField := by\n  apply IsScalarTower.of_algebraMap_eq'\n  simp_rw [RingHom.algebraMap_toAlgebra]\n  change _ = X.presheaf.germ x \u226b _\n  rw [X.presheaf.germ_stalkSpecializes]", "start": [102, 1], "end": [107, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.genericPoint_eq_bot_of_affine", "code": "@[simp]\ntheorem genericPoint_eq_bot_of_affine (R : CommRingCat) [IsDomain R] :\n    genericPoint (Scheme.Spec.obj <| op R).carrier = (\u27e80, Ideal.bot_prime\u27e9 : PrimeSpectrum R)", "start": [114, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.functionField_isFractionRing_of_affine", "code": "instance functionField_isFractionRing_of_affine (R : CommRingCat.{u}) [IsDomain R] :\n    IsFractionRing R (Scheme.Spec.obj <| op R).functionField := by\n  convert StructureSheaf.IsLocalization.to_stalk R (genericPoint _)\n  delta IsFractionRing IsLocalization.AtPrime\n  apply Eq.to_iff\n  congr 1\n  rw [genericPoint_eq_bot_of_affine]\n  ext\n  exact mem_nonZeroDivisors_iff_ne_zero", "start": [124, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsAffineOpen.primeIdealOf_genericPoint", "code": "theorem IsAffineOpen.primeIdealOf_genericPoint {X : Scheme} [IsIntegral X] {U : Opens X.carrier}\n    (hU : IsAffineOpen U) [h : Nonempty U] :\n    hU.primeIdealOf\n        \u27e8genericPoint X.carrier,\n          ((genericPoint_spec X.carrier).mem_open_set_iff U.isOpen).mpr (by simpa using h)\u27e9 =\n      genericPoint (Scheme.Spec.obj <| op <| X.presheaf.obj <| op U).carrier", "start": [141, 1], "end": [158, 81], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.functionField_isFractionRing_of_isAffineOpen", "code": "theorem functionField_isFractionRing_of_isAffineOpen [IsIntegral X] (U : Opens X.carrier)\n    (hU : IsAffineOpen U) [hU' : Nonempty U] :\n    IsFractionRing (X.presheaf.obj <| op U) X.functionField", "start": [161, 1], "end": [172, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean", "imports": ["Mathlib/Geometry/Manifold/ContMDiffMap.lean", "Mathlib/Geometry/Manifold/MFDeriv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContMDiffAt.mfderiv", "code": "protected theorem ContMDiffAt.mfderiv {x\u2080 : N} (f : N \u2192 M \u2192 M') (g : N \u2192 M)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (x\u2080, g x\u2080)) (hg : ContMDiffAt J I m g x\u2080)\n    (hmn : m + 1 \u2264 n) :\n    ContMDiffAt J \ud835\udcd8(\ud835\udd5c, E \u2192L[\ud835\udd5c] E') m\n      (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) x\u2080)\n      x\u2080", "start": [68, 1], "end": [182, 35], "kind": "commanddeclaration"}, {"full_name": "ContMDiffAt.mfderiv_const", "code": "theorem ContMDiffAt.mfderiv_const {x\u2080 : M} {f : M \u2192 M'} (hf : ContMDiffAt I I' n f x\u2080)\n    (hmn : m + 1 \u2264 n) :\n    ContMDiffAt I \ud835\udcd8(\ud835\udd5c, E \u2192L[\ud835\udd5c] E') m (inTangentCoordinates I I' id f (mfderiv I I' f) x\u2080) x\u2080", "start": [185, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "ContMDiffAt.mfderiv_apply", "code": "theorem ContMDiffAt.mfderiv_apply {x\u2080 : N'} (f : N \u2192 M \u2192 M') (g : N \u2192 M) (g\u2081 : N' \u2192 N) (g\u2082 : N' \u2192 E)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (g\u2081 x\u2080, g (g\u2081 x\u2080)))\n    (hg : ContMDiffAt J I m g (g\u2081 x\u2080)) (hg\u2081 : ContMDiffAt J' J m g\u2081 x\u2080)\n    (hg\u2082 : ContMDiffAt J' \ud835\udcd8(\ud835\udd5c, E) m g\u2082 x\u2080) (hmn : m + 1 \u2264 n) :\n    ContMDiffAt J' \ud835\udcd8(\ud835\udd5c, E') m\n      (fun x => inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderiv I I' (f x) (g x)) (g\u2081 x\u2080) (g\u2081 x) (g\u2082 x)) x\u2080", "start": [199, 1], "end": [214, 61], "kind": "commanddeclaration"}, {"full_name": "ContMDiffOn.continuousOn_tangentMapWithin_aux", "code": "theorem ContMDiffOn.continuousOn_tangentMapWithin_aux {f : H \u2192 H'} {s : Set H}\n    (hf : ContMDiffOn I I' n f s) (hn : 1 \u2264 n) (hs : UniqueMDiffOn I s) :\n    ContinuousOn (tangentMapWithin I I' f s) (\u03c0 E (TangentSpace I) \u207b\u00b9' s)", "start": [223, 1], "end": [280, 37], "kind": "commanddeclaration"}, {"full_name": "ContMDiffOn.contMDiffOn_tangentMapWithin_aux", "code": "theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H \u2192 H'} {s : Set H}\n    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 \u2264 n) (hs : UniqueMDiffOn I s) :\n    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)\n      (\u03c0 E (TangentSpace I) \u207b\u00b9' s)", "start": [283, 1], "end": [339, 70], "kind": "commanddeclaration"}, {"full_name": "ContMDiffOn.contMDiffOn_tangentMapWithin", "code": "theorem ContMDiffOn.contMDiffOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : m + 1 \u2264 n)\n    (hs : UniqueMDiffOn I s) :\n    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)\n      (\u03c0 E (TangentSpace I) \u207b\u00b9' s)", "start": [342, 1], "end": [512, 39], "kind": "commanddeclaration"}, {"full_name": "ContMDiffOn.continuousOn_tangentMapWithin", "code": "theorem ContMDiffOn.continuousOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : 1 \u2264 n)\n    (hs : UniqueMDiffOn I s) :\n    ContinuousOn (tangentMapWithin I I' f s) (\u03c0 E (TangentSpace I) \u207b\u00b9' s)", "start": [515, 1], "end": [523, 20], "kind": "commanddeclaration"}, {"full_name": "ContMDiff.contMDiff_tangentMap", "code": "theorem ContMDiff.contMDiff_tangentMap (hf : ContMDiff I I' n f) (hmn : m + 1 \u2264 n) :\n    ContMDiff I.tangent I'.tangent m (tangentMap I I' f)", "start": [526, 1], "end": [531, 29], "kind": "commanddeclaration"}, {"full_name": "ContMDiff.continuous_tangentMap", "code": "theorem ContMDiff.continuous_tangentMap (hf : ContMDiff I I' n f) (hmn : 1 \u2264 n) :\n    Continuous (tangentMap I I' f)", "start": [534, 1], "end": [540, 29], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.tangentMap_tangentBundle_pure", "code": "theorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :\n    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = \u27e8\u27e8p.proj, 0\u27e9, \u27e8p.2, 0\u27e9\u27e9", "start": [551, 1], "end": [593, 44], "kind": "commanddeclaration"}, {"full_name": "ContMDiffMap.mdifferentiable'", "code": "protected theorem mdifferentiable' (f : C^n\u27eeI, M; I', M'\u27ef) (hn : 1 \u2264 n) : MDifferentiable I I' f", "start": [606, 1], "end": [607, 33], "kind": "commanddeclaration"}, {"full_name": "ContMDiffMap.mdifferentiable", "code": "protected theorem mdifferentiable (f : C^\u221e\u27eeI, M; I', M'\u27ef) : MDifferentiable I I' f", "start": [610, 1], "end": [611, 37], "kind": "commanddeclaration"}, {"full_name": "ContMDiffMap.mdifferentiableAt", "code": "protected theorem mdifferentiableAt (f : C^\u221e\u27eeI, M; I', M'\u27ef) {x} : MDifferentiableAt I I' f x", "start": [614, 1], "end": [615, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/HalesJewett.lean", "imports": ["Mathlib/Data/Fintype/Sum.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Fintype/Pi.lean", "Mathlib/Data/Fintype/Option.lean"], "premises": [{"full_name": "Combinatorics.Line", "code": "structure Line (\u03b1 \u03b9 : Type*) where\n  \n  idxFun : \u03b9 \u2192 Option \u03b1\n  \n  proper : \u2203 i, idxFun i = none", "start": [71, 1], "end": [87, 32], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.IsMono", "code": "def IsMono {\u03b1 \u03b9 \u03ba} (C : (\u03b9 \u2192 \u03b1) \u2192 \u03ba) (l : Line \u03b1 \u03b9) : Prop :=\n  \u2203 c, \u2200 x, C (l x) = c", "start": [96, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.diagonal", "code": "def diagonal (\u03b1 \u03b9) [Nonempty \u03b9] : Line \u03b1 \u03b9 where\n  idxFun _ := none\n  proper := \u27e8Classical.arbitrary \u03b9, rfl\u27e9", "start": [101, 1], "end": [104, 41], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.AlmostMono", "code": "structure AlmostMono {\u03b1 \u03b9 \u03ba : Type*} (C : (\u03b9 \u2192 Option \u03b1) \u2192 \u03ba) where\n  \n  line : Line (Option \u03b1) \u03b9\n  \n  color : \u03ba\n  \n  has_color : \u2200 x : \u03b1, C (line (some x)) = color", "start": [110, 1], "end": [119, 49], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.ColorFocused", "code": "structure ColorFocused {\u03b1 \u03b9 \u03ba : Type*} (C : (\u03b9 \u2192 Option \u03b1) \u2192 \u03ba) where\n  \n  lines : Multiset (AlmostMono C)\n  \n  focus : \u03b9 \u2192 Option \u03b1\n  \n  is_focused : \u2200 p \u2208 lines, p.line none = focus\n  \n  distinct_colors : (lines.map AlmostMono.color).Nodup", "start": [128, 1], "end": [141, 55], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.map", "code": "def map {\u03b1 \u03b1' \u03b9} (f : \u03b1 \u2192 \u03b1') (l : Line \u03b1 \u03b9) : Line \u03b1' \u03b9 where\n  idxFun i := (l.idxFun i).map f\n  proper := \u27e8l.proper.choose, by simp only [l.proper.choose_spec, Option.map_none']\u27e9", "start": [148, 1], "end": [152, 85], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.vertical", "code": "def vertical {\u03b1 \u03b9 \u03b9'} (v : \u03b9 \u2192 \u03b1) (l : Line \u03b1 \u03b9') : Line \u03b1 (Sum \u03b9 \u03b9') where\n  idxFun := Sum.elim (some \u2218 v) l.idxFun\n  proper := \u27e8Sum.inr l.proper.choose, l.proper.choose_spec\u27e9", "start": [155, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.horizontal", "code": "def horizontal {\u03b1 \u03b9 \u03b9'} (l : Line \u03b1 \u03b9) (v : \u03b9' \u2192 \u03b1) : Line \u03b1 (Sum \u03b9 \u03b9') where\n  idxFun := Sum.elim l.idxFun (some \u2218 v)\n  proper := \u27e8Sum.inl l.proper.choose, l.proper.choose_spec\u27e9", "start": [161, 1], "end": [164, 60], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.prod", "code": "def prod {\u03b1 \u03b9 \u03b9'} (l : Line \u03b1 \u03b9) (l' : Line \u03b1 \u03b9') : Line \u03b1 (Sum \u03b9 \u03b9') where\n  idxFun := Sum.elim l.idxFun l'.idxFun\n  proper := \u27e8Sum.inl l.proper.choose, l.proper.choose_spec\u27e9", "start": [167, 1], "end": [170, 60], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.apply", "code": "theorem apply {\u03b1 \u03b9} (l : Line \u03b1 \u03b9) (x : \u03b1) : l x = fun i => (l.idxFun i).getD x", "start": [173, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.apply_none", "code": "theorem apply_none {\u03b1 \u03b9} (l : Line \u03b1 \u03b9) (x : \u03b1) (i : \u03b9) (h : l.idxFun i = none) : l x i = x", "start": [177, 1], "end": [178, 43], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.apply_of_ne_none", "code": "theorem apply_of_ne_none {\u03b1 \u03b9} (l : Line \u03b1 \u03b9) (x : \u03b1) (i : \u03b9) (h : l.idxFun i \u2260 none) :\n    some (l x i) = l.idxFun i", "start": [181, 1], "end": [182, 75], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.map_apply", "code": "@[simp]\ntheorem map_apply {\u03b1 \u03b1' \u03b9} (f : \u03b1 \u2192 \u03b1') (l : Line \u03b1 \u03b9) (x : \u03b1) : l.map f (f x) = f \u2218 l x", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.vertical_apply", "code": "@[simp]\ntheorem vertical_apply {\u03b1 \u03b9 \u03b9'} (v : \u03b9 \u2192 \u03b1) (l : Line \u03b1 \u03b9') (x : \u03b1) :\n    l.vertical v x = Sum.elim v (l x)", "start": [191, 1], "end": [195, 18], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.horizontal_apply", "code": "@[simp]\ntheorem horizontal_apply {\u03b1 \u03b9 \u03b9'} (l : Line \u03b1 \u03b9) (v : \u03b9' \u2192 \u03b1) (x : \u03b1) :\n    l.horizontal v x = Sum.elim (l x) v", "start": [198, 1], "end": [202, 18], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.prod_apply", "code": "@[simp]\ntheorem prod_apply {\u03b1 \u03b9 \u03b9'} (l : Line \u03b1 \u03b9) (l' : Line \u03b1 \u03b9') (x : \u03b1) :\n    l.prod l' x = Sum.elim (l x) (l' x)", "start": [205, 1], "end": [209, 18], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.diagonal_apply", "code": "@[simp]\ntheorem diagonal_apply {\u03b1 \u03b9} [Nonempty \u03b9] (x : \u03b1) : Line.diagonal \u03b1 \u03b9 x = fun _ => x", "start": [212, 1], "end": [214, 44], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.exists_mono_in_high_dimension'", "code": "private theorem exists_mono_in_high_dimension' :\n    \u2200 (\u03b1 : Type u) [Finite \u03b1] (\u03ba : Type max v u) [Finite \u03ba],\n      \u2203 (\u03b9 : Type) (_ : Fintype \u03b9), \u2200 C : (\u03b9 \u2192 \u03b1) \u2192 \u03ba, \u2203 l : Line \u03b1 \u03b9, l.IsMono C", "start": [217, 1], "end": [323, 54], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.Line.exists_mono_in_high_dimension", "code": "theorem exists_mono_in_high_dimension (\u03b1 : Type u) [Finite \u03b1] (\u03ba : Type v) [Finite \u03ba] :\n    \u2203 (\u03b9 : Type) (_ : Fintype \u03b9), \u2200 C : (\u03b9 \u2192 \u03b1) \u2192 \u03ba, \u2203 l : Line \u03b1 \u03b9, l.IsMono C", "start": [327, 1], "end": [334, 63], "kind": "commanddeclaration"}, {"full_name": "Combinatorics.exists_mono_homothetic_copy", "code": "theorem exists_mono_homothetic_copy {M \u03ba : Type*} [AddCommMonoid M] (S : Finset M) [Finite \u03ba]\n    (C : M \u2192 \u03ba) : \u2203 a > 0, \u2203 (b : M) (c : \u03ba), \u2200 s \u2208 S, C (a \u2022 s + b) = c", "start": [339, 1], "end": [367, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/ZeroAtInfty.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Topology/ContinuousFunction/CocompactMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZeroAtInftyContinuousMap", "code": "structure ZeroAtInftyContinuousMap (\u03b1 : Type u) (\u03b2 : Type v) [TopologicalSpace \u03b1] [Zero \u03b2]\n    [TopologicalSpace \u03b2] extends ContinuousMap \u03b1 \u03b2 : Type max u v where\n  \n  zero_at_infty' : Tendsto toFun (cocompact \u03b1) (\ud835\udcdd 0)", "start": [35, 1], "end": [45, 53], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMapClass", "code": "class ZeroAtInftyContinuousMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1]\n    [Zero \u03b2] [TopologicalSpace \u03b2] extends ContinuousMapClass F \u03b1 \u03b2 where\n  \n  zero_at_infty (f : F) : Tendsto f (cocompact \u03b1) (\ud835\udcdd 0)", "start": [58, 1], "end": [65, 56], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instZeroAtInftyContinuousMapClass", "code": "instance instZeroAtInftyContinuousMapClass : ZeroAtInftyContinuousMapClass C\u2080(\u03b1, \u03b2) \u03b1 \u03b2 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8_, _\u27e9, _\u27e9 := f\n    obtain \u27e8\u27e8_, _\u27e9, _\u27e9 := g\n    congr\n  map_continuous f := f.continuous_toFun\n  zero_at_infty f := f.zero_at_infty'", "start": [78, 1], "end": [85, 38], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instCoeFun", "code": "instance instCoeFun : CoeFun C\u2080(\u03b1, \u03b2) fun _ => \u03b1 \u2192 \u03b2 :=\n  FunLike.hasCoeToFun", "start": [87, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instCoeTC", "code": "instance instCoeTC : CoeTC F C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun f =>\n    { toFun := f\n      continuous_toFun := map_continuous f\n      zero_at_infty' := zero_at_infty f }\u27e9", "start": [92, 1], "end": [96, 43], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_toContinuousMap", "code": "@[simp]\ntheorem coe_toContinuousMap (f : C\u2080(\u03b1, \u03b2)) : (f.toContinuousMap : \u03b1 \u2192 \u03b2) = f", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.ext", "code": "@[ext]\ntheorem ext {f g : C\u2080(\u03b1, \u03b2)} (h : \u2200 x, f x = g x) : f = g", "start": [103, 1], "end": [105, 20], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.copy", "code": "protected def copy (f : C\u2080(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : C\u2080(\u03b1, \u03b2) where\n  toFun := f'\n  continuous_toFun := by\n    rw [h]\n    exact f.continuous_toFun\n  zero_at_infty' := by\n    simp_rw [h]\n    exact f.zero_at_infty'", "start": [108, 1], "end": [117, 27], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : C\u2080(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.copy_eq", "code": "theorem copy_eq (f : C\u2080(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [125, 1], "end": [126, 17], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.eq_of_empty", "code": "theorem eq_of_empty [IsEmpty \u03b1] (f g : C\u2080(\u03b1, \u03b2)) : f = g", "start": [129, 1], "end": [130, 26], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.ContinuousMap.liftZeroAtInfty", "code": "@[simps]\ndef ContinuousMap.liftZeroAtInfty [CompactSpace \u03b1] : C(\u03b1, \u03b2) \u2243 C\u2080(\u03b1, \u03b2) where\n  toFun f :=\n    { toFun := f\n      continuous_toFun := f.continuous\n      zero_at_infty' := by simp }\n  invFun f := f\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl", "start": [133, 1], "end": [147, 8], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.zeroAtInftyContinuousMapClass.ofCompact", "code": "def zeroAtInftyContinuousMapClass.ofCompact {G : Type*} [ContinuousMapClass G \u03b1 \u03b2]\n    [CompactSpace \u03b1] : ZeroAtInftyContinuousMapClass G \u03b1 \u03b2 where\n  coe g := g\n  coe_injective' f g h := FunLike.coe_fn_eq.mp h\n  map_continuous := map_continuous\n  zero_at_infty := by simp", "start": [150, 1], "end": [157, 27], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instZero", "code": "instance instZero [Zero \u03b2] : Zero C\u2080(\u03b1, \u03b2) :=\n  \u27e8\u27e80, tendsto_const_nhds\u27e9\u27e9", "start": [174, 1], "end": [175, 28], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instInhabited", "code": "instance instInhabited [Zero \u03b2] : Inhabited C\u2080(\u03b1, \u03b2) :=\n  \u27e80\u27e9", "start": [177, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_zero", "code": "@[simp]\ntheorem coe_zero [Zero \u03b2] : \u21d1(0 : C\u2080(\u03b1, \u03b2)) = 0", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.zero_apply", "code": "theorem zero_apply [Zero \u03b2] : (0 : C\u2080(\u03b1, \u03b2)) x = 0", "start": [185, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instMul", "code": "instance instMul [MulZeroClass \u03b2] [ContinuousMul \u03b2] : Mul C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun f g =>\n    \u27e8f * g, by simpa only [mul_zero] using (zero_at_infty f).mul (zero_at_infty g)\u27e9\u27e9", "start": [189, 1], "end": [191, 85], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_mul", "code": "@[simp]\ntheorem coe_mul [MulZeroClass \u03b2] [ContinuousMul \u03b2] (f g : C\u2080(\u03b1, \u03b2)) : \u21d1(f * g) = f * g", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.mul_apply", "code": "theorem mul_apply [MulZeroClass \u03b2] [ContinuousMul \u03b2] (f g : C\u2080(\u03b1, \u03b2)) : (f * g) x = f x * g x", "start": [198, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instMulZeroClass", "code": "instance instMulZeroClass [MulZeroClass \u03b2] [ContinuousMul \u03b2] : MulZeroClass C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.mulZeroClass _ coe_zero coe_mul", "start": [202, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instSemigroupWithZero", "code": "instance instSemigroupWithZero [SemigroupWithZero \u03b2] [ContinuousMul \u03b2] :\n    SemigroupWithZero C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.semigroupWithZero _ coe_zero coe_mul", "start": [205, 1], "end": [207, 61], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAdd", "code": "instance instAdd [AddZeroClass \u03b2] [ContinuousAdd \u03b2] : Add C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun f g => \u27e8f + g, by simpa only [add_zero] using (zero_at_infty f).add (zero_at_infty g)\u27e9\u27e9", "start": [209, 1], "end": [210, 95], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_add", "code": "@[simp]\ntheorem coe_add [AddZeroClass \u03b2] [ContinuousAdd \u03b2] (f g : C\u2080(\u03b1, \u03b2)) : \u21d1(f + g) = f + g", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.add_apply", "code": "theorem add_apply [AddZeroClass \u03b2] [ContinuousAdd \u03b2] (f g : C\u2080(\u03b1, \u03b2)) : (f + g) x = f x + g x", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAddZeroClass", "code": "instance instAddZeroClass [AddZeroClass \u03b2] [ContinuousAdd \u03b2] : AddZeroClass C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.addZeroClass _ coe_zero coe_add", "start": [221, 1], "end": [222, 56], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_nsmulRec", "code": "@[simp]\ntheorem coe_nsmulRec : \u2200 n, \u21d1(nsmulRec n f) = n \u2022 \u21d1f", "start": [228, 1], "end": [231, 67], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNatSMul", "code": "instance instNatSMul : SMul \u2115 C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun n f => \u27e8n \u2022 (f : C(\u03b1, \u03b2)),\n    by simpa [coe_nsmulRec] using zero_at_infty (nsmulRec n f)\u27e9\u27e9", "start": [234, 1], "end": [236, 65], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAddMonoid", "code": "instance instAddMonoid : AddMonoid C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.addMonoid _ coe_zero coe_add fun _ _ => rfl", "start": [239, 1], "end": [240, 68], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAddCommMonoid", "code": "instance instAddCommMonoid [AddCommMonoid \u03b2] [ContinuousAdd \u03b2] : AddCommMonoid C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.addCommMonoid _ coe_zero coe_add fun _ _ => rfl", "start": [244, 1], "end": [245, 72], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNeg", "code": "instance instNeg : Neg C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun f => \u27e8-f, by simpa only [neg_zero] using (zero_at_infty f).neg\u27e9\u27e9", "start": [251, 1], "end": [252, 72], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_neg", "code": "@[simp]\ntheorem coe_neg : \u21d1(-f) = -f", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.neg_apply", "code": "theorem neg_apply : (-f) x = -f x", "start": [259, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instSub", "code": "instance instSub : Sub C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun f g => \u27e8f - g, by simpa only [sub_zero] using (zero_at_infty f).sub (zero_at_infty g)\u27e9\u27e9", "start": [263, 1], "end": [264, 95], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_sub", "code": "@[simp]\ntheorem coe_sub : \u21d1(f - g) = f - g", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.sub_apply", "code": "theorem sub_apply : (f - g) x = f x - g x", "start": [271, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_zsmulRec", "code": "@[simp]\ntheorem coe_zsmulRec : \u2200 z, \u21d1(zsmulRec z f) = z \u2022 \u21d1f", "start": [275, 1], "end": [278, 76], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instIntSMul", "code": "instance instIntSMul : SMul \u2124 C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun n f => \u27e8\u27e8n \u2022 \u21d1f, Continuous.const_smul f.continuous n\u27e9,\n    by simpa using zero_at_infty (zsmulRec n f)\u27e9\u27e9", "start": [281, 1], "end": [284, 50], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAddGroup", "code": "instance instAddGroup : AddGroup C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.addGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl) fun _ _ => rfl", "start": [287, 1], "end": [288, 100], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instAddCommGroup", "code": "instance instAddCommGroup [AddCommGroup \u03b2] [TopologicalAddGroup \u03b2] : AddCommGroup C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.addCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl) fun _ _ =>\n    rfl", "start": [292, 1], "end": [294, 8], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instSMul", "code": "instance instSMul [Zero \u03b2] {R : Type*} [Zero R] [SMulWithZero R \u03b2] [ContinuousConstSMul R \u03b2] :\n    SMul R C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun r f => \u27e8\u27e8r \u2022 \u21d1f, Continuous.const_smul f.continuous r\u27e9,\n    by simpa [smul_zero] using (zero_at_infty f).const_smul r\u27e9\u27e9", "start": [296, 1], "end": [300, 64], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_smul", "code": "@[simp]\ntheorem coe_smul [Zero \u03b2] {R : Type*} [Zero R] [SMulWithZero R \u03b2] [ContinuousConstSMul R \u03b2] (r : R)\n    (f : C\u2080(\u03b1, \u03b2)) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [302, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.smul_apply", "code": "theorem smul_apply [Zero \u03b2] {R : Type*} [Zero R] [SMulWithZero R \u03b2] [ContinuousConstSMul R \u03b2]\n    (r : R) (f : C\u2080(\u03b1, \u03b2)) (x : \u03b1) : (r \u2022 f) x = r \u2022 f x", "start": [308, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instIsCentralScalar", "code": "instance instIsCentralScalar [Zero \u03b2] {R : Type*} [Zero R] [SMulWithZero R \u03b2] [SMulWithZero R\u1d50\u1d52\u1d56 \u03b2]\n    [ContinuousConstSMul R \u03b2] [IsCentralScalar R \u03b2] : IsCentralScalar R C\u2080(\u03b1, \u03b2) :=\n  \u27e8fun _ _ => ext fun _ => op_smul_eq_smul _ _\u27e9", "start": [313, 1], "end": [315, 48], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instSMulWithZero", "code": "instance instSMulWithZero [Zero \u03b2] {R : Type*} [Zero R] [SMulWithZero R \u03b2]\n    [ContinuousConstSMul R \u03b2] : SMulWithZero R C\u2080(\u03b1, \u03b2) :=\n  Function.Injective.smulWithZero \u27e8_, coe_zero\u27e9 FunLike.coe_injective coe_smul", "start": [317, 1], "end": [319, 79], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instMulActionWithZero", "code": "instance instMulActionWithZero [Zero \u03b2] {R : Type*} [MonoidWithZero R] [MulActionWithZero R \u03b2]\n    [ContinuousConstSMul R \u03b2] : MulActionWithZero R C\u2080(\u03b1, \u03b2) :=\n  Function.Injective.mulActionWithZero \u27e8_, coe_zero\u27e9 FunLike.coe_injective coe_smul", "start": [321, 1], "end": [323, 84], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instModule", "code": "instance instModule [AddCommMonoid \u03b2] [ContinuousAdd \u03b2] {R : Type*} [Semiring R] [Module R \u03b2]\n    [ContinuousConstSMul R \u03b2] : Module R C\u2080(\u03b1, \u03b2) :=\n  Function.Injective.module R \u27e8\u27e8_, coe_zero\u27e9, coe_add\u27e9 FunLike.coe_injective coe_smul", "start": [325, 1], "end": [327, 86], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalNonAssocSemiring", "code": "instance instNonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring \u03b2] [TopologicalSemiring \u03b2] :\n    NonUnitalNonAssocSemiring C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalNonAssocSemiring _ coe_zero coe_add coe_mul fun _ _ => rfl", "start": [329, 1], "end": [331, 92], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalSemiring", "code": "instance instNonUnitalSemiring [NonUnitalSemiring \u03b2] [TopologicalSemiring \u03b2] :\n    NonUnitalSemiring C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalSemiring _ coe_zero coe_add coe_mul fun _ _ => rfl", "start": [333, 1], "end": [335, 84], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalCommSemiring", "code": "instance instNonUnitalCommSemiring [NonUnitalCommSemiring \u03b2] [TopologicalSemiring \u03b2] :\n    NonUnitalCommSemiring C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalCommSemiring _ coe_zero coe_add coe_mul fun _ _ => rfl", "start": [337, 1], "end": [339, 88], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalNonAssocRing", "code": "instance instNonUnitalNonAssocRing [NonUnitalNonAssocRing \u03b2] [TopologicalRing \u03b2] :\n    NonUnitalNonAssocRing C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalNonAssocRing _ coe_zero coe_add coe_mul coe_neg coe_sub\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [341, 1], "end": [344, 36], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalRing", "code": "instance instNonUnitalRing [NonUnitalRing \u03b2] [TopologicalRing \u03b2] : NonUnitalRing C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalRing _ coe_zero coe_add coe_mul coe_neg coe_sub (fun _ _ => rfl)\n    fun _ _ => rfl", "start": [346, 1], "end": [348, 19], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalCommRing", "code": "instance instNonUnitalCommRing [NonUnitalCommRing \u03b2] [TopologicalRing \u03b2] :\n    NonUnitalCommRing C\u2080(\u03b1, \u03b2) :=\n  FunLike.coe_injective.nonUnitalCommRing _ coe_zero coe_add coe_mul coe_neg coe_sub\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [350, 1], "end": [353, 36], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instIsScalarTower", "code": "instance instIsScalarTower {R : Type*} [Semiring R] [NonUnitalNonAssocSemiring \u03b2]\n    [TopologicalSemiring \u03b2] [Module R \u03b2] [ContinuousConstSMul R \u03b2] [IsScalarTower R \u03b2 \u03b2] :\n    IsScalarTower R C\u2080(\u03b1, \u03b2) C\u2080(\u03b1, \u03b2) where\n  smul_assoc r f g := by\n    ext\n    simp only [smul_eq_mul, coe_mul, coe_smul, Pi.mul_apply, Pi.smul_apply]\n    rw [\u2190 smul_eq_mul, \u2190 smul_eq_mul, smul_assoc]", "start": [355, 1], "end": [361, 50], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instSMulCommClass", "code": "instance instSMulCommClass {R : Type*} [Semiring R] [NonUnitalNonAssocSemiring \u03b2]\n    [TopologicalSemiring \u03b2] [Module R \u03b2] [ContinuousConstSMul R \u03b2] [SMulCommClass R \u03b2 \u03b2] :\n    SMulCommClass R C\u2080(\u03b1, \u03b2) C\u2080(\u03b1, \u03b2) where\n  smul_comm r f g := by\n    ext\n    simp only [smul_eq_mul, coe_smul, coe_mul, Pi.smul_apply, Pi.mul_apply]\n    rw [\u2190 smul_eq_mul, \u2190 smul_eq_mul, smul_comm]", "start": [363, 1], "end": [369, 49], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.uniformContinuous", "code": "theorem uniformContinuous (f : F) : UniformContinuous (f : \u03b2 \u2192 \u03b3)", "start": [377, 1], "end": [378, 78], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.bounded", "code": "protected theorem bounded (f : F) : \u2203 C, \u2200 x y : \u03b1, dist ((f : \u03b1 \u2192 \u03b2) x) (f y) \u2264 C", "start": [398, 1], "end": [409, 78], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.isBounded_range", "code": "theorem isBounded_range (f : C\u2080(\u03b1, \u03b2)) : IsBounded (range f)", "start": [412, 1], "end": [413, 61], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.isBounded_image", "code": "theorem isBounded_image (f : C\u2080(\u03b1, \u03b2)) (s : Set \u03b1) : IsBounded (f '' s)", "start": [416, 1], "end": [417, 53], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instBoundedContinuousMapClass", "code": "instance (priority := 100) instBoundedContinuousMapClass : BoundedContinuousMapClass F \u03b1 \u03b2 :=\n  { \u2039ZeroAtInftyContinuousMapClass F \u03b1 \u03b2\u203a with\n    map_bounded := fun f => ZeroAtInftyContinuousMap.bounded f }", "start": [420, 1], "end": [422, 65], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.toBcf", "code": "@[simps!]\ndef toBcf (f : C\u2080(\u03b1, \u03b2)) : \u03b1 \u2192\u1d47 \u03b2 :=\n  \u27e8f, map_bounded f\u27e9", "start": [424, 1], "end": [427, 21], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.toBcf_injective", "code": "theorem toBcf_injective : Function.Injective (toBcf : C\u2080(\u03b1, \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b2)", "start": [434, 1], "end": [436, 41], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instMetricSpace", "code": "noncomputable instance instMetricSpace : MetricSpace C\u2080(\u03b1, \u03b2) :=\n  MetricSpace.induced _ (toBcf_injective \u03b1 \u03b2) inferInstance", "start": [443, 1], "end": [446, 60], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.dist_toBcf_eq_dist", "code": "@[simp]\ntheorem dist_toBcf_eq_dist {f g : C\u2080(\u03b1, \u03b2)} : dist f.toBcf g.toBcf = dist f g", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.tendsto_iff_tendstoUniformly", "code": "theorem tendsto_iff_tendstoUniformly {\u03b9 : Type*} {F : \u03b9 \u2192 C\u2080(\u03b1, \u03b2)} {f : C\u2080(\u03b1, \u03b2)} {l : Filter \u03b9} :\n    Tendsto F l (\ud835\udcdd f) \u2194 TendstoUniformly (fun i => F i) f l", "start": [455, 1], "end": [460, 16], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.isometry_toBcf", "code": "theorem isometry_toBcf : Isometry (toBcf : C\u2080(\u03b1, \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b2)", "start": [463, 1], "end": [463, 74], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.closed_range_toBcf", "code": "theorem closed_range_toBcf : IsClosed (range (toBcf : C\u2080(\u03b1, \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b2))", "start": [466, 1], "end": [478, 41], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instCompleteSpace", "code": "instance instCompleteSpace [CompleteSpace \u03b2] : CompleteSpace C\u2080(\u03b1, \u03b2) :=\n  (completeSpace_iff_isComplete_range isometry_toBcf.uniformInducing).mpr\n    closed_range_toBcf.isComplete", "start": [481, 1], "end": [485, 34], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNormedAddCommGroup", "code": "noncomputable instance instNormedAddCommGroup : NormedAddCommGroup C\u2080(\u03b1, \u03b2) :=\n  NormedAddCommGroup.induced C\u2080(\u03b1, \u03b2) (\u03b1 \u2192\u1d47 \u03b2) (\u27e8\u27e8toBcf, rfl\u27e9, fun _ _ => rfl\u27e9 : C\u2080(\u03b1, \u03b2) \u2192+ \u03b1 \u2192\u1d47 \u03b2)\n    (toBcf_injective \u03b1 \u03b2)", "start": [503, 1], "end": [505, 26], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.norm_toBcf_eq_norm", "code": "@[simp]\ntheorem norm_toBcf_eq_norm {f : C\u2080(\u03b1, \u03b2)} : \u2016f.toBcf\u2016 = \u2016f\u2016", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNonUnitalNormedRing", "code": "noncomputable instance instNonUnitalNormedRing : NonUnitalNormedRing C\u2080(\u03b1, \u03b2) :=\n  { ZeroAtInftyContinuousMap.instNonUnitalRing, ZeroAtInftyContinuousMap.instNormedAddCommGroup with\n    norm_mul := fun f g => norm_mul_le f.toBcf g.toBcf }", "start": [520, 1], "end": [522, 57], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instStar", "code": "instance instStar : Star C\u2080(\u03b1, \u03b2) where\n  star f :=\n    { toFun := fun x => star (f x)\n      continuous_toFun := (map_continuous f).star\n      zero_at_infty' := by\n        simpa only [star_zero] using (continuous_star.tendsto (0 : \u03b2)).comp (zero_at_infty f) }", "start": [543, 1], "end": [548, 96], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_star", "code": "@[simp]\ntheorem coe_star (f : C\u2080(\u03b1, \u03b2)) : \u21d1(star f) = star (\u21d1f)", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.star_apply", "code": "theorem star_apply (f : C\u2080(\u03b1, \u03b2)) (x : \u03b1) : (star f) x = star (f x)", "start": [555, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instStarAddMonoid", "code": "instance instStarAddMonoid [ContinuousAdd \u03b2] : StarAddMonoid C\u2080(\u03b1, \u03b2) where\n  star_involutive f := ext fun x => star_star (f x)\n  star_add f g := ext fun x => star_add (f x) (g x)", "start": [559, 1], "end": [561, 52], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instNormedStarGroup", "code": "instance instNormedStarGroup : NormedStarGroup C\u2080(\u03b1, \u03b2) where\n  norm_star f := (norm_star f.toBcf : _)", "start": [569, 1], "end": [570, 41], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instStarModule", "code": "instance instStarModule : StarModule \ud835\udd5c C\u2080(\u03b1, \u03b2) where\n  star_smul k f := ext fun x => star_smul k (f x)", "start": [579, 1], "end": [580, 50], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instStarRing", "code": "instance instStarRing : StarRing C\u2080(\u03b1, \u03b2) :=\n  { ZeroAtInftyContinuousMap.instStarAddMonoid with\n    star_mul := fun f g => ext fun x => star_mul (f x) (g x) }", "start": [589, 1], "end": [591, 63], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.instCstarRing", "code": "instance instCstarRing [NonUnitalNormedRing \u03b2] [StarRing \u03b2] [CstarRing \u03b2] : CstarRing C\u2080(\u03b1, \u03b2) where\n  norm_star_mul_self {f} := CstarRing.norm_star_mul_self (x := f.toBcf)", "start": [597, 1], "end": [598, 72], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.comp", "code": "def comp (f : C\u2080(\u03b3, \u03b4)) (g : \u03b2 \u2192co \u03b3) : C\u2080(\u03b2, \u03b4) where\n  toContinuousMap := (f : C(\u03b3, \u03b4)).comp g\n  zero_at_infty' := (zero_at_infty f).comp (cocompact_tendsto g)", "start": [617, 1], "end": [621, 65], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.coe_comp_to_continuous_fun", "code": "@[simp]\ntheorem coe_comp_to_continuous_fun (f : C\u2080(\u03b3, \u03b4)) (g : \u03b2 \u2192co \u03b3) : ((f.comp g) : \u03b2 \u2192 \u03b4) = f \u2218 g", "start": [624, 1], "end": [626, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : C\u2080(\u03b3, \u03b4)) : f.comp (CocompactMap.id \u03b3) = f", "start": [629, 1], "end": [631, 19], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : C\u2080(\u03b3, \u03b4)) (g : \u03b2 \u2192co \u03b3) (h : \u03b1 \u2192co \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [634, 1], "end": [637, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.zero_comp", "code": "@[simp]\ntheorem zero_comp (g : \u03b2 \u2192co \u03b3) : (0 : C\u2080(\u03b3, \u03b4)).comp g = 0", "start": [640, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.compAddMonoidHom", "code": "def compAddMonoidHom [AddMonoid \u03b4] [ContinuousAdd \u03b4] (g : \u03b2 \u2192co \u03b3) : C\u2080(\u03b3, \u03b4) \u2192+ C\u2080(\u03b2, \u03b4) where\n  toFun f := f.comp g\n  map_zero' := zero_comp g\n  map_add' _ _ := rfl", "start": [647, 1], "end": [651, 22], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.compMulHom", "code": "def compMulHom [MulZeroClass \u03b4] [ContinuousMul \u03b4] (g : \u03b2 \u2192co \u03b3) : C\u2080(\u03b3, \u03b4) \u2192\u2099* C\u2080(\u03b2, \u03b4) where\n  toFun f := f.comp g\n  map_mul' _ _ := rfl", "start": [654, 1], "end": [657, 22], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.compLinearMap", "code": "def compLinearMap [AddCommMonoid \u03b4] [ContinuousAdd \u03b4] {R : Type*} [Semiring R] [Module R \u03b4]\n    [ContinuousConstSMul R \u03b4] (g : \u03b2 \u2192co \u03b3) : C\u2080(\u03b3, \u03b4) \u2192\u2097[R] C\u2080(\u03b2, \u03b4) where\n  toFun f := f.comp g\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [660, 1], "end": [665, 23], "kind": "commanddeclaration"}, {"full_name": "ZeroAtInftyContinuousMap.compNonUnitalAlgHom", "code": "def compNonUnitalAlgHom {R : Type*} [Semiring R] [NonUnitalNonAssocSemiring \u03b4]\n    [TopologicalSemiring \u03b4] [Module R \u03b4] [ContinuousConstSMul R \u03b4] (g : \u03b2 \u2192co \u03b3) :\n    C\u2080(\u03b3, \u03b4) \u2192\u2099\u2090[R] C\u2080(\u03b2, \u03b4) where\n  toFun f := f.comp g\n  map_smul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [668, 1], "end": [676, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/Functor.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Closed/Cartesian.lean", "Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.frobeniusMorphism", "code": "def frobeniusMorphism (h : L \u22a3 F) (A : C) :\n    prod.functor.obj (F.obj A) \u22d9 L \u27f6 L \u22d9 prod.functor.obj A :=\n  prodComparisonNatTrans L (F.obj A) \u226b whiskerLeft _ (prod.functor.map (h.counit.app _))", "start": [51, 1], "end": [63, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.frobeniusMorphism_iso_of_preserves_binary_products", "code": "instance frobeniusMorphism_iso_of_preserves_binary_products (h : L \u22a3 F) (A : C)\n    [PreservesLimitsOfShape (Discrete WalkingPair) L] [Full F] [Faithful F] :\n    IsIso (frobeniusMorphism F h A) :=\n  suffices \u2200 (X : D), IsIso ((frobeniusMorphism F h A).app X) from NatIso.isIso_of_isIso_app _\n  fun B \u21a6 by dsimp [frobeniusMorphism]; infer_instance", "start": [66, 1], "end": [73, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.expComparison", "code": "def expComparison (A : C) : exp A \u22d9 F \u27f6 F \u22d9 exp (F.obj A) :=\n  transferNatTrans (exp.adjunction A) (exp.adjunction (F.obj A)) (prodComparisonNatIso F A).inv", "start": [80, 1], "end": [84, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.expComparison_ev", "code": "theorem expComparison_ev (A B : C) :\n    Limits.prod.map (\ud835\udfd9 (F.obj A)) ((expComparison F A).app B) \u226b (exp.ev (F.obj A)).app (F.obj B) =\n      inv (prodComparison F _ _) \u226b F.map ((exp.ev _).app _)", "start": [87, 1], "end": [92, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coev_expComparison", "code": "theorem coev_expComparison (A B : C) :\n    F.map ((exp.coev A).app B) \u226b (expComparison F A).app (A \u2a2f B) =\n      (exp.coev _).app (F.obj B) \u226b (exp (F.obj A)).map (inv (prodComparison F A B))", "start": [95, 1], "end": [101, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uncurry_expComparison", "code": "theorem uncurry_expComparison (A B : C) :\n    CartesianClosed.uncurry ((expComparison F A).app B) =\n      inv (prodComparison F _ _) \u226b F.map ((exp.ev _).app _)", "start": [104, 1], "end": [107, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.expComparison_whiskerLeft", "code": "theorem expComparison_whiskerLeft {A A' : C} (f : A' \u27f6 A) :\n    expComparison F A \u226b whiskerLeft _ (pre (F.map f)) =\n      whiskerRight (pre f) _ \u226b expComparison F A'", "start": [110, 1], "end": [120, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosedFunctor", "code": "class CartesianClosedFunctor : Prop where\n  comparison_iso : \u2200 A, IsIso (expComparison F A)", "start": [123, 1], "end": [127, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.frobeniusMorphism_mate", "code": "theorem frobeniusMorphism_mate (h : L \u22a3 F) (A : C) :\n    transferNatTransSelf (h.comp (exp.adjunction A)) ((exp.adjunction (F.obj A)).comp h)\n        (frobeniusMorphism F h A) =\n      expComparison F A", "start": [132, 1], "end": [153, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.frobeniusMorphism_iso_of_expComparison_iso", "code": "theorem frobeniusMorphism_iso_of_expComparison_iso (h : L \u22a3 F) (A : C)\n    [i : IsIso (expComparison F A)] : IsIso (frobeniusMorphism F h A)", "start": [156, 1], "end": [163, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.expComparison_iso_of_frobeniusMorphism_iso", "code": "theorem expComparison_iso_of_frobeniusMorphism_iso (h : L \u22a3 F) (A : C)\n    [i : IsIso (frobeniusMorphism F h A)] : IsIso (expComparison F A)", "start": [166, 1], "end": [172, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cartesianClosedFunctorOfLeftAdjointPreservesBinaryProducts", "code": "theorem cartesianClosedFunctorOfLeftAdjointPreservesBinaryProducts (h : L \u22a3 F) [Full F] [Faithful F]\n    [PreservesLimitsOfShape (Discrete WalkingPair) L] : CartesianClosedFunctor F where", "start": [175, 1], "end": [183, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/PhragmenLindelof.lean", "imports": ["Mathlib/Analysis/Complex/AbsMax.lean", "Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PhragmenLindelof.isBigO_sub_exp_exp", "code": "theorem isBigO_sub_exp_exp {a : \u211d} {f g : \u2102 \u2192 E} {l : Filter \u2102} {u : \u2102 \u2192 \u211d}\n    (hBf : \u2203 c < a, \u2203 B, f =O[l] fun z => expR (B * expR (c * |u z|)))\n    (hBg : \u2203 c < a, \u2203 B, g =O[l] fun z => expR (B * expR (c * |u z|))) :\n    \u2203 c < a, \u2203 B, (f - g) =O[l] fun z => expR (B * expR (c * |u z|))", "start": [62, 1], "end": [78, 84], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.isBigO_sub_exp_rpow", "code": "theorem isBigO_sub_exp_rpow {a : \u211d} {f g : \u2102 \u2192 E} {l : Filter \u2102}\n    (hBf : \u2203 c < a, \u2203 B, f =O[comap Complex.abs atTop \u2293 l] fun z => expR (B * abs z ^ c))\n    (hBg : \u2203 c < a, \u2203 B, g =O[comap Complex.abs atTop \u2293 l] fun z => expR (B * abs z ^ c)) :\n    \u2203 c < a, \u2203 B, (f - g) =O[comap Complex.abs atTop \u2293 l] fun z => expR (B * abs z ^ c)", "start": [82, 1], "end": [101, 84], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.horizontal_strip", "code": "theorem horizontal_strip (hfd : DiffContOnCl \u2102 f (im \u207b\u00b9' Ioo a b))\n    (hB : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 re) atTop \u2293 \ud835\udcdf (im \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.re|)))\n    (hle_a : \u2200 z : \u2102, im z = a \u2192 \u2016f z\u2016 \u2264 C) (hle_b : \u2200 z, im z = b \u2192 \u2016f z\u2016 \u2264 C) (hza : a \u2264 im z)\n    (hzb : im z \u2264 b) : \u2016f z\u2016 \u2264 C", "start": [111, 1], "end": [228, 46], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_horizontal_strip", "code": "theorem eq_zero_on_horizontal_strip (hd : DiffContOnCl \u2102 f (im \u207b\u00b9' Ioo a b))\n    (hB : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 re) atTop \u2293 \ud835\udcdf (im \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.re|)))\n    (ha : \u2200 z : \u2102, z.im = a \u2192 f z = 0) (hb : \u2200 z : \u2102, z.im = b \u2192 f z = 0) :\n    EqOn f 0 (im \u207b\u00b9' Icc a b)", "start": [231, 1], "end": [246, 58], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_horizontal_strip", "code": "theorem eqOn_horizontal_strip {g : \u2102 \u2192 E} (hdf : DiffContOnCl \u2102 f (im \u207b\u00b9' Ioo a b))\n    (hBf : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 re) atTop \u2293 \ud835\udcdf (im \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.re|)))\n    (hdg : DiffContOnCl \u2102 g (im \u207b\u00b9' Ioo a b))\n    (hBg : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      g =O[comap (Abs.abs \u2218 re) atTop \u2293 \ud835\udcdf (im \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.re|)))\n    (ha : \u2200 z : \u2102, z.im = a \u2192 f z = g z) (hb : \u2200 z : \u2102, z.im = b \u2192 f z = g z) :\n    EqOn f g (im \u207b\u00b9' Icc a b)", "start": [249, 1], "end": [268, 84], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.vertical_strip", "code": "theorem vertical_strip (hfd : DiffContOnCl \u2102 f (re \u207b\u00b9' Ioo a b))\n    (hB : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 im) atTop \u2293 \ud835\udcdf (re \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.im|)))\n    (hle_a : \u2200 z : \u2102, re z = a \u2192 \u2016f z\u2016 \u2264 C) (hle_b : \u2200 z, re z = b \u2192 \u2016f z\u2016 \u2264 C) (hza : a \u2264 re z)\n    (hzb : re z \u2264 b) : \u2016f z\u2016 \u2264 C", "start": [275, 1], "end": [303, 18], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_vertical_strip", "code": "theorem eq_zero_on_vertical_strip (hd : DiffContOnCl \u2102 f (re \u207b\u00b9' Ioo a b))\n    (hB : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 im) atTop \u2293 \ud835\udcdf (re \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.im|)))\n    (ha : \u2200 z : \u2102, re z = a \u2192 f z = 0) (hb : \u2200 z : \u2102, re z = b \u2192 f z = 0) :\n    EqOn f 0 (re \u207b\u00b9' Icc a b)", "start": [306, 1], "end": [321, 58], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_vertical_strip", "code": "theorem eqOn_vertical_strip {g : \u2102 \u2192 E} (hdf : DiffContOnCl \u2102 f (re \u207b\u00b9' Ioo a b))\n    (hBf : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      f =O[comap (Abs.abs \u2218 im) atTop \u2293 \ud835\udcdf (re \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.im|)))\n    (hdg : DiffContOnCl \u2102 g (re \u207b\u00b9' Ioo a b))\n    (hBg : \u2203 c < \u03c0 / (b - a), \u2203 B,\n      g =O[comap (Abs.abs \u2218 im) atTop \u2293 \ud835\udcdf (re \u207b\u00b9' Ioo a b)] fun z \u21a6 expR (B * expR (c * |z.im|)))\n    (ha : \u2200 z : \u2102, re z = a \u2192 f z = g z) (hb : \u2200 z : \u2102, re z = b \u2192 f z = g z) :\n    EqOn f g (re \u207b\u00b9' Icc a b)", "start": [324, 1], "end": [343, 84], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.quadrant_I", "code": "nonrec theorem quadrant_I (hd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Ioi 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 \u2016f x\u2016 \u2264 C) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 \u2016f (x * I)\u2016 \u2264 C) (hz_re : 0 \u2264 z.re)\n    (hz_im : 0 \u2264 z.im) : \u2016f z\u2016 \u2264 C", "start": [350, 1], "end": [416, 36], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_quadrant_I", "code": "theorem eq_zero_on_quadrant_I (hd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Ioi 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 f x = 0) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 f (x * I) = 0) :\n    EqOn f 0 {z | 0 \u2264 z.re \u2227 0 \u2264 z.im}", "start": [420, 1], "end": [435, 61], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_quadrant_I", "code": "theorem eqOn_quadrant_I (hdf : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Ioi 0))\n    (hBf : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl \u2102 g (Ioi 0 \u00d7\u2102 Ioi 0))\n    (hBg : \u2203 c < (2 : \u211d), \u2203 B,\n      g =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 f x = g x) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 f (x * I) = g (x * I)) :\n    EqOn f g {z | 0 \u2264 z.re \u2227 0 \u2264 z.im}", "start": [439, 1], "end": [457, 89], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.quadrant_II", "code": "theorem quadrant_II (hd : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Ioi 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 \u2016f x\u2016 \u2264 C) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 \u2016f (x * I)\u2016 \u2264 C) (hz_re : z.re \u2264 0)\n    (hz_im : 0 \u2264 z.im) : \u2016f z\u2016 \u2264 C", "start": [461, 1], "end": [485, 34], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_quadrant_II", "code": "theorem eq_zero_on_quadrant_II (hd : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Ioi 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 f x = 0) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 f (x * I) = 0) :\n    EqOn f 0 {z | z.re \u2264 0 \u2227 0 \u2264 z.im}", "start": [489, 1], "end": [504, 61], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_quadrant_II", "code": "theorem eqOn_quadrant_II (hdf : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Ioi 0))\n    (hBf : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl \u2102 g (Iio 0 \u00d7\u2102 Ioi 0))\n    (hBg : \u2203 c < (2 : \u211d), \u2203 B,\n      g =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Ioi 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 f x = g x) (him : \u2200 x : \u211d, 0 \u2264 x \u2192 f (x * I) = g (x * I)) :\n    EqOn f g {z | z.re \u2264 0 \u2227 0 \u2264 z.im}", "start": [508, 1], "end": [525, 87], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.quadrant_III", "code": "theorem quadrant_III (hd : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Iio 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 \u2016f x\u2016 \u2264 C) (him : \u2200 x : \u211d, x \u2264 0 \u2192 \u2016f (x * I)\u2016 \u2264 C) (hz_re : z.re \u2264 0)\n    (hz_im : z.im \u2264 0) : \u2016f z\u2016 \u2264 C", "start": [529, 1], "end": [558, 37], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_quadrant_III", "code": "theorem eq_zero_on_quadrant_III (hd : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Iio 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 f x = 0) (him : \u2200 x : \u211d, x \u2264 0 \u2192 f (x * I) = 0) :\n    EqOn f 0 {z | z.re \u2264 0 \u2227 z.im \u2264 0}", "start": [562, 1], "end": [576, 59], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_quadrant_III", "code": "theorem eqOn_quadrant_III (hdf : DiffContOnCl \u2102 f (Iio 0 \u00d7\u2102 Iio 0))\n    (hBf : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl \u2102 g (Iio 0 \u00d7\u2102 Iio 0))\n    (hBg : \u2203 c < (2 : \u211d), \u2203 B,\n      g =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Iio 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, x \u2264 0 \u2192 f x = g x) (him : \u2200 x : \u211d, x \u2264 0 \u2192 f (x * I) = g (x * I)) :\n    EqOn f g {z | z.re \u2264 0 \u2227 z.im \u2264 0}", "start": [580, 1], "end": [597, 87], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.quadrant_IV", "code": "theorem quadrant_IV (hd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Iio 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 \u2016f x\u2016 \u2264 C) (him : \u2200 x : \u211d, x \u2264 0 \u2192 \u2016f (x * I)\u2016 \u2264 C) (hz_re : 0 \u2264 z.re)\n    (hz_im : z.im \u2264 0) : \u2016f z\u2016 \u2264 C", "start": [601, 1], "end": [628, 37], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_quadrant_IV", "code": "theorem eq_zero_on_quadrant_IV (hd : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Iio 0))\n    (hB : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 f x = 0) (him : \u2200 x : \u211d, x \u2264 0 \u2192 f (x * I) = 0) :\n    EqOn f 0 {z | 0 \u2264 z.re \u2227 z.im \u2264 0}", "start": [632, 1], "end": [647, 61], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_quadrant_IV", "code": "theorem eqOn_quadrant_IV (hdf : DiffContOnCl \u2102 f (Ioi 0 \u00d7\u2102 Iio 0))\n    (hBf : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hdg : DiffContOnCl \u2102 g (Ioi 0 \u00d7\u2102 Iio 0))\n    (hBg : \u2203 c < (2 : \u211d), \u2203 B,\n      g =O[comap Complex.abs atTop \u2293 \ud835\udcdf (Ioi 0 \u00d7\u2102 Iio 0)] fun z => expR (B * abs z ^ c))\n    (hre : \u2200 x : \u211d, 0 \u2264 x \u2192 f x = g x) (him : \u2200 x : \u211d, x \u2264 0 \u2192 f (x * I) = g (x * I)) :\n    EqOn f g {z | 0 \u2264 z.re \u2227 z.im \u2264 0}", "start": [651, 1], "end": [668, 87], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.right_half_plane_of_tendsto_zero_on_real", "code": "theorem right_half_plane_of_tendsto_zero_on_real (hd : DiffContOnCl \u2102 f {z | 0 < z.re})\n    (hexp : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : Tendsto (fun x : \u211d => f x) atTop (\ud835\udcdd 0)) (him : \u2200 x : \u211d, \u2016f (x * I)\u2016 \u2264 C)\n    (hz : 0 \u2264 z.re) : \u2016f z\u2016 \u2264 C", "start": [677, 1], "end": [747, 22], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.right_half_plane_of_bounded_on_real", "code": "theorem right_half_plane_of_bounded_on_real (hd : DiffContOnCl \u2102 f {z | 0 < z.re})\n    (hexp : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : IsBoundedUnder (\u00b7 \u2264 \u00b7) atTop fun x : \u211d => \u2016f x\u2016) (him : \u2200 x : \u211d, \u2016f (x * I)\u2016 \u2264 C)\n    (hz : 0 \u2264 z.re) : \u2016f z\u2016 \u2264 C", "start": [750, 1], "end": [791, 16], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eq_zero_on_right_half_plane_of_superexponential_decay", "code": "theorem eq_zero_on_right_half_plane_of_superexponential_decay (hd : DiffContOnCl \u2102 f {z | 0 < z.re})\n    (hexp : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop expR fun x => \u2016f x\u2016) (him : \u2203 C, \u2200 x : \u211d, \u2016f (x * I)\u2016 \u2264 C) :\n    EqOn f 0 {z : \u2102 | 0 \u2264 z.re}", "start": [794, 1], "end": [847, 15], "kind": "commanddeclaration"}, {"full_name": "PhragmenLindelof.eqOn_right_half_plane_of_superexponential_decay", "code": "theorem eqOn_right_half_plane_of_superexponential_decay {g : \u2102 \u2192 E}\n    (hfd : DiffContOnCl \u2102 f {z | 0 < z.re}) (hgd : DiffContOnCl \u2102 g {z | 0 < z.re})\n    (hfexp : \u2203 c < (2 : \u211d), \u2203 B,\n      f =O[comap Complex.abs atTop \u2293 \ud835\udcdf {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hgexp : \u2203 c < (2 : \u211d), \u2203 B,\n      g =O[comap Complex.abs atTop \u2293 \ud835\udcdf {z | 0 < z.re}] fun z => expR (B * abs z ^ c))\n    (hre : SuperpolynomialDecay atTop expR fun x => \u2016f x - g x\u2016)\n    (hfim : \u2203 C, \u2200 x : \u211d, \u2016f (x * I)\u2016 \u2264 C) (hgim : \u2203 C, \u2200 x : \u211d, \u2016g (x * I)\u2016 \u2264 C) :\n    EqOn f g {z : \u2102 | 0 \u2264 z.re}", "start": [850, 1], "end": [886, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat/Symmetric.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat/Monoidal.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticModuleCat.toModuleCatBraidedFunctor", "code": "@[simps toMonoidalFunctor]\ndef toModuleCatBraidedFunctor : BraidedFunctor (QuadraticModuleCat.{u} R) (ModuleCat.{u} R) where\n  toMonoidalFunctor := toModuleCatMonoidalFunctor R", "start": [39, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instSymmetricCategory", "code": "instance instSymmetricCategory : SymmetricCategory (QuadraticModuleCat.{u} R) :=\n  symmetricCategoryOfFaithful (toModuleCatBraidedFunctor R)", "start": [47, 1], "end": [48, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/MinimalPrime.lean", "imports": ["Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/Order/Minimal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.minimalPrimes", "code": "protected def Ideal.minimalPrimes : Set (Ideal R) :=\n  minimals (\u00b7 \u2264 \u00b7) { p | p.IsPrime \u2227 I \u2264 p }", "start": [37, 1], "end": [39, 45], "kind": "commanddeclaration"}, {"full_name": "minimalPrimes", "code": "def minimalPrimes (R : Type*) [CommRing R] : Set (Ideal R) :=\n  Ideal.minimalPrimes \u22a5", "start": [42, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_minimalPrimes_le", "code": "theorem Ideal.exists_minimalPrimes_le [J.IsPrime] (e : I \u2264 J) : \u2203 p \u2208 I.minimalPrimes, p \u2264 J", "start": [50, 1], "end": [68, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_minimalPrimes", "code": "@[simp]\ntheorem Ideal.radical_minimalPrimes : I.radical.minimalPrimes = I.minimalPrimes", "start": [71, 1], "end": [82, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.sInf_minimalPrimes", "code": "@[simp]\ntheorem Ideal.sInf_minimalPrimes : sInf I.minimalPrimes = I.radical", "start": [85, 1], "end": [96, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective", "code": "theorem Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective {f : R \u2192+* S}\n    (hf : Function.Injective f) (p) (H : p \u2208 minimalPrimes R) :\n    \u2203 p' : Ideal S, p'.IsPrime \u2227 p'.comap f = p", "start": [99, 1], "end": [120, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_comap_eq_of_mem_minimalPrimes", "code": "theorem Ideal.exists_comap_eq_of_mem_minimalPrimes {I : Ideal S} (f : R \u2192+* S) (p)\n    (H : p \u2208 (I.comap f).minimalPrimes) : \u2203 p' : Ideal S, p'.IsPrime \u2227 I \u2264 p' \u2227 p'.comap f = p", "start": [123, 1], "end": [153, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_minimalPrimes_comap_eq", "code": "theorem Ideal.exists_minimalPrimes_comap_eq {I : Ideal S} (f : R \u2192+* S) (p)\n    (H : p \u2208 (I.comap f).minimalPrimes) : \u2203 p' \u2208 I.minimalPrimes, Ideal.comap f p' = p", "start": [156, 1], "end": [163, 74], "kind": "commanddeclaration"}, {"full_name": "Ideal.minimal_primes_comap_of_surjective", "code": "theorem Ideal.minimal_primes_comap_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f)\n    {I J : Ideal S} (h : J \u2208 I.minimalPrimes) : J.comap f \u2208 (I.comap f).minimalPrimes", "start": [166, 1], "end": [176, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_minimalPrimes_eq_of_surjective", "code": "theorem Ideal.comap_minimalPrimes_eq_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f)\n    (I : Ideal S) : (I.comap f).minimalPrimes = Ideal.comap f '' I.minimalPrimes", "start": [179, 1], "end": [187, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.minimalPrimes_eq_comap", "code": "theorem Ideal.minimalPrimes_eq_comap :\n    I.minimalPrimes = Ideal.comap (Ideal.Quotient.mk I) '' minimalPrimes (R \u29f8 I)", "start": [190, 1], "end": [193, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.minimalPrimes_eq_subsingleton", "code": "theorem Ideal.minimalPrimes_eq_subsingleton (hI : I.IsPrimary) : I.minimalPrimes = {I.radical}", "start": [196, 1], "end": [203, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.minimalPrimes_eq_subsingleton_self", "code": "theorem Ideal.minimalPrimes_eq_subsingleton_self [I.IsPrime] : I.minimalPrimes = {I}", "start": [206, 1], "end": [211, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/LHopital.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Inv.lean", "Mathlib/Analysis/Calculus/MeanValue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasDerivAt.lhopital_zero_right_on_Ioo", "code": "theorem lhopital_zero_right_on_Ioo (hff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (hg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [51, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_right_on_Ico", "code": "theorem lhopital_zero_right_on_Ico (hff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ico a b))\n    (hcg : ContinuousOn g (Ico a b)) (hg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [95, 1], "end": [104, 77], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_left_on_Ioo", "code": "theorem lhopital_zero_left_on_Ioo (hff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (hg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0)\n    (hfb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd 0)) (hgb : Tendsto g (\ud835\udcdd[<] b) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[<] b) l) :\n  Tendsto (fun x => f x / g x) (\ud835\udcdd[<] b) l", "start": [107, 1], "end": [129, 23], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_left_on_Ioc", "code": "theorem lhopital_zero_left_on_Ioc (hff' : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioo a b, HasDerivAt g (g' x) x) (hcf : ContinuousOn f (Ioc a b))\n    (hcg : ContinuousOn g (Ioc a b)) (hg' : \u2200 x \u2208 Ioo a b, g' x \u2260 0) (hfb : f b = 0) (hgb : g b = 0)\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[<] b) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[<] b) l", "start": [132, 1], "end": [141, 78], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_atTop_on_Ioi", "code": "theorem lhopital_zero_atTop_on_Ioi (hff' : \u2200 x \u2208 Ioi a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x) (hg' : \u2200 x \u2208 Ioi a, g' x \u2260 0)\n    (hftop : Tendsto f atTop (\ud835\udcdd 0)) (hgtop : Tendsto g atTop (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l", "start": [144, 1], "end": [174, 23], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_atBot_on_Iio", "code": "theorem lhopital_zero_atBot_on_Iio (hff' : \u2200 x \u2208 Iio a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200 x \u2208 Iio a, HasDerivAt g (g' x) x) (hg' : \u2200 x \u2208 Iio a, g' x \u2260 0)\n    (hfbot : Tendsto f atBot (\ud835\udcdd 0)) (hgbot : Tendsto g atBot (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l", "start": [177, 1], "end": [199, 23], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_right_on_Ioo", "code": "theorem lhopital_zero_right_on_Ioo (hdf : DifferentiableOn \u211d f (Ioo a b))\n    (hg' : \u2200 x \u2208 Ioo a b, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [206, 1], "end": [216, 57], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_right_on_Ico", "code": "theorem lhopital_zero_right_on_Ico (hdf : DifferentiableOn \u211d f (Ioo a b))\n    (hcf : ContinuousOn f (Ico a b)) (hcg : ContinuousOn g (Ico a b))\n    (hg' : \u2200 x \u2208 Ioo a b, (deriv g) x \u2260 0) (hfa : f a = 0) (hga : g a = 0)\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [219, 1], "end": [228, 77], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_left_on_Ioo", "code": "theorem lhopital_zero_left_on_Ioo (hdf : DifferentiableOn \u211d f (Ioo a b))\n    (hg' : \u2200 x \u2208 Ioo a b, (deriv g) x \u2260 0) (hfb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd 0))\n    (hgb : Tendsto g (\ud835\udcdd[<] b) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[<] b) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[<] b) l", "start": [231, 1], "end": [241, 57], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_atTop_on_Ioi", "code": "theorem lhopital_zero_atTop_on_Ioi (hdf : DifferentiableOn \u211d f (Ioi a))\n    (hg' : \u2200 x \u2208 Ioi a, (deriv g) x \u2260 0) (hftop : Tendsto f atTop (\ud835\udcdd 0))\n    (hgtop : Tendsto g atTop (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l", "start": [244, 1], "end": [253, 61], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_atBot_on_Iio", "code": "theorem lhopital_zero_atBot_on_Iio (hdf : DifferentiableOn \u211d f (Iio a))\n    (hg' : \u2200 x \u2208 Iio a, (deriv g) x \u2260 0) (hfbot : Tendsto f atBot (\ud835\udcdd 0))\n    (hgbot : Tendsto g atBot (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l", "start": [256, 1], "end": [265, 61], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_nhds_right", "code": "theorem lhopital_zero_nhds_right (hff' : \u2200\u1da0 x in \ud835\udcdd[>] a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd[>] a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd[>] a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [280, 1], "end": [295, 68], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_nhds_left", "code": "theorem lhopital_zero_nhds_left (hff' : \u2200\u1da0 x in \ud835\udcdd[<] a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd[<] a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd[<] a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[<] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[<] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[<] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[<] a) l", "start": [298, 1], "end": [313, 66], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_nhds'", "code": "theorem lhopital_zero_nhds' (hff' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd[\u2260] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l", "start": [316, 1], "end": [325, 69], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_nhds", "code": "theorem lhopital_zero_nhds (hff' : \u2200\u1da0 x in \ud835\udcdd a, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in \ud835\udcdd a, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in \ud835\udcdd a, g' x \u2260 0)\n    (hfa : Tendsto f (\ud835\udcdd a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) (\ud835\udcdd a) l) : Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l", "start": [328, 1], "end": [335, 63], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_atTop", "code": "theorem lhopital_zero_atTop (hff' : \u2200\u1da0 x in atTop, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in atTop, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in atTop, g' x \u2260 0)\n    (hftop : Tendsto f atTop (\ud835\udcdd 0)) (hgtop : Tendsto g atTop (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atTop l) : Tendsto (fun x => f x / g x) atTop l", "start": [338, 1], "end": [353, 87], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.lhopital_zero_atBot", "code": "theorem lhopital_zero_atBot (hff' : \u2200\u1da0 x in atBot, HasDerivAt f (f' x) x)\n    (hgg' : \u2200\u1da0 x in atBot, HasDerivAt g (g' x) x) (hg' : \u2200\u1da0 x in atBot, g' x \u2260 0)\n    (hfbot : Tendsto f atBot (\ud835\udcdd 0)) (hgbot : Tendsto g atBot (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => f' x / g' x) atBot l) : Tendsto (fun x => f x / g x) atBot l", "start": [356, 1], "end": [371, 87], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_nhds_right", "code": "theorem lhopital_zero_nhds_right (hdf : \u2200\u1da0 x in \ud835\udcdd[>] a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd[>] a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[>] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[>] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[>] a) l", "start": [378, 1], "end": [391, 71], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_nhds_left", "code": "theorem lhopital_zero_nhds_left (hdf : \u2200\u1da0 x in \ud835\udcdd[<] a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd[<] a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[<] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[<] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[<] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[<] a) l", "start": [394, 1], "end": [407, 70], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_nhds'", "code": "theorem lhopital_zero_nhds' (hdf : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd[\u2260] a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hga : Tendsto g (\ud835\udcdd[\u2260] a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd[\u2260] a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l", "start": [410, 1], "end": [419, 61], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_nhds", "code": "theorem lhopital_zero_nhds (hdf : \u2200\u1da0 x in \ud835\udcdd a, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x in \ud835\udcdd a, deriv g x \u2260 0) (hfa : Tendsto f (\ud835\udcdd a) (\ud835\udcdd 0)) (hga : Tendsto g (\ud835\udcdd a) (\ud835\udcdd 0))\n    (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) (\ud835\udcdd a) l) :\n    Tendsto (fun x => f x / g x) (\ud835\udcdd[\u2260] a) l", "start": [422, 1], "end": [429, 63], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_atTop", "code": "theorem lhopital_zero_atTop (hdf : \u2200\u1da0 x : \u211d in atTop, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x : \u211d in atTop, deriv g x \u2260 0) (hftop : Tendsto f atTop (\ud835\udcdd 0))\n    (hgtop : Tendsto g atTop (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atTop l) :\n    Tendsto (fun x => f x / g x) atTop l", "start": [432, 1], "end": [444, 70], "kind": "commanddeclaration"}, {"full_name": "deriv.lhopital_zero_atBot", "code": "theorem lhopital_zero_atBot (hdf : \u2200\u1da0 x : \u211d in atBot, DifferentiableAt \u211d f x)\n    (hg' : \u2200\u1da0 x : \u211d in atBot, deriv g x \u2260 0) (hfbot : Tendsto f atBot (\ud835\udcdd 0))\n    (hgbot : Tendsto g atBot (\ud835\udcdd 0)) (hdiv : Tendsto (fun x => (deriv f) x / (deriv g) x) atBot l) :\n    Tendsto (fun x => f x / g x) atBot l", "start": [447, 1], "end": [459, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/Filter.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Topology/Filter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.tendsto_nhds_atTop", "code": "protected theorem tendsto_nhds_atTop [NoMaxOrder X] : Tendsto \ud835\udcdd (atTop : Filter X) (\ud835\udcdd atTop)", "start": [25, 1], "end": [26, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_atBot", "code": "protected theorem tendsto_nhds_atBot [NoMinOrder X] : Tendsto \ud835\udcdd (atBot : Filter X) (\ud835\udcdd atBot)", "start": [29, 1], "end": [30, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nhds_atTop", "code": "theorem Tendsto.nhds_atTop [NoMaxOrder X] {f : \u03b1 \u2192 X} {l : Filter \u03b1} (h : Tendsto f l atTop) :\n    Tendsto (\ud835\udcdd \u2218 f) l (\ud835\udcdd atTop)", "start": [33, 1], "end": [35, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nhds_atBot", "code": "theorem Tendsto.nhds_atBot [NoMinOrder X] {f : \u03b1 \u2192 X} {l : Filter \u03b1} (h : Tendsto f l atBot) :\n    Tendsto (\ud835\udcdd \u2218 f) l (\ud835\udcdd atBot)", "start": [38, 1], "end": [40, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Option.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.smul_def", "code": "@[to_additive]\ntheorem smul_def : a \u2022 x = x.map ((\u00b7 \u2022 \u00b7) a)", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Option.smul_none", "code": "@[to_additive (attr := simp)]\ntheorem smul_none : a \u2022 (none : Option \u03b1) = none", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Option.smul_some", "code": "@[to_additive (attr := simp)]\ntheorem smul_some : a \u2022 some b = some (a \u2022 b)", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean", "imports": ["Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean"], "premises": [{"full_name": "QuaternionGroup", "code": "inductive QuaternionGroup (n : \u2115) : Type\n  | a : ZMod (2 * n) \u2192 QuaternionGroup n\n  | xa : ZMod (2 * n) \u2192 QuaternionGroup n\n  deriving DecidableEq", "start": [49, 1], "end": [56, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.mul", "code": "private def mul : QuaternionGroup n \u2192 QuaternionGroup n \u2192 QuaternionGroup n\n  | a i, a j => a (i + j)\n  | a i, xa j => xa (j - i)\n  | xa i, a j => xa (i + j)\n  | xa i, xa j => a (n + j - i)", "start": [63, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.one", "code": "private def one : QuaternionGroup n :=\n  a 0", "start": [71, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.inv", "code": "private def inv : QuaternionGroup n \u2192 QuaternionGroup n\n  | a i => a (-i)\n  | xa i => xa (n + i)", "start": [79, 1], "end": [83, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.a_mul_a", "code": "@[simp]\ntheorem a_mul_a (i j : ZMod (2 * n)) : a i * a j = a (i + j)", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.a_mul_xa", "code": "@[simp]\ntheorem a_mul_xa (i j : ZMod (2 * n)) : a i * xa j = xa (j - i)", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.xa_mul_a", "code": "@[simp]\ntheorem xa_mul_a (i j : ZMod (2 * n)) : xa i * a j = xa (i + j)", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.xa_mul_xa", "code": "@[simp]\ntheorem xa_mul_xa (i j : ZMod (2 * n)) : xa i * xa j = a ((n : ZMod (2 * n)) + j - i)", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.one_def", "code": "theorem one_def : (1 : QuaternionGroup n) = a 0", "start": [131, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.fintypeHelper", "code": "private def fintypeHelper : Sum (ZMod (2 * n)) (ZMod (2 * n)) \u2243 QuaternionGroup n where\n  invFun i :=\n    match i with\n    | a j => Sum.inl j\n    | xa j => Sum.inr j\n  toFun i :=\n    match i with\n    | Sum.inl j => a j\n    | Sum.inr j => xa j\n  left_inv := by rintro (x | x) <;> rfl\n  right_inv := by rintro (x | x) <;> rfl", "start": [135, 1], "end": [145, 41], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.quaternionGroupZeroEquivDihedralGroupZero", "code": "def quaternionGroupZeroEquivDihedralGroupZero : QuaternionGroup 0 \u2243* DihedralGroup 0 where\n  toFun i :=\n    match i with\n    | a j => DihedralGroup.r j\n    | xa j => DihedralGroup.sr j\n  invFun i :=\n    match i with\n    | DihedralGroup.r j => a j\n    | DihedralGroup.sr j => xa j\n  left_inv := by rintro (k | k) <;> rfl\n  right_inv := by rintro (k | k) <;> rfl\n  map_mul' := by rintro (k | k) (l | l) <;> simp", "start": [147, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.card", "code": "theorem card [NeZero n] : Fintype.card (QuaternionGroup n) = 4 * n", "start": [172, 1], "end": [176, 7], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.a_one_pow", "code": "@[simp]\ntheorem a_one_pow (k : \u2115) : (a 1 : QuaternionGroup n) ^ k = a k", "start": [179, 1], "end": [186, 21], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.a_one_pow_n", "code": "theorem a_one_pow_n : (a 1 : QuaternionGroup n) ^ (2 * n) = 1", "start": [190, 1], "end": [193, 29], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.xa_sq", "code": "@[simp]\ntheorem xa_sq (i : ZMod (2 * n)) : xa i ^ 2 = a n", "start": [196, 1], "end": [197, 66], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.xa_pow_four", "code": "@[simp]\ntheorem xa_pow_four (i : ZMod (2 * n)) : xa i ^ 4 = 1", "start": [200, 1], "end": [206, 17], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.orderOf_xa", "code": "@[simp]\ntheorem orderOf_xa [NeZero n] (i : ZMod (2 * n)) : orderOf (xa i) = 4", "start": [209, 1], "end": [223, 13], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.quaternionGroup_one_isCyclic", "code": "theorem quaternionGroup_one_isCyclic : IsCyclic (QuaternionGroup 1)", "start": [226, 1], "end": [230, 21], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.orderOf_a_one", "code": "@[simp]\ntheorem orderOf_a_one : orderOf (a 1 : QuaternionGroup n) = 2 * n", "start": [233, 1], "end": [252, 42], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.orderOf_a", "code": "theorem orderOf_a [NeZero n] (i : ZMod (2 * n)) :\n    orderOf (a i) = 2 * n / Nat.gcd (2 * n) i.val", "start": [255, 1], "end": [260, 47], "kind": "commanddeclaration"}, {"full_name": "QuaternionGroup.exponent", "code": "theorem exponent : Monoid.exponent (QuaternionGroup n) = 2 * lcm n 2", "start": [263, 1], "end": [282, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Free.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/Algebra/Category/ModuleCat/Adjunctions.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Finrank.lean", "Mathlib/Algebra/Homology/ShortExact/Preadditive.lean"], "premises": [{"full_name": "ModuleCat.disjoint_span_sum", "code": "theorem disjoint_span_sum : Disjoint (span R (range (u \u2218 Sum.inl)))\n    (span R (range (u \u2218 Sum.inr)))", "start": [49, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.linearIndependent_leftExact", "code": "theorem linearIndependent_leftExact : LinearIndependent R u", "start": [56, 1], "end": [72, 65], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.linearIndependent_shortExact", "code": "theorem linearIndependent_shortExact {w : \u03b9' \u2192 P}\n    (hw : LinearIndependent R w) (hse : ShortExact f g) :\n    LinearIndependent R (Sum.elim (f \u2218 v) (g.toFun.invFun \u2218 w))", "start": [74, 1], "end": [84, 79], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.span_exact", "code": "theorem span_exact (he : Exact f g) (huv : u \u2218 Sum.inl = f \u2218 v)\n    (hv : \u22a4 \u2264 span R (range v))\n    (hw : \u22a4 \u2264 span R (range (g \u2218 u \u2218 Sum.inr))) :\n    \u22a4 \u2264 span R (range u)", "start": [92, 1], "end": [133, 59], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.span_rightExact", "code": "theorem span_rightExact {w : \u03b9' \u2192 P} (hv : \u22a4 \u2264 span R (range v))\n    (hw : \u22a4 \u2264 span R (range w)) (hE : Epi g) (he : Exact f g) :\n    \u22a4 \u2264 span R (range (Sum.elim (f \u2218 v) (g.toFun.invFun \u2218 w)))", "start": [135, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.Basis.ofShortExact", "code": "noncomputable\ndef Basis.ofShortExact {M : ModuleCat R} {f : N \u27f6 M} {g : M \u27f6 P} (h : ShortExact f g)\n    (bN : Basis \u03b9 R N) (bP : Basis \u03b9' R P) : Basis (\u03b9 \u2295 \u03b9') R M :=\n  Basis.mk (linearIndependent_shortExact bN.linearIndependent bP.linearIndependent h)\n    (span_rightExact (le_of_eq (bN.span_eq.symm)) (le_of_eq (bP.span_eq.symm)) h.epi h.exact)", "start": [150, 1], "end": [156, 94], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.free_shortExact", "code": "theorem free_shortExact {M : ModuleCat R} {f : N \u27f6 M}\n    {g : M \u27f6 P} (h : ShortExact f g) [Module.Free R N] [Module.Free R P] :\n    Module.Free R M", "start": [158, 1], "end": [163, 35], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.free_shortExact_rank_add", "code": "theorem free_shortExact_rank_add {M : ModuleCat R} {f : N \u27f6 M}\n    {g : M \u27f6 P} (h : ShortExact f g) [Module.Free R N] [Module.Free R P] [StrongRankCondition R] :\n    Module.rank R M = Module.rank R N + Module.rank R P", "start": [165, 1], "end": [172, 66], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.free_shortExact_finrank_add", "code": "theorem free_shortExact_finrank_add {M : ModuleCat R} {f : N \u27f6 M}\n    {g : M \u27f6 P} (h : ShortExact f g) [Module.Free R N] [Module.Finite R N]\n    [Module.Free R P] [Module.Finite R P]\n    (hN : FiniteDimensional.finrank R N = n)\n    (hP : FiniteDimensional.finrank R P = p)\n    [StrongRankCondition R]:\n    FiniteDimensional.finrank R M = n + p", "start": [174, 1], "end": [183, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/IO/Process.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IO.Process.runCmdWithInput'", "code": "def runCmdWithInput' (cmd : String) (args : Array String)\n    (input : String := \"\") (throwFailure := true) : IO (UInt32 \u00d7 String \u00d7 String) := do\n  let child \u2190 spawn\n    { cmd := cmd, args := args, stdin := .piped, stdout := .piped, stderr := .piped }\n  let (stdin, child) \u2190 child.takeStdin\n  stdin.putStr input\n  stdin.flush\n  let stdout \u2190 IO.asTask child.stdout.readToEnd Task.Priority.dedicated\n  let err \u2190 child.stderr.readToEnd\n  let exitCode \u2190 child.wait\n  if exitCode != 0 && throwFailure then\n    throw $ IO.userError err\n  else\n    let out \u2190 IO.ofExcept stdout.get\n    return (exitCode, out, err)", "start": [15, 1], "end": [35, 32], "kind": "commanddeclaration"}, {"full_name": "IO.Process.runCmdWithInput", "code": "def runCmdWithInput (cmd : String) (args : Array String)\n    (input : String := \"\") (throwFailure := true) : IO String := do\n  return (\u2190 runCmdWithInput' cmd args input throwFailure).2.1", "start": [37, 1], "end": [43, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "imports": ["Mathlib/Data/List/Cycle.lean", "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "Mathlib/GroupTheory/Perm/List.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.formPerm_disjoint_iff", "code": "theorem formPerm_disjoint_iff (hl : Nodup l) (hl' : Nodup l') (hn : 2 \u2264 l.length)\n    (hn' : 2 \u2264 l'.length) : Perm.Disjoint (formPerm l) (formPerm l') \u2194 l.Disjoint l'", "start": [58, 1], "end": [70, 65], "kind": "commanddeclaration"}, {"full_name": "List.isCycle_formPerm", "code": "theorem isCycle_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) : IsCycle (formPerm l)", "start": [74, 1], "end": [86, 84], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_sameCycle_formPerm", "code": "theorem pairwise_sameCycle_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) :\n    Pairwise l.formPerm.SameCycle l", "start": [89, 1], "end": [94, 61], "kind": "commanddeclaration"}, {"full_name": "List.cycleOf_formPerm", "code": "theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) (x) :\n    cycleOf l.attach.formPerm x = l.attach.formPerm", "start": [97, 1], "end": [102, 70], "kind": "commanddeclaration"}, {"full_name": "List.cycleType_formPerm", "code": "theorem cycleType_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) :\n    cycleType l.attach.formPerm = {l.length}", "start": [105, 1], "end": [117, 9], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_mem_eq_next", "code": "theorem formPerm_apply_mem_eq_next (hl : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    formPerm l x = next l x hx", "start": [121, 1], "end": [124, 50], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm", "code": "def formPerm : \u2200 (s : Cycle \u03b1) (_ : Nodup s), Equiv.Perm \u03b1 :=\n  fun s => Quotient.hrecOn s (fun l _ => List.formPerm l) fun l\u2081 l\u2082 (h : l\u2081 ~r l\u2082) => by\n    apply Function.hfunext\n    ext\n    \u00b7 exact h.nodup_iff\n    \u00b7 intro h\u2081 h\u2082 _\n      exact heq_of_eq (formPerm_eq_of_isRotated h\u2081 h)", "start": [133, 1], "end": [142, 54], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_coe", "code": "@[simp]\ntheorem formPerm_coe (l : List \u03b1) (hl : l.Nodup) : formPerm (l : Cycle \u03b1) hl = l.formPerm", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_subsingleton", "code": "theorem formPerm_subsingleton (s : Cycle \u03b1) (h : Subsingleton s) : formPerm s h.nodup = 1", "start": [150, 1], "end": [157, 13], "kind": "commanddeclaration"}, {"full_name": "Cycle.isCycle_formPerm", "code": "theorem isCycle_formPerm (s : Cycle \u03b1) (h : Nodup s) (hn : Nontrivial s) :\n    IsCycle (formPerm s h)", "start": [160, 1], "end": [163, 55], "kind": "commanddeclaration"}, {"full_name": "Cycle.support_formPerm", "code": "theorem support_formPerm [Fintype \u03b1] (s : Cycle \u03b1) (h : Nodup s) (hn : Nontrivial s) :\n    support (formPerm s h) = s.toFinset", "start": [166, 1], "end": [171, 58], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_eq_self_of_not_mem", "code": "theorem formPerm_eq_self_of_not_mem (s : Cycle \u03b1) (h : Nodup s) (x : \u03b1) (hx : x \u2209 s) :\n    formPerm s h x = x", "start": [174, 1], "end": [177, 54], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_apply_mem_eq_next", "code": "theorem formPerm_apply_mem_eq_next (s : Cycle \u03b1) (h : Nodup s) (x : \u03b1) (hx : x \u2208 s) :\n    formPerm s h x = next s h x hx", "start": [180, 1], "end": [183, 64], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_reverse", "code": "nonrec theorem formPerm_reverse (s : Cycle \u03b1) (h : Nodup s) :\n    formPerm s.reverse (nodup_reverse_iff.mpr h) = (formPerm s h)\u207b\u00b9", "start": [186, 1], "end": [189, 35], "kind": "commanddeclaration"}, {"full_name": "Cycle.formPerm_eq_formPerm_iff", "code": "nonrec theorem formPerm_eq_formPerm_iff {\u03b1 : Type*} [DecidableEq \u03b1] {s s' : Cycle \u03b1} {hs : s.Nodup}\n    {hs' : s'.Nodup} :\n    s.formPerm hs = s'.formPerm hs' \u2194 s = s' \u2228 s.Subsingleton \u2227 s'.Subsingleton", "start": [192, 1], "end": [203, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList", "code": "def toList : List \u03b1 :=\n  (List.range (cycleOf p x).support.card).map fun k => (p ^ k) x", "start": [214, 1], "end": [218, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_one", "code": "@[simp]\ntheorem toList_one : toList (1 : Perm \u03b1) x = []", "start": [221, 1], "end": [222, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_eq_nil_iff", "code": "@[simp]\ntheorem toList_eq_nil_iff {p : Perm \u03b1} {x} : toList p x = [] \u2194 x \u2209 p.support", "start": [225, 1], "end": [226, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.length_toList", "code": "@[simp]\ntheorem length_toList : length (toList p x) = (cycleOf p x).support.card", "start": [229, 1], "end": [230, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_ne_singleton", "code": "theorem toList_ne_singleton (y : \u03b1) : toList p x \u2260 [y]", "start": [233, 1], "end": [235, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.two_le_length_toList_iff_mem_support", "code": "theorem two_le_length_toList_iff_mem_support {p : Perm \u03b1} {x : \u03b1} :\n    2 \u2264 length (toList p x) \u2194 x \u2208 p.support", "start": [238, 1], "end": [239, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.length_toList_pos_of_mem_support", "code": "theorem length_toList_pos_of_mem_support (h : x \u2208 p.support) : 0 < length (toList p x)", "start": [242, 1], "end": [243, 68], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nthLe_toList", "code": "theorem nthLe_toList (n : \u2115) (hn : n < length (toList p x)) : (toList p x).nthLe n hn = (p ^ n) x", "start": [246, 1], "end": [247, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_nthLe_zero", "code": "theorem toList_nthLe_zero (h : x \u2208 p.support) :\n    (toList p x).nthLe 0 (length_toList_pos_of_mem_support _ _ h) = x", "start": [250, 1], "end": [251, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_toList_iff", "code": "theorem mem_toList_iff {y : \u03b1} : y \u2208 toList p x \u2194 SameCycle p x y \u2227 x \u2208 p.support", "start": [256, 1], "end": [265, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nodup_toList", "code": "theorem nodup_toList (p : Perm \u03b1) (x : \u03b1) : Nodup (toList p x)", "start": [269, 1], "end": [299, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.next_toList_eq_apply", "code": "theorem next_toList_eq_apply (p : Perm \u03b1) (x y : \u03b1) (hy : y \u2208 toList p x) :\n    next (toList p x) y hy = p y", "start": [303, 1], "end": [311, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_pow_apply_eq_rotate", "code": "theorem toList_pow_apply_eq_rotate (p : Perm \u03b1) (x : \u03b1) (k : \u2115) :\n    p.toList ((p ^ k) x) = (p.toList x).rotate k", "start": [315, 1], "end": [321, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.toList_isRotated", "code": "theorem SameCycle.toList_isRotated {f : Perm \u03b1} {x y : \u03b1} (h : SameCycle f x y) :\n    toList f x ~r toList f y", "start": [324, 1], "end": [334, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_apply_mem_toList_iff_mem_support", "code": "theorem pow_apply_mem_toList_iff_mem_support {n : \u2115} : (p ^ n) x \u2208 p.toList x \u2194 x \u2208 p.support", "start": [337, 1], "end": [340, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_formPerm_nil", "code": "theorem toList_formPerm_nil (x : \u03b1) : toList (formPerm ([] : List \u03b1)) x = []", "start": [343, 1], "end": [343, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_formPerm_singleton", "code": "theorem toList_formPerm_singleton (x y : \u03b1) : toList (formPerm [x]) y = []", "start": [346, 1], "end": [346, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_formPerm_nontrivial", "code": "theorem toList_formPerm_nontrivial (l : List \u03b1) (hl : 2 \u2264 l.length) (hn : Nodup l) :\n    toList (formPerm l) (l.nthLe 0 (zero_lt_two.trans_le hl)) = l", "start": [350, 1], "end": [362, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toList_formPerm_isRotated_self", "code": "theorem toList_formPerm_isRotated_self (l : List \u03b1) (hl : 2 \u2264 l.length) (hn : Nodup l) (x : \u03b1)\n    (hx : x \u2208 l) : toList (formPerm l) x ~r l", "start": [365, 1], "end": [375, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.formPerm_toList", "code": "theorem formPerm_toList (f : Perm \u03b1) (x : \u03b1) : formPerm (toList f x) = f.cycleOf x", "start": [378, 1], "end": [390, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toCycle", "code": "def toCycle (f : Perm \u03b1) (hf : IsCycle f) : Cycle \u03b1 :=\n  Multiset.recOn (Finset.univ : Finset \u03b1).val (Quot.mk _ [])\n    (fun x _ l => if f x = x then l else toList f x)\n    (by\n      intro x y _ s\n      refine' heq_of_eq _\n      split_ifs with hx hy hy <;> try rfl\n      \u00b7 have hc : SameCycle f x y := IsCycle.sameCycle hf hx hy\n        exact Quotient.sound' hc.toList_isRotated)", "start": [393, 1], "end": [406, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.toCycle_eq_toList", "code": "theorem toCycle_eq_toList (f : Perm \u03b1) (hf : IsCycle f) (x : \u03b1) (hx : f x \u2260 x) :\n    toCycle f hf = toList f x", "start": [409, 1], "end": [413, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nodup_toCycle", "code": "theorem nodup_toCycle (f : Perm \u03b1) (hf : IsCycle f) : (toCycle f hf).Nodup", "start": [416, 1], "end": [418, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nontrivial_toCycle", "code": "theorem nontrivial_toCycle (f : Perm \u03b1) (hf : IsCycle f) : (toCycle f hf).Nontrivial", "start": [421, 1], "end": [423, 92], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isoCycle", "code": "def isoCycle : { f : Perm \u03b1 // IsCycle f } \u2243 { s : Cycle \u03b1 // s.Nodup \u2227 s.Nontrivial } where\n  toFun f := \u27e8toCycle (f : Perm \u03b1) f.prop, nodup_toCycle f f.prop, nontrivial_toCycle _ f.prop\u27e9\n  invFun s := \u27e8(s : Cycle \u03b1).formPerm s.prop.left, (s : Cycle \u03b1).isCycle_formPerm _ s.prop.right\u27e9\n  left_inv f := by\n    obtain \u27e8x, hx, -\u27e9 := id f.prop\n    simpa [toCycle_eq_toList (f : Perm \u03b1) f.prop x hx, formPerm_toList, Subtype.ext_iff] using\n      f.prop.cycleOf_eq hx\n  right_inv s := by\n    rcases s with \u27e8\u27e8s\u27e9, hn, ht\u27e9\n    obtain \u27e8x, -, -, hx, -\u27e9 := id ht\n    have hl : 2 \u2264 s.length := by simpa using Cycle.length_nontrivial ht\n    simp only [Cycle.mk_eq_coe, Cycle.nodup_coe_iff, Cycle.mem_coe_iff, Subtype.coe_mk,\n      Cycle.formPerm_coe] at hn hx \u22a2\n    apply Subtype.ext\n    dsimp\n    rw [toCycle_eq_toList _ _ x]\n    \u00b7 refine' Quotient.sound' _\n      exact toList_formPerm_isRotated_self _ hl hn _ hx\n    \u00b7 rw [\u2190 mem_support, support_formPerm_of_nodup _ hn]\n      \u00b7 simpa using hx\n      \u00b7 rintro _ rfl\n        simp [Nat.succ_le_succ_iff] at hl", "start": [426, 1], "end": [451, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.existsUnique_cycle", "code": "theorem IsCycle.existsUnique_cycle {f : Perm \u03b1} (hf : IsCycle f) :\n    \u2203! s : Cycle \u03b1, \u2203 h : s.Nodup, s.formPerm h = f", "start": [460, 1], "end": [475, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.existsUnique_cycle_subtype", "code": "theorem IsCycle.existsUnique_cycle_subtype {f : Perm \u03b1} (hf : IsCycle f) :\n    \u2203! s : { s : Cycle \u03b1 // s.Nodup }, (s : Cycle \u03b1).formPerm s.prop = f", "start": [478, 1], "end": [483, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.existsUnique_cycle_nontrivial_subtype", "code": "theorem IsCycle.existsUnique_cycle_nontrivial_subtype {f : Perm \u03b1} (hf : IsCycle f) :\n    \u2203! s : { s : Cycle \u03b1 // s.Nodup \u2227 s.Nontrivial }, (s : Cycle \u03b1).formPerm s.prop.left = f", "start": [486, 1], "end": [497, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isoCycle'", "code": "def isoCycle' : { f : Perm \u03b1 // IsCycle f } \u2243 { s : Cycle \u03b1 // s.Nodup \u2227 s.Nontrivial } :=\n  let f : { s : Cycle \u03b1 // s.Nodup \u2227 s.Nontrivial } \u2192 { f : Perm \u03b1 // IsCycle f } :=\n    fun s => \u27e8(s : Cycle \u03b1).formPerm s.prop.left, (s : Cycle \u03b1).isCycle_formPerm _ s.prop.right\u27e9\n  { toFun := Fintype.bijInv (show Function.Bijective f by\n      rw [Function.bijective_iff_existsUnique]\n      rintro \u27e8f, hf\u27e9\n      simp only [Subtype.ext_iff]\n      exact hf.existsUnique_cycle_nontrivial_subtype)\n    invFun := f\n    left_inv := Fintype.rightInverse_bijInv _\n    right_inv := Fintype.leftInverse_bijInv _ }", "start": [504, 1], "end": [518, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.repr_perm", "code": "unsafe instance repr_perm [Repr \u03b1] : Repr (Perm \u03b1) :=\n  \u27e8fun f _ => repr (Multiset.pmap (fun (g : Perm \u03b1) (hg : g.IsCycle) => isoCycle \u27e8g, hg\u27e9)\n    (Perm.cycleFactorsFinset f).val fun _ hg => (mem_cycleFactorsFinset_iff.mp (Finset.mem_def.mpr hg)).left)\u27e9", "start": [524, 1], "end": [527, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bool/AllAny.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.all_iff_forall", "code": "theorem all_iff_forall {p : \u03b1 \u2192 Bool} : all l p \u2194 \u2200 a \u2208 l, p a", "start": [27, 1], "end": [30, 62], "kind": "commanddeclaration"}, {"full_name": "List.all_iff_forall_prop", "code": "theorem all_iff_forall_prop : (all l fun a => p a) \u2194 \u2200 a \u2208 l, p a", "start": [33, 1], "end": [34, 49], "kind": "commanddeclaration"}, {"full_name": "List.any_iff_exists", "code": "theorem any_iff_exists {p : \u03b1 \u2192 Bool} : any l p \u2194 \u2203 a \u2208 l, p a", "start": [42, 1], "end": [45, 65], "kind": "commanddeclaration"}, {"full_name": "List.any_iff_exists_prop", "code": "theorem any_iff_exists_prop : (any l fun a => p a) \u2194 \u2203 a \u2208 l, p a", "start": [48, 1], "end": [48, 94], "kind": "commanddeclaration"}, {"full_name": "List.any_of_mem", "code": "theorem any_of_mem {p : \u03b1 \u2192 Bool} (h\u2081 : a \u2208 l) (h\u2082 : p a) : any l p", "start": [51, 1], "end": [52, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/ContinuousMonoidHom.lean", "imports": ["Mathlib/Analysis/Complex/Circle.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousAddMonoidHom", "code": "structure ContinuousAddMonoidHom (A B : Type*) [AddMonoid A] [AddMonoid B] [TopologicalSpace A]\n  [TopologicalSpace B] extends A \u2192+ B where\n  \n  continuous_toFun : @Continuous A B _ _ toFun", "start": [30, 1], "end": [39, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom", "code": "@[to_additive \"The type of continuous additive monoid homomorphisms from `A` to `B`.\"]\nstructure ContinuousMonoidHom extends A \u2192* B where\n  \n  continuous_toFun : @Continuous A B _ _ toFun", "start": [42, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousAddMonoidHomClass", "code": "class ContinuousAddMonoidHomClass (A B : outParam (Type*)) [AddMonoid A] [AddMonoid B]\n  [TopologicalSpace A] [TopologicalSpace B] extends AddMonoidHomClass F A B where\n  \n  map_continuous (f : F) : Continuous f", "start": [56, 1], "end": [64, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHomClass", "code": "@[to_additive]\nclass ContinuousMonoidHomClass (A B : outParam (Type*)) [Monoid A] [Monoid B]\n    [TopologicalSpace A] [TopologicalSpace B] extends MonoidHomClass F A B where\n  \n  map_continuous (f : F) : Continuous f", "start": [67, 1], "end": [76, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHomClass.toContinuousMapClass", "code": "@[to_additive]\ninstance (priority := 100) ContinuousMonoidHomClass.toContinuousMapClass\n    [ContinuousMonoidHomClass F A B] : ContinuousMapClass F A B :=\n  { \u2039ContinuousMonoidHomClass F A B\u203a with }", "start": [88, 1], "end": [91, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.ContinuousMonoidHom.ContinuousMonoidHomClass", "code": "@[to_additive]\ninstance ContinuousMonoidHom.ContinuousMonoidHomClass :\n  ContinuousMonoidHomClass (ContinuousMonoidHom A B) A B where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    obtain \u27e8\u27e8\u27e8 _ , _ \u27e9, _\u27e9, _\u27e9 := f\n    obtain \u27e8\u27e8\u27e8 _ , _ \u27e9, _\u27e9, _\u27e9 := g\n    congr\n\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_continuous f := f.continuous_toFun", "start": [99, 1], "end": [110, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext {f g : ContinuousMonoidHom A B} (h : \u2200 x, f x = g x) : f = g", "start": [119, 1], "end": [121, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.toContinuousMap", "code": "@[to_additive \"Reinterpret a `ContinuousAddMonoidHom` as a `ContinuousMap`.\"]\ndef toContinuousMap (f : ContinuousMonoidHom A B) : C(A, B) :=\n  { f with }", "start": [125, 1], "end": [128, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.toContinuousMap_injective", "code": "@[to_additive]\ntheorem toContinuousMap_injective : Injective (toContinuousMap : _ \u2192 C(A, B))", "start": [132, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.mk'", "code": "@[to_additive \"Construct a `ContinuousAddMonoidHom` from a `Continuous` `AddMonoidHom`.\"]\ndef mk' (f : A \u2192* B) (hf : Continuous f) : ContinuousMonoidHom A B :=\n  { f with continuous_toFun := (hf : Continuous f.toFun)}", "start": [139, 1], "end": [142, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.comp", "code": "@[to_additive (attr := simps!) \"Composition of two continuous homomorphisms.\"]\ndef comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) : ContinuousMonoidHom A C :=\n  mk' (g.toMonoidHom.comp f.toMonoidHom) (g.continuous_toFun.comp f.continuous_toFun)", "start": [146, 1], "end": [149, 86], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.prod", "code": "@[to_additive (attr := simps!) \"Product of two continuous homomorphisms on the same space.\"]\ndef prod (f : ContinuousMonoidHom A B) (g : ContinuousMonoidHom A C) :\n    ContinuousMonoidHom A (B \u00d7 C) :=\n  mk' (f.toMonoidHom.prod g.toMonoidHom) (f.continuous_toFun.prod_mk g.continuous_toFun)", "start": [153, 1], "end": [157, 89], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.prod_map", "code": "@[to_additive (attr := simps!) \"Product of two continuous homomorphisms on different spaces.\"]\ndef prod_map (f : ContinuousMonoidHom A C) (g : ContinuousMonoidHom B D) :\n    ContinuousMonoidHom (A \u00d7 B) (C \u00d7 D) :=\n  mk' (f.toMonoidHom.prodMap g.toMonoidHom) (f.continuous_toFun.prod_map g.continuous_toFun)", "start": [161, 1], "end": [165, 93], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.one", "code": "@[to_additive (attr := simps!) \"The trivial continuous homomorphism.\"]\ndef one : ContinuousMonoidHom A B :=\n  mk' 1 continuous_const", "start": [171, 1], "end": [174, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.id", "code": "@[to_additive (attr := simps!) \"The identity continuous homomorphism.\"]\ndef id : ContinuousMonoidHom A A :=\n  mk' (MonoidHom.id A) continuous_id", "start": [182, 1], "end": [185, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.fst", "code": "@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the first factor.\"]\ndef fst : ContinuousMonoidHom (A \u00d7 B) A :=\n  mk' (MonoidHom.fst A B) continuous_fst", "start": [189, 1], "end": [193, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.snd", "code": "@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the second factor.\"]\ndef snd : ContinuousMonoidHom (A \u00d7 B) B :=\n  mk' (MonoidHom.snd A B) continuous_snd", "start": [197, 1], "end": [201, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.inl", "code": "@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the first factor.\"]\ndef inl : ContinuousMonoidHom A (A \u00d7 B) :=\n  prod (id A) (one A B)", "start": [205, 1], "end": [209, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.inr", "code": "@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the second factor.\"]\ndef inr : ContinuousMonoidHom B (A \u00d7 B) :=\n  prod (one B A) (id B)", "start": [213, 1], "end": [217, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.diag", "code": "@[to_additive (attr := simps!) \"The continuous homomorphism given by the diagonal embedding.\"]\ndef diag : ContinuousMonoidHom A (A \u00d7 A) :=\n  prod (id A) (id A)", "start": [221, 1], "end": [224, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.swap", "code": "@[to_additive (attr := simps!) \"The continuous homomorphism given by swapping components.\"]\ndef swap : ContinuousMonoidHom (A \u00d7 B) (B \u00d7 A) :=\n  prod (snd A B) (fst A B)", "start": [228, 1], "end": [231, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.mul", "code": "@[to_additive (attr := simps!) \"The continuous homomorphism given by addition.\"]\ndef mul : ContinuousMonoidHom (E \u00d7 E) E :=\n  mk' mulMonoidHom continuous_mul", "start": [235, 1], "end": [238, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.inv", "code": "@[to_additive (attr := simps!) \"The continuous homomorphism given by negation.\"]\ndef inv : ContinuousMonoidHom E E :=\n  mk' invMonoidHom continuous_inv", "start": [242, 1], "end": [245, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.coprod", "code": "@[to_additive (attr := simps!) \"Coproduct of two continuous homomorphisms to the same space.\"]\ndef coprod (f : ContinuousMonoidHom A E) (g : ContinuousMonoidHom B E) :\n    ContinuousMonoidHom (A \u00d7 B) E :=\n  (mul E).comp (f.prod_map g)", "start": [251, 1], "end": [255, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.inducing_toContinuousMap", "code": "@[to_additive]\ntheorem inducing_toContinuousMap : Inducing (toContinuousMap : ContinuousMonoidHom A B \u2192 C(A, B))", "start": [276, 1], "end": [278, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.embedding_toContinuousMap", "code": "@[to_additive]\ntheorem embedding_toContinuousMap :\n    Embedding (toContinuousMap : ContinuousMonoidHom A B \u2192 C(A, B))", "start": [282, 1], "end": [285, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.closedEmbedding_toContinuousMap", "code": "@[to_additive]\ntheorem closedEmbedding_toContinuousMap [ContinuousMul B] [T2Space B] :\n    ClosedEmbedding (toContinuousMap : ContinuousMonoidHom A B \u2192 C(A, B))", "start": [289, 1], "end": [329, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.continuous_of_continuous_uncurry", "code": "@[to_additive]\ntheorem continuous_of_continuous_uncurry {A : Type*} [TopologicalSpace A]\n    (f : A \u2192 ContinuousMonoidHom B C) (h : Continuous (Function.uncurry fun x y => f x y)) :\n    Continuous f", "start": [346, 1], "end": [351, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.continuous_comp", "code": "@[to_additive]\ntheorem continuous_comp [LocallyCompactSpace B] :\n    Continuous fun f : ContinuousMonoidHom A B \u00d7 ContinuousMonoidHom B C => f.2.comp f.1", "start": [355, 1], "end": [360, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.continuous_comp_left", "code": "@[to_additive]\ntheorem continuous_comp_left (f : ContinuousMonoidHom A B) :\n    Continuous fun g : ContinuousMonoidHom B C => g.comp f", "start": [364, 1], "end": [368, 90], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.continuous_comp_right", "code": "@[to_additive]\ntheorem continuous_comp_right (f : ContinuousMonoidHom B C) :\n    Continuous fun g : ContinuousMonoidHom A B => f.comp g", "start": [372, 1], "end": [376, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.compLeft", "code": "@[to_additive \"`ContinuousAddMonoidHom _ f` is a functor.\"]\ndef compLeft (f : ContinuousMonoidHom A B) :\n    ContinuousMonoidHom (ContinuousMonoidHom B E) (ContinuousMonoidHom A E) where\n  toFun g := g.comp f\n  map_one' := rfl\n  map_mul' _g _h := rfl\n  continuous_toFun := f.continuous_comp_left", "start": [382, 1], "end": [389, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousMonoidHom.compRight", "code": "@[to_additive \"`ContinuousAddMonoidHom f _` is a functor.\"]\ndef compRight {B : Type*} [CommGroup B] [TopologicalSpace B] [TopologicalGroup B]\n    (f : ContinuousMonoidHom B E) :\n    ContinuousMonoidHom (ContinuousMonoidHom A B) (ContinuousMonoidHom A E) where\n  toFun g := f.comp g\n  map_one' := ext fun _a => map_one f\n  map_mul' g h := ext fun a => map_mul f (g a) (h a)\n  continuous_toFun := f.continuous_comp_right", "start": [395, 1], "end": [403, 46], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual", "code": "def PontryaginDual :=\n  ContinuousMonoidHom A circle", "start": [411, 1], "end": [413, 31], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.map", "code": "noncomputable def map (f : ContinuousMonoidHom A B) :\n    ContinuousMonoidHom (PontryaginDual B) (PontryaginDual A) :=\n  f.compLeft circle", "start": [444, 1], "end": [447, 20], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.map_apply", "code": "@[simp]\ntheorem map_apply (f : ContinuousMonoidHom A B) (x : PontryaginDual B) (y : A) :\n    map f x y = x (f y)", "start": [450, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.map_one", "code": "@[simp]\ntheorem map_one : map (one A B) = one (PontryaginDual B) (PontryaginDual A)", "start": [456, 1], "end": [458, 53], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.map_comp", "code": "@[simp]\ntheorem map_comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) :\n    map (comp g f) = ContinuousMonoidHom.comp (map f) (map g)", "start": [461, 1], "end": [464, 34], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.map_mul", "code": "@[simp]\nnonrec theorem map_mul (f g : ContinuousMonoidHom A E) : map (f * g) = map f * map g", "start": [468, 1], "end": [470, 50], "kind": "commanddeclaration"}, {"full_name": "PontryaginDual.mapHom", "code": "noncomputable def mapHom [LocallyCompactSpace E] :\n    ContinuousMonoidHom (ContinuousMonoidHom A E)\n      (ContinuousMonoidHom (PontryaginDual E) (PontryaginDual A)) where\n  toFun := map\n  map_one' := map_one\n  map_mul' := map_mul\n  continuous_toFun := continuous_of_continuous_uncurry _ continuous_comp", "start": [475, 1], "end": [482, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Dioph.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/Data/Vector3.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/PellMatiyasevic.lean", "Mathlib/Data/Fin/Fin2.lean"], "premises": [{"full_name": "IsPoly", "code": "inductive IsPoly : ((\u03b1 \u2192 \u2115) \u2192 \u2124) \u2192 Prop\n  | proj : \u2200 i, IsPoly fun x : \u03b1 \u2192 \u2115 => x i\n  | const : \u2200 n : \u2124, IsPoly fun _ : \u03b1 \u2192 \u2115 => n\n  | sub : \u2200 {f g : (\u03b1 \u2192 \u2115) \u2192 \u2124}, IsPoly f \u2192 IsPoly g \u2192 IsPoly fun x => f x - g x\n  | mul : \u2200 {f g : (\u03b1 \u2192 \u2115) \u2192 \u2124}, IsPoly f \u2192 IsPoly g \u2192 IsPoly fun x => f x * g x", "start": [74, 1], "end": [82, 81], "kind": "commanddeclaration"}, {"full_name": "IsPoly.neg", "code": "theorem IsPoly.neg {f : (\u03b1 \u2192 \u2115) \u2192 \u2124} : IsPoly f \u2192 IsPoly (-f)", "start": [85, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "IsPoly.add", "code": "theorem IsPoly.add {f g : (\u03b1 \u2192 \u2115) \u2192 \u2124} (hf : IsPoly f) (hg : IsPoly g) : IsPoly (f + g)", "start": [89, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "Poly", "code": "def Poly (\u03b1 : Type u) := { f : (\u03b1 \u2192 \u2115) \u2192 \u2124 // IsPoly f }", "start": [93, 1], "end": [94, 57], "kind": "commanddeclaration"}, {"full_name": "Poly.funLike", "code": "instance funLike : FunLike (Poly \u03b1) (\u03b1 \u2192 \u2115) fun _ => \u2124 :=\n  \u27e8Subtype.val, Subtype.val_injective\u27e9", "start": [101, 1], "end": [102, 39], "kind": "commanddeclaration"}, {"full_name": "Poly.isPoly", "code": "protected theorem isPoly (f : Poly \u03b1) : IsPoly f", "start": [110, 1], "end": [111, 56], "kind": "commanddeclaration"}, {"full_name": "Poly.ext", "code": "@[ext]\ntheorem ext {f g : Poly \u03b1} : (\u2200 x, f x = g x) \u2192 f = g", "start": [114, 1], "end": [116, 73], "kind": "commanddeclaration"}, {"full_name": "Poly.proj", "code": "def proj (i : \u03b1) : Poly \u03b1 := \u27e8_, IsPoly.proj i\u27e9", "start": [119, 1], "end": [120, 48], "kind": "commanddeclaration"}, {"full_name": "Poly.proj_apply", "code": "@[simp]\ntheorem proj_apply (i : \u03b1) (x) : proj i x = x i", "start": [123, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "Poly.const", "code": "def const (n : \u2124) : Poly \u03b1 := \u27e8_, IsPoly.const n\u27e9", "start": [127, 1], "end": [128, 50], "kind": "commanddeclaration"}, {"full_name": "Poly.const_apply", "code": "@[simp]\ntheorem const_apply (n) (x : \u03b1 \u2192 \u2115) : const n x = n", "start": [131, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : Poly \u03b1) = const 0", "start": [147, 1], "end": [148, 50], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : Poly \u03b1) = const 1", "start": [151, 1], "end": [152, 49], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_neg", "code": "@[simp]\ntheorem coe_neg (f : Poly \u03b1) : \u21d1(-f) = -f", "start": [155, 1], "end": [156, 49], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_add", "code": "@[simp]\ntheorem coe_add (f g : Poly \u03b1) : \u21d1(f + g) = f + g", "start": [159, 1], "end": [160, 57], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_sub", "code": "@[simp]\ntheorem coe_sub (f g : Poly \u03b1) : \u21d1(f - g) = f - g", "start": [163, 1], "end": [164, 57], "kind": "commanddeclaration"}, {"full_name": "Poly.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : Poly \u03b1) : \u21d1(f * g) = f * g", "start": [167, 1], "end": [168, 57], "kind": "commanddeclaration"}, {"full_name": "Poly.zero_apply", "code": "@[simp]\ntheorem zero_apply (x) : (0 : Poly \u03b1) x = 0", "start": [171, 1], "end": [172, 51], "kind": "commanddeclaration"}, {"full_name": "Poly.one_apply", "code": "@[simp]\ntheorem one_apply (x) : (1 : Poly \u03b1) x = 1", "start": [175, 1], "end": [176, 50], "kind": "commanddeclaration"}, {"full_name": "Poly.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : Poly \u03b1) (x) : (-f) x = -f x", "start": [179, 1], "end": [180, 58], "kind": "commanddeclaration"}, {"full_name": "Poly.add_apply", "code": "@[simp]\ntheorem add_apply (f g : Poly \u03b1) (x : \u03b1 \u2192 \u2115) : (f + g) x = f x + g x", "start": [183, 1], "end": [184, 76], "kind": "commanddeclaration"}, {"full_name": "Poly.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : Poly \u03b1) (x : \u03b1 \u2192 \u2115) : (f - g) x = f x - g x", "start": [187, 1], "end": [188, 76], "kind": "commanddeclaration"}, {"full_name": "Poly.mul_apply", "code": "@[simp]\ntheorem mul_apply (f g : Poly \u03b1) (x : \u03b1 \u2192 \u2115) : (f * g) x = f x * g x", "start": [191, 1], "end": [192, 76], "kind": "commanddeclaration"}, {"full_name": "Poly.induction", "code": "theorem induction {C : Poly \u03b1 \u2192 Prop} (H1 : \u2200 i, C (proj i)) (H2 : \u2200 n, C (const n))\n    (H3 : \u2200 f g, C f \u2192 C g \u2192 C (f - g)) (H4 : \u2200 f g, C f \u2192 C g \u2192 C (f * g)) (f : Poly \u03b1) : C f", "start": [244, 1], "end": [248, 65], "kind": "commanddeclaration"}, {"full_name": "Poly.sumsq", "code": "def sumsq : List (Poly \u03b1) \u2192 Poly \u03b1\n  | [] => 0\n  | p::ps => p * p + sumsq ps", "start": [251, 1], "end": [257, 30], "kind": "commanddeclaration"}, {"full_name": "Poly.sumsq_nonneg", "code": "theorem sumsq_nonneg (x : \u03b1 \u2192 \u2115) : \u2200 l, 0 \u2264 sumsq l x", "start": [260, 1], "end": [264, 61], "kind": "commanddeclaration"}, {"full_name": "Poly.sumsq_eq_zero", "code": "theorem sumsq_eq_zero (x) : \u2200 l, sumsq l x = 0 \u2194 l.All\u2082 fun a : Poly \u03b1 => a x = 0", "start": [267, 1], "end": [282, 65], "kind": "commanddeclaration"}, {"full_name": "Poly.map", "code": "def map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (g : Poly \u03b1) : Poly \u03b2 :=\n  \u27e8fun v => g <| v \u2218 f, Poly.induction (C := fun g => IsPoly (fun v => g (v \u2218 f)))\n    (fun i => by simp; apply IsPoly.proj) (fun n => by simp; apply IsPoly.const)\n    (fun f g pf pg => by simp; apply IsPoly.sub pf pg)\n    (fun f g pf pg => by simp; apply IsPoly.mul pf pg) _\u27e9", "start": [287, 1], "end": [292, 58], "kind": "commanddeclaration"}, {"full_name": "Poly.map_apply", "code": "@[simp]\ntheorem map_apply {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (g : Poly \u03b1) (v) : map f g v = g (v \u2218 f)", "start": [295, 1], "end": [296, 84], "kind": "commanddeclaration"}, {"full_name": "Dioph", "code": "def Dioph {\u03b1 : Type u} (S : Set (\u03b1 \u2192 \u2115)) : Prop :=\n  \u2203 (\u03b2 : Type u) (p : Poly (Sum \u03b1 \u03b2)), \u2200 v, S v \u2194 \u2203 t, p (v \u2297 t) = 0", "start": [306, 1], "end": [309, 69], "kind": "commanddeclaration"}, {"full_name": "Dioph.ext", "code": "theorem ext (d : Dioph S) (H : \u2200 v, v \u2208 S \u2194 v \u2208 S') : Dioph S'", "start": [318, 1], "end": [318, 87], "kind": "commanddeclaration"}, {"full_name": "Dioph.of_no_dummies", "code": "theorem of_no_dummies (S : Set (\u03b1 \u2192 \u2115)) (p : Poly \u03b1) (h : \u2200 v, S v \u2194 p v = 0) : Dioph S", "start": [321, 1], "end": [322, 93], "kind": "commanddeclaration"}, {"full_name": "Dioph.inject_dummies_lem", "code": "theorem inject_dummies_lem (f : \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 Option \u03b2) (inv : \u2200 x, g (f x) = some x)\n    (p : Poly (Sum \u03b1 \u03b2)) (v : \u03b1 \u2192 \u2115) :\n    (\u2203 t, p (v \u2297 t) = 0) \u2194 \u2203 t, p.map (inl \u2297 inr \u2218 f) (v \u2297 t) = 0", "start": [325, 1], "end": [333, 33], "kind": "commanddeclaration"}, {"full_name": "Dioph.inject_dummies", "code": "theorem inject_dummies (f : \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 Option \u03b2) (inv : \u2200 x, g (f x) = some x)\n    (p : Poly (Sum \u03b1 \u03b2)) (h : \u2200 v, S v \u2194 \u2203 t, p (v \u2297 t) = 0) :\n    \u2203 q : Poly (Sum \u03b1 \u03b3), \u2200 v, S v \u2194 \u2203 t, q (v \u2297 t) = 0", "start": [336, 1], "end": [339, 82], "kind": "commanddeclaration"}, {"full_name": "Dioph.reindex_dioph", "code": "theorem reindex_dioph (f : \u03b1 \u2192 \u03b2) : \u2200 _ : Dioph S, Dioph {v | v \u2218 f \u2208 S}", "start": [344, 1], "end": [349, 56], "kind": "commanddeclaration"}, {"full_name": "Dioph.DiophList.all\u2082", "code": "theorem DiophList.all\u2082 (l : List (Set <| \u03b1 \u2192 \u2115)) (d : l.All\u2082 Dioph) :\n    Dioph {v | l.All\u2082 fun S : Set (\u03b1 \u2192 \u2115) => v \u2208 S}", "start": [354, 1], "end": [388, 82], "kind": "commanddeclaration"}, {"full_name": "Dioph.inter", "code": "theorem inter (d : Dioph S) (d' : Dioph S') : Dioph (S \u2229 S')", "start": [391, 1], "end": [391, 95], "kind": "commanddeclaration"}, {"full_name": "Dioph.union", "code": "theorem union : \u2200 (_ : Dioph S) (_ : Dioph S'), Dioph (S \u222a S')", "start": [394, 1], "end": [410, 48], "kind": "commanddeclaration"}, {"full_name": "Dioph.DiophPfun", "code": "def DiophPfun (f : (\u03b1 \u2192 \u2115) \u2192. \u2115) : Prop :=\n  Dioph {v : Option \u03b1 \u2192 \u2115 | f.graph (v \u2218 some, v none)}", "start": [413, 1], "end": [415, 56], "kind": "commanddeclaration"}, {"full_name": "Dioph.DiophFn", "code": "def DiophFn (f : (\u03b1 \u2192 \u2115) \u2192 \u2115) : Prop :=\n  Dioph {v : Option \u03b1 \u2192 \u2115 | f (v \u2218 some) = v none}", "start": [418, 1], "end": [420, 51], "kind": "commanddeclaration"}, {"full_name": "Dioph.reindex_diophFn", "code": "theorem reindex_diophFn {f : (\u03b1 \u2192 \u2115) \u2192 \u2115} (g : \u03b1 \u2192 \u03b2) (d : DiophFn f) :\n    DiophFn fun v => f (v \u2218 g)", "start": [423, 1], "end": [424, 87], "kind": "commanddeclaration"}, {"full_name": "Dioph.ex_dioph", "code": "theorem ex_dioph {S : Set (Sum \u03b1 \u03b2 \u2192 \u2115)} : Dioph S \u2192 Dioph {v | \u2203 x, v \u2297 x \u2208 S}", "start": [427, 1], "end": [442, 97], "kind": "commanddeclaration"}, {"full_name": "Dioph.ex1_dioph", "code": "theorem ex1_dioph {S : Set (Option \u03b1 \u2192 \u2115)} : Dioph S \u2192 Dioph {v | \u2203 x, x ::\u2092 v \u2208 S}", "start": [445, 1], "end": [461, 98], "kind": "commanddeclaration"}, {"full_name": "Dioph.dom_dioph", "code": "theorem dom_dioph {f : (\u03b1 \u2192 \u2115) \u2192. \u2115} (d : DiophPfun f) : Dioph f.Dom", "start": [464, 1], "end": [465, 89], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_iff_pFun", "code": "theorem diophFn_iff_pFun (f : (\u03b1 \u2192 \u2115) \u2192 \u2115) : DiophFn f = @DiophPfun \u03b1 f", "start": [468, 1], "end": [469, 75], "kind": "commanddeclaration"}, {"full_name": "Dioph.abs_poly_dioph", "code": "theorem abs_poly_dioph (p : Poly \u03b1) : DiophFn fun v => (p v).natAbs", "start": [472, 1], "end": [474, 61], "kind": "commanddeclaration"}, {"full_name": "Dioph.proj_dioph", "code": "theorem proj_dioph (i : \u03b1) : DiophFn fun v => v i", "start": [477, 1], "end": [478, 31], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophPfun_comp1", "code": "theorem diophPfun_comp1 {S : Set (Option \u03b1 \u2192 \u2115)} (d : Dioph S) {f} (df : DiophPfun f) :\n    Dioph {v : \u03b1 \u2192 \u2115 | \u2203 h : f.Dom v, f.fn v h ::\u2092 v \u2208 S}", "start": [481, 1], "end": [489, 89], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_comp1", "code": "theorem diophFn_comp1 {S : Set (Option \u03b1 \u2192 \u2115)} (d : Dioph S) {f : (\u03b1 \u2192 \u2115) \u2192 \u2115} (df : DiophFn f) :\n    Dioph {v | f v ::\u2092 v \u2208 S}", "start": [492, 1], "end": [495, 54], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_vec_comp1", "code": "theorem diophFn_vec_comp1 {S : Set (Vector3 \u2115 (succ n))} (d : Dioph S) {f : Vector3 \u2115 n \u2192 \u2115}\n    (df : DiophFn f) : Dioph {v : Vector3 \u2115 n | (f v::v) \u2208 S}", "start": [511, 1], "end": [517, 28], "kind": "commanddeclaration"}, {"full_name": "Dioph.vec_ex1_dioph", "code": "theorem vec_ex1_dioph (n) {S : Set (Vector3 \u2115 (succ n))} (d : Dioph S) :\n    Dioph {v : Fin2 n \u2192 \u2115 | \u2203 x, (x::v) \u2208 S}", "start": [520, 1], "end": [526, 56], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_vec", "code": "theorem diophFn_vec (f : Vector3 \u2115 n \u2192 \u2115) : DiophFn f \u2194 Dioph {v | f (v \u2218 fs) = v fz}", "start": [529, 1], "end": [530, 62], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophPfun_vec", "code": "theorem diophPfun_vec (f : Vector3 \u2115 n \u2192. \u2115) : DiophPfun f \u2194 Dioph {v | f.graph (v \u2218 fs, v fz)}", "start": [533, 1], "end": [534, 62], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_compn", "code": "theorem diophFn_compn :\n    \u2200 {n} {S : Set (Sum \u03b1 (Fin2 n) \u2192 \u2115)} (_ : Dioph S) {f : Vector3 ((\u03b1 \u2192 \u2115) \u2192 \u2115) n}\n      (_ : VectorAllP DiophFn f), Dioph {v : \u03b1 \u2192 \u2115 | (v \u2297 fun i => f i v) \u2208 S}", "start": [537, 1], "end": [564, 49], "kind": "commanddeclaration"}, {"full_name": "Dioph.dioph_comp", "code": "theorem dioph_comp {S : Set (Vector3 \u2115 n)} (d : Dioph S) (f : Vector3 ((\u03b1 \u2192 \u2115) \u2192 \u2115) n)\n    (df : VectorAllP DiophFn f) : Dioph {v | (fun i => f i v) \u2208 S}", "start": [567, 1], "end": [569, 43], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_comp", "code": "theorem diophFn_comp {f : Vector3 \u2115 n \u2192 \u2115} (df : DiophFn f) (g : Vector3 ((\u03b1 \u2192 \u2115) \u2192 \u2115) n)\n    (dg : VectorAllP DiophFn g) : DiophFn fun v => f fun i => g i v", "start": [572, 1], "end": [577, 67], "kind": "commanddeclaration"}, {"full_name": "Dioph.proj_dioph_of_nat", "code": "theorem proj_dioph_of_nat {n : \u2115} (m : \u2115) [IsLT m n] : DiophFn fun v : Vector3 \u2115 n => v &m", "start": [588, 1], "end": [589, 16], "kind": "commanddeclaration"}, {"full_name": "Dioph.const_dioph", "code": "theorem const_dioph (n : \u2115) : DiophFn (const (\u03b1 \u2192 \u2115) n)", "start": [594, 1], "end": [595, 32], "kind": "commanddeclaration"}, {"full_name": "Dioph.dioph_comp2", "code": "theorem dioph_comp2 {S : \u2115 \u2192 \u2115 \u2192 Prop} (d : Dioph fun v : Vector3 \u2115 2 => S (v &0) (v &1)) :\n    Dioph fun v => S (f v) (g v)", "start": [602, 1], "end": [603, 65], "kind": "commanddeclaration"}, {"full_name": "Dioph.diophFn_comp2", "code": "theorem diophFn_comp2 {h : \u2115 \u2192 \u2115 \u2192 \u2115} (d : DiophFn fun v : Vector3 \u2115 2 => h (v &0) (v &1)) :\n    DiophFn fun v => h (f v) (g v)", "start": [606, 1], "end": [607, 69], "kind": "commanddeclaration"}, {"full_name": "Dioph.eq_dioph", "code": "theorem eq_dioph : Dioph fun v => f v = g v", "start": [610, 1], "end": [613, 95], "kind": "commanddeclaration"}, {"full_name": "Dioph.add_dioph", "code": "theorem add_dioph : DiophFn fun v => f v + g v", "start": [619, 1], "end": [620, 90], "kind": "commanddeclaration"}, {"full_name": "Dioph.mul_dioph", "code": "theorem mul_dioph : DiophFn fun v => f v * g v", "start": [626, 1], "end": [627, 90], "kind": "commanddeclaration"}, {"full_name": "Dioph.le_dioph", "code": "theorem le_dioph : Dioph {v | f v \u2264 g v}", "start": [633, 1], "end": [635, 85], "kind": "commanddeclaration"}, {"full_name": "Dioph.lt_dioph", "code": "theorem lt_dioph : Dioph {v | f v < g v}", "start": [640, 1], "end": [640, 60], "kind": "commanddeclaration"}, {"full_name": "Dioph.ne_dioph", "code": "theorem ne_dioph : Dioph {v | f v \u2260 g v}", "start": [645, 1], "end": [646, 79], "kind": "commanddeclaration"}, {"full_name": "Dioph.sub_dioph", "code": "theorem sub_dioph : DiophFn fun v => f v - g v", "start": [651, 1], "end": [664, 62], "kind": "commanddeclaration"}, {"full_name": "Dioph.dvd_dioph", "code": "theorem dvd_dioph : Dioph fun v => f v \u2223 g v", "start": [669, 1], "end": [670, 59], "kind": "commanddeclaration"}, {"full_name": "Dioph.mod_dioph", "code": "theorem mod_dioph : DiophFn fun v => f v % g v", "start": [675, 1], "end": [688, 36], "kind": "commanddeclaration"}, {"full_name": "Dioph.modEq_dioph", "code": "theorem modEq_dioph {h : (\u03b1 \u2192 \u2115) \u2192 \u2115} (dh : DiophFn h) : Dioph fun v => f v \u2261 g v [MOD h v]", "start": [693, 1], "end": [694, 23], "kind": "commanddeclaration"}, {"full_name": "Dioph.div_dioph", "code": "theorem div_dioph : DiophFn fun v => f v / g v", "start": [699, 1], "end": [718, 92], "kind": "commanddeclaration"}, {"full_name": "Dioph.pell_dioph", "code": "theorem pell_dioph :\n    Dioph fun v : Vector3 \u2115 4 => \u2203 h : 1 < v &0, xn h (v &1) = v &2 \u2227 yn h (v &1) = v &3", "start": [726, 1], "end": [751, 49], "kind": "commanddeclaration"}, {"full_name": "Dioph.xn_dioph", "code": "theorem xn_dioph : DiophPfun fun v : Vector3 \u2115 2 => \u27e81 < v &0, fun h => xn h (v &1)\u27e9", "start": [754, 1], "end": [759, 91], "kind": "commanddeclaration"}, {"full_name": "Dioph.pow_dioph", "code": "theorem pow_dioph : DiophFn fun v => f v ^ g v", "start": [762, 1], "end": [788, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PSigma/Order.lean", "imports": ["Mathlib/Data/Sigma/Lex.lean", "lake-packages/lean4/src/lean/Init/NotationExtra.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/BoundedOrder.lean", "Mathlib/Mathport/Notation.lean"], "premises": [{"full_name": "PSigma.Lex.le", "code": "instance le [LT \u03b9] [\u2200 i, LE (\u03b1 i)] : LE (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8Lex (\u00b7 < \u00b7) fun _ => (\u00b7 \u2264 \u00b7)\u27e9", "start": [44, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.lt", "code": "instance lt [LT \u03b9] [\u2200 i, LT (\u03b1 i)] : LT (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8Lex (\u00b7 < \u00b7) fun _ => (\u00b7 < \u00b7)\u27e9", "start": [49, 1], "end": [51, 33], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.preorder", "code": "instance preorder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] : Preorder (\u03a3\u2097' i, \u03b1 i) :=\n  { Lex.le, Lex.lt with\n    le_refl := fun \u27e8i, a\u27e9 => Lex.right _ le_rfl,\n    le_trans := by\n      rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 \u27e8a\u2083, b\u2083\u27e9 \u27e8h\u2081r\u27e9 \u27e8h\u2082r\u27e9\n      \u00b7 left\n        apply lt_trans\n        repeat' assumption\n      \u00b7 left\n        assumption\n      \u00b7 left\n        assumption\n      \u00b7 right\n        apply le_trans\n        repeat' assumption,\n    lt_iff_le_not_le := by\n      refine' fun a b => \u27e8fun hab => \u27e8hab.mono_right fun i a b => le_of_lt, _\u27e9, _\u27e9\n      \u00b7 rintro (\u27e8i, a, hji\u27e9 | \u27e8i, hba\u27e9) <;> obtain \u27e8_, _, hij\u27e9 | \u27e8_, hab\u27e9 := hab\n        \u00b7 exact hij.not_lt hji\n        \u00b7 exact lt_irrefl _ hji\n        \u00b7 exact lt_irrefl _ hij\n        \u00b7 exact hab.not_le hba\n      \u00b7 rintro \u27e8\u27e8j, b, hij\u27e9 | \u27e8i, hab\u27e9, hba\u27e9\n        \u00b7 exact Lex.left _ _ hij\n        \u00b7 exact Lex.right _ (hab.lt_of_not_le fun h => hba <| Lex.right _ h) }", "start": [54, 1], "end": [78, 79], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.partialOrder", "code": "instance partialOrder [PartialOrder \u03b9] [\u2200 i, PartialOrder (\u03b1 i)] : PartialOrder (\u03a3\u2097' i, \u03b1 i) :=\n  { Lex.preorder with\n    le_antisymm := by\n      rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 (\u27e8_, _, hlt\u2081\u27e9 | \u27e8_, hlt\u2081\u27e9) (\u27e8_, _, hlt\u2082\u27e9 | \u27e8_, hlt\u2082\u27e9)\n      \u00b7 exact (lt_irrefl a\u2081 <| hlt\u2081.trans hlt\u2082).elim\n      \u00b7 exact (lt_irrefl a\u2081 hlt\u2081).elim\n      \u00b7 exact (lt_irrefl a\u2081 hlt\u2082).elim\n      \u00b7 rw [hlt\u2081.antisymm hlt\u2082] }", "start": [81, 1], "end": [89, 34], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.linearOrder", "code": "instance linearOrder [LinearOrder \u03b9] [\u2200 i, LinearOrder (\u03b1 i)] : LinearOrder (\u03a3\u2097' i, \u03b1 i) :=\n  { Lex.partialOrder with\n    le_total := by\n      rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9\n      obtain hij | rfl | hji := lt_trichotomy i j\n      \u00b7 exact Or.inl (Lex.left _ _ hij)\n      \u00b7 obtain hab | hba := le_total a b\n        \u00b7 exact Or.inl (Lex.right _ hab)\n        \u00b7 exact Or.inr (Lex.right _ hba)\n      \u00b7 exact Or.inr (Lex.left _ _ hji),\n    decidableEq := PSigma.decidableEq, decidableLE := Lex.decidable _ _,\n    decidableLT := Lex.decidable _ _ }", "start": [92, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.orderBot", "code": "instance orderBot [PartialOrder \u03b9] [OrderBot \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderBot (\u03b1 \u22a5)] :\n    OrderBot (\u03a3\u2097' i, \u03b1 i) where\n  bot := \u27e8\u22a5, \u22a5\u27e9\n  bot_le := fun \u27e8a, b\u27e9 => by\n    obtain rfl | ha := eq_bot_or_bot_lt a\n    \u00b7 exact Lex.right _ bot_le\n    \u00b7 exact Lex.left _ _ ha", "start": [107, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.orderTop", "code": "instance orderTop [PartialOrder \u03b9] [OrderTop \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderTop (\u03b1 \u22a4)] :\n    OrderTop (\u03a3\u2097' i, \u03b1 i) where\n  top := \u27e8\u22a4, \u22a4\u27e9\n  le_top := fun \u27e8a, b\u27e9 => by\n    obtain rfl | ha := eq_top_or_lt_top a\n    \u00b7 exact Lex.right _ le_top\n    \u00b7 exact Lex.left _ _ ha", "start": [117, 1], "end": [124, 28], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.boundedOrder", "code": "instance boundedOrder [PartialOrder \u03b9] [BoundedOrder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [OrderBot (\u03b1 \u22a5)]\n    [OrderTop (\u03b1 \u22a4)] : BoundedOrder (\u03a3\u2097' i, \u03b1 i) :=\n  { Lex.orderBot, Lex.orderTop with }", "start": [127, 1], "end": [130, 38], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.denselyOrdered", "code": "instance denselyOrdered [Preorder \u03b9] [DenselyOrdered \u03b9] [\u2200 i, Nonempty (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] : DenselyOrdered (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | @\u27e8_, _, b, h\u27e9)\n    \u00b7 obtain \u27e8k, hi, hj\u27e9 := exists_between h\n      obtain \u27e8c\u27e9 : Nonempty (\u03b1 k) := inferInstance\n      exact \u27e8\u27e8k, c\u27e9, left _ _ hi, left _ _ hj\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ ha, right _ hb\u27e9\u27e9", "start": [133, 1], "end": [141, 46], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.denselyOrdered_of_noMaxOrder", "code": "instance denselyOrdered_of_noMaxOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] [\u2200 i, NoMaxOrder (\u03b1 i)] : DenselyOrdered (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | @\u27e8_, _, b, h\u27e9)\n    \u00b7 obtain \u27e8c, ha\u27e9 := exists_gt a\n      exact \u27e8\u27e8i, c\u27e9, right _ ha, left _ _ h\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ ha, right _ hb\u27e9\u27e9", "start": [144, 1], "end": [151, 46], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.densely_ordered_of_noMinOrder", "code": "instance densely_ordered_of_noMinOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, DenselyOrdered (\u03b1 i)] [\u2200 i, NoMinOrder (\u03b1 i)] : DenselyOrdered (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9 \u27e8j, b\u27e9 (\u27e8_, _, h\u27e9 | @\u27e8_, _, b, h\u27e9)\n    \u00b7 obtain \u27e8c, hb\u27e9 := exists_lt b\n      exact \u27e8\u27e8j, c\u27e9, left _ _ h, right _ hb\u27e9\n    \u00b7 obtain \u27e8c, ha, hb\u27e9 := exists_between h\n      exact \u27e8\u27e8i, c\u27e9, right _ ha, right _ hb\u27e9\u27e9", "start": [154, 1], "end": [161, 46], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.noMaxOrder_of_nonempty", "code": "instance noMaxOrder_of_nonempty [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [NoMaxOrder \u03b9]\n    [\u2200 i, Nonempty (\u03b1 i)] : NoMaxOrder (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8j, h\u27e9 := exists_gt i\n    obtain \u27e8b\u27e9 : Nonempty (\u03b1 j) := inferInstance\n    exact \u27e8\u27e8j, b\u27e9, left _ _ h\u27e9\u27e9", "start": [164, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.noMinOrder_of_nonempty", "code": "instance noMinOrder_of_nonempty [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [NoMinOrder \u03b9]\n    [\u2200 i, Nonempty (\u03b1 i)] : NoMinOrder (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8j, h\u27e9 := exists_lt i\n    obtain \u27e8b\u27e9 : Nonempty (\u03b1 j) := inferInstance\n    exact \u27e8\u27e8j, b\u27e9, left _ _ h\u27e9\u27e9", "start": [174, 1], "end": [180, 32], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.noMaxOrder", "code": "instance noMaxOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, NoMaxOrder (\u03b1 i)] :\n    NoMaxOrder (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8b, h\u27e9 := exists_gt a\n    exact \u27e8\u27e8i, b\u27e9, right _ h\u27e9\u27e9", "start": [183, 1], "end": [188, 31], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.noMinOrder", "code": "instance noMinOrder [Preorder \u03b9] [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, NoMinOrder (\u03b1 i)] :\n    NoMinOrder (\u03a3\u2097' i, \u03b1 i) :=\n  \u27e8by\n    rintro \u27e8i, a\u27e9\n    obtain \u27e8b, h\u27e9 := exists_lt a\n    exact \u27e8\u27e8i, b\u27e9, right _ h\u27e9\u27e9", "start": [191, 1], "end": [196, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/SheafCondition/EqualizerProducts.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "Mathlib/Topology/Sheaves/SheafCondition/PairwiseIntersections.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens", "code": "def piOpens : C :=\n  \u220f fun i : \u03b9 => F.obj (op (U i))", "start": [42, 1], "end": [44, 34], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.piInters", "code": "def piInters : C :=\n  \u220f fun p : \u03b9 \u00d7 \u03b9 => F.obj (op (U p.1 \u2293 U p.2))", "start": [48, 1], "end": [52, 48], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes", "code": "def leftRes : piOpens F U \u27f6 piInters.{v'} F U :=\n  Pi.lift fun p : \u03b9 \u00d7 \u03b9 => Pi.\u03c0 _ p.1 \u226b F.map (infLELeft (U p.1) (U p.2)).op", "start": [56, 1], "end": [60, 77], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.rightRes", "code": "def rightRes : piOpens F U \u27f6 piInters.{v'} F U :=\n  Pi.lift fun p : \u03b9 \u00d7 \u03b9 => Pi.\u03c0 _ p.2 \u226b F.map (infLERight (U p.1) (U p.2)).op", "start": [64, 1], "end": [68, 78], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.res", "code": "def res : F.obj (op (iSup U)) \u27f6 piOpens.{v'} F U :=\n  Pi.lift fun i : \u03b9 => F.map (TopologicalSpace.Opens.leSupr U i).op", "start": [72, 1], "end": [76, 68], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.res_\u03c0", "code": "@[simp, elementwise]\ntheorem res_\u03c0 (i : \u03b9) : res F U \u226b limit.\u03c0 _ \u27e8i\u27e9 = F.map (Opens.leSupr U i).op", "start": [80, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.w", "code": "@[elementwise]\ntheorem w : res F U \u226b leftRes F U = res F U \u226b rightRes F U", "start": [86, 1], "end": [95, 10], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.diagram", "code": "@[reducible]\ndef diagram : WalkingParallelPair \u2964 C :=\n  parallelPair (leftRes.{v'} F U) (rightRes F U)", "start": [99, 1], "end": [103, 49], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork", "code": "def fork : Fork.{v} (leftRes F U) (rightRes F U) :=\n  Fork.of\u03b9 _ (w F U)", "start": [107, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork_pt", "code": "@[simp]\ntheorem fork_pt : (fork F U).pt = F.obj (op (iSup U))", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork_\u03b9", "code": "@[simp]\ntheorem fork_\u03b9 : (fork F U).\u03b9 = res F U", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork_\u03c0_app_walkingParallelPair_zero", "code": "@[simp]\ntheorem fork_\u03c0_app_walkingParallelPair_zero : (fork F U).\u03c0.app WalkingParallelPair.zero = res F U", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork_\u03c0_app_walkingParallelPair_one", "code": "@[simp (high)]\ntheorem fork_\u03c0_app_walkingParallelPair_one :\n    (fork F U).\u03c0.app WalkingParallelPair.one = res F U \u226b leftRes F U", "start": [134, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.piOpens.isoOfIso", "code": "@[simp]\ndef piOpens.isoOfIso (\u03b1 : F \u2245 G) : piOpens F U \u2245 piOpens.{v'} G U :=\n  Pi.mapIso fun _ => \u03b1.app _", "start": [143, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.piInters.isoOfIso", "code": "@[simp]\ndef piInters.isoOfIso (\u03b1 : F \u2245 G) : piInters F U \u2245 piInters.{v'} G U :=\n  Pi.mapIso fun _ => \u03b1.app _", "start": [150, 1], "end": [153, 29], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.diagram.isoOfIso", "code": "def diagram.isoOfIso (\u03b1 : F \u2245 G) : diagram F U \u2245 diagram.{v'} G U :=\n  NatIso.ofComponents (by rintro \u27e8\u27e9; exact piOpens.isoOfIso U \u03b1; exact piInters.isoOfIso U \u03b1)\n    (by\n      rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9\n      \u00b7 simp\n      \u00b7 refine limit.hom_ext (fun _ => ?_)\n        simp only [leftRes, piOpens.isoOfIso, piInters.isoOfIso, parallelPair_map_left,\n          Functor.mapIso_hom, lim_map, limit.lift_map, limit.lift_\u03c0, Cones.postcompose_obj_\u03c0,\n          NatTrans.comp_app, Fan.mk_\u03c0_app, Discrete.natIso_hom_app, Iso.app_hom, Category.assoc,\n          NatTrans.naturality, limMap_\u03c0_assoc]\n      \u00b7 refine limit.hom_ext (fun _ => ?_)\n        simp only [rightRes, piOpens.isoOfIso, piInters.isoOfIso, parallelPair_map_right,\n          Functor.mapIso_hom, lim_map, limit.lift_map, limit.lift_\u03c0, Cones.postcompose_obj_\u03c0,\n          NatTrans.comp_app, Fan.mk_\u03c0_app, Discrete.natIso_hom_app, Iso.app_hom, Category.assoc,\n          NatTrans.naturality, limMap_\u03c0_assoc]\n      \u00b7 simp)", "start": [157, 1], "end": [177, 14], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionEqualizerProducts.fork.isoOfIso", "code": "def fork.isoOfIso (\u03b1 : F \u2245 G) :\n    fork F U \u2245 (Cones.postcompose (diagram.isoOfIso U \u03b1).inv).obj (fork G U) := by\n  fapply Fork.ext\n  \u00b7 apply \u03b1.app\n  \u00b7 refine limit.hom_ext (fun _ => ?_)\n    dsimp only [Fork.\u03b9]\n    simp only [res, diagram.isoOfIso, Iso.app_hom, piOpens.isoOfIso, Cones.postcompose_obj_\u03c0,\n      NatTrans.comp_app, fork_\u03c0_app_walkingParallelPair_zero, NatIso.ofComponents_inv_app,\n      Functor.mapIso_inv, lim_map, limit.lift_map, Category.assoc, limit.lift_\u03c0, Fan.mk_\u03c0_app,\n      Discrete.natIso_inv_app, Iso.app_inv, NatTrans.naturality, Iso.hom_inv_id_app_assoc]", "start": [181, 1], "end": [198, 91], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.IsSheafEqualizerProducts", "code": "def IsSheafEqualizerProducts (F : Presheaf.{v', v, u} C X) : Prop :=\n  \u2200 \u2983\u03b9 : Type v'\u2984 (U : \u03b9 \u2192 Opens X), Nonempty (IsLimit (SheafConditionEqualizerProducts.fork F U))", "start": [204, 1], "end": [210, 99], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj", "code": "@[simps]\ndef coneEquivFunctorObj (c : Cone ((diagram U).op \u22d9 F)) :\n    Cone (SheafConditionEqualizerProducts.diagram F U) where\n  pt := c.pt\n  \u03c0 :=\n    { app := fun Z =>\n        WalkingParallelPair.casesOn Z (Pi.lift fun i : \u03b9 => c.\u03c0.app (op (single i)))\n          (Pi.lift fun b : \u03b9 \u00d7 \u03b9 => c.\u03c0.app (op (pair b.1 b.2)))\n      naturality := fun Y Z f => by\n        cases Y <;> cases Z <;> cases f\n        \u00b7 refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_\u03c0, Category.id_comp, Fan.mk_\u03c0_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_\u03c0, Category.id_comp, Fan.mk_\u03c0_app]\n        \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n          dsimp [SheafConditionEqualizerProducts.leftRes]\n          simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n            Category.assoc]\n          have h := c.\u03c0.naturality (Quiver.Hom.op (Hom.left i j))\n          dsimp at h\n          simpa using h\n        \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n          dsimp [SheafConditionEqualizerProducts.rightRes]\n          simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n            Category.assoc]\n          have h := c.\u03c0.naturality (Quiver.Hom.op (Hom.right i j))\n          dsimp at h\n          simpa using h\n        \u00b7 refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_\u03c0, Category.id_comp, Fan.mk_\u03c0_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_\u03c0, Category.id_comp, Fan.mk_\u03c0_app] }", "start": [224, 1], "end": [268, 69], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor", "code": "@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op \u22d9 F) \u2964 Limits.Cone (SheafConditionEqualizerProducts.diagram F U)\n    where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          \u00b7 refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_\u03c0_app, Limits.ConeMorphism.w, Limits.limit.lift_\u03c0,\n              Category.assoc, coneEquivFunctorObj_\u03c0_app] }", "start": [274, 1], "end": [288, 59], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj", "code": "@[simps]\ndef coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :\n    Limits.Cone ((diagram U).op \u22d9 F) where\n  pt := c.pt\n  \u03c0 :=\n    { app := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (\u27e8i\u27e9 | \u27e8i, j\u27e9)\n        \u00b7 exact c.\u03c0.app WalkingParallelPair.zero \u226b Pi.\u03c0 _ i\n        \u00b7 exact c.\u03c0.app WalkingParallelPair.one \u226b Pi.\u03c0 _ (i, j)\n      naturality := by\n        intro x y f\n        induction x using Opposite.rec' with | h x => ?_\n        induction y using Opposite.rec' with | h y => ?_\n        have ef : f = f.unop.op := rfl\n        revert ef\n        generalize f.unop = f'\n        rintro rfl\n        rcases x with (\u27e8i\u27e9 | \u27e8\u27e9) <;> rcases y with (\u27e8\u27e9 | \u27e8j, j\u27e9) <;> rcases f' with \u27e8\u27e9\n        \u00b7 dsimp\n          erw [F.map_id]\n          simp\n        \u00b7 dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.\u03c0.naturality WalkingParallelPairHom.left\n          dsimp [SheafConditionEqualizerProducts.leftRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =\u226b Pi.\u03c0 _ (i, j)\n          rw [h']\n          simp only [Category.assoc, limit.lift_\u03c0, Fan.mk_\u03c0_app]\n          rfl\n        \u00b7 dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.\u03c0.naturality WalkingParallelPairHom.right\n          dsimp [SheafConditionEqualizerProducts.rightRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =\u226b Pi.\u03c0 _ (j, i)\n          rw [h']\n          simp\n          rfl\n        \u00b7 dsimp\n          erw [F.map_id]\n          simp }", "start": [294, 1], "end": [338, 17], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse", "code": "@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) \u2964 Limits.Cone ((diagram U).op \u22d9 F)\n    where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (\u27e8i\u27e9 | \u27e8i, j\u27e9)\n        \u00b7 dsimp\n          dsimp only [Fork.\u03b9]\n          rw [\u2190 f.w WalkingParallelPair.zero, Category.assoc]\n        \u00b7 dsimp\n          rw [\u2190 f.w WalkingParallelPair.one, Category.assoc] }", "start": [342, 1], "end": [358, 63], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp", "code": "@[simps]\ndef coneEquivUnitIsoApp (c : Cone ((diagram U).op \u22d9 F)) :\n    (\ud835\udfed (Cone ((diagram U).op \u22d9 F))).obj c \u2245 (coneEquivFunctor F U \u22d9 coneEquivInverse F U).obj c\n    where\n  hom :=\n    { hom := \ud835\udfd9 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_;\n        rcases j with \u27e8\u27e9 <;>\n        \u00b7 dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0] }\n  inv :=\n    { hom := \ud835\udfd9 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_;\n        rcases j with \u27e8\u27e9 <;>\n        \u00b7 dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0] }", "start": [362, 1], "end": [380, 83], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso", "code": "@[simps!]\ndef coneEquivUnitIso :\n    \ud835\udfed (Limits.Cone ((diagram U).op \u22d9 F)) \u2245 coneEquivFunctor F U \u22d9 coneEquivInverse F U :=\n  NatIso.ofComponents (coneEquivUnitIsoApp F U)", "start": [384, 1], "end": [388, 48], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso", "code": "@[simps!]\ndef coneEquivCounitIso :\n    coneEquivInverse F U \u22d9 coneEquivFunctor F U \u2245\n      \ud835\udfed (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=\n  NatIso.ofComponents\n    (fun c =>\n      { hom :=\n          { hom := \ud835\udfd9 _\n            w := by\n              rintro \u27e8_ | _\u27e9\n              \u00b7 refine limit.hom_ext fun \u27e8j\u27e9 => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0]\n              \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0] }\n        inv :=\n          { hom := \ud835\udfd9 _\n            w := by\n              rintro \u27e8_ | _\u27e9\n              \u00b7 refine limit.hom_ext fun \u27e8j\u27e9 => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0]\n              \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_\u03c0_app, Category.id_comp, Limits.limit.lift_\u03c0] } })\n    fun {c d} f => by\n    ext\n    dsimp\n    simp only [Category.comp_id, Category.id_comp]", "start": [392, 1], "end": [430, 51], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv", "code": "@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op \u22d9 F) \u224c Limits.Cone (SheafConditionEqualizerProducts.diagram F U)\n    where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U", "start": [434, 1], "end": [444, 38], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.isLimitMapConeOfIsLimitSheafConditionFork", "code": "def isLimitMapConeOfIsLimitSheafConditionFork\n    (P : IsLimit (SheafConditionEqualizerProducts.fork F U)) : IsLimit (F.mapCone (cocone U).op) :=\n  IsLimit.ofIsoLimit ((IsLimit.ofConeEquiv (coneEquiv F U).symm).symm P)\n    { hom :=\n        { hom := \ud835\udfd9 _\n          w := by\n            intro x\n            induction x with | h x => ?_\n            rcases x with \u27e8\u27e9\n            \u00b7 simp\n              rfl\n            \u00b7 dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,\n                SheafConditionEqualizerProducts.leftRes]\n              simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n                Category.assoc]\n              rw [\u2190 F.map_comp]\n              rfl }\n      inv :=\n        { hom := \ud835\udfd9 _\n          w := by\n            intro x\n            induction x with | h x => ?_\n            rcases x with \u27e8\u27e9\n            \u00b7 simp\n              rfl\n            \u00b7 dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,\n                SheafConditionEqualizerProducts.leftRes]\n              simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n                Category.assoc]\n              rw [\u2190 F.map_comp]\n              rfl } }", "start": [452, 1], "end": [485, 22], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.SheafConditionPairwiseIntersections.isLimitSheafConditionForkOfIsLimitMapCone", "code": "def isLimitSheafConditionForkOfIsLimitMapCone (Q : IsLimit (F.mapCone (cocone U).op)) :\n    IsLimit (SheafConditionEqualizerProducts.fork F U) :=\n  IsLimit.ofIsoLimit ((IsLimit.ofConeEquiv (coneEquiv F U)).symm Q)\n    { hom :=\n        { hom := \ud835\udfd9 _\n          w := by\n            rintro \u27e8\u27e9\n            \u00b7 simp\n              rfl\n            \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n              dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,\n                SheafConditionEqualizerProducts.leftRes]\n              simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n                Category.assoc]\n              rw [\u2190 F.map_comp]\n              rfl }\n      inv :=\n        { hom := \ud835\udfd9 _\n          w := by\n            rintro \u27e8\u27e9\n            \u00b7 simp\n              rfl\n            \u00b7 refine limit.hom_ext fun \u27e8i, j\u27e9 => ?_\n              dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,\n                SheafConditionEqualizerProducts.leftRes]\n              simp only [limit.lift_\u03c0, limit.lift_\u03c0_assoc, Category.id_comp, Fan.mk_\u03c0_app,\n                Category.assoc]\n              rw [\u2190 F.map_comp]\n              rfl } }", "start": [489, 1], "end": [524, 22], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.isSheaf_iff_isSheafEqualizerProducts", "code": "theorem isSheaf_iff_isSheafEqualizerProducts (F : Presheaf C X) :\n    F.IsSheaf \u2194 F.IsSheafEqualizerProducts", "start": [532, 1], "end": [539, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Func.lean", "imports": ["Mathlib/Data/Nat/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Func.neg", "code": "def neg [Neg \u03b1] (as : List \u03b1) :=\n  as.map fun a \u21a6 -a", "start": [44, 1], "end": [46, 20], "kind": "commanddeclaration"}, {"full_name": "List.Func.set", "code": "@[simp]\ndef set (a : \u03b1) : List \u03b1 \u2192 \u2115 \u2192 List \u03b1\n  | _ :: as, 0 => a :: as\n  | [], 0 => [a]\n  | h :: as, k + 1 => h :: set a as k\n  | [], k + 1 => default :: set a ([] : List \u03b1) k", "start": [51, 1], "end": [59, 50], "kind": "commanddeclaration"}, {"full_name": "List.Func.get", "code": "@[simp]\ndef get : \u2115 \u2192 List \u03b1 \u2192 \u03b1\n  | _, [] => default\n  | 0, a :: _ => a\n  | n + 1, _ :: as => get n as", "start": [66, 1], "end": [71, 31], "kind": "commanddeclaration"}, {"full_name": "List.Func.Equiv", "code": "def Equiv (as1 as2 : List \u03b1) : Prop :=\n  \u2200 m : Nat, get m as1 = get m as2", "start": [74, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "List.Func.pointwise", "code": "@[simp]\ndef pointwise (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3\n  | [], [] => []\n  | [], b :: bs => map (f default) (b :: bs)\n  | a :: as, [] => map (fun x \u21a6 f x default) (a :: as)\n  | a :: as, b :: bs => f a b :: pointwise f as bs", "start": [81, 1], "end": [87, 51], "kind": "commanddeclaration"}, {"full_name": "List.Func.add", "code": "def add {\u03b1 : Type u} [Zero \u03b1] [Add \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1 :=\n  @pointwise \u03b1 \u03b1 \u03b1 \u27e80\u27e9 \u27e80\u27e9 (\u00b7 + \u00b7)", "start": [90, 1], "end": [92, 35], "kind": "commanddeclaration"}, {"full_name": "List.Func.sub", "code": "def sub {\u03b1 : Type u} [Zero \u03b1] [Sub \u03b1] : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1 :=\n  @pointwise \u03b1 \u03b1 \u03b1 \u27e80\u27e9 \u27e80\u27e9 (@Sub.sub \u03b1 _)", "start": [95, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "List.Func.length_set", "code": "theorem length_set : \u2200 {m : \u2115} {as : List \u03b1}, as {m \u21a6 a}.length = max as.length (m + 1)", "start": [101, 1], "end": [112, 57], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_nil", "code": "theorem get_nil {k : \u2115} : (get k [] : \u03b1) = default", "start": [116, 1], "end": [116, 73], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_eq_default_of_le", "code": "theorem get_eq_default_of_le : \u2200 (k : \u2115) {as : List \u03b1}, as.length \u2264 k \u2192 get k as = default", "start": [119, 1], "end": [125, 42], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_set", "code": "@[simp]\ntheorem get_set {a : \u03b1} : \u2200 {k : \u2115} {as : List \u03b1}, get k (as {k \u21a6 a}) = a", "start": [128, 1], "end": [131, 48], "kind": "commanddeclaration"}, {"full_name": "List.Func.eq_get_of_mem", "code": "theorem eq_get_of_mem {a : \u03b1} : \u2200 {as : List \u03b1}, a \u2208 as \u2192 \u2203 n : Nat, a = get n as", "start": [134, 1], "end": [142, 23], "kind": "commanddeclaration"}, {"full_name": "List.Func.mem_get_of_le", "code": "theorem mem_get_of_le : \u2200 {n : \u2115} {as : List \u03b1}, n < as.length \u2192 get n as \u2208 as", "start": [147, 1], "end": [155, 36], "kind": "commanddeclaration"}, {"full_name": "List.Func.mem_get_of_ne_zero", "code": "theorem mem_get_of_ne_zero : \u2200 {n : \u2115} {as : List \u03b1}, get n as \u2260 default \u2192 get n as \u2208 as", "start": [158, 1], "end": [164, 13], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_set_eq_of_ne", "code": "theorem get_set_eq_of_ne {a : \u03b1} :\n    \u2200 {as : List \u03b1} (k : \u2115) (m : \u2115), m \u2260 k \u2192 get m (as {k \u21a6 a}) = get m as", "start": [167, 1], "end": [191, 16], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_map", "code": "theorem get_map {f : \u03b1 \u2192 \u03b2} :\n    \u2200 {n : \u2115} {as : List \u03b1}, n < as.length \u2192 get n (as.map f) = f (get n as)", "start": [194, 1], "end": [202, 21], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_map'", "code": "theorem get_map' {f : \u03b1 \u2192 \u03b2} {n : \u2115} {as : List \u03b1} :\n    f default = default \u2192 get n (as.map f) = f (get n as)", "start": [205, 1], "end": [212, 13], "kind": "commanddeclaration"}, {"full_name": "List.Func.forall_val_of_forall_mem", "code": "theorem forall_val_of_forall_mem {as : List \u03b1} {p : \u03b1 \u2192 Prop} :\n    p default \u2192 (\u2200 x \u2208 as, p x) \u2192 \u2200 n, p (get n as)", "start": [215, 1], "end": [222, 13], "kind": "commanddeclaration"}, {"full_name": "List.Func.equiv_refl", "code": "theorem equiv_refl : Equiv as as", "start": [226, 1], "end": [226, 48], "kind": "commanddeclaration"}, {"full_name": "List.Func.equiv_symm", "code": "theorem equiv_symm : Equiv as1 as2 \u2192 Equiv as2 as1", "start": [229, 1], "end": [229, 77], "kind": "commanddeclaration"}, {"full_name": "List.Func.equiv_trans", "code": "theorem equiv_trans : Equiv as1 as2 \u2192 Equiv as2 as3 \u2192 Equiv as1 as3", "start": [232, 1], "end": [233, 25], "kind": "commanddeclaration"}, {"full_name": "List.Func.equiv_of_eq", "code": "theorem equiv_of_eq : as1 = as2 \u2192 Equiv as1 as2", "start": [236, 1], "end": [236, 90], "kind": "commanddeclaration"}, {"full_name": "List.Func.eq_of_equiv", "code": "theorem eq_of_equiv : \u2200 {as1 as2 : List \u03b1}, as1.length = as2.length \u2192 Equiv as1 as2 \u2192 as1 = as2", "start": [239, 1], "end": [249, 23], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_neg", "code": "@[simp]\ntheorem get_neg [AddGroup \u03b1] {k : \u2115} {as : List \u03b1} : @get \u03b1 \u27e80\u27e9 k (neg as) = -@get \u03b1 \u27e80\u27e9 k as", "start": [259, 1], "end": [263, 17], "kind": "commanddeclaration"}, {"full_name": "List.Func.length_neg", "code": "@[simp]\ntheorem length_neg [Neg \u03b1] (as : List \u03b1) : (neg as).length = as.length", "start": [266, 1], "end": [268, 30], "kind": "commanddeclaration"}, {"full_name": "List.Func.nil_pointwise", "code": "theorem nil_pointwise {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} : \u2200 bs : List \u03b2, pointwise f [] bs = bs.map (f default)", "start": [274, 1], "end": [276, 95], "kind": "commanddeclaration"}, {"full_name": "List.Func.pointwise_nil", "code": "theorem pointwise_nil {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} :\n    \u2200 as : List \u03b1, pointwise f as [] = as.map fun a \u21a6 f a default", "start": [279, 1], "end": [282, 100], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_pointwise", "code": "theorem get_pointwise [Inhabited \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (h1 : f default default = default) :\n    \u2200 (k : Nat) (as : List \u03b1) (bs : List \u03b2), get k (pointwise f as bs) = f (get k as) (get k bs)", "start": [285, 1], "end": [298, 68], "kind": "commanddeclaration"}, {"full_name": "List.Func.length_pointwise", "code": "theorem length_pointwise {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} :\n    \u2200 {as : List \u03b1} {bs : List \u03b2}, (pointwise f as bs).length = max as.length bs.length", "start": [301, 1], "end": [309, 80], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_add", "code": "@[simp]\ntheorem get_add {\u03b1 : Type u} [AddMonoid \u03b1] {k : \u2115} {xs ys : List \u03b1} :\n    @get \u03b1 \u27e80\u27e9 k (add xs ys) = @get \u03b1 \u27e80\u27e9 k xs + @get \u03b1 \u27e80\u27e9 k ys", "start": [317, 1], "end": [323, 17], "kind": "commanddeclaration"}, {"full_name": "List.Func.length_add", "code": "@[simp]\ntheorem length_add {\u03b1 : Type u} [Zero \u03b1] [Add \u03b1] {xs ys : List \u03b1} :\n    (add xs ys).length = max xs.length ys.length", "start": [326, 1], "end": [329, 40], "kind": "commanddeclaration"}, {"full_name": "List.Func.nil_add", "code": "@[simp]\ntheorem nil_add {\u03b1 : Type u} [AddMonoid \u03b1] (as : List \u03b1) : add [] as = as", "start": [332, 1], "end": [337, 19], "kind": "commanddeclaration"}, {"full_name": "List.Func.add_nil", "code": "@[simp]\ntheorem add_nil {\u03b1 : Type u} [AddMonoid \u03b1] (as : List \u03b1) : add as [] = as", "start": [343, 1], "end": [348, 19], "kind": "commanddeclaration"}, {"full_name": "List.Func.map_add_map", "code": "theorem map_add_map {\u03b1 : Type u} [AddMonoid \u03b1] (f g : \u03b1 \u2192 \u03b1) {as : List \u03b1} :\n    add (as.map f) (as.map g) = as.map fun x \u21a6 f x + g x", "start": [351, 1], "end": [363, 19], "kind": "commanddeclaration"}, {"full_name": "List.Func.get_sub", "code": "@[simp]\ntheorem get_sub {\u03b1 : Type u} [AddGroup \u03b1] {k : \u2115} {xs ys : List \u03b1} :\n    @get \u03b1 \u27e80\u27e9 k (sub xs ys) = @get \u03b1 \u27e80\u27e9 k xs - @get \u03b1 \u27e80\u27e9 k ys", "start": [367, 1], "end": [371, 17], "kind": "commanddeclaration"}, {"full_name": "List.Func.length_sub", "code": "@[simp]\ntheorem length_sub [Zero \u03b1] [Sub \u03b1] {xs ys : List \u03b1} :\n    (sub xs ys).length = max xs.length ys.length", "start": [374, 1], "end": [377, 40], "kind": "commanddeclaration"}, {"full_name": "List.Func.nil_sub", "code": "@[simp]\ntheorem nil_sub {\u03b1 : Type*} [AddGroup \u03b1] (as : List \u03b1) : sub [] as = neg as", "start": [380, 1], "end": [384, 19], "kind": "commanddeclaration"}, {"full_name": "List.Func.sub_nil", "code": "@[simp]\ntheorem sub_nil {\u03b1 : Type*} [AddGroup \u03b1] (as : List \u03b1) : sub as [] = as", "start": [387, 1], "end": [392, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/Away/AdjoinRoot.lean", "imports": ["Mathlib/RingTheory/AdjoinRoot.lean", "Mathlib/RingTheory/Localization/Away/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Localization.awayEquivAdjoin", "code": "noncomputable def Localization.awayEquivAdjoin (r : R) : Away r \u2243\u2090[R] AdjoinRoot (C r * X - 1) :=\n  AlgEquiv.ofAlgHom\n    { awayLift _ r\n      (isUnit_of_mul_eq_one ((algebraMap R (AdjoinRoot (C r * X - 1))) r) (root (C r * X - 1))\n        (root_isInv r)) with\n      commutes' :=\n        IsLocalization.Away.AwayMap.lift_eq r (isUnit_of_mul_eq_one _ _ <| root_isInv r) }\n    (liftHom _ (IsLocalization.Away.invSelf r) <| by\n      simp only [map_sub, map_mul, aeval_C, aeval_X, IsLocalization.Away.mul_invSelf, aeval_one,\n        sub_self])\n    (Subsingleton.elim _ _)\n    (Subsingleton.elim (h := IsLocalization.algHom_subsingleton (Submonoid.powers r)) _ _)", "start": [24, 1], "end": [39, 91], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.adjoin_inv", "code": "theorem IsLocalization.adjoin_inv (r : R) : IsLocalization.Away r (AdjoinRoot <| C r * X - 1)", "start": [42, 1], "end": [43, 79], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.Away.finitePresentation", "code": "theorem IsLocalization.Away.finitePresentation (r : R) {S} [CommRing S] [Algebra R S]\n    [IsLocalization.Away r S] : Algebra.FinitePresentation R S", "start": [46, 1], "end": [49, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/OpenImmersion.lean", "imports": ["Mathlib/Topology/LocalAtTarget.lean", "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.isOpenImmersion_iff_stalk", "code": "theorem isOpenImmersion_iff_stalk {f : X \u27f6 Y} : IsOpenImmersion f \u2194\n    OpenEmbedding f.1.base \u2227 \u2200 x, IsIso (PresheafedSpace.stalkMap f.1 x)", "start": [34, 1], "end": [38, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersion_stableUnderComposition", "code": "theorem isOpenImmersion_stableUnderComposition :\n    MorphismProperty.StableUnderComposition @IsOpenImmersion", "start": [41, 1], "end": [43, 75], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersion_respectsIso", "code": "theorem isOpenImmersion_respectsIso : MorphismProperty.RespectsIso @IsOpenImmersion", "start": [46, 1], "end": [48, 30], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersion_is_local_at_target", "code": "theorem isOpenImmersion_is_local_at_target : PropertyIsLocalAtTarget @IsOpenImmersion", "start": [51, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsOpenImmersion.openCover_TFAE", "code": "theorem IsOpenImmersion.openCover_TFAE {X Y : Scheme.{u}} (f : X \u27f6 Y) : List.TFAE\n    [IsOpenImmersion f,\n    \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} Y,\n      \u2200 i : \ud835\udcb0.J, IsOpenImmersion (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n    \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (i : \ud835\udcb0.J),\n      IsOpenImmersion (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n    \u2200 U : Opens Y.carrier, IsOpenImmersion (f \u2223_ U),\n    \u2200 {U : Scheme} (g : U \u27f6 Y) [IsOpenImmersion g],\n      IsOpenImmersion (pullback.snd : pullback f g \u27f6 _),\n    \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4),\n      \u2200 i, IsOpenImmersion (f \u2223_ U i)]", "start": [75, 1], "end": [86, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsOpenImmersion.openCover_iff", "code": "theorem IsOpenImmersion.openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    (f : X \u27f6 Y) :\n    IsOpenImmersion f \u2194 \u2200 i, IsOpenImmersion (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [89, 1], "end": [92, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersion_stableUnderBaseChange", "code": "theorem isOpenImmersion_stableUnderBaseChange :\n    MorphismProperty.StableUnderBaseChange @IsOpenImmersion", "start": [95, 1], "end": [98, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/CompactOperator.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Bounded.lean", "Mathlib/Topology/Algebra/Module/StrongTopology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsCompactOperator", "code": "def IsCompactOperator {M\u2081 M\u2082 : Type*} [Zero M\u2081] [TopologicalSpace M\u2081] [TopologicalSpace M\u2082]\n    (f : M\u2081 \u2192 M\u2082) : Prop :=\n  \u2203 K, IsCompact K \u2227 f \u207b\u00b9' K \u2208 (\ud835\udcdd 0 : Filter M\u2081)", "start": [55, 1], "end": [63, 49], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_zero", "code": "theorem isCompactOperator_zero {M\u2081 M\u2082 : Type*} [Zero M\u2081] [TopologicalSpace M\u2081]\n    [TopologicalSpace M\u2082] [Zero M\u2082] : IsCompactOperator (0 : M\u2081 \u2192 M\u2082)", "start": [66, 1], "end": [68, 70], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_exists_mem_nhds_image_subset_compact", "code": "theorem isCompactOperator_iff_exists_mem_nhds_image_subset_compact (f : M\u2081 \u2192 M\u2082) :\n    IsCompactOperator f \u2194 \u2203 V \u2208 (\ud835\udcdd 0 : Filter M\u2081), \u2203 K : Set M\u2082, IsCompact K \u2227 f '' V \u2286 K", "start": [78, 1], "end": [81, 59], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image", "code": "theorem isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image [T2Space M\u2082] (f : M\u2081 \u2192 M\u2082) :\n    IsCompactOperator f \u2194 \u2203 V \u2208 (\ud835\udcdd 0 : Filter M\u2081), IsCompact (closure <| f '' V)", "start": [84, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.image_subset_compact_of_isVonNBounded", "code": "theorem IsCompactOperator.image_subset_compact_of_isVonNBounded {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) {S : Set M\u2081} (hS : IsVonNBounded \ud835\udd5c\u2081 S) :\n    \u2203 K : Set M\u2082, IsCompact K \u2227 f '' S \u2286 K", "start": [100, 1], "end": [108, 87], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.isCompact_closure_image_of_isVonNBounded", "code": "theorem IsCompactOperator.isCompact_closure_image_of_isVonNBounded [T2Space M\u2082] {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) {S : Set M\u2081} (hS : IsVonNBounded \ud835\udd5c\u2081 S) :\n    IsCompact (closure <| f '' S)", "start": [112, 1], "end": [116, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.image_subset_compact_of_bounded", "code": "theorem IsCompactOperator.image_subset_compact_of_bounded [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) {S : Set M\u2081} (hS : Bornology.IsBounded S) :\n    \u2203 K : Set M\u2082, IsCompact K \u2227 f '' S \u2286 K", "start": [128, 1], "end": [131, 85], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.isCompact_closure_image_of_bounded", "code": "theorem IsCompactOperator.isCompact_closure_image_of_bounded [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    [T2Space M\u2082] {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) {S : Set M\u2081}\n    (hS : Bornology.IsBounded S) : IsCompact (closure <| f '' S)", "start": [134, 1], "end": [137, 88], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.image_ball_subset_compact", "code": "theorem IsCompactOperator.image_ball_subset_compact [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) (r : \u211d) : \u2203 K : Set M\u2082, IsCompact K \u2227 f '' Metric.ball 0 r \u2286 K", "start": [140, 1], "end": [142, 84], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.image_closedBall_subset_compact", "code": "theorem IsCompactOperator.image_closedBall_subset_compact [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) (r : \u211d) :\n    \u2203 K : Set M\u2082, IsCompact K \u2227 f '' Metric.closedBall 0 r \u2286 K", "start": [145, 1], "end": [148, 90], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.isCompact_closure_image_ball", "code": "theorem IsCompactOperator.isCompact_closure_image_ball [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082]\n    {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) (r : \u211d) :\n    IsCompact (closure <| f '' Metric.ball 0 r)", "start": [151, 1], "end": [154, 87], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.isCompact_closure_image_closedBall", "code": "theorem IsCompactOperator.isCompact_closure_image_closedBall [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    [T2Space M\u2082] {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) (r : \u211d) :\n    IsCompact (closure <| f '' Metric.closedBall 0 r)", "start": [157, 1], "end": [160, 93], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_image_ball_subset_compact", "code": "theorem isCompactOperator_iff_image_ball_subset_compact [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {r : \u211d} (hr : 0 < r) :\n    IsCompactOperator f \u2194 \u2203 K : Set M\u2082, IsCompact K \u2227 f '' Metric.ball 0 r \u2286 K", "start": [163, 1], "end": [168, 57], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_image_closedBall_subset_compact", "code": "theorem isCompactOperator_iff_image_closedBall_subset_compact [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {r : \u211d} (hr : 0 < r) :\n    IsCompactOperator f \u2194 \u2203 K : Set M\u2082, IsCompact K \u2227 f '' Metric.closedBall 0 r \u2286 K", "start": [171, 1], "end": [176, 69], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_isCompact_closure_image_ball", "code": "theorem isCompactOperator_iff_isCompact_closure_image_ball [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082]\n    (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {r : \u211d} (hr : 0 < r) :\n    IsCompactOperator f \u2194 IsCompact (closure <| f '' Metric.ball 0 r)", "start": [179, 1], "end": [184, 49], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_iff_isCompact_closure_image_closedBall", "code": "theorem isCompactOperator_iff_isCompact_closure_image_closedBall [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082]\n    [T2Space M\u2082] (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {r : \u211d} (hr : 0 < r) :\n    IsCompactOperator f \u2194 IsCompact (closure <| f '' Metric.closedBall 0 r)", "start": [187, 1], "end": [192, 61], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.smul", "code": "theorem IsCompactOperator.smul {S : Type*} [Monoid S] [DistribMulAction S M\u2082]\n    [ContinuousConstSMul S M\u2082] {f : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f) (c : S) :\n    IsCompactOperator (c \u2022 f)", "start": [206, 1], "end": [211, 58], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.add", "code": "theorem IsCompactOperator.add [ContinuousAdd M\u2082] {f g : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f + g)", "start": [214, 1], "end": [219, 85], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.neg", "code": "theorem IsCompactOperator.neg [ContinuousNeg M\u2084] {f : M\u2081 \u2192 M\u2084} (hf : IsCompactOperator f) :\n    IsCompactOperator (-f)", "start": [222, 1], "end": [225, 83], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.sub", "code": "theorem IsCompactOperator.sub [TopologicalAddGroup M\u2084] {f g : M\u2081 \u2192 M\u2084} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f - g)", "start": [228, 1], "end": [230, 43], "kind": "commanddeclaration"}, {"full_name": "compactOperator", "code": "def compactOperator [Module R\u2081 M\u2081] [Module R\u2084 M\u2084] [ContinuousConstSMul R\u2084 M\u2084]\n    [TopologicalAddGroup M\u2084] : Submodule R\u2084 (M\u2081 \u2192SL[\u03c3\u2081\u2084] M\u2084) where\n  carrier := { f | IsCompactOperator f }\n  add_mem' hf hg := hf.add hg\n  zero_mem' := isCompactOperator_zero\n  smul_mem' c _ hf := hf.smul c", "start": [235, 1], "end": [241, 32], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.comp_clm", "code": "theorem IsCompactOperator.comp_clm [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] {f : M\u2082 \u2192 M\u2083}\n    (hf : IsCompactOperator f) (g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : IsCompactOperator (f \u2218 g)", "start": [252, 1], "end": [257, 26], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.continuous_comp", "code": "theorem IsCompactOperator.continuous_comp {f : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f) {g : M\u2082 \u2192 M\u2083}\n    (hg : Continuous g) : IsCompactOperator (g \u2218 f)", "start": [260, 1], "end": [265, 50], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.clm_comp", "code": "theorem IsCompactOperator.clm_comp [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] [AddCommMonoid M\u2083]\n    [Module R\u2083 M\u2083] {f : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f) (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) :\n    IsCompactOperator (g \u2218 f)", "start": [268, 1], "end": [271, 34], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.codRestrict", "code": "theorem IsCompactOperator.codRestrict {f : M\u2081 \u2192 M\u2082} (hf : IsCompactOperator f) {V : Submodule R\u2082 M\u2082}\n    (hV : \u2200 x, f x \u2208 V) (h_closed : IsClosed (V : Set M\u2082)) :\n    IsCompactOperator (Set.codRestrict f V hV)", "start": [282, 1], "end": [286, 73], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.restrict", "code": "theorem IsCompactOperator.restrict {f : M\u2081 \u2192\u2097[R\u2081] M\u2081} (hf : IsCompactOperator f)\n    {V : Submodule R\u2081 M\u2081} (hV : \u2200 v \u2208 V, f v \u2208 V) (h_closed : IsClosed (V : Set M\u2081)) :\n    IsCompactOperator (f.restrict hV)", "start": [298, 1], "end": [309, 70], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.restrict'", "code": "theorem IsCompactOperator.restrict' [SeparatedSpace M\u2082] {f : M\u2082 \u2192\u2097[R\u2082] M\u2082}\n    (hf : IsCompactOperator f) {V : Submodule R\u2082 M\u2082} (hV : \u2200 v \u2208 V, f v \u2208 V)\n    [hcomplete : CompleteSpace V] : IsCompactOperator (f.restrict hV)", "start": [312, 1], "end": [323, 74], "kind": "commanddeclaration"}, {"full_name": "IsCompactOperator.continuous", "code": "@[continuity]\ntheorem IsCompactOperator.continuous {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) :\n    Continuous f", "start": [335, 1], "end": [365, 14], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mkOfIsCompactOperator", "code": "def ContinuousLinearMap.mkOfIsCompactOperator {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} (hf : IsCompactOperator f) :\n    M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082 :=\n  \u27e8f, hf.continuous\u27e9", "start": [368, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap", "code": "@[simp]\ntheorem ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) :\n    (ContinuousLinearMap.mkOfIsCompactOperator hf : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = f", "start": [374, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_mkOfIsCompactOperator", "code": "@[simp]\ntheorem ContinuousLinearMap.coe_mkOfIsCompactOperator {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) : (ContinuousLinearMap.mkOfIsCompactOperator hf : M\u2081 \u2192 M\u2082) = f", "start": [381, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator", "code": "theorem ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator {f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082}\n    (hf : IsCompactOperator f) :\n    ContinuousLinearMap.mkOfIsCompactOperator hf \u2208 compactOperator \u03c3\u2081\u2082 M\u2081 M\u2082", "start": [387, 1], "end": [390, 5], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_isCompactOperator", "code": "theorem isClosed_setOf_isCompactOperator {\ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type*} [NontriviallyNormedField \ud835\udd5c\u2081]\n    [NormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082} {M\u2081 M\u2082 : Type*} [SeminormedAddCommGroup M\u2081]\n    [AddCommGroup M\u2082] [NormedSpace \ud835\udd5c\u2081 M\u2081] [Module \ud835\udd5c\u2082 M\u2082] [UniformSpace M\u2082] [UniformAddGroup M\u2082]\n    [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082] [CompleteSpace M\u2082] :\n    IsClosed { f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082 | IsCompactOperator f }", "start": [395, 1], "end": [431, 7], "kind": "commanddeclaration"}, {"full_name": "compactOperator_topologicalClosure", "code": "theorem compactOperator_topologicalClosure {\ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type*} [NontriviallyNormedField \ud835\udd5c\u2081]\n    [NormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082} {M\u2081 M\u2082 : Type*} [SeminormedAddCommGroup M\u2081]\n    [AddCommGroup M\u2082] [NormedSpace \ud835\udd5c\u2081 M\u2081] [Module \ud835\udd5c\u2082 M\u2082] [UniformSpace M\u2082] [UniformAddGroup M\u2082]\n    [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082] [CompleteSpace M\u2082]\n    [ContinuousSMul \ud835\udd5c\u2082 (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082)] :\n    (compactOperator \u03c3\u2081\u2082 M\u2081 M\u2082).topologicalClosure = compactOperator \u03c3\u2081\u2082 M\u2081 M\u2082", "start": [434, 1], "end": [440, 59], "kind": "commanddeclaration"}, {"full_name": "isCompactOperator_of_tendsto", "code": "theorem isCompactOperator_of_tendsto {\u03b9 \ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type*} [NontriviallyNormedField \ud835\udd5c\u2081]\n    [NormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c\u2081 \u2192+* \ud835\udd5c\u2082} {M\u2081 M\u2082 : Type*} [SeminormedAddCommGroup M\u2081]\n    [AddCommGroup M\u2082] [NormedSpace \ud835\udd5c\u2081 M\u2081] [Module \ud835\udd5c\u2082 M\u2082] [UniformSpace M\u2082] [UniformAddGroup M\u2082]\n    [ContinuousConstSMul \ud835\udd5c\u2082 M\u2082] [T2Space M\u2082] [CompleteSpace M\u2082] {l : Filter \u03b9} [l.NeBot]\n    {F : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} {f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (hf : Tendsto F l (\ud835\udcdd f))\n    (hF : \u2200\u1da0 i in l, IsCompactOperator (F i)) : IsCompactOperator f", "start": [443, 1], "end": [449, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/SqrtNormNum.lean", "imports": ["Mathlib/Data/Nat/Sqrt.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Combinatorics/SetFamily/Kleitman.lean", "imports": ["Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean", "Mathlib/Combinatorics/SetFamily/Intersecting.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.card_biUnion_le_of_intersecting", "code": "theorem Finset.card_biUnion_le_of_intersecting (s : Finset \u03b9) (f : \u03b9 \u2192 Finset (Finset \u03b1))\n    (hf : \u2200 i \u2208 s, (f i : Set (Finset \u03b1)).Intersecting) :\n    (s.biUnion f).card \u2264 2 ^ Fintype.card \u03b1 - 2 ^ (Fintype.card \u03b1 - s.card)", "start": [35, 1], "end": [85, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean", "imports": ["Mathlib/Algebra/Exact.lean", "Mathlib/RingTheory/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "le_comap_range_lTensor", "code": "lemma le_comap_range_lTensor (q : Q) :\n    LinearMap.range g \u2264 (LinearMap.range (lTensor Q g)).comap (TensorProduct.mk R Q P q) := by\n  rintro x \u27e8n, rfl\u27e9\n  exact \u27e8q \u2297\u209c[R] n, rfl\u27e9", "start": [92, 1], "end": [95, 25], "kind": "mathlibtacticlemma"}, {"full_name": "le_comap_range_rTensor", "code": "lemma le_comap_range_rTensor (q : Q) :\n    LinearMap.range g \u2264 (LinearMap.range (rTensor Q g)).comap\n      ((TensorProduct.mk R P Q).flip q) := by\n  rintro x \u27e8n, rfl\u27e9\n  exact \u27e8n \u2297\u209c[R] q, rfl\u27e9", "start": [97, 1], "end": [101, 25], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.surjective", "code": "theorem lTensor.surjective (hg : Function.Surjective g) :\n    Function.Surjective (lTensor Q g)", "start": [105, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "rTensor.surjective", "code": "theorem rTensor.surjective (hg : Function.Surjective g) :\n    Function.Surjective (rTensor Q g)", "start": [119, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exact_subtype_mkQ", "code": "lemma LinearMap.exact_subtype_mkQ (Q : Submodule R N) :\n    Exact (Submodule.subtype Q) (Submodule.mkQ Q) := by\n  rw [exact_iff, Submodule.ker_mkQ, Submodule.range_subtype Q]", "start": [141, 1], "end": [143, 63], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.exact_map_mkQ_range", "code": "lemma LinearMap.exact_map_mkQ_range (f : M \u2192\u2097[R] N) :\n    Exact f (Submodule.mkQ (range f)) :=\n  exact_iff.mpr <| Submodule.ker_mkQ _", "start": [145, 1], "end": [147, 39], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.exact_subtype_ker_map", "code": "lemma LinearMap.exact_subtype_ker_map (g : N \u2192\u2097[R] P) :\n    Exact (Submodule.subtype (ker g)) g :=\n  exact_iff.mpr <| (Submodule.range_subtype _).symm", "start": [149, 1], "end": [151, 52], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.toFun", "code": "noncomputable def lTensor.toFun :\n    Q \u2297[R] N \u29f8 LinearMap.range (lTensor Q f) \u2192\u2097[R] Q \u2297[R] P :=\n  Submodule.liftQ _ (lTensor Q g) <| by\n    rw [LinearMap.range_le_iff_comap, \u2190 LinearMap.ker_comp,\n      \u2190 lTensor_comp, hfg.linearMap_comp_eq_zero, lTensor_zero, ker_zero]", "start": [157, 1], "end": [162, 74], "kind": "commanddeclaration"}, {"full_name": "lTensor.inverse_of_rightInverse", "code": "noncomputable def lTensor.inverse_of_rightInverse {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    Q \u2297[R] P \u2192\u2097[R] Q \u2297[R] N \u29f8 LinearMap.range (lTensor Q f) :=\n  TensorProduct.lift <| LinearMap.flip <| {\n    toFun := fun p \u21a6 Submodule.mkQ _ \u2218\u2097 ((TensorProduct.mk R _ _).flip (h p))\n    map_add' := fun p p' => LinearMap.ext <| fun q => (Submodule.Quotient.eq _).mpr <| by\n      change q \u2297\u209c[R] (h (p + p')) - (q \u2297\u209c[R] (h p) + q \u2297\u209c[R] (h p')) \u2208 range (lTensor Q f)\n      rw [\u2190 TensorProduct.tmul_add, \u2190 TensorProduct.tmul_sub]\n      apply le_comap_range_lTensor f\n      rw [exact_iff] at hfg\n      simp only [\u2190 hfg, mem_ker, map_sub, map_add, hgh _, sub_self]\n    map_smul' := fun r p => LinearMap.ext <| fun q => (Submodule.Quotient.eq _).mpr <| by\n      change q \u2297\u209c[R] (h (r \u2022 p)) - r \u2022 q \u2297\u209c[R] (h p) \u2208 range (lTensor Q f)\n      rw [\u2190 TensorProduct.tmul_smul, \u2190 TensorProduct.tmul_sub]\n      apply le_comap_range_lTensor f\n      rw [exact_iff] at hfg\n      simp only [\u2190 hfg, mem_ker, map_sub, map_smul, hgh _, sub_self] }", "start": [164, 1], "end": [180, 71], "kind": "commanddeclaration"}, {"full_name": "lTensor.inverse_of_rightInverse_apply", "code": "lemma lTensor.inverse_of_rightInverse_apply\n    {h : P \u2192 N} (hgh : Function.RightInverse h g) (y : Q \u2297[R] N) :\n    (lTensor.inverse_of_rightInverse Q hfg hgh) ((lTensor Q g) y) =\n      Submodule.Quotient.mk (p := (LinearMap.range (lTensor Q f))) y := by\n  simp only [\u2190 LinearMap.comp_apply, \u2190 Submodule.mkQ_apply]\n  rw [exact_iff] at hfg\n  apply LinearMap.congr_fun\n  apply TensorProduct.ext'\n  intro n q\n  simp? [lTensor.inverse_of_rightInverse] says\n    simp only [inverse_of_rightInverse, coe_comp, Function.comp_apply, lTensor_tmul,\n      lift.tmul, flip_apply, coe_mk, AddHom.coe_mk, mk_apply, Submodule.mkQ_apply]\n  rw [Submodule.Quotient.eq, \u2190 TensorProduct.tmul_sub]\n  apply le_comap_range_lTensor f n\n  rw [\u2190 hfg, mem_ker, map_sub, sub_eq_zero, hgh]", "start": [182, 1], "end": [196, 49], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.inverse_of_rightInverse_comp_lTensor", "code": "lemma lTensor.inverse_of_rightInverse_comp_lTensor\n    {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    (lTensor.inverse_of_rightInverse Q hfg hgh).comp (lTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (lTensor Q f)) := by\n  rw [LinearMap.ext_iff]\n  intro y\n  simp only [coe_comp, Function.comp_apply, Submodule.mkQ_apply,\n    lTensor.inverse_of_rightInverse_apply]", "start": [198, 1], "end": [205, 43], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.inverse", "code": "noncomputable\ndef lTensor.inverse :\n    Q \u2297[R] P \u2192\u2097[R] Q \u2297[R] N \u29f8 LinearMap.range (lTensor Q f) :=\n  lTensor.inverse_of_rightInverse Q hfg (Function.rightInverse_surjInv hg)", "start": [207, 1], "end": [211, 75], "kind": "commanddeclaration"}, {"full_name": "lTensor.inverse_apply", "code": "lemma lTensor.inverse_apply (y : Q \u2297[R] N) :\n    (lTensor.inverse Q hfg hg) ((lTensor Q g) y) =\n      Submodule.Quotient.mk (p := (LinearMap.range (lTensor Q f))) y := by\n  rw [lTensor.inverse, lTensor.inverse_of_rightInverse_apply]", "start": [213, 1], "end": [216, 62], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.inverse_comp_lTensor", "code": "lemma lTensor.inverse_comp_lTensor :\n    (lTensor.inverse Q hfg hg).comp (lTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (lTensor Q f)) := by\n  rw [lTensor.inverse, lTensor.inverse_of_rightInverse_comp_lTensor]", "start": [218, 1], "end": [221, 69], "kind": "mathlibtacticlemma"}, {"full_name": "lTensor.linearEquiv_of_rightInverse", "code": "noncomputable\ndef lTensor.linearEquiv_of_rightInverse {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    ((Q \u2297[R] N) \u29f8 (LinearMap.range (lTensor Q f))) \u2243\u2097[R] (Q \u2297[R] P) := {\n  toLinearMap := lTensor.toFun Q hfg\n  invFun    := lTensor.inverse_of_rightInverse Q hfg hgh\n  left_inv  := fun y \u21a6 by\n    simp only [lTensor.toFun, AddHom.toFun_eq_coe, coe_toAddHom]\n    obtain \u27e8y, rfl\u27e9 := Submodule.mkQ_surjective _ y\n    simp only [Submodule.mkQ_apply, Submodule.liftQ_apply, lTensor.inverse_of_rightInverse_apply]\n  right_inv := fun z \u21a6 by\n    simp only [AddHom.toFun_eq_coe, coe_toAddHom]\n    obtain \u27e8y, rfl\u27e9 := lTensor.surjective Q (hgh.surjective) z\n    rw [lTensor.inverse_of_rightInverse_apply]\n    simp only [lTensor.toFun, Submodule.liftQ_apply] }", "start": [223, 1], "end": [239, 55], "kind": "commanddeclaration"}, {"full_name": "lTensor.equiv", "code": "noncomputable def lTensor.equiv :\n    ((Q \u2297[R] N) \u29f8 (LinearMap.range (lTensor Q f))) \u2243\u2097[R] (Q \u2297[R] P) :=\n  lTensor.linearEquiv_of_rightInverse Q hfg (Function.rightInverse_surjInv hg)", "start": [241, 1], "end": [245, 79], "kind": "commanddeclaration"}, {"full_name": "lTensor_exact", "code": "theorem lTensor_exact : Exact (lTensor Q f) (lTensor Q g)", "start": [247, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "lTensor_mkQ", "code": "lemma lTensor_mkQ (N : Submodule R M) :\n    ker (lTensor Q (N.mkQ)) = range (lTensor Q N.subtype) := by\n  rw [\u2190 exact_iff]\n  exact lTensor_exact Q (LinearMap.exact_subtype_mkQ N) (Submodule.mkQ_surjective N)", "start": [256, 1], "end": [260, 85], "kind": "mathlibtacticlemma"}, {"full_name": "rTensor.toFun", "code": "noncomputable def rTensor.toFun :\n    N \u2297[R] Q \u29f8 range (rTensor Q f) \u2192\u2097[R] P \u2297[R] Q :=\n  Submodule.liftQ _ (rTensor Q g) <| by\n    rw [range_le_iff_comap, \u2190 ker_comp, \u2190 rTensor_comp,\n      hfg.linearMap_comp_eq_zero, rTensor_zero, ker_zero]", "start": [262, 1], "end": [267, 58], "kind": "commanddeclaration"}, {"full_name": "rTensor.inverse_of_rightInverse", "code": "noncomputable def rTensor.inverse_of_rightInverse {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    P \u2297[R] Q \u2192\u2097[R] N \u2297[R] Q \u29f8 LinearMap.range (rTensor Q f) :=\n  TensorProduct.lift  {\n    toFun := fun p \u21a6 Submodule.mkQ _ \u2218\u2097 TensorProduct.mk R _ _ (h p)\n    map_add' := fun p p' => LinearMap.ext <| fun q => (Submodule.Quotient.eq _).mpr <| by\n      change h (p + p') \u2297\u209c[R] q - (h p \u2297\u209c[R] q + h p' \u2297\u209c[R] q) \u2208 range (rTensor Q f)\n      rw [\u2190 TensorProduct.add_tmul, \u2190 TensorProduct.sub_tmul]\n      apply le_comap_range_rTensor f\n      rw [exact_iff] at hfg\n      simp only [\u2190 hfg, mem_ker, map_sub, map_add, hgh _, sub_self]\n    map_smul' := fun r p => LinearMap.ext <| fun q => (Submodule.Quotient.eq _).mpr <| by\n      change h (r \u2022 p) \u2297\u209c[R] q - r \u2022 h p \u2297\u209c[R] q \u2208 range (rTensor Q f)\n      rw [TensorProduct.smul_tmul', \u2190 TensorProduct.sub_tmul]\n      apply le_comap_range_rTensor f\n      rw [exact_iff] at hfg\n      simp only [\u2190 hfg, mem_ker, map_sub, map_smul, hgh _, sub_self] }", "start": [269, 1], "end": [285, 71], "kind": "commanddeclaration"}, {"full_name": "rTensor.inverse_of_rightInverse_apply", "code": "lemma rTensor.inverse_of_rightInverse_apply\n    {h : P \u2192 N} (hgh : Function.RightInverse h g) (y : N \u2297[R] Q) :\n    (rTensor.inverse_of_rightInverse Q hfg hgh) ((rTensor Q g) y) =\n      Submodule.Quotient.mk (p := LinearMap.range (rTensor Q f)) y := by\n  simp only [\u2190 LinearMap.comp_apply, \u2190 Submodule.mkQ_apply]\n  rw [exact_iff] at hfg\n  apply LinearMap.congr_fun\n  apply TensorProduct.ext'\n  intro n q\n  simp? [rTensor.inverse_of_rightInverse] says\n    simp only [inverse_of_rightInverse, coe_comp, Function.comp_apply, rTensor_tmul,\n      lift.tmul, coe_mk, AddHom.coe_mk, mk_apply, Submodule.mkQ_apply]\n  rw [Submodule.Quotient.eq, \u2190 TensorProduct.sub_tmul]\n  apply le_comap_range_rTensor f\n  rw [\u2190 hfg, mem_ker, map_sub, sub_eq_zero, hgh]", "start": [287, 1], "end": [301, 49], "kind": "mathlibtacticlemma"}, {"full_name": "rTensor.inverse_of_rightInverse_comp_rTensor", "code": "lemma rTensor.inverse_of_rightInverse_comp_rTensor\n    {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    (rTensor.inverse_of_rightInverse Q hfg hgh).comp (rTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (rTensor Q f)) := by\n  rw [LinearMap.ext_iff]\n  intro y\n  simp only [coe_comp, Function.comp_apply, Submodule.mkQ_apply,\n    rTensor.inverse_of_rightInverse_apply]", "start": [303, 1], "end": [310, 43], "kind": "mathlibtacticlemma"}, {"full_name": "rTensor.inverse", "code": "noncomputable\ndef rTensor.inverse :\n    P \u2297[R] Q \u2192\u2097[R] N \u2297[R] Q \u29f8 LinearMap.range (rTensor Q f) :=\n  rTensor.inverse_of_rightInverse Q hfg (Function.rightInverse_surjInv hg)", "start": [312, 1], "end": [316, 75], "kind": "commanddeclaration"}, {"full_name": "rTensor.inverse_apply", "code": "lemma rTensor.inverse_apply (y : N \u2297[R] Q) :\n    (rTensor.inverse Q hfg hg) ((rTensor Q g) y) =\n      Submodule.Quotient.mk (p := LinearMap.range (rTensor Q f)) y := by\n  rw [rTensor.inverse, rTensor.inverse_of_rightInverse_apply]", "start": [318, 1], "end": [321, 62], "kind": "mathlibtacticlemma"}, {"full_name": "rTensor.inverse_comp_rTensor", "code": "lemma rTensor.inverse_comp_rTensor :\n    (rTensor.inverse Q hfg hg).comp (rTensor Q g) =\n      Submodule.mkQ (p := LinearMap.range (rTensor Q f)) := by\n  rw [rTensor.inverse, rTensor.inverse_of_rightInverse_comp_rTensor]", "start": [323, 1], "end": [326, 69], "kind": "mathlibtacticlemma"}, {"full_name": "rTensor.linearEquiv_of_rightInverse", "code": "noncomputable\ndef rTensor.linearEquiv_of_rightInverse {h : P \u2192 N} (hgh : Function.RightInverse h g) :\n    ((N \u2297[R] Q) \u29f8 (range (rTensor Q f))) \u2243\u2097[R] (P \u2297[R] Q) := {\n  toLinearMap := rTensor.toFun Q hfg\n  invFun      := rTensor.inverse_of_rightInverse Q hfg hgh\n  left_inv    := fun y \u21a6 by\n    simp only [rTensor.toFun, AddHom.toFun_eq_coe, coe_toAddHom]\n    obtain \u27e8y, rfl\u27e9 := Submodule.mkQ_surjective _ y\n    simp only [Submodule.mkQ_apply, Submodule.liftQ_apply, rTensor.inverse_of_rightInverse_apply]\n  right_inv   := fun z \u21a6 by\n    simp only [AddHom.toFun_eq_coe, coe_toAddHom]\n    obtain \u27e8y, rfl\u27e9 := rTensor.surjective Q hgh.surjective z\n    rw [rTensor.inverse_of_rightInverse_apply]\n    simp only [rTensor.toFun, Submodule.liftQ_apply] }", "start": [328, 1], "end": [344, 55], "kind": "commanddeclaration"}, {"full_name": "rTensor.equiv", "code": "noncomputable def rTensor.equiv :\n    ((N \u2297[R] Q) \u29f8 (LinearMap.range (rTensor Q f))) \u2243\u2097[R] (P \u2297[R] Q) :=\n  rTensor.linearEquiv_of_rightInverse Q hfg (Function.rightInverse_surjInv hg)", "start": [346, 1], "end": [350, 79], "kind": "commanddeclaration"}, {"full_name": "rTensor_exact", "code": "theorem rTensor_exact : Exact (rTensor Q f) (rTensor Q g)", "start": [352, 1], "end": [359, 48], "kind": "commanddeclaration"}, {"full_name": "rTensor_mkQ", "code": "lemma rTensor_mkQ (N : Submodule R M) :\n    ker (rTensor Q (N.mkQ)) = range (rTensor Q N.subtype) := by\n  rw [\u2190 exact_iff]\n  exact rTensor_exact Q (LinearMap.exact_subtype_mkQ N) (Submodule.mkQ_surjective N)", "start": [361, 1], "end": [365, 85], "kind": "mathlibtacticlemma"}, {"full_name": "TensorProduct.map_surjective", "code": "theorem TensorProduct.map_surjective : Function.Surjective (TensorProduct.map g g')", "start": [373, 1], "end": [375, 86], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_ker", "code": "theorem TensorProduct.map_ker :\n    ker (TensorProduct.map g g') = range (lTensor N f') \u2294 range (rTensor N' f)", "start": [377, 1], "end": [390, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_includeLeft_eq", "code": "lemma Ideal.map_includeLeft_eq (I : Ideal A) :\n    (I.map (Algebra.TensorProduct.includeLeft : A \u2192\u2090[R] A \u2297[R] B)).restrictScalars R\n      = LinearMap.range (LinearMap.rTensor B (Submodule.subtype (I.restrictScalars R))) := by\n  rw [\u2190 Submodule.carrier_inj]\n  apply le_antisymm\n  \u00b7 intro x\n    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]\n    intro hx\n    rw [Ideal.map, \u2190 submodule_span_eq] at hx\n    refine' Submodule.span_induction hx _ _ _ _\n    \u00b7 intro x\n      simp only [includeLeft_apply, Set.mem_image, SetLike.mem_coe]\n      rintro \u27e8y, hy, rfl\u27e9\n      use \u27e8y, hy\u27e9 \u2297\u209c[R] 1\n      rfl\n    \u00b7 use 0\n      simp only [map_zero]\n    \u00b7 rintro x y \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9\n      use x + y\n      simp only [map_add]\n    \u00b7 rintro a x \u27e8x, hx, rfl\u27e9\n      induction a using TensorProduct.induction_on with\n      | zero =>\n        use 0\n        simp only [map_zero, smul_eq_mul, zero_mul]\n      | tmul a b =>\n        induction x using TensorProduct.induction_on with\n        | zero =>\n          use 0\n          simp only [map_zero, smul_eq_mul, mul_zero]\n        | tmul x y =>\n          use (a \u2022 x) \u2297\u209c[R] (b * y)\n          simp only [LinearMap.lTensor_tmul, Submodule.coeSubtype, smul_eq_mul, tmul_mul_tmul]\n          rfl\n        | add x y hx hy =>\n          obtain \u27e8x', hx'\u27e9 := hx\n          obtain \u27e8y', hy'\u27e9 := hy\n          use x' + y'\n          simp only [map_add, hx', smul_add, hy']\n      | add a b ha hb =>\n        obtain \u27e8x', ha'\u27e9 := ha\n        obtain \u27e8y', hb'\u27e9 := hb\n        use x' + y'\n        simp only [map_add, ha', add_smul, hb']\n\n  \u00b7 rintro x \u27e8y, rfl\u27e9\n    induction y using TensorProduct.induction_on with\n    | zero =>\n        rw [map_zero]\n        apply zero_mem\n    | tmul a b =>\n        simp only [LinearMap.rTensor_tmul, Submodule.coeSubtype]\n        suffices : (a : A) \u2297\u209c[R] b = ((1 : A) \u2297\u209c[R] b) * ((a : A) \u2297\u209c[R] (1 : B))\n        simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n          Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]\n        rw [this]\n        apply Ideal.mul_mem_left\n        apply Ideal.mem_map_of_mem\n        exact Submodule.coe_mem a\n        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,\n          mul_one, one_mul]\n    | add x y hx hy =>\n        rw [map_add]\n        apply Submodule.add_mem _ hx hy", "start": [404, 1], "end": [469, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.map_includeRight_eq", "code": "lemma Ideal.map_includeRight_eq (I : Ideal B) :\n    (I.map (Algebra.TensorProduct.includeRight : B \u2192\u2090[R] A \u2297[R] B)).restrictScalars R\n      = LinearMap.range (LinearMap.lTensor A (Submodule.subtype (I.restrictScalars R))) := by\n  rw [\u2190 Submodule.carrier_inj]\n  apply le_antisymm\n  \u00b7 intro x\n    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]\n    intro hx\n    rw [Ideal.map, \u2190 submodule_span_eq] at hx\n    refine' Submodule.span_induction hx _ _ _ _\n    \u00b7 intro x\n      simp only [includeRight_apply, Set.mem_image, SetLike.mem_coe]\n      rintro \u27e8y, hy, rfl\u27e9\n      use 1 \u2297\u209c[R] \u27e8y, hy\u27e9\n      rfl\n    \u00b7 use 0\n      simp only [map_zero]\n    \u00b7 rintro x y \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9\n      use x + y\n      simp only [map_add]\n    \u00b7 rintro a x \u27e8x, hx, rfl\u27e9\n      induction a using TensorProduct.induction_on with\n      | zero =>\n        use 0\n        simp only [map_zero, smul_eq_mul, zero_mul]\n      | tmul a b =>\n        induction x using TensorProduct.induction_on with\n        | zero =>\n          use 0\n          simp only [map_zero, smul_eq_mul, mul_zero]\n        | tmul x y =>\n          use (a * x) \u2297\u209c[R] (b \u2022y)\n          simp only [LinearMap.lTensor_tmul, Submodule.coeSubtype, smul_eq_mul, tmul_mul_tmul]\n          rfl\n        | add x y hx hy =>\n          obtain \u27e8x', hx'\u27e9 := hx\n          obtain \u27e8y', hy'\u27e9 := hy\n          use x' + y'\n          simp only [map_add, hx', smul_add, hy']\n      | add a b ha hb =>\n        obtain \u27e8x', ha'\u27e9 := ha\n        obtain \u27e8y', hb'\u27e9 := hb\n        use x' + y'\n        simp only [map_add, ha', add_smul, hb']\n\n  \u00b7 rintro x \u27e8y, rfl\u27e9\n    induction y using TensorProduct.induction_on with\n    | zero =>\n        rw [map_zero]\n        apply zero_mem\n    | tmul a b =>\n        simp only [LinearMap.lTensor_tmul, Submodule.coeSubtype]\n        suffices : a \u2297\u209c[R] (b : B) = (a \u2297\u209c[R] (1 : B)) * ((1 : A) \u2297\u209c[R] (b : B))\n        rw [this]\n        simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n          Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]\n        apply Ideal.mul_mem_left\n        apply Ideal.mem_map_of_mem\n        exact Submodule.coe_mem b\n        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,\n          mul_one, one_mul]\n    | add x y hx hy =>\n        rw [map_add]\n        apply Submodule.add_mem _ hx hy", "start": [471, 1], "end": [536, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Algebra.TensorProduct.lTensor_ker", "code": "lemma Algebra.TensorProduct.lTensor_ker (hg : Function.Surjective g) :\n    RingHom.ker (map (AlgHom.id R A) g) =\n      (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C \u2192\u2090[R] A \u2297[R] C) := by\n  rw [\u2190 Submodule.restrictScalars_inj R]\n  have : (RingHom.ker (map (AlgHom.id R A) g)).restrictScalars R =\n    LinearMap.ker (LinearMap.lTensor A (AlgHom.toLinearMap g)) := rfl\n  rw [this, Ideal.map_includeRight_eq]\n  rw [(lTensor_exact A g.toLinearMap.exact_subtype_ker_map hg).linearMap_ker_eq]\n  rfl", "start": [546, 1], "end": [555, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Algebra.TensorProduct.rTensor_ker", "code": "lemma Algebra.TensorProduct.rTensor_ker (hf : Function.Surjective f) :\n    RingHom.ker (map f (AlgHom.id R C)) =\n      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A \u2192\u2090[R] A \u2297[R] C) := by\n  rw [\u2190 Submodule.restrictScalars_inj R]\n  have : (RingHom.ker (map f (AlgHom.id R C))).restrictScalars R =\n    LinearMap.ker (LinearMap.rTensor C (AlgHom.toLinearMap f)) := rfl\n  rw [this, Ideal.map_includeLeft_eq]\n  rw [(rTensor_exact C f.toLinearMap.exact_subtype_ker_map hf).linearMap_ker_eq]\n  rfl", "start": [557, 1], "end": [566, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Algebra.TensorProduct.map_ker", "code": "theorem Algebra.TensorProduct.map_ker (hf : Function.Surjective f) (hg : Function.Surjective g) :\n    RingHom.ker (map f g) =\n      (RingHom.ker f).map (Algebra.TensorProduct.includeLeft : A \u2192\u2090[R] A \u2297[R] C) \u2294\n        (RingHom.ker g).map (Algebra.TensorProduct.includeRight : C \u2192\u2090[R] A \u2297[R] C)", "start": [568, 1], "end": [589, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/WithDensity.lean", "imports": ["Mathlib/Probability/Kernel/MeasurableIntegral.lean", "Mathlib/MeasureTheory/Integral/SetIntegral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.kernel.withDensity", "code": "noncomputable def withDensity (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba] (f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e) :\n    kernel \u03b1 \u03b2 :=\n  @dite _ (Measurable (Function.uncurry f)) (Classical.dec _) (fun hf =>\n    (\u27e8fun a => (\u03ba a).withDensity (f a),\n      by\n        refine' Measure.measurable_of_measurable_coe _ fun s hs => _\n        simp_rw [withDensity_apply _ hs]\n        exact hf.set_lintegral_kernel_prod_right hs\u27e9 : kernel \u03b1 \u03b2)) fun _ => 0", "start": [44, 1], "end": [54, 79], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_of_not_measurable", "code": "theorem withDensity_of_not_measurable (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba]\n    (hf : \u00acMeasurable (Function.uncurry f)) : withDensity \u03ba f = 0", "start": [57, 1], "end": [58, 99], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_apply", "code": "protected theorem withDensity_apply (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba]\n    (hf : Measurable (Function.uncurry f)) (a : \u03b1) :\n    withDensity \u03ba f a = (\u03ba a).withDensity (f a)", "start": [61, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_apply'", "code": "theorem withDensity_apply' (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba]\n    (hf : Measurable (Function.uncurry f)) (a : \u03b1) {s : Set \u03b2} (hs : MeasurableSet s) :\n    withDensity \u03ba f a s = \u222b\u207b b in s, f a b \u2202\u03ba a", "start": [69, 1], "end": [72, 61], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.lintegral_withDensity", "code": "theorem lintegral_withDensity (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba]\n    (hf : Measurable (Function.uncurry f)) (a : \u03b1) {g : \u03b2 \u2192 \u211d\u22650\u221e} (hg : Measurable g) :\n    \u222b\u207b b, g b \u2202withDensity \u03ba f a = \u222b\u207b b, f a b * g b \u2202\u03ba a", "start": [75, 1], "end": [80, 25], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_withDensity", "code": "theorem integral_withDensity {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    {f : \u03b2 \u2192 E} [IsSFiniteKernel \u03ba] {a : \u03b1} {g : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650}\n    (hg : Measurable (Function.uncurry g)) :\n    \u222b b, f b \u2202withDensity \u03ba (fun a b => g a b) a = \u222b b, g a b \u2022 f b \u2202\u03ba a", "start": [83, 1], "end": [89, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_add_left", "code": "theorem withDensity_add_left (\u03ba \u03b7 : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba] [IsSFiniteKernel \u03b7]\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e) : withDensity (\u03ba + \u03b7) f = withDensity \u03ba f + withDensity \u03b7 f", "start": [92, 1], "end": [99, 18], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_kernel_sum", "code": "theorem withDensity_kernel_sum [Countable \u03b9] (\u03ba : \u03b9 \u2192 kernel \u03b1 \u03b2) (h\u03ba : \u2200 i, IsSFiniteKernel (\u03ba i))\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e) :\n    @withDensity _ _ _ _ (kernel.sum \u03ba) (isSFiniteKernel_sum h\u03ba) f =\n      kernel.sum fun i => withDensity (\u03ba i) f", "start": [102, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.withDensity_tsum", "code": "theorem withDensity_tsum [Countable \u03b9] (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba] {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 i, Measurable (Function.uncurry (f i))) :\n    withDensity \u03ba (\u2211' n, f n) = kernel.sum fun n => withDensity \u03ba (f n)", "start": [114, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.isFiniteKernel_withDensity_of_bounded", "code": "theorem isFiniteKernel_withDensity_of_bounded (\u03ba : kernel \u03b1 \u03b2) [IsFiniteKernel \u03ba] {B : \u211d\u22650\u221e}\n    (hB_top : B \u2260 \u221e) (hf_B : \u2200 a b, f a b \u2264 B) : IsFiniteKernel (withDensity \u03ba f)", "start": [137, 1], "end": [151, 19], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.isSFiniteKernel_withDensity_of_isFiniteKernel", "code": "theorem isSFiniteKernel_withDensity_of_isFiniteKernel (\u03ba : kernel \u03b1 \u03b2) [IsFiniteKernel \u03ba]\n    (hf_ne_top : \u2200 a b, f a b \u2260 \u221e) : IsSFiniteKernel (withDensity \u03ba f)", "start": [154, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.IsSFiniteKernel.withDensity", "code": "nonrec theorem IsSFiniteKernel.withDensity (\u03ba : kernel \u03b1 \u03b2) [IsSFiniteKernel \u03ba]\n    (hf_ne_top : \u2200 a b, f a b \u2260 \u221e) : IsSFiniteKernel (withDensity \u03ba f)", "start": [213, 1], "end": [223, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Ordmap/Ordset.lean", "imports": ["Mathlib/Tactic/Abel.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Data/Ordmap/Ordnode.lean", "Mathlib/Data/Nat/Dist.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": [{"full_name": "Ordnode.not_le_delta", "code": "theorem not_le_delta {s} (H : 1 \u2264 s) : \u00acs \u2264 delta * 0", "start": [78, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "Ordnode.delta_lt_false", "code": "theorem delta_lt_false {a b : \u2115} (h\u2081 : delta * a < b) (h\u2082 : delta * b < a) : False", "start": [82, 1], "end": [84, 83], "kind": "commanddeclaration"}, {"full_name": "Ordnode.realSize", "code": "def realSize : Ordnode \u03b1 \u2192 \u2115\n  | nil => 0\n  | node _ l _ r => realSize l + realSize r + 1", "start": [93, 1], "end": [96, 48], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized", "code": "def Sized : Ordnode \u03b1 \u2192 Prop\n  | nil => True\n  | node s l _ r => s = size l + size r + 1 \u2227 Sized l \u2227 Sized r", "start": [102, 1], "end": [106, 64], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.node'", "code": "theorem Sized.node' {l x r} (hl : @Sized \u03b1 l) (hr : Sized r) : Sized (node' l x r)", "start": [109, 1], "end": [110, 16], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.eq_node'", "code": "theorem Sized.eq_node' {s l x r} (h : @Sized \u03b1 (node s l x r)) : node s l x r = .node' l x r", "start": [113, 1], "end": [114, 11], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.size_eq", "code": "theorem Sized.size_eq {s l x r} (H : Sized (@node \u03b1 s l x r)) :\n    size (@node \u03b1 s l x r) = size l + size r + 1", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.induction", "code": "@[elab_as_elim]\ntheorem Sized.induction {t} (hl : @Sized \u03b1 t) {C : Ordnode \u03b1 \u2192 Prop} (H0 : C nil)\n    (H1 : \u2200 l x r, C l \u2192 C r \u2192 C (.node' l x r)) : C t", "start": [122, 1], "end": [129, 51], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_eq_realSize", "code": "theorem size_eq_realSize : \u2200 {t : Ordnode \u03b1}, Sized t \u2192 size t = realSize t", "start": [132, 1], "end": [135, 65], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.size_eq_zero", "code": "@[simp]\ntheorem Sized.size_eq_zero {t : Ordnode \u03b1} (ht : Sized t) : size t = 0 \u2194 t = nil", "start": [138, 1], "end": [140, 33], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.pos", "code": "theorem Sized.pos {s l x r} (h : Sized (@node \u03b1 s l x r)) : 0 < s", "start": [143, 1], "end": [144, 34], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_dual", "code": "theorem dual_dual : \u2200 t : Ordnode \u03b1, dual (dual t) = t", "start": [150, 1], "end": [152, 65], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_dual", "code": "@[simp]\ntheorem size_dual (t : Ordnode \u03b1) : size (dual t) = size t", "start": [155, 1], "end": [156, 81], "kind": "commanddeclaration"}, {"full_name": "Ordnode.BalancedSz", "code": "def BalancedSz (l r : \u2115) : Prop :=\n  l + r \u2264 1 \u2228 l \u2264 delta * r \u2227 r \u2264 delta * l", "start": [162, 1], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.BalancedSz.dec", "code": "instance BalancedSz.dec : DecidableRel BalancedSz := fun _ _ => Or.decidable", "start": [169, 1], "end": [169, 77], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Balanced", "code": "def Balanced : Ordnode \u03b1 \u2192 Prop\n  | nil => True\n  | node _ l _ r => BalancedSz (size l) (size r) \u2227 Balanced l \u2227 Balanced r", "start": [172, 1], "end": [176, 75], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Balanced.dec", "code": "instance Balanced.dec : DecidablePred (@Balanced \u03b1)\n  | nil => by\n    unfold Balanced\n    infer_instance\n  | node _ l _ r => by\n    unfold Balanced\n    haveI := Balanced.dec l\n    haveI := Balanced.dec r\n    infer_instance", "start": [179, 1], "end": [187, 19], "kind": "commanddeclaration"}, {"full_name": "Ordnode.BalancedSz.symm", "code": "@[symm]\ntheorem BalancedSz.symm {l r : \u2115} : BalancedSz l r \u2192 BalancedSz r l", "start": [190, 1], "end": [192, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balancedSz_zero", "code": "theorem balancedSz_zero {l : \u2115} : BalancedSz l 0 \u2194 l \u2264 1", "start": [195, 1], "end": [196, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balancedSz_up", "code": "theorem balancedSz_up {l r\u2081 r\u2082 : \u2115} (h\u2081 : r\u2081 \u2264 r\u2082) (h\u2082 : l + r\u2082 \u2264 1 \u2228 r\u2082 \u2264 delta * l)\n    (H : BalancedSz l r\u2081) : BalancedSz l r\u2082", "start": [199, 1], "end": [209, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balancedSz_down", "code": "theorem balancedSz_down {l r\u2081 r\u2082 : \u2115} (h\u2081 : r\u2081 \u2264 r\u2082) (h\u2082 : l + r\u2082 \u2264 1 \u2228 l \u2264 delta * r\u2081)\n    (H : BalancedSz l r\u2082) : BalancedSz l r\u2081", "start": [212, 1], "end": [215, 87], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Balanced.dual", "code": "theorem Balanced.dual : \u2200 {t : Ordnode \u03b1}, Balanced t \u2192 Balanced (dual t)", "start": [218, 1], "end": [220, 96], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node3L", "code": "def node3L (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  node' (node' l x m) y r", "start": [226, 1], "end": [228, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node3R", "code": "def node3R (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  node' l x (node' m y r)", "start": [231, 1], "end": [233, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node4L", "code": "def node4L : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | l, x, node _ ml y mr, z, r => node' (node' l x ml) y (node' mr z r)\n  | l, x, nil, z, r => node3L l x nil z r", "start": [236, 1], "end": [239, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node4R", "code": "def node4R : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | l, x, node _ ml y mr, z, r => node' (node' l x ml) y (node' mr z r)\n  | l, x, nil, z, r => node3R l x nil z r", "start": [243, 1], "end": [246, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateL", "code": "def rotateL : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | l, x, node _ m y r => if size m < ratio * size r then node3L l x m y r else node4L l x m y r\n  | l, x, nil => node' l x nil", "start": [250, 1], "end": [254, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateL_node", "code": "theorem rotateL_node (l : Ordnode \u03b1) (x : \u03b1) (sz : \u2115) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    rotateL l x (node sz m y r) =\n      if size m < ratio * size r then node3L l x m y r else node4L l x m y r", "start": [257, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateL_nil", "code": "theorem rotateL_nil (l : Ordnode \u03b1) (x : \u03b1) : rotateL l x nil = node' l x nil", "start": [262, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateR", "code": "def rotateR : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | node _ l x m, y, r => if size m < ratio * size l then node3R l x m y r else node4R l x m y r\n  | nil, y, r => node' nil y r", "start": [268, 1], "end": [272, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateR_node", "code": "theorem rotateR_node (sz : \u2115) (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    rotateR (node sz l x m) y r =\n      if size m < ratio * size l then node3R l x m y r else node4R l x m y r", "start": [275, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.rotateR_nil", "code": "theorem rotateR_nil (y : \u03b1) (r : Ordnode \u03b1) : rotateR nil y r = node' nil y r", "start": [280, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceL'", "code": "def balanceL' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  if size l + size r \u2264 1 then node' l x r\n  else if size l > delta * size r then rotateR l x r else node' l x r", "start": [286, 1], "end": [290, 70], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceR'", "code": "def balanceR' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  if size l + size r \u2264 1 then node' l x r\n  else if size r > delta * size l then rotateL l x r else node' l x r", "start": [293, 1], "end": [297, 70], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balance'", "code": "def balance' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  if size l + size r \u2264 1 then node' l x r\n  else\n    if size r > delta * size l then rotateL l x r\n    else if size l > delta * size r then rotateR l x r else node' l x r", "start": [300, 1], "end": [306, 72], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_node'", "code": "theorem dual_node' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (node' l x r) = node' (dual r) x (dual l)", "start": [309, 1], "end": [310, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_node3L", "code": "theorem dual_node3L (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node3L l x m y r) = node3R (dual r) y (dual m) x (dual l)", "start": [313, 1], "end": [315, 46], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_node3R", "code": "theorem dual_node3R (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node3R l x m y r) = node3L (dual r) y (dual m) x (dual l)", "start": [318, 1], "end": [320, 46], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_node4L", "code": "theorem dual_node4L (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node4L l x m y r) = node4R (dual r) y (dual m) x (dual l)", "start": [323, 1], "end": [325, 79], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_node4R", "code": "theorem dual_node4R (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node4R l x m y r) = node4L (dual r) y (dual m) x (dual l)", "start": [328, 1], "end": [330, 79], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_rotateL", "code": "theorem dual_rotateL (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (rotateL l x r) = rotateR (dual r) x (dual l)", "start": [333, 1], "end": [336, 54], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_rotateR", "code": "theorem dual_rotateR (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (rotateR l x r) = rotateL (dual r) x (dual l)", "start": [339, 1], "end": [341, 71], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_balance'", "code": "theorem dual_balance' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (balance' l x r) = balance' (dual r) x (dual l)", "start": [344, 1], "end": [348, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_balanceL", "code": "theorem dual_balanceL (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (balanceL l x r) = balanceR (dual r) x (dual l)", "start": [351, 1], "end": [364, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_balanceR", "code": "theorem dual_balanceR (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (balanceR l x r) = balanceL (dual r) x (dual l)", "start": [367, 1], "end": [369, 73], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.node3L", "code": "theorem Sized.node3L {l x m y r} (hl : @Sized \u03b1 l) (hm : Sized m) (hr : Sized r) :\n    Sized (node3L l x m y r)", "start": [372, 1], "end": [374, 25], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.node3R", "code": "theorem Sized.node3R {l x m y r} (hl : @Sized \u03b1 l) (hm : Sized m) (hr : Sized r) :\n    Sized (node3R l x m y r)", "start": [377, 1], "end": [379, 25], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.node4L", "code": "theorem Sized.node4L {l x m y r} (hl : @Sized \u03b1 l) (hm : Sized m) (hr : Sized r) :\n    Sized (node4L l x m y r)", "start": [382, 1], "end": [384, 94], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node3L_size", "code": "theorem node3L_size {l x m y r} : size (@node3L \u03b1 l x m y r) = size l + size m + size r + 2", "start": [387, 1], "end": [388, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node3R_size", "code": "theorem node3R_size {l x m y r} : size (@node3R \u03b1 l x m y r) = size l + size m + size r + 2", "start": [391, 1], "end": [392, 61], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node4L_size", "code": "theorem node4L_size {l x m y r} (hm : Sized m) :\n    size (@node4L \u03b1 l x m y r) = size l + size m + size r + 2", "start": [395, 1], "end": [397, 82], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.dual", "code": "theorem Sized.dual : \u2200 {t : Ordnode \u03b1}, Sized t \u2192 Sized (dual t)", "start": [400, 1], "end": [402, 97], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.dual_iff", "code": "theorem Sized.dual_iff {t : Ordnode \u03b1} : Sized (.dual t) \u2194 Sized t", "start": [405, 1], "end": [406, 61], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.rotateL", "code": "theorem Sized.rotateL {l x r} (hl : @Sized \u03b1 l) (hr : Sized r) : Sized (rotateL l x r)", "start": [409, 1], "end": [413, 34], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.rotateR", "code": "theorem Sized.rotateR {l x r} (hl : @Sized \u03b1 l) (hr : Sized r) : Sized (rotateR l x r)", "start": [416, 1], "end": [417, 74], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.rotateL_size", "code": "theorem Sized.rotateL_size {l x r} (hm : Sized r) :\n    size (@Ordnode.rotateL \u03b1 l x r) = size l + size r + 1", "start": [420, 1], "end": [424, 64], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.rotateR_size", "code": "theorem Sized.rotateR_size {l x r} (hl : Sized l) :\n    size (@Ordnode.rotateR \u03b1 l x r) = size l + size r + 1", "start": [427, 1], "end": [429, 96], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Sized.balance'", "code": "theorem Sized.balance' {l x r} (hl : @Sized \u03b1 l) (hr : Sized r) : Sized (balance' l x r)", "start": [432, 1], "end": [437, 22], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_balance'", "code": "theorem size_balance' {l x r} (hl : @Sized \u03b1 l) (hr : Sized r) :\n    size (@balance' \u03b1 l x r) = size l + size r + 1", "start": [440, 1], "end": [446, 8], "kind": "commanddeclaration"}, {"full_name": "Ordnode.All.imp", "code": "theorem All.imp {P Q : \u03b1 \u2192 Prop} (H : \u2200 a, P a \u2192 Q a) : \u2200 {t}, All P t \u2192 All Q t", "start": [452, 1], "end": [454, 63], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Any.imp", "code": "theorem Any.imp {P Q : \u03b1 \u2192 Prop} (H : \u2200 a, P a \u2192 Q a) : \u2200 {t}, Any P t \u2192 Any Q t", "start": [457, 1], "end": [459, 67], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_singleton", "code": "theorem all_singleton {P : \u03b1 \u2192 Prop} {x : \u03b1} : All P (singleton x) \u2194 P x", "start": [462, 1], "end": [463, 41], "kind": "commanddeclaration"}, {"full_name": "Ordnode.any_singleton", "code": "theorem any_singleton {P : \u03b1 \u2192 Prop} {x : \u03b1} : Any P (singleton x) \u2194 P x", "start": [466, 1], "end": [467, 69], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_dual", "code": "theorem all_dual {P : \u03b1 \u2192 Prop} : \u2200 {t : Ordnode \u03b1}, All P (dual t) \u2194 All P t", "start": [470, 1], "end": [474, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_iff_forall", "code": "theorem all_iff_forall {P : \u03b1 \u2192 Prop} : \u2200 {t}, All P t \u2194 \u2200 x, Emem x t \u2192 P x", "start": [477, 1], "end": [479, 81], "kind": "commanddeclaration"}, {"full_name": "Ordnode.any_iff_exists", "code": "theorem any_iff_exists {P : \u03b1 \u2192 Prop} : \u2200 {t}, Any P t \u2194 \u2203 x, Emem x t \u2227 P x", "start": [482, 1], "end": [484, 93], "kind": "commanddeclaration"}, {"full_name": "Ordnode.emem_iff_all", "code": "theorem emem_iff_all {x : \u03b1} {t} : Emem x t \u2194 \u2200 P, All P t \u2192 P x", "start": [487, 1], "end": [488, 88], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_node'", "code": "theorem all_node' {P l x r} : @All \u03b1 P (node' l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [491, 1], "end": [492, 10], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_node3L", "code": "theorem all_node3L {P l x m y r} :\n    @All \u03b1 P (node3L l x m y r) \u2194 All P l \u2227 P x \u2227 All P m \u2227 P y \u2227 All P r", "start": [495, 1], "end": [497, 38], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_node3R", "code": "theorem all_node3R {P l x m y r} :\n    @All \u03b1 P (node3R l x m y r) \u2194 All P l \u2227 P x \u2227 All P m \u2227 P y \u2227 All P r", "start": [500, 1], "end": [502, 10], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_node4L", "code": "theorem all_node4L {P l x m y r} :\n    @All \u03b1 P (node4L l x m y r) \u2194 All P l \u2227 P x \u2227 All P m \u2227 P y \u2227 All P r", "start": [505, 1], "end": [507, 67], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_node4R", "code": "theorem all_node4R {P l x m y r} :\n    @All \u03b1 P (node4R l x m y r) \u2194 All P l \u2227 P x \u2227 All P m \u2227 P y \u2227 All P r", "start": [510, 1], "end": [512, 67], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_rotateL", "code": "theorem all_rotateL {P l x r} : @All \u03b1 P (rotateL l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [515, 1], "end": [517, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_rotateR", "code": "theorem all_rotateR {P l x r} : @All \u03b1 P (rotateR l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [520, 1], "end": [521, 98], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_balance'", "code": "theorem all_balance' {P l x r} : @All \u03b1 P (balance' l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [524, 1], "end": [525, 74], "kind": "commanddeclaration"}, {"full_name": "Ordnode.foldr_cons_eq_toList", "code": "theorem foldr_cons_eq_toList : \u2200 (t : Ordnode \u03b1) (r : List \u03b1), t.foldr List.cons r = toList t ++ r", "start": [531, 1], "end": [535, 60], "kind": "commanddeclaration"}, {"full_name": "Ordnode.toList_nil", "code": "@[simp]\ntheorem toList_nil : toList (@nil \u03b1) = []", "start": [538, 1], "end": [540, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.toList_node", "code": "@[simp]\ntheorem toList_node (s l x r) : toList (@node \u03b1 s l x r) = toList l ++ x :: toList r", "start": [543, 1], "end": [545, 48], "kind": "commanddeclaration"}, {"full_name": "Ordnode.emem_iff_mem_toList", "code": "theorem emem_iff_mem_toList {x : \u03b1} {t} : Emem x t \u2194 x \u2208 toList t", "start": [548, 1], "end": [549, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.length_toList'", "code": "theorem length_toList' : \u2200 t : Ordnode \u03b1, (toList t).length = t.realSize", "start": [552, 1], "end": [556, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.length_toList", "code": "theorem length_toList {t : Ordnode \u03b1} (h : Sized t) : (toList t).length = t.size", "start": [559, 1], "end": [560, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.equiv_iff", "code": "theorem equiv_iff {t\u2081 t\u2082 : Ordnode \u03b1} (h\u2081 : Sized t\u2081) (h\u2082 : Sized t\u2082) :\n    Equiv t\u2081 t\u2082 \u2194 toList t\u2081 = toList t\u2082", "start": [563, 1], "end": [565, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.pos_size_of_mem", "code": "theorem pos_size_of_mem [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] {x : \u03b1} {t : Ordnode \u03b1} (h : Sized t)\n    (h_mem : x \u2208 t) : 0 < size t", "start": [571, 1], "end": [572, 86], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMin'_dual", "code": "theorem findMin'_dual : \u2200 (t) (x : \u03b1), findMin' (dual t) x = findMax' x t", "start": [578, 1], "end": [580, 41], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMax'_dual", "code": "theorem findMax'_dual (t) (x : \u03b1) : findMax' x (dual t) = findMin' t x", "start": [583, 1], "end": [584, 34], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMin_dual", "code": "theorem findMin_dual : \u2200 t : Ordnode \u03b1, findMin (dual t) = findMax t", "start": [587, 1], "end": [589, 56], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMax_dual", "code": "theorem findMax_dual (t : Ordnode \u03b1) : findMax (dual t) = findMin t", "start": [592, 1], "end": [593, 33], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_eraseMin", "code": "theorem dual_eraseMin : \u2200 t : Ordnode \u03b1, dual (eraseMin t) = eraseMax (dual t)", "start": [596, 1], "end": [600, 94], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_eraseMax", "code": "theorem dual_eraseMax (t : Ordnode \u03b1) : dual (eraseMax t) = eraseMin (dual t)", "start": [603, 1], "end": [604, 58], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMin_eq", "code": "theorem splitMin_eq :\n    \u2200 (s l) (x : \u03b1) (r), splitMin' l x r = (findMin' l x, eraseMin (node s l x r))", "start": [607, 1], "end": [610, 96], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMax_eq", "code": "theorem splitMax_eq :\n    \u2200 (s l) (x : \u03b1) (r), splitMax' l x r = (eraseMax (node s l x r), findMax' x r)", "start": [613, 1], "end": [616, 96], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMin'_all", "code": "theorem findMin'_all {P : \u03b1 \u2192 Prop} : \u2200 (t) (x : \u03b1), All P t \u2192 P x \u2192 P (findMin' t x)", "start": [620, 1], "end": [622, 66], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMax'_all", "code": "theorem findMax'_all {P : \u03b1 \u2192 Prop} : \u2200 (x : \u03b1) (t), P x \u2192 All P t \u2192 P (findMax' x t)", "start": [626, 1], "end": [628, 66], "kind": "commanddeclaration"}, {"full_name": "Ordnode.merge_nil_left", "code": "@[simp]\ntheorem merge_nil_left (t : Ordnode \u03b1) : merge t nil = t", "start": [637, 1], "end": [638, 79], "kind": "commanddeclaration"}, {"full_name": "Ordnode.merge_nil_right", "code": "@[simp]\ntheorem merge_nil_right (t : Ordnode \u03b1) : merge nil t = t", "start": [641, 1], "end": [643, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.merge_node", "code": "@[simp]\ntheorem merge_node {ls ll lx lr rs rl rx rr} :\n    merge (@node \u03b1 ls ll lx lr) (node rs rl rx rr) =\n      if delta * ls < rs then balanceL (merge (node ls ll lx lr) rl) rx rr\n      else if delta * rs < ls then balanceR ll lx (merge lr (node rs rl rx rr))\n      else glue (node ls ll lx lr) (node rs rl rx rr)", "start": [646, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual_insert", "code": "theorem dual_insert [Preorder \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) :\n    \u2200 t : Ordnode \u03b1, dual (Ordnode.insert x t) = @Ordnode.insert \u03b1\u1d52\u1d48 _ _ x (dual t)", "start": [658, 1], "end": [665, 86], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balance_eq_balance'", "code": "theorem balance_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r) : @balance \u03b1 l x r = balance' l x r", "start": [671, 1], "end": [756, 94], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceL_eq_balance", "code": "theorem balanceL_eq_balance {l x r} (sl : Sized l) (sr : Sized r) (H1 : size l = 0 \u2192 size r \u2264 1)\n    (H2 : 1 \u2264 size l \u2192 1 \u2264 size r \u2192 size r \u2264 delta * size l) :\n    @balanceL \u03b1 l x r = balance l x r", "start": [759, 1], "end": [772, 66], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised", "code": "def Raised (n m : \u2115) : Prop :=\n  m = n \u2228 m = n + 1", "start": [775, 1], "end": [777, 20], "kind": "commanddeclaration"}, {"full_name": "Ordnode.raised_iff", "code": "theorem raised_iff {n m} : Raised n m \u2194 n \u2264 m \u2227 m \u2264 n + 1", "start": [780, 1], "end": [787, 39], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised.dist_le", "code": "theorem Raised.dist_le {n m} (H : Raised n m) : Nat.dist n m \u2264 1", "start": [790, 1], "end": [791, 85], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised.dist_le'", "code": "theorem Raised.dist_le' {n m} (H : Raised n m) : Nat.dist m n \u2264 1", "start": [794, 1], "end": [795, 38], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised.add_left", "code": "theorem Raised.add_left (k) {n m} (H : Raised n m) : Raised (k + n) (k + m)", "start": [798, 1], "end": [801, 21], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised.add_right", "code": "theorem Raised.add_right (k) {n m} (H : Raised n m) : Raised (n + k) (m + k)", "start": [804, 1], "end": [805, 48], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Raised.right", "code": "theorem Raised.right {l x\u2081 x\u2082 r\u2081 r\u2082} (H : Raised (size r\u2081) (size r\u2082)) :\n    Raised (size (@node' \u03b1 l x\u2081 r\u2081)) (size (@node' \u03b1 l x\u2082 r\u2082))", "start": [808, 1], "end": [813, 21], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceL_eq_balance'", "code": "theorem balanceL_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r)\n    (H :\n      (\u2203 l', Raised l' (size l) \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised (size r) r' \u2227 BalancedSz (size l) r') :\n    @balanceL \u03b1 l x r = balance' l x r", "start": [816, 1], "end": [832, 43], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balance_sz_dual", "code": "theorem balance_sz_dual {l r}\n    (H : (\u2203 l', Raised (@size \u03b1 l) l' \u2227 BalancedSz l' (@size \u03b1 r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    (\u2203 l', Raised l' (size (dual r)) \u2227 BalancedSz l' (size (dual l))) \u2228\n      \u2203 r', Raised (size (dual l)) r' \u2227 BalancedSz (size (dual r)) r'", "start": [835, 1], "end": [843, 58], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_balanceL", "code": "theorem size_balanceL {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H : (\u2203 l', Raised l' (size l) \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised (size r) r' \u2227 BalancedSz (size l) r') :\n    size (@balanceL \u03b1 l x r) = size l + size r + 1", "start": [846, 1], "end": [850, 63], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_balanceL", "code": "theorem all_balanceL {P l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H :\n      (\u2203 l', Raised l' (size l) \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised (size r) r' \u2227 BalancedSz (size l) r') :\n    All P (@balanceL \u03b1 l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [853, 1], "end": [858, 56], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceR_eq_balance'", "code": "theorem balanceR_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r)\n    (H : (\u2203 l', Raised (size l) l' \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    @balanceR \u03b1 l x r = balance' l x r", "start": [861, 1], "end": [868, 15], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_balanceR", "code": "theorem size_balanceR {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H : (\u2203 l', Raised (size l) l' \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    size (@balanceR \u03b1 l x r) = size l + size r + 1", "start": [871, 1], "end": [875, 63], "kind": "commanddeclaration"}, {"full_name": "Ordnode.all_balanceR", "code": "theorem all_balanceR {P l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H :\n      (\u2203 l', Raised (size l) l' \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    All P (@balanceR \u03b1 l x r) \u2194 All P l \u2227 P x \u2227 All P r", "start": [878, 1], "end": [883, 56], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded", "code": "def Bounded : Ordnode \u03b1 \u2192 WithBot \u03b1 \u2192 WithTop \u03b1 \u2192 Prop\n  | nil, some a, some b => a < b\n  | nil, _, _ => True\n  | node _ l x r, o\u2081, o\u2082 => Bounded l o\u2081 x \u2227 Bounded r (\u2191x) o\u2082", "start": [893, 1], "end": [899, 63], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.dual", "code": "theorem Bounded.dual :\n    \u2200 {t : Ordnode \u03b1} {o\u2081 o\u2082}, Bounded t o\u2081 o\u2082 \u2192 @Bounded \u03b1\u1d52\u1d48 _ (dual t) o\u2082 o\u2081", "start": [902, 1], "end": [905, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.dual_iff", "code": "theorem Bounded.dual_iff {t : Ordnode \u03b1} {o\u2081 o\u2082} :\n    Bounded t o\u2081 o\u2082 \u2194 @Bounded \u03b1\u1d52\u1d48 _ (.dual t) o\u2082 o\u2081", "start": [908, 1], "end": [911, 83], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.weak_left", "code": "theorem Bounded.weak_left : \u2200 {t : Ordnode \u03b1} {o\u2081 o\u2082}, Bounded t o\u2081 o\u2082 \u2192 Bounded t \u22a5 o\u2082", "start": [914, 1], "end": [916, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.weak_right", "code": "theorem Bounded.weak_right : \u2200 {t : Ordnode \u03b1} {o\u2081 o\u2082}, Bounded t o\u2081 o\u2082 \u2192 Bounded t o\u2081 \u22a4", "start": [919, 1], "end": [921, 56], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.weak", "code": "theorem Bounded.weak {t : Ordnode \u03b1} {o\u2081 o\u2082} (h : Bounded t o\u2081 o\u2082) : Bounded t \u22a5 \u22a4", "start": [924, 1], "end": [925, 25], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.mono_left", "code": "theorem Bounded.mono_left {x y : \u03b1} (xy : x \u2264 y) :\n    \u2200 {t : Ordnode \u03b1} {o}, Bounded t y o \u2192 Bounded t x o", "start": [928, 1], "end": [932, 56], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.mono_right", "code": "theorem Bounded.mono_right {x y : \u03b1} (xy : x \u2264 y) :\n    \u2200 {t : Ordnode \u03b1} {o}, Bounded t o x \u2192 Bounded t o y", "start": [935, 1], "end": [939, 57], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.to_lt", "code": "theorem Bounded.to_lt : \u2200 {t : Ordnode \u03b1} {x y : \u03b1}, Bounded t x y \u2192 x < y", "start": [942, 1], "end": [944, 63], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.to_nil", "code": "theorem Bounded.to_nil {t : Ordnode \u03b1} : \u2200 {o\u2081 o\u2082}, Bounded t o\u2081 o\u2082 \u2192 Bounded nil o\u2081 o\u2082", "start": [947, 1], "end": [950, 33], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.trans_left", "code": "theorem Bounded.trans_left {t\u2081 t\u2082 : Ordnode \u03b1} {x : \u03b1} :\n    \u2200 {o\u2081 o\u2082}, Bounded t\u2081 o\u2081 x \u2192 Bounded t\u2082 x o\u2082 \u2192 Bounded t\u2082 o\u2081 o\u2082", "start": [953, 1], "end": [956, 58], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.trans_right", "code": "theorem Bounded.trans_right {t\u2081 t\u2082 : Ordnode \u03b1} {x : \u03b1} :\n    \u2200 {o\u2081 o\u2082}, Bounded t\u2081 o\u2081 x \u2192 Bounded t\u2082 x o\u2082 \u2192 Bounded t\u2081 o\u2081 o\u2082", "start": [959, 1], "end": [962, 59], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.mem_lt", "code": "theorem Bounded.mem_lt : \u2200 {t o} {x : \u03b1}, Bounded t o x \u2192 All (\u00b7 < x) t", "start": [965, 1], "end": [968, 72], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.mem_gt", "code": "theorem Bounded.mem_gt : \u2200 {t o} {x : \u03b1}, Bounded t x o \u2192 All (\u00b7 > x) t", "start": [971, 1], "end": [973, 100], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.of_lt", "code": "theorem Bounded.of_lt :\n    \u2200 {t o\u2081 o\u2082} {x : \u03b1}, Bounded t o\u2081 o\u2082 \u2192 Bounded nil o\u2081 x \u2192 All (\u00b7 < x) t \u2192 Bounded t o\u2081 x", "start": [976, 1], "end": [979, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.of_gt", "code": "theorem Bounded.of_gt :\n    \u2200 {t o\u2081 o\u2082} {x : \u03b1}, Bounded t o\u2081 o\u2082 \u2192 Bounded nil x o\u2082 \u2192 All (\u00b7 > x) t \u2192 Bounded t x o\u2082", "start": [982, 1], "end": [985, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Bounded.to_sep", "code": "theorem Bounded.to_sep {t\u2081 t\u2082 o\u2081 o\u2082} {x : \u03b1}\n    (h\u2081 : Bounded t\u2081 o\u2081 (x : WithTop \u03b1)) (h\u2082 : Bounded t\u2082 (x : WithBot \u03b1) o\u2082) :\n    t\u2081.All fun y => t\u2082.All fun z : \u03b1 => y < z", "start": [988, 1], "end": [992, 49], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'", "code": "structure Valid' (lo : WithBot \u03b1) (t : Ordnode \u03b1) (hi : WithTop \u03b1) : Prop where\n  ord : t.Bounded lo hi\n  sz : t.Sized\n  bal : t.Balanced", "start": [1004, 1], "end": [1010, 19], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid", "code": "def Valid (t : Ordnode \u03b1) : Prop :=\n  Valid' \u22a5 t \u22a4", "start": [1016, 1], "end": [1020, 15], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.mono_left", "code": "theorem Valid'.mono_left {x y : \u03b1} (xy : x \u2264 y) {t : Ordnode \u03b1} {o} (h : Valid' y t o) :\n    Valid' x t o", "start": [1023, 1], "end": [1025, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.mono_right", "code": "theorem Valid'.mono_right {x y : \u03b1} (xy : x \u2264 y) {t : Ordnode \u03b1} {o} (h : Valid' o t x) :\n    Valid' o t y", "start": [1028, 1], "end": [1030, 32], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.trans_left", "code": "theorem Valid'.trans_left {t\u2081 t\u2082 : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (h : Bounded t\u2081 o\u2081 x)\n    (H : Valid' x t\u2082 o\u2082) : Valid' o\u2081 t\u2082 o\u2082", "start": [1033, 1], "end": [1035, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.trans_right", "code": "theorem Valid'.trans_right {t\u2081 t\u2082 : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (H : Valid' o\u2081 t\u2081 x)\n    (h : Bounded t\u2082 x o\u2082) : Valid' o\u2081 t\u2081 o\u2082", "start": [1038, 1], "end": [1040, 32], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.of_lt", "code": "theorem Valid'.of_lt {t : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (H : Valid' o\u2081 t o\u2082) (h\u2081 : Bounded nil o\u2081 x)\n    (h\u2082 : All (\u00b7 < x) t) : Valid' o\u2081 t x", "start": [1043, 1], "end": [1045, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.of_gt", "code": "theorem Valid'.of_gt {t : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (H : Valid' o\u2081 t o\u2082) (h\u2081 : Bounded nil x o\u2082)\n    (h\u2082 : All (\u00b7 > x) t) : Valid' x t o\u2082", "start": [1048, 1], "end": [1050, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.valid", "code": "theorem Valid'.valid {t o\u2081 o\u2082} (h : @Valid' \u03b1 _ o\u2081 t o\u2082) : Valid t", "start": [1053, 1], "end": [1054, 23], "kind": "commanddeclaration"}, {"full_name": "Ordnode.valid'_nil", "code": "theorem valid'_nil {o\u2081 o\u2082} (h : Bounded nil o\u2081 o\u2082) : Valid' o\u2081 (@nil \u03b1) o\u2082", "start": [1057, 1], "end": [1058, 14], "kind": "commanddeclaration"}, {"full_name": "Ordnode.valid_nil", "code": "theorem valid_nil : Valid (@nil \u03b1)", "start": [1061, 1], "end": [1062, 16], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node", "code": "theorem Valid'.node {s l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : BalancedSz (size l) (size r)) (hs : s = size l + size r + 1) :\n    Valid' o\u2081 (@node \u03b1 s l x r) o\u2082", "start": [1065, 1], "end": [1068, 52], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.dual", "code": "theorem Valid'.dual : \u2200 {t : Ordnode \u03b1} {o\u2081 o\u2082}, Valid' o\u2081 t o\u2082 \u2192 @Valid' \u03b1\u1d52\u1d48 _ o\u2082 (dual t) o\u2081", "start": [1071, 1], "end": [1077, 62], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.dual_iff", "code": "theorem Valid'.dual_iff {t : Ordnode \u03b1} {o\u2081 o\u2082} : Valid' o\u2081 t o\u2082 \u2194 @Valid' \u03b1\u1d52\u1d48 _ o\u2082 (.dual t) o\u2081", "start": [1080, 1], "end": [1082, 82], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.dual", "code": "theorem Valid.dual {t : Ordnode \u03b1} : Valid t \u2192 @Valid \u03b1\u1d52\u1d48 _ (.dual t)", "start": [1085, 1], "end": [1086, 14], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.dual_iff", "code": "theorem Valid.dual_iff {t : Ordnode \u03b1} : Valid t \u2194 @Valid \u03b1\u1d52\u1d48 _ (.dual t)", "start": [1089, 1], "end": [1090, 18], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.left", "code": "theorem Valid'.left {s l x r o\u2081 o\u2082} (H : Valid' o\u2081 (@Ordnode.node \u03b1 s l x r) o\u2082) : Valid' o\u2081 l x", "start": [1093, 1], "end": [1094, 28], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.right", "code": "theorem Valid'.right {s l x r o\u2081 o\u2082} (H : Valid' o\u2081 (@Ordnode.node \u03b1 s l x r) o\u2082) : Valid' x r o\u2082", "start": [1097, 1], "end": [1098, 28], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.left", "code": "nonrec theorem Valid.left {s l x r} (H : Valid (@node \u03b1 s l x r)) : Valid l", "start": [1101, 1], "end": [1102, 15], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.right", "code": "nonrec theorem Valid.right {s l x r} (H : Valid (@node \u03b1 s l x r)) : Valid r", "start": [1105, 1], "end": [1106, 16], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.size_eq", "code": "theorem Valid.size_eq {s l x r} (H : Valid (@node \u03b1 s l x r)) :\n    size (@node \u03b1 s l x r) = size l + size r + 1", "start": [1109, 1], "end": [1111, 8], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node'", "code": "theorem Valid'.node' {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : BalancedSz (size l) (size r)) : Valid' o\u2081 (@node' \u03b1 l x r) o\u2082", "start": [1114, 1], "end": [1116, 19], "kind": "commanddeclaration"}, {"full_name": "Ordnode.valid'_singleton", "code": "theorem valid'_singleton {x : \u03b1} {o\u2081 o\u2082} (h\u2081 : Bounded nil o\u2081 x) (h\u2082 : Bounded nil x o\u2082) :\n    Valid' o\u2081 (singleton x : Ordnode \u03b1) o\u2082", "start": [1119, 1], "end": [1121, 64], "kind": "commanddeclaration"}, {"full_name": "Ordnode.valid_singleton", "code": "theorem valid_singleton {x : \u03b1} : Valid (singleton x : Ordnode \u03b1)", "start": [1124, 1], "end": [1125, 25], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node3L", "code": "theorem Valid'.node3L {l} {x : \u03b1} {m} {y : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hm : Valid' x m y)\n    (hr : Valid' y r o\u2082) (H1 : BalancedSz (size l) (size m))\n    (H2 : BalancedSz (size l + size m + 1) (size r)) : Valid' o\u2081 (@node3L \u03b1 l x m y r) o\u2082", "start": [1128, 1], "end": [1131, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node3R", "code": "theorem Valid'.node3R {l} {x : \u03b1} {m} {y : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hm : Valid' x m y)\n    (hr : Valid' y r o\u2082) (H1 : BalancedSz (size l) (size m + size r + 1))\n    (H2 : BalancedSz (size m) (size r)) : Valid' o\u2081 (@node3R \u03b1 l x m y r) o\u2082", "start": [1134, 1], "end": [1137, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L_lemma\u2081", "code": "theorem Valid'.node4L_lemma\u2081 {a b c d : \u2115} (lr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9)\n    (mr\u2082 : b + c + 1 \u2264 3 * d) (mm\u2081 : b \u2264 3 * c) : b < 3 * a + 1", "start": [1140, 1], "end": [1141, 79], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L_lemma\u2082", "code": "theorem Valid'.node4L_lemma\u2082 {b c d : \u2115} (mr\u2082 : b + c + 1 \u2264 3 * d) : c \u2264 3 * d", "start": [1144, 1], "end": [1144, 94], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L_lemma\u2083", "code": "theorem Valid'.node4L_lemma\u2083 {b c d : \u2115} (mr\u2081 : 2 * d \u2264 b + c + 1) (mm\u2081 : b \u2264 3 * c) : d \u2264 3 * c", "start": [1147, 1], "end": [1148, 14], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L_lemma\u2084", "code": "theorem Valid'.node4L_lemma\u2084 {a b c d : \u2115} (lr\u2081 : 3 * a \u2264 b + c + 1 + d) (mr\u2082 : b + c + 1 \u2264 3 * d)\n    (mm\u2081 : b \u2264 3 * c) : a + b + 1 \u2264 3 * (c + d + 1)", "start": [1151, 1], "end": [1152, 67], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L_lemma\u2085", "code": "theorem Valid'.node4L_lemma\u2085 {a b c d : \u2115} (lr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9)\n    (mr\u2081 : 2 * d \u2264 b + c + 1) (mm\u2082 : c \u2264 3 * b) : c + d + 1 \u2264 3 * (a + b + 1)", "start": [1155, 1], "end": [1156, 93], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.node4L", "code": "theorem Valid'.node4L {l} {x : \u03b1} {m} {y : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hm : Valid' x m y)\n    (hr : Valid' (\u2191y) r o\u2082) (Hm : 0 < size m)\n    (H : size l = 0 \u2227 size m = 1 \u2227 size r \u2264 1 \u2228\n        0 < size l \u2227\n          ratio * size r \u2264 size m \u2227\n            delta * size l \u2264 size m + size r \u2227\n              3 * (size m + size r) \u2264 16 * size l + 9 \u2227 size m \u2264 delta * size r) :\n    Valid' o\u2081 (@node4L \u03b1 l x m y r) o\u2082", "start": [1159, 1], "end": [1214, 45], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateL_lemma\u2081", "code": "theorem Valid'.rotateL_lemma\u2081 {a b c : \u2115} (H2 : 3 * a \u2264 b + c) (hb\u2082 : c \u2264 3 * b) : a \u2264 3 * b", "start": [1217, 1], "end": [1218, 11], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateL_lemma\u2082", "code": "theorem Valid'.rotateL_lemma\u2082 {a b c : \u2115} (H3 : 2 * (b + c) \u2264 9 * a + 3) (h : b < 2 * c) :\n    b < 3 * a + 1", "start": [1221, 1], "end": [1222, 33], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateL_lemma\u2083", "code": "theorem Valid'.rotateL_lemma\u2083 {a b c : \u2115} (H2 : 3 * a \u2264 b + c) (h : b < 2 * c) : a + b < 3 * c", "start": [1225, 1], "end": [1226, 14], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateL_lemma\u2084", "code": "theorem Valid'.rotateL_lemma\u2084 {a b : \u2115} (H3 : 2 * b \u2264 9 * a + 3) : 3 * b \u2264 16 * a + 9", "start": [1229, 1], "end": [1230, 11], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateL", "code": "theorem Valid'.rotateL {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H1 : \u00acsize l + size r \u2264 1) (H2 : delta * size l < size r)\n    (H3 : 2 * size r \u2264 9 * size l + 5 \u2228 size r \u2264 3) : Valid' o\u2081 (@rotateL \u03b1 l x r) o\u2082", "start": [1233, 1], "end": [1290, 100], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.rotateR", "code": "theorem Valid'.rotateR {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H1 : \u00acsize l + size r \u2264 1) (H2 : delta * size r < size l)\n    (H3 : 2 * size l \u2264 9 * size r + 5 \u2228 size l \u2264 3) : Valid' o\u2081 (@rotateR \u03b1 l x r) o\u2082", "start": [1293, 1], "end": [1301, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balance'_aux", "code": "theorem Valid'.balance'_aux {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H\u2081 : 2 * @size \u03b1 r \u2264 9 * size l + 5 \u2228 size r \u2264 3)\n    (H\u2082 : 2 * @size \u03b1 l \u2264 9 * size r + 5 \u2228 size l \u2264 3) : Valid' o\u2081 (@balance' \u03b1 l x r) o\u2082", "start": [1304, 1], "end": [1311, 60], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balance'_lemma", "code": "theorem Valid'.balance'_lemma {\u03b1 l l' r r'} (H1 : BalancedSz l' r')\n    (H2 : Nat.dist (@size \u03b1 l) l' \u2264 1 \u2227 size r = r' \u2228 Nat.dist (size r) r' \u2264 1 \u2227 size l = l') :\n    2 * @size \u03b1 r \u2264 9 * size l + 5 \u2228 size r \u2264 3", "start": [1314, 1], "end": [1330, 87], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balance'", "code": "theorem Valid'.balance' {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : \u2203 l' r', BalancedSz l' r' \u2227\n          (Nat.dist (size l) l' \u2264 1 \u2227 size r = r' \u2228 Nat.dist (size r) r' \u2264 1 \u2227 size l = l')) :\n    Valid' o\u2081 (@balance' \u03b1 l x r) o\u2082", "start": [1333, 1], "end": [1338, 98], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balance", "code": "theorem Valid'.balance {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : \u2203 l' r', BalancedSz l' r' \u2227\n          (Nat.dist (size l) l' \u2264 1 \u2227 size r = r' \u2228 Nat.dist (size r) r' \u2264 1 \u2227 size l = l')) :\n    Valid' o\u2081 (@balance \u03b1 l x r) o\u2082", "start": [1341, 1], "end": [1345, 71], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balanceL_aux", "code": "theorem Valid'.balanceL_aux {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H\u2081 : size l = 0 \u2192 size r \u2264 1) (H\u2082 : 1 \u2264 size l \u2192 1 \u2264 size r \u2192 size r \u2264 delta * size l)\n    (H\u2083 : 2 * @size \u03b1 l \u2264 9 * size r + 5 \u2228 size l \u2264 3) : Valid' o\u2081 (@balanceL \u03b1 l x r) o\u2082", "start": [1348, 1], "end": [1357, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balanceL", "code": "theorem Valid'.balanceL {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : (\u2203 l', Raised l' (size l) \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised (size r) r' \u2227 BalancedSz (size l) r') :\n    Valid' o\u2081 (@balanceL \u03b1 l x r) o\u2082", "start": [1360, 1], "end": [1368, 45], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balanceR_aux", "code": "theorem Valid'.balanceR_aux {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H\u2081 : size r = 0 \u2192 size l \u2264 1) (H\u2082 : 1 \u2264 size r \u2192 1 \u2264 size l \u2192 size l \u2264 delta * size r)\n    (H\u2083 : 2 * @size \u03b1 r \u2264 9 * size l + 5 \u2228 size r \u2264 3) : Valid' o\u2081 (@balanceR \u03b1 l x r) o\u2082", "start": [1371, 1], "end": [1377, 22], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.balanceR", "code": "theorem Valid'.balanceR {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082)\n    (H : (\u2203 l', Raised (size l) l' \u2227 BalancedSz l' (size r)) \u2228\n        \u2203 r', Raised r' (size r) \u2227 BalancedSz (size l) r') :\n    Valid' o\u2081 (@balanceR \u03b1 l x r) o\u2082", "start": [1380, 1], "end": [1384, 90], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.eraseMax_aux", "code": "theorem Valid'.eraseMax_aux {s l x r o\u2081 o\u2082} (H : Valid' o\u2081 (.node s l x r) o\u2082) :\n    Valid' o\u2081 (@eraseMax \u03b1 (.node' l x r)) \u2191(findMax' x r) \u2227\n      size (.node' l x r) = size (eraseMax (.node' l x r)) + 1", "start": [1387, 1], "end": [1397, 20], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.eraseMin_aux", "code": "theorem Valid'.eraseMin_aux {s l} {x : \u03b1} {r o\u2081 o\u2082} (H : Valid' o\u2081 (.node s l x r) o\u2082) :\n    Valid' \u2191(findMin' l x) (@eraseMin \u03b1 (.node' l x r)) o\u2082 \u2227\n      size (.node' l x r) = size (eraseMin (.node' l x r)) + 1", "start": [1400, 1], "end": [1405, 12], "kind": "commanddeclaration"}, {"full_name": "Ordnode.eraseMin.valid", "code": "theorem eraseMin.valid : \u2200 {t}, @Valid \u03b1 _ t \u2192 Valid (eraseMin t)", "start": [1408, 1], "end": [1410, 74], "kind": "commanddeclaration"}, {"full_name": "Ordnode.eraseMax.valid", "code": "theorem eraseMax.valid {t} (h : @Valid \u03b1 _ t) : Valid (eraseMax t)", "start": [1413, 1], "end": [1414, 66], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.glue_aux", "code": "theorem Valid'.glue_aux {l r o\u2081 o\u2082} (hl : Valid' o\u2081 l o\u2082) (hr : Valid' o\u2081 r o\u2082)\n    (sep : l.All fun x => r.All fun y => x < y) (bal : BalancedSz (size l) (size r)) :\n    Valid' o\u2081 (@glue \u03b1 l r) o\u2082 \u2227 size (glue l r) = size l + size r", "start": [1417, 1], "end": [1447, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.glue", "code": "theorem Valid'.glue {l} {x : \u03b1} {r o\u2081 o\u2082} (hl : Valid' o\u2081 l x) (hr : Valid' x r o\u2082) :\n    BalancedSz (size l) (size r) \u2192\n      Valid' o\u2081 (@glue \u03b1 l r) o\u2082 \u2227 size (@glue \u03b1 l r) = size l + size r", "start": [1450, 1], "end": [1453, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.merge_lemma", "code": "theorem Valid'.merge_lemma {a b c : \u2115} (h\u2081 : 3 * a < b + c + 1) (h\u2082 : b \u2264 3 * c) :\n    2 * (a + b) \u2264 9 * c + 5", "start": [1456, 1], "end": [1457, 43], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.merge_aux\u2081", "code": "theorem Valid'.merge_aux\u2081 {o\u2081 o\u2082 ls ll lx lr rs rl rx rr t}\n    (hl : Valid' o\u2081 (@Ordnode.node \u03b1 ls ll lx lr) o\u2082) (hr : Valid' o\u2081 (.node rs rl rx rr) o\u2082)\n    (h : delta * ls < rs) (v : Valid' o\u2081 t rx) (e : size t = ls + size rl) :\n    Valid' o\u2081 (.balanceL t rx rr) o\u2082 \u2227 size (.balanceL t rx rr) = ls + rs", "start": [1460, 1], "end": [1475, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.merge_aux", "code": "theorem Valid'.merge_aux {l r o\u2081 o\u2082} (hl : Valid' o\u2081 l o\u2082) (hr : Valid' o\u2081 r o\u2082)\n    (sep : l.All fun x => r.All fun y => x < y) :\n    Valid' o\u2081 (@merge \u03b1 l r) o\u2082 \u2227 size (merge l r) = size l + size r", "start": [1478, 1], "end": [1496, 74], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid.merge", "code": "theorem Valid.merge {l r} (hl : Valid l) (hr : Valid r)\n    (sep : l.All fun x => r.All fun y => x < y) : Valid (@merge \u03b1 l r)", "start": [1499, 1], "end": [1501, 33], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insertWith.valid_aux", "code": "theorem insertWith.valid_aux [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (f : \u03b1 \u2192 \u03b1) (x : \u03b1)\n    (hf : \u2200 y, x \u2264 y \u2227 y \u2264 x \u2192 x \u2264 f y \u2227 f y \u2264 x) :\n    \u2200 {t o\u2081 o\u2082},\n      Valid' o\u2081 t o\u2082 \u2192\n        Bounded nil o\u2081 x \u2192\n          Bounded nil x o\u2082 \u2192\n            Valid' o\u2081 (insertWith f x t) o\u2082 \u2227 Raised (size t) (size (insertWith f x t))", "start": [1504, 1], "end": [1531, 35], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insertWith.valid", "code": "theorem insertWith.valid [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (f : \u03b1 \u2192 \u03b1) (x : \u03b1)\n    (hf : \u2200 y, x \u2264 y \u2227 y \u2264 x \u2192 x \u2264 f y \u2227 f y \u2264 x) {t} (h : Valid t) : Valid (insertWith f x t)", "start": [1534, 1], "end": [1536, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert_eq_insertWith", "code": "theorem insert_eq_insertWith [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) :\n    \u2200 t, Ordnode.insert x t = insertWith (fun _ => x) x t", "start": [1539, 1], "end": [1543, 86], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert.valid", "code": "theorem insert.valid [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) {t} (h : Valid t) :\n    Valid (Ordnode.insert x t)", "start": [1546, 1], "end": [1548, 88], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert'_eq_insertWith", "code": "theorem insert'_eq_insertWith [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) :\n    \u2200 t, insert' x t = insertWith id x t", "start": [1551, 1], "end": [1555, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert'.valid", "code": "theorem insert'.valid [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) {t} (h : Valid t) :\n    Valid (insert' x t)", "start": [1558, 1], "end": [1560, 73], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.map_aux", "code": "theorem Valid'.map_aux {\u03b2} [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (f_strict_mono : StrictMono f) {t a\u2081 a\u2082}\n    (h : Valid' a\u2081 t a\u2082) :\n    Valid' (Option.map f a\u2081) (map f t) (Option.map f a\u2082) \u2227 (map f t).size = t.size", "start": [1563, 1], "end": [1591, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.map.valid", "code": "theorem map.valid {\u03b2} [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (f_strict_mono : StrictMono f) {t} (h : Valid t) :\n    Valid (map f t)", "start": [1594, 1], "end": [1596, 37], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Valid'.erase_aux", "code": "theorem Valid'.erase_aux [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) {t a\u2081 a\u2082} (h : Valid' a\u2081 t a\u2082) :\n    Valid' a\u2081 (erase x t) a\u2082 \u2227 Raised (erase x t).size t.size", "start": [1599, 1], "end": [1631, 65], "kind": "commanddeclaration"}, {"full_name": "Ordnode.erase.valid", "code": "theorem erase.valid [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) {t} (h : Valid t) : Valid (erase x t)", "start": [1634, 1], "end": [1635, 27], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_erase_of_mem", "code": "theorem size_erase_of_mem [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] {x : \u03b1} {t a\u2081 a\u2082} (h : Valid' a\u2081 t a\u2082)\n    (h_mem : x \u2208 t) : size (erase x t) = size t - 1", "start": [1638, 1], "end": [1672, 42], "kind": "commanddeclaration"}, {"full_name": "Ordset", "code": "def Ordset (\u03b1 : Type*) [Preorder \u03b1] :=\n  { t : Ordnode \u03b1 // t.Valid }", "start": [1679, 1], "end": [1684, 31], "kind": "commanddeclaration"}, {"full_name": "Ordset.nil", "code": "nonrec def nil : Ordset \u03b1 :=\n  \u27e8nil, \u27e8\u27e9, \u27e8\u27e9, \u27e8\u27e9\u27e9", "start": [1693, 1], "end": [1695, 20], "kind": "commanddeclaration"}, {"full_name": "Ordset.size", "code": "def size (s : Ordset \u03b1) : \u2115 :=\n  s.1.size", "start": [1698, 1], "end": [1700, 11], "kind": "commanddeclaration"}, {"full_name": "Ordset.singleton", "code": "protected def singleton (a : \u03b1) : Ordset \u03b1 :=\n  \u27e8singleton a, valid_singleton\u27e9", "start": [1703, 1], "end": [1705, 33], "kind": "commanddeclaration"}, {"full_name": "Ordset.instEmptyCollection", "code": "instance instEmptyCollection : EmptyCollection (Ordset \u03b1) :=\n  \u27e8nil\u27e9", "start": [1708, 1], "end": [1709, 8], "kind": "commanddeclaration"}, {"full_name": "Ordset.instInhabited", "code": "instance instInhabited : Inhabited (Ordset \u03b1) :=\n  \u27e8nil\u27e9", "start": [1712, 1], "end": [1713, 8], "kind": "commanddeclaration"}, {"full_name": "Ordset.instSingleton", "code": "instance instSingleton : Singleton \u03b1 (Ordset \u03b1) :=\n  \u27e8Ordset.singleton\u27e9", "start": [1716, 1], "end": [1717, 21], "kind": "commanddeclaration"}, {"full_name": "Ordset.Empty", "code": "def Empty (s : Ordset \u03b1) : Prop :=\n  s = \u2205", "start": [1720, 1], "end": [1722, 8], "kind": "commanddeclaration"}, {"full_name": "Ordset.empty_iff", "code": "theorem empty_iff {s : Ordset \u03b1} : s = \u2205 \u2194 s.1.empty", "start": [1725, 1], "end": [1727, 77], "kind": "commanddeclaration"}, {"full_name": "Ordset.Empty.instDecidablePred", "code": "instance Empty.instDecidablePred : DecidablePred (@Empty \u03b1 _) :=\n  fun _ => decidable_of_iff' _ empty_iff", "start": [1730, 1], "end": [1731, 41], "kind": "commanddeclaration"}, {"full_name": "Ordset.insert", "code": "protected def insert [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) (s : Ordset \u03b1) :\n    Ordset \u03b1 :=\n  \u27e8Ordnode.insert x s.1, insert.valid _ s.2\u27e9", "start": [1734, 1], "end": [1738, 45], "kind": "commanddeclaration"}, {"full_name": "Ordset.instInsert", "code": "instance instInsert [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : Insert \u03b1 (Ordset \u03b1) :=\n  \u27e8Ordset.insert\u27e9", "start": [1741, 1], "end": [1742, 18], "kind": "commanddeclaration"}, {"full_name": "Ordset.insert'", "code": "nonrec def insert' [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) (s : Ordset \u03b1) :\n    Ordset \u03b1 :=\n  \u27e8insert' x s.1, insert'.valid _ s.2\u27e9", "start": [1745, 1], "end": [1749, 39], "kind": "commanddeclaration"}, {"full_name": "Ordset.mem", "code": "def mem (x : \u03b1) (s : Ordset \u03b1) : Bool :=\n  x \u2208 s.val", "start": [1756, 1], "end": [1759, 12], "kind": "commanddeclaration"}, {"full_name": "Ordset.find", "code": "def find (x : \u03b1) (s : Ordset \u03b1) : Option \u03b1 :=\n  Ordnode.find x s.val", "start": [1762, 1], "end": [1765, 23], "kind": "commanddeclaration"}, {"full_name": "Ordset.instMembership", "code": "instance instMembership : Membership \u03b1 (Ordset \u03b1) :=\n  \u27e8fun x s => mem x s\u27e9", "start": [1768, 1], "end": [1769, 23], "kind": "commanddeclaration"}, {"full_name": "Ordset.mem.decidable", "code": "instance mem.decidable (x : \u03b1) (s : Ordset \u03b1) : Decidable (x \u2208 s) :=\n  instDecidableEqBool _ _", "start": [1772, 1], "end": [1773, 26], "kind": "commanddeclaration"}, {"full_name": "Ordset.pos_size_of_mem", "code": "theorem pos_size_of_mem {x : \u03b1} {t : Ordset \u03b1} (h_mem : x \u2208 t) : 0 < size t", "start": [1776, 1], "end": [1778, 52], "kind": "commanddeclaration"}, {"full_name": "Ordset.erase", "code": "def erase [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) (s : Ordset \u03b1) : Ordset \u03b1 :=\n  \u27e8Ordnode.erase x s.val, Ordnode.erase.valid x s.property\u27e9", "start": [1783, 1], "end": [1786, 60], "kind": "commanddeclaration"}, {"full_name": "Ordset.map", "code": "def map {\u03b2} [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (f_strict_mono : StrictMono f) (s : Ordset \u03b1) : Ordset \u03b2 :=\n  \u27e8Ordnode.map f s.val, Ordnode.map.valid f_strict_mono s.property\u27e9", "start": [1789, 1], "end": [1791, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Functor.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Multiset/Functor.lean", "Mathlib/Data/Finset/NAry.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.functor", "code": "protected instance functor : Functor Finset where map f s := s.image f", "start": [37, 1], "end": [39, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.lawfulFunctor", "code": "instance lawfulFunctor : LawfulFunctor Finset where\n  id_map s := image_id\n  comp_map f g s := image_image.symm\n  map_const {\u03b1} {\u03b2} := by simp only [Functor.mapConst, Functor.map]", "start": [41, 1], "end": [44, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.fmap_def", "code": "@[simp]\ntheorem fmap_def {s : Finset \u03b1} (f : \u03b1 \u2192 \u03b2) : f <$> s = s.image f", "start": [46, 1], "end": [47, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.pure", "code": "protected instance pure : Pure Finset :=\n  \u27e8fun x => {x}\u27e9", "start": [55, 1], "end": [56, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.pure_def", "code": "@[simp]\ntheorem pure_def {\u03b1} : (pure : \u03b1 \u2192 Finset \u03b1) = singleton", "start": [58, 1], "end": [59, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.applicative", "code": "protected instance applicative : Applicative Finset :=\n  { Finset.functor, Finset.pure with\n    seq := fun t s => t.sup fun f => (s ()).image f\n    seqLeft := fun s t => if t () = \u2205 then \u2205 else s\n    seqRight := fun s t => if s = \u2205 then \u2205 else t () }", "start": [69, 1], "end": [73, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.seq_def", "code": "@[simp]\ntheorem seq_def (s : Finset \u03b1) (t : Finset (\u03b1 \u2192 \u03b2)) : t <*> s = t.sup fun f => s.image f", "start": [75, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.seqLeft_def", "code": "@[simp]\ntheorem seqLeft_def (s : Finset \u03b1) (t : Finset \u03b2) : s <* t = if t = \u2205 then \u2205 else s", "start": [80, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.seqRight_def", "code": "@[simp]\ntheorem seqRight_def (s : Finset \u03b1) (t : Finset \u03b2) : s *> t = if s = \u2205 then \u2205 else t", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_def", "code": "theorem image\u2082_def {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    image\u2082 f s t = f <$> s <*> t", "start": [90, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.lawfulApplicative", "code": "instance lawfulApplicative : LawfulApplicative Finset :=\n  { Finset.lawfulFunctor with\n    seqLeft_eq := fun s t => by\n      rw [seq_def, fmap_def, seqLeft_def]\n      obtain rfl | ht := t.eq_empty_or_nonempty\n      \u00b7 simp_rw [image_empty, if_true]\n        exact (sup_bot _).symm\n      \u00b7 ext a\n        rw [if_neg ht.ne_empty, mem_sup]\n        refine' \u27e8fun ha => \u27e8const _ a, mem_image_of_mem _ ha, mem_image_const_self.2 ht\u27e9, _\u27e9\n        rintro \u27e8f, hf, ha\u27e9\n        rw [mem_image] at hf ha\n        obtain \u27e8b, hb, rfl\u27e9 := hf\n        obtain \u27e8_, _, rfl\u27e9 := ha\n        exact hb\n    seqRight_eq := fun s t => by\n      rw [seq_def, fmap_def, seqRight_def]\n      obtain rfl | hs := s.eq_empty_or_nonempty\n      \u00b7 rw [if_pos rfl, image_empty, sup_empty, bot_eq_empty]\n      \u00b7 ext a\n        rw [if_neg hs.ne_empty, mem_sup]\n        refine' \u27e8fun ha => \u27e8id, mem_image_const_self.2 hs, by rwa [image_id]\u27e9, _\u27e9\n        rintro \u27e8f, hf, ha\u27e9\n        rw [mem_image] at hf ha\n        obtain \u27e8b, hb, rfl\u27e9 := ha\n        obtain \u27e8_, _, rfl\u27e9 := hf\n        exact hb\n    pure_seq := fun f s => by simp only [pure_def, seq_def, sup_singleton, fmap_def]\n    map_pure := fun f a => image_singleton _ _\n    seq_pure := fun s a => sup_singleton'' _ _\n    seq_assoc := fun s t u => by\n      ext a\n      simp_rw [seq_def, fmap_def]\n      simp only [exists_prop, mem_sup, mem_image]\n      constructor\n      \u00b7 rintro \u27e8g, hg, b, \u27e8f, hf, a, ha, rfl\u27e9, rfl\u27e9\n        exact \u27e8g \u2218 f, \u27e8comp g, \u27e8g, hg, rfl\u27e9, f, hf, rfl\u27e9, a, ha, rfl\u27e9\n      \u00b7 rintro \u27e8c, \u27e8_, \u27e8g, hg, rfl\u27e9, f, hf, rfl\u27e9, a, ha, rfl\u27e9\n        exact \u27e8g, hg, f a, \u27e8f, hf, a, ha, rfl\u27e9, rfl\u27e9 }", "start": [98, 1], "end": [136, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.commApplicative", "code": "instance commApplicative : CommApplicative Finset :=\n  { Finset.lawfulApplicative with\n    commutative_prod := fun s t => by\n      simp_rw [seq_def, fmap_def, sup_image, sup_eq_biUnion]\n      change (s.biUnion fun a => t.image fun b => (a, b))\n        = t.biUnion fun b => s.image fun a => (a, b)\n      trans s \u00d7\u02e2 t <;> [rw [product_eq_biUnion]; rw [product_eq_biUnion_right]] }", "start": [138, 1], "end": [144, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.bind_def", "code": "@[simp]\ntheorem bind_def {\u03b1 \u03b2} : (\u00b7 >>= \u00b7) = sup (\u03b1 := Finset \u03b1) (\u03b2 := \u03b2)", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.traverse", "code": "def traverse [DecidableEq \u03b2] (f : \u03b1 \u2192 F \u03b2) (s : Finset \u03b1) : F (Finset \u03b2) :=\n  Multiset.toFinset <$> Multiset.traverse f s.1", "start": [194, 1], "end": [196, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.id_traverse", "code": "@[simp]\ntheorem id_traverse [DecidableEq \u03b1] (s : Finset \u03b1) : traverse (pure : \u03b1 \u2192 Id \u03b1) s = s", "start": [199, 1], "end": [202, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.map_comp_coe", "code": "@[simp]\ntheorem map_comp_coe (h : \u03b1 \u2192 \u03b2) :\n    Functor.map h \u2218 Multiset.toFinset = Multiset.toFinset \u2218 Functor.map h", "start": [207, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.map_traverse", "code": "theorem map_traverse (g : \u03b1 \u2192 G \u03b2) (h : \u03b2 \u2192 \u03b3) (s : Finset \u03b1) :\n    Functor.map h <$> traverse g s = traverse (Functor.map h \u2218 g) s", "start": [213, 1], "end": [217, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/IsDiag.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Orthogonal.lean", "Mathlib/Data/Matrix/Kronecker.lean", "Mathlib/LinearAlgebra/Matrix/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.IsDiag", "code": "def IsDiag [Zero \u03b1] (A : Matrix n n \u03b1) : Prop :=\n  \u2200 \u2983i j\u2984, i \u2260 j \u2192 A i j = 0", "start": [35, 1], "end": [37, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_diagonal", "code": "@[simp]\ntheorem isDiag_diagonal [Zero \u03b1] [DecidableEq n] (d : n \u2192 \u03b1) : (diagonal d).IsDiag", "start": [40, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.diagonal_diag", "code": "theorem IsDiag.diagonal_diag [Zero \u03b1] [DecidableEq n] {A : Matrix n n \u03b1} (h : A.IsDiag) :\n    diagonal (diag A) = A", "start": [45, 1], "end": [51, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_iff_diagonal_diag", "code": "theorem isDiag_iff_diagonal_diag [Zero \u03b1] [DecidableEq n] (A : Matrix n n \u03b1) :\n    A.IsDiag \u2194 diagonal (diag A) = A", "start": [54, 1], "end": [57, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_of_subsingleton", "code": "theorem isDiag_of_subsingleton [Zero \u03b1] [Subsingleton n] (A : Matrix n n \u03b1) : A.IsDiag", "start": [60, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_zero", "code": "@[simp]\ntheorem isDiag_zero [Zero \u03b1] : (0 : Matrix n n \u03b1).IsDiag", "start": [65, 1], "end": [67, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_one", "code": "@[simp]\ntheorem isDiag_one [DecidableEq n] [Zero \u03b1] [One \u03b1] : (1 : Matrix n n \u03b1).IsDiag", "start": [70, 1], "end": [73, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.map", "code": "theorem IsDiag.map [Zero \u03b1] [Zero \u03b2] {A : Matrix n n \u03b1} (ha : A.IsDiag) {f : \u03b1 \u2192 \u03b2} (hf : f 0 = 0) :\n    (A.map f).IsDiag", "start": [76, 1], "end": [79, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.neg", "code": "theorem IsDiag.neg [AddGroup \u03b1] {A : Matrix n n \u03b1} (ha : A.IsDiag) : (-A).IsDiag", "start": [82, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_neg_iff", "code": "@[simp]\ntheorem isDiag_neg_iff [AddGroup \u03b1] {A : Matrix n n \u03b1} : (-A).IsDiag \u2194 A.IsDiag", "start": [87, 1], "end": [89, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.add", "code": "theorem IsDiag.add [AddZeroClass \u03b1] {A B : Matrix n n \u03b1} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A + B).IsDiag", "start": [92, 1], "end": [95, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.sub", "code": "theorem IsDiag.sub [AddGroup \u03b1] {A B : Matrix n n \u03b1} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A - B).IsDiag", "start": [98, 1], "end": [101, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.smul", "code": "theorem IsDiag.smul [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] (k : R) {A : Matrix n n \u03b1}\n    (ha : A.IsDiag) : (k \u2022 A).IsDiag", "start": [104, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_smul_one", "code": "@[simp]\ntheorem isDiag_smul_one (n) [Semiring \u03b1] [DecidableEq n] (k : \u03b1) :\n    (k \u2022 (1 : Matrix n n \u03b1)).IsDiag", "start": [110, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.transpose", "code": "theorem IsDiag.transpose [Zero \u03b1] {A : Matrix n n \u03b1} (ha : A.IsDiag) : A\u1d40.IsDiag", "start": [116, 1], "end": [117, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_transpose_iff", "code": "@[simp]\ntheorem isDiag_transpose_iff [Zero \u03b1] {A : Matrix n n \u03b1} : A\u1d40.IsDiag \u2194 A.IsDiag", "start": [120, 1], "end": [122, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.conjTranspose", "code": "theorem IsDiag.conjTranspose [Semiring \u03b1] [StarRing \u03b1] {A : Matrix n n \u03b1} (ha : A.IsDiag) :\n    A\u1d34.IsDiag", "start": [125, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_conjTranspose_iff", "code": "@[simp]\ntheorem isDiag_conjTranspose_iff [Semiring \u03b1] [StarRing \u03b1] {A : Matrix n n \u03b1} :\n    A\u1d34.IsDiag \u2194 A.IsDiag", "start": [130, 1], "end": [135, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.submatrix", "code": "theorem IsDiag.submatrix [Zero \u03b1] {A : Matrix n n \u03b1} (ha : A.IsDiag) {f : m \u2192 n}\n    (hf : Injective f) : (A.submatrix f f).IsDiag", "start": [138, 1], "end": [139, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.kronecker", "code": "theorem IsDiag.kronecker [MulZeroClass \u03b1] {A : Matrix m m \u03b1} {B : Matrix n n \u03b1} (hA : A.IsDiag)\n    (hB : B.IsDiag) : (A \u2297\u2096 B).IsDiag", "start": [142, 1], "end": [149, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.isSymm", "code": "theorem IsDiag.isSymm [Zero \u03b1] {A : Matrix n n \u03b1} (h : A.IsDiag) : A.IsSymm", "start": [152, 1], "end": [155, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.fromBlocks", "code": "theorem IsDiag.fromBlocks [Zero \u03b1] {A : Matrix m m \u03b1} {D : Matrix n n \u03b1} (ha : A.IsDiag)\n    (hd : D.IsDiag) : (A.fromBlocks 0 0 D).IsDiag", "start": [158, 1], "end": [165, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.isDiag_fromBlocks_iff", "code": "theorem isDiag_fromBlocks_iff [Zero \u03b1] {A : Matrix m m \u03b1} {B : Matrix m n \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} : (A.fromBlocks B C D).IsDiag \u2194 A.IsDiag \u2227 B = 0 \u2227 C = 0 \u2227 D.IsDiag", "start": [168, 1], "end": [179, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsDiag.fromBlocks_of_isSymm", "code": "theorem IsDiag.fromBlocks_of_isSymm [Zero \u03b1] {A : Matrix m m \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) :\n    (A.fromBlocks 0 C D).IsDiag", "start": [182, 1], "end": [188, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRows", "code": "theorem mul_transpose_self_isDiag_iff_hasOrthogonalRows [Fintype n] [Mul \u03b1] [AddCommMonoid \u03b1]\n    {A : Matrix m n \u03b1} : (A * A\u1d40).IsDiag \u2194 A.HasOrthogonalRows", "start": [191, 1], "end": [193, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalCols", "code": "theorem transpose_mul_self_isDiag_iff_hasOrthogonalCols [Fintype m] [Mul \u03b1] [AddCommMonoid \u03b1]\n    {A : Matrix m n \u03b1} : (A\u1d40 * A).IsDiag \u2194 A.HasOrthogonalCols", "start": [196, 1], "end": [198, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Polynomials.lean", "imports": ["Mathlib/Data/Polynomial/RingDivision.lean", "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean", "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.eventually_no_roots", "code": "theorem eventually_no_roots (hP : P \u2260 0) : \u2200\u1da0 x in atTop, \u00acP.IsRoot x", "start": [34, 1], "end": [35, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isEquivalent_atTop_lead", "code": "theorem isEquivalent_atTop_lead :\n    (fun x => eval x P) ~[atTop] fun x => P.leadingCoeff * x ^ P.natDegree", "start": [42, 1], "end": [54, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.tendsto_atTop_of_leadingCoeff_nonneg", "code": "theorem tendsto_atTop_of_leadingCoeff_nonneg (hdeg : 0 < P.degree) (hnng : 0 \u2264 P.leadingCoeff) :\n    Tendsto (fun x => eval x P) atTop atTop", "start": [57, 1], "end": [61, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.tendsto_atTop_iff_leadingCoeff_nonneg", "code": "theorem tendsto_atTop_iff_leadingCoeff_nonneg :\n    Tendsto (fun x => eval x P) atTop atTop \u2194 0 < P.degree \u2227 0 \u2264 P.leadingCoeff", "start": [64, 1], "end": [70, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.tendsto_atBot_iff_leadingCoeff_nonpos", "code": "theorem tendsto_atBot_iff_leadingCoeff_nonpos :\n    Tendsto (fun x => eval x P) atTop atBot \u2194 0 < P.degree \u2227 P.leadingCoeff \u2264 0", "start": [73, 1], "end": [76, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.tendsto_atBot_of_leadingCoeff_nonpos", "code": "theorem tendsto_atBot_of_leadingCoeff_nonpos (hdeg : 0 < P.degree) (hnps : P.leadingCoeff \u2264 0) :\n    Tendsto (fun x => eval x P) atTop atBot", "start": [79, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.abs_tendsto_atTop", "code": "theorem abs_tendsto_atTop (hdeg : 0 < P.degree) :\n    Tendsto (fun x => abs <| eval x P) atTop atTop", "start": [84, 1], "end": [88, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.abs_isBoundedUnder_iff", "code": "theorem abs_isBoundedUnder_iff :\n    (IsBoundedUnder (\u00b7 \u2264 \u00b7) atTop fun x => |eval x P|) \u2194 P.degree \u2264 0", "start": [91, 1], "end": [97, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.abs_tendsto_atTop_iff", "code": "theorem abs_tendsto_atTop_iff : Tendsto (fun x => abs <| eval x P) atTop atTop \u2194 0 < P.degree", "start": [100, 1], "end": [102, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.tendsto_nhds_iff", "code": "theorem tendsto_nhds_iff {c : \ud835\udd5c} :\n    Tendsto (fun x => eval x P) atTop (\ud835\udcdd c) \u2194 P.leadingCoeff = c \u2227 P.degree \u2264 0", "start": [105, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isEquivalent_atTop_div", "code": "theorem isEquivalent_atTop_div :\n    (fun x => eval x P / eval x Q) ~[atTop] fun x =>\n      P.leadingCoeff / Q.leadingCoeff * x ^ (P.natDegree - Q.natDegree : \u2124)", "start": [124, 1], "end": [134, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_zero_of_degree_lt", "code": "theorem div_tendsto_zero_of_degree_lt (hdeg : P.degree < Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (\ud835\udcdd 0)", "start": [137, 1], "end": [145, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_zero_iff_degree_lt", "code": "theorem div_tendsto_zero_iff_degree_lt (hQ : Q \u2260 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (\ud835\udcdd 0) \u2194 P.degree < Q.degree", "start": [148, 1], "end": [162, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_leadingCoeff_div_of_degree_eq", "code": "theorem div_tendsto_leadingCoeff_div_of_degree_eq (hdeg : P.degree = Q.degree) :\n    Tendsto (fun x => eval x P / eval x Q) atTop (\ud835\udcdd <| P.leadingCoeff / Q.leadingCoeff)", "start": [165, 1], "end": [169, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_atTop_of_degree_gt'", "code": "theorem div_tendsto_atTop_of_degree_gt' (hdeg : Q.degree < P.degree)\n    (hpos : 0 < P.leadingCoeff / Q.leadingCoeff) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atTop", "start": [172, 1], "end": [182, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_atTop_of_degree_gt", "code": "theorem div_tendsto_atTop_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q \u2260 0)\n    (hnng : 0 \u2264 P.leadingCoeff / Q.leadingCoeff) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atTop", "start": [185, 1], "end": [192, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_atBot_of_degree_gt'", "code": "theorem div_tendsto_atBot_of_degree_gt' (hdeg : Q.degree < P.degree)\n    (hneg : P.leadingCoeff / Q.leadingCoeff < 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atBot", "start": [195, 1], "end": [205, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_tendsto_atBot_of_degree_gt", "code": "theorem div_tendsto_atBot_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q \u2260 0)\n    (hnps : P.leadingCoeff / Q.leadingCoeff \u2264 0) :\n    Tendsto (fun x => eval x P / eval x Q) atTop atBot", "start": [208, 1], "end": [215, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.abs_div_tendsto_atTop_of_degree_gt", "code": "theorem abs_div_tendsto_atTop_of_degree_gt (hdeg : Q.degree < P.degree) (hQ : Q \u2260 0) :\n    Tendsto (fun x => |eval x P / eval x Q|) atTop atTop", "start": [218, 1], "end": [223, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isBigO_of_degree_le", "code": "theorem isBigO_of_degree_le (h : P.degree \u2264 Q.degree) :\n    (fun x => eval x P) =O[atTop] fun x => eval x Q", "start": [228, 1], "end": [237, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Intrinsic.lean", "imports": ["Mathlib/Analysis/NormedSpace/AddTorsorBases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "intrinsicInterior", "code": "def intrinsicInterior (s : Set P) : Set P :=\n  (\u2191) '' interior ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s)", "start": [60, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier", "code": "def intrinsicFrontier (s : Set P) : Set P :=\n  (\u2191) '' frontier ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s)", "start": [65, 1], "end": [67, 54], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure", "code": "def intrinsicClosure (s : Set P) : Set P :=\n  (\u2191) '' closure ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s)", "start": [70, 1], "end": [72, 53], "kind": "commanddeclaration"}, {"full_name": "mem_intrinsicInterior", "code": "@[simp]\ntheorem mem_intrinsicInterior :\n    x \u2208 intrinsicInterior \ud835\udd5c s \u2194 \u2203 y, y \u2208 interior ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s) \u2227 \u2191y = x", "start": [77, 1], "end": [80, 18], "kind": "commanddeclaration"}, {"full_name": "mem_intrinsicFrontier", "code": "@[simp]\ntheorem mem_intrinsicFrontier :\n    x \u2208 intrinsicFrontier \ud835\udd5c s \u2194 \u2203 y, y \u2208 frontier ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s) \u2227 \u2191y = x", "start": [83, 1], "end": [86, 18], "kind": "commanddeclaration"}, {"full_name": "mem_intrinsicClosure", "code": "@[simp]\ntheorem mem_intrinsicClosure :\n    x \u2208 intrinsicClosure \ud835\udd5c s \u2194 \u2203 y, y \u2208 closure ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s) \u2227 \u2191y = x", "start": [89, 1], "end": [92, 18], "kind": "commanddeclaration"}, {"full_name": "intrinsicInterior_subset", "code": "theorem intrinsicInterior_subset : intrinsicInterior \ud835\udd5c s \u2286 s", "start": [95, 1], "end": [96, 37], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_subset", "code": "theorem intrinsicFrontier_subset (hs : IsClosed s) : intrinsicFrontier \ud835\udd5c s \u2286 s", "start": [99, 1], "end": [100, 74], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_subset_intrinsicClosure", "code": "theorem intrinsicFrontier_subset_intrinsicClosure : intrinsicFrontier \ud835\udd5c s \u2286 intrinsicClosure \ud835\udd5c s", "start": [103, 1], "end": [104, 41], "kind": "commanddeclaration"}, {"full_name": "subset_intrinsicClosure", "code": "theorem subset_intrinsicClosure : s \u2286 intrinsicClosure \ud835\udd5c s", "start": [107, 1], "end": [108, 70], "kind": "commanddeclaration"}, {"full_name": "intrinsicInterior_empty", "code": "@[simp]\ntheorem intrinsicInterior_empty : intrinsicInterior \ud835\udd5c (\u2205 : Set P) = \u2205", "start": [111, 1], "end": [112, 101], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_empty", "code": "@[simp]\ntheorem intrinsicFrontier_empty : intrinsicFrontier \ud835\udd5c (\u2205 : Set P) = \u2205", "start": [115, 1], "end": [116, 101], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_empty", "code": "@[simp]\ntheorem intrinsicClosure_empty : intrinsicClosure \ud835\udd5c (\u2205 : Set P) = \u2205", "start": [119, 1], "end": [120, 98], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_nonempty", "code": "@[simp]\ntheorem intrinsicClosure_nonempty : (intrinsicClosure \ud835\udd5c s).Nonempty \u2194 s.Nonempty", "start": [123, 1], "end": [126, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.ofIntrinsicClosure", "code": "alias \u27e8Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosure\u27e9 := intrinsicClosure_nonempty", "start": [129, 1], "end": [129, 100], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Nonempty.intrinsicClosure", "code": "alias \u27e8Set.Nonempty.ofIntrinsicClosure, Set.Nonempty.intrinsicClosure\u27e9 := intrinsicClosure_nonempty", "start": [129, 1], "end": [129, 100], "kind": "stdtacticaliasaliaslr"}, {"full_name": "intrinsicInterior_singleton", "code": "@[simp]\ntheorem intrinsicInterior_singleton (x : P) : intrinsicInterior \ud835\udd5c ({x} : Set P) = {x}", "start": [135, 1], "end": [138, 60], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_singleton", "code": "@[simp]\ntheorem intrinsicFrontier_singleton (x : P) : intrinsicFrontier \ud835\udd5c ({x} : Set P) = \u2205", "start": [141, 1], "end": [143, 88], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_singleton", "code": "@[simp]\ntheorem intrinsicClosure_singleton (x : P) : intrinsicClosure \ud835\udd5c ({x} : Set P) = {x}", "start": [146, 1], "end": [149, 60], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_mono", "code": "theorem intrinsicClosure_mono (h : s \u2286 t) : intrinsicClosure \ud835\udd5c s \u2286 intrinsicClosure \ud835\udd5c t", "start": [157, 1], "end": [161, 25], "kind": "commanddeclaration"}, {"full_name": "interior_subset_intrinsicInterior", "code": "theorem interior_subset_intrinsicInterior : interior s \u2286 intrinsicInterior \ud835\udd5c s", "start": [164, 1], "end": [166, 79], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_subset_closure", "code": "theorem intrinsicClosure_subset_closure : intrinsicClosure \ud835\udd5c s \u2286 closure s", "start": [169, 1], "end": [170, 73], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_subset_frontier", "code": "theorem intrinsicFrontier_subset_frontier : intrinsicFrontier \ud835\udd5c s \u2286 frontier s", "start": [173, 1], "end": [174, 74], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_subset_affineSpan", "code": "theorem intrinsicClosure_subset_affineSpan : intrinsicClosure \ud835\udd5c s \u2286 affineSpan \ud835\udd5c s", "start": [177, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_diff_intrinsicFrontier", "code": "@[simp]\ntheorem intrinsicClosure_diff_intrinsicFrontier (s : Set P) :\n    intrinsicClosure \ud835\udd5c s \\ intrinsicFrontier \ud835\udd5c s = intrinsicInterior \ud835\udd5c s", "start": [181, 1], "end": [185, 50], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_diff_intrinsicInterior", "code": "@[simp]\ntheorem intrinsicClosure_diff_intrinsicInterior (s : Set P) :\n    intrinsicClosure \ud835\udd5c s \\ intrinsicInterior \ud835\udd5c s = intrinsicFrontier \ud835\udd5c s", "start": [188, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "intrinsicInterior_union_intrinsicFrontier", "code": "@[simp]\ntheorem intrinsicInterior_union_intrinsicFrontier (s : Set P) :\n    intrinsicInterior \ud835\udd5c s \u222a intrinsicFrontier \ud835\udd5c s = intrinsicClosure \ud835\udd5c s", "start": [194, 1], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "intrinsicFrontier_union_intrinsicInterior", "code": "@[simp]\ntheorem intrinsicFrontier_union_intrinsicInterior (s : Set P) :\n    intrinsicFrontier \ud835\udd5c s \u222a intrinsicInterior \ud835\udd5c s = intrinsicClosure \ud835\udd5c s", "start": [201, 1], "end": [204, 61], "kind": "commanddeclaration"}, {"full_name": "isClosed_intrinsicClosure", "code": "theorem isClosed_intrinsicClosure (hs : IsClosed (affineSpan \ud835\udd5c s : Set P)) :\n    IsClosed (intrinsicClosure \ud835\udd5c s)", "start": [207, 1], "end": [209, 66], "kind": "commanddeclaration"}, {"full_name": "isClosed_intrinsicFrontier", "code": "theorem isClosed_intrinsicFrontier (hs : IsClosed (affineSpan \ud835\udd5c s : Set P)) :\n    IsClosed (intrinsicFrontier \ud835\udd5c s)", "start": [212, 1], "end": [214, 67], "kind": "commanddeclaration"}, {"full_name": "affineSpan_intrinsicClosure", "code": "@[simp]\ntheorem affineSpan_intrinsicClosure (s : Set P) :\n    affineSpan \ud835\udd5c (intrinsicClosure \ud835\udd5c s) = affineSpan \ud835\udd5c s", "start": [217, 1], "end": [221, 46], "kind": "commanddeclaration"}, {"full_name": "IsClosed.intrinsicClosure", "code": "protected theorem IsClosed.intrinsicClosure (hs : IsClosed ((\u2191) \u207b\u00b9' s : Set <| affineSpan \ud835\udd5c s)) :\n    intrinsicClosure \ud835\udd5c s = s", "start": [224, 1], "end": [227, 65], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_idem", "code": "@[simp]\ntheorem intrinsicClosure_idem (s : Set P) :\n    intrinsicClosure \ud835\udd5c (intrinsicClosure \ud835\udd5c s) = intrinsicClosure \ud835\udd5c s", "start": [230, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.image_intrinsicInterior", "code": "@[simp]\ntheorem image_intrinsicInterior (\u03c6 : P \u2192\u1d43\u2071[\ud835\udd5c] Q) (s : Set P) :\n    intrinsicInterior \ud835\udd5c (\u03c6 '' s) = \u03c6 '' intrinsicInterior \ud835\udd5c s", "start": [252, 1], "end": [263, 71], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.image_intrinsicFrontier", "code": "@[simp]\ntheorem image_intrinsicFrontier (\u03c6 : P \u2192\u1d43\u2071[\ud835\udd5c] Q) (s : Set P) :\n    intrinsicFrontier \ud835\udd5c (\u03c6 '' s) = \u03c6 '' intrinsicFrontier \ud835\udd5c s", "start": [266, 1], "end": [277, 71], "kind": "commanddeclaration"}, {"full_name": "AffineIsometry.image_intrinsicClosure", "code": "@[simp]\ntheorem image_intrinsicClosure (\u03c6 : P \u2192\u1d43\u2071[\ud835\udd5c] Q) (s : Set P) :\n    intrinsicClosure \ud835\udd5c (\u03c6 '' s) = \u03c6 '' intrinsicClosure \ud835\udd5c s", "start": [280, 1], "end": [291, 71], "kind": "commanddeclaration"}, {"full_name": "intrinsicClosure_eq_closure", "code": "@[simp]\ntheorem intrinsicClosure_eq_closure : intrinsicClosure \ud835\udd5c s = closure s", "start": [301, 1], "end": [314, 42], "kind": "commanddeclaration"}, {"full_name": "closure_diff_intrinsicInterior", "code": "@[simp]\ntheorem closure_diff_intrinsicInterior (s : Set P) :\n    closure s \\ intrinsicInterior \ud835\udd5c s = intrinsicFrontier \ud835\udd5c s", "start": [319, 1], "end": [322, 78], "kind": "commanddeclaration"}, {"full_name": "closure_diff_intrinsicFrontier", "code": "@[simp]\ntheorem closure_diff_intrinsicFrontier (s : Set P) :\n    closure s \\ intrinsicFrontier \ud835\udd5c s = intrinsicInterior \ud835\udd5c s", "start": [325, 1], "end": [328, 78], "kind": "commanddeclaration"}, {"full_name": "aux", "code": "private theorem aux {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (\u03c6 : \u03b1 \u2243\u209c \u03b2)\n    (s : Set \u03b2) : (interior s).Nonempty \u2194 (interior (\u03c6 \u207b\u00b9' s)).Nonempty", "start": [333, 1], "end": [335, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.intrinsicInterior", "code": "protected theorem Set.Nonempty.intrinsicInterior (hscv : Convex \u211d s) (hsne : s.Nonempty) :\n    (intrinsicInterior \u211d s).Nonempty", "start": [339, 1], "end": [351, 75], "kind": "commanddeclaration"}, {"full_name": "intrinsicInterior_nonempty", "code": "theorem intrinsicInterior_nonempty (hs : Convex \u211d s) :\n    (intrinsicInterior \u211d s).Nonempty \u2194 s.Nonempty", "start": [354, 1], "end": [357, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/LongNames.lean", "imports": ["Mathlib/Lean/Name.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "printNameHashMap", "code": "def printNameHashMap (h : Std.HashMap Name (Array Name)) : IO Unit :=\n  for (m, names) in h.toList do\n    IO.println \"    IO.println $ m.toString ++ \":\"\n    for n in names do\n      IO.println n", "start": [17, 1], "end": [23, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/WithTerminal.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.WithTerminal", "code": "inductive WithTerminal : Type u\n  | of : C \u2192 WithTerminal\n  | star : WithTerminal\n  deriving Inhabited", "start": [44, 1], "end": [48, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial", "code": "inductive WithInitial : Type u\n  | of : C \u2192 WithInitial\n  | star : WithInitial\n  deriving Inhabited", "start": [53, 1], "end": [57, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.Hom", "code": "@[simp]\ndef Hom : WithTerminal C \u2192 WithTerminal C \u2192 Type v\n  | of X, of Y => X \u27f6 Y\n  | star, of _ => PEmpty\n  | _, star => PUnit", "start": [66, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.id", "code": "@[simp]\ndef id : \u2200 X : WithTerminal C, Hom X X\n  | of _ => \ud835\udfd9 _\n  | star => PUnit.unit", "start": [75, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.comp", "code": "@[simp]\ndef comp : \u2200 {X Y Z : WithTerminal C}, Hom X Y \u2192 Hom Y Z \u2192 Hom X Z\n  | of _X, of _Y, of _Z => fun f g => f \u226b g\n  | of _X, _, star => fun _f _g => PUnit.unit\n  | star, of _X, _ => fun f _g => PEmpty.elim f\n  | _, star, of _Y => fun _f g => PEmpty.elim g\n  | star, star, star => fun _ _ => PUnit.unit", "start": [82, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.down", "code": "def down {X Y : C} (f : of X \u27f6 of Y) : X \u27f6 Y := f", "start": [106, 1], "end": [107, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.down_id", "code": "@[simp] lemma down_id {X : C} : down (\ud835\udfd9 (of X)) = \ud835\udfd9 X := rfl", "start": [109, 1], "end": [109, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithTerminal.down_comp", "code": "@[simp] lemma down_comp {X Y Z : C} (f : of X \u27f6 of Y) (g : of Y \u27f6 of Z) :\n    down (f \u226b g) = down f \u226b down g :=\n  rfl", "start": [110, 1], "end": [112, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithTerminal.false_of_from_star", "code": "@[aesop safe destruct (rule_sets [CategoryTheory])]\nlemma false_of_from_star {X : C} (f : star \u27f6 of X) : False := (f : PEmpty).elim", "start": [114, 1], "end": [115, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithTerminal.incl", "code": "def incl : C \u2964 WithTerminal C where\n  obj := of\n  map f := f", "start": [117, 1], "end": [120, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.map", "code": "def map {D : Type*} [Category D] (F : C \u2964 D) : WithTerminal C \u2964 WithTerminal D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of x, of y, f => F.map (down f)\n    | of _, star, _ => PUnit.unit\n    | star, star, _ => PUnit.unit", "start": [128, 1], "end": [138, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.starTerminal", "code": "def starTerminal : Limits.IsTerminal (star : WithTerminal C) :=\n  Limits.IsTerminal.ofUnique _", "start": [148, 1], "end": [150, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.lift", "code": "@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, F.obj x \u27f6 Z)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) : WithTerminal C \u2964 D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of x, of y, f => F.map (down f)\n    | of x, star, _ => M x\n    | star, star, _ => \ud835\udfd9 Z", "start": [153, 1], "end": [165, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.inclLift", "code": "@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, F.obj x \u27f6 Z)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) : incl \u22d9 lift F M hM \u2245 F where\n  hom := { app := fun X => \ud835\udfd9 _ }\n  inv := { app := fun X => \ud835\udfd9 _ }", "start": [168, 1], "end": [173, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.liftStar", "code": "@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, F.obj x \u27f6 Z)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) : (lift F M hM).obj star \u2245 Z :=\n  eqToIso rfl", "start": [176, 1], "end": [180, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.lift_map_liftStar", "code": "theorem lift_map_liftStar {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, F.obj x \u27f6 Z)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x) (x : C) :\n    (lift F M hM).map (starTerminal.from (incl.obj x)) \u226b (liftStar F M hM).hom =\n      (inclLift F M hM).hom.app x \u226b M x", "start": [183, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.liftUnique", "code": "@[simp]\ndef liftUnique {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, F.obj x \u27f6 Z)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), F.map f \u226b M y = M x)\n    (G : WithTerminal C \u2964 D) (h : incl \u22d9 G \u2245 F)\n    (hG : G.obj star \u2245 Z)\n    (hh : \u2200 x : C, G.map (starTerminal.from (incl.obj x)) \u226b hG.hom = h.hom.app x \u226b M x) :\n    G \u2245 lift F M hM :=\n  NatIso.ofComponents\n    (fun X =>\n      match X with\n      | of x => h.app x\n      | star => hG)\n    (by\n      rintro (X | X) (Y | Y) f\n      \u00b7 apply h.hom.naturality\n      \u00b7 cases f\n        exact hh _\n      \u00b7 cases f\n      \u00b7 cases f\n        change G.map (\ud835\udfd9 _) \u226b hG.hom = hG.hom \u226b \ud835\udfd9 _\n        simp)", "start": [191, 1], "end": [212, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.liftToTerminal", "code": "@[simps!]\ndef liftToTerminal {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsTerminal Z) :\n    WithTerminal C \u2964 D :=\n  lift F (fun _x => hZ.from _) fun _x _y _f => hZ.hom_ext _ _", "start": [215, 1], "end": [219, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.inclLiftToTerminal", "code": "@[simps!]\ndef inclLiftToTerminal {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsTerminal Z) :\n    incl \u22d9 liftToTerminal F hZ \u2245 F :=\n  inclLift _ _ _", "start": [222, 1], "end": [226, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.liftToTerminalUnique", "code": "@[simps!]\ndef liftToTerminalUnique {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsTerminal Z)\n    (G : WithTerminal C \u2964 D) (h : incl \u22d9 G \u2245 F) (hG : G.obj star \u2245 Z) : G \u2245 liftToTerminal F hZ :=\n  liftUnique F (fun _z => hZ.from _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x =>\n    hZ.hom_ext _ _", "start": [229, 1], "end": [234, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.homFrom", "code": "@[simp]\ndef homFrom (X : C) : incl.obj X \u27f6 star :=\n  starTerminal.from _", "start": [237, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithTerminal.isIso_of_from_star", "code": "instance isIso_of_from_star {X : WithTerminal C} (f : star \u27f6 X) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => \u27e8f, rfl, rfl\u27e9", "start": [243, 1], "end": [246, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.Hom", "code": "@[simp]\ndef Hom : WithInitial C \u2192 WithInitial C \u2192 Type v\n  | of X, of Y => X \u27f6 Y\n  | of _, _ => PEmpty\n  | star, _ => PUnit", "start": [255, 1], "end": [261, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.id", "code": "@[simp]\ndef id : \u2200 X : WithInitial C, Hom X X\n  | of _ => \ud835\udfd9 _\n  | star => PUnit.unit", "start": [264, 1], "end": [268, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.comp", "code": "@[simp]\ndef comp : \u2200 {X Y Z : WithInitial C}, Hom X Y \u2192 Hom Y Z \u2192 Hom X Z\n  | of _X, of _Y, of _Z => fun f g => f \u226b g\n  | star, _, of _X => fun _f _g => PUnit.unit\n  | _, of _X, star => fun _f g => PEmpty.elim g\n  | of _Y, star, _ => fun f _g => PEmpty.elim f\n  | star, star, star => fun _ _ => PUnit.unit", "start": [271, 1], "end": [278, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.down", "code": "def down {X Y : C} (f : of X \u27f6 of Y) : X \u27f6 Y := f", "start": [293, 1], "end": [294, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.down_id", "code": "@[simp] lemma down_id {X : C} : down (\ud835\udfd9 (of X)) = \ud835\udfd9 X := rfl", "start": [296, 1], "end": [296, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithInitial.down_comp", "code": "@[simp] lemma down_comp {X Y Z : C} (f : of X \u27f6 of Y) (g : of Y \u27f6 of Z) :\n    down (f \u226b g) = down f \u226b down g :=\n  rfl", "start": [297, 1], "end": [299, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithInitial.false_of_to_star", "code": "@[aesop safe destruct (rule_sets [CategoryTheory])]\nlemma false_of_to_star {X : C} (f : of X \u27f6 star) : False := (f : PEmpty).elim", "start": [301, 1], "end": [302, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.WithInitial.incl", "code": "def incl : C \u2964 WithInitial C where\n  obj := of\n  map f := f", "start": [304, 1], "end": [307, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.map", "code": "def map {D : Type*} [Category D] (F : C \u2964 D) : WithInitial C \u2964 WithInitial D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of x, of y, f => F.map (down f)\n    | star, of _, _ => PUnit.unit\n    | star, star, _ => PUnit.unit", "start": [315, 1], "end": [325, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.starInitial", "code": "def starInitial : Limits.IsInitial (star : WithInitial C) :=\n  Limits.IsInitial.ofUnique _", "start": [336, 1], "end": [338, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.lift", "code": "@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, Z \u27f6 F.obj x)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), M x \u226b F.map f = M y) : WithInitial C \u2964 D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of x, of y, f => F.map (down f)\n    | star, of x, _ => M _\n    | star, star, _ => \ud835\udfd9 _", "start": [341, 1], "end": [353, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.inclLift", "code": "@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, Z \u27f6 F.obj x)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), M x \u226b F.map f = M y) : incl \u22d9 lift F M hM \u2245 F where\n  hom := { app := fun X => \ud835\udfd9 _ }\n  inv := { app := fun X => \ud835\udfd9 _ }", "start": [356, 1], "end": [361, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.liftStar", "code": "@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, Z \u27f6 F.obj x)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), M x \u226b F.map f = M y) : (lift F M hM).obj star \u2245 Z :=\n  eqToIso rfl", "start": [364, 1], "end": [368, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.liftStar_lift_map", "code": "theorem liftStar_lift_map {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, Z \u27f6 F.obj x)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), M x \u226b F.map f = M y) (x : C) :\n    (liftStar F M hM).hom \u226b (lift F M hM).map (starInitial.to (incl.obj x)) =\n      M x \u226b (inclLift F M hM).hom.app x", "start": [371, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.liftUnique", "code": "@[simp]\ndef liftUnique {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (M : \u2200 x : C, Z \u27f6 F.obj x)\n    (hM : \u2200 (x y : C) (f : x \u27f6 y), M x \u226b F.map f = M y)\n    (G : WithInitial C \u2964 D) (h : incl \u22d9 G \u2245 F)\n    (hG : G.obj star \u2245 Z)\n    (hh : \u2200 x : C, hG.symm.hom \u226b G.map (starInitial.to (incl.obj x)) = M x \u226b h.symm.hom.app x) :\n    G \u2245 lift F M hM :=\n  NatIso.ofComponents\n    (fun X =>\n      match X with\n      | of x => h.app x\n      | star => hG)\n    (by\n      rintro (X | X) (Y | Y) f\n      \u00b7 apply h.hom.naturality\n      \u00b7 cases f\n      \u00b7 cases f\n        change G.map _ \u226b h.hom.app _ = hG.hom \u226b _\n        symm\n        erw [\u2190 Iso.eq_inv_comp, \u2190 Category.assoc, hh]\n        simp\n      \u00b7 cases f\n        change G.map (\ud835\udfd9 _) \u226b hG.hom = hG.hom \u226b \ud835\udfd9 _\n        simp)", "start": [379, 1], "end": [403, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.liftToInitial", "code": "@[simps!]\ndef liftToInitial {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsInitial Z) :\n    WithInitial C \u2964 D :=\n  lift F (fun _x => hZ.to _) fun _x _y _f => hZ.hom_ext _ _", "start": [406, 1], "end": [410, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.inclLiftToInitial", "code": "@[simps!]\ndef inclLiftToInitial {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsInitial Z) :\n    incl \u22d9 liftToInitial F hZ \u2245 F :=\n  inclLift _ _ _", "start": [413, 1], "end": [417, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.liftToInitialUnique", "code": "@[simps!]\ndef liftToInitialUnique {D : Type*} [Category D] {Z : D} (F : C \u2964 D) (hZ : Limits.IsInitial Z)\n    (G : WithInitial C \u2964 D) (h : incl \u22d9 G \u2245 F) (hG : G.obj star \u2245 Z) : G \u2245 liftToInitial F hZ :=\n  liftUnique F (fun _z => hZ.to _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x => hZ.hom_ext _ _", "start": [420, 1], "end": [424, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.homTo", "code": "@[simp]\ndef homTo (X : C) : star \u27f6 incl.obj X :=\n  starInitial.to _", "start": [427, 1], "end": [430, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.WithInitial.isIso_of_to_star", "code": "instance isIso_of_to_star {X : WithInitial C} (f : X \u27f6 star) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => \u27e8f, rfl, rfl\u27e9", "start": [434, 1], "end": [437, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Filtered/Small.lean", "imports": ["Mathlib/CategoryTheory/EssentiallySmall.lean", "Mathlib/CategoryTheory/Filtered/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsFiltered.FilteredClosure", "code": "inductive FilteredClosure : C \u2192 Prop\n  | base : (x : \u03b1) \u2192 FilteredClosure (f x)\n  | max : {j j' : C} \u2192 FilteredClosure j \u2192 FilteredClosure j' \u2192 FilteredClosure (max j j')\n  | coeq : {j j' : C} \u2192 FilteredClosure j \u2192 FilteredClosure j' \u2192 (f f' : j \u27f6 j') \u2192\n      FilteredClosure (coeq f f')", "start": [30, 1], "end": [36, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.FilteredClosureSmall.InductiveStep", "code": "private inductive InductiveStep (n : \u2115) (X : \u2200 (k : \u2115), k < n \u2192 \u03a3 t : Type (max v w), t \u2192 C) :\n    Type (max v w)\n  | max : {k k' : \u2115} \u2192 (hk : k < n) \u2192 (hk' : k' < n) \u2192 (X _ hk).1 \u2192 (X _ hk').1 \u2192 InductiveStep n X\n  | coeq : {k k' : \u2115} \u2192 (hk : k < n) \u2192 (hk' : k' < n) \u2192 (j : (X _ hk).1) \u2192 (j' : (X _ hk').1) \u2192\n      ((X _ hk).2 j \u27f6 (X _ hk').2 j') \u2192 ((X _ hk).2 j \u27f6 (X _ hk').2 j') \u2192 InductiveStep n X", "start": [61, 1], "end": [68, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.FilteredClosureSmall.inductiveStepRealization", "code": "private noncomputable def inductiveStepRealization (n : \u2115)\n    (X : \u2200 (k : \u2115), k < n \u2192 \u03a3 t : Type (max v w), t \u2192 C) : InductiveStep.{w} n X \u2192 C\n  | (InductiveStep.max hk hk' x y) => max ((X _ hk).2 x) ((X _ hk').2 y)\n  | (InductiveStep.coeq _ _ _ _ f g) => coeq f g", "start": [70, 1], "end": [75, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.FilteredClosureSmall.bundledAbstractFilteredClosure", "code": "private noncomputable def bundledAbstractFilteredClosure : \u2115 \u2192 \u03a3 t : Type (max v w), t \u2192 C :=\n  Nat.strongRec' fun n => match n with\n    | 0 => fun _ => \u27e8ULift.{v} \u03b1, f \u2218 ULift.down\u27e9\n    | (n + 1) => fun X => \u27e8InductiveStep.{w, v, u} (n + 1) X, inductiveStepRealization (n + 1) X\u27e9", "start": [77, 1], "end": [82, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.FilteredClosureSmall.AbstractFilteredClosure", "code": "private noncomputable def AbstractFilteredClosure : Type (max v w) :=\n  \u03a3 n, (bundledAbstractFilteredClosure f n).1", "start": [84, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.FilteredClosureSmall.abstractFilteredClosureRealization", "code": "private noncomputable def abstractFilteredClosureRealization : AbstractFilteredClosure f \u2192 C :=\n  fun x => (bundledAbstractFilteredClosure f x.1).2 x.2", "start": [88, 1], "end": [90, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.small_fullSubcategory_filteredClosure", "code": "theorem small_fullSubcategory_filteredClosure :\n    Small.{max v w} (FullSubcategory (FilteredClosure f))", "start": [94, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.SmallFilteredIntermediate", "code": "def SmallFilteredIntermediate : Type (max u\u2081 v) :=\n  SmallModel.{max u\u2081 v} (FullSubcategory (FilteredClosure F.obj))", "start": [125, 1], "end": [128, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.SmallFilteredIntermediate.factoring", "code": "noncomputable def factoring : D \u2964 SmallFilteredIntermediate F :=\n  FullSubcategory.lift _ F FilteredClosure.base \u22d9 (equivSmallModel _).functor", "start": [135, 1], "end": [138, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.SmallFilteredIntermediate.inclusion", "code": "noncomputable def inclusion : SmallFilteredIntermediate F \u2964 C :=\n  (equivSmallModel _).inverse \u22d9 fullSubcategoryInclusion _", "start": [140, 1], "end": [143, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsFiltered.SmallFilteredIntermediate.factoringCompInclusion", "code": "noncomputable def factoringCompInclusion : factoring F \u22d9 inclusion F \u2245 F :=\n  isoWhiskerLeft _ (isoWhiskerRight (Equivalence.unitIso _).symm _)", "start": [151, 1], "end": [154, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosure", "code": "inductive CofilteredClosure : C \u2192 Prop\n  | base : (x : \u03b1) \u2192 CofilteredClosure (f x)\n  | min : {j j' : C} \u2192 CofilteredClosure j \u2192 CofilteredClosure j' \u2192 CofilteredClosure (min j j')\n  | eq : {j j' : C} \u2192 CofilteredClosure j \u2192 CofilteredClosure j' \u2192 (f f' : j \u27f6 j') \u2192\n      CofilteredClosure (eq f f')", "start": [175, 1], "end": [181, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosureSmall.InductiveStep", "code": "private inductive InductiveStep (n : \u2115) (X : \u2200 (k : \u2115), k < n \u2192 \u03a3 t : Type (max v w), t \u2192 C) :\n    Type (max v w)\n  | min : {k k' : \u2115} \u2192 (hk : k < n) \u2192 (hk' : k' < n) \u2192 (X _ hk).1 \u2192 (X _ hk').1 \u2192 InductiveStep n X\n  | eq : {k k' : \u2115} \u2192 (hk : k < n) \u2192 (hk' : k' < n) \u2192 (j : (X _ hk).1) \u2192 (j' : (X _ hk').1) \u2192\n      ((X _ hk).2 j \u27f6 (X _ hk').2 j') \u2192 ((X _ hk).2 j \u27f6 (X _ hk').2 j') \u2192 InductiveStep n X", "start": [192, 1], "end": [198, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosureSmall.inductiveStepRealization", "code": "private noncomputable def inductiveStepRealization (n : \u2115)\n    (X : \u2200 (k : \u2115), k < n \u2192 \u03a3 t : Type (max v w), t \u2192 C) : InductiveStep.{w} n X \u2192 C\n  | (InductiveStep.min hk hk' x y) => min ((X _ hk).2 x) ((X _ hk').2 y)\n  | (InductiveStep.eq _ _ _ _ f g) => eq f g", "start": [200, 1], "end": [205, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosureSmall.bundledAbstractCofilteredClosure", "code": "private noncomputable def bundledAbstractCofilteredClosure : \u2115 \u2192 \u03a3 t : Type (max v w), t \u2192 C :=\n  Nat.strongRec' fun n => match n with\n    | 0 => fun _ => \u27e8ULift.{v} \u03b1, f \u2218 ULift.down\u27e9\n    | (n + 1) => fun X => \u27e8InductiveStep.{w, v, u} (n + 1) X, inductiveStepRealization (n + 1) X\u27e9", "start": [207, 1], "end": [212, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosureSmall.AbstractCofilteredClosure", "code": "private noncomputable def AbstractCofilteredClosure : Type (max v w) :=\n  \u03a3 n, (bundledAbstractCofilteredClosure f n).1", "start": [214, 1], "end": [217, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.CofilteredClosureSmall.abstractCofilteredClosureRealization", "code": "private noncomputable def abstractCofilteredClosureRealization : AbstractCofilteredClosure f \u2192 C :=\n  fun x => (bundledAbstractCofilteredClosure f x.1).2 x.2", "start": [219, 1], "end": [222, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.small_fullSubcategory_cofilteredClosure", "code": "theorem small_fullSubcategory_cofilteredClosure :\n    Small.{max v w} (FullSubcategory (CofilteredClosure f))", "start": [226, 1], "end": [244, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.SmallCofilteredIntermediate", "code": "def SmallCofilteredIntermediate : Type (max u\u2081 v) :=\n  SmallModel.{max u\u2081 v} (FullSubcategory (CofilteredClosure F.obj))", "start": [258, 1], "end": [261, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.factoring", "code": "noncomputable def factoring : D \u2964 SmallCofilteredIntermediate F :=\n  FullSubcategory.lift _ F CofilteredClosure.base \u22d9 (equivSmallModel _).functor", "start": [268, 1], "end": [271, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.inclusion", "code": "noncomputable def inclusion : SmallCofilteredIntermediate F \u2964 C :=\n  (equivSmallModel _).inverse \u22d9 fullSubcategoryInclusion _", "start": [273, 1], "end": [276, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCofiltered.SmallCofilteredIntermediate.factoringCompInclusion", "code": "noncomputable def factoringCompInclusion : factoring F \u22d9 inclusion F \u2245 F :=\n  isoWhiskerLeft _ (isoWhiskerRight (Equivalence.unitIso _).symm _)", "start": [284, 1], "end": [287, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CountableDenseLinearOrder.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Order/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.exists_between_finsets", "code": "theorem exists_between_finsets {\u03b1 : Type*} [LinearOrder \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1]\n    [NoMaxOrder \u03b1] [nonem : Nonempty \u03b1] (lo hi : Finset \u03b1) (lo_lt_hi : \u2200 x \u2208 lo, \u2200 y \u2208 hi, x < y) :\n    \u2203 m : \u03b1, (\u2200 x \u2208 lo, x < m) \u2227 \u2200 y \u2208 hi, m < y", "start": [40, 1], "end": [66, 82], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso", "code": "def PartialIso : Type _ :=\n  { f : Finset (\u03b1 \u00d7 \u03b2) //\n    \u2200 (p) (_ : p \u2208 f) (q) (_ : q \u2208 f),\n      cmp (Prod.fst p) (Prod.fst q) = cmp (Prod.snd p) (Prod.snd q) }", "start": [72, 1], "end": [78, 70], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.exists_across", "code": "theorem exists_across [DenselyOrdered \u03b2] [NoMinOrder \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2]\n    (f : PartialIso \u03b1 \u03b2) (a : \u03b1) :\n    \u2203 b : \u03b2, \u2200 p \u2208 f.val, cmp (Prod.fst p) a = cmp (Prod.snd p) b", "start": [89, 1], "end": [122, 35], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.comm", "code": "protected def comm : PartialIso \u03b1 \u03b2 \u2192 PartialIso \u03b2 \u03b1 :=\n  Subtype.map (Finset.image (Equiv.prodComm _ _)) fun f hf p hp q hq \u21a6\n    Eq.symm <|\n      hf ((Equiv.prodComm \u03b1 \u03b2).symm p)\n        (by\n          rw [\u2190 Finset.mem_coe, Finset.coe_image, Equiv.image_eq_preimage] at hp\n          rwa [\u2190 Finset.mem_coe])\n        ((Equiv.prodComm \u03b1 \u03b2).symm q)\n        (by\n          rw [\u2190 Finset.mem_coe, Finset.coe_image, Equiv.image_eq_preimage] at hq\n          rwa [\u2190 Finset.mem_coe])", "start": [125, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.definedAtLeft", "code": "def definedAtLeft [DenselyOrdered \u03b2] [NoMinOrder \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2] (a : \u03b1) :\n    Cofinal (PartialIso \u03b1 \u03b2) where\n  carrier := {f | \u2203 b : \u03b2, (a, b) \u2208 f.val}\n  mem_gt f := by\n    cases' exists_across f a with b a_b\n    refine\n      \u27e8\u27e8insert (a, b) f.val, fun p hp q hq \u21a6 ?_\u27e9, \u27e8b, Finset.mem_insert_self _ _\u27e9,\n        Finset.subset_insert _ _\u27e9\n    rw [Finset.mem_insert] at hp hq\n    rcases hp with (rfl | pf) <;> rcases hq with (rfl | qf)\n    \u00b7 simp only [cmp_self_eq_eq]\n    \u00b7 rw [cmp_eq_cmp_symm]\n      exact a_b _ qf\n    \u00b7 exact a_b _ pf\n    \u00b7 exact f.prop _ pf _ qf", "start": [141, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.definedAtRight", "code": "def definedAtRight [DenselyOrdered \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1] [Nonempty \u03b1] (b : \u03b2) :\n    Cofinal (PartialIso \u03b1 \u03b2) where\n  carrier := {f | \u2203 a, (a, b) \u2208 f.val}\n  mem_gt f := by\n    rcases (definedAtLeft \u03b1 b).mem_gt f.comm with \u27e8f', \u27e8a, ha\u27e9, hl\u27e9\n    refine' \u27e8f'.comm, \u27e8a, _\u27e9, _\u27e9\n    \u00b7 change (a, b) \u2208 f'.val.image _\n      rwa [\u2190 Finset.mem_coe, Finset.coe_image, Equiv.image_eq_preimage]\n    \u00b7 change _ \u2286 f'.val.image _\n      rwa [\u2190 Finset.coe_subset, Finset.coe_image, \u2190 Equiv.subset_image, \u2190 Finset.coe_image,\n        Finset.coe_subset]", "start": [162, 1], "end": [174, 27], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.funOfIdeal", "code": "def funOfIdeal [DenselyOrdered \u03b2] [NoMinOrder \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2] (a : \u03b1)\n    (I : Ideal (PartialIso \u03b1 \u03b2)) :\n    (\u2203 f, f \u2208 definedAtLeft \u03b2 a \u2227 f \u2208 I) \u2192 { b // \u2203 f \u2208 I, (a, b) \u2208 Subtype.val f } :=\n  Classical.indefiniteDescription _ \u2218 fun \u27e8f, \u27e8b, hb\u27e9, hf\u27e9 \u21a6 \u27e8b, f, hf, hb\u27e9", "start": [179, 1], "end": [184, 76], "kind": "commanddeclaration"}, {"full_name": "Order.PartialIso.invOfIdeal", "code": "def invOfIdeal [DenselyOrdered \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1] [Nonempty \u03b1] (b : \u03b2)\n    (I : Ideal (PartialIso \u03b1 \u03b2)) :\n    (\u2203 f, f \u2208 definedAtRight \u03b1 b \u2227 f \u2208 I) \u2192 { a // \u2203 f \u2208 I, (a, b) \u2208 Subtype.val f } :=\n  Classical.indefiniteDescription _ \u2218 fun \u27e8f, \u27e8a, ha\u27e9, hf\u27e9 \u21a6 \u27e8a, f, hf, ha\u27e9", "start": [187, 1], "end": [192, 76], "kind": "commanddeclaration"}, {"full_name": "Order.embedding_from_countable_to_dense", "code": "theorem embedding_from_countable_to_dense [Encodable \u03b1] [DenselyOrdered \u03b2] [Nontrivial \u03b2] :\n    Nonempty (\u03b1 \u21aao \u03b2)", "start": [201, 1], "end": [216, 81], "kind": "commanddeclaration"}, {"full_name": "Order.iso_of_countable_dense", "code": "theorem iso_of_countable_dense [Encodable \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] [NoMaxOrder \u03b1]\n    [Nonempty \u03b1] [Encodable \u03b2] [DenselyOrdered \u03b2] [NoMinOrder \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2] :\n    Nonempty (\u03b1 \u2243o \u03b2)", "start": [219, 1], "end": [232, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "Mathlib/LinearAlgebra/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineBasis.toMatrix", "code": "noncomputable def toMatrix {\u03b9' : Type*} (q : \u03b9' \u2192 P) : Matrix \u03b9' \u03b9 k :=\n  fun i j => b.coord j (q i)", "start": [35, 1], "end": [40, 29], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_apply", "code": "@[simp]\ntheorem toMatrix_apply {\u03b9' : Type*} (q : \u03b9' \u2192 P) (i : \u03b9') (j : \u03b9) :\n    b.toMatrix q i j = b.coord j (q i)", "start": [43, 1], "end": [45, 46], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_self", "code": "@[simp]\ntheorem toMatrix_self [DecidableEq \u03b9] : b.toMatrix b = (1 : Matrix \u03b9 \u03b9 k)", "start": [48, 1], "end": [51, 77], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_row_sum_one", "code": "theorem toMatrix_row_sum_one {\u03b9' : Type*} (q : \u03b9' \u2192 P) (i : \u03b9') : \u2211 j, b.toMatrix q i j = 1", "start": [56, 1], "end": [57, 7], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.affineIndependent_of_toMatrix_right_inv", "code": "theorem affineIndependent_of_toMatrix_right_inv [DecidableEq \u03b9'] (p : \u03b9' \u2192 P) {A : Matrix \u03b9 \u03b9' k}\n    (hA : b.toMatrix p * A = 1) : AffineIndependent k p", "start": [60, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.affineSpan_eq_top_of_toMatrix_left_inv", "code": "theorem affineSpan_eq_top_of_toMatrix_left_inv [DecidableEq \u03b9] [Nontrivial k] (p : \u03b9' \u2192 P)\n    {A : Matrix \u03b9 \u03b9' k} (hA : A * b.toMatrix p = 1) : affineSpan k (range p) = \u22a4", "start": [79, 1], "end": [103, 47], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_vecMul_coords", "code": "@[simp]\ntheorem toMatrix_vecMul_coords (x : P) : (b.toMatrix b\u2082).vecMul (b\u2082.coords x) = b.coords x", "start": [106, 1], "end": [115, 66], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_mul_toMatrix", "code": "theorem toMatrix_mul_toMatrix : b.toMatrix b\u2082 * b\u2082.toMatrix b = 1", "start": [120, 1], "end": [123, 77], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.isUnit_toMatrix", "code": "theorem isUnit_toMatrix : IsUnit (b.toMatrix b\u2082)", "start": [126, 1], "end": [130, 52], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.isUnit_toMatrix_iff", "code": "theorem isUnit_toMatrix_iff [Nontrivial k] (p : \u03b9 \u2192 P) :\n    IsUnit (b.toMatrix p) \u2194 AffineIndependent k p \u2227 affineSpan k (range p) = \u22a4", "start": [133, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.toMatrix_inv_vecMul_toMatrix", "code": "@[simp]\ntheorem toMatrix_inv_vecMul_toMatrix (x : P) :\n    (b.toMatrix b\u2082)\u207b\u00b9.vecMul (b.coords x) = b\u2082.coords x", "start": [153, 1], "end": [162, 23], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.det_smul_coords_eq_cramer_coords", "code": "theorem det_smul_coords_eq_cramer_coords (x : P) :\n    (b.toMatrix b\u2082).det \u2022 b\u2082.coords x = (b.toMatrix b\u2082)\u1d40.cramer (b.coords x)", "start": [165, 1], "end": [171, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Trails.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Walk.IsTrail.edgesFinset", "code": "@[reducible]\ndef IsTrail.edgesFinset {u v : V} {p : G.Walk u v} (h : p.IsTrail) : Finset (Sym2 V) :=\n  \u27e8p.edges, h.edges_nodup\u27e9", "start": [46, 1], "end": [49, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.even_countP_edges_iff", "code": "theorem IsTrail.even_countP_edges_iff {u v : V} {p : G.Walk u v} (ht : p.IsTrail) (x : V) :\n    Even (p.edges.countP fun e => x \u2208 e) \u2194 u \u2260 v \u2192 x \u2260 u \u2227 x \u2260 v", "start": [54, 1], "end": [82, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian", "code": "def IsEulerian {u v : V} (p : G.Walk u v) : Prop :=\n  \u2200 e, e \u2208 G.edgeSet \u2192 p.edges.count e = 1", "start": [85, 1], "end": [91, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.isTrail", "code": "theorem IsEulerian.isTrail {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail", "start": [94, 1], "end": [99, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.mem_edges_iff", "code": "theorem IsEulerian.mem_edges_iff {u v : V} {p : G.Walk u v} (h : p.IsEulerian) {e : Sym2 V} :\n    e \u2208 p.edges \u2194 e \u2208 G.edgeSet", "start": [102, 1], "end": [105, 76], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.fintypeEdgeSet", "code": "def IsEulerian.fintypeEdgeSet {u v : V} {p : G.Walk u v} (h : p.IsEulerian) :\n    Fintype G.edgeSet :=\n  Fintype.ofFinset h.isTrail.edgesFinset fun e => by\n    simp only [Finset.mem_mk, Multiset.mem_coe, h.mem_edges_iff]", "start": [108, 1], "end": [112, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.isEulerian_of_forall_mem", "code": "theorem IsTrail.isEulerian_of_forall_mem {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (hc : \u2200 e, e \u2208 G.edgeSet \u2192 e \u2208 p.edges) : p.IsEulerian", "start": [115, 1], "end": [117, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isEulerian_iff", "code": "theorem isEulerian_iff {u v : V} (p : G.Walk u v) :\n    p.IsEulerian \u2194 p.IsTrail \u2227 \u2200 e, e \u2208 G.edgeSet \u2192 e \u2208 p.edges", "start": [120, 1], "end": [126, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.edgesFinset_eq", "code": "theorem IsEulerian.edgesFinset_eq [Fintype G.edgeSet] {u v : V} {p : G.Walk u v}\n    (h : p.IsEulerian) : h.isTrail.edgesFinset = G.edgeFinset", "start": [129, 1], "end": [132, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.even_degree_iff", "code": "theorem IsEulerian.even_degree_iff {x u v : V} {p : G.Walk u v} (ht : p.IsEulerian) [Fintype V]\n    [DecidableRel G.Adj] : Even (G.degree x) \u2194 u \u2260 v \u2192 x \u2260 u \u2227 x \u2260 v", "start": [135, 1], "end": [143, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.card_filter_odd_degree", "code": "theorem IsEulerian.card_filter_odd_degree [Fintype V] [DecidableRel G.Adj] {u v : V}\n    {p : G.Walk u v} (ht : p.IsEulerian) {s}\n    (h : s = (Finset.univ : Finset V).filter fun v => Odd (G.degree v)) :\n    s.card = 0 \u2228 s.card = 2", "start": [146, 1], "end": [161, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsEulerian.card_odd_degree", "code": "theorem IsEulerian.card_odd_degree [Fintype V] [DecidableRel G.Adj] {u v : V} {p : G.Walk u v}\n    (ht : p.IsEulerian) : Fintype.card { v : V | Odd (G.degree v) } = 0 \u2228\n      Fintype.card { v : V | Odd (G.degree v) } = 2", "start": [164, 1], "end": [170, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/FreeGroup/NielsenSchreier.lean", "imports": ["Mathlib/Combinatorics/Quiver/ConnectedComponent.lean", "Mathlib/Combinatorics/Quiver/Arborescence.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "Mathlib/CategoryTheory/Action.lean"], "premises": [{"full_name": "IsFreeGroupoid.Generators", "code": "@[nolint unusedArguments]\ndef IsFreeGroupoid.Generators (G) [Groupoid G] :=\n  G", "start": [63, 1], "end": [69, 4], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid", "code": "class IsFreeGroupoid (G) [Groupoid.{v} G] where\n  quiverGenerators : Quiver.{v + 1} (IsFreeGroupoid.Generators G)\n  of : \u2200 {a b : IsFreeGroupoid.Generators G}, (a \u27f6 b) \u2192 ((show G from a) \u27f6 b)\n  unique_lift :\n    \u2200 {X : Type v} [Group X] (f : Labelling (IsFreeGroupoid.Generators G) X),\n      \u2203! F : G \u2964 CategoryTheory.SingleObj X, \u2200 (a b) (g : a \u27f6 b), F.map (of g) = f g", "start": [72, 1], "end": [85, 85], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.ext_functor", "code": "@[ext]\ntheorem ext_functor {G} [Groupoid.{v} G] [IsFreeGroupoid G] {X : Type v} [Group X]\n    (f g : G \u2964 CategoryTheory.SingleObj X) (h : \u2200 (a b) (e : a \u27f6 b), f.map (of e) = g.map (of e)) :\n    f = g", "start": [94, 1], "end": [101, 51], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.actionGroupoidIsFree", "code": "instance actionGroupoidIsFree {G A : Type u} [Group G] [IsFreeGroup G] [MulAction G A] :\n    IsFreeGroupoid (ActionCategory G A) where\n  quiverGenerators :=\n    \u27e8fun a b => { e : IsFreeGroup.Generators G // IsFreeGroup.of e \u2022 a.back = b.back }\u27e9\n  of := fun (e : { e // _}) => \u27e8IsFreeGroup.of e, e.property\u27e9\n  unique_lift := by\n    intro X _ f\n    let f' : IsFreeGroup.Generators G \u2192 (A \u2192 X) \u22ca[mulAutArrow] G := fun e =>\n      \u27e8fun b => @f \u27e8(), _\u27e9 \u27e8(), b\u27e9 \u27e8e, smul_inv_smul _ b\u27e9, IsFreeGroup.of e\u27e9\n    rcases IsFreeGroup.unique_lift f' with \u27e8F', hF', uF'\u27e9\n    refine' \u27e8uncurry F' _, _, _\u27e9\n    \u00b7 suffices SemidirectProduct.rightHom.comp F' = MonoidHom.id _ by\n        exact FunLike.ext_iff.mp this\n      ext\n      rw [MonoidHom.comp_apply, hF']\n      rfl\n    \u00b7 rintro \u27e8\u27e8\u27e9, a : A\u27e9 \u27e8\u27e8\u27e9, b\u27e9 \u27e8e, h : IsFreeGroup.of e \u2022 a = b\u27e9\n      change (F' (IsFreeGroup.of _)).left _ = _\n      rw [hF']\n      cases inv_smul_eq_iff.mpr h.symm\n      rfl\n    \u00b7 intro E hE\n      have : curry E = F' := by\n        apply uF'\n        intro e\n        ext\n        \u00b7 convert hE _ _ _\n          rfl\n        \u00b7 rfl\n      apply Functor.hext\n      \u00b7 intro\n        apply Unit.ext\n      \u00b7 refine' ActionCategory.cases _\n        intros\n        simp only [\u2190 this, uncurry_map, curry_apply_left, coe_back, homOfPair.val]\n        rfl", "start": [104, 1], "end": [146, 12], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.root'", "code": "private def root' : G :=\n  show T from root T", "start": [158, 1], "end": [160, 21], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.homOfPath", "code": "def homOfPath : \u2200 {a : G}, Path (root T) a \u2192 (root' T \u27f6 a)\n  | _, Path.nil => \ud835\udfd9 _\n  | _, Path.cons p f => homOfPath p \u226b Sum.recOn f.val (fun e => of e) fun e => inv (of e)", "start": [165, 1], "end": [169, 90], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.treeHom", "code": "def treeHom (a : G) : root' T \u27f6 a :=\n  homOfPath T default", "start": [172, 1], "end": [174, 22], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.treeHom_eq", "code": "theorem treeHom_eq {a : G} (p : Path (root T) a) : treeHom T a = homOfPath T p", "start": [177, 1], "end": [179, 34], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.treeHom_root", "code": "@[simp]\ntheorem treeHom_root : treeHom T (root' T) = \ud835\udfd9 _", "start": [182, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.loopOfHom", "code": "def loopOfHom {a b : G} (p : a \u27f6 b) : End (root' T) :=\n  treeHom T a \u226b p \u226b inv (treeHom T b)", "start": [189, 1], "end": [191, 38], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.loopOfHom_eq_id", "code": "theorem loopOfHom_eq_id {a b : Generators G} (e) (H : e \u2208 wideSubquiverSymmetrify T a b) :\n    loopOfHom T (of e) = \ud835\udfd9 (root' T)", "start": [194, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.functorOfMonoidHom", "code": "@[simps]\ndef functorOfMonoidHom {X} [Monoid X] (f : End (root' T) \u2192* X) : G \u2964 CategoryTheory.SingleObj X\n    where\n  obj _ := ()\n  map p := f (loopOfHom T p)\n  map_id := by\n    intro a\n    dsimp only [loopOfHom]\n    rw [Category.id_comp, IsIso.hom_inv_id, \u2190 End.one_def, f.map_one, id_as_one]\n  map_comp := by\n    intros\n    rw [comp_as_mul, \u2190 f.map_mul]\n    simp only [IsIso.inv_hom_id_assoc, loopOfHom, End.mul_def, Category.assoc]", "start": [205, 1], "end": [219, 79], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.SpanningTree.endIsFree", "code": "def endIsFree : IsFreeGroup (End (root' T)) :=\n  IsFreeGroup.ofUniqueLift ((wideSubquiverEquivSetTotal <| wideSubquiverSymmetrify T)\u1d9c : Set _)\n    (fun e => loopOfHom T (of e.val.hom))\n    (by\n      intro X _ f\n      let f' : Labelling (Generators G) X := fun a b e =>\n        if h : e \u2208 wideSubquiverSymmetrify T a b then 1 else f \u27e8\u27e8a, b, e\u27e9, h\u27e9\n      rcases unique_lift f' with \u27e8F', hF', uF'\u27e9\n      refine' \u27e8F'.mapEnd _, _, _\u27e9\n      \u00b7 suffices \u2200 {x y} (q : x \u27f6 y), F'.map (loopOfHom T q) = (F'.map q : X) by\n          rintro \u27e8\u27e8a, b, e\u27e9, h\u27e9\n          erw [Functor.mapEnd_apply, this, hF']\n          exact dif_neg h\n        intros x y q\n        suffices \u2200 {a} (p : Path (root T) a), F'.map (homOfPath T p) = 1 by\n          simp only [this, treeHom, comp_as_mul, inv_as_inv, loopOfHom, inv_one, mul_one,\n            one_mul, Functor.map_inv, Functor.map_comp]\n        intro a p\n        induction' p with b c p e ih\n        \u00b7 rw [homOfPath, F'.map_id, id_as_one]\n        rw [homOfPath, F'.map_comp, comp_as_mul, ih, mul_one]\n        rcases e with \u27e8e | e, eT\u27e9\n        \u00b7 rw [hF']\n          exact dif_pos (Or.inl eT)\n        \u00b7 rw [F'.map_inv, inv_as_inv, inv_eq_one, hF']\n          exact dif_pos (Or.inr eT)\n      \u00b7 intro E hE\n        ext x\n        suffices (functorOfMonoidHom T E).map x = F'.map x by\n          simpa only [loopOfHom, functorOfMonoidHom, IsIso.inv_id, treeHom_root,\n            Category.id_comp, Category.comp_id] using this\n        congr\n        apply uF'\n        intro a b e\n        change E (loopOfHom T _) = dite _ _ _\n        split_ifs with h\n        \u00b7 rw [loopOfHom_eq_id T e h, \u2190 End.one_def, E.map_one]\n        \u00b7 exact hE \u27e8\u27e8a, b, e\u27e9, h\u27e9)", "start": [222, 1], "end": [262, 35], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.symgen", "code": "private def symgen {G : Type u} [Groupoid.{v} G] [IsFreeGroupoid G] :\n    G \u2192 Symmetrify (Generators G) :=\n  id", "start": [267, 1], "end": [270, 5], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.path_nonempty_of_hom", "code": "theorem path_nonempty_of_hom {G} [Groupoid.{u, u} G] [IsFreeGroupoid G] {a b : G} :\n    Nonempty (a \u27f6 b) \u2192 Nonempty (Path (symgen a) (symgen b))", "start": [273, 1], "end": [288, 47], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.generators_connected", "code": "instance generators_connected (G) [Groupoid.{u, u} G] [IsConnected G] [IsFreeGroupoid G] (r : G) :\n    RootedConnected (symgen r) :=\n  \u27e8fun b => path_nonempty_of_hom (CategoryTheory.nonempty_hom_of_connected_groupoid r b)\u27e9", "start": [291, 1], "end": [294, 90], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroupoid.endIsFreeOfConnectedFree", "code": "instance endIsFreeOfConnectedFree {G} [Groupoid G] [IsConnected G] [IsFreeGroupoid G] (r : G) :\n    IsFreeGroup (End r) :=\n  SpanningTree.endIsFree <| geodesicSubtree (symgen r)", "start": [297, 1], "end": [301, 55], "kind": "commanddeclaration"}, {"full_name": "subgroupIsFreeOfIsFree", "code": "instance subgroupIsFreeOfIsFree {G : Type u} [Group G] [IsFreeGroup G] (H : Subgroup G) :\n    IsFreeGroup H :=\n  IsFreeGroup.ofMulEquiv (endMulEquivSubgroup H)", "start": [306, 1], "end": [309, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Const.lean", "imports": ["Mathlib/Control/Functor/Multivariate.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.Const", "code": "@[nolint unusedArguments]\ndef Const (A : Type*) (_v : TypeVec.{u} n) : Type _ := A", "start": [30, 1], "end": [32, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.inhabited", "code": "instance Const.inhabited {A \u03b1} [Inhabited A] : Inhabited (Const n A \u03b1) := \u27e8(default : A)\u27e9", "start": [35, 1], "end": [35, 90], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.mk", "code": "protected def mk (x : A) : Const n A \u03b1 := x", "start": [44, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.get", "code": "protected def get (x : Const n A \u03b1) : A := x", "start": [48, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.mk_get", "code": "@[simp]\nprotected theorem mk_get (x : Const n A \u03b1) : Const.mk (Const.get x) = x", "start": [52, 1], "end": [53, 79], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.get_mk", "code": "@[simp]\nprotected theorem get_mk (x : A) : Const.get (Const.mk x : Const n A \u03b1) = x", "start": [56, 1], "end": [57, 83], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.map", "code": "protected def map : Const n A \u03b1 \u2192 Const n A \u03b2 := fun x => x", "start": [60, 1], "end": [61, 60], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.MvFunctor", "code": "instance MvFunctor : MvFunctor (Const n A) where map _f := Const.map", "start": [64, 1], "end": [64, 69], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.map_mk", "code": "theorem map_mk (x : A) : f <$$> Const.mk x = Const.mk x", "start": [66, 1], "end": [66, 63], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.get_map", "code": "theorem get_map (x : (Const n A) \u03b1) : Const.get (f <$$> x) = Const.get x", "start": [69, 1], "end": [69, 80], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Const.mvqpf", "code": "instance mvqpf : @MvQPF _ (Const n A) MvQPF.Const.MvFunctor where\n  P := MvPFunctor.const n A\n  abs x := MvPFunctor.const.get x\n  repr x := MvPFunctor.const.mk n x\n  abs_repr := fun _ => const.get_mk _\n  abs_map := fun _ => const.get_map _", "start": [72, 1], "end": [77, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/OmegaLimit.lean", "imports": ["Mathlib/Dynamics/Flow.lean", "Mathlib/Tactic/Monotonicity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "omegaLimit", "code": "def omegaLimit [TopologicalSpace \u03b2] (f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Set \u03b2 :=\n  \u22c2 u \u2208 f, closure (image2 \u03d5 u s)", "start": [47, 1], "end": [50, 34], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_def", "code": "theorem omegaLimit_def : \u03c9 f \u03d5 s = \u22c2 u \u2208 f, closure (image2 \u03d5 u s)", "start": [71, 1], "end": [71, 74], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_subset_of_tendsto", "code": "theorem omegaLimit_subset_of_tendsto {m : \u03c4 \u2192 \u03c4} {f\u2081 f\u2082 : Filter \u03c4} (hf : Tendsto m f\u2081 f\u2082) :\n    \u03c9 f\u2081 (fun t x \u21a6 \u03d5 (m t) x) s \u2286 \u03c9 f\u2082 \u03d5 s", "start": [74, 1], "end": [78, 76], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_mono_left", "code": "theorem omegaLimit_mono_left {f\u2081 f\u2082 : Filter \u03c4} (hf : f\u2081 \u2264 f\u2082) : \u03c9 f\u2081 \u03d5 s \u2286 \u03c9 f\u2082 \u03d5 s", "start": [81, 1], "end": [82, 54], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_mono_right", "code": "theorem omegaLimit_mono_right {s\u2081 s\u2082 : Set \u03b1} (hs : s\u2081 \u2286 s\u2082) : \u03c9 f \u03d5 s\u2081 \u2286 \u03c9 f \u03d5 s\u2082", "start": [85, 1], "end": [86, 71], "kind": "commanddeclaration"}, {"full_name": "isClosed_omegaLimit", "code": "theorem isClosed_omegaLimit : IsClosed (\u03c9 f \u03d5 s)", "start": [89, 1], "end": [90, 70], "kind": "commanddeclaration"}, {"full_name": "mapsTo_omegaLimit'", "code": "theorem mapsTo_omegaLimit' {\u03b1' \u03b2' : Type*} [TopologicalSpace \u03b2'] {f : Filter \u03c4} {\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2}\n    {\u03d5' : \u03c4 \u2192 \u03b1' \u2192 \u03b2'} {ga : \u03b1 \u2192 \u03b1'} {s' : Set \u03b1'} (hs : MapsTo ga s s') {gb : \u03b2 \u2192 \u03b2'}\n    (hg : \u2200\u1da0 t in f, EqOn (gb \u2218 \u03d5 t) (\u03d5' t \u2218 ga) s) (hgc : Continuous gb) :\n    MapsTo gb (\u03c9 f \u03d5 s) (\u03c9 f \u03d5' s')", "start": [93, 1], "end": [102, 57], "kind": "commanddeclaration"}, {"full_name": "mapsTo_omegaLimit", "code": "theorem mapsTo_omegaLimit {\u03b1' \u03b2' : Type*} [TopologicalSpace \u03b2'] {f : Filter \u03c4} {\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2}\n    {\u03d5' : \u03c4 \u2192 \u03b1' \u2192 \u03b2'} {ga : \u03b1 \u2192 \u03b1'} {s' : Set \u03b1'} (hs : MapsTo ga s s') {gb : \u03b2 \u2192 \u03b2'}\n    (hg : \u2200 t x, gb (\u03d5 t x) = \u03d5' t (ga x)) (hgc : Continuous gb) :\n    MapsTo gb (\u03c9 f \u03d5 s) (\u03c9 f \u03d5' s')", "start": [105, 1], "end": [109, 74], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_image_eq", "code": "theorem omegaLimit_image_eq {\u03b1' : Type*} (\u03d5 : \u03c4 \u2192 \u03b1' \u2192 \u03b2) (f : Filter \u03c4) (g : \u03b1 \u2192 \u03b1') :\n    \u03c9 f \u03d5 (g '' s) = \u03c9 f (fun t x \u21a6 \u03d5 t (g x)) s", "start": [112, 1], "end": [113, 98], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_preimage_subset", "code": "theorem omegaLimit_preimage_subset {\u03b1' : Type*} (\u03d5 : \u03c4 \u2192 \u03b1' \u2192 \u03b2) (s : Set \u03b1') (f : Filter \u03c4)\n    (g : \u03b1 \u2192 \u03b1') : \u03c9 f (fun t x \u21a6 \u03d5 t (g x)) (g \u207b\u00b9' s) \u2286 \u03c9 f \u03d5 s", "start": [116, 1], "end": [118, 76], "kind": "commanddeclaration"}, {"full_name": "mem_omegaLimit_iff_frequently", "code": "theorem mem_omegaLimit_iff_frequently (y : \u03b2) :\n    y \u2208 \u03c9 f \u03d5 s \u2194 \u2200 n \u2208 \ud835\udcdd y, \u2203\u1da0 t in f, (s \u2229 \u03d5 t \u207b\u00b9' n).Nonempty", "start": [129, 1], "end": [141, 39], "kind": "commanddeclaration"}, {"full_name": "mem_omegaLimit_iff_frequently\u2082", "code": "theorem mem_omegaLimit_iff_frequently\u2082 (y : \u03b2) :\n    y \u2208 \u03c9 f \u03d5 s \u2194 \u2200 n \u2208 \ud835\udcdd y, \u2203\u1da0 t in f, (\u03d5 t '' s \u2229 n).Nonempty", "start": [144, 1], "end": [149, 68], "kind": "commanddeclaration"}, {"full_name": "mem_omegaLimit_singleton_iff_map_cluster_point", "code": "theorem mem_omegaLimit_singleton_iff_map_cluster_point (x : \u03b1) (y : \u03b2) :\n    y \u2208 \u03c9 f \u03d5 {x} \u2194 MapClusterPt y f fun t \u21a6 \u03d5 t x", "start": [152, 1], "end": [157, 100], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_inter", "code": "theorem omegaLimit_inter : \u03c9 f \u03d5 (s\u2081 \u2229 s\u2082) \u2286 \u03c9 f \u03d5 s\u2081 \u2229 \u03c9 f \u03d5 s\u2082", "start": [165, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_iInter", "code": "theorem omegaLimit_iInter (p : \u03b9 \u2192 Set \u03b1) : \u03c9 f \u03d5 (\u22c2 i, p i) \u2286 \u22c2 i, \u03c9 f \u03d5 (p i)", "start": [170, 1], "end": [171, 71], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_union", "code": "theorem omegaLimit_union : \u03c9 f \u03d5 (s\u2081 \u222a s\u2082) = \u03c9 f \u03d5 s\u2081 \u222a \u03c9 f \u03d5 s\u2082", "start": [174, 1], "end": [186, 61], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_iUnion", "code": "theorem omegaLimit_iUnion (p : \u03b9 \u2192 Set \u03b1) : \u22c3 i, \u03c9 f \u03d5 (p i) \u2286 \u03c9 f \u03d5 (\u22c3 i, p i)", "start": [189, 1], "end": [191, 62], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_eq_iInter", "code": "theorem omegaLimit_eq_iInter : \u03c9 f \u03d5 s = \u22c2 u : \u21a5f.sets, closure (image2 \u03d5 u s)", "start": [201, 1], "end": [202, 24], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_eq_biInter_inter", "code": "theorem omegaLimit_eq_biInter_inter {v : Set \u03c4} (hv : v \u2208 f) :\n    \u03c9 f \u03d5 s = \u22c2 u \u2208 f, closure (image2 \u03d5 (u \u2229 v) s)", "start": [205, 1], "end": [208, 97], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_eq_iInter_inter", "code": "theorem omegaLimit_eq_iInter_inter {v : Set \u03c4} (hv : v \u2208 f) :\n    \u03c9 f \u03d5 s = \u22c2 u : \u21a5f.sets, closure (image2 \u03d5 (u \u2229 v) s)", "start": [211, 1], "end": [214, 26], "kind": "commanddeclaration"}, {"full_name": "omegaLimit_subset_closure_fw_image", "code": "theorem omegaLimit_subset_closure_fw_image {u : Set \u03c4} (hu : u \u2208 f) :\n    \u03c9 f \u03d5 s \u2286 closure (image2 \u03d5 u s)", "start": [217, 1], "end": [222, 19], "kind": "commanddeclaration"}, {"full_name": "eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset'", "code": "theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set \u03b2}\n    (hc\u2081 : IsCompact c) (hc\u2082 : \u2203 v \u2208 f, closure (image2 \u03d5 v s) \u2286 c) {n : Set \u03b2} (hn\u2081 : IsOpen n)\n    (hn\u2082 : \u03c9 f \u03d5 s \u2286 n) : \u2203 u \u2208 f, closure (image2 \u03d5 u s) \u2286 n", "start": [230, 1], "end": [266, 21], "kind": "commanddeclaration"}, {"full_name": "eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset", "code": "theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space \u03b2]\n    {c : Set \u03b2} (hc\u2081 : IsCompact c) (hc\u2082 : \u2200\u1da0 t in f, MapsTo (\u03d5 t) s c) {n : Set \u03b2} (hn\u2081 : IsOpen n)\n    (hn\u2082 : \u03c9 f \u03d5 s \u2286 n) : \u2203 u \u2208 f, closure (image2 \u03d5 u s) \u2286 n", "start": [269, 1], "end": [277, 85], "kind": "commanddeclaration"}, {"full_name": "eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset", "code": "theorem eventually_mapsTo_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset [T2Space \u03b2]\n    {c : Set \u03b2} (hc\u2081 : IsCompact c) (hc\u2082 : \u2200\u1da0 t in f, MapsTo (\u03d5 t) s c) {n : Set \u03b2} (hn\u2081 : IsOpen n)\n    (hn\u2082 : \u03c9 f \u03d5 s \u2286 n) : \u2200\u1da0 t in f, MapsTo (\u03d5 t) s n", "start": [280, 1], "end": [287, 55], "kind": "commanddeclaration"}, {"full_name": "eventually_closure_subset_of_isOpen_of_omegaLimit_subset", "code": "theorem eventually_closure_subset_of_isOpen_of_omegaLimit_subset [CompactSpace \u03b2] {v : Set \u03b2}\n    (hv\u2081 : IsOpen v) (hv\u2082 : \u03c9 f \u03d5 s \u2286 v) : \u2203 u \u2208 f, closure (image2 \u03d5 u s) \u2286 v", "start": [290, 1], "end": [293, 59], "kind": "commanddeclaration"}, {"full_name": "eventually_mapsTo_of_isOpen_of_omegaLimit_subset", "code": "theorem eventually_mapsTo_of_isOpen_of_omegaLimit_subset [CompactSpace \u03b2] {v : Set \u03b2}\n    (hv\u2081 : IsOpen v) (hv\u2082 : \u03c9 f \u03d5 s \u2286 v) : \u2200\u1da0 t in f, MapsTo (\u03d5 t) s v", "start": [296, 1], "end": [300, 55], "kind": "commanddeclaration"}, {"full_name": "nonempty_omegaLimit_of_isCompact_absorbing", "code": "theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set \u03b2} (hc\u2081 : IsCompact c)\n    (hc\u2082 : \u2203 v \u2208 f, closure (image2 \u03d5 v s) \u2286 c) (hs : s.Nonempty) : (\u03c9 f \u03d5 s).Nonempty", "start": [303, 1], "end": [322, 35], "kind": "commanddeclaration"}, {"full_name": "nonempty_omegaLimit", "code": "theorem nonempty_omegaLimit [CompactSpace \u03b2] [NeBot f] (hs : s.Nonempty) : (\u03c9 f \u03d5 s).Nonempty", "start": [325, 1], "end": [326, 101], "kind": "commanddeclaration"}, {"full_name": "Flow.isInvariant_omegaLimit", "code": "theorem isInvariant_omegaLimit (hf : \u2200 t, Tendsto ((\u00b7 + \u00b7) t) f f) : IsInvariant \u03d5 (\u03c9 f \u03d5 s)", "start": [343, 1], "end": [347, 46], "kind": "commanddeclaration"}, {"full_name": "Flow.omegaLimit_image_subset", "code": "theorem omegaLimit_image_subset (t : \u03c4) (ht : Tendsto (\u00b7 + t) f f) :\n    \u03c9 f \u03d5 (\u03d5 t '' s) \u2286 \u03c9 f \u03d5 s", "start": [350, 1], "end": [353, 44], "kind": "commanddeclaration"}, {"full_name": "Flow.omegaLimit_image_eq", "code": "@[simp]\ntheorem omegaLimit_image_eq (hf : \u2200 t, Tendsto (\u00b7 + t) f f) (t : \u03c4) : \u03c9 f \u03d5 (\u03d5 t '' s) = \u03c9 f \u03d5 s", "start": [370, 1], "end": [376, 69], "kind": "commanddeclaration"}, {"full_name": "Flow.omegaLimit_omegaLimit", "code": "theorem omegaLimit_omegaLimit (hf : \u2200 t, Tendsto ((\u00b7 + \u00b7) t) f f) : \u03c9 f \u03d5 (\u03c9 f \u03d5 s) \u2286 \u03c9 f \u03d5 s", "start": [379, 1], "end": [395, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Eigenspace/IsAlgClosed.lean", "imports": ["Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.End.exists_eigenvalue", "code": "theorem exists_eigenvalue [IsAlgClosed K] [FiniteDimensional K V] [Nontrivial V] (f : End K V) :\n    \u2203 c : K, f.HasEigenvalue c", "start": [39, 1], "end": [44, 66], "kind": "commanddeclaration"}, {"full_name": "Module.End.iSup_generalizedEigenspace_eq_top", "code": "theorem iSup_generalizedEigenspace_eq_top [IsAlgClosed K] [FiniteDimensional K V] (f : End K V) :\n    \u2a06 (\u03bc : K) (k : \u2115), f.generalizedEigenspace \u03bc k = \u22a4", "start": [51, 1], "end": [111, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ZetaFunction.lean", "imports": ["Mathlib/NumberTheory/ModularForms/JacobiTheta/Basic.lean", "Mathlib/NumberTheory/ZetaValues.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "zetaKernel\u2081", "code": "def zetaKernel\u2081 (t : \u211d) : \u2102 :=\n  \u2211' n : \u2115, rexp (-\u03c0 * t * ((n : \u211d) + 1) ^ 2)", "start": [73, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "zetaKernel\u2082", "code": "def zetaKernel\u2082 : \u211d \u2192 \u2102 :=\n  zetaKernel\u2081 + indicator (Ioc 0 1) fun t => ((1 - 1 / sqrt t) / 2 : \u2102)", "start": [78, 1], "end": [80, 72], "kind": "commanddeclaration"}, {"full_name": "riemannCompletedZeta\u2080", "code": "def riemannCompletedZeta\u2080 (s : \u2102) : \u2102 :=\n  mellin zetaKernel\u2082 (s / 2)", "start": [83, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "riemannCompletedZeta", "code": "def riemannCompletedZeta (s : \u2102) : \u2102 :=\n  riemannCompletedZeta\u2080 s - 1 / s + 1 / (s - 1)", "start": [88, 1], "end": [91, 48], "kind": "commanddeclaration"}, {"full_name": "riemannZeta", "code": "irreducible_def riemannZeta :=\n  Function.update (fun s : \u2102 =>\n    (\u03c0 : \u2102) ^ (s / 2) * riemannCompletedZeta s / Gamma (s / 2)) 0 (-1 / 2)", "start": [94, 1], "end": [98, 75], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "riemannZeta_zero", "code": "theorem riemannZeta_zero : riemannZeta 0 = -1 / 2", "start": [103, 1], "end": [106, 35], "kind": "commanddeclaration"}, {"full_name": "summable_exp_neg_pi_mul_nat_sq", "code": "theorem summable_exp_neg_pi_mul_nat_sq {t : \u211d} (ht : 0 < t) :\n    Summable fun n : \u2115 => rexp (-\u03c0 * t * ((n : \u211d) + 1) ^ 2)", "start": [115, 1], "end": [124, 68], "kind": "commanddeclaration"}, {"full_name": "zetaKernel\u2081_eq_jacobiTheta", "code": "theorem zetaKernel\u2081_eq_jacobiTheta {t : \u211d} (ht : 0 < t) :\n    zetaKernel\u2081 t = (jacobiTheta (t * I) - 1) / 2", "start": [127, 1], "end": [137, 23], "kind": "commanddeclaration"}, {"full_name": "continuousAt_zetaKernel\u2081", "code": "theorem continuousAt_zetaKernel\u2081 {t : \u211d} (ht : 0 < t) : ContinuousAt zetaKernel\u2081 t", "start": [140, 1], "end": [148, 37], "kind": "commanddeclaration"}, {"full_name": "locally_integrable_zetaKernel\u2081", "code": "theorem locally_integrable_zetaKernel\u2081 : LocallyIntegrableOn zetaKernel\u2081 (Ioi 0)", "start": [151, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "locally_integrable_zetaKernel\u2082", "code": "theorem locally_integrable_zetaKernel\u2082 : LocallyIntegrableOn zetaKernel\u2082 (Ioi 0)", "start": [157, 1], "end": [173, 54], "kind": "commanddeclaration"}, {"full_name": "zetaKernel\u2082_one_div", "code": "theorem zetaKernel\u2082_one_div {t : \u211d} (ht : 0 < t) :\n    zetaKernel\u2082 (1 / t) = sqrt t * zetaKernel\u2082 t", "start": [176, 1], "end": [203, 27], "kind": "commanddeclaration"}, {"full_name": "isBigO_atTop_zetaKernel\u2081", "code": "theorem isBigO_atTop_zetaKernel\u2081 : IsBigO atTop zetaKernel\u2081 fun t => exp (-\u03c0 * t)", "start": [213, 1], "end": [225, 50], "kind": "commanddeclaration"}, {"full_name": "isBigO_atTop_zetaKernel\u2082", "code": "theorem isBigO_atTop_zetaKernel\u2082 : IsBigO atTop zetaKernel\u2082 fun t => exp (-\u03c0 * t)", "start": [229, 1], "end": [235, 14], "kind": "commanddeclaration"}, {"full_name": "isBigO_zero_zetaKernel\u2082", "code": "theorem isBigO_zero_zetaKernel\u2082 : IsBigO (\ud835\udcdd[>] 0) zetaKernel\u2082 fun t => exp (-\u03c0 / t) / sqrt t", "start": [239, 1], "end": [256, 67], "kind": "commanddeclaration"}, {"full_name": "isBigO_zero_zetaKernel\u2082_rpow", "code": "theorem isBigO_zero_zetaKernel\u2082_rpow (a : \u211d) : IsBigO (\ud835\udcdd[>] 0) zetaKernel\u2082 fun t => t ^ a", "start": [260, 1], "end": [272, 91], "kind": "commanddeclaration"}, {"full_name": "isBigO_zero_zetaKernel\u2081", "code": "theorem isBigO_zero_zetaKernel\u2081 : IsBigO (\ud835\udcdd[>] 0) zetaKernel\u2081 fun t => t ^ (-(1 / 2) : \u211d)", "start": [276, 1], "end": [296, 89], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_mellin_zetaKernel\u2081", "code": "theorem differentiableAt_mellin_zetaKernel\u2081 {s : \u2102} (hs : 1 / 2 < s.re) :\n    DifferentiableAt \u2102 (mellin zetaKernel\u2081) s", "start": [304, 1], "end": [308, 56], "kind": "commanddeclaration"}, {"full_name": "differentiable_mellin_zetaKernel\u2082", "code": "theorem differentiable_mellin_zetaKernel\u2082 : Differentiable \u2102 (mellin zetaKernel\u2082)", "start": [311, 1], "end": [314, 100], "kind": "commanddeclaration"}, {"full_name": "differentiable_completed_zeta\u2080", "code": "theorem differentiable_completed_zeta\u2080 : Differentiable \u2102 riemannCompletedZeta\u2080", "start": [317, 1], "end": [319, 88], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_completed_zeta", "code": "theorem differentiableAt_completed_zeta {s : \u2102} (hs : s \u2260 0) (hs' : s \u2260 1) :\n    DifferentiableAt \u2102 riemannCompletedZeta s", "start": [322, 1], "end": [329, 61], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_riemannZeta", "code": "theorem differentiableAt_riemannZeta {s : \u2102} (hs' : s \u2260 1) : DifferentiableAt \u2102 riemannZeta s", "start": [332, 1], "end": [405, 98], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_neg_two_mul_nat_add_one", "code": "theorem riemannZeta_neg_two_mul_nat_add_one (n : \u2115) : riemannZeta (-2 * (n + 1)) = 0", "start": [408, 1], "end": [414, 14], "kind": "commanddeclaration"}, {"full_name": "RiemannHypothesis", "code": "def RiemannHypothesis : Prop :=\n  \u2200 (s : \u2102) (_ : riemannCompletedZeta s = 0) (_ : \u00ac\u2203 n : \u2115, s = -2 * (n + 1)), s.re = 1 / 2", "start": [417, 1], "end": [420, 92], "kind": "commanddeclaration"}, {"full_name": "hasMellin_one_div_sqrt_Ioc", "code": "theorem hasMellin_one_div_sqrt_Ioc {s : \u2102} (hs : 1 / 2 < re s) :\n    HasMellin (indicator (Ioc 0 1) (fun t => 1 / \u2191(sqrt t) : \u211d \u2192 \u2102)) s (1 / (s - 1 / 2))", "start": [428, 1], "end": [437, 13], "kind": "commanddeclaration"}, {"full_name": "hasMellin_one_div_sqrt_sub_one_div_two_Ioc", "code": "theorem hasMellin_one_div_sqrt_sub_one_div_two_Ioc {s : \u2102} (hs : 1 / 2 < s.re) :\n    HasMellin ((Ioc 0 1).indicator fun t => (1 - 1 / (sqrt t : \u2102)) / 2) s\n      (1 / (2 * s) - 1 / (2 * s - 1))", "start": [440, 1], "end": [457, 74], "kind": "commanddeclaration"}, {"full_name": "mellin_zetaKernel\u2082_eq_of_lt_re", "code": "theorem mellin_zetaKernel\u2082_eq_of_lt_re {s : \u2102} (hs : 1 / 2 < s.re) :\n    mellin zetaKernel\u2082 s = mellin zetaKernel\u2081 s + 1 / (2 * s) - 1 / (2 * s - 1)", "start": [460, 1], "end": [466, 83], "kind": "commanddeclaration"}, {"full_name": "completed_zeta_eq_mellin_of_one_lt_re", "code": "theorem completed_zeta_eq_mellin_of_one_lt_re {s : \u2102} (hs : 1 < re s) :\n    riemannCompletedZeta s = mellin zetaKernel\u2081 (s / 2)", "start": [469, 1], "end": [479, 7], "kind": "commanddeclaration"}, {"full_name": "integral_cpow_mul_exp_neg_pi_mul_sq", "code": "theorem integral_cpow_mul_exp_neg_pi_mul_sq {s : \u2102} (hs : 0 < s.re) (n : \u2115) :\n    \u222b t : \u211d in Ioi 0, (t : \u2102) ^ (s - 1) * rexp (-\u03c0 * t * ((n : \u211d) + 1) ^ 2) =\n      (\u03c0 : \u2102) ^ (-s) * Complex.Gamma s * (1 / ((n : \u2102) + 1) ^ (2 * s))", "start": [487, 1], "end": [507, 7], "kind": "commanddeclaration"}, {"full_name": "mellin_zetaKernel\u2081_eq_tsum", "code": "theorem mellin_zetaKernel\u2081_eq_tsum {s : \u2102} (hs : 1 / 2 < s.re) :\n    mellin zetaKernel\u2081 s = (\u03c0 : \u2102) ^ (-s) * Gamma s * \u2211' n : \u2115, 1 / ((n : \u2102) + 1) ^ (2 * s)", "start": [510, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "completed_zeta_eq_tsum_of_one_lt_re", "code": "theorem completed_zeta_eq_tsum_of_one_lt_re {s : \u2102} (hs : 1 < re s) :\n    riemannCompletedZeta s =\n      (\u03c0 : \u2102) ^ (-s / 2) * Gamma (s / 2) * \u2211' n : \u2115, 1 / ((n : \u2102) + 1) ^ s", "start": [556, 1], "end": [562, 75], "kind": "commanddeclaration"}, {"full_name": "zeta_eq_tsum_one_div_nat_add_one_cpow", "code": "theorem zeta_eq_tsum_one_div_nat_add_one_cpow {s : \u2102} (hs : 1 < re s) :\n    riemannZeta s = \u2211' n : \u2115, 1 / ((n : \u2102) + 1) ^ s", "start": [565, 1], "end": [577, 28], "kind": "commanddeclaration"}, {"full_name": "zeta_eq_tsum_one_div_nat_cpow", "code": "theorem zeta_eq_tsum_one_div_nat_cpow {s : \u2102} (hs : 1 < re s) :\n    riemannZeta s = \u2211' n : \u2115, 1 / (n : \u2102) ^ s", "start": [580, 1], "end": [592, 15], "kind": "commanddeclaration"}, {"full_name": "zeta_nat_eq_tsum_of_gt_one", "code": "theorem zeta_nat_eq_tsum_of_gt_one {k : \u2115} (hk : 1 < k) :\n    riemannZeta k = \u2211' n : \u2115, 1 / (n : \u2102) ^ k", "start": [595, 1], "end": [601, 19], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_two_mul_nat", "code": "theorem riemannZeta_two_mul_nat {k : \u2115} (hk : k \u2260 0) :\n    riemannZeta (2 * k) = (-1 : \u2102) ^ (k + 1) * (2 : \u2102) ^ (2 * k - 1)\n      * (\u03c0 : \u2102) ^ (2 * k) * bernoulli (2 * k) / (2 * k)!", "start": [604, 1], "end": [619, 13], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_two", "code": "theorem riemannZeta_two : riemannZeta 2 = (\u03c0 : \u2102) ^ 2 / 6", "start": [622, 1], "end": [626, 13], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_four", "code": "theorem riemannZeta_four : riemannZeta 4 = \u03c0 ^ 4 / 90", "start": [629, 1], "end": [634, 13], "kind": "commanddeclaration"}, {"full_name": "riemannCompletedZeta\u2080_one_sub", "code": "theorem riemannCompletedZeta\u2080_one_sub (s : \u2102) :\n    riemannCompletedZeta\u2080 (1 - s) = riemannCompletedZeta\u2080 s", "start": [642, 1], "end": [655, 7], "kind": "commanddeclaration"}, {"full_name": "riemannCompletedZeta_one_sub", "code": "theorem riemannCompletedZeta_one_sub (s : \u2102) :\n    riemannCompletedZeta (1 - s) = riemannCompletedZeta s", "start": [658, 1], "end": [663, 56], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_one_sub", "code": "theorem riemannZeta_one_sub {s : \u2102} (hs : \u2200 n : \u2115, s \u2260 -n) (hs' : s \u2260 1) :\n    riemannZeta (1 - s) =\n      (2 : \u2102) ^ (1 - s) * (\u03c0 : \u2102) ^ (-s) * Gamma s * sin (\u03c0 * (1 - s) / 2) * riemannZeta s", "start": [666, 1], "end": [726, 7], "kind": "commanddeclaration"}, {"full_name": "riemannZeta_neg_nat_eq_bernoulli", "code": "theorem riemannZeta_neg_nat_eq_bernoulli (k : \u2115) :\n    riemannZeta (-k) = (-1 : \u2102) ^ k * bernoulli (k + 1) / (k + 1)", "start": [729, 1], "end": [800, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Category/MeasCat.lean", "imports": ["Mathlib/MeasureTheory/Measure/GiryMonad.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Monad/Algebra.lean", "Mathlib/CategoryTheory/ConcreteCategory/UnbundledHom.lean"], "premises": [{"full_name": "MeasCat", "code": "def MeasCat : Type (u + 1) :=\n  Bundled MeasurableSpace", "start": [42, 1], "end": [44, 26], "kind": "commanddeclaration"}, {"full_name": "MeasCat.of", "code": "def of (\u03b1 : Type u) [ms : MeasurableSpace \u03b1] : MeasCat :=\n  \u27e8\u03b1, ms\u27e9", "start": [55, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "MeasCat.coe_of", "code": "@[simp]\ntheorem coe_of (X : Type u) [MeasurableSpace X] : (of X : Type u) = X", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "MeasCat.unbundledHom", "code": "instance unbundledHom : UnbundledHom @Measurable :=\n  \u27e8@measurable_id, @Measurable.comp\u27e9", "start": [65, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "MeasCat.Measure", "code": "def Measure : MeasCat \u2964 MeasCat where\n  obj X := \u27e8@MeasureTheory.Measure X.1 X.2, inferInstance\u27e9\n  map f := \u27e8Measure.map (\u21d1f), Measure.measurable_map f.1 f.2\u27e9\n  map_id := fun \u27e8\u03b1, I\u27e9 => Subtype.eq <| funext fun \u03bc => @Measure.map_id \u03b1 I \u03bc\n  map_comp := fun \u27e8_, hf\u27e9 \u27e8_, hg\u27e9 => Subtype.eq <| funext fun _ => (Measure.map_map hg hf).symm", "start": [80, 1], "end": [93, 96], "kind": "commanddeclaration"}, {"full_name": "MeasCat.Giry", "code": "def Giry : CategoryTheory.Monad MeasCat where\n  toFunctor := Measure\n  \u03b7' :=\n    { app := fun X => \u27e8@Measure.dirac X.1 X.2, Measure.measurable_dirac\u27e9\n      naturality := fun _ _ \u27e8_, hf\u27e9 => Subtype.eq <| funext fun a => (Measure.map_dirac hf a).symm }\n  \u03bc' :=\n    { app := fun X => \u27e8@Measure.join X.1 X.2, Measure.measurable_join\u27e9\n      naturality := fun _ _ \u27e8_, hf\u27e9 => Subtype.eq <| funext fun \u03bc => Measure.join_map_map hf \u03bc }\n  assoc' _ := Subtype.eq <| funext fun _ => Measure.join_map_join _\n  left_unit' _ := Subtype.eq <| funext fun _ => Measure.join_dirac _\n  right_unit' _ := Subtype.eq <| funext fun _ => Measure.join_map_dirac _", "start": [96, 1], "end": [107, 74], "kind": "commanddeclaration"}, {"full_name": "MeasCat.Integral", "code": "def Integral : Giry.Algebra where\n  A := MeasCat.of \u211d\u22650\u221e\n  a := \u27e8fun m : MeasureTheory.Measure \u211d\u22650\u221e \u21a6 \u222b\u207b x, x \u2202m, Measure.measurable_lintegral measurable_id\u27e9\n  unit := Subtype.eq <| funext fun r : \u211d\u22650\u221e => lintegral_dirac' _ measurable_id\n  assoc := Subtype.eq <| funext fun \u03bc : MeasureTheory.Measure (MeasureTheory.Measure \u211d\u22650\u221e) =>\n    show \u222b\u207b x, x \u2202\u03bc.join = \u222b\u207b x, x \u2202Measure.map (fun m => \u222b\u207b x, x \u2202m) \u03bc by\n      rw [Measure.lintegral_join, lintegral_map] <;>\n        apply_rules [measurable_id, Measure.measurable_lintegral]", "start": [110, 1], "end": [119, 66], "kind": "commanddeclaration"}, {"full_name": "TopCat.hasForgetToMeasCat", "code": "instance TopCat.hasForgetToMeasCat : HasForget\u2082 TopCat.{u} MeasCat.{u} :=\n  BundledHom.mkHasForget\u2082 borel (fun f => \u27e8f.1, f.2.borel_measurable\u27e9) (fun _ => rfl)", "start": [124, 1], "end": [125, 86], "kind": "commanddeclaration"}, {"full_name": "Borel", "code": "@[reducible]\ndef Borel : TopCat.{u} \u2964 MeasCat.{u} :=\n  forget\u2082 TopCat.{u} MeasCat.{u}", "start": [128, 1], "end": [131, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/CommutingProbability.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "Mathlib/Algebra/Group/ConjFinite.lean", "Mathlib/Tactic/Qify.lean", "Mathlib/GroupTheory/Index.lean", "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Abelianization.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean"], "premises": [{"full_name": "commProb", "code": "def commProb : \u211a :=\n  Nat.card { p : M \u00d7 M // Commute p.1 p.2 } / (Nat.card M : \u211a) ^ 2", "start": [41, 1], "end": [43, 67], "kind": "commanddeclaration"}, {"full_name": "commProb_def", "code": "theorem commProb_def :\n    commProb M = Nat.card { p : M \u00d7 M // Commute p.1 p.2 } / (Nat.card M : \u211a) ^ 2", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "commProb_prod", "code": "theorem commProb_prod (M' : Type*) [Mul M'] : commProb (M \u00d7 M') = commProb M * commProb M'", "start": [51, 1], "end": [56, 101], "kind": "commanddeclaration"}, {"full_name": "commProb_pi", "code": "theorem commProb_pi (i : \u03b1 \u2192 Type*) [Fintype \u03b1] [\u2200 a, Mul (i a)] :\n    commProb (\u2200 a, i a) = \u220f a, commProb (i a)", "start": [58, 1], "end": [64, 72], "kind": "commanddeclaration"}, {"full_name": "commProb_function", "code": "theorem commProb_function [Fintype \u03b1] [Mul \u03b2] :\n    commProb (\u03b1 \u2192 \u03b2) = (commProb \u03b2) ^ Fintype.card \u03b1", "start": [66, 1], "end": [68, 56], "kind": "commanddeclaration"}, {"full_name": "commProb_eq_zero_of_infinite", "code": "@[simp]\ntheorem commProb_eq_zero_of_infinite [Infinite M] : commProb M = 0", "start": [70, 1], "end": [72, 79], "kind": "commanddeclaration"}, {"full_name": "commProb_pos", "code": "theorem commProb_pos [h : Nonempty M] : 0 < commProb M", "start": [76, 1], "end": [79, 53], "kind": "commanddeclaration"}, {"full_name": "commProb_le_one", "code": "theorem commProb_le_one : commProb M \u2264 1", "start": [82, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "commProb_eq_one_iff", "code": "theorem commProb_eq_one_iff [h : Nonempty M] :\n    commProb M = 1 \u2194 Commutative ((\u00b7 * \u00b7) : M \u2192 M \u2192 M)", "start": [90, 1], "end": [97, 60], "kind": "commanddeclaration"}, {"full_name": "commProb_def'", "code": "theorem commProb_def' : commProb G = Nat.card (ConjClasses G) / Nat.card G", "start": [102, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commProb_subgroup_le", "code": "theorem Subgroup.commProb_subgroup_le : commProb H \u2264 commProb G * (H.index : \u211a) ^ 2", "start": [112, 1], "end": [120, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commProb_quotient_le", "code": "theorem Subgroup.commProb_quotient_le [H.Normal] : commProb (G \u29f8 H) \u2264 commProb G * Nat.card H", "start": [123, 1], "end": [132, 43], "kind": "commanddeclaration"}, {"full_name": "inv_card_commutator_le_commProb", "code": "theorem inv_card_commutator_le_commProb : (\u2191(Nat.card (commutator G)))\u207b\u00b9 \u2264 commProb G", "start": [137, 1], "end": [140, 43], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.commProb_odd", "code": "lemma commProb_odd {n : \u2115} (hn : Odd n) :\n    commProb (DihedralGroup n) = (n + 3) / (4 * n) := by\n  rw [commProb_def', DihedralGroup.card_conjClasses_odd hn, nat_card]\n  qify [show 2 \u2223 n + 3 by rw [Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.odd_iff.mp hn]; rfl]\n  rw [div_div, \u2190 mul_assoc]\n  congr", "start": [146, 1], "end": [151, 8], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.div_two_lt", "code": "private lemma div_two_lt {n : \u2115} (h0 : n \u2260 0) : n / 2 < n :=\n  Nat.div_lt_self (Nat.pos_of_ne_zero h0) (lt_add_one 1)", "start": [153, 1], "end": [154, 57], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.div_four_lt", "code": "private lemma div_four_lt : {n : \u2115} \u2192 (h0 : n \u2260 0) \u2192 (h1 : n \u2260 1) \u2192 n / 4 + 1 < n\n  | 0 | 1 | 2 | 3 => by decide\n  | n + 4 => by intros; linarith [n.add_div_right four_pos, n.div_le_self 4]", "start": [156, 1], "end": [158, 77], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.reciprocalFactors", "code": "def reciprocalFactors (n : \u2115) : List \u2115 :=\n  if h0 : n = 0 then [0]\n  else if h1 : n = 1 then []\n  else if Even n then\n    3 :: reciprocalFactors (n / 2)\n  else\n    n % 4 * n :: reciprocalFactors (n / 4 + 1)\ndecreasing_by\n  simp_wf\n  first | exact div_two_lt h0 | exact div_four_lt h0 h1", "start": [160, 1], "end": [170, 56], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.reciprocalFactors_zero", "code": "@[simp] lemma reciprocalFactors_zero : reciprocalFactors 0 = [0] := rfl", "start": [172, 1], "end": [172, 72], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.reciprocalFactors_one", "code": "@[simp] lemma reciprocalFactors_one : reciprocalFactors 1 = [] := rfl", "start": [174, 1], "end": [174, 70], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.reciprocalFactors_even", "code": "lemma reciprocalFactors_even {n : \u2115} (h0 : n \u2260 0) (h2 : Even n) :\n    reciprocalFactors n = 3 :: reciprocalFactors (n / 2) := by\n  have h1 : n \u2260 1\n  \u00b7 rintro rfl\n    norm_num at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_pos h2]", "start": [176, 1], "end": [181, 60], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.reciprocalFactors_odd", "code": "lemma reciprocalFactors_odd {n : \u2115} (h1 : n \u2260 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n \u2260 0\n  \u00b7 rintro rfl\n    norm_num at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.odd_iff_not_even.mp h2)]", "start": [183, 1], "end": [188, 86], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.Product", "code": "abbrev Product (l : List \u2115) : Type :=\n  \u2200 i : Fin l.length, DihedralGroup l[i]", "start": [190, 1], "end": [192, 41], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.commProb_nil", "code": "lemma commProb_nil : commProb (Product []) = 1 := by\n  simp [Product, commProb_pi]", "start": [194, 1], "end": [195, 30], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.commProb_cons", "code": "lemma commProb_cons (n : \u2115) (l : List \u2115) :\n    commProb (Product (n :: l)) = commProb (DihedralGroup n) * commProb (Product l) := by\n  simp [Product, commProb_pi, Fin.prod_univ_succ]", "start": [197, 1], "end": [199, 50], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.commProb_reciprocal", "code": "theorem commProb_reciprocal (n : \u2115) :\n    commProb (Product (reciprocalFactors n)) = 1 / n", "start": [201, 1], "end": [225, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean", "imports": ["Mathlib/Algebra/QuaternionBasis.lean", "Mathlib/LinearAlgebra/QuadraticForm/Prod.lean", "Mathlib/Algebra/DualNumber.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "Mathlib/Data/Complex/Module.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Star.lean"], "premises": [{"full_name": "CliffordAlgebraRing.\u03b9_eq_zero", "code": "@[simp]\ntheorem \u03b9_eq_zero : \u03b9 (0 : QuadraticForm R Unit) = 0", "start": [74, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraRing.reverse_apply", "code": "theorem reverse_apply (x : CliffordAlgebra (0 : QuadraticForm R Unit)) :\n    reverse (R := R) x = x", "start": [90, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraRing.reverse_eq_id", "code": "@[simp]\ntheorem reverse_eq_id :\n    (reverse : CliffordAlgebra (0 : QuadraticForm R Unit) \u2192\u2097[R] _) = LinearMap.id", "start": [99, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraRing.involute_eq_id", "code": "@[simp]\ntheorem involute_eq_id :\n    (involute : CliffordAlgebra (0 : QuadraticForm R Unit) \u2192\u2090[R] _) = AlgHom.id R _", "start": [105, 1], "end": [107, 100], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraRing.equiv", "code": "protected def equiv : CliffordAlgebra (0 : QuadraticForm R Unit) \u2243\u2090[R] R :=\n  AlgEquiv.ofAlgHom\n    (CliffordAlgebra.lift (0 : QuadraticForm R Unit) <|\n      \u27e80, fun m : Unit => (zero_mul (0 : R)).trans (algebraMap R _).map_zero.symm\u27e9)\n    (Algebra.ofId R _) (by ext x; exact AlgHom.commutes _ x)\n    (by ext : 1; rw [\u03b9_eq_zero, LinearMap.comp_zero, LinearMap.comp_zero])", "start": [110, 1], "end": [116, 75], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.Q", "code": "def Q : QuadraticForm \u211d \u211d :=\n  -QuadraticForm.sq (R := \u211d)", "start": [128, 1], "end": [130, 29], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.Q_apply", "code": "@[simp]\ntheorem Q_apply (r : \u211d) : Q r = -(r * r)", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.toComplex", "code": "def toComplex : CliffordAlgebra Q \u2192\u2090[\u211d] \u2102 :=\n  CliffordAlgebra.lift Q\n    \u27e8LinearMap.toSpanSingleton _ _ Complex.I, fun r => by\n      dsimp [LinearMap.toSpanSingleton, LinearMap.id]\n      rw [mul_mul_mul_comm]\n      simp\u27e9", "start": [140, 1], "end": [147, 12], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.toComplex_\u03b9", "code": "@[simp]\ntheorem toComplex_\u03b9 (r : \u211d) : toComplex (\u03b9 Q r) = r \u2022 Complex.I", "start": [150, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.toComplex_involute", "code": "@[simp]\ntheorem toComplex_involute (c : CliffordAlgebra Q) :\n    toComplex (involute c) = conj (toComplex c)", "start": [155, 1], "end": [164, 13], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.ofComplex", "code": "def ofComplex : \u2102 \u2192\u2090[\u211d] CliffordAlgebra Q :=\n  Complex.lift\n    \u27e8CliffordAlgebra.\u03b9 Q 1, by\n      rw [CliffordAlgebra.\u03b9_sq_scalar, Q_apply, one_mul, RingHom.map_neg, RingHom.map_one]\u27e9", "start": [167, 1], "end": [172, 92], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.ofComplex_I", "code": "@[simp]\ntheorem ofComplex_I : ofComplex Complex.I = \u03b9 Q 1", "start": [175, 1], "end": [177, 38], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.toComplex_comp_ofComplex", "code": "@[simp]\ntheorem toComplex_comp_ofComplex : toComplex.comp ofComplex = AlgHom.id \u211d \u2102", "start": [181, 1], "end": [185, 42], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.toComplex_ofComplex", "code": "@[simp]\ntheorem toComplex_ofComplex (c : \u2102) : toComplex (ofComplex c) = c", "start": [188, 1], "end": [190, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.ofComplex_comp_toComplex", "code": "@[simp]\ntheorem ofComplex_comp_toComplex : ofComplex.comp toComplex = AlgHom.id \u211d (CliffordAlgebra Q)", "start": [193, 1], "end": [198, 42], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.ofComplex_toComplex", "code": "@[simp]\ntheorem ofComplex_toComplex (c : CliffordAlgebra Q) : ofComplex (toComplex c) = c", "start": [201, 1], "end": [203, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.equiv", "code": "@[simps!]\nprotected def equiv : CliffordAlgebra Q \u2243\u2090[\u211d] \u2102 :=\n  AlgEquiv.ofAlgHom toComplex ofComplex toComplex_comp_ofComplex ofComplex_comp_toComplex", "start": [206, 1], "end": [209, 90], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.reverse_apply", "code": "theorem reverse_apply (x : CliffordAlgebra Q) : reverse (R := \u211d) x = x", "start": [222, 1], "end": [228, 61], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.reverse_eq_id", "code": "@[simp]\ntheorem reverse_eq_id : (reverse : CliffordAlgebra Q \u2192\u2097[\u211d] _) = LinearMap.id", "start": [231, 1], "end": [233, 30], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraComplex.ofComplex_conj", "code": "@[simp]\ntheorem ofComplex_conj (c : \u2102) : ofComplex (conj c) = involute (ofComplex c)", "start": [236, 1], "end": [240, 96], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.Q", "code": "def Q : QuadraticForm R (R \u00d7 R) :=\n  (c\u2081 \u2022 QuadraticForm.sq (R := R)).prod (c\u2082 \u2022 QuadraticForm.sq)", "start": [259, 1], "end": [262, 64], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.Q_apply", "code": "@[simp]\ntheorem Q_apply (v : R \u00d7 R) : Q c\u2081 c\u2082 v = c\u2081 * (v.1 * v.1) + c\u2082 * (v.2 * v.2)", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.quaternionBasis", "code": "@[simps i j k]\ndef quaternionBasis : QuaternionAlgebra.Basis (CliffordAlgebra (Q c\u2081 c\u2082)) c\u2081 c\u2082 where\n  i := \u03b9 (Q c\u2081 c\u2082) (1, 0)\n  j := \u03b9 (Q c\u2081 c\u2082) (0, 1)\n  k := \u03b9 (Q c\u2081 c\u2082) (1, 0) * \u03b9 (Q c\u2081 c\u2082) (0, 1)\n  i_mul_i := by\n    rw [\u03b9_sq_scalar, Q_apply, \u2190 Algebra.algebraMap_eq_smul_one]\n    simp\n  j_mul_j := by\n    rw [\u03b9_sq_scalar, Q_apply, \u2190 Algebra.algebraMap_eq_smul_one]\n    simp\n  i_mul_j := rfl\n  j_mul_i := by\n    rw [eq_neg_iff_add_eq_zero, \u03b9_mul_\u03b9_add_swap, QuadraticForm.polar]\n    simp", "start": [272, 1], "end": [287, 9], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.toQuaternion", "code": "def toQuaternion : CliffordAlgebra (Q c\u2081 c\u2082) \u2192\u2090[R] \u210d[R,c\u2081,c\u2082] :=\n  CliffordAlgebra.lift (Q c\u2081 c\u2082)\n    \u27e8{  toFun := fun v => (\u27e80, v.1, v.2, 0\u27e9 : \u210d[R,c\u2081,c\u2082])\n        map_add' := fun v\u2081 v\u2082 => by simp\n        map_smul' := fun r v => by dsimp; rw [mul_zero]; rfl }, fun v => by\n      dsimp\n      ext\n      all_goals dsimp; ring\u27e9", "start": [292, 1], "end": [301, 29], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.toQuaternion_\u03b9", "code": "@[simp]\ntheorem toQuaternion_\u03b9 (v : R \u00d7 R) :\n    toQuaternion (\u03b9 (Q c\u2081 c\u2082) v) = (\u27e80, v.1, v.2, 0\u27e9 : \u210d[R,c\u2081,c\u2082])", "start": [304, 1], "end": [307, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.toQuaternion_star", "code": "theorem toQuaternion_star (c : CliffordAlgebra (Q c\u2081 c\u2082)) :\n    toQuaternion (star c) = star (toQuaternion c)", "start": [310, 1], "end": [322, 94], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.ofQuaternion", "code": "def ofQuaternion : \u210d[R,c\u2081,c\u2082] \u2192\u2090[R] CliffordAlgebra (Q c\u2081 c\u2082) :=\n  (quaternionBasis c\u2081 c\u2082).liftHom", "start": [325, 1], "end": [327, 34], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.ofQuaternion_mk", "code": "@[simp]\ntheorem ofQuaternion_mk (a\u2081 a\u2082 a\u2083 a\u2084 : R) :\n    ofQuaternion (\u27e8a\u2081, a\u2082, a\u2083, a\u2084\u27e9 : \u210d[R,c\u2081,c\u2082]) =\n      algebraMap R _ a\u2081 + a\u2082 \u2022 \u03b9 (Q c\u2081 c\u2082) (1, 0) + a\u2083 \u2022 \u03b9 (Q c\u2081 c\u2082) (0, 1) +\n        a\u2084 \u2022 (\u03b9 (Q c\u2081 c\u2082) (1, 0) * \u03b9 (Q c\u2081 c\u2082) (0, 1))", "start": [330, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.ofQuaternion_comp_toQuaternion", "code": "@[simp]\ntheorem ofQuaternion_comp_toQuaternion :\n    ofQuaternion.comp toQuaternion = AlgHom.id R (CliffordAlgebra (Q c\u2081 c\u2082))", "start": [338, 1], "end": [348, 90], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.ofQuaternion_toQuaternion", "code": "@[simp]\ntheorem ofQuaternion_toQuaternion (c : CliffordAlgebra (Q c\u2081 c\u2082)) :\n    ofQuaternion (toQuaternion c) = c", "start": [351, 1], "end": [354, 52], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.toQuaternion_comp_ofQuaternion", "code": "@[simp]\ntheorem toQuaternion_comp_ofQuaternion :\n    toQuaternion.comp ofQuaternion = AlgHom.id R \u210d[R,c\u2081,c\u2082]", "start": [357, 1], "end": [361, 57], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.toQuaternion_ofQuaternion", "code": "@[simp]\ntheorem toQuaternion_ofQuaternion (q : \u210d[R,c\u2081,c\u2082]) : toQuaternion (ofQuaternion q) = q", "start": [364, 1], "end": [366, 52], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.equiv", "code": "@[simps!]\nprotected def equiv : CliffordAlgebra (Q c\u2081 c\u2082) \u2243\u2090[R] \u210d[R,c\u2081,c\u2082] :=\n  AlgEquiv.ofAlgHom toQuaternion ofQuaternion toQuaternion_comp_ofQuaternion\n    ofQuaternion_comp_toQuaternion", "start": [369, 1], "end": [374, 35], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraQuaternion.ofQuaternion_star", "code": "@[simp]\ntheorem ofQuaternion_star (q : \u210d[R,c\u2081,c\u2082]) : ofQuaternion (star q) = star (ofQuaternion q)", "start": [377, 1], "end": [382, 33], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraDualNumber.\u03b9_mul_\u03b9", "code": "theorem \u03b9_mul_\u03b9 (r\u2081 r\u2082) : \u03b9 (0 : QuadraticForm R R) r\u2081 * \u03b9 (0 : QuadraticForm R R) r\u2082 = 0", "start": [401, 1], "end": [404, 15], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraDualNumber.equiv", "code": "protected def equiv : CliffordAlgebra (0 : QuadraticForm R R) \u2243\u2090[R] R[\u03b5] :=\n  AlgEquiv.ofAlgHom\n    (CliffordAlgebra.lift (0 : QuadraticForm R R) \u27e8inrHom R _, fun m => inr_mul_inr _ m m\u27e9)\n    (DualNumber.lift \u27e8\u03b9 (R := R) _ 1, \u03b9_mul_\u03b9 (1 : R) 1\u27e9)\n    (by ext : 1; simp; erw [lift_\u03b9_apply]; simp)\n    (by ext : 2; simp; erw [lift_\u03b9_apply]; simp)", "start": [407, 1], "end": [416, 49], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraDualNumber.equiv_\u03b9", "code": "@[simp]\ntheorem equiv_\u03b9 (r : R) : CliffordAlgebraDualNumber.equiv (\u03b9 (R := R) _ r) = r \u2022 \u03b5", "start": [419, 1], "end": [421, 49], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebraDualNumber.equiv_symm_eps", "code": "@[simp]\ntheorem equiv_symm_eps :\n    CliffordAlgebraDualNumber.equiv.symm (eps : R[\u03b5]) = \u03b9 (0 : QuadraticForm R R) 1", "start": [424, 1], "end": [428, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Instances/UnitsOfNormedAlgebra.lean", "imports": ["Mathlib/Analysis/NormedSpace/Units.lean", "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.chartAt_apply", "code": "theorem chartAt_apply {a : R\u02e3} {b : R\u02e3} : chartAt R a b = b", "start": [60, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Units.chartAt_source", "code": "theorem chartAt_source {a : R\u02e3} : (chartAt R a).source = Set.univ", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/TorusIntegral.lean", "imports": ["Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "Mathlib/MeasureTheory/Constructions/Prod/Integral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "torusMap", "code": "def torusMap (c : \u2102\u207f) (R : \u211d\u207f) : \u211d\u207f \u2192 \u2102\u207f := fun \u03b8 i => c i + R i * exp (\u03b8 i * I)", "start": [80, 1], "end": [83, 81], "kind": "commanddeclaration"}, {"full_name": "torusMap_sub_center", "code": "theorem torusMap_sub_center (c : \u2102\u207f) (R : \u211d\u207f) (\u03b8 : \u211d\u207f) : torusMap c R \u03b8 - c = torusMap 0 R \u03b8", "start": [86, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "torusMap_eq_center_iff", "code": "theorem torusMap_eq_center_iff {c : \u2102\u207f} {R : \u211d\u207f} {\u03b8 : \u211d\u207f} : torusMap c R \u03b8 = c \u2194 R = 0", "start": [90, 1], "end": [91, 43], "kind": "commanddeclaration"}, {"full_name": "torusMap_zero_radius", "code": "@[simp]\ntheorem torusMap_zero_radius (c : \u2102\u207f) : torusMap c 0 = const \u211d\u207f c", "start": [94, 1], "end": [96, 46], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable", "code": "def TorusIntegrable (f : \u2102\u207f \u2192 E) (c : \u2102\u207f) (R : \u211d\u207f) : Prop :=\n  IntegrableOn (fun \u03b8 : \u211d\u207f => f (torusMap c R \u03b8)) (Icc (0 : \u211d\u207f) fun _ => 2 * \u03c0) volume", "start": [103, 1], "end": [106, 87], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.torusIntegrable_const", "code": "theorem torusIntegrable_const (a : E) (c : \u2102\u207f) (R : \u211d\u207f) : TorusIntegrable (fun _ => a) c R", "start": [114, 1], "end": [116, 45], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.neg", "code": "protected nonrec theorem neg (hf : TorusIntegrable f c R) : TorusIntegrable (-f) c R", "start": [119, 1], "end": [120, 95], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.add", "code": "protected nonrec theorem add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f + g) c R", "start": [123, 1], "end": [126, 12], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.sub", "code": "protected nonrec theorem sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    TorusIntegrable (f - g) c R", "start": [129, 1], "end": [132, 12], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.torusIntegrable_zero_radius", "code": "theorem torusIntegrable_zero_radius {f : \u2102\u207f \u2192 E} {c : \u2102\u207f} : TorusIntegrable f c 0", "start": [135, 1], "end": [137, 40], "kind": "commanddeclaration"}, {"full_name": "TorusIntegrable.function_integrable", "code": "theorem function_integrable [NormedSpace \u2102 E] (hf : TorusIntegrable f c R) :\n    IntegrableOn (fun \u03b8 : \u211d\u207f => (\u220f i, R i * exp (\u03b8 i * I) * I : \u2102) \u2022 f (torusMap c R \u03b8))\n      (Icc (0 : \u211d\u207f) fun _ => 2 * \u03c0) volume", "start": [140, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "torusIntegral", "code": "def torusIntegral (f : \u2102\u207f \u2192 E) (c : \u2102\u207f) (R : \u211d\u207f) :=\n  \u222b \u03b8 : \u211d\u207f in Icc (0 : \u211d\u207f) fun _ => 2 * \u03c0, (\u220f i, R i * exp (\u03b8 i * I) * I : \u2102) \u2022 f (torusMap c R \u03b8)", "start": [153, 1], "end": [156, 99], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_radius_zero", "code": "theorem torusIntegral_radius_zero (hn : n \u2260 0) (f : \u2102\u207f \u2192 E) (c : \u2102\u207f) :\n    (\u222f x in T(c, 0), f x) = 0", "start": [161, 1], "end": [164, 46], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_neg", "code": "theorem torusIntegral_neg (f : \u2102\u207f \u2192 E) (c : \u2102\u207f) (R : \u211d\u207f) :\n    (\u222f x in T(c, R), -f x) = -\u222f x in T(c, R), f x", "start": [167, 1], "end": [168, 91], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_add", "code": "theorem torusIntegral_add (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (\u222f x in T(c, R), f x + g x) = (\u222f x in T(c, R), f x) + \u222f x in T(c, R), g x", "start": [171, 1], "end": [174, 63], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_sub", "code": "theorem torusIntegral_sub (hf : TorusIntegrable f c R) (hg : TorusIntegrable g c R) :\n    (\u222f x in T(c, R), f x - g x) = (\u222f x in T(c, R), f x) - \u222f x in T(c, R), g x", "start": [177, 1], "end": [179, 85], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_smul", "code": "theorem torusIntegral_smul {\ud835\udd5c : Type*} [IsROrC \ud835\udd5c] [NormedSpace \ud835\udd5c E] [SMulCommClass \ud835\udd5c \u2102 E] (a : \ud835\udd5c)\n    (f : \u2102\u207f \u2192 E) (c : \u2102\u207f) (R : \u211d\u207f) : (\u222f x in T(c, R), a \u2022 f x) = a \u2022 \u222f x in T(c, R), f x", "start": [182, 1], "end": [184, 74], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_const_mul", "code": "theorem torusIntegral_const_mul (a : \u2102) (f : \u2102\u207f \u2192 \u2102) (c : \u2102\u207f) (R : \u211d\u207f) :\n    (\u222f x in T(c, R), a * f x) = a * \u222f x in T(c, R), f x", "start": [187, 1], "end": [189, 29], "kind": "commanddeclaration"}, {"full_name": "norm_torusIntegral_le_of_norm_le_const", "code": "theorem norm_torusIntegral_le_of_norm_le_const {C : \u211d} (hf : \u2200 \u03b8, \u2016f (torusMap c R \u03b8)\u2016 \u2264 C) :\n    \u2016\u222f x in T(c, R), f x\u2016 \u2264 ((2 * \u03c0) ^ (n : \u2115) * \u220f i, |R i|) * C", "start": [192, 1], "end": [207, 65], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_dim0", "code": "@[simp]\ntheorem torusIntegral_dim0 (f : \u2102\u2070 \u2192 E) (c : \u2102\u2070) (R : \u211d\u2070) : (\u222f x in T(c, R), f x) = f c", "start": [210, 1], "end": [215, 88], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_dim1", "code": "theorem torusIntegral_dim1 (f : \u2102\u00b9 \u2192 E) (c : \u2102\u00b9) (R : \u211d\u00b9) :\n    (\u222f x in T(c, R), f x) = \u222e z in C(c 0, R 0), f fun _ => z", "start": [218, 1], "end": [231, 24], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_succAbove", "code": "theorem torusIntegral_succAbove {f : \u2102\u207f\u207a\u00b9 \u2192 E} {c : \u2102\u207f\u207a\u00b9} {R : \u211d\u207f\u207a\u00b9} (hf : TorusIntegrable f c R)\n    (i : Fin (n + 1)) :\n    (\u222f x in T(c, R), f x) =\n      \u222e x in C(c i, R i), \u222f y in T(c \u2218 i.succAbove, R \u2218 i.succAbove), f (i.insertNth x y)", "start": [234, 1], "end": [256, 78], "kind": "commanddeclaration"}, {"full_name": "torusIntegral_succ", "code": "theorem torusIntegral_succ {f : \u2102\u207f\u207a\u00b9 \u2192 E} {c : \u2102\u207f\u207a\u00b9} {R : \u211d\u207f\u207a\u00b9} (hf : TorusIntegrable f c R) :\n    (\u222f x in T(c, R), f x) =\n      \u222e x in C(c 0, R 0), \u222f y in T(c \u2218 Fin.succ, R \u2218 Fin.succ), f (Fin.cons x y)", "start": [259, 1], "end": [263, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Metric.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "Mathlib/Data/Nat/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.dist", "code": "noncomputable def dist (u v : V) : \u2115 :=\n  sInf (Set.range (Walk.length : G.Walk u v \u2192 \u2115))", "start": [47, 1], "end": [50, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.exists_walk_of_dist", "code": "protected theorem Reachable.exists_walk_of_dist {u v : V} (hr : G.Reachable u v) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v", "start": [55, 1], "end": [57, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.exists_walk_of_dist", "code": "protected theorem Connected.exists_walk_of_dist (hconn : G.Connected) (u v : V) :\n    \u2203 p : G.Walk u v, p.length = G.dist u v", "start": [60, 1], "end": [62, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_le", "code": "theorem dist_le {u v : V} (p : G.Walk u v) : G.dist u v \u2264 p.length", "start": [65, 1], "end": [66, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_eq_zero_iff_eq_or_not_reachable", "code": "@[simp]\ntheorem dist_eq_zero_iff_eq_or_not_reachable {u v : V} :\n    G.dist u v = 0 \u2194 u = v \u2228 \u00acG.Reachable u v", "start": [69, 1], "end": [71, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_self", "code": "theorem dist_self {v : V} : dist G v v = 0", "start": [74, 1], "end": [74, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.dist_eq_zero_iff", "code": "protected theorem Reachable.dist_eq_zero_iff {u v : V} (hr : G.Reachable u v) :\n    G.dist u v = 0 \u2194 u = v", "start": [77, 1], "end": [78, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.pos_dist_of_ne", "code": "protected theorem Reachable.pos_dist_of_ne {u v : V} (h : G.Reachable u v) (hne : u \u2260 v) :\n    0 < G.dist u v", "start": [81, 1], "end": [83, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.dist_eq_zero_iff", "code": "protected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) {u v : V} :\n    G.dist u v = 0 \u2194 u = v", "start": [86, 1], "end": [87, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.pos_dist_of_ne", "code": "protected theorem Connected.pos_dist_of_ne {u v : V} (hconn : G.Connected) (hne : u \u2260 v) :\n    0 < G.dist u v", "start": [90, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_eq_zero_of_not_reachable", "code": "theorem dist_eq_zero_of_not_reachable {u v : V} (h : \u00acG.Reachable u v) : G.dist u v = 0", "start": [95, 1], "end": [96, 11], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.nonempty_of_pos_dist", "code": "theorem nonempty_of_pos_dist {u v : V} (h : 0 < G.dist u v) :\n    (Set.univ : Set (G.Walk u v)).Nonempty", "start": [99, 1], "end": [102, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.dist_triangle", "code": "protected theorem Connected.dist_triangle (hconn : G.Connected) {u v w : V} :\n    G.dist u w \u2264 G.dist u v + G.dist v w", "start": [105, 1], "end": [110, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_comm_aux", "code": "private theorem dist_comm_aux {u v : V} (h : G.Reachable u v) : G.dist u v \u2264 G.dist v u", "start": [113, 1], "end": [116, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.dist_comm", "code": "theorem dist_comm {u v : V} : G.dist u v = G.dist v u", "start": [118, 1], "end": [122, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Girth.lean", "imports": ["Mathlib/Data/ENat/Lattice.lean", "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.girth", "code": "noncomputable def girth (G : SimpleGraph \u03b1) : \u2115\u221e :=\n\u2a05 a, \u2a05 w : G.Walk a a, \u2a05 _ : w.IsCycle, w.length", "start": [19, 1], "end": [22, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.le_girth", "code": "@[simp] lemma le_girth : n \u2264 G.girth \u2194 \u2200 a (w : G.Walk a a), w.IsCycle \u2192 n \u2264 w.length := by\n  simp [girth]", "start": [24, 1], "end": [25, 15], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.girth_eq_top", "code": "@[simp] lemma girth_eq_top : G.girth = \u22a4 \u2194 G.IsAcyclic := by simp [girth, IsAcyclic]", "start": [27, 1], "end": [27, 85], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.IsAcyclic.girth_eq_top", "code": "protected alias \u27e8_, IsAcyclic.girth_eq_top\u27e9 := girth_eq_top", "start": [29, 1], "end": [29, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.girth_anti", "code": "lemma girth_anti : Antitone (girth : SimpleGraph \u03b1 \u2192 \u2115\u221e) :=\n\u03bb G H h \u21a6 iInf_mono \u03bb a \u21a6 iInf\u2082_mono' \u03bb w hw \u21a6 \u27e8w.mapLe h, hw.mapLe _, by simp\u27e9", "start": [31, 1], "end": [32, 80], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.exists_girth_eq_length", "code": "lemma exists_girth_eq_length :\n    (\u2203 (a : \u03b1) (w : G.Walk a a), w.IsCycle \u2227 G.girth = w.length) \u2194 \u00ac G.IsAcyclic := by\n  refine' \u27e8_, \u03bb h \u21a6 _\u27e9\n  \u00b7 rintro \u27e8a, w, hw, _\u27e9 hG\n    exact hG _ hw\n  \u00b7 simp_rw [\u2190girth_eq_top, \u2190Ne.def, girth, iInf_subtype', iInf_sigma', ENat.iInf_coe_ne_top,\n      \u2190exists_prop, Subtype.exists', Sigma.exists', eq_comm] at h \u22a2\n    exact ciInf_mem _", "start": [34, 1], "end": [41, 22], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.girth_bot", "code": "@[simp] lemma girth_bot : girth (\u22a5 : SimpleGraph \u03b1) = \u22a4 := by simp", "start": [43, 1], "end": [43, 67], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Sheaves/LocallySurjective.lean", "imports": ["Mathlib/Topology/Sheaves/Presheaf.lean", "Mathlib/Topology/Sheaves/Stalks.lean", "Mathlib/CategoryTheory/Sites/Surjective.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.Presheaf.IsLocallySurjective", "code": "def IsLocallySurjective (T : \u2131 \u27f6 \ud835\udca2) :=\n  CategoryTheory.IsLocallySurjective (Opens.grothendieckTopology X) T", "start": [51, 1], "end": [58, 70], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.isLocallySurjective_iff", "code": "theorem isLocallySurjective_iff (T : \u2131 \u27f6 \ud835\udca2) :\n    IsLocallySurjective T \u2194\n      \u2200 (U t), \u2200 x \u2208 U, \u2203 (V : _) (\u03b9 : V \u27f6 U), (\u2203 s, T.app _ s = t |_\u2095 \u03b9) \u2227 x \u2208 V", "start": [62, 1], "end": [65, 10], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks", "code": "theorem locally_surjective_iff_surjective_on_stalks (T : \u2131 \u27f6 \ud835\udca2) :\n    IsLocallySurjective T \u2194 \u2200 x : X, Function.Surjective ((stalkFunctor C x).map T)", "start": [73, 1], "end": [114, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Cone/Pointed.lean", "imports": ["Mathlib/Algebra/Module/Submodule/Basic.lean", "Mathlib/Algebra/Order/Nonneg/Module.lean", "Mathlib/Analysis/Convex/Cone/Dual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PointedCone", "code": "abbrev PointedCone (\ud835\udd5c E) [OrderedSemiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] :=\n  Submodule {c : \ud835\udd5c // 0 \u2264 c} E", "start": [29, 1], "end": [31, 31], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone", "code": "@[coe]\ndef toConvexCone (S : PointedCone \ud835\udd5c E) : ConvexCone \ud835\udd5c E where\n  carrier := S\n  smul_mem' c hc _ hx := S.smul_mem \u27e8c, le_of_lt hc\u27e9 hx\n  add_mem' _ hx _ hy := S.add_mem hx hy", "start": [42, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone_injective", "code": "theorem toConvexCone_injective : Injective ((\u2191) : PointedCone \ud835\udd5c E \u2192 ConvexCone \ud835\udd5c E)", "start": [52, 1], "end": [53, 36], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone_pointed", "code": "@[simp]\ntheorem toConvexCone_pointed (S : PointedCone \ud835\udd5c E) : (S : ConvexCone \ud835\udd5c E).Pointed", "start": [55, 1], "end": [57, 42], "kind": "commanddeclaration"}, {"full_name": "PointedCone.ext", "code": "@[ext]\ntheorem ext {S T : PointedCone \ud835\udd5c E} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [59, 1], "end": [61, 16], "kind": "commanddeclaration"}, {"full_name": "PointedCone.instZero", "code": "instance instZero (S : PointedCone \ud835\udd5c E) : Zero S :=\n  \u27e80, S.zero_mem\u27e9", "start": [63, 1], "end": [64, 18], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.toPointedCone", "code": "def _root_.ConvexCone.toPointedCone {S : ConvexCone \ud835\udd5c E} (hS : S.Pointed) : PointedCone \ud835\udd5c E where\n  carrier := S\n  add_mem' hx hy := S.add_mem hx hy\n  zero_mem' := hS\n  smul_mem' := fun \u27e8c, hc\u27e9 x hx => by\n    simp_rw [SetLike.mem_coe]\n    cases' eq_or_lt_of_le hc with hzero hpos\n    \u00b7 unfold ConvexCone.Pointed at hS\n      convert hS\n      simp [\u2190 hzero]\n    \u00b7 apply ConvexCone.smul_mem\n      convert hpos\n      exact hx", "start": [66, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.mem_toPointedCone", "code": "@[simp]\nlemma _root_.ConvexCone.mem_toPointedCone {S : ConvexCone \ud835\udd5c E} (hS : S.Pointed) (x : E) :\n    x \u2208 S.toPointedCone hS \u2194 x \u2208 S :=\n  Iff.rfl", "start": [81, 1], "end": [84, 10], "kind": "mathlibtacticlemma"}, {"full_name": "ConvexCone.coe_toPointedCone", "code": "@[simp, norm_cast]\nlemma _root_.ConvexCone.coe_toPointedCone {S : ConvexCone \ud835\udd5c E} (hS : S.Pointed) :\n    S.toPointedCone hS = S :=\n  rfl", "start": [86, 1], "end": [89, 6], "kind": "mathlibtacticlemma"}, {"full_name": "PointedCone.canLift", "code": "instance canLift : CanLift (ConvexCone \ud835\udd5c E) (PointedCone \ud835\udd5c E) (\u2191) ConvexCone.Pointed where\n  prf S hS := \u27e8S.toPointedCone hS, rfl\u27e9", "start": [91, 1], "end": [92, 40], "kind": "commanddeclaration"}, {"full_name": "PointedCone.map", "code": "def map (f : E \u2192\u2097[\ud835\udd5c] F) (S : PointedCone \ud835\udd5c E) : PointedCone \ud835\udd5c F :=\n  Submodule.map (f : E \u2192\u2097[\ud835\udd5c\u22650] F) S", "start": [115, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone_map", "code": "@[simp, norm_cast]\ntheorem toConvexCone_map (S : PointedCone \ud835\udd5c E) (f : E \u2192\u2097[\ud835\udd5c] F) :\n    (S.map f : ConvexCone \ud835\udd5c F) = (S : ConvexCone \ud835\udd5c E).map f", "start": [119, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map (S : PointedCone \ud835\udd5c E) (f : E \u2192\u2097[\ud835\udd5c] F) : (S.map f : Set F) = f '' S", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.mem_map", "code": "@[simp]\ntheorem mem_map {f : E \u2192\u2097[\ud835\udd5c] F} {S : PointedCone \ud835\udd5c E} {y : F} : y \u2208 S.map f \u2194 \u2203 x \u2208 S, f x = y", "start": [128, 1], "end": [130, 10], "kind": "commanddeclaration"}, {"full_name": "PointedCone.map_map", "code": "theorem map_map (g : F \u2192\u2097[\ud835\udd5c] G) (f : E \u2192\u2097[\ud835\udd5c] F) (S : PointedCone \ud835\udd5c E) :\n    (S.map f).map g = S.map (g.comp f)", "start": [132, 1], "end": [134, 49], "kind": "commanddeclaration"}, {"full_name": "PointedCone.map_id", "code": "@[simp]\ntheorem map_id (S : PointedCone \ud835\udd5c E) : S.map LinearMap.id = S", "start": [136, 1], "end": [138, 42], "kind": "commanddeclaration"}, {"full_name": "PointedCone.comap", "code": "def comap (f : E \u2192\u2097[\ud835\udd5c] F) (S : PointedCone \ud835\udd5c F) : PointedCone \ud835\udd5c E :=\n  Submodule.comap (f : E \u2192\u2097[\ud835\udd5c\u22650] F) S", "start": [140, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "PointedCone.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap (f : E \u2192\u2097[\ud835\udd5c] F) (S : PointedCone \ud835\udd5c F) : (S.comap f : Set E) = f \u207b\u00b9' S", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.comap_id", "code": "@[simp]\ntheorem comap_id (S : PointedCone \ud835\udd5c E) : S.comap LinearMap.id = S", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.comap_comap", "code": "theorem comap_comap (g : F \u2192\u2097[\ud835\udd5c] G) (f : E \u2192\u2097[\ud835\udd5c] F) (S : PointedCone \ud835\udd5c G) :\n    (S.comap g).comap f = S.comap (g.comp f)", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.mem_comap", "code": "@[simp]\ntheorem mem_comap {f : E \u2192\u2097[\ud835\udd5c] F} {S : PointedCone \ud835\udd5c F} {x : E} : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [156, 1], "end": [158, 10], "kind": "commanddeclaration"}, {"full_name": "PointedCone.positive", "code": "def positive : PointedCone \ud835\udd5c E :=\n  (ConvexCone.positive \ud835\udd5c E).toPointedCone <| ConvexCone.pointed_positive \ud835\udd5c E", "start": [168, 1], "end": [171, 77], "kind": "commanddeclaration"}, {"full_name": "PointedCone.mem_positive", "code": "@[simp]\ntheorem mem_positive {x : E} : x \u2208 positive \ud835\udd5c E \u2194 0 \u2264 x", "start": [173, 1], "end": [175, 10], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone_positive", "code": "@[simp, norm_cast]\ntheorem toConvexCone_positive : \u2191(positive \ud835\udd5c E) = ConvexCone.positive \ud835\udd5c E", "start": [177, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.dual", "code": "def dual (S : PointedCone \u211d E) : PointedCone \u211d E :=\n  ((S : Set E).innerDualCone).toPointedCone <| pointed_innerDualCone (S : Set E)", "start": [186, 1], "end": [188, 81], "kind": "commanddeclaration"}, {"full_name": "PointedCone.toConvexCone_dual", "code": "@[simp, norm_cast]\ntheorem toConvexCone_dual (S : PointedCone \u211d E) : \u2191(dual S) = (S : Set E).innerDualCone", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "PointedCone.mem_dual", "code": "@[simp]\ntheorem mem_dual {S : PointedCone \u211d E} {y : E} : y \u2208 dual S \u2194 \u2200 \u2983x\u2984, x \u2208 S \u2192 0 \u2264 \u27eax, y\u27eb_\u211d", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Order.lean", "imports": ["Mathlib/ModelTheory/Semantics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.order", "code": "protected def order : Language :=\n  Language.mk\u2082 Empty Empty Empty Empty Unit", "start": [45, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderStructure", "code": "instance orderStructure [LE M] : Language.order.Structure M :=\n  Structure.mk\u2082 Empty.elim Empty.elim Empty.elim Empty.elim fun _ => (\u00b7 \u2264 \u00b7)", "start": [50, 1], "end": [51, 77], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Order.Language.instIsRelational", "code": "instance Language.instIsRelational : IsRelational Language.order :=\n  Language.isRelational_mk\u2082", "start": [56, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Order.Language.instSubsingleton", "code": "instance Language.instSubsingleton : Subsingleton (Language.order.Relations n) :=\n  Language.subsingleton_mk\u2082_relations", "start": [60, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.IsOrdered", "code": "class IsOrdered (L : Language.{u, v}) where\n  leSymb : L.Relations 2", "start": [66, 1], "end": [68, 25], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Term.le", "code": "def Term.le (t\u2081 t\u2082 : L.Term (Sum \u03b1 (Fin n))) : L.BoundedFormula \u03b1 n :=\n  leSymb.boundedFormula\u2082 t\u2081 t\u2082", "start": [77, 1], "end": [79, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Term.lt", "code": "def Term.lt (t\u2081 t\u2082 : L.Term (Sum \u03b1 (Fin n))) : L.BoundedFormula \u03b1 n :=\n  t\u2081.le t\u2082 \u2293 \u223c(t\u2082.le t\u2081)", "start": [82, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderLHom", "code": "def orderLHom : Language.order \u2192\u1d38 L :=\n  LHom.mk\u2082 Empty.elim Empty.elim Empty.elim Empty.elim fun _ => leSymb", "start": [89, 1], "end": [92, 71], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderLHom_leSymb", "code": "@[simp]\ntheorem orderLHom_leSymb [L.IsOrdered] :\n    (orderLHom L).onRelation leSymb = (leSymb : L.Relations 2)", "start": [100, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderLHom_order", "code": "@[simp]\ntheorem orderLHom_order : orderLHom Language.order = LHom.id Language.order", "start": [106, 1], "end": [108, 62], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.sum.instIsOrdered", "code": "instance sum.instIsOrdered : IsOrdered (L.sum Language.order) :=\n  \u27e8Sum.inr IsOrdered.leSymb\u27e9", "start": [111, 1], "end": [112, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.preorderTheory", "code": "def preorderTheory : L.Theory :=\n  {leSymb.reflexive, leSymb.transitive}", "start": [119, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.partialOrderTheory", "code": "def partialOrderTheory : L.Theory :=\n  {leSymb.reflexive, leSymb.antisymmetric, leSymb.transitive}", "start": [124, 1], "end": [126, 62], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.linearOrderTheory", "code": "def linearOrderTheory : L.Theory :=\n  {leSymb.reflexive, leSymb.antisymmetric, leSymb.transitive, leSymb.total}", "start": [129, 1], "end": [131, 76], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.noTopOrderSentence", "code": "def noTopOrderSentence : L.Sentence :=\n  \u2200'\u2203'\u223c((&1).le &0)", "start": [134, 1], "end": [137, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.noBotOrderSentence", "code": "def noBotOrderSentence : L.Sentence :=\n  \u2200'\u2203'\u223c((&0).le &1)", "start": [140, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.denselyOrderedSentence", "code": "def denselyOrderedSentence : L.Sentence :=\n  \u2200'\u2200'((&0).lt &1 \u27f9 \u2203'((&0).lt &2 \u2293 (&2).lt &1))", "start": [146, 1], "end": [149, 49], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.dlo", "code": "def dlo : L.Theory :=\n  L.linearOrderTheory \u222a {L.noTopOrderSentence, L.noBotOrderSentence, L.denselyOrderedSentence}", "start": [152, 1], "end": [154, 95], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.OrderedStructure", "code": "abbrev OrderedStructure [IsOrdered L] [LE M] [L.Structure M] : Prop :=\n  LHom.IsExpansionOn (orderLHom L) M", "start": [161, 1], "end": [163, 37], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderedStructure_iff", "code": "@[simp]\ntheorem orderedStructure_iff [IsOrdered L] [LE M] [L.Structure M] :\n    L.OrderedStructure M \u2194 LHom.IsExpansionOn (orderLHom L) M", "start": [168, 1], "end": [171, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.orderedStructure_LE", "code": "instance orderedStructure_LE [LE M] : OrderedStructure Language.order M := by\n  rw [orderedStructure_iff, orderLHom_order]\n  exact LHom.id_isExpansionOn M", "start": [174, 1], "end": [176, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.model_preorder", "code": "instance model_preorder [Preorder M] : M \u22a8 Language.order.preorderTheory := by\n  simp only [preorderTheory, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    forall_eq_or_imp, Relations.realize_reflexive, relMap_apply\u2082, forall_eq,\n    Relations.realize_transitive]\n  exact \u27e8le_refl, fun _ _ _ => le_trans\u27e9", "start": [179, 1], "end": [183, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.model_partialOrder", "code": "instance model_partialOrder [PartialOrder M] : M \u22a8 Language.order.partialOrderTheory := by\n  simp only [partialOrderTheory, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    forall_eq_or_imp, Relations.realize_reflexive, relMap_apply\u2082, Relations.realize_antisymmetric,\n    forall_eq, Relations.realize_transitive]\n  exact \u27e8le_refl, fun _ _ => le_antisymm, fun _ _ _ => le_trans\u27e9", "start": [186, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.model_linearOrder", "code": "instance model_linearOrder [LinearOrder M] : M \u22a8 Language.order.linearOrderTheory := by\n  simp only [linearOrderTheory, Theory.model_iff, Set.mem_insert_iff, Set.mem_singleton_iff,\n    forall_eq_or_imp, Relations.realize_reflexive, relMap_apply\u2082, Relations.realize_antisymmetric,\n    Relations.realize_transitive, forall_eq, Relations.realize_total]\n  exact \u27e8le_refl, fun _ _ => le_antisymm, fun _ _ _ => le_trans, le_total\u27e9", "start": [193, 1], "end": [197, 75], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.relMap_leSymb", "code": "@[simp]\ntheorem relMap_leSymb [LE M] [L.OrderedStructure M] {a b : M} :\n    RelMap (leSymb : L.Relations 2) ![a, b] \u2194 a \u2264 b", "start": [204, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Term.realize_le", "code": "@[simp]\ntheorem Term.realize_le [LE M] [L.OrderedStructure M] {t\u2081 t\u2082 : L.Term (Sum \u03b1 (Fin n))} {v : \u03b1 \u2192 M}\n    {xs : Fin n \u2192 M} :\n    (t\u2081.le t\u2082).Realize v xs \u2194 t\u2081.realize (Sum.elim v xs) \u2264 t\u2082.realize (Sum.elim v xs)", "start": [211, 1], "end": [215, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Term.realize_lt", "code": "@[simp]\ntheorem Term.realize_lt [Preorder M] [L.OrderedStructure M] {t\u2081 t\u2082 : L.Term (Sum \u03b1 (Fin n))}\n    {v : \u03b1 \u2192 M} {xs : Fin n \u2192 M} :\n    (t\u2081.lt t\u2082).Realize v xs \u2194 t\u2081.realize (Sum.elim v xs) < t\u2082.realize (Sum.elim v xs)", "start": [218, 1], "end": [222, 35], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_noTopOrder_iff", "code": "theorem realize_noTopOrder_iff : M \u22a8 Language.order.noTopOrderSentence \u2194 NoTopOrder M", "start": [231, 1], "end": [237, 24], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_noTopOrder", "code": "@[simp]\ntheorem realize_noTopOrder [h : NoTopOrder M] : M \u22a8 Language.order.noTopOrderSentence", "start": [240, 1], "end": [242, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_noBotOrder_iff", "code": "theorem realize_noBotOrder_iff : M \u22a8 Language.order.noBotOrderSentence \u2194 NoBotOrder M", "start": [245, 1], "end": [251, 24], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_noBotOrder", "code": "@[simp]\ntheorem realize_noBotOrder [h : NoBotOrder M] : M \u22a8 Language.order.noBotOrderSentence", "start": [254, 1], "end": [256, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_denselyOrdered_iff", "code": "theorem realize_denselyOrdered_iff [Preorder M] :\n    M \u22a8 Language.order.denselyOrderedSentence \u2194 DenselyOrdered M", "start": [261, 1], "end": [268, 26], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_denselyOrdered", "code": "@[simp]\ntheorem realize_denselyOrdered [Preorder M] [h : DenselyOrdered M] :\n    M \u22a8 Language.order.denselyOrderedSentence", "start": [271, 1], "end": [274, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.model_dlo", "code": "instance model_dlo [LinearOrder M] [DenselyOrdered M] [NoTopOrder M] [NoBotOrder M] :\n    M \u22a8 Language.order.dlo := by\n  simp only [dlo, Set.union_insert, Set.union_singleton, Theory.model_iff, Set.mem_insert_iff,\n    forall_eq_or_imp, realize_noTopOrder, realize_noBotOrder, realize_denselyOrdered,\n    true_and_iff]\n  rw [\u2190 Theory.model_iff]\n  infer_instance", "start": [277, 1], "end": [283, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Cardinality.lean", "imports": ["Mathlib/Data/MvPolynomial/Cardinal.lean", "Mathlib/Data/Nat/Factorization/PrimePow.lean", "Mathlib/Data/Rat/Denumerable.lean", "Mathlib/FieldTheory/Finite/GaloisField.lean", "Mathlib/SetTheory/Cardinal/Divisibility.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Localization/Cardinality.lean", "Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/Algebra/Field/ULift.lean"], "premises": [{"full_name": "Fintype.isPrimePow_card_of_field", "code": "theorem Fintype.isPrimePow_card_of_field {\u03b1} [Fintype \u03b1] [Field \u03b1] : IsPrimePow \u2016\u03b1\u2016", "start": [39, 1], "end": [49, 42], "kind": "commanddeclaration"}, {"full_name": "Fintype.nonempty_field_iff", "code": "theorem Fintype.nonempty_field_iff {\u03b1} [Fintype \u03b1] : Nonempty (Field \u03b1) \u2194 IsPrimePow \u2016\u03b1\u2016", "start": [52, 1], "end": [57, 86], "kind": "commanddeclaration"}, {"full_name": "Fintype.not_isField_of_card_not_prime_pow", "code": "theorem Fintype.not_isField_of_card_not_prime_pow {\u03b1} [Fintype \u03b1] [Ring \u03b1] :\n    \u00acIsPrimePow \u2016\u03b1\u2016 \u2192 \u00acIsField \u03b1", "start": [60, 1], "end": [62, 56], "kind": "commanddeclaration"}, {"full_name": "Infinite.nonempty_field", "code": "theorem Infinite.nonempty_field {\u03b1 : Type u} [Infinite \u03b1] : Nonempty (Field \u03b1)", "start": [65, 1], "end": [76, 9], "kind": "commanddeclaration"}, {"full_name": "Field.nonempty_iff", "code": "theorem Field.nonempty_iff {\u03b1 : Type u} : Nonempty (Field \u03b1) \u2194 IsPrimePow #\u03b1", "start": [79, 1], "end": [85, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/AbelRuffini.lean", "imports": ["Mathlib/FieldTheory/PolynomialGaloisGroup.lean", "Mathlib/RingTheory/RootsOfUnity/Basic.lean", "Mathlib/GroupTheory/Solvable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "gal_zero_isSolvable", "code": "theorem gal_zero_isSolvable : IsSolvable (0 : F[X]).Gal", "start": [41, 1], "end": [41, 77], "kind": "commanddeclaration"}, {"full_name": "gal_one_isSolvable", "code": "theorem gal_one_isSolvable : IsSolvable (1 : F[X]).Gal", "start": [44, 1], "end": [44, 76], "kind": "commanddeclaration"}, {"full_name": "gal_C_isSolvable", "code": "theorem gal_C_isSolvable (x : F) : IsSolvable (C x).Gal", "start": [47, 1], "end": [47, 77], "kind": "commanddeclaration"}, {"full_name": "gal_X_isSolvable", "code": "theorem gal_X_isSolvable : IsSolvable (X : F[X]).Gal", "start": [51, 1], "end": [51, 74], "kind": "commanddeclaration"}, {"full_name": "gal_X_sub_C_isSolvable", "code": "theorem gal_X_sub_C_isSolvable (x : F) : IsSolvable (X - C x).Gal", "start": [55, 1], "end": [55, 87], "kind": "commanddeclaration"}, {"full_name": "gal_X_pow_isSolvable", "code": "theorem gal_X_pow_isSolvable (n : \u2115) : IsSolvable (X ^ n : F[X]).Gal", "start": [59, 1], "end": [59, 90], "kind": "commanddeclaration"}, {"full_name": "gal_mul_isSolvable", "code": "theorem gal_mul_isSolvable {p q : F[X]} (_ : IsSolvable p.Gal) (_ : IsSolvable q.Gal) :\n    IsSolvable (p * q).Gal", "start": [63, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "gal_prod_isSolvable", "code": "theorem gal_prod_isSolvable {s : Multiset F[X]} (hs : \u2200 p \u2208 s, IsSolvable (Gal p)) :\n    IsSolvable s.prod.Gal", "start": [68, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "gal_isSolvable_of_splits", "code": "theorem gal_isSolvable_of_splits {p q : F[X]}\n    (_ : Fact (p.Splits (algebraMap F q.SplittingField))) (hq : IsSolvable q.Gal) :\n    IsSolvable p.Gal", "start": [77, 1], "end": [81, 82], "kind": "commanddeclaration"}, {"full_name": "gal_isSolvable_tower", "code": "theorem gal_isSolvable_tower (p q : F[X]) (hpq : p.Splits (algebraMap F q.SplittingField))\n    (hp : IsSolvable p.Gal) (hq : IsSolvable (q.map (algebraMap F p.SplittingField)).Gal) :\n    IsSolvable q.Gal", "start": [84, 1], "end": [95, 72], "kind": "commanddeclaration"}, {"full_name": "gal_X_pow_sub_one_isSolvable", "code": "theorem gal_X_pow_sub_one_isSolvable (n : \u2115) : IsSolvable (X ^ n - 1 : F[X]).Gal", "start": [100, 1], "end": [116, 87], "kind": "commanddeclaration"}, {"full_name": "gal_X_pow_sub_C_isSolvable_aux", "code": "theorem gal_X_pow_sub_C_isSolvable_aux (n : \u2115) (a : F)\n    (h : (X ^ n - 1 : F[X]).Splits (RingHom.id F)) : IsSolvable (X ^ n - C a).Gal", "start": [120, 1], "end": [155, 56], "kind": "commanddeclaration"}, {"full_name": "splits_X_pow_sub_one_of_X_pow_sub_C", "code": "theorem splits_X_pow_sub_one_of_X_pow_sub_C {F : Type*} [Field F] {E : Type*} [Field E]\n    (i : F \u2192+* E) (n : \u2115) {a : F} (ha : a \u2260 0) (h : (X ^ n - C a).Splits i) :\n    (X ^ n - 1 : F[X]).Splits i", "start": [159, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "gal_X_pow_sub_C_isSolvable", "code": "theorem gal_X_pow_sub_C_isSolvable (n : \u2115) (x : F) : IsSolvable (X ^ n - C x).Gal", "start": [200, 1], "end": [211, 33], "kind": "commanddeclaration"}, {"full_name": "IsSolvableByRad", "code": "inductive IsSolvableByRad : E \u2192 Prop\n  | base (\u03b1 : F) : IsSolvableByRad (algebraMap F E \u03b1)\n  | add (\u03b1 \u03b2 : E) : IsSolvableByRad \u03b1 \u2192 IsSolvableByRad \u03b2 \u2192 IsSolvableByRad (\u03b1 + \u03b2)\n  | neg (\u03b1 : E) : IsSolvableByRad \u03b1 \u2192 IsSolvableByRad (-\u03b1)\n  | mul (\u03b1 \u03b2 : E) : IsSolvableByRad \u03b1 \u2192 IsSolvableByRad \u03b2 \u2192 IsSolvableByRad (\u03b1 * \u03b2)\n  | inv (\u03b1 : E) : IsSolvableByRad \u03b1 \u2192 IsSolvableByRad \u03b1\u207b\u00b9\n  | rad (\u03b1 : E) (n : \u2115) (hn : n \u2260 0) : IsSolvableByRad (\u03b1 ^ n) \u2192 IsSolvableByRad \u03b1", "start": [219, 1], "end": [226, 83], "kind": "commanddeclaration"}, {"full_name": "solvableByRad", "code": "def solvableByRad : IntermediateField F E where\n  carrier := IsSolvableByRad F\n  zero_mem' := by\n    change IsSolvableByRad F 0\n    convert IsSolvableByRad.base (E := E) (0 : F); rw [RingHom.map_zero]\n  add_mem' := by apply IsSolvableByRad.add\n  one_mem' := by\n    change IsSolvableByRad F 1\n    convert IsSolvableByRad.base (E := E) (1 : F); rw [RingHom.map_one]\n  mul_mem' := by apply IsSolvableByRad.mul\n  inv_mem' := IsSolvableByRad.inv\n  algebraMap_mem' := IsSolvableByRad.base", "start": [231, 1], "end": [243, 42], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.induction", "code": "theorem induction (P : solvableByRad F E \u2192 Prop)\n    (base : \u2200 \u03b1 : F, P (algebraMap F (solvableByRad F E) \u03b1))\n    (add : \u2200 \u03b1 \u03b2 : solvableByRad F E, P \u03b1 \u2192 P \u03b2 \u2192 P (\u03b1 + \u03b2))\n    (neg : \u2200 \u03b1 : solvableByRad F E, P \u03b1 \u2192 P (-\u03b1))\n    (mul : \u2200 \u03b1 \u03b2 : solvableByRad F E, P \u03b1 \u2192 P \u03b2 \u2192 P (\u03b1 * \u03b2))\n    (inv : \u2200 \u03b1 : solvableByRad F E, P \u03b1 \u2192 P \u03b1\u207b\u00b9)\n    (rad : \u2200 \u03b1 : solvableByRad F E, \u2200 n : \u2115, n \u2260 0 \u2192 P (\u03b1 ^ n) \u2192 P \u03b1) (\u03b1 : solvableByRad F E) :\n    P \u03b1", "start": [250, 1], "end": [282, 76], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.isIntegral", "code": "theorem isIntegral (\u03b1 : solvableByRad F E) : IsIntegral F \u03b1", "start": [285, 1], "end": [301, 26], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.P", "code": "def P (\u03b1 : solvableByRad F E) : Prop :=\n  IsSolvable (minpoly F \u03b1).Gal", "start": [304, 1], "end": [306, 31], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.induction3", "code": "theorem induction3 {\u03b1 : solvableByRad F E} {n : \u2115} (hn : n \u2260 0) (h\u03b1 : P (\u03b1 ^ n)) : P \u03b1", "start": [310, 1], "end": [334, 43], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.induction2", "code": "theorem induction2 {\u03b1 \u03b2 \u03b3 : solvableByRad F E} (h\u03b3 : \u03b3 \u2208 F\u27ee\u03b1, \u03b2\u27ef) (h\u03b1 : P \u03b1) (h\u03b2 : P \u03b2) : P \u03b3", "start": [337, 1], "end": [368, 34], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.induction1", "code": "theorem induction1 {\u03b1 \u03b2 : solvableByRad F E} (h\u03b2 : \u03b2 \u2208 F\u27ee\u03b1\u27ef) (h\u03b1 : P \u03b1) : P \u03b2", "start": [371, 1], "end": [373, 79], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.isSolvable", "code": "theorem isSolvable (\u03b1 : solvableByRad F E) : IsSolvable (minpoly F \u03b1).Gal", "start": [376, 1], "end": [386, 32], "kind": "commanddeclaration"}, {"full_name": "solvableByRad.isSolvable'", "code": "theorem isSolvable' {\u03b1 : E} {q : F[X]} (q_irred : Irreducible q) (q_aeval : aeval \u03b1 q = 0)\n    (h\u03b1 : IsSolvableByRad F \u03b1) : IsSolvable q.Gal", "start": [389, 1], "end": [400, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/VectorBundle/Pullback.lean", "imports": ["Mathlib/Geometry/Manifold/ContMDiffMap.lean", "Mathlib/Geometry/Manifold/VectorBundle/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SmoothVectorBundle.pullback", "code": "instance SmoothVectorBundle.pullback : SmoothVectorBundle F (f *\u1d56 E) IB' where\n  smoothOn_coordChangeL := by\n    rintro _ _ \u27e8e, he, rfl\u27e9 \u27e8e', he', rfl\u27e9; skip\n    refine' ((smoothOn_coordChangeL _ e e').comp f.smooth.smoothOn fun b hb => hb).congr _\n    rintro b (hb : f b \u2208 e.baseSet \u2229 e'.baseSet); ext v\n    show ((e.pullback f).coordChangeL \ud835\udd5c (e'.pullback f) b) v = (e.coordChangeL \ud835\udd5c e' (f b)) v\n    rw [e.coordChangeL_apply e' hb, (e.pullback f).coordChangeL_apply' _]\n    exacts [rfl, hb]", "start": [36, 1], "end": [45, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Destutter.lean", "imports": ["Mathlib/Data/List/Chain.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.destutter'_nil", "code": "@[simp]\ntheorem destutter'_nil : destutter' R a [] = [a]", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_cons", "code": "theorem destutter'_cons :\n    (b :: l).destutter' R a = if R a b then a :: destutter' R b l else destutter' R a l", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_cons_pos", "code": "@[simp]\ntheorem destutter'_cons_pos (h : R b a) : (a :: l).destutter' R b = b :: l.destutter' R a", "start": [47, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_cons_neg", "code": "@[simp]\ntheorem destutter'_cons_neg (h : \u00acR b a) : (a :: l).destutter' R b = l.destutter' R b", "start": [52, 1], "end": [54, 28], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_singleton", "code": "@[simp]\ntheorem destutter'_singleton : [b].destutter' R a = if R a b then [a, b] else [a]", "start": [59, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_sublist", "code": "theorem destutter'_sublist (a) : l.destutter' R a <+ a :: l", "start": [64, 1], "end": [70, 56], "kind": "commanddeclaration"}, {"full_name": "List.mem_destutter'", "code": "theorem mem_destutter' (a) : a \u2208 l.destutter' R a", "start": [73, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_is_chain", "code": "theorem destutter'_is_chain : \u2200 l : List \u03b1, \u2200 {a b}, R a b \u2192 (l.destutter' R b).Chain R a", "start": [82, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_is_chain'", "code": "theorem destutter'_is_chain' (a) : (l.destutter' R a).Chain' R", "start": [92, 1], "end": [98, 15], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_of_chain", "code": "theorem destutter'_of_chain (h : l.Chain R a) : l.destutter' R a = a :: l", "start": [101, 1], "end": [105, 38], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_eq_self_iff", "code": "@[simp]\ntheorem destutter'_eq_self_iff (a) : l.destutter' R a = a :: l \u2194 l.Chain R a", "start": [108, 1], "end": [114, 63], "kind": "commanddeclaration"}, {"full_name": "List.destutter'_ne_nil", "code": "theorem destutter'_ne_nil : l.destutter' R a \u2260 []", "start": [117, 1], "end": [118, 40], "kind": "commanddeclaration"}, {"full_name": "List.destutter_nil", "code": "@[simp]\ntheorem destutter_nil : ([] : List \u03b1).destutter R = []", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter_cons'", "code": "theorem destutter_cons' : (a :: l).destutter R = destutter' R a l", "start": [126, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter_cons_cons", "code": "theorem destutter_cons_cons :\n    (a :: b :: l).destutter R = if R a b then a :: destutter' R b l else destutter' R a l", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter_singleton", "code": "@[simp]\ntheorem destutter_singleton : destutter R [a] = [a]", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "List.destutter_pair", "code": "@[simp]\ntheorem destutter_pair : destutter R [a, b] = if R a b then [a, b] else [a]", "start": [140, 1], "end": [142, 26], "kind": "commanddeclaration"}, {"full_name": "List.destutter_sublist", "code": "theorem destutter_sublist : \u2200 l : List \u03b1, l.destutter R <+ l", "start": [145, 1], "end": [147, 39], "kind": "commanddeclaration"}, {"full_name": "List.destutter_is_chain'", "code": "theorem destutter_is_chain' : \u2200 l : List \u03b1, (l.destutter R).Chain' R", "start": [150, 1], "end": [152, 41], "kind": "commanddeclaration"}, {"full_name": "List.destutter_of_chain'", "code": "theorem destutter_of_chain' : \u2200 l : List \u03b1, l.Chain' R \u2192 l.destutter R = l", "start": [155, 1], "end": [157, 43], "kind": "commanddeclaration"}, {"full_name": "List.destutter_eq_self_iff", "code": "@[simp]\ntheorem destutter_eq_self_iff : \u2200 l : List \u03b1, l.destutter R = l \u2194 l.Chain' R", "start": [160, 1], "end": [163, 43], "kind": "commanddeclaration"}, {"full_name": "List.destutter_idem", "code": "theorem destutter_idem : (l.destutter R).destutter R = l.destutter R", "start": [166, 1], "end": [167, 53], "kind": "commanddeclaration"}, {"full_name": "List.destutter_eq_nil", "code": "@[simp]\ntheorem destutter_eq_nil : \u2200 {l : List \u03b1}, destutter R l = [] \u2194 l = []", "start": [170, 1], "end": [173, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/ZMod.lean", "imports": ["Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "Mathlib/Algebra/Squarefree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isReduced_zmod", "code": "@[simp]\ntheorem isReduced_zmod {n : \u2115} : IsReduced (ZMod n) \u2194 Squarefree n \u2228 n = 0", "start": [23, 1], "end": [28, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/Cone.lean", "imports": ["Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ring.PositiveCone", "code": "structure PositiveCone (\u03b1 : Type*) [Ring \u03b1] extends AddCommGroup.PositiveCone \u03b1 where\n  \n  one_nonneg : nonneg 1\n  \n  mul_pos : \u2200 a b, pos a \u2192 pos b \u2192 pos (a * b)", "start": [23, 1], "end": [29, 47], "kind": "commanddeclaration"}, {"full_name": "Ring.TotalPositiveCone", "code": "structure TotalPositiveCone (\u03b1 : Type*) [Ring \u03b1] extends PositiveCone \u03b1,\n  AddCommGroup.TotalPositiveCone \u03b1", "start": [36, 1], "end": [38, 35], "kind": "commanddeclaration"}, {"full_name": "Ring.PositiveCone.one_pos", "code": "theorem PositiveCone.one_pos (C : PositiveCone \u03b1) : C.pos 1", "start": [49, 1], "end": [50, 91], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedRing.mkOfPositiveCone", "code": "def StrictOrderedRing.mkOfPositiveCone (C : PositiveCone \u03b1) : StrictOrderedRing \u03b1 :=\n  { \u2039Ring \u03b1\u203a, OrderedAddCommGroup.mkOfPositiveCone C.toPositiveCone with\n    exists_pair_ne := \u27e80, 1, fun h => by simpa [\u2190 h, C.pos_iff] using C.one_pos\u27e9,\n    zero_le_one := by\n      change C.nonneg (1 - 0)\n      convert C.one_nonneg\n      simp,\n    mul_pos := fun x y xp yp => by\n      change C.pos (x * y - 0)\n      rw [sub_zero]\n      exact C.mul_pos x y (by rwa [\u2190 sub_zero x]) (by rwa [\u2190 sub_zero y]) }", "start": [57, 1], "end": [69, 76], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.mkOfPositiveCone", "code": "def LinearOrderedRing.mkOfPositiveCone (C : TotalPositiveCone \u03b1) : LinearOrderedRing \u03b1 :=\n  { LinearOrderedAddCommGroup.mkOfPositiveCone C.toTotalPositiveCone,\n    StrictOrderedRing.mkOfPositiveCone C.toPositiveCone_1 with }", "start": [72, 1], "end": [76, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DList/Instances.lean", "imports": ["Mathlib/Control/Traversable/Instances.lean", "Mathlib/Control/Traversable/Equiv.lean", "Mathlib/Data/DList/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.DList.listEquivDList", "code": "def DList.listEquivDList : List \u03b1 \u2243 DList \u03b1 := by\n  refine'\n      { toFun := DList.ofList\n        invFun := DList.toList.. } <;>\n    simp [Function.RightInverse, Function.LeftInverse, DList.toList_ofList, DList.ofList_toList]", "start": [26, 1], "end": [32, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Born.lean", "imports": ["Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "Mathlib/Topology/Bornology/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Born", "code": "def Born :=\n  Bundled Bornology", "start": [22, 1], "end": [24, 20], "kind": "commanddeclaration"}, {"full_name": "Born.of", "code": "def of (\u03b1 : Type*) [Bornology \u03b1] : Born :=\n  Bundled.of \u03b1", "start": [36, 1], "end": [38, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Basis/Flag.lean", "imports": ["Mathlib/Data/Fin/FlagRange.lean", "Mathlib/LinearAlgebra/Basis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Basis.flag", "code": "def flag (b : Basis (Fin n) R M) (k : Fin (n + 1)) : Submodule R M :=\n  .span R <| b '' {i | i.castSucc < k}", "start": [26, 1], "end": [28, 39], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_zero", "code": "@[simp]\ntheorem flag_zero (b : Basis (Fin n) R M) : b.flag 0 = \u22a5", "start": [30, 1], "end": [31, 75], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_last", "code": "@[simp]\ntheorem flag_last (b : Basis (Fin n) R M) : b.flag (.last n) = \u22a4", "start": [33, 1], "end": [35, 36], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_le_iff", "code": "theorem flag_le_iff (b : Basis (Fin n) R M) {k p} :\n    b.flag k \u2264 p \u2194 \u2200 i : Fin n, i.castSucc < k \u2192 b i \u2208 p", "start": [37, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_succ", "code": "theorem flag_succ (b : Basis (Fin n) R M) (k : Fin n) :\n    b.flag k.succ = (R \u2219 b k) \u2294 b.flag k.castSucc", "start": [41, 1], "end": [44, 94], "kind": "commanddeclaration"}, {"full_name": "Basis.self_mem_flag", "code": "theorem self_mem_flag (b : Basis (Fin n) R M) {i : Fin n} {k : Fin (n + 1)} (h : i.castSucc < k) :\n    b i \u2208 b.flag k", "start": [46, 1], "end": [48, 38], "kind": "commanddeclaration"}, {"full_name": "Basis.self_mem_flag_iff", "code": "@[simp]\ntheorem self_mem_flag_iff [Nontrivial R] (b : Basis (Fin n) R M) {i : Fin n} {k : Fin (n + 1)} :\n    b i \u2208 b.flag k \u2194 i.castSucc < k", "start": [50, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_mono", "code": "@[mono]\ntheorem flag_mono (b : Basis (Fin n) R M) : Monotone b.flag", "start": [55, 1], "end": [57, 75], "kind": "commanddeclaration"}, {"full_name": "Basis.isChain_range_flag", "code": "theorem isChain_range_flag (b : Basis (Fin n) R M) : IsChain (\u00b7 \u2264 \u00b7) (range b.flag)", "start": [59, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_strictMono", "code": "@[mono]\ntheorem flag_strictMono [Nontrivial R] (b : Basis (Fin n) R M) : StrictMono b.flag", "start": [62, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_le_ker_coord_iff", "code": "@[simp]\ntheorem flag_le_ker_coord_iff [Nontrivial R] (b : Basis (Fin n) R M) {k : Fin (n + 1)} {l : Fin n} :\n    b.flag k \u2264 LinearMap.ker (b.coord l) \u2194 k \u2264 l.castSucc", "start": [72, 1], "end": [75, 76], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_le_ker_coord", "code": "theorem flag_le_ker_coord (b : Basis (Fin n) R M) {k : Fin (n + 1)} {l : Fin n}\n    (h : k \u2264 l.castSucc) : b.flag k \u2264 LinearMap.ker (b.coord l)", "start": [77, 1], "end": [80, 36], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_covby", "code": "theorem flag_covby (b : Basis (Fin n) K V) (i : Fin n) :\n    b.flag i.castSucc \u22d6 b.flag i.succ", "start": [88, 1], "end": [92, 7], "kind": "commanddeclaration"}, {"full_name": "Basis.flag_wcovby", "code": "theorem flag_wcovby (b : Basis (Fin n) K V) (i : Fin n) :\n    b.flag i.castSucc \u2a7f b.flag i.succ", "start": [94, 1], "end": [96, 26], "kind": "commanddeclaration"}, {"full_name": "Basis.toFlag", "code": "@[simps!]\ndef toFlag (b : Basis (Fin n) K V) : Flag (Submodule K V) :=\n  .rangeFin b.flag b.flag_zero b.flag_last b.flag_wcovby", "start": [98, 1], "end": [101, 57], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_toFlag", "code": "@[simp]\ntheorem mem_toFlag (b : Basis (Fin n) K V) {p : Submodule K V} : p \u2208 b.toFlag \u2194 \u2203 k, b.flag k = p", "start": [103, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "Basis.isMaxChain_range_flag", "code": "theorem isMaxChain_range_flag (b : Basis (Fin n) K V) : IsMaxChain (\u00b7 \u2264 \u00b7) (range b.flag)", "start": [107, 1], "end": [108, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "imports": ["Mathlib/Topology/Algebra/UniformRing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/UniformSpace/Completion.lean", "Mathlib/Topology/Algebra/Nonarchimedean/Bases.lean", "Mathlib/RingTheory/Ideal/Operations.lean"], "premises": [{"full_name": "Ideal.adic_basis", "code": "theorem adic_basis (I : Ideal R) : SubmodulesRingBasis fun n : \u2115 => (I ^ n \u2022 \u22a4 : Ideal R)", "start": [55, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.ringFilterBasis", "code": "def ringFilterBasis (I : Ideal R) :=\n  I.adic_basis.toRing_subgroups_basis.toRingFilterBasis", "start": [77, 1], "end": [79, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.adicTopology", "code": "def adicTopology (I : Ideal R) : TopologicalSpace R :=\n  (adic_basis I).topology", "start": [82, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.nonarchimedean", "code": "theorem nonarchimedean (I : Ideal R) : @NonarchimedeanRing R _ I.adicTopology", "start": [88, 1], "end": [89, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.hasBasis_nhds_zero_adic", "code": "theorem hasBasis_nhds_zero_adic (I : Ideal R) :\n    HasBasis (@nhds R I.adicTopology (0 : R)) (fun _n : \u2115 => True) fun n =>\n      ((I ^ n : Ideal R) : Set R)", "start": [92, 1], "end": [104, 50], "kind": "commanddeclaration"}, {"full_name": "Ideal.hasBasis_nhds_adic", "code": "theorem hasBasis_nhds_adic (I : Ideal R) (x : R) :\n    HasBasis (@nhds R I.adicTopology x) (fun _n : \u2115 => True) fun n =>\n      (fun y => x + y) '' (I ^ n : Ideal R)", "start": [107, 1], "end": [112, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.adic_module_basis", "code": "theorem adic_module_basis :\n    I.ringFilterBasis.SubmodulesBasis fun n : \u2115 => I ^ n \u2022 (\u22a4 : Submodule R M)", "start": [117, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.adicModuleTopology", "code": "def adicModuleTopology : TopologicalSpace M :=\n  @ModuleFilterBasis.topology R M _ I.adic_basis.topology _ _\n    (I.ringFilterBasis.moduleFilterBasis (I.adic_module_basis M))", "start": [130, 1], "end": [134, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.openAddSubgroup", "code": "def openAddSubgroup (n : \u2115) : @OpenAddSubgroup R _ I.adicTopology := by\n  letI := I.adicTopology\n  refine \u27e8(I ^ n).toAddSubgroup, ?_\u27e9\n  convert (I.adic_basis.toRing_subgroups_basis.openAddSubgroup n).isOpen\n  change (I ^ n : Set R) = (I ^ n \u2022 (\u22a4 : Ideal R) : Set R)\n  simp [smul_top_eq_map, Algebra.id.map_eq_id, map_id, restrictScalars_self]", "start": [137, 1], "end": [144, 77], "kind": "commanddeclaration"}, {"full_name": "IsAdic", "code": "def IsAdic [H : TopologicalSpace R] (J : Ideal R) : Prop :=\n  H = J.adicTopology", "start": [151, 1], "end": [154, 21], "kind": "commanddeclaration"}, {"full_name": "isAdic_iff", "code": "theorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J \u2194\n      (\u2200 n : \u2115, IsOpen ((J ^ n : Ideal R) : Set R)) \u2227\n        \u2200 s \u2208 \ud835\udcdd (0 : R), \u2203 n : \u2115, ((J ^ n : Ideal R) : Set R) \u2286 s", "start": [157, 1], "end": [185, 48], "kind": "commanddeclaration"}, {"full_name": "is_ideal_adic_pow", "code": "theorem is_ideal_adic_pow {J : Ideal R} (h : IsAdic J) {n : \u2115} (hn : 0 < n) : IsAdic (J ^ n)", "start": [190, 1], "end": [205, 26], "kind": "commanddeclaration"}, {"full_name": "is_bot_adic_iff", "code": "theorem is_bot_adic_iff {A : Type*} [CommRing A] [TopologicalSpace A] [TopologicalRing A] :\n    IsAdic (\u22a5 : Ideal A) \u2194 DiscreteTopology A", "start": [208, 1], "end": [220, 36], "kind": "commanddeclaration"}, {"full_name": "WithIdeal", "code": "class WithIdeal (R : Type*) [CommRing R] where\n  i : Ideal R", "start": [225, 1], "end": [227, 14], "kind": "commanddeclaration"}, {"full_name": "WithIdeal.topologicalSpaceModule", "code": "def topologicalSpaceModule (M : Type*) [AddCommGroup M] [Module R M] : TopologicalSpace M :=\n  (i : Ideal R).adicModuleTopology M", "start": [248, 1], "end": [251, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Shift/Localization.lean", "imports": ["Mathlib/CategoryTheory/Shift/Induced.lean", "Mathlib/CategoryTheory/Localization/Predicate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MorphismProperty.IsCompatibleWithShift", "code": "class IsCompatibleWithShift : Prop :=\n  \n  condition : \u2200 (a : A), W.inverseImage (shiftFunctor C a) = W", "start": [30, 1], "end": [36, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MorphismProperty.IsCompatibleWithShift.iff", "code": "lemma iff {X Y : C} (f : X \u27f6 Y) (a : A) : W (f\u27e6a\u27e7') \u2194 W f := by\n  conv_rhs => rw [\u2190 @IsCompatibleWithShift.condition _ _ W A _ _ _ a]", "start": [44, 1], "end": [45, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.MorphismProperty.IsCompatibleWithShift.shiftFunctor_comp_inverts", "code": "lemma shiftFunctor_comp_inverts (a : A) :\n    W.IsInvertedBy (shiftFunctor C a \u22d9 L) := fun _ _ f hf =>\n  Localization.inverts L W _ (by simpa only [iff] using hf)", "start": [47, 1], "end": [49, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.HasShift.localized", "code": "noncomputable def HasShift.localized : HasShift D A :=\n  HasShift.induced L A\n    (fun a => Localization.lift (shiftFunctor C a \u22d9 L)\n      (MorphismProperty.IsCompatibleWithShift.shiftFunctor_comp_inverts L W a) L)\n    (fun _ => Localization.fac _ _ _)\n    \u27e8\u27e8(inferInstance : Full (Localization.whiskeringLeftFunctor' L W D))\u27e9,\n      (inferInstance : Faithful (Localization.whiskeringLeftFunctor' L W D))\u27e9", "start": [57, 1], "end": [66, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.CommShift.localized", "code": "noncomputable def Functor.CommShift.localized :\n    @Functor.CommShift _ _ _ _ L A _ _ (HasShift.localized L W A) :=\n  Functor.CommShift.ofInduced _ _ _ _ _", "start": [68, 1], "end": [71, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasShift.localization", "code": "noncomputable instance HasShift.localization :\n    HasShift W.Localization A :=\n  HasShift.localized W.Q W A", "start": [75, 1], "end": [78, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MorphismProperty.commShift_Q", "code": "noncomputable instance MorphismProperty.commShift_Q :\n    W.Q.CommShift A :=\n  Functor.CommShift.localized W.Q W A", "start": [80, 1], "end": [83, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/DedekindDomain/Factorization.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsDedekindDomain.HeightOneSpectrum.maxPowDividing", "code": "def IsDedekindDomain.HeightOneSpectrum.maxPowDividing (I : Ideal R) : Ideal R :=\n  v.asIdeal ^ (Associates.mk v.asIdeal).count (Associates.mk I).factors", "start": [37, 1], "end": [40, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.finite_factors", "code": "theorem Ideal.finite_factors {I : Ideal R} (hI : I \u2260 0) :\n    {v : HeightOneSpectrum R | v.asIdeal \u2223 I}.Finite", "start": [43, 1], "end": [52, 83], "kind": "commanddeclaration"}, {"full_name": "Associates.finite_factors", "code": "theorem Associates.finite_factors {I : Ideal R} (hI : I \u2260 0) :\n    \u2200\u1da0 v : HeightOneSpectrum R in Filter.cofinite,\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : \u2124) = 0", "start": [55, 1], "end": [66, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.finite_mulSupport", "code": "theorem finite_mulSupport {I : Ideal R} (hI : I \u2260 0) :\n    (mulSupport fun v : HeightOneSpectrum R => v.maxPowDividing I).Finite", "start": [71, 1], "end": [83, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.finite_mulSupport_coe", "code": "theorem finite_mulSupport_coe {I : Ideal R} (hI : I \u2260 0) :\n    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R\u2070 K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : \u2124)).Finite", "start": [86, 1], "end": [93, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.finite_mulSupport_inv", "code": "theorem finite_mulSupport_inv {I : Ideal R} (hI : I \u2260 0) :\n    (mulSupport fun v : HeightOneSpectrum R => (v.asIdeal : FractionalIdeal R\u2070 K) ^\n      (-((Associates.mk v.asIdeal).count (Associates.mk I).factors : \u2124))).Finite", "start": [96, 1], "end": [103, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.finprod_not_dvd", "code": "theorem finprod_not_dvd (I : Ideal R) (hI : I \u2260 0) :\n    \u00acv.asIdeal ^ ((Associates.mk v.asIdeal).count (Associates.mk I).factors + 1) \u2223\n        \u220f\u1da0 v : HeightOneSpectrum R, v.maxPowDividing I", "start": [106, 1], "end": [120, 77], "kind": "commanddeclaration"}, {"full_name": "Associates.finprod_ne_zero", "code": "theorem Associates.finprod_ne_zero (I : Ideal R) :\n    Associates.mk (\u220f\u1da0 v : HeightOneSpectrum R, v.maxPowDividing I) \u2260 0", "start": [125, 1], "end": [132, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.finprod_count", "code": "theorem finprod_count (I : Ideal R) (hI : I \u2260 0) : (Associates.mk v.asIdeal).count\n    (Associates.mk (\u220f\u1da0 v : HeightOneSpectrum R, v.maxPowDividing I)).factors =\n    (Associates.mk v.asIdeal).count (Associates.mk I).factors", "start": [137, 1], "end": [150, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.finprod_heightOneSpectrum_factorization", "code": "theorem finprod_heightOneSpectrum_factorization (I : Ideal R) (hI : I \u2260 0) :\n    \u220f\u1da0 v : HeightOneSpectrum R, v.maxPowDividing I = I", "start": [153, 1], "end": [165, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.finprod_heightOneSpectrum_factorization_coe", "code": "theorem finprod_heightOneSpectrum_factorization_coe (I : Ideal R) (hI : I \u2260 0) :\n    (\u220f\u1da0 v : HeightOneSpectrum R, (v.asIdeal : FractionalIdeal R\u2070 K) ^\n      ((Associates.mk v.asIdeal).count (Associates.mk I).factors : \u2124)) = I", "start": [168, 1], "end": [176, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/ShrinkingLemma.lean", "imports": ["Mathlib/Topology/ShrinkingLemma.lean", "Mathlib/Topology/EMetricSpace/Paracompact.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "exists_subset_iUnion_ball_radius_lt", "code": "theorem exists_subset_iUnion_ball_radius_lt {r : \u03b9 \u2192 \u211d} (hs : IsClosed s)\n    (uf : \u2200 x \u2208 s, { i | x \u2208 ball (c i) (r i) }.Finite) (us : s \u2286 \u22c3 i, ball (c i) (r i)) :\n    \u2203 r' : \u03b9 \u2192 \u211d, (s \u2286 \u22c3 i, ball (c i) (r' i)) \u2227 \u2200 i, r' i < r i", "start": [34, 1], "end": [46, 52], "kind": "commanddeclaration"}, {"full_name": "exists_iUnion_ball_eq_radius_lt", "code": "theorem exists_iUnion_ball_eq_radius_lt {r : \u03b9 \u2192 \u211d} (uf : \u2200 x, { i | x \u2208 ball (c i) (r i) }.Finite)\n    (uU : \u22c3 i, ball (c i) (r i) = univ) :\n    \u2203 r' : \u03b9 \u2192 \u211d, \u22c3 i, ball (c i) (r' i) = univ \u2227 \u2200 i, r' i < r i", "start": [49, 1], "end": [56, 33], "kind": "commanddeclaration"}, {"full_name": "exists_subset_iUnion_ball_radius_pos_lt", "code": "theorem exists_subset_iUnion_ball_radius_pos_lt {r : \u03b9 \u2192 \u211d} (hr : \u2200 i, 0 < r i) (hs : IsClosed s)\n    (uf : \u2200 x \u2208 s, { i | x \u2208 ball (c i) (r i) }.Finite) (us : s \u2286 \u22c3 i, ball (c i) (r i)) :\n    \u2203 r' : \u03b9 \u2192 \u211d, (s \u2286 \u22c3 i, ball (c i) (r' i)) \u2227 \u2200 i, r' i \u2208 Ioo 0 (r i)", "start": [59, 1], "end": [69, 49], "kind": "commanddeclaration"}, {"full_name": "exists_iUnion_ball_eq_radius_pos_lt", "code": "theorem exists_iUnion_ball_eq_radius_pos_lt {r : \u03b9 \u2192 \u211d} (hr : \u2200 i, 0 < r i)\n    (uf : \u2200 x, { i | x \u2208 ball (c i) (r i) }.Finite) (uU : \u22c3 i, ball (c i) (r i) = univ) :\n    \u2203 r' : \u03b9 \u2192 \u211d, \u22c3 i, ball (c i) (r' i) = univ \u2227 \u2200 i, r' i \u2208 Ioo 0 (r i)", "start": [72, 1], "end": [80, 33], "kind": "commanddeclaration"}, {"full_name": "exists_locallyFinite_subset_iUnion_ball_radius_lt", "code": "theorem exists_locallyFinite_subset_iUnion_ball_radius_lt (hs : IsClosed s) {R : \u03b1 \u2192 \u211d}\n    (hR : \u2200 x \u2208 s, 0 < R x) :\n    \u2203 (\u03b9 : Type u) (c : \u03b9 \u2192 \u03b1) (r r' : \u03b9 \u2192 \u211d),\n      (\u2200 i, c i \u2208 s \u2227 0 < r i \u2227 r i < r' i \u2227 r' i < R (c i)) \u2227\n        (LocallyFinite fun i => ball (c i) (r' i)) \u2227 s \u2286 \u22c3 i, ball (c i) (r i)", "start": [83, 1], "end": [106, 91], "kind": "commanddeclaration"}, {"full_name": "exists_locallyFinite_iUnion_eq_ball_radius_lt", "code": "theorem exists_locallyFinite_iUnion_eq_ball_radius_lt {R : \u03b1 \u2192 \u211d} (hR : \u2200 x, 0 < R x) :\n    \u2203 (\u03b9 : Type u) (c : \u03b9 \u2192 \u03b1) (r r' : \u03b9 \u2192 \u211d),\n      (\u2200 i, 0 < r i \u2227 r i < r' i \u2227 r' i < R (c i)) \u2227\n        (LocallyFinite fun i => ball (c i) (r' i)) \u2227 \u22c3 i, ball (c i) (r i) = univ", "start": [109, 1], "end": [125, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/Opposite.lean", "imports": ["Mathlib/CategoryTheory/Localization/Predicate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.op", "code": "def StrictUniversalPropertyFixedTarget.op {E : Type*} [Category E]\n    (h : StrictUniversalPropertyFixedTarget L W E\u1d52\u1d56) :\n    StrictUniversalPropertyFixedTarget L.op W.op E where\n  inverts := h.inverts.op\n  lift F hF := (h.lift F.rightOp hF.rightOp).leftOp\n  fac F hF := by\n    convert congr_arg Functor.leftOp (h.fac F.rightOp hF.rightOp)\n  uniq F\u2081 F\u2082 eq := by\n    suffices F\u2081.rightOp = F\u2082.rightOp by\n      rw [\u2190 F\u2081.rightOp_leftOp_eq, \u2190 F\u2082.rightOp_leftOp_eq, this]\n    have eq' := congr_arg Functor.rightOp eq\n    exact h.uniq _ _ eq'", "start": [30, 1], "end": [43, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.isLocalization_op", "code": "instance isLocalization_op : W.Q.op.IsLocalization W.op :=\n  Functor.IsLocalization.mk' W.Q.op W.op (strictUniversalPropertyFixedTargetQ W _).op\n    (strictUniversalPropertyFixedTargetQ W _).op", "start": [46, 1], "end": [48, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.op", "code": "instance IsLocalization.op [L.IsLocalization W] : L.op.IsLocalization W.op :=\n  IsLocalization.of_equivalence_target W.Q.op W.op L.op (Localization.equivalenceFromModel L W).op\n    (NatIso.op (Localization.qCompEquivalenceFromModelFunctorIso L W).symm)", "start": [55, 1], "end": [57, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Young/SemistandardTableau.lean", "imports": ["Mathlib/Combinatorics/Young/YoungDiagram.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ssyt", "code": "structure Ssyt (\u03bc : YoungDiagram) where\n  \n  entry : \u2115 \u2192 \u2115 \u2192 \u2115\n  \n  row_weak' : \u2200 {i j1 j2 : \u2115}, j1 < j2 \u2192 (i, j2) \u2208 \u03bc \u2192 entry i j1 \u2264 entry i j2\n  \n  col_strict' : \u2200 {i1 i2 j : \u2115}, i1 < i2 \u2192 (i2, j) \u2208 \u03bc \u2192 entry i1 j < entry i2 j\n  \n  zeros' : \u2200 {i j}, (i, j) \u2209 \u03bc \u2192 entry i j = 0", "start": [47, 1], "end": [61, 47], "kind": "commanddeclaration"}, {"full_name": "Ssyt.funLike", "code": "instance funLike {\u03bc : YoungDiagram} : FunLike (Ssyt \u03bc) \u2115 fun _ \u21a6 \u2115 \u2192 \u2115 where\n  coe := Ssyt.entry\n  coe_injective' T T' h := by\n    cases T\n    cases T'\n    congr", "start": [66, 1], "end": [71, 10], "kind": "commanddeclaration"}, {"full_name": "Ssyt.to_fun_eq_coe", "code": "@[simp]\ntheorem to_fun_eq_coe {\u03bc : YoungDiagram} {T : Ssyt \u03bc} : T.entry = (T : \u2115 \u2192 \u2115 \u2192 \u2115)", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Ssyt.ext", "code": "@[ext]\ntheorem ext {\u03bc : YoungDiagram} {T T' : Ssyt \u03bc} (h : \u2200 i j, T i j = T' i j) : T = T'", "start": [83, 1], "end": [87, 12], "kind": "commanddeclaration"}, {"full_name": "Ssyt.copy", "code": "protected def copy {\u03bc : YoungDiagram} (T : Ssyt \u03bc) (entry' : \u2115 \u2192 \u2115 \u2192 \u2115) (h : entry' = T) : Ssyt \u03bc\n    where\n  entry := entry'\n  row_weak' := h.symm \u25b8 T.row_weak'\n  col_strict' := h.symm \u25b8 T.col_strict'\n  zeros' := h.symm \u25b8 T.zeros'", "start": [90, 1], "end": [97, 30], "kind": "commanddeclaration"}, {"full_name": "Ssyt.coe_copy", "code": "@[simp]\ntheorem coe_copy {\u03bc : YoungDiagram} (T : Ssyt \u03bc) (entry' : \u2115 \u2192 \u2115 \u2192 \u2115) (h : entry' = T) :\n    \u21d1(T.copy entry' h) = entry'", "start": [100, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Ssyt.copy_eq", "code": "theorem copy_eq {\u03bc : YoungDiagram} (T : Ssyt \u03bc) (entry' : \u2115 \u2192 \u2115 \u2192 \u2115) (h : entry' = T) :\n    T.copy entry' h = T", "start": [106, 1], "end": [108, 17], "kind": "commanddeclaration"}, {"full_name": "Ssyt.row_weak", "code": "theorem row_weak {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i j1 j2 : \u2115} (hj : j1 < j2)\n    (hcell : (i, j2) \u2208 \u03bc) : T i j1 \u2264 T i j2", "start": [111, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "Ssyt.col_strict", "code": "theorem col_strict {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i1 i2 j : \u2115} (hi : i1 < i2)\n    (hcell : (i2, j) \u2208 \u03bc) : T i1 j < T i2 j", "start": [116, 1], "end": [118, 25], "kind": "commanddeclaration"}, {"full_name": "Ssyt.zeros", "code": "theorem zeros {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i j : \u2115} (not_cell : (i, j) \u2209 \u03bc) : T i j = 0", "start": [121, 1], "end": [122, 20], "kind": "commanddeclaration"}, {"full_name": "Ssyt.row_weak_of_le", "code": "theorem row_weak_of_le {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i j1 j2 : \u2115} (hj : j1 \u2264 j2)\n    (cell : (i, j2) \u2208 \u03bc) : T i j1 \u2264 T i j2", "start": [125, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "Ssyt.col_weak", "code": "theorem col_weak {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i1 i2 j : \u2115} (hi : i1 \u2264 i2) (cell : (i2, j) \u2208 \u03bc) :\n    T i1 j \u2264 T i2 j", "start": [132, 1], "end": [136, 41], "kind": "commanddeclaration"}, {"full_name": "Ssyt.highestWeight", "code": "def highestWeight (\u03bc : YoungDiagram) : Ssyt \u03bc where\n  entry i j := if (i, j) \u2208 \u03bc then i else 0\n  row_weak' hj hcell := by\n    simp only\n    rw [if_pos hcell, if_pos (\u03bc.up_left_mem (by rfl) (le_of_lt hj) hcell)]\n  col_strict' hi hcell := by\n    simp only\n    rwa [if_pos hcell, if_pos (\u03bc.up_left_mem (le_of_lt hi) (by rfl) hcell)]\n  zeros' not_cell := if_neg not_cell", "start": [139, 1], "end": [148, 37], "kind": "commanddeclaration"}, {"full_name": "Ssyt.highestWeight_apply", "code": "@[simp]\ntheorem highestWeight_apply {\u03bc : YoungDiagram} {i j : \u2115} :\n    highestWeight \u03bc i j = if (i, j) \u2208 \u03bc then i else 0", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/Tactic/Widget/Gcongr.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/Tactic/Ring/Basic.lean", "Mathlib/Tactic/SudoSetOption.lean", "Mathlib/Tactic/ModCases.lean", "Mathlib/Tactic/Find.lean", "Mathlib/Tactic/DefEqTransformations.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Tactic/NormNum/Pow.lean", "Mathlib/Tactic/ProjectionNotation.lean", "Mathlib/Tactic/Eqns.lean", "Mathlib/Tactic/RunCmd.lean", "Mathlib/Tactic/Tauto.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Tactic/SimpRw.lean", "Mathlib/Tactic/Continuity/Init.lean", "Mathlib/Tactic/NormNum/Prime.lean", "Mathlib/Tactic/PrintPrefix.lean", "Mathlib/Tactic/Use.lean", "Mathlib/Tactic/Clear_.lean", "Mathlib/Tactic/SuccessIfFailWithMsg.lean", "Mathlib/Tactic/NormNum/OfScientific.lean", "Mathlib/Tactic/Attr/Register.lean", "Mathlib/Tactic/Lift.lean", "Mathlib/Tactic/Observe.lean", "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "Mathlib/Tactic/PushNeg.lean", "Mathlib/Tactic/LinearCombination.lean", "Mathlib/Tactic/ClearExcept.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Tactic/Continuity.lean", "Mathlib/Tactic/Linarith/Frontend.lean", "Mathlib/Tactic/Widget/CommDiag.lean", "Mathlib/Tactic/ApplyCongr.lean", "Mathlib/Tactic/CategoryTheory/Slice.lean", "Mathlib/Tactic/CategoryTheory/Reassoc.lean", "Mathlib/Tactic/Polyrith.lean", "Mathlib/Tactic/FailIfNoProgress.lean", "Mathlib/Tactic/GuardGoalNums.lean", "Mathlib/Tactic/Have.lean", "Mathlib/Tactic/Ring/RingNF.lean", "Mathlib/Tactic/ToLevel.lean", "Mathlib/Tactic/Linarith/Elimination.lean", "Mathlib/Tactic/DeriveToExpr.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Tactic/Substs.lean", "Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/Tactic/Clean.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Tactic/Measurability/Init.lean", "Mathlib/Tactic/Nontriviality/Core.lean", "Mathlib/Tactic/CategoryTheory/Coherence.lean", "Mathlib/Tactic/RenameBVar.lean", "Mathlib/Tactic/MkIffOfInductiveProp.lean", "Mathlib/Tactic/Monotonicity/Attr.lean", "Mathlib/Tactic/CancelDenoms.lean", "Mathlib/Tactic/Convert.lean", "Mathlib/Tactic/GCongr/ForwardAttr.lean", "Mathlib/Tactic/ProxyType.lean", "Mathlib/Tactic/Positivity/Core.lean", "Mathlib/Tactic/Cache.lean", "Mathlib/Tactic/Says.lean", "Mathlib/Tactic/InferParam.lean", "Mathlib/Tactic/Congr!.lean", "Mathlib/Tactic/TermCongr.lean", "Mathlib/Tactic/ByContra.lean", "Mathlib/Tactic/Backtrack.lean", "Mathlib/Tactic/Coe.lean", "Mathlib/Tactic/CasesM.lean", "Mathlib/Tactic/UnsetOption.lean", "Mathlib/Tactic/Linarith/Parsing.lean", "Mathlib/Tactic/NormNum/Result.lean", "Mathlib/Tactic/Widget/Conv.lean", "Mathlib/Tactic/ScopedNS.lean", "Mathlib/Tactic/RSuffices.lean", "Mathlib/Tactic/CancelDenoms/Core.lean", "Mathlib/Tactic/NormCast/Tactic.lean", "Mathlib/Tactic/Set.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/NormNum/NatSqrt.lean", "Mathlib/Tactic/Inhabit.lean", "Mathlib/Tactic/GuardHypNums.lean", "Mathlib/Tactic/Explode/Datatypes.lean", "Mathlib/Tactic/Qify.lean", "Mathlib/Tactic/MoveAdd.lean", "Mathlib/Tactic/Measurability.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Tactic/TryThis.lean", "Mathlib/Tactic/IrreducibleDef.lean", "Mathlib/Tactic/Propose.lean", "Mathlib/Tactic/NormNum/NatFib.lean", "Mathlib/Tactic/NormNum/Inv.lean", "Mathlib/Tactic/Monotonicity/Basic.lean", "Mathlib/Tactic/Rewrites.lean", "Mathlib/Tactic/Sat/FromLRAT.lean", "Mathlib/Tactic/ToExpr.lean", "Mathlib/Tactic/Group.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Tactic/LeftRight.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Tactic/ExtractGoal.lean", "Mathlib/Tactic/PermuteGoals.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/HaveI.lean", "Mathlib/Tactic/Attr/Core.lean", "Mathlib/Tactic/Widget/Calc.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/Tactic/NormNum/LegendreSymbol.lean", "Mathlib/Tactic/NormNum.lean", "Mathlib/Tactic/SetLike.lean", "Mathlib/Tactic/ToAdditive.lean", "Mathlib/Tactic/Variable.lean", "Mathlib/Tactic/NormNum/BigOperators.lean", "Mathlib/Tactic/LiftLets.lean", "Mathlib/Tactic/ApplyWith.lean", "Mathlib/Tactic/Widget/SelectInsertParamsClass.lean", "Mathlib/Tactic/SwapVar.lean", "Mathlib/Tactic/Lint.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Tactic/Linarith/Verification.lean", "Mathlib/Tactic/GeneralizeProofs.lean", "Mathlib/Tactic/CategoryTheory/BicategoryCoherence.lean", "Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Tactic/Linarith/Preprocessing.lean", "Mathlib/Tactic/Linarith/Datatypes.lean", "Mathlib/Tactic/SuppressCompilation.lean", "Mathlib/Tactic/Explode.lean", "Mathlib/Tactic/NormNum/Eq.lean", "Mathlib/Tactic/Recover.lean", "Mathlib/Tactic/NormNum/IsCoprime.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Tactic/ExtractLets.lean", "Mathlib/Tactic/ComputeDegree.lean", "Mathlib/Tactic/Conv.lean", "Mathlib/Tactic/Congrm.lean", "Mathlib/Tactic/Monotonicity.lean", "Mathlib/Tactic/Trace.lean", "Mathlib/Tactic/Clear!.lean", "Mathlib/Tactic/NoncommRing.lean", "Mathlib/Tactic/Simps/Basic.lean", "Mathlib/Tactic/Linarith/Lemmas.lean", "Mathlib/Tactic/Replace.lean", "Mathlib/Tactic/Monotonicity/Lemmas.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Tactic/DeriveFintype.lean", "Mathlib/Tactic/NormNum/Core.lean", "Mathlib/Tactic/NormCast.lean", "Mathlib/Tactic/Existsi.lean", "Mathlib/Tactic/Relation/Rfl.lean", "Mathlib/Tactic/TypeCheck.lean", "Mathlib/Tactic/Contrapose.lean", "Mathlib/Tactic/SlimCheck.lean", "Mathlib/Tactic/Zify.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/Tactic/Choose.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Tactic/Change.lean", "Mathlib/Tactic/FBinop.lean", "Mathlib/Tactic/HelpCmd.lean", "Mathlib/Tactic/LibrarySearch.lean", "Mathlib/Tactic/Simps/NotationClass.lean", "Mathlib/Tactic/Rename.lean", "Mathlib/Tactic/Widget/Congrm.lean", "Mathlib/Tactic/NormNum/Ineq.lean", "Mathlib/Tactic/DeriveTraversable.lean", "Mathlib/Tactic/SplitIfs.lean", "Mathlib/Tactic/Relation/Trans.lean", "Mathlib/Tactic/WLOG.lean", "Mathlib/Tactic/FieldSimp.lean", "Mathlib/Tactic/Explode/Pretty.lean", "Mathlib/Tactic/HigherOrder.lean", "Mathlib/Tactic/SimpIntro.lean", "Mathlib/Tactic/Recall.lean", "Mathlib/Tactic/NormNum/GCD.lean", "Mathlib/Tactic/Positivity/Basic.lean", "Mathlib/Tactic/Constructor.lean"], "premises": []}
{"path": "Mathlib/Analysis/Complex/OpenMapping.lean", "imports": ["Mathlib/Analysis/Analytic/IsolatedZeros.lean", "Mathlib/Analysis/Complex/AbsMax.lean", "Mathlib/Analysis/Complex/CauchyIntegral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DiffContOnCl.ball_subset_image_closedBall", "code": "theorem DiffContOnCl.ball_subset_image_closedBall (h : DiffContOnCl \u2102 f (ball z\u2080 r)) (hr : 0 < r)\n    (hf : \u2200 z \u2208 sphere z\u2080 r, \u03b5 \u2264 \u2016f z - f z\u2080\u2016) (hz\u2080 : \u2203\u1da0 z in \ud835\udcdd z\u2080, f z \u2260 f z\u2080) :\n    ball (f z\u2080) (\u03b5 / 2) \u2286 f '' closedBall z\u2080 r", "start": [42, 1], "end": [70, 82], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux", "code": "theorem AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux (hf : AnalyticAt \u2102 f z\u2080) :\n    (\u2200\u1da0 z in \ud835\udcdd z\u2080, f z = f z\u2080) \u2228 \ud835\udcdd (f z\u2080) \u2264 map f (\ud835\udcdd z\u2080)", "start": [73, 1], "end": [106, 65], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.eventually_constant_or_nhds_le_map_nhds", "code": "theorem AnalyticAt.eventually_constant_or_nhds_le_map_nhds {z\u2080 : E} (hg : AnalyticAt \u2102 g z\u2080) :\n    (\u2200\u1da0 z in \ud835\udcdd z\u2080, g z = g z\u2080) \u2228 \ud835\udcdd (g z\u2080) \u2264 map g (\ud835\udcdd z\u2080)", "start": [109, 1], "end": [157, 30], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.is_constant_or_isOpen", "code": "theorem AnalyticOn.is_constant_or_isOpen (hg : AnalyticOn \u2102 g U) (hU : IsPreconnected U) :\n    (\u2203 w, \u2200 z \u2208 U, g z = w) \u2228 \u2200 (s) (_ : s \u2286 U), IsOpen s \u2192 IsOpen (g '' s)", "start": [160, 1], "end": [172, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/MeanErgodic.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Projection.lean", "Mathlib/Dynamics/BirkhoffSum/NormedSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure", "code": "theorem LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure [NormedSpace \ud835\udd5c E]\n    (f : E \u2192\u2097[\ud835\udd5c] E) (hf : LipschitzWith 1 f) (g : E \u2192L[\ud835\udd5c] LinearMap.eqLocus f 1)\n    (hg_proj : \u2200 x : LinearMap.eqLocus f 1, g x = x)\n    (hg_ker : (LinearMap.ker g : Set E) \u2286 closure (LinearMap.range (f - 1))) (x : E) :\n    Tendsto (birkhoffAverage \ud835\udd5c f _root_.id \u00b7 x) atTop (\ud835\udcdd (g x))", "start": [27, 1], "end": [71, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.tendsto_birkhoffAverage_orthogonalProjection", "code": "theorem ContinuousLinearMap.tendsto_birkhoffAverage_orthogonalProjection (f : E \u2192L[\ud835\udd5c] E)\n    (hf : \u2016f\u2016 \u2264 1) (x : E) :\n    Tendsto (birkhoffAverage \ud835\udd5c f _root_.id \u00b7 x) atTop\n      (\ud835\udcdd <| orthogonalProjection (LinearMap.eqLocus f 1) x)", "start": [77, 1], "end": [103, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/PerfectClosure.lean", "imports": ["Mathlib/FieldTheory/Perfect.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PerfectClosure.R", "code": "@[mk_iff]\ninductive PerfectClosure.R : \u2115 \u00d7 K \u2192 \u2115 \u00d7 K \u2192 Prop\n  | intro : \u2200 n x, PerfectClosure.R (n, x) (n + 1, frobenius K p x)", "start": [22, 1], "end": [25, 68], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure", "code": "def PerfectClosure : Type u :=\n  Quot (PerfectClosure.R K p)", "start": [28, 1], "end": [30, 30], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk", "code": "def mk (x : \u2115 \u00d7 K) : PerfectClosure K p :=\n  Quot.mk (R K p) x", "start": [43, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_succ_pow", "code": "@[simp] theorem mk_succ_pow (m : \u2115) (x : K) : mk K p \u27e8m + 1, x ^ p\u27e9 = mk K p \u27e8m, x\u27e9", "start": [48, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.quot_mk_eq_mk", "code": "@[simp]\ntheorem quot_mk_eq_mk (x : \u2115 \u00d7 K) : (Quot.mk (R K p) x : PerfectClosure K p) = mk K p x", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.liftOn", "code": "def liftOn {L : Type*} (x : PerfectClosure K p) (f : \u2115 \u00d7 K \u2192 L)\n    (hf : \u2200 x y, R K p x y \u2192 f x = f y) : L :=\n  Quot.liftOn x f hf", "start": [58, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.liftOn_mk", "code": "@[simp]\ntheorem liftOn_mk {L : Sort _} (f : \u2115 \u00d7 K \u2192 L) (hf : \u2200 x y, R K p x y \u2192 f x = f y) (x : \u2115 \u00d7 K) :\n    (mk K p x).liftOn f hf = f x", "start": [65, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on (x : PerfectClosure K p) {q : PerfectClosure K p \u2192 Prop}\n    (h : \u2200 x, q (mk K p x)) : q x", "start": [71, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mul_aux_left", "code": "private theorem mul_aux_left (x1 x2 y : \u2115 \u00d7 K) (H : R K p x1 x2) :\n    mk K p (x1.1 + y.1, (frobenius K p)^[y.1] x1.2 * (frobenius K p)^[x1.1] y.2) =\n      mk K p (x2.1 + y.1, (frobenius K p)^[y.1] x2.2 * (frobenius K p)^[x2.1] y.2)", "start": [79, 1], "end": [87, 20], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mul_aux_right", "code": "private theorem mul_aux_right (x y1 y2 : \u2115 \u00d7 K) (H : R K p y1 y2) :\n    mk K p (x.1 + y1.1, (frobenius K p)^[y1.1] x.2 * (frobenius K p)^[x.1] y1.2) =\n      mk K p (x.1 + y2.1, (frobenius K p)^[y2.1] x.2 * (frobenius K p)^[x.1] y2.2)", "start": [89, 1], "end": [96, 20], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_mul_mk", "code": "@[simp]\ntheorem mk_mul_mk (x y : \u2115 \u00d7 K) :\n    mk K p x * mk K p y =\n      mk K p (x.1 + y.1, (frobenius K p)^[y.1] x.2 * (frobenius K p)^[x.1] y.2)", "start": [108, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.one_def", "code": "theorem one_def : (1 : PerfectClosure K p) = mk K p (0, 1)", "start": [139, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.add_aux_left", "code": "private theorem add_aux_left (x1 x2 y : \u2115 \u00d7 K) (H : R K p x1 x2) :\n    mk K p (x1.1 + y.1, (frobenius K p)^[y.1] x1.2 + (frobenius K p)^[x1.1] y.2) =\n      mk K p (x2.1 + y.1, (frobenius K p)^[y.1] x2.2 + (frobenius K p)^[x2.1] y.2)", "start": [146, 1], "end": [154, 20], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.add_aux_right", "code": "private theorem add_aux_right (x y1 y2 : \u2115 \u00d7 K) (H : R K p y1 y2) :\n    mk K p (x.1 + y1.1, (frobenius K p)^[y1.1] x.2 + (frobenius K p)^[x.1] y1.2) =\n      mk K p (x.1 + y2.1, (frobenius K p)^[y2.1] x.2 + (frobenius K p)^[x.1] y2.2)", "start": [156, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_add_mk", "code": "@[simp]\ntheorem mk_add_mk (x y : \u2115 \u00d7 K) :\n    mk K p x + mk K p y =\n      mk K p (x.1 + y.1, (frobenius K p)^[y.1] x.2 + (frobenius K p)^[x.1] y.2)", "start": [175, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.neg_mk", "code": "@[simp]\ntheorem neg_mk (x : \u2115 \u00d7 K) : -mk K p x = mk K p (x.1, -x.2)", "start": [187, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.zero_def", "code": "theorem zero_def : (0 : PerfectClosure K p) = mk K p (0, 0)", "start": [195, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_zero_zero", "code": "@[simp]\ntheorem mk_zero_zero : mk K p (0, 0) = 0", "start": [199, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_zero", "code": "theorem mk_zero (n : \u2115) : mk K p (n, 0) = 0", "start": [205, 1], "end": [212, 35], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.R.sound", "code": "theorem R.sound (m n : \u2115) (x y : K) (H : (frobenius K p)^[m] x = y) :\n    mk K p (n, x) = mk K p (m + n, y)", "start": [216, 1], "end": [223, 16], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.PerfectClosure.addCommGroup", "code": "instance PerfectClosure.addCommGroup : AddCommGroup (PerfectClosure K p) :=\n  { (inferInstance : Add (PerfectClosure K p)),\n    (inferInstance : Neg (PerfectClosure K p)) with\n    add_assoc := fun e f g =>\n      Quot.inductionOn e fun \u27e8m, x\u27e9 =>\n        Quot.inductionOn f fun \u27e8n, y\u27e9 =>\n          Quot.inductionOn g fun \u27e8s, z\u27e9 => by\n            simp only [quot_mk_eq_mk, mk_add_mk] apply congr_arg (Quot.mk _)\n            simp only [iterate_map_add, \u2190 iterate_add_apply, add_assoc, add_comm s _]\n    zero := 0\n    zero_add := fun e =>\n      Quot.inductionOn e fun \u27e8n, x\u27e9 =>\n        congr_arg (Quot.mk _) <| by\n          simp only [RingHom.iterate_map_zero, iterate_zero_apply, zero_add]\n    add_zero := fun e =>\n      Quot.inductionOn e fun \u27e8n, x\u27e9 =>\n        congr_arg (Quot.mk _) <| by\n          simp only [RingHom.iterate_map_zero, iterate_zero_apply, add_zero]\n    sub_eq_add_neg := fun a b => rfl\n    add_left_neg := fun e =>\n      Quot.inductionOn e fun \u27e8n, x\u27e9 => by\n        simp only [quot_mk_eq_mk, neg_mk, mk_add_mk, RingHom.iterate_map_neg, add_left_neg, mk_zero]\n    add_comm := fun e f =>\n      Quot.inductionOn e fun \u27e8m, x\u27e9 =>\n        Quot.inductionOn f fun \u27e8n, y\u27e9 => congr_arg (Quot.mk _) <| by simp only [add_comm] }", "start": [226, 1], "end": [251, 92], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.PerfectClosure.commRing", "code": "instance PerfectClosure.commRing : CommRing (PerfectClosure K p) :=\n  { PerfectClosure.addCommGroup K p, AddMonoidWithOne.unary,\n    (inferInstance : CommMonoid (PerfectClosure K p)) with\n    zero_mul := fun a => by\n      refine Quot.inductionOn a fun \u27e8m, x\u27e9 => ?_\n      rw [zero_def, quot_mk_eq_mk, mk_mul_mk]\n      simp only [zero_add, iterate_zero, id_eq, RingHom.iterate_map_zero, zero_mul, mk_zero]\n    mul_zero := fun a => by\n      refine Quot.inductionOn a fun \u27e8m, x\u27e9 => ?_\n      rw [zero_def, quot_mk_eq_mk, mk_mul_mk]\n      simp only [zero_add, iterate_zero, id_eq, RingHom.iterate_map_zero, mul_zero, mk_zero]\n    left_distrib := fun e f g =>\n      Quot.inductionOn e fun \u27e8m, x\u27e9 =>\n        Quot.inductionOn f fun \u27e8n, y\u27e9 =>\n          Quot.inductionOn g fun \u27e8s, z\u27e9 => by\n            simp only [quot_mk_eq_mk, mk_add_mk, mk_mul_mk] simp only [add_assoc, add_comm, add_left_comm]\n            apply R.sound\n            simp only [iterate_map_mul, iterate_map_add, \u2190 iterate_add_apply,\n              mul_add, add_comm, add_left_comm]\n    right_distrib := fun e f g =>\n      Quot.inductionOn e fun \u27e8m, x\u27e9 =>\n        Quot.inductionOn f fun \u27e8n, y\u27e9 =>\n          Quot.inductionOn g fun \u27e8s, z\u27e9 => by\n            simp only [quot_mk_eq_mk, mk_add_mk, mk_mul_mk] simp only [add_assoc, add_comm _ s, add_left_comm _ s]\n            apply R.sound\n            simp only [iterate_map_mul, iterate_map_add, \u2190 iterate_add_apply,\n              add_mul, add_comm, add_left_comm] }", "start": [253, 1], "end": [282, 50], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.eq_iff'", "code": "theorem eq_iff' (x y : \u2115 \u00d7 K) :\n    mk K p x = mk K p y \u2194 \u2203 z, (frobenius K p)^[y.1 + z] x.2 = (frobenius K p)^[x.1 + z] y.2", "start": [284, 1], "end": [306, 39], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.nat_cast", "code": "theorem nat_cast (n x : \u2115) : (x : PerfectClosure K p) = mk K p (n, x)", "start": [309, 1], "end": [319, 16], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.int_cast", "code": "theorem int_cast (x : \u2124) : (x : PerfectClosure K p) = mk K p (0, x)", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.nat_cast_eq_iff", "code": "theorem nat_cast_eq_iff (x y : \u2115) : (x : PerfectClosure K p) = y \u2194 (x : K) = y", "start": [327, 1], "end": [332, 41], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.frobenius_mk", "code": "theorem frobenius_mk (x : \u2115 \u00d7 K) :\n    (frobenius (PerfectClosure K p) p : PerfectClosure K p \u2192 PerfectClosure K p) (mk K p x) =\n      mk _ _ (x.1, x.2 ^ p)", "start": [339, 1], "end": [353, 42], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.of", "code": "def of : K \u2192+* PerfectClosure K p where\n  toFun x := mk _ _ (0, x)\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [356, 1], "end": [362, 22], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.of_apply", "code": "theorem of_apply (x : K) : of K p x = mk _ _ (0, x)", "start": [365, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.eq_iff", "code": "theorem eq_iff [CommRing K] [IsReduced K] (p : \u2115) [Fact p.Prime] [CharP K p] (x y : \u2115 \u00d7 K) :\n    Quot.mk (R K p) x = Quot.mk (R K p) y \u2194 (frobenius K p)^[y.1] x.2 = (frobenius K p)^[x.1] y.2", "start": [371, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.mk_inv", "code": "@[simp]\ntheorem mk_inv (x : \u2115 \u00d7 K) : (mk K p x)\u207b\u00b9 = mk K p (x.1, x.2\u207b\u00b9)", "start": [392, 1], "end": [394, 6], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.iterate_frobenius_mk", "code": "@[simp]\ntheorem iterate_frobenius_mk (n : \u2115) (x : K) :\n    (frobenius (PerfectClosure K p) p)^[n] (mk K p \u27e8n, x\u27e9) = of K p x", "start": [431, 1], "end": [435, 59], "kind": "commanddeclaration"}, {"full_name": "PerfectClosure.lift", "code": "noncomputable def lift (L : Type v) [CommSemiring L] [CharP L p] [PerfectRing L p] :\n    (K \u2192+* L) \u2243 (PerfectClosure K p \u2192+* L) where\n  toFun f :=\n    { toFun := by\n        refine' fun e => liftOn e (fun x => (frobeniusEquiv L p).symm^[x.1] (f x.2)) _\n        rintro - - \u27e8n, x\u27e9\n        simp [f.map_frobenius]\n      map_one' := f.map_one\n      map_zero' := f.map_zero\n      map_mul' := by\n        rintro \u27e8n, x\u27e9 \u27e8m, y\u27e9\n        simp only [quot_mk_eq_mk, liftOn_mk, f.map_iterate_frobenius, mk_mul_mk, map_mul,\n          iterate_map_mul]\n        have := LeftInverse.iterate (frobeniusEquiv_symm_apply_frobenius L p)\n        rw [iterate_add_apply, this _ _, add_comm, iterate_add_apply, this _ _]\n      map_add' := by\n        rintro \u27e8n, x\u27e9 \u27e8m, y\u27e9\n        simp only [quot_mk_eq_mk, liftOn_mk, f.map_iterate_frobenius, mk_add_mk, map_add,\n          iterate_map_add]\n        have := LeftInverse.iterate (frobeniusEquiv_symm_apply_frobenius L p)\n        rw [iterate_add_apply, this _ _, add_comm n, iterate_add_apply, this _ _] }\n  invFun f := f.comp (of K p)\n  left_inv f := by ext x; rfl\n  right_inv f := by\n    ext \u27e8n, x\u27e9\n    simp only [quot_mk_eq_mk, RingHom.comp_apply, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,\n      liftOn_mk]\n    apply (injective_frobenius L p).iterate n\n    rw [\u2190 f.map_iterate_frobenius, iterate_frobenius_mk,\n      RightInverse.iterate (frobenius_apply_frobeniusEquiv_symm L p) n]", "start": [437, 1], "end": [468, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/RingHom/Surjective.lean", "imports": ["Mathlib/RingTheory/LocalProperties.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.surjective_stableUnderComposition", "code": "theorem surjective_stableUnderComposition : StableUnderComposition surjective", "start": [26, 1], "end": [27, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.surjective_respectsIso", "code": "theorem surjective_respectsIso : RespectsIso surjective", "start": [30, 1], "end": [33, 21], "kind": "commanddeclaration"}, {"full_name": "RingHom.surjective_stableUnderBaseChange", "code": "theorem surjective_stableUnderBaseChange : StableUnderBaseChange surjective", "start": [36, 1], "end": [46, 89], "kind": "commanddeclaration"}, {"full_name": "RingHom.surjective_ofLocalizationSpan", "code": "theorem surjective_ofLocalizationSpan : OfLocalizationSpan surjective", "start": [51, 1], "end": [74, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Nilpotent.lean", "imports": ["Mathlib/GroupTheory/Sylow.lean", "Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/GroupTheory/Solvable.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/PGroup.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/GroupTheory/QuotientGroup.lean"], "premises": [{"full_name": "upperCentralSeriesStep", "code": "def upperCentralSeriesStep : Subgroup G where\n  carrier := { x : G | \u2200 y : G, x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H }\n  one_mem' y := by simp [Subgroup.one_mem]\n  mul_mem' {a b ha hb y} := by\n    convert Subgroup.mul_mem _ (ha (b * y * b\u207b\u00b9)) (hb y) using 1\n    group\n  inv_mem' {x hx y} := by\n    specialize hx y\u207b\u00b9\n    rw [mul_assoc, inv_inv] at hx \u22a2\n    exact Subgroup.Normal.mem_comm inferInstance hx", "start": [88, 1], "end": [101, 52], "kind": "commanddeclaration"}, {"full_name": "mem_upperCentralSeriesStep", "code": "theorem mem_upperCentralSeriesStep (x : G) :\n    x \u2208 upperCentralSeriesStep H \u2194 \u2200 y, x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 H", "start": [104, 1], "end": [105, 73], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeriesStep_eq_comap_center", "code": "theorem upperCentralSeriesStep_eq_comap_center :\n    upperCentralSeriesStep H = Subgroup.comap (mk' H) (center (G \u29f8 H))", "start": [110, 1], "end": [119, 44], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeriesAux", "code": "def upperCentralSeriesAux : \u2115 \u2192 \u03a3'H : Subgroup G, Normal H\n  | 0 => \u27e8\u22a5, inferInstance\u27e9\n  | n + 1 =>\n    let un := upperCentralSeriesAux n\n    let _un_normal := un.2\n    \u27e8upperCentralSeriesStep un.1, inferInstance\u27e9", "start": [128, 1], "end": [135, 49], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries", "code": "def upperCentralSeries (n : \u2115) : Subgroup G :=\n  (upperCentralSeriesAux G n).1", "start": [138, 1], "end": [140, 32], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_normal", "code": "instance upperCentralSeries_normal (n : \u2115) : Normal (upperCentralSeries G n) :=\n  (upperCentralSeriesAux G n).2", "start": [143, 1], "end": [144, 32], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_zero", "code": "@[simp]\ntheorem upperCentralSeries_zero : upperCentralSeries G 0 = \u22a5", "start": [146, 1], "end": [147, 68], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_one", "code": "@[simp]\ntheorem upperCentralSeries_one : upperCentralSeries G 1 = center G", "start": [150, 1], "end": [155, 86], "kind": "commanddeclaration"}, {"full_name": "mem_upperCentralSeries_succ_iff", "code": "theorem mem_upperCentralSeries_succ_iff (n : \u2115) (x : G) :\n    x \u2208 upperCentralSeries G (n + 1) \u2194 \u2200 y : G, x * y * x\u207b\u00b9 * y\u207b\u00b9 \u2208 upperCentralSeries G n", "start": [158, 1], "end": [162, 10], "kind": "commanddeclaration"}, {"full_name": "Group.IsNilpotent", "code": "class Group.IsNilpotent (G : Type*) [Group G] : Prop where\n  nilpotent' : \u2203 n : \u2115, upperCentralSeries G n = \u22a4", "start": [167, 1], "end": [169, 51], "kind": "commanddeclaration"}, {"full_name": "Group.IsNilpotent.nilpotent", "code": "lemma Group.IsNilpotent.nilpotent (G : Type*) [Group G] [IsNilpotent G] :\n    \u2203 n : \u2115, upperCentralSeries G n = \u22a4 := Group.IsNilpotent.nilpotent'", "start": [173, 1], "end": [174, 72], "kind": "mathlibtacticlemma"}, {"full_name": "IsAscendingCentralSeries", "code": "def IsAscendingCentralSeries (H : \u2115 \u2192 Subgroup G) : Prop :=\n  H 0 = \u22a5 \u2227 \u2200 (x : G) (n : \u2115), x \u2208 H (n + 1) \u2192 \u2200 g, x * g * x\u207b\u00b9 * g\u207b\u00b9 \u2208 H n", "start": [180, 1], "end": [183, 76], "kind": "commanddeclaration"}, {"full_name": "IsDescendingCentralSeries", "code": "def IsDescendingCentralSeries (H : \u2115 \u2192 Subgroup G) :=\n  H 0 = \u22a4 \u2227 \u2200 (x : G) (n : \u2115), x \u2208 H n \u2192 \u2200 g, x * g * x\u207b\u00b9 * g\u207b\u00b9 \u2208 H (n + 1)", "start": [186, 1], "end": [189, 76], "kind": "commanddeclaration"}, {"full_name": "ascending_central_series_le_upper", "code": "theorem ascending_central_series_le_upper (H : \u2115 \u2192 Subgroup G) (hH : IsAscendingCentralSeries H) :\n    \u2200 n : \u2115, H n \u2264 upperCentralSeries G n", "start": [192, 1], "end": [199, 76], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_isAscendingCentralSeries", "code": "theorem upperCentralSeries_isAscendingCentralSeries :\n    IsAscendingCentralSeries (upperCentralSeries G)", "start": [204, 1], "end": [207, 26], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_mono", "code": "theorem upperCentralSeries_mono : Monotone (upperCentralSeries G)", "start": [210, 1], "end": [214, 88], "kind": "commanddeclaration"}, {"full_name": "nilpotent_iff_finite_ascending_central_series", "code": "theorem nilpotent_iff_finite_ascending_central_series :\n    IsNilpotent G \u2194 \u2203 n : \u2115, \u2203 H : \u2115 \u2192 Subgroup G, IsAscendingCentralSeries H \u2227 H n = \u22a4", "start": [217, 1], "end": [227, 51], "kind": "commanddeclaration"}, {"full_name": "is_decending_rev_series_of_is_ascending", "code": "theorem is_decending_rev_series_of_is_ascending {H : \u2115 \u2192 Subgroup G} {n : \u2115} (hn : H n = \u22a4)\n    (hasc : IsAscendingCentralSeries H) : IsDescendingCentralSeries fun m : \u2115 => H (n - m)", "start": [230, 1], "end": [243, 72], "kind": "commanddeclaration"}, {"full_name": "is_ascending_rev_series_of_is_descending", "code": "theorem is_ascending_rev_series_of_is_descending {H : \u2115 \u2192 Subgroup G} {n : \u2115} (hn : H n = \u22a5)\n    (hdesc : IsDescendingCentralSeries H) : IsAscendingCentralSeries fun m : \u2115 => H (n - m)", "start": [246, 1], "end": [257, 72], "kind": "commanddeclaration"}, {"full_name": "nilpotent_iff_finite_descending_central_series", "code": "theorem nilpotent_iff_finite_descending_central_series :\n    IsNilpotent G \u2194 \u2203 n : \u2115, \u2203 H : \u2115 \u2192 Subgroup G, IsDescendingCentralSeries H \u2227 H n = \u22a5", "start": [260, 1], "end": [275, 15], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries", "code": "def lowerCentralSeries (G : Type*) [Group G] : \u2115 \u2192 Subgroup G\n  | 0 => \u22a4\n  | n + 1 => \u2045lowerCentralSeries G n, \u22a4\u2046", "start": [278, 1], "end": [282, 41], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_zero", "code": "@[simp]\ntheorem lowerCentralSeries_zero : lowerCentralSeries G 0 = \u22a4", "start": [287, 1], "end": [288, 68], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_one", "code": "@[simp]\ntheorem lowerCentralSeries_one : lowerCentralSeries G 1 = commutator G", "start": [291, 1], "end": [292, 78], "kind": "commanddeclaration"}, {"full_name": "mem_lowerCentralSeries_succ_iff", "code": "theorem mem_lowerCentralSeries_succ_iff (n : \u2115) (q : G) :\n    q \u2208 lowerCentralSeries G (n + 1) \u2194\n    q \u2208 closure { x | \u2203 p \u2208 lowerCentralSeries G n,\n                        \u2203 q \u2208 (\u22a4 : Subgroup G), p * q * p\u207b\u00b9 * q\u207b\u00b9 = x }", "start": [295, 1], "end": [298, 83], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_succ", "code": "theorem lowerCentralSeries_succ (n : \u2115) :\n    lowerCentralSeries G (n + 1) =\n      closure { x | \u2203 p \u2208 lowerCentralSeries G n, \u2203 q \u2208 (\u22a4 : Subgroup G), p * q * p\u207b\u00b9 * q\u207b\u00b9 = x }", "start": [301, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_normal", "code": "instance lowerCentralSeries_normal (n : \u2115) : Normal (lowerCentralSeries G n) := by\n  induction' n with d hd\n  \u00b7 exact (\u22a4 : Subgroup G).normal_of_characteristic\n  \u00b7 exact @Subgroup.commutator_normal _ _ (lowerCentralSeries G d) \u22a4 hd _", "start": [307, 1], "end": [310, 74], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_antitone", "code": "theorem lowerCentralSeries_antitone : Antitone (lowerCentralSeries G)", "start": [312, 1], "end": [320, 86], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_isDescendingCentralSeries", "code": "theorem lowerCentralSeries_isDescendingCentralSeries :\n    IsDescendingCentralSeries (lowerCentralSeries G)", "start": [323, 1], "end": [328, 50], "kind": "commanddeclaration"}, {"full_name": "descending_central_series_ge_lower", "code": "theorem descending_central_series_ge_lower (H : \u2115 \u2192 Subgroup G) (hH : IsDescendingCentralSeries H) :\n    \u2200 n : \u2115, lowerCentralSeries G n \u2264 H n", "start": [331, 1], "end": [336, 64], "kind": "commanddeclaration"}, {"full_name": "nilpotent_iff_lowerCentralSeries", "code": "theorem nilpotent_iff_lowerCentralSeries : IsNilpotent G \u2194 \u2203 n, lowerCentralSeries G n = \u22a5", "start": [339, 1], "end": [349, 86], "kind": "commanddeclaration"}, {"full_name": "Group.nilpotencyClass", "code": "noncomputable def Group.nilpotencyClass : \u2115 := Nat.find (IsNilpotent.nilpotent G)", "start": [360, 1], "end": [362, 82], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_nilpotencyClass", "code": "@[simp]\ntheorem upperCentralSeries_nilpotencyClass : upperCentralSeries G (Group.nilpotencyClass G) = \u22a4", "start": [367, 1], "end": [369, 42], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries_eq_top_iff_nilpotencyClass_le", "code": "theorem upperCentralSeries_eq_top_iff_nilpotencyClass_le {n : \u2115} :\n    upperCentralSeries G n = \u22a4 \u2194 Group.nilpotencyClass G \u2264 n", "start": [372, 1], "end": [380, 38], "kind": "commanddeclaration"}, {"full_name": "least_ascending_central_series_length_eq_nilpotencyClass", "code": "theorem least_ascending_central_series_length_eq_nilpotencyClass :\n    Nat.find ((nilpotent_iff_finite_ascending_central_series G).mp hG) =\n    Group.nilpotencyClass G", "start": [383, 1], "end": [393, 51], "kind": "commanddeclaration"}, {"full_name": "least_descending_central_series_length_eq_nilpotencyClass", "code": "theorem least_descending_central_series_length_eq_nilpotencyClass :\n    Nat.find ((nilpotent_iff_finite_descending_central_series G).mp hG) =\n    Group.nilpotencyClass G", "start": [396, 1], "end": [412, 15], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_length_eq_nilpotencyClass", "code": "theorem lowerCentralSeries_length_eq_nilpotencyClass :\n    Nat.find (nilpotent_iff_lowerCentralSeries.mp hG) = @Group.nilpotencyClass G _ _", "start": [415, 1], "end": [424, 84], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_nilpotencyClass", "code": "@[simp]\ntheorem lowerCentralSeries_nilpotencyClass :\n    lowerCentralSeries G (Group.nilpotencyClass G) = \u22a5", "start": [427, 1], "end": [431, 63], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_eq_bot_iff_nilpotencyClass_le", "code": "theorem lowerCentralSeries_eq_bot_iff_nilpotencyClass_le {n : \u2115} :\n    lowerCentralSeries G n = \u22a5 \u2194 Group.nilpotencyClass G \u2264 n", "start": [434, 1], "end": [443, 40], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_map_subtype_le", "code": "theorem lowerCentralSeries_map_subtype_le (H : Subgroup G) (n : \u2115) :\n    (lowerCentralSeries H n).map H.subtype \u2264 lowerCentralSeries G n", "start": [448, 1], "end": [455, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isNilpotent", "code": "instance Subgroup.isNilpotent (H : Subgroup G) [hG : IsNilpotent G] : IsNilpotent H := by\n  rw [nilpotent_iff_lowerCentralSeries] at *\n  rcases hG with \u27e8n, hG\u27e9\n  use n\n  have := lowerCentralSeries_map_subtype_le H n\n  simp only [hG, SetLike.le_def, mem_map, forall_apply_eq_imp_iff\u2082, exists_imp] at this\n  exact eq_bot_iff.mpr fun x hx => Subtype.ext (this x \u27e8hx, rfl\u27e9)", "start": [458, 1], "end": [465, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nilpotencyClass_le", "code": "theorem Subgroup.nilpotencyClass_le (H : Subgroup G) [hG : IsNilpotent G] :\n    Group.nilpotencyClass H \u2264 Group.nilpotencyClass G", "start": [468, 1], "end": [477, 66], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_of_subsingleton", "code": "instance (priority := 100) isNilpotent_of_subsingleton [Subsingleton G] : IsNilpotent G :=\n  nilpotent_iff_lowerCentralSeries.2 \u27e80, Subsingleton.elim \u22a4 \u22a5\u27e9", "start": [480, 1], "end": [481, 64], "kind": "commanddeclaration"}, {"full_name": "upperCentralSeries.map", "code": "theorem upperCentralSeries.map {H : Type*} [Group H] {f : G \u2192* H} (h : Function.Surjective f)\n    (n : \u2115) : Subgroup.map f (upperCentralSeries G n) \u2264 upperCentralSeries H n", "start": [484, 1], "end": [490, 45], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries.map", "code": "theorem lowerCentralSeries.map {H : Type*} [Group H] (f : G \u2192* H) (n : \u2115) :\n    Subgroup.map f (lowerCentralSeries G n) \u2264 lowerCentralSeries H n", "start": [493, 1], "end": [503, 90], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_succ_eq_bot", "code": "theorem lowerCentralSeries_succ_eq_bot {n : \u2115} (h : lowerCentralSeries G n \u2264 center G) :\n    lowerCentralSeries G (n + 1) = \u22a5", "start": [506, 1], "end": [511, 36], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_of_ker_le_center", "code": "theorem isNilpotent_of_ker_le_center {H : Type*} [Group H] (f : G \u2192* H) (hf1 : f.ker \u2264 center G)\n    (hH : IsNilpotent H) : IsNilpotent G", "start": [514, 1], "end": [522, 57], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_le_of_ker_le_center", "code": "theorem nilpotencyClass_le_of_ker_le_center {H : Type*} [Group H] (f : G \u2192* H)\n    (hf1 : f.ker \u2264 center G) (hH : IsNilpotent H) :\n    @Group.nilpotencyClass G _ (isNilpotent_of_ker_le_center f hf1 hH) \u2264\n      Group.nilpotencyClass H + 1", "start": [525, 1], "end": [536, 61], "kind": "commanddeclaration"}, {"full_name": "nilpotent_of_surjective", "code": "theorem nilpotent_of_surjective {G' : Type*} [Group G'] [h : IsNilpotent G] (f : G \u2192* G')\n    (hf : Function.Surjective f) : IsNilpotent G'", "start": [539, 1], "end": [549, 63], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_le_of_surjective", "code": "theorem nilpotencyClass_le_of_surjective {G' : Type*} [Group G'] (f : G \u2192* G')\n    (hf : Function.Surjective f) [h : IsNilpotent G] :\n    @Group.nilpotencyClass G' _ (nilpotent_of_surjective _ hf) \u2264 Group.nilpotencyClass G", "start": [553, 1], "end": [566, 63], "kind": "commanddeclaration"}, {"full_name": "nilpotent_of_mulEquiv", "code": "theorem nilpotent_of_mulEquiv {G' : Type*} [Group G'] [_h : IsNilpotent G] (f : G \u2243* G') :\n    IsNilpotent G'", "start": [570, 1], "end": [573, 64], "kind": "commanddeclaration"}, {"full_name": "nilpotent_quotient_of_nilpotent", "code": "instance nilpotent_quotient_of_nilpotent (H : Subgroup G) [H.Normal] [_h : IsNilpotent G] :\n    IsNilpotent (G \u29f8 H) :=\n  nilpotent_of_surjective (QuotientGroup.mk' H) QuotientGroup.mk_surjective", "start": [576, 1], "end": [579, 76], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_quotient_le", "code": "theorem nilpotencyClass_quotient_le (H : Subgroup G) [H.Normal] [_h : IsNilpotent G] :\n    Group.nilpotencyClass (G \u29f8 H) \u2264 Group.nilpotencyClass G", "start": [582, 1], "end": [585, 85], "kind": "commanddeclaration"}, {"full_name": "comap_center_subst", "code": "private theorem comap_center_subst {H\u2081 H\u2082 : Subgroup G} [Normal H\u2081] [Normal H\u2082] (h : H\u2081 = H\u2082) :\n    comap (mk' H\u2081) (center (G \u29f8 H\u2081)) = comap (mk' H\u2082) (center (G \u29f8 H\u2082))", "start": [589, 1], "end": [590, 91], "kind": "commanddeclaration"}, {"full_name": "comap_upperCentralSeries_quotient_center", "code": "theorem comap_upperCentralSeries_quotient_center (n : \u2115) :\n    comap (mk' (center G)) (upperCentralSeries (G \u29f8 center G) n) = upperCentralSeries G n.succ", "start": [592, 1], "end": [607, 56], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_zero_iff_subsingleton", "code": "theorem nilpotencyClass_zero_iff_subsingleton [IsNilpotent G] :\n    Group.nilpotencyClass G = 0 \u2194 Subsingleton G", "start": [611, 1], "end": [615, 60], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_quotient_center", "code": "theorem nilpotencyClass_quotient_center [hH : IsNilpotent G] :\n    Group.nilpotencyClass (G \u29f8 center G) = Group.nilpotencyClass G - 1", "start": [618, 1], "end": [636, 73], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_eq_quotient_center_plus_one", "code": "theorem nilpotencyClass_eq_quotient_center_plus_one [hH : IsNilpotent G] [Nontrivial G] :\n    Group.nilpotencyClass G = Group.nilpotencyClass (G \u29f8 center G) + 1", "start": [640, 1], "end": [648, 9], "kind": "commanddeclaration"}, {"full_name": "of_quotient_center_nilpotent", "code": "theorem of_quotient_center_nilpotent (h : IsNilpotent (G \u29f8 center G)) : IsNilpotent G", "start": [651, 1], "end": [655, 56], "kind": "commanddeclaration"}, {"full_name": "nilpotent_center_quotient_ind", "code": "@[elab_as_elim]\ntheorem nilpotent_center_quotient_ind {P : \u2200 (G) [Group G] [IsNilpotent G], Prop}\n    (G : Type*) [Group G] [IsNilpotent G]\n    (hbase : \u2200 (G) [Group G] [Subsingleton G], P G)\n    (hstep : \u2200 (G) [Group G] [IsNilpotent G], \u2200 _ih : P (G \u29f8 center G), P G) : P G", "start": [658, 1], "end": [672, 28], "kind": "commanddeclaration"}, {"full_name": "derived_le_lower_central", "code": "theorem derived_le_lower_central (n : \u2115) : derivedSeries G n \u2264 lowerCentralSeries G n", "start": [675, 1], "end": [679, 9], "kind": "commanddeclaration"}, {"full_name": "CommGroup.isNilpotent", "code": "instance (priority := 100) CommGroup.isNilpotent {G : Type*} [CommGroup G] : IsNilpotent G := by\n  use 1\n  rw [upperCentralSeries_one]\n  apply CommGroup.center_eq_top", "start": [682, 1], "end": [686, 32], "kind": "commanddeclaration"}, {"full_name": "CommGroup.nilpotencyClass_le_one", "code": "theorem CommGroup.nilpotencyClass_le_one {G : Type*} [CommGroup G] :\n    Group.nilpotencyClass G \u2264 1", "start": [689, 1], "end": [694, 32], "kind": "commanddeclaration"}, {"full_name": "commGroupOfNilpotencyClass", "code": "def commGroupOfNilpotencyClass [IsNilpotent G] (h : Group.nilpotencyClass G \u2264 1) : CommGroup G :=\n  Group.commGroupOfCenterEqTop <| by\n    rw [\u2190 upperCentralSeries_one]\n    exact upperCentralSeries_eq_top_iff_nilpotencyClass_le.mpr h", "start": [697, 1], "end": [701, 65], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_prod", "code": "theorem lowerCentralSeries_prod (n : \u2115) :\n    lowerCentralSeries (G\u2081 \u00d7 G\u2082) n = (lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n)", "start": [708, 1], "end": [719, 84], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_prod", "code": "instance isNilpotent_prod [IsNilpotent G\u2081] [IsNilpotent G\u2082] : IsNilpotent (G\u2081 \u00d7 G\u2082) := by\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine' \u27e8max (Group.nilpotencyClass G\u2081) (Group.nilpotencyClass G\u2082), _\u27e9\n  rw [lowerCentralSeries_prod,\n    lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (le_max_left _ _),\n    lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (le_max_right _ _), bot_prod_bot]", "start": [723, 1], "end": [729, 91], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_prod", "code": "theorem nilpotencyClass_prod [IsNilpotent G\u2081] [IsNilpotent G\u2082] :\n    Group.nilpotencyClass (G\u2081 \u00d7 G\u2082) =\n    max (Group.nilpotencyClass G\u2081) (Group.nilpotencyClass G\u2082)", "start": [732, 1], "end": [738, 46], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_pi_le", "code": "theorem lowerCentralSeries_pi_le (n : \u2115) :\n    lowerCentralSeries (\u2200 i, Gs i) n \u2264 Subgroup.pi Set.univ\n      fun i => lowerCentralSeries (Gs i) n", "start": [748, 1], "end": [759, 62], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_pi_of_bounded_class", "code": "theorem isNilpotent_pi_of_bounded_class [\u2200 i, IsNilpotent (Gs i)] (n : \u2115)\n    (h : \u2200 i, Group.nilpotencyClass (Gs i) \u2264 n) : IsNilpotent (\u2200 i, Gs i)", "start": [763, 1], "end": [772, 67], "kind": "commanddeclaration"}, {"full_name": "lowerCentralSeries_pi_of_finite", "code": "theorem lowerCentralSeries_pi_of_finite [Finite \u03b7] (n : \u2115) :\n    lowerCentralSeries (\u2200 i, Gs i) n = Subgroup.pi Set.univ\n      fun i => lowerCentralSeries (Gs i) n", "start": [782, 1], "end": [793, 62], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_pi", "code": "instance isNilpotent_pi [Finite \u03b7] [\u2200 i, IsNilpotent (Gs i)] : IsNilpotent (\u2200 i, Gs i) := by\n  cases nonempty_fintype \u03b7\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine' \u27e8Finset.univ.sup fun i => Group.nilpotencyClass (Gs i), _\u27e9\n  rw [lowerCentralSeries_pi_of_finite, pi_eq_bot_iff]\n  intro i\n  apply lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr\n  exact\n    @Finset.le_sup _ _ _ _ Finset.univ (fun i => Group.nilpotencyClass (Gs i)) _ (Finset.mem_univ i)", "start": [797, 1], "end": [806, 101], "kind": "commanddeclaration"}, {"full_name": "nilpotencyClass_pi", "code": "theorem nilpotencyClass_pi [Fintype \u03b7] [\u2200 i, IsNilpotent (Gs i)] :\n    Group.nilpotencyClass (\u2200 i, Gs i) = Finset.univ.sup fun i => Group.nilpotencyClass (Gs i)", "start": [809, 1], "end": [815, 83], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.to_isSolvable", "code": "instance (priority := 100) IsNilpotent.to_isSolvable [h : IsNilpotent G] : IsSolvable G := by\n  obtain \u27e8n, hn\u27e9 := nilpotent_iff_lowerCentralSeries.1 h\n  use n\n  rw [eq_bot_iff, \u2190 hn]\n  exact derived_le_lower_central n", "start": [820, 1], "end": [825, 35], "kind": "commanddeclaration"}, {"full_name": "normalizerCondition_of_isNilpotent", "code": "theorem normalizerCondition_of_isNilpotent [h : IsNilpotent G] : NormalizerCondition G", "start": [828, 1], "end": [844, 66], "kind": "commanddeclaration"}, {"full_name": "IsPGroup.isNilpotent", "code": "theorem IsPGroup.isNilpotent [Finite G] {p : \u2115} [hp : Fact (Nat.Prime p)] (h : IsPGroup p G) :\n    IsNilpotent G", "start": [855, 1], "end": [871, 45], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_of_product_of_sylow_group", "code": "theorem isNilpotent_of_product_of_sylow_group\n    (e : (\u2200 p : (Fintype.card G).factorization.support, \u2200 P : Sylow p G, (\u2191P : Subgroup G)) \u2243* G) :\n    IsNilpotent G", "start": [876, 1], "end": [886, 34], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_of_finite_tFAE", "code": "theorem isNilpotent_of_finite_tFAE :\n    List.TFAE\n      [IsNilpotent G, NormalizerCondition G, \u2200 H : Subgroup G, IsCoatom H \u2192 H.Normal,\n        \u2200 (p : \u2115) (_hp : Fact p.Prime) (P : Sylow p G), (\u2191P : Subgroup G).Normal,\n        Nonempty\n          ((\u2200 p : (card G).factorization.support, \u2200 P : Sylow p G, (\u2191P : Subgroup G)) \u2243* G)]", "start": [889, 1], "end": [908, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Ends/Properties.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "Mathlib/CategoryTheory/CofilteredSystem.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.end_componentCompl_infinite", "code": "lemma end_componentCompl_infinite (e : G.end) (K : (Finset V)\u1d52\u1d56) :\n    ((e : (j : (Finset V)\u1d52\u1d56) \u2192 G.componentComplFunctor.obj j) K).supp.Infinite := by\n  refine (e.val K).infinite_iff_in_all_ranges.mpr (fun L h => ?_)\n  change Opposite.unop K \u2286 Opposite.unop (Opposite.op L) at h\n  exact \u27e8e.val (Opposite.op L), (e.prop (CategoryTheory.opHomOfLE h))\u27e9", "start": [31, 1], "end": [36, 71], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.compononentComplFunctor_nonempty_of_infinite", "code": "instance compononentComplFunctor_nonempty_of_infinite [Infinite V] (K : (Finset V)\u1d52\u1d56) :\n    Nonempty (G.componentComplFunctor.obj K) := G.componentCompl_nonempty_of_infinite K.unop", "start": [38, 1], "end": [39, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplFunctor_finite", "code": "instance componentComplFunctor_finite [LocallyFinite G] [Fact G.Preconnected]\n    (K : (Finset V)\u1d52\u1d56) : Finite (G.componentComplFunctor.obj K) := G.componentCompl_finite K.unop", "start": [41, 1], "end": [42, 98], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.nonempty_ends_of_infinite", "code": "lemma nonempty_ends_of_infinite [LocallyFinite G] [Fact G.Preconnected] [Infinite V] :\n    G.end.Nonempty := by\n  classical\n  apply nonempty_sections_of_finite_inverse_system G.componentComplFunctor", "start": [44, 1], "end": [48, 75], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Condensed/Abelian.lean", "imports": ["Mathlib/Condensed/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/GroupCat/Abelian.lean", "Mathlib/Algebra/Category/GroupCat/FilteredColimits.lean", "Mathlib/Topology/Sheaves/Abelian.lean"], "premises": [{"full_name": "CondensedAb", "code": "abbrev CondensedAb := Condensed.{u} AddCommGroupCat.{u+1}", "start": [21, 1], "end": [25, 58], "kind": "commanddeclaration"}, {"full_name": "CondensedAb.abelian", "code": "noncomputable instance CondensedAb.abelian :\n    CategoryTheory.Abelian CondensedAb.{u} :=\n  letI : PreservesLimits (forget AddCommGroupCat.{u+1}) :=\n    AddCommGroupCat.forgetPreservesLimits.{u+1}\n  CategoryTheory.sheafIsAbelian", "start": [27, 1], "end": [31, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Star.lean", "imports": ["Mathlib/Algebra/Star/Order.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Data/Rat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Rat/Order.lean"], "premises": []}
{"path": "Mathlib/Algebra/Category/ModuleCat/Simple.lean", "imports": ["Mathlib/CategoryTheory/Simple.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/SimpleModule.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Algebra.lean", "Mathlib/Algebra/Category/ModuleCat/Subobject.lean"], "premises": [{"full_name": "simple_iff_isSimpleModule", "code": "theorem simple_iff_isSimpleModule : Simple (of R M) \u2194 IsSimpleModule R M", "start": [25, 1], "end": [26, 92], "kind": "commanddeclaration"}, {"full_name": "simple_iff_isSimpleModule'", "code": "theorem simple_iff_isSimpleModule' (M : ModuleCat R) : Simple M \u2194 IsSimpleModule R M", "start": [29, 1], "end": [30, 73], "kind": "commanddeclaration"}, {"full_name": "simple_of_isSimpleModule", "code": "instance simple_of_isSimpleModule [IsSimpleModule R M] : Simple (of R M) :=\n  simple_iff_isSimpleModule.mpr \u2039_\u203a", "start": [33, 1], "end": [35, 36], "kind": "commanddeclaration"}, {"full_name": "isSimpleModule_of_simple", "code": "instance isSimpleModule_of_simple (M : ModuleCat R) [Simple M] : IsSimpleModule R M :=\n  simple_iff_isSimpleModule.mp (Simple.of_iso (ofSelfIso M))", "start": [38, 1], "end": [40, 61], "kind": "commanddeclaration"}, {"full_name": "simple_of_finrank_eq_one", "code": "theorem simple_of_finrank_eq_one {k : Type*} [Field k] [Algebra k R] {V : ModuleCat R}\n    (h : finrank k V = 1) : Simple V", "start": [47, 1], "end": [50, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/MeasurableSpace/Card.lean", "imports": ["Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "Mathlib/SetTheory/Cardinal/Cofinality.lean", "Mathlib/SetTheory/Cardinal/Continuum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasurableSpace.generateMeasurableRec", "code": "def generateMeasurableRec (s : Set (Set \u03b1)) : (\u03c9\u2081 : Type u) \u2192 Set (Set \u03b1)\n  | i =>\n    let S := \u22c3 j : Iio i, generateMeasurableRec s (j.1)\n    s \u222a {\u2205} \u222a compl '' S \u222a Set.range fun f : \u2115 \u2192 S => \u22c3 n, (f n).1\n  termination_by generateMeasurableRec s i => i\n  decreasing_by exact j.2", "start": [41, 1], "end": [52, 26], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.self_subset_generateMeasurableRec", "code": "theorem self_subset_generateMeasurableRec (s : Set (Set \u03b1)) (i : \u03c9\u2081) :\n    s \u2286 generateMeasurableRec s i", "start": [55, 1], "end": [59, 19], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.empty_mem_generateMeasurableRec", "code": "theorem empty_mem_generateMeasurableRec (s : Set (Set \u03b1)) (i : \u03c9\u2081) :\n    \u2205 \u2208 generateMeasurableRec s i", "start": [62, 1], "end": [65, 82], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.compl_mem_generateMeasurableRec", "code": "theorem compl_mem_generateMeasurableRec {s : Set (Set \u03b1)} {i j : \u03c9\u2081} (h : j < i) {t : Set \u03b1}\n    (ht : t \u2208 generateMeasurableRec s j) : t\u1d9c \u2208 generateMeasurableRec s i", "start": [68, 1], "end": [71, 81], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.iUnion_mem_generateMeasurableRec", "code": "theorem iUnion_mem_generateMeasurableRec {s : Set (Set \u03b1)} {i : \u03c9\u2081} {f : \u2115 \u2192 Set \u03b1}\n    (hf : \u2200 n, \u2203 j < i, f n \u2208 generateMeasurableRec s j) :\n    (\u22c3 n, f n) \u2208 generateMeasurableRec s i", "start": [74, 1], "end": [78, 101], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateMeasurableRec_subset", "code": "theorem generateMeasurableRec_subset (s : Set (Set \u03b1)) {i j : \u03c9\u2081} (h : i \u2264 j) :\n    generateMeasurableRec s i \u2286 generateMeasurableRec s j", "start": [81, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.cardinal_generateMeasurableRec_le", "code": "theorem cardinal_generateMeasurableRec_le (s : Set (Set \u03b1)) (i : \u03c9\u2081) :\n    #(generateMeasurableRec s i) \u2264 max #s 2 ^ aleph0.{u}", "start": [89, 1], "end": [113, 49], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateMeasurable_eq_rec", "code": "theorem generateMeasurable_eq_rec (s : Set (Set \u03b1)) :\n    { t | GenerateMeasurable s t } =\n        \u22c3 (i : (Quotient.out (aleph 1).ord).\u03b1), generateMeasurableRec s i", "start": [116, 1], "end": [151, 24], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.cardinal_generateMeasurable_le", "code": "theorem cardinal_generateMeasurable_le (s : Set (Set \u03b1)) :\n    #{ t | GenerateMeasurable s t } \u2264 max #s 2 ^ aleph0.{u}", "start": [154, 1], "end": [164, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.cardinalMeasurableSet_le", "code": "theorem cardinalMeasurableSet_le (s : Set (Set \u03b1)) :\n    #{ t | @MeasurableSet \u03b1 (generateFrom s) t } \u2264 max #s 2 ^ aleph0.{u}", "start": [167, 1], "end": [171, 35], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.cardinal_generateMeasurable_le_continuum", "code": "theorem cardinal_generateMeasurable_le_continuum {s : Set (Set \u03b1)} (hs : #s \u2264 \ud835\udd20) :\n    #{ t | GenerateMeasurable s t } \u2264 \ud835\udd20", "start": [174, 1], "end": [181, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.cardinal_measurableSet_le_continuum", "code": "theorem cardinal_measurableSet_le_continuum {s : Set (Set \u03b1)} :\n    #s \u2264 \ud835\udd20 \u2192 #{ t | @MeasurableSet \u03b1 (generateFrom s) t } \u2264 \ud835\udd20", "start": [184, 1], "end": [188, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/SmallComplete.lean", "imports": ["Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Computability/Ackermann.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Computability/Primrec.lean", "Mathlib/Tactic/Linarith.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ack", "code": "def ack : \u2115 \u2192 \u2115 \u2192 \u2115\n  | 0, n => n + 1\n  | m + 1, 0 => ack m 1\n  | m + 1, n + 1 => ack m (ack (m + 1) n)\n  termination_by ack m n => (m, n)", "start": [54, 1], "end": [66, 35], "kind": "commanddeclaration"}, {"full_name": "ack_zero", "code": "@[simp]\ntheorem ack_zero (n : \u2115) : ack 0 n = n + 1", "start": [69, 1], "end": [70, 58], "kind": "commanddeclaration"}, {"full_name": "ack_succ_zero", "code": "@[simp]\ntheorem ack_succ_zero (m : \u2115) : ack (m + 1) 0 = ack m 1", "start": [73, 1], "end": [74, 71], "kind": "commanddeclaration"}, {"full_name": "ack_succ_succ", "code": "@[simp]\ntheorem ack_succ_succ (m n : \u2115) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n)", "start": [77, 1], "end": [78, 93], "kind": "commanddeclaration"}, {"full_name": "ack_one", "code": "@[simp]\ntheorem ack_one (n : \u2115) : ack 1 n = n + 2", "start": [81, 1], "end": [85, 14], "kind": "commanddeclaration"}, {"full_name": "ack_two", "code": "@[simp]\ntheorem ack_two (n : \u2115) : ack 2 n = 2 * n + 3", "start": [88, 1], "end": [92, 21], "kind": "commanddeclaration"}, {"full_name": "ack_three", "code": "@[simp]\ntheorem ack_three (n : \u2115) : ack 3 n = 2 ^ (n + 3) - 3", "start": [96, 1], "end": [104, 22], "kind": "commanddeclaration"}, {"full_name": "ack_pos", "code": "theorem ack_pos : \u2200 m n, 0 < ack m n", "start": [107, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "one_lt_ack_succ_left", "code": "theorem one_lt_ack_succ_left : \u2200 m n, 1 < ack (m + 1) n", "start": [117, 1], "end": [124, 31], "kind": "commanddeclaration"}, {"full_name": "one_lt_ack_succ_right", "code": "theorem one_lt_ack_succ_right : \u2200 m n, 1 < ack m (n + 1)", "start": [127, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "ack_strictMono_right", "code": "theorem ack_strictMono_right : \u2200 m, StrictMono (ack m)", "start": [136, 1], "end": [145, 56], "kind": "commanddeclaration"}, {"full_name": "ack_mono_right", "code": "theorem ack_mono_right (m : \u2115) : Monotone (ack m)", "start": [148, 1], "end": [149, 36], "kind": "commanddeclaration"}, {"full_name": "ack_injective_right", "code": "theorem ack_injective_right (m : \u2115) : Function.Injective (ack m)", "start": [152, 1], "end": [153, 37], "kind": "commanddeclaration"}, {"full_name": "ack_lt_iff_right", "code": "@[simp]\ntheorem ack_lt_iff_right {m n\u2081 n\u2082 : \u2115} : ack m n\u2081 < ack m n\u2082 \u2194 n\u2081 < n\u2082", "start": [156, 1], "end": [158, 37], "kind": "commanddeclaration"}, {"full_name": "ack_le_iff_right", "code": "@[simp]\ntheorem ack_le_iff_right {m n\u2081 n\u2082 : \u2115} : ack m n\u2081 \u2264 ack m n\u2082 \u2194 n\u2081 \u2264 n\u2082", "start": [161, 1], "end": [163, 37], "kind": "commanddeclaration"}, {"full_name": "ack_inj_right", "code": "@[simp]\ntheorem ack_inj_right {m n\u2081 n\u2082 : \u2115} : ack m n\u2081 = ack m n\u2082 \u2194 n\u2081 = n\u2082", "start": [166, 1], "end": [168, 33], "kind": "commanddeclaration"}, {"full_name": "max_ack_right", "code": "theorem max_ack_right (m n\u2081 n\u2082 : \u2115) : ack m (max n\u2081 n\u2082) = max (ack m n\u2081) (ack m n\u2082)", "start": [171, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "add_lt_ack", "code": "theorem add_lt_ack : \u2200 m n, m + n < ack m n", "start": [175, 1], "end": [186, 42], "kind": "commanddeclaration"}, {"full_name": "add_add_one_le_ack", "code": "theorem add_add_one_le_ack (m n : \u2115) : m + n + 1 \u2264 ack m n", "start": [189, 1], "end": [190, 33], "kind": "commanddeclaration"}, {"full_name": "lt_ack_left", "code": "theorem lt_ack_left (m n : \u2115) : m < ack m n", "start": [193, 1], "end": [194, 53], "kind": "commanddeclaration"}, {"full_name": "lt_ack_right", "code": "theorem lt_ack_right (m n : \u2115) : n < ack m n", "start": [197, 1], "end": [198, 52], "kind": "commanddeclaration"}, {"full_name": "ack_strict_mono_left'", "code": "private theorem ack_strict_mono_left' : \u2200 {m\u2081 m\u2082} (n), m\u2081 < m\u2082 \u2192 ack m\u2081 n < ack m\u2082 n", "start": [202, 1], "end": [216, 53], "kind": "commanddeclaration"}, {"full_name": "ack_strictMono_left", "code": "theorem ack_strictMono_left (n : \u2115) : StrictMono fun m => ack m n", "start": [218, 1], "end": [219, 26], "kind": "commanddeclaration"}, {"full_name": "ack_mono_left", "code": "theorem ack_mono_left (n : \u2115) : Monotone fun m => ack m n", "start": [222, 1], "end": [223, 35], "kind": "commanddeclaration"}, {"full_name": "ack_injective_left", "code": "theorem ack_injective_left (n : \u2115) : Function.Injective fun m => ack m n", "start": [226, 1], "end": [227, 36], "kind": "commanddeclaration"}, {"full_name": "ack_lt_iff_left", "code": "@[simp]\ntheorem ack_lt_iff_left {m\u2081 m\u2082 n : \u2115} : ack m\u2081 n < ack m\u2082 n \u2194 m\u2081 < m\u2082", "start": [230, 1], "end": [232, 36], "kind": "commanddeclaration"}, {"full_name": "ack_le_iff_left", "code": "@[simp]\ntheorem ack_le_iff_left {m\u2081 m\u2082 n : \u2115} : ack m\u2081 n \u2264 ack m\u2082 n \u2194 m\u2081 \u2264 m\u2082", "start": [235, 1], "end": [237, 36], "kind": "commanddeclaration"}, {"full_name": "ack_inj_left", "code": "@[simp]\ntheorem ack_inj_left {m\u2081 m\u2082 n : \u2115} : ack m\u2081 n = ack m\u2082 n \u2194 m\u2081 = m\u2082", "start": [240, 1], "end": [242, 32], "kind": "commanddeclaration"}, {"full_name": "max_ack_left", "code": "theorem max_ack_left (m\u2081 m\u2082 n : \u2115) : ack (max m\u2081 m\u2082) n = max (ack m\u2081 n) (ack m\u2082 n)", "start": [245, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "ack_le_ack", "code": "theorem ack_le_ack {m\u2081 m\u2082 n\u2081 n\u2082 : \u2115} (hm : m\u2081 \u2264 m\u2082) (hn : n\u2081 \u2264 n\u2082) : ack m\u2081 n\u2081 \u2264 ack m\u2082 n\u2082", "start": [249, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "ack_succ_right_le_ack_succ_left", "code": "theorem ack_succ_right_le_ack_succ_left (m n : \u2115) : ack m (n + 1) \u2264 ack (m + 1) n", "start": [253, 1], "end": [258, 13], "kind": "commanddeclaration"}, {"full_name": "sq_le_two_pow_add_one_minus_three", "code": "private theorem sq_le_two_pow_add_one_minus_three (n : \u2115) : n ^ 2 \u2264 2 ^ (n + 1) - 3", "start": [262, 1], "end": [275, 46], "kind": "commanddeclaration"}, {"full_name": "ack_add_one_sq_lt_ack_add_three", "code": "theorem ack_add_one_sq_lt_ack_add_three : \u2200 m n, (ack m n + 1) ^ 2 \u2264 ack (m + 3) n", "start": [277, 1], "end": [285, 13], "kind": "commanddeclaration"}, {"full_name": "ack_ack_lt_ack_max_add_two", "code": "theorem ack_ack_lt_ack_max_add_two (m n k : \u2115) : ack m (ack n k) < ack (max m n + 2) k", "start": [288, 1], "end": [294, 67], "kind": "commanddeclaration"}, {"full_name": "ack_add_one_sq_lt_ack_add_four", "code": "theorem ack_add_one_sq_lt_ack_add_four (m n : \u2115) : ack m ((n + 1) ^ 2) < ack (m + 4) n", "start": [297, 1], "end": [304, 61], "kind": "commanddeclaration"}, {"full_name": "ack_pair_lt", "code": "theorem ack_pair_lt (m n k : \u2115) : ack m (pair n k) < ack (m + 4) (max n k)", "start": [307, 1], "end": [309, 39], "kind": "commanddeclaration"}, {"full_name": "exists_lt_ack_of_nat_primrec", "code": "theorem exists_lt_ack_of_nat_primrec {f : \u2115 \u2192 \u2115} (hf : Nat.Primrec f) :\n    \u2203 m, \u2200 n, f n < ack m n", "start": [312, 1], "end": [378, 87], "kind": "commanddeclaration"}, {"full_name": "not_nat_primrec_ack_self", "code": "theorem not_nat_primrec_ack_self : \u00acNat.Primrec fun n => ack n n", "start": [381, 1], "end": [383, 21], "kind": "commanddeclaration"}, {"full_name": "not_primrec_ack_self", "code": "theorem not_primrec_ack_self : \u00acPrimrec fun n => ack n n", "start": [386, 1], "end": [388, 33], "kind": "commanddeclaration"}, {"full_name": "not_primrec\u2082_ack", "code": "theorem not_primrec\u2082_ack : \u00acPrimrec\u2082 ack", "start": [391, 1], "end": [393, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Pi/Interval.lean", "imports": ["Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Data/Finset/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.Icc_eq", "code": "theorem Icc_eq : Icc a b = piFinset fun i => Icc (a i) (b i)", "start": [38, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Icc", "code": "theorem card_Icc : (Icc a b).card = \u220f i, (Icc (a i) (b i)).card", "start": [42, 1], "end": [43, 18], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Ico", "code": "theorem card_Ico : (Ico a b).card = (\u220f i, (Icc (a i) (b i)).card) - 1", "start": [46, 1], "end": [47, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Ioc", "code": "theorem card_Ioc : (Ioc a b).card = (\u220f i, (Icc (a i) (b i)).card) - 1", "start": [50, 1], "end": [51, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Ioo", "code": "theorem card_Ioo : (Ioo a b).card = (\u220f i, (Icc (a i) (b i)).card) - 2", "start": [54, 1], "end": [55, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Iic", "code": "theorem card_Iic : (Iic b).card = \u220f i, (Iic (b i)).card", "start": [67, 1], "end": [68, 18], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Iio", "code": "theorem card_Iio : (Iio b).card = (\u220f i, (Iic (b i)).card) - 1", "start": [71, 1], "end": [72, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Ici", "code": "theorem card_Ici : (Ici a).card = \u220f i, (Ici (a i)).card", "start": [84, 1], "end": [85, 18], "kind": "commanddeclaration"}, {"full_name": "Pi.card_Ioi", "code": "theorem card_Ioi : (Ioi a).card = (\u220f i, (Ici (a i)).card) - 1", "start": [88, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.uIcc_eq", "code": "theorem uIcc_eq : uIcc a b = piFinset fun i => uIcc (a i) (b i)", "start": [98, 1], "end": [98, 71], "kind": "commanddeclaration"}, {"full_name": "Pi.card_uIcc", "code": "theorem card_uIcc : (uIcc a b).card = \u220f i, (uIcc (a i) (b i)).card", "start": [101, 1], "end": [101, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat/Kernels.lean", "imports": ["Mathlib/Analysis/Normed/Group/SemiNormedGroupCat.lean", "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "Mathlib/Analysis/Normed/Group/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiNormedGroupCat\u2081.cokernelCocone", "code": "def cokernelCocone {X Y : SemiNormedGroupCat\u2081.{u}} (f : X \u27f6 Y) : Cofork f 0 :=\n  Cofork.of\u03c0\n    (@SemiNormedGroupCat\u2081.mkHom _ (SemiNormedGroupCat.of (Y \u29f8 NormedAddGroupHom.range f.1))\n      f.1.range.normedMk (NormedAddGroupHom.isQuotientQuotient _).norm_le)\n    (by\n      ext x\n      erw [Limits.zero_comp, comp_apply, SemiNormedGroupCat\u2081.mkHom_apply,\n        SemiNormedGroupCat\u2081.zero_apply, \u2190 NormedAddGroupHom.mem_ker, f.1.range.ker_normedMk,\n        f.1.mem_range]\n      use x\n      rfl)", "start": [37, 1], "end": [53, 11], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.cokernelLift", "code": "def cokernelLift {X Y : SemiNormedGroupCat\u2081.{u}} (f : X \u27f6 Y) (s : CokernelCofork f) :\n    (cokernelCocone f).pt \u27f6 s.pt := by\n  fconstructor\n  \u00b7 apply NormedAddGroupHom.lift _ s.\u03c0.1\n    rintro _ \u27e8b, rfl\u27e9\n    change (f \u226b s.\u03c0) b = 0\n    simp\n    erw [zero_apply]\n  exact NormedAddGroupHom.lift_normNoninc _ _ _ s.\u03c0.2", "start": [57, 1], "end": [69, 54], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.fork", "code": "def fork {V W : SemiNormedGroupCat.{u}} (f g : V \u27f6 W) : Fork f g :=\n  @Fork.of\u03b9 _ _ _ _ _ _ (of (f - g : NormedAddGroupHom V W).ker)\n    (NormedAddGroupHom.incl (f - g).ker) <| by\n    change NormedAddGroupHom V W at f g\n    ext v\n    have : v.1 \u2208 (f - g).ker := v.2\n    simpa only [NormedAddGroupHom.incl_apply, Pi.zero_apply, coe_comp, NormedAddGroupHom.coe_zero,\n      NormedAddGroupHom.mem_ker, NormedAddGroupHom.coe_sub, Pi.sub_apply,\n      sub_eq_zero] using this", "start": [109, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.hasLimit_parallelPair", "code": "instance hasLimit_parallelPair {V W : SemiNormedGroupCat.{u}} (f g : V \u27f6 W) :\n    HasLimit (parallelPair f g) where\n  exists_limit :=\n    Nonempty.intro\n      { cone := fork f g\n        isLimit :=\n          Fork.IsLimit.mk _\n            (fun c =>\n              NormedAddGroupHom.ker.lift (Fork.\u03b9 c) _ <|\n                show NormedAddGroupHom.compHom (f - g) c.\u03b9 = 0 by\n                  rw [AddMonoidHom.map_sub, AddMonoidHom.sub_apply, sub_eq_zero]; exact c.condition)\n            (fun c => NormedAddGroupHom.ker.incl_comp_lift _ _ _) fun c g h => by\n        ext x; dsimp; simp_rw [\u2190 h]; rfl}", "start": [123, 1], "end": [136, 48], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.cokernelCocone", "code": "noncomputable\ndef cokernelCocone {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) : Cofork f 0 :=\n  @Cofork.of\u03c0 _ _ _ _ _ _ (SemiNormedGroupCat.of (Y \u29f8 NormedAddGroupHom.range f)) f.range.normedMk\n    (by\n      ext a\n      simp only [comp_apply, Limits.zero_comp]\n      erw [comp_apply, NormedAddGroupHom.zero_apply]\n      letI : SeminormedAddCommGroup ((forget SemiNormedGroupCat).obj Y) :=\n        (inferInstance : SeminormedAddCommGroup Y)\n      erw [ \u2190NormedAddGroupHom.mem_ker, f.range.ker_normedMk, f.mem_range]\n    convert exists_apply_eq_apply f a)", "start": [150, 1], "end": [167, 41], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.cokernelLift", "code": "noncomputable\ndef cokernelLift {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) (s : CokernelCofork f) :\n    (cokernelCocone f).pt \u27f6 s.pt :=\n  NormedAddGroupHom.lift _ s.\u03c0\n    (by\n      rintro _ \u27e8b, rfl\u27e9\n      change (f \u226b s.\u03c0) b = 0\n      simp\n      erw [zero_apply])", "start": [171, 1], "end": [181, 24], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.isColimitCokernelCocone", "code": "noncomputable\ndef isColimitCokernelCocone {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    IsColimit (cokernelCocone f) :=\n  isColimitAux _ (cokernelLift f)\n    (fun s => by\n      ext\n      apply NormedAddGroupHom.lift_mk f.range\n      rintro _ \u27e8b, rfl\u27e9\n      change (f \u226b s.\u03c0) b = 0\n      simp\n      erw [zero_apply])\n    fun s m w => NormedAddGroupHom.lift_unique f.range _ _ _ w", "start": [185, 1], "end": [198, 63], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel", "code": "noncomputable\ndef explicitCokernel {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) : SemiNormedGroupCat.{u} :=\n  (cokernelCocone f).pt", "start": [213, 1], "end": [216, 24], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc", "code": "noncomputable\ndef explicitCokernelDesc {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z} (w : f \u226b g = 0) :\n    explicitCokernel f \u27f6 Z :=\n  (isColimitCokernelCocone f).desc (Cofork.of\u03c0 g (by simp [w]))", "start": [220, 1], "end": [224, 64], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0", "code": "noncomputable\ndef explicitCokernel\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) : Y \u27f6 explicitCokernel f :=\n  (cokernelCocone f).\u03b9.app WalkingParallelPair.one", "start": [228, 1], "end": [231, 51], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0_surjective", "code": "theorem explicitCokernel\u03c0_surjective {X Y : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} :\n    Function.Surjective (explicitCokernel\u03c0 f)", "start": [235, 1], "end": [237, 23], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.comp_explicitCokernel\u03c0", "code": "@[simp, reassoc]\ntheorem comp_explicitCokernel\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    f \u226b explicitCokernel\u03c0 f = 0", "start": [241, 1], "end": [245, 7], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0_apply_dom_eq_zero", "code": "@[simp]\ntheorem explicitCokernel\u03c0_apply_dom_eq_zero {X Y : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} (x : X) :\n    (explicitCokernel\u03c0 f) (f x) = 0", "start": [252, 1], "end": [255, 75], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0_desc", "code": "@[simp, reassoc]\ntheorem explicitCokernel\u03c0_desc {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    (w : f \u226b g = 0) : explicitCokernel\u03c0 f \u226b explicitCokernelDesc w = g", "start": [259, 1], "end": [262, 38], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0_desc_apply", "code": "@[simp]\ntheorem explicitCokernel\u03c0_desc_apply {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    {cond : f \u226b g = 0} (x : Y) : explicitCokernelDesc cond (explicitCokernel\u03c0 f x) = g x", "start": [266, 1], "end": [269, 96], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_unique", "code": "theorem explicitCokernelDesc_unique {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    (w : f \u226b g = 0) (e : explicitCokernel f \u27f6 Z) (he : explicitCokernel\u03c0 f \u226b e = g) :\n    e = explicitCokernelDesc w", "start": [273, 1], "end": [280, 13], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_comp_eq_desc", "code": "theorem explicitCokernelDesc_comp_eq_desc {X Y Z W : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    {h : Z \u27f6 W} {cond' : f \u226b g = 0} :\n    explicitCokernelDesc cond' \u226b h =\n      explicitCokernelDesc\n        (show f \u226b g \u226b h = 0 by rw [\u2190 CategoryTheory.Category.assoc, cond', Limits.zero_comp])", "start": [284, 1], "end": [292, 63], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_zero", "code": "@[simp]\ntheorem explicitCokernelDesc_zero {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} :\n    explicitCokernelDesc (show f \u226b (0 : Y \u27f6 Z) = 0 from CategoryTheory.Limits.comp_zero) = 0", "start": [296, 1], "end": [299, 77], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel_hom_ext", "code": "@[ext]\ntheorem explicitCokernel_hom_ext {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y}\n    (e\u2081 e\u2082 : explicitCokernel f \u27f6 Z) (h : explicitCokernel\u03c0 f \u226b e\u2081 = explicitCokernel\u03c0 f \u226b e\u2082) :\n    e\u2081 = e\u2082", "start": [303, 1], "end": [312, 10], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel\u03c0.epi", "code": "instance explicitCokernel\u03c0.epi {X Y : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} :\n    Epi (explicitCokernel\u03c0 f) := by\n  constructor\n  intro Z g h H\n  ext x\n  rw [H]", "start": [316, 1], "end": [324, 9], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.isQuotient_explicitCokernel\u03c0", "code": "theorem isQuotient_explicitCokernel\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    NormedAddGroupHom.IsQuotient (explicitCokernel\u03c0 f)", "start": [328, 1], "end": [330, 41], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.normNoninc_explicitCokernel\u03c0", "code": "theorem normNoninc_explicitCokernel\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    (explicitCokernel\u03c0 f).NormNoninc", "start": [334, 1], "end": [336, 43], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_norm_le_of_norm_le", "code": "theorem explicitCokernelDesc_norm_le_of_norm_le {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y}\n    {g : Y \u27f6 Z} (w : f \u226b g = 0) (c : \u211d\u22650) (h : \u2016g\u2016 \u2264 c) : \u2016explicitCokernelDesc w\u2016 \u2264 c", "start": [342, 1], "end": [344, 41], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_normNoninc", "code": "theorem explicitCokernelDesc_normNoninc {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    {cond : f \u226b g = 0} (hg : g.NormNoninc) : (explicitCokernelDesc cond).NormNoninc", "start": [348, 1], "end": [354, 69], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_comp_eq_zero", "code": "theorem explicitCokernelDesc_comp_eq_zero {X Y Z W : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    {h : Z \u27f6 W} (cond : f \u226b g = 0) (cond2 : g \u226b h = 0) : explicitCokernelDesc cond \u226b h = 0", "start": [358, 1], "end": [361, 15], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelDesc_norm_le", "code": "theorem explicitCokernelDesc_norm_le {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    (w : f \u226b g = 0) : \u2016explicitCokernelDesc w\u2016 \u2264 \u2016g\u2016", "start": [365, 1], "end": [367, 56], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelIso", "code": "noncomputable\ndef explicitCokernelIso {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    explicitCokernel f \u2245 cokernel f :=\n  (isColimitCokernelCocone f).coconePointUniqueUpToIso (colimit.isColimit _)", "start": [371, 1], "end": [375, 77], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelIso_hom_\u03c0", "code": "@[simp]\ntheorem explicitCokernelIso_hom_\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    explicitCokernel\u03c0 f \u226b (explicitCokernelIso f).hom = cokernel.\u03c0 _", "start": [379, 1], "end": [382, 84], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelIso_inv_\u03c0", "code": "@[simp]\ntheorem explicitCokernelIso_inv_\u03c0 {X Y : SemiNormedGroupCat.{u}} (f : X \u27f6 Y) :\n    cokernel.\u03c0 f \u226b (explicitCokernelIso f).inv = explicitCokernel\u03c0 f", "start": [386, 1], "end": [389, 48], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernelIso_hom_desc", "code": "@[simp]\ntheorem explicitCokernelIso_hom_desc {X Y Z : SemiNormedGroupCat.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    (w : f \u226b g = 0) :\n    (explicitCokernelIso f).hom \u226b cokernel.desc f g w = explicitCokernelDesc w", "start": [393, 1], "end": [399, 40], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.explicitCokernel.map", "code": "noncomputable def explicitCokernel.map {A B C D : SemiNormedGroupCat.{u}}\n    {fab : A \u27f6 B} {fbd : B \u27f6 D} {fac : A \u27f6 C} {fcd : C \u27f6 D} (h : fab \u226b fbd = fac \u226b fcd) :\n    explicitCokernel fab \u27f6 explicitCokernel fcd :=\n  @explicitCokernelDesc _ _ _ fab (fbd \u226b explicitCokernel\u03c0 _) <| by simp [reassoc_of% h]", "start": [403, 1], "end": [407, 89], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.ExplicitCoker.map_desc", "code": "theorem ExplicitCoker.map_desc {A B C D B' D' : SemiNormedGroupCat.{u}}\n    {fab : A \u27f6 B} {fbd : B \u27f6 D} {fac : A \u27f6 C} {fcd : C \u27f6 D} {h : fab \u226b fbd = fac \u226b fcd}\n    {fbb' : B \u27f6 B'} {fdd' : D \u27f6 D'} {condb : fab \u226b fbb' = 0} {condd : fcd \u226b fdd' = 0} {g : B' \u27f6 D'}\n    (h' : fbb' \u226b g = fbd \u226b fdd') :\n    explicitCokernelDesc condb \u226b g = explicitCokernel.map h \u226b explicitCokernelDesc condd", "start": [411, 1], "end": [418, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Holor.lean", "imports": ["Mathlib/Algebra/Module/Pi.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HolorIndex", "code": "def HolorIndex (ds : List \u2115) : Type :=\n  { is : List \u2115 // Forall\u2082 (\u00b7 < \u00b7) is ds }", "start": [41, 1], "end": [44, 43], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.take", "code": "def take : \u2200 {ds\u2081 : List \u2115}, HolorIndex (ds\u2081 ++ ds\u2082) \u2192 HolorIndex ds\u2081\n  | ds, is => \u27e8List.take (length ds) is.1, forall\u2082_take_append is.1 ds ds\u2082 is.2\u27e9", "start": [51, 1], "end": [52, 81], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.drop", "code": "def drop : \u2200 {ds\u2081 : List \u2115}, HolorIndex (ds\u2081 ++ ds\u2082) \u2192 HolorIndex ds\u2082\n  | ds, is => \u27e8List.drop (length ds) is.1, forall\u2082_drop_append is.1 ds ds\u2082 is.2\u27e9", "start": [55, 1], "end": [56, 81], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.cast_type", "code": "theorem cast_type (is : List \u2115) (eq : ds\u2081 = ds\u2082) (h : Forall\u2082 (\u00b7 < \u00b7) is ds\u2081) :\n    (cast (congr_arg HolorIndex eq) \u27e8is, h\u27e9).val = is", "start": [59, 1], "end": [60, 74], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.assocRight", "code": "def assocRight : HolorIndex (ds\u2081 ++ ds\u2082 ++ ds\u2083) \u2192 HolorIndex (ds\u2081 ++ (ds\u2082 ++ ds\u2083)) :=\n  cast (congr_arg HolorIndex (append_assoc ds\u2081 ds\u2082 ds\u2083))", "start": [63, 1], "end": [64, 57], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.assocLeft", "code": "def assocLeft : HolorIndex (ds\u2081 ++ (ds\u2082 ++ ds\u2083)) \u2192 HolorIndex (ds\u2081 ++ ds\u2082 ++ ds\u2083) :=\n  cast (congr_arg HolorIndex (append_assoc ds\u2081 ds\u2082 ds\u2083).symm)", "start": [67, 1], "end": [68, 62], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.take_take", "code": "theorem take_take : \u2200 t : HolorIndex (ds\u2081 ++ ds\u2082 ++ ds\u2083), t.assocRight.take = t.take.take", "start": [71, 1], "end": [74, 88], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.drop_take", "code": "theorem drop_take : \u2200 t : HolorIndex (ds\u2081 ++ ds\u2082 ++ ds\u2083), t.assocRight.drop.take = t.take.drop", "start": [77, 1], "end": [78, 88], "kind": "commanddeclaration"}, {"full_name": "HolorIndex.drop_drop", "code": "theorem drop_drop : \u2200 t : HolorIndex (ds\u2081 ++ ds\u2082 ++ ds\u2083), t.assocRight.drop.drop = t.drop", "start": [81, 1], "end": [82, 92], "kind": "commanddeclaration"}, {"full_name": "Holor", "code": "def Holor (\u03b1 : Type u) (ds : List \u2115) :=\n  HolorIndex ds \u2192 \u03b1", "start": [87, 1], "end": [89, 20], "kind": "commanddeclaration"}, {"full_name": "Holor.mul", "code": "def mul [Mul \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2082) : Holor \u03b1 (ds\u2081 ++ ds\u2082) := fun t =>\n  x t.take * y t.drop", "start": [174, 1], "end": [176, 22], "kind": "commanddeclaration"}, {"full_name": "Holor.cast_type", "code": "theorem cast_type (eq : ds\u2081 = ds\u2082) (a : Holor \u03b1 ds\u2081) :\n    cast (congr_arg (Holor \u03b1) eq) a = fun t => a (cast (congr_arg HolorIndex eq.symm) t)", "start": [181, 1], "end": [183, 16], "kind": "commanddeclaration"}, {"full_name": "Holor.assocRight", "code": "def assocRight : Holor \u03b1 (ds\u2081 ++ ds\u2082 ++ ds\u2083) \u2192 Holor \u03b1 (ds\u2081 ++ (ds\u2082 ++ ds\u2083)) :=\n  cast (congr_arg (Holor \u03b1) (append_assoc ds\u2081 ds\u2082 ds\u2083))", "start": [186, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "Holor.assocLeft", "code": "def assocLeft : Holor \u03b1 (ds\u2081 ++ (ds\u2082 ++ ds\u2083)) \u2192 Holor \u03b1 (ds\u2081 ++ ds\u2082 ++ ds\u2083) :=\n  cast (congr_arg (Holor \u03b1) (append_assoc ds\u2081 ds\u2082 ds\u2083).symm)", "start": [190, 1], "end": [191, 61], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_assoc0", "code": "theorem mul_assoc0 [Semigroup \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2082) (z : Holor \u03b1 ds\u2083) :\n    x \u2297 y \u2297 z = (x \u2297 (y \u2297 z)).assocLeft", "start": [194, 1], "end": [201, 22], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_assoc", "code": "theorem mul_assoc [Semigroup \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2082) (z : Holor \u03b1 ds\u2083) :\n    HEq (mul (mul x y) z) (mul x (mul y z))", "start": [204, 1], "end": [205, 89], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_left_distrib", "code": "theorem mul_left_distrib [Distrib \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2082) (z : Holor \u03b1 ds\u2082) :\n    x \u2297 (y + z) = x \u2297 y + x \u2297 z", "start": [208, 1], "end": [209, 97], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_right_distrib", "code": "theorem mul_right_distrib [Distrib \u03b1] (x : Holor \u03b1 ds\u2081) (y : Holor \u03b1 ds\u2081) (z : Holor \u03b1 ds\u2082) :\n    (x + y) \u2297 z = x \u2297 z + y \u2297 z", "start": [212, 1], "end": [213, 92], "kind": "commanddeclaration"}, {"full_name": "Holor.zero_mul", "code": "@[simp]\nnonrec theorem zero_mul {\u03b1 : Type} [Ring \u03b1] (x : Holor \u03b1 ds\u2082) : (0 : Holor \u03b1 ds\u2081) \u2297 x = 0", "start": [216, 1], "end": [218, 51], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_zero", "code": "@[simp]\nnonrec theorem mul_zero {\u03b1 : Type} [Ring \u03b1] (x : Holor \u03b1 ds\u2081) : x \u2297 (0 : Holor \u03b1 ds\u2082) = 0", "start": [221, 1], "end": [223, 51], "kind": "commanddeclaration"}, {"full_name": "Holor.mul_scalar_mul", "code": "theorem mul_scalar_mul [Monoid \u03b1] (x : Holor \u03b1 []) (y : Holor \u03b1 ds) :\n    x \u2297 y = x \u27e8[], Forall\u2082.nil\u27e9 \u2022 y", "start": [226, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Holor.slice", "code": "def slice (x : Holor \u03b1 (d :: ds)) (i : \u2115) (h : i < d) : Holor \u03b1 ds := fun is : HolorIndex ds =>\n  x \u27e8i :: is.1, Forall\u2082.cons h is.2\u27e9", "start": [232, 1], "end": [234, 37], "kind": "commanddeclaration"}, {"full_name": "Holor.unitVec", "code": "def unitVec [Monoid \u03b1] [AddMonoid \u03b1] (d : \u2115) (j : \u2115) : Holor \u03b1 [d] := fun ti =>\n  if ti.1 = [j] then 1 else 0", "start": [237, 1], "end": [239, 30], "kind": "commanddeclaration"}, {"full_name": "Holor.holor_index_cons_decomp", "code": "theorem holor_index_cons_decomp (p : HolorIndex (d :: ds) \u2192 Prop) :\n    \u2200 t : HolorIndex (d :: ds),\n      (\u2200 i is, \u2200 h : t.1 = i :: is, p \u27e8i :: is, by rw [\u2190 h]; exact t.2\u27e9) \u2192 p t", "start": [242, 1], "end": [246, 36], "kind": "commanddeclaration"}, {"full_name": "Holor.slice_eq", "code": "theorem slice_eq (x : Holor \u03b1 (d :: ds)) (y : Holor \u03b1 (d :: ds)) (h : slice x = slice y) : x = y", "start": [249, 1], "end": [259, 72], "kind": "commanddeclaration"}, {"full_name": "Holor.slice_unitVec_mul", "code": "theorem slice_unitVec_mul [Ring \u03b1] {i : \u2115} {j : \u2115} (hid : i < d) (x : Holor \u03b1 ds) :\n    slice (unitVec d j \u2297 x) i hid = if i = j then x else 0", "start": [262, 1], "end": [266, 81], "kind": "commanddeclaration"}, {"full_name": "Holor.slice_add", "code": "theorem slice_add [Add \u03b1] (i : \u2115) (hid : i < d) (x : Holor \u03b1 (d :: ds)) (y : Holor \u03b1 (d :: ds)) :\n    slice x i hid + slice y i hid = slice (x + y) i hid", "start": [269, 1], "end": [271, 52], "kind": "commanddeclaration"}, {"full_name": "Holor.slice_zero", "code": "theorem slice_zero [Zero \u03b1] (i : \u2115) (hid : i < d) : slice (0 : Holor \u03b1 (d :: ds)) i hid = 0", "start": [274, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "Holor.slice_sum", "code": "theorem slice_sum [AddCommMonoid \u03b1] {\u03b2 : Type} (i : \u2115) (hid : i < d) (s : Finset \u03b2)\n    (f : \u03b2 \u2192 Holor \u03b1 (d :: ds)) : (\u2211 x in s, slice (f x) i hid) = slice (\u2211 x in s, f x) i hid", "start": [278, 1], "end": [284, 79], "kind": "commanddeclaration"}, {"full_name": "Holor.sum_unitVec_mul_slice", "code": "@[simp]\ntheorem sum_unitVec_mul_slice [Ring \u03b1] (x : Holor \u03b1 (d :: ds)) :\n    (\u2211 i in (Finset.range d).attach,\n        unitVec d i \u2297 slice x i (Nat.succ_le_of_lt (Finset.mem_range.1 i.prop))) =\n      x", "start": [287, 1], "end": [305, 46], "kind": "commanddeclaration"}, {"full_name": "Holor.CPRankMax1", "code": "inductive CPRankMax1 [Mul \u03b1] : \u2200 {ds}, Holor \u03b1 ds \u2192 Prop\n  | nil (x : Holor \u03b1 []) : CPRankMax1 x\n  | cons {d} {ds} (x : Holor \u03b1 [d]) (y : Holor \u03b1 ds) : CPRankMax1 y \u2192 CPRankMax1 (x \u2297 y)", "start": [309, 1], "end": [313, 89], "kind": "commanddeclaration"}, {"full_name": "Holor.CPRankMax", "code": "inductive CPRankMax [Mul \u03b1] [AddMonoid \u03b1] : \u2115 \u2192 \u2200 {ds}, Holor \u03b1 ds \u2192 Prop\n  | zero {ds} : CPRankMax 0 (0 : Holor \u03b1 ds)\n  | succ (n) {ds} (x : Holor \u03b1 ds) (y : Holor \u03b1 ds) :\n    CPRankMax1 x \u2192 CPRankMax n y \u2192 CPRankMax (n + 1) (x + y)", "start": [316, 1], "end": [321, 61], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_nil", "code": "theorem cprankMax_nil [Monoid \u03b1] [AddMonoid \u03b1] (x : Holor \u03b1 nil) : CPRankMax 1 x", "start": [324, 1], "end": [326, 34], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_1", "code": "theorem cprankMax_1 [Monoid \u03b1] [AddMonoid \u03b1] {x : Holor \u03b1 ds} (h : CPRankMax1 x) :\n    CPRankMax 1 x", "start": [329, 1], "end": [332, 33], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_add", "code": "theorem cprankMax_add [Monoid \u03b1] [AddMonoid \u03b1] :\n    \u2200 {m : \u2115} {n : \u2115} {x : Holor \u03b1 ds} {y : Holor \u03b1 ds},\n      CPRankMax m x \u2192 CPRankMax n y \u2192 CPRankMax (m + n) (x + y)", "start": [335, 1], "end": [347, 33], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_mul", "code": "theorem cprankMax_mul [Ring \u03b1] :\n    \u2200 (n : \u2115) (x : Holor \u03b1 [d]) (y : Holor \u03b1 ds), CPRankMax n y \u2192 CPRankMax n (x \u2297 y)", "start": [350, 1], "end": [358, 37], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_sum", "code": "theorem cprankMax_sum [Ring \u03b1] {\u03b2} {n : \u2115} (s : Finset \u03b2) (f : \u03b2 \u2192 Holor \u03b1 ds) :\n    (\u2200 x \u2208 s, CPRankMax n (f x)) \u2192 CPRankMax (s.card * n) (\u2211 x in s, f x)", "start": [361, 1], "end": [374, 73], "kind": "commanddeclaration"}, {"full_name": "Holor.cprankMax_upper_bound", "code": "theorem cprankMax_upper_bound [Ring \u03b1] : \u2200 {ds}, \u2200 x : Holor \u03b1 ds, CPRankMax ds.prod x", "start": [377, 1], "end": [397, 26], "kind": "commanddeclaration"}, {"full_name": "Holor.cprank", "code": "noncomputable def cprank [Ring \u03b1] (x : Holor \u03b1 ds) : Nat :=\n  @Nat.find (fun n => CPRankMax n x) (Classical.decPred _) \u27e8ds.prod, cprankMax_upper_bound x\u27e9", "start": [400, 1], "end": [403, 94], "kind": "commanddeclaration"}, {"full_name": "Holor.cprank_upper_bound", "code": "theorem cprank_upper_bound [Ring \u03b1] : \u2200 {ds}, \u2200 x : Holor \u03b1 ds, cprank x \u2264 ds.prod", "start": [406, 1], "end": [410, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Ideals.lean", "imports": ["Mathlib/Analysis/NormedSpace/Units.lean", "Mathlib/Data/IsROrC/Basic.lean", "Mathlib/Topology/Algebra/Module/CharacterSpace.lean", "Mathlib/Topology/UrysohnsLemma.lean", "Mathlib/Topology/Algebra/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/ContinuousFunction/Compact.lean"], "premises": [{"full_name": "ContinuousMap.idealOfSet", "code": "def idealOfSet (s : Set X) : Ideal C(X, R) where\n  carrier := {f : C(X, R) | \u2200 x \u2208 s\u1d9c, f x = 0}\n  add_mem' {f g} hf hg x hx := by simp [hf x hx, hg x hx, coe_add, Pi.add_apply, add_zero]\n  zero_mem' _ _ := rfl\n  smul_mem' c f hf x hx := mul_zero (c x) \u25b8 congr_arg (fun y => c x * y) (hf x hx)", "start": [87, 1], "end": [93, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOfSet_closed", "code": "theorem idealOfSet_closed [T2Space R] (s : Set X) :\n    IsClosed (idealOfSet R s : Set C(X, R))", "start": [96, 1], "end": [100, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_idealOfSet", "code": "theorem mem_idealOfSet {s : Set X} {f : C(X, R)} :\n    f \u2208 idealOfSet R s \u2194 \u2200 \u2983x : X\u2984, x \u2208 s\u1d9c \u2192 f x = 0", "start": [105, 1], "end": [107, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.not_mem_idealOfSet", "code": "theorem not_mem_idealOfSet {s : Set X} {f : C(X, R)} : f \u2209 idealOfSet R s \u2194 \u2203 x \u2208 s\u1d9c, f x \u2260 0", "start": [110, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfIdeal", "code": "def setOfIdeal (I : Ideal C(X, R)) : Set X :=\n  {x : X | \u2200 f \u2208 I, (f : C(X, R)) x = 0}\u1d9c", "start": [114, 1], "end": [117, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.not_mem_setOfIdeal", "code": "theorem not_mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x \u2209 setOfIdeal I \u2194 \u2200 \u2983f : C(X, R)\u2984, f \u2208 I \u2192 f x = 0", "start": [120, 1], "end": [122, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_setOfIdeal", "code": "theorem mem_setOfIdeal {I : Ideal C(X, R)} {x : X} :\n    x \u2208 setOfIdeal I \u2194 \u2203 f \u2208 I, (f : C(X, R)) x \u2260 0", "start": [125, 1], "end": [127, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfIdeal_open", "code": "theorem setOfIdeal_open [T2Space R] (I : Ideal C(X, R)) : IsOpen (setOfIdeal I)", "start": [130, 1], "end": [134, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.opensOfIdeal", "code": "@[simps]\ndef opensOfIdeal [T2Space R] (I : Ideal C(X, R)) : Opens X :=\n  \u27e8setOfIdeal I, setOfIdeal_open I\u27e9", "start": [137, 1], "end": [140, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfTop_eq_univ", "code": "@[simp]\ntheorem setOfTop_eq_univ [Nontrivial R] : setOfIdeal (\u22a4 : Ideal C(X, R)) = Set.univ", "start": [143, 1], "end": [145, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOfEmpty_eq_bot", "code": "@[simp]\ntheorem idealOfEmpty_eq_bot : idealOfSet R (\u2205 : Set X) = \u22a5", "start": [148, 1], "end": [152, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mem_idealOfSet_compl_singleton", "code": "@[simp]\ntheorem mem_idealOfSet_compl_singleton (x : X) (f : C(X, R)) :\n    f \u2208 idealOfSet R ({x}\u1d9c : Set X) \u2194 f x = 0", "start": [155, 1], "end": [158, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.ideal_gc", "code": "theorem ideal_gc : GaloisConnection (setOfIdeal : Ideal C(X, R) \u2192 Set X) (idealOfSet R)", "start": [163, 1], "end": [170, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_mul_le_one_eqOn_ge", "code": "theorem exists_mul_le_one_eqOn_ge (f : C(X, \u211d\u22650)) {c : \u211d\u22650} (hc : 0 < c) :\n    \u2203 g : C(X, \u211d\u22650), (\u2200 x : X, (g * f) x \u2264 1) \u2227 {x : X | c \u2264 f x}.EqOn (g * f) 1", "start": [181, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOfSet_ofIdeal_eq_closure", "code": "@[simp]\ntheorem idealOfSet_ofIdeal_eq_closure (I : Ideal C(X, \ud835\udd5c)) :\n    idealOfSet \ud835\udd5c (setOfIdeal I) = I.closure", "start": [198, 1], "end": [303, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOfSet_ofIdeal_isClosed", "code": "theorem idealOfSet_ofIdeal_isClosed {I : Ideal C(X, \ud835\udd5c)} (hI : IsClosed (I : Set C(X, \ud835\udd5c))) :\n    idealOfSet \ud835\udd5c (setOfIdeal I) = I", "start": [306, 1], "end": [308, 86], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfIdeal_ofSet_eq_interior", "code": "@[simp]\ntheorem setOfIdeal_ofSet_eq_interior (s : Set X) : setOfIdeal (idealOfSet \ud835\udd5c s) = interior s", "start": [313, 1], "end": [333, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfIdeal_ofSet_of_isOpen", "code": "theorem setOfIdeal_ofSet_of_isOpen {s : Set X} (hs : IsOpen s) : setOfIdeal (idealOfSet \ud835\udd5c s) = s", "start": [336, 1], "end": [337, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOpensGI", "code": "@[simps]\ndef idealOpensGI : GaloisInsertion (opensOfIdeal : Ideal C(X, \ud835\udd5c) \u2192 Opens X) fun s => idealOfSet \ud835\udd5c s\n    where\n  choice I _ := opensOfIdeal I.closure\n  gc I s := ideal_gc X \ud835\udd5c I s\n  le_l_u s := (setOfIdeal_ofSet_of_isOpen \ud835\udd5c s.isOpen).ge\n  choice_eq I hI :=\n    congr_arg _ <|\n      Ideal.ext\n        (Set.ext_iff.mp\n          (isClosed_of_closure_subset <|\n              (idealOfSet_ofIdeal_eq_closure I \u25b8 hI : I.closure \u2264 I)).closure_eq)", "start": [342, 1], "end": [355, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOfSet_isMaximal_iff", "code": "theorem idealOfSet_isMaximal_iff (s : Opens X) :\n    (idealOfSet \ud835\udd5c (s : Set X)).IsMaximal \u2194 IsCoatom s", "start": [360, 1], "end": [365, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.idealOf_compl_singleton_isMaximal", "code": "theorem idealOf_compl_singleton_isMaximal (x : X) : (idealOfSet \ud835\udd5c ({x}\u1d9c : Set X)).IsMaximal", "start": [368, 1], "end": [369, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.setOfIdeal_eq_compl_singleton", "code": "theorem setOfIdeal_eq_compl_singleton (I : Ideal C(X, \ud835\udd5c)) [hI : I.IsMaximal] :\n    \u2203 x : X, setOfIdeal I = {x}\u1d9c", "start": [374, 1], "end": [379, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.ideal_isMaximal_iff", "code": "theorem ideal_isMaximal_iff (I : Ideal C(X, \ud835\udd5c)) [hI : IsClosed (I : Set C(X, \ud835\udd5c))] :\n    I.IsMaximal \u2194 \u2203 x : X, idealOfSet \ud835\udd5c {x}\u1d9c = I", "start": [382, 1], "end": [393, 42], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.continuousMapEval", "code": "def continuousMapEval : C(X, characterSpace \ud835\udd5c C(X, \ud835\udd5c)) where\n  toFun x :=\n    \u27e8{  toFun := fun f => f x\n        map_add' := fun f g => rfl\n        map_smul' := fun z f => rfl\n        cont := continuous_eval_const x }, by\n        rw [CharacterSpace.eq_set_map_one_map_mul]; exact \u27e8rfl, fun f g => rfl\u27e9\u27e9\n  continuous_toFun := Continuous.subtype_mk (continuous_of_continuous_eval map_continuous) _", "start": [414, 1], "end": [423, 93], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.continuousMapEval_apply_apply", "code": "@[simp]\ntheorem continuousMapEval_apply_apply (x : X) (f : C(X, \ud835\udd5c)) : continuousMapEval X \ud835\udd5c x f = f x", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.continuousMapEval_bijective", "code": "theorem continuousMapEval_bijective : Bijective (continuousMapEval X \ud835\udd5c)", "start": [435, 1], "end": [449, 53], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.homeoEval", "code": "noncomputable def homeoEval : X \u2243\u209c characterSpace \ud835\udd5c C(X, \ud835\udd5c) :=\n  @Continuous.homeoOfEquivCompactToT2 _ _ _ _ _ _\n    { Equiv.ofBijective _ (continuousMapEval_bijective X \ud835\udd5c) with toFun := continuousMapEval X \ud835\udd5c }\n    (map_continuous (continuousMapEval X \ud835\udd5c))", "start": [452, 1], "end": [457, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Contraction.lean", "imports": ["Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Fold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CliffordAlgebra.contractLeftAux", "code": "@[simps!]\ndef contractLeftAux (d : Module.Dual R M) :\n    M \u2192\u2097[R] CliffordAlgebra Q \u00d7 CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q :=\n  haveI v_mul := (Algebra.lmul R (CliffordAlgebra Q)).toLinearMap \u2218\u2097 \u03b9 Q\n  d.smulRight (LinearMap.fst _ (CliffordAlgebra Q) (CliffordAlgebra Q)) -\n    v_mul.compl\u2082 (LinearMap.snd _ (CliffordAlgebra Q) _)", "start": [59, 1], "end": [65, 57], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeftAux_contractLeftAux", "code": "theorem contractLeftAux_contractLeftAux (v : M) (x : CliffordAlgebra Q) (fx : CliffordAlgebra Q) :\n    contractLeftAux Q d v (\u03b9 Q v * x, contractLeftAux Q d v (x, fx)) = Q v \u2022 fx", "start": [68, 1], "end": [72, 14], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft", "code": "def contractLeft : Module.Dual R M \u2192\u2097[R] CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q where\n  toFun d := foldr' Q (contractLeftAux Q d) (contractLeftAux_contractLeftAux Q d) 0\n  map_add' d\u2081 d\u2082 :=\n    LinearMap.ext fun x => by\n      dsimp only\n      rw [LinearMap.add_apply]\n      induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n      \u00b7 simp_rw [foldr'_algebraMap, smul_zero, zero_add]\n      \u00b7 rw [map_add, map_add, map_add, add_add_add_comm, hx, hy]\n      \u00b7 rw [foldr'_\u03b9_mul, foldr'_\u03b9_mul, foldr'_\u03b9_mul, hx]\n        dsimp only [contractLeftAux_apply_apply]\n        rw [sub_add_sub_comm, mul_add, LinearMap.add_apply, add_smul]\n  map_smul' c d :=\n    LinearMap.ext fun x => by\n      dsimp only\n      rw [LinearMap.smul_apply, RingHom.id_apply]\n      induction' x using CliffordAlgebra.left_induction with r x y hx hy m x hx\n      \u00b7 simp_rw [foldr'_algebraMap, smul_zero]\n      \u00b7 rw [map_add, map_add, smul_add, hx, hy]\n      \u00b7 rw [foldr'_\u03b9_mul, foldr'_\u03b9_mul, hx]\n        dsimp only [contractLeftAux_apply_apply]\n        rw [LinearMap.smul_apply, smul_assoc, mul_smul_comm, smul_sub]", "start": [77, 1], "end": [103, 71], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight", "code": "def contractRight : CliffordAlgebra Q \u2192\u2097[R] Module.Dual R M \u2192\u2097[R] CliffordAlgebra Q :=\n  LinearMap.flip (LinearMap.compl\u2082 (LinearMap.compr\u2082 contractLeft reverse) reverse)", "start": [106, 1], "end": [113, 84], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_eq", "code": "theorem contractRight_eq (x : CliffordAlgebra Q) :\n    contractRight (Q := Q) x d = reverse (contractLeft (R := R) (M := M) d <| reverse x)", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_\u03b9_mul", "code": "theorem contractLeft_\u03b9_mul (a : M) (b : CliffordAlgebra Q) :\n    d\u230b(\u03b9 Q a * b) = d a \u2022 b - \u03b9 Q a * (d\u230bb)", "start": [129, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_mul_\u03b9", "code": "theorem contractRight_mul_\u03b9 (a : M) (b : CliffordAlgebra Q) :\n    b * \u03b9 Q a\u230ad = d a \u2022 b - b\u230ad * \u03b9 Q a", "start": [137, 1], "end": [141, 67], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_algebraMap_mul", "code": "theorem contractLeft_algebraMap_mul (r : R) (b : CliffordAlgebra Q) :\n    d\u230b(algebraMap _ _ r * b) = algebraMap _ _ r * (d\u230bb)", "start": [144, 1], "end": [146, 72], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_mul_algebraMap", "code": "theorem contractLeft_mul_algebraMap (a : CliffordAlgebra Q) (r : R) :\n    d\u230b(a * algebraMap _ _ r) = d\u230ba * algebraMap _ _ r", "start": [149, 1], "end": [151, 91], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_algebraMap_mul", "code": "theorem contractRight_algebraMap_mul (r : R) (b : CliffordAlgebra Q) :\n    algebraMap _ _ r * b\u230ad = algebraMap _ _ r * (b\u230ad)", "start": [154, 1], "end": [156, 65], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_mul_algebraMap", "code": "theorem contractRight_mul_algebraMap (a : CliffordAlgebra Q) (r : R) :\n    a * algebraMap _ _ r\u230ad = a\u230ad * algebraMap _ _ r", "start": [159, 1], "end": [161, 74], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_\u03b9", "code": "@[simp]\ntheorem contractLeft_\u03b9 (x : M) : d\u230b\u03b9 Q x = algebraMap R _ (d x)", "start": [166, 1], "end": [172, 64], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_\u03b9", "code": "@[simp]\ntheorem contractRight_\u03b9 (x : M) : \u03b9 Q x\u230ad = algebraMap R _ (d x)", "start": [175, 1], "end": [177, 69], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_algebraMap", "code": "@[simp]\ntheorem contractLeft_algebraMap (r : R) : d\u230balgebraMap R (CliffordAlgebra Q) r = 0", "start": [180, 1], "end": [184, 64], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_algebraMap", "code": "@[simp]\ntheorem contractRight_algebraMap (r : R) : algebraMap R (CliffordAlgebra Q) r\u230ad = 0", "start": [187, 1], "end": [189, 77], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_one", "code": "@[simp]\ntheorem contractLeft_one : d\u230b(1 : CliffordAlgebra Q) = 0", "start": [192, 1], "end": [194, 59], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_one", "code": "@[simp]\ntheorem contractRight_one : (1 : CliffordAlgebra Q)\u230ad = 0", "start": [197, 1], "end": [199, 60], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_contractLeft", "code": "theorem contractLeft_contractLeft (x : CliffordAlgebra Q) : d\u230b(d\u230bx) = 0", "start": [204, 1], "end": [210, 36], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_contractRight", "code": "theorem contractRight_contractRight (x : CliffordAlgebra Q) : x\u230ad\u230ad = 0", "start": [213, 1], "end": [215, 96], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractLeft_comm", "code": "theorem contractLeft_comm (x : CliffordAlgebra Q) : d\u230b(d'\u230bx) = -(d'\u230b(d\u230bx))", "start": [218, 1], "end": [224, 68], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.contractRight_comm", "code": "theorem contractRight_comm (x : CliffordAlgebra Q) : x\u230ad\u230ad' = -(x\u230ad'\u230ad)", "start": [227, 1], "end": [230, 49], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeFormAux", "code": "@[simps!]\ndef changeFormAux (B : BilinForm R M) : M \u2192\u2097[R] CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q :=\n  haveI v_mul := (Algebra.lmul R (CliffordAlgebra Q)).toLinearMap \u2218\u2097 \u03b9 Q\n  v_mul - contractLeft \u2218\u2097 (BilinForm.toLin B)", "start": [242, 1], "end": [246, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeFormAux_changeFormAux", "code": "theorem changeFormAux_changeFormAux (B : BilinForm R M) (v : M) (x : CliffordAlgebra Q) :\n    changeFormAux Q B v (changeFormAux Q B v x) = (Q v - B v v) \u2022 x", "start": [249, 1], "end": [254, 24], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm", "code": "def changeForm (h : B.toQuadraticForm = Q' - Q) : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q' :=\n  foldr Q (changeFormAux Q' B)\n    (fun m x =>\n      (changeFormAux_changeFormAux Q' B m x).trans <| by\n        dsimp only [\u2190 BilinForm.toQuadraticForm_apply]\n        rw [h, QuadraticForm.sub_apply, sub_sub_cancel])\n    1", "start": [263, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm.zero_proof", "code": "theorem changeForm.zero_proof : (0 : BilinForm R M).toQuadraticForm = Q - Q", "start": [276, 1], "end": [278, 20], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm.add_proof", "code": "theorem changeForm.add_proof : (B + B').toQuadraticForm = Q'' - Q", "start": [281, 1], "end": [283, 63], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm.neg_proof", "code": "theorem changeForm.neg_proof : (-B).toQuadraticForm = Q - Q'", "start": [286, 1], "end": [288, 45], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm.associated_neg_proof", "code": "theorem changeForm.associated_neg_proof [Invertible (2 : R)] :\n    (QuadraticForm.associated (R := R) (M := M) (-Q)).toQuadraticForm = 0 - Q", "start": [291, 1], "end": [293, 50], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_algebraMap", "code": "@[simp]\ntheorem changeForm_algebraMap (r : R) : changeForm h (algebraMap R _ r) = algebraMap R _ r", "start": [296, 1], "end": [298, 84], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_one", "code": "@[simp]\ntheorem changeForm_one : changeForm h (1 : CliffordAlgebra Q) = 1", "start": [301, 1], "end": [303, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_\u03b9", "code": "@[simp]\ntheorem changeForm_\u03b9 (m : M) : changeForm h (\u03b9 (M := M) Q m) = \u03b9 (M := M) Q' m", "start": [306, 1], "end": [309, 86], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_\u03b9_mul", "code": "theorem changeForm_\u03b9_mul (m : M) (x : CliffordAlgebra Q) :\n    changeForm h (\u03b9 (M := M) Q m * x) = \u03b9 (M := M) Q' m * changeForm h x\n    - contractLeft (Q := Q') (BilinForm.toLin B m) (changeForm h x)", "start": [312, 1], "end": [317, 56], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_\u03b9_mul_\u03b9", "code": "theorem changeForm_\u03b9_mul_\u03b9 (m\u2081 m\u2082 : M) :\n    changeForm h (\u03b9 Q m\u2081 * \u03b9 Q m\u2082) = \u03b9 Q' m\u2081 * \u03b9 Q' m\u2082 - algebraMap _ _ (B m\u2081 m\u2082)", "start": [320, 1], "end": [322, 77], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_contractLeft", "code": "theorem changeForm_contractLeft (d : Module.Dual R M) (x : CliffordAlgebra Q) :\n    changeForm h (contractLeft (Q := Q) d x) = contractLeft (Q := Q') d (changeForm h x)", "start": [325, 1], "end": [334, 66], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_self_apply", "code": "theorem changeForm_self_apply (x : CliffordAlgebra Q) : changeForm (Q' := Q)\n    changeForm.zero_proof x = x", "start": [337, 1], "end": [343, 16], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_self", "code": "@[simp]\ntheorem changeForm_self :\n    changeForm changeForm.zero_proof = (LinearMap.id : CliffordAlgebra Q \u2192\u2097[R] _)", "start": [346, 1], "end": [349, 41], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_changeForm", "code": "theorem changeForm_changeForm (x : CliffordAlgebra Q) :\n    changeForm h' (changeForm h x) = changeForm (changeForm.add_proof h h') x", "start": [352, 1], "end": [360, 42], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeForm_comp_changeForm", "code": "theorem changeForm_comp_changeForm :\n    (changeForm h').comp (changeForm h) = changeForm (changeForm.add_proof h h')", "start": [363, 1], "end": [365, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeFormEquiv", "code": "@[simps apply]\ndef changeFormEquiv : CliffordAlgebra Q \u2243\u2097[R] CliffordAlgebra Q' :=\n  { changeForm h with\n    toFun := changeForm h\n    invFun := changeForm (changeForm.neg_proof h)\n    left_inv := fun x => by\n      dsimp only\n      exact (changeForm_changeForm _ _ x).trans <| by simp_rw [add_right_neg, changeForm_self_apply]\n    right_inv := fun x => by\n      dsimp only\n      exact (changeForm_changeForm _ _ x).trans <|\n        by simp_rw [add_left_neg, changeForm_self_apply] }", "start": [368, 1], "end": [382, 59], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.changeFormEquiv_symm", "code": "@[simp]\ntheorem changeFormEquiv_symm :\n    (changeFormEquiv h).symm = changeFormEquiv (changeForm.neg_proof h)", "start": [385, 1], "end": [388, 31], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.equivExterior", "code": "@[simp]\ndef equivExterior [Invertible (2 : R)] : CliffordAlgebra Q \u2243\u2097[R] ExteriorAlgebra R M :=\n  changeFormEquiv changeForm.associated_neg_proof", "start": [393, 1], "end": [399, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/VectorBundle/Hom.lean", "imports": ["Mathlib/Geometry/Manifold/VectorBundle/Basic.lean", "Mathlib/Topology/VectorBundle/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "smoothOn_continuousLinearMapCoordChange", "code": "theorem smoothOn_continuousLinearMapCoordChange\n    [SmoothVectorBundle F\u2081 E\u2081 IB] [SmoothVectorBundle F\u2082 E\u2082 IB] [MemTrivializationAtlas e\u2081]\n    [MemTrivializationAtlas e\u2081'] [MemTrivializationAtlas e\u2082] [MemTrivializationAtlas e\u2082'] :\n    SmoothOn IB \ud835\udcd8(\ud835\udd5c, (F\u2081 \u2192L[\ud835\udd5c] F\u2082) \u2192L[\ud835\udd5c] F\u2081 \u2192L[\ud835\udd5c] F\u2082)\n      (continuousLinearMapCoordChange (RingHom.id \ud835\udd5c) e\u2081 e\u2081' e\u2082 e\u2082')\n      (e\u2081.baseSet \u2229 e\u2082.baseSet \u2229 (e\u2081'.baseSet \u2229 e\u2082'.baseSet))", "start": [44, 1], "end": [52, 67], "kind": "commanddeclaration"}, {"full_name": "hom_chart", "code": "theorem hom_chart (y\u2080 y : LE\u2081E\u2082) :\n    chartAt (ModelProd HB (F\u2081 \u2192L[\ud835\udd5c] F\u2082)) y\u2080 y =\n      (chartAt HB y\u2080.1 y.1, inCoordinates F\u2081 E\u2081 F\u2082 E\u2082 y\u2080.1 y.1 y\u2080.1 y.1 y.2)", "start": [55, 1], "end": [59, 101], "kind": "commanddeclaration"}, {"full_name": "contMDiffAt_hom_bundle", "code": "theorem contMDiffAt_hom_bundle (f : M \u2192 LE\u2081E\u2082) {x\u2080 : M} {n : \u2115\u221e} :\n    ContMDiffAt IM (IB.prod \ud835\udcd8(\ud835\udd5c, F\u2081 \u2192L[\ud835\udd5c] F\u2082)) n f x\u2080 \u2194\n      ContMDiffAt IM IB n (fun x => (f x).1) x\u2080 \u2227\n        ContMDiffAt IM \ud835\udcd8(\ud835\udd5c, F\u2081 \u2192L[\ud835\udd5c] F\u2082) n\n          (fun x => inCoordinates F\u2081 E\u2081 F\u2082 E\u2082 (f x\u2080).1 (f x).1 (f x\u2080).1 (f x).1 (f x).2) x\u2080", "start": [64, 1], "end": [69, 28], "kind": "commanddeclaration"}, {"full_name": "smoothAt_hom_bundle", "code": "theorem smoothAt_hom_bundle (f : M \u2192 LE\u2081E\u2082) {x\u2080 : M} :\n    SmoothAt IM (IB.prod \ud835\udcd8(\ud835\udd5c, F\u2081 \u2192L[\ud835\udd5c] F\u2082)) f x\u2080 \u2194\n      SmoothAt IM IB (fun x => (f x).1) x\u2080 \u2227\n        SmoothAt IM \ud835\udcd8(\ud835\udd5c, F\u2081 \u2192L[\ud835\udd5c] F\u2082)\n          (fun x => inCoordinates F\u2081 E\u2081 F\u2082 E\u2082 (f x\u2080).1 (f x).1 (f x\u2080).1 (f x).1 (f x).2) x\u2080", "start": [72, 1], "end": [77, 27], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.vectorPrebundle.isSmooth", "code": "instance Bundle.ContinuousLinearMap.vectorPrebundle.isSmooth :\n    (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id \ud835\udd5c) F\u2081 E\u2081 F\u2082 E\u2082).IsSmooth IB where\n  exists_smoothCoordChange := by\n    rintro _ \u27e8e\u2081, e\u2082, he\u2081, he\u2082, rfl\u27e9 _ \u27e8e\u2081', e\u2082', he\u2081', he\u2082', rfl\u27e9\n    exact \u27e8continuousLinearMapCoordChange (RingHom.id \ud835\udd5c) e\u2081 e\u2081' e\u2082 e\u2082',\n      smoothOn_continuousLinearMapCoordChange IB,\n      continuousLinearMapCoordChange_apply (RingHom.id \ud835\udd5c) e\u2081 e\u2081' e\u2082 e\u2082'\u27e9", "start": [82, 1], "end": [88, 73], "kind": "commanddeclaration"}, {"full_name": "SmoothVectorBundle.continuousLinearMap", "code": "instance SmoothVectorBundle.continuousLinearMap :\n    SmoothVectorBundle (F\u2081 \u2192L[\ud835\udd5c] F\u2082) (Bundle.ContinuousLinearMap (RingHom.id \ud835\udd5c) E\u2081 E\u2082) IB :=\n  (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id \ud835\udd5c) F\u2081 E\u2081 F\u2082 E\u2082).smoothVectorBundle IB", "start": [91, 1], "end": [93, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/Units.lean", "imports": ["Mathlib/RingTheory/RootsOfUnity/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Gershgorin.lean", "Mathlib/RingTheory/Ideal/Norm.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/NumberField/CanonicalEmbedding.lean", "Mathlib/NumberTheory/NumberField/Norm.lean"], "premises": [{"full_name": "Rat.RingOfIntegers.isUnit_iff", "code": "theorem Rat.RingOfIntegers.isUnit_iff {x : \ud835\udcde \u211a} : IsUnit x \u2194 (x : \u211a) = 1 \u2228 (x : \u211a) = -1", "start": [53, 1], "end": [56, 39], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_norm_int", "code": "theorem Algebra.coe_norm_int {K : Type*} [Field K] [NumberField K] (x : \ud835\udcde K) :\n    Algebra.norm \u2124 x = Algebra.norm \u211a (x : K)", "start": [59, 1], "end": [61, 97], "kind": "commanddeclaration"}, {"full_name": "NumberField.isUnit_iff_norm", "code": "theorem NumberField.isUnit_iff_norm [NumberField K] {x : \ud835\udcde K} :\n    IsUnit x \u2194 |(RingOfIntegers.norm \u211a x : \u211a)| = 1", "start": [71, 1], "end": [74, 62], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_injective", "code": "theorem coe_injective : Function.Injective ((\u2191) : (\ud835\udcde K)\u02e3 \u2192 K)", "start": [83, 1], "end": [84, 62], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_mul", "code": "theorem coe_mul (x y : (\ud835\udcde K)\u02e3) : ((x * y : (\ud835\udcde K)\u02e3) : K) = (x : K) * (y : K)", "start": [88, 1], "end": [88, 83], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_pow", "code": "theorem coe_pow (x : (\ud835\udcde K)\u02e3) (n : \u2115) : (x ^ n : K) = (x : K) ^ n", "start": [90, 1], "end": [91, 54], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_zpow", "code": "theorem coe_zpow (x : (\ud835\udcde K)\u02e3) (n : \u2124) : (x ^ n : K) = (x : K) ^ n", "start": [93, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_one", "code": "theorem coe_one : ((1 : (\ud835\udcde K)\u02e3) : K) = (1 : K)", "start": [97, 1], "end": [97, 54], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_neg_one", "code": "theorem coe_neg_one : ((-1 : (\ud835\udcde K)\u02e3) : K) = (-1 : K)", "start": [99, 1], "end": [99, 60], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.coe_ne_zero", "code": "theorem coe_ne_zero (x : (\ud835\udcde K)\u02e3) : (x : K) \u2260 0", "start": [101, 1], "end": [102, 60], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.torsion", "code": "def torsion : Subgroup (\ud835\udcde K)\u02e3 := CommGroup.torsion (\ud835\udcde K)\u02e3", "start": [110, 1], "end": [111, 58], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.mem_torsion", "code": "theorem mem_torsion {x : (\ud835\udcde K)\u02e3} [NumberField K] :\n    x \u2208 torsion K \u2194 \u2200 w : InfinitePlace K, w x = 1", "start": [113, 1], "end": [120, 53], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.torsionOrder", "code": "def torsionOrder [NumberField K] : \u2115+ := \u27e8Fintype.card (torsion K), Fintype.card_pos\u27e9", "start": [142, 1], "end": [143, 86], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.rootsOfUnity_eq_one", "code": "theorem rootsOfUnity_eq_one [NumberField K] {k : \u2115+} (hc : Nat.Coprime k (torsionOrder K))\n    {\u03b6 : (\ud835\udcde K)\u02e3} : \u03b6 \u2208 rootsOfUnity k (\ud835\udcde K) \u2194 \u03b6 = 1", "start": [145, 1], "end": [157, 32], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.rootsOfUnity_eq_torsion", "code": "theorem rootsOfUnity_eq_torsion [NumberField K] :\n    rootsOfUnity (torsionOrder K) (\ud835\udcde K) = torsion K", "start": [159, 1], "end": [168, 71], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.w\u2080", "code": "def w\u2080 : InfinitePlace K := (inferInstance : Nonempty (InfinitePlace K)).some", "start": [194, 1], "end": [195, 78], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.logEmbedding", "code": "def logEmbedding : Additive ((\ud835\udcde K)\u02e3) \u2192+ ({w : InfinitePlace K // w \u2260 w\u2080} \u2192 \u211d) :=\n{ toFun := fun x w => mult w.val * Real.log (w.val (Additive.toMul x))\n  map_zero' := by simp; rfl\n  map_add' := fun _ _ => by simp [Real.log_mul, mul_add]; rfl }", "start": [199, 1], "end": [203, 64], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.logEmbedding_component", "code": "@[simp]\ntheorem logEmbedding_component (x : (\ud835\udcde K)\u02e3) (w : {w : InfinitePlace K // w \u2260 w\u2080}) :\n    (logEmbedding K x) w = mult w.val * Real.log (w.val x)", "start": [207, 1], "end": [209, 66], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.sum_logEmbedding_component", "code": "theorem sum_logEmbedding_component (x : (\ud835\udcde K)\u02e3) :\n    \u2211 w, logEmbedding K x w = - mult (w\u2080 : InfinitePlace K) * Real.log (w\u2080 (x : K))", "start": [211, 1], "end": [223, 77], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.mult_log_place_eq_zero", "code": "theorem mult_log_place_eq_zero {x : (\ud835\udcde K)\u02e3} {w : InfinitePlace K} :\n    mult w * Real.log (w x) = 0 \u2194 w x = 1", "start": [225, 1], "end": [231, 38], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.logEmbedding_eq_zero_iff", "code": "theorem logEmbedding_eq_zero_iff {x : (\ud835\udcde K)\u02e3} :\n    logEmbedding K x = 0 \u2194 x \u2208 torsion K", "start": [233, 1], "end": [245, 80], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.logEmbedding_component_le", "code": "theorem logEmbedding_component_le {r : \u211d} {x : (\ud835\udcde K)\u02e3} (hr : 0 \u2264 r) (h : \u2016logEmbedding K x\u2016 \u2264 r)\n    (w : {w : InfinitePlace K // w \u2260 w\u2080}) : |logEmbedding K x w| \u2264 r", "start": [247, 1], "end": [251, 25], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.log_le_of_logEmbedding_le", "code": "theorem log_le_of_logEmbedding_le {r : \u211d} {x : (\ud835\udcde K)\u02e3} (hr : 0 \u2264 r) (h : \u2016logEmbedding K x\u2016 \u2264 r)\n    (w : InfinitePlace K) : |Real.log (w x)| \u2264 (Fintype.card (InfinitePlace K)) * r", "start": [253, 1], "end": [276, 100], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.unitLattice", "code": "noncomputable def _root_.NumberField.Units.unitLattice :\n    AddSubgroup ({w : InfinitePlace K // w \u2260 w\u2080} \u2192 \u211d) :=\n  AddSubgroup.map (logEmbedding K) \u22a4", "start": [280, 1], "end": [283, 37], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.unitLattice_inter_ball_finite", "code": "theorem unitLattice_inter_ball_finite (r : \u211d) :\n    ((unitLattice K : Set ({ w : InfinitePlace K // w \u2260 w\u2080} \u2192 \u211d)) \u2229\n      Metric.closedBall 0 r).Finite", "start": [285, 1], "end": [304, 24], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq_next", "code": "theorem seq_next {x : \ud835\udcde K} (hx : x \u2260 0) :\n    \u2203 y : \ud835\udcde K, y \u2260 0 \u2227 (\u2200 w, w \u2260 w\u2081 \u2192 w y < w x) \u2227 |Algebra.norm \u211a (y : K)| \u2264 B", "start": [329, 1], "end": [353, 26], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq", "code": "def seq : \u2115 \u2192 { x : \ud835\udcde K // x \u2260 0 }\n  | 0 => \u27e81, by norm_num\u27e9\n  | n + 1 =>\n    \u27e8(seq_next K w\u2081 hB (seq n).prop).choose, (seq_next K w\u2081 hB (seq n).prop).choose_spec.1\u27e9", "start": [355, 1], "end": [362, 92], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq_ne_zero", "code": "theorem seq_ne_zero (n : \u2115) : (seq K w\u2081 hB n : K) \u2260 0", "start": [364, 1], "end": [367, 52], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq_norm_ne_zero", "code": "theorem seq_norm_ne_zero (n : \u2115) : Algebra.norm \u2124 (seq K w\u2081 hB n : \ud835\udcde K) \u2260 0", "start": [369, 1], "end": [371, 78], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq_decreasing", "code": "theorem seq_decreasing {n m : \u2115} (h : n < m) (w : InfinitePlace K) (hw : w \u2260 w\u2081) :\n    w (seq K w\u2081 hB m) < w (seq K w\u2081 hB n)", "start": [373, 1], "end": [387, 77], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.seq_norm_le", "code": "theorem seq_norm_le (n : \u2115) :\n    Int.natAbs (Algebra.norm \u2124 (seq K w\u2081 hB n : \ud835\udcde K)) \u2264 B", "start": [389, 1], "end": [400, 68], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.exists_unit", "code": "theorem exists_unit (w\u2081 : InfinitePlace K ) :\n    \u2203 u : (\ud835\udcde K)\u02e3, \u2200 w : InfinitePlace K, w \u2260 w\u2081 \u2192 Real.log (w u) < 0", "start": [402, 1], "end": [433, 99], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top", "code": "theorem unitLattice_span_eq_top :\n    Submodule.span \u211d (unitLattice K : Set ({w : InfinitePlace K // w \u2260 w\u2080} \u2192 \u211d)) = \u22a4", "start": [435, 1], "end": [462, 60], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.rank", "code": "def rank : \u2115 := Fintype.card (InfinitePlace K) - 1", "start": [474, 1], "end": [475, 51], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.instDiscrete_unitLattice", "code": "instance instDiscrete_unitLattice : DiscreteTopology (unitLattice K) := by\n  refine discreteTopology_of_open_singleton_zero ?_\n  refine isOpen_singleton_of_finite_mem_nhds 0 (s := Metric.closedBall 0 1) ?_ ?_\n  \u00b7 exact Metric.closedBall_mem_nhds _ (by norm_num)\n  \u00b7 refine Set.Finite.of_finite_image ?_ (Set.injOn_of_injective Subtype.val_injective _)\n    convert unitLattice_inter_ball_finite K 1\n    ext x\n    refine \u27e8?_, fun \u27e8hx1, hx2\u27e9 => \u27e8\u27e8x, hx1\u27e9, hx2, rfl\u27e9\u27e9\n    rintro \u27e8x, hx, rfl\u27e9\n    exact \u27e8Subtype.mem x, hx\u27e9", "start": [477, 1], "end": [486, 30], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.finrank_eq_rank", "code": "protected theorem finrank_eq_rank :\n    finrank \u211d ({w : InfinitePlace K // w \u2260 w\u2080} \u2192 \u211d) = Units.rank K", "start": [488, 1], "end": [491, 39], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.instModuleFree_unitLattice", "code": "instance instModuleFree_unitLattice : Module.Free \u2124 (unitLattice K) :=\n  Zlattice.module_free \u211d (unitLattice_span_eq_top K)", "start": [493, 1], "end": [494, 53], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.instModuleFinite_unitLattice", "code": "instance instModuleFinite_unitLattice : Module.Finite \u2124 (unitLattice K) :=\n  Zlattice.module_finite \u211d (unitLattice_span_eq_top K)", "start": [496, 1], "end": [497, 55], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.unitLattice_rank", "code": "@[simp]\ntheorem unitLattice_rank :\n    finrank \u2124 (unitLattice K) = Units.rank K", "start": [499, 1], "end": [503, 52], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.unitLatticeEquiv", "code": "def unitLatticeEquiv : (unitLattice K) \u2243\u2097[\u2124] Additive ((\ud835\udcde K)\u02e3 \u29f8 (torsion K)) := by\n  refine AddEquiv.toIntLinearEquiv ?_\n  rw [unitLattice, \u2190 AddMonoidHom.range_eq_map (logEmbedding K)]\n  refine (QuotientAddGroup.quotientKerEquivRange (logEmbedding K)).symm.trans ?_\n  refine (QuotientAddGroup.quotientAddEquivOfEq ?_).trans\n    (QuotientAddGroup.quotientKerEquivOfSurjective\n      (MonoidHom.toAdditive (QuotientGroup.mk' (torsion K))) (fun x => ?_))\n  \u00b7 ext\n    rw [MonoidHom.coe_toAdditive_ker, QuotientGroup.ker_mk', AddMonoidHom.mem_ker,\n      logEmbedding_eq_zero_iff]\n    rfl\n  \u00b7 refine \u27e8Additive.ofMul x.out', ?_\u27e9\n    simp only [MonoidHom.toAdditive_apply_apply, toMul_ofMul, QuotientGroup.mk'_apply,\n      QuotientGroup.out_eq']\n    rfl", "start": [505, 1], "end": [521, 8], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.rank_modTorsion", "code": "theorem rank_modTorsion :\n    FiniteDimensional.finrank \u2124 (Additive ((\ud835\udcde K)\u02e3 \u29f8 (torsion K))) = rank K", "start": [549, 1], "end": [551, 71], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.basisModTorsion", "code": "def basisModTorsion : Basis (Fin (rank K)) \u2124 (Additive ((\ud835\udcde K)\u02e3 \u29f8 (torsion K))) :=\n  Basis.reindex (Module.Free.chooseBasis \u2124 _) (Fintype.equivOfCardEq <| by\n    rw [\u2190 FiniteDimensional.finrank_eq_card_chooseBasisIndex, rank_modTorsion, Fintype.card_fin])", "start": [553, 1], "end": [556, 98], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.fundSystem", "code": "def fundSystem : Fin (rank K) \u2192 (\ud835\udcde K)\u02e3 :=\n  fun i => Quotient.out' (Additive.toMul (basisModTorsion K i))", "start": [558, 1], "end": [561, 64], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.fun_eq_repr", "code": "theorem fun_eq_repr {x \u03b6 : (\ud835\udcde K)\u02e3} {f : Fin (rank K) \u2192 \u2124} (h\u03b6 : \u03b6 \u2208 torsion K)\n    (h : x = \u03b6 * \u220f i, (fundSystem K i) ^ (f i)) :\n    f = (basisModTorsion K).repr (Additive.ofMul \u2191x)", "start": [563, 1], "end": [576, 79], "kind": "commanddeclaration"}, {"full_name": "NumberField.Units.exist_unique_eq_mul_prod", "code": "theorem exist_unique_eq_mul_prod (x : (\ud835\udcde K)\u02e3) : \u2203! (\u03b6 : torsion K) (e : Fin (rank K) \u2192 \u2124),\n    x = \u03b6 * \u220f i, (fundSystem K i) ^ (e i)", "start": [578, 1], "end": [597, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Auto.lean", "imports": ["Mathlib/Data/Matrix/Reflection.lean", "Mathlib/Algebra/Expr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/W/Constructions.lean", "imports": ["Mathlib/Data/W/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WType.Nat\u03b1", "code": "inductive Nat\u03b1 : Type\n  | zero : Nat\u03b1\n  | succ : Nat\u03b1", "start": [34, 1], "end": [37, 16], "kind": "commanddeclaration"}, {"full_name": "WType.Nat\u03b2", "code": "def Nat\u03b2 : Nat\u03b1 \u2192 Type\n  | Nat\u03b1.zero => Empty\n  | Nat\u03b1.succ => Unit", "start": [43, 1], "end": [46, 22], "kind": "commanddeclaration"}, {"full_name": "WType.ofNat", "code": "@[simp]\ndef ofNat : \u2115 \u2192 WType Nat\u03b2\n  | Nat.zero => \u27e8Nat\u03b1.zero, Empty.elim\u27e9\n  | Nat.succ n => \u27e8Nat\u03b1.succ, fun _ \u21a6 ofNat n\u27e9", "start": [52, 1], "end": [56, 47], "kind": "commanddeclaration"}, {"full_name": "WType.toNat", "code": "@[simp]\ndef toNat : WType Nat\u03b2 \u2192 \u2115\n  | WType.mk Nat\u03b1.zero _ => 0\n  | WType.mk Nat\u03b1.succ f => (f ()).toNat.succ", "start": [59, 1], "end": [63, 46], "kind": "commanddeclaration"}, {"full_name": "WType.leftInverse_nat", "code": "theorem leftInverse_nat : Function.LeftInverse ofNat toNat", "start": [66, 1], "end": [74, 8], "kind": "commanddeclaration"}, {"full_name": "WType.rightInverse_nat", "code": "theorem rightInverse_nat : Function.RightInverse ofNat toNat", "start": [77, 1], "end": [79, 59], "kind": "commanddeclaration"}, {"full_name": "WType.equivNat", "code": "def equivNat : WType Nat\u03b2 \u2243 \u2115 where\n  toFun := toNat\n  invFun := ofNat\n  left_inv := leftInverse_nat\n  right_inv := rightInverse_nat", "start": [82, 1], "end": [87, 32], "kind": "commanddeclaration"}, {"full_name": "WType.Nat\u03b1EquivPUnitSumPUnit", "code": "@[simps]\ndef Nat\u03b1EquivPUnitSumPUnit : Nat\u03b1 \u2243 Sum PUnit.{u + 1} PUnit\n    where\n  toFun c :=\n    match c with\n    | Nat\u03b1.zero => inl unit\n    | Nat\u03b1.succ => inr unit\n  invFun b :=\n    match b with\n    | inl _ => Nat\u03b1.zero\n    | inr _ => Nat\u03b1.succ\n  left_inv c :=\n    match c with\n    | Nat\u03b1.zero => rfl\n    | Nat\u03b1.succ => rfl\n  right_inv b :=\n    match b with\n    | inl _ => rfl\n    | inr _ => rfl", "start": [92, 1], "end": [113, 19], "kind": "commanddeclaration"}, {"full_name": "WType.List\u03b1", "code": "inductive List\u03b1 : Type u\n  | nil : List\u03b1\n  | cons : \u03b3 \u2192 List\u03b1", "start": [122, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "WType.List\u03b2", "code": "def List\u03b2 : List\u03b1 \u03b3 \u2192 Type u\n  | List\u03b1.nil => PEmpty\n  | List\u03b1.cons _ => PUnit", "start": [140, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "WType.ofList", "code": "@[simp]\ndef ofList : List \u03b3 \u2192 WType (List\u03b2 \u03b3)\n  | List.nil => \u27e8List\u03b1.nil, PEmpty.elim\u27e9\n  | List.cons hd tl => \u27e8List\u03b1.cons hd, fun _ \u21a6 ofList tl\u27e9", "start": [149, 1], "end": [153, 58], "kind": "commanddeclaration"}, {"full_name": "WType.toList", "code": "@[simp]\ndef toList : WType (List\u03b2 \u03b3) \u2192 List \u03b3\n  | WType.mk List\u03b1.nil _ => []\n  | WType.mk (List\u03b1.cons hd) f => hd :: (f PUnit.unit).toList", "start": [156, 1], "end": [160, 62], "kind": "commanddeclaration"}, {"full_name": "WType.leftInverse_list", "code": "theorem leftInverse_list : Function.LeftInverse (ofList \u03b3) (toList _)", "start": [163, 1], "end": [170, 8], "kind": "commanddeclaration"}, {"full_name": "WType.rightInverse_list", "code": "theorem rightInverse_list : Function.RightInverse (ofList \u03b3) (toList _)", "start": [173, 1], "end": [175, 67], "kind": "commanddeclaration"}, {"full_name": "WType.equivList", "code": "def equivList : WType (List\u03b2 \u03b3) \u2243 List \u03b3\n    where\n  toFun := toList _\n  invFun := ofList _\n  left_inv := leftInverse_list _\n  right_inv := rightInverse_list _", "start": [178, 1], "end": [184, 35], "kind": "commanddeclaration"}, {"full_name": "WType.List\u03b1EquivPUnitSum", "code": "def List\u03b1EquivPUnitSum : List\u03b1 \u03b3 \u2243 Sum PUnit.{v + 1} \u03b3\n    where\n  toFun c :=\n    match c with\n    | List\u03b1.nil => Sum.inl PUnit.unit\n    | List\u03b1.cons x => Sum.inr x\n  invFun := Sum.elim (fun _ \u21a6 List\u03b1.nil) List\u03b1.cons\n  left_inv c :=\n    match c with\n    | List\u03b1.nil => rfl\n    | List\u03b1.cons _ => rfl\n  right_inv x :=\n    match x with\n    | Sum.inl PUnit.unit => rfl\n    | Sum.inr _ => rfl", "start": [187, 1], "end": [204, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/RingInvo.lean", "imports": ["Mathlib/Algebra/Ring/Opposite.lean", "Mathlib/Algebra/Ring/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingInvo", "code": "structure RingInvo [Semiring R] extends R \u2243+* R\u1d50\u1d52\u1d56 where\n  \n  involution' : \u2200 x, (toFun (toFun x).unop).unop = x", "start": [35, 1], "end": [38, 53], "kind": "commanddeclaration"}, {"full_name": "RingInvoClass", "code": "class RingInvoClass (F : Type*) (R : outParam (Type*)) [Semiring R] extends\n    RingEquivClass F R R\u1d50\u1d52\u1d56 where\n  \n  involution : \u2200 (f : F) (x), (f (f x).unop).unop = x", "start": [45, 1], "end": [50, 54], "kind": "commanddeclaration"}, {"full_name": "RingInvoClass.toRingInvo", "code": "@[coe]\ndef RingInvoClass.toRingInvo {R} [Semiring R] [RingInvoClass F R] (f : F) :\n    RingInvo R :=\n  { (f : R \u2243+* R\u1d50\u1d52\u1d56) with involution' := RingInvoClass.involution f }", "start": [53, 1], "end": [58, 70], "kind": "commanddeclaration"}, {"full_name": "RingInvo.mk'", "code": "def mk' (f : R \u2192+* R\u1d50\u1d52\u1d56) (involution : \u2200 r, (f (f r).unop).unop = r) : RingInvo R :=\n  { f with\n    invFun := fun r => (f r.unop).unop\n    left_inv := fun r => involution r\n    right_inv := fun _ => MulOpposite.unop_injective <| involution _\n    involution' := involution }", "start": [83, 1], "end": [89, 32], "kind": "commanddeclaration"}, {"full_name": "RingInvo.involution", "code": "@[simp]\ntheorem involution (f : RingInvo R) (x : R) : (f (f x).unop).unop = x", "start": [97, 1], "end": [99, 18], "kind": "commanddeclaration"}, {"full_name": "RingInvo.coe_ringEquiv", "code": "@[norm_cast]\ntheorem coe_ringEquiv (f : RingInvo R) (a : R) : (f : R \u2243+* R\u1d50\u1d52\u1d56) a = f a", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "RingInvo.map_eq_zero_iff", "code": "theorem map_eq_zero_iff (f : RingInvo R) {x : R} : f x = 0 \u2194 x = 0", "start": [114, 1], "end": [115, 32], "kind": "commanddeclaration"}, {"full_name": "RingInvo.id", "code": "protected def RingInvo.id : RingInvo R :=\n  { RingEquiv.toOpposite R with involution' := fun _ => rfl }", "start": [126, 1], "end": [128, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Tropical/Lattice.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Algebra/Tropical/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "instSupTropical", "code": "instance instSupTropical [Sup R] : Sup (Tropical R) where\n  sup x y := trop (untrop x \u2294 untrop y)", "start": [34, 1], "end": [35, 40], "kind": "commanddeclaration"}, {"full_name": "instInfTropical", "code": "instance instInfTropical [Inf R] : Inf (Tropical R) where\n  inf x y := trop (untrop x \u2293 untrop y)", "start": [37, 1], "end": [38, 40], "kind": "commanddeclaration"}, {"full_name": "instSemilatticeInfTropical", "code": "instance instSemilatticeInfTropical [SemilatticeInf R] : SemilatticeInf (Tropical R) :=\n  { instInfTropical,\n    Tropical.instPartialOrderTropical with\n    le_inf := fun _ _ _ \u21a6 @SemilatticeInf.le_inf R _ _ _ _\n    inf_le_left := fun _ _ \u21a6 inf_le_left\n    inf_le_right := fun _ _ \u21a6 inf_le_right }", "start": [40, 1], "end": [45, 45], "kind": "commanddeclaration"}, {"full_name": "instSemilatticeSupTropical", "code": "instance instSemilatticeSupTropical [SemilatticeSup R] : SemilatticeSup (Tropical R) :=\n  { instSupTropical,\n    Tropical.instPartialOrderTropical with\n    sup_le := fun _ _ _ \u21a6 @SemilatticeSup.sup_le R _ _ _ _\n    le_sup_left := fun _ _ \u21a6 le_sup_left\n    le_sup_right := fun _ _ \u21a6 le_sup_right }", "start": [47, 1], "end": [52, 45], "kind": "commanddeclaration"}, {"full_name": "instLatticeTropical", "code": "instance instLatticeTropical [Lattice R] : Lattice (Tropical R) :=\n  { instSemilatticeInfTropical, instSemilatticeSupTropical with }", "start": [54, 1], "end": [55, 66], "kind": "commanddeclaration"}, {"full_name": "instConditionallyCompleteLatticeTropical", "code": "instance instConditionallyCompleteLatticeTropical [ConditionallyCompleteLattice R] :\n    ConditionallyCompleteLattice (Tropical R) :=\n  { @instInfTropical R _, @instSupTropical R _,\n    instLatticeTropical with\n    le_csSup := fun _s _x hs hx \u21a6\n      le_csSup (untrop_monotone.map_bddAbove hs) (Set.mem_image_of_mem untrop hx)\n    csSup_le := fun _s _x hs hx \u21a6\n      csSup_le (hs.image untrop) (untrop_monotone.mem_upperBounds_image hx)\n    le_csInf := fun _s _x hs hx \u21a6\n      le_csInf (hs.image untrop) (untrop_monotone.mem_lowerBounds_image hx)\n    csInf_le := fun _s _x hs hx \u21a6\n      csInf_le (untrop_monotone.map_bddBelow hs) (Set.mem_image_of_mem untrop hx) }", "start": [61, 1], "end": [72, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/List.lean", "imports": ["Mathlib/Topology/Algebra/Monoid.lean", "Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhds_list", "code": "theorem nhds_list (as : List \u03b1) : \ud835\udcdd as = traverse \ud835\udcdd as", "start": [26, 1], "end": [62, 82], "kind": "commanddeclaration"}, {"full_name": "nhds_nil", "code": "@[simp]\ntheorem nhds_nil : \ud835\udcdd ([] : List \u03b1) = pure []", "start": [65, 1], "end": [67, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_cons", "code": "theorem nhds_cons (a : \u03b1) (l : List \u03b1) : \ud835\udcdd (a::l) = List.cons <$> \ud835\udcdd a <*> \ud835\udcdd l", "start": [70, 1], "end": [71, 52], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_cons", "code": "theorem List.tendsto_cons {a : \u03b1} {l : List \u03b1} :\n    Tendsto (fun p : \u03b1 \u00d7 List \u03b1 => List.cons p.1 p.2) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) (\ud835\udcdd (a::l))", "start": [74, 1], "end": [76, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.cons", "code": "theorem Filter.Tendsto.cons {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 List \u03b2} {a : Filter \u03b1} {b : \u03b2}\n    {l : List \u03b2} (hf : Tendsto f a (\ud835\udcdd b)) (hg : Tendsto g a (\ud835\udcdd l)) :\n    Tendsto (fun a => List.cons (f a) (g a)) a (\ud835\udcdd (b::l))", "start": [79, 1], "end": [82, 49], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_cons_iff", "code": "theorem tendsto_cons_iff {\u03b2 : Type*} {f : List \u03b1 \u2192 \u03b2} {b : Filter \u03b2} {a : \u03b1} {l : List \u03b1} :\n    Tendsto f (\ud835\udcdd (a::l)) b \u2194 Tendsto (fun p : \u03b1 \u00d7 List \u03b1 => f (p.1::p.2)) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) b", "start": [87, 1], "end": [93, 42], "kind": "commanddeclaration"}, {"full_name": "List.continuous_cons", "code": "theorem continuous_cons : Continuous fun x : \u03b1 \u00d7 List \u03b1 => (x.1::x.2 : List \u03b1)", "start": [96, 1], "end": [97, 89], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_nhds", "code": "theorem tendsto_nhds {\u03b2 : Type*} {f : List \u03b1 \u2192 \u03b2} {r : List \u03b1 \u2192 Filter \u03b2}\n    (h_nil : Tendsto f (pure []) (r []))\n    (h_cons :\n      \u2200 l a,\n        Tendsto f (\ud835\udcdd l) (r l) \u2192\n          Tendsto (fun p : \u03b1 \u00d7 List \u03b1 => f (p.1::p.2)) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) (r (a::l))) :\n    \u2200 l, Tendsto f (\ud835\udcdd l) (r l)", "start": [100, 1], "end": [109, 81], "kind": "commanddeclaration"}, {"full_name": "List.continuousAt_length", "code": "theorem continuousAt_length : \u2200 l : List \u03b1, ContinuousAt List.length l", "start": [112, 1], "end": [119, 40], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_insertNth'", "code": "theorem tendsto_insertNth' {a : \u03b1} :\n    \u2200 {n : \u2115} {l : List \u03b1},\n      Tendsto (fun p : \u03b1 \u00d7 List \u03b1 => insertNth n p.1 p.2) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) (\ud835\udcdd (insertNth n a l))", "start": [122, 1], "end": [135, 98], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_insertNth", "code": "theorem tendsto_insertNth {\u03b2} {n : \u2115} {a : \u03b1} {l : List \u03b1} {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 List \u03b1}\n    {b : Filter \u03b2} (hf : Tendsto f b (\ud835\udcdd a)) (hg : Tendsto g b (\ud835\udcdd l)) :\n    Tendsto (fun b : \u03b2 => insertNth n (f b) (g b)) b (\ud835\udcdd (insertNth n a l))", "start": [138, 1], "end": [141, 50], "kind": "commanddeclaration"}, {"full_name": "List.continuous_insertNth", "code": "theorem continuous_insertNth {n : \u2115} : Continuous fun p : \u03b1 \u00d7 List \u03b1 => insertNth n p.1 p.2", "start": [144, 1], "end": [146, 62], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_removeNth", "code": "theorem tendsto_removeNth :\n    \u2200 {n : \u2115} {l : List \u03b1}, Tendsto (fun l => removeNth l n) (\ud835\udcdd l) (\ud835\udcdd (removeNth l n))", "start": [149, 1], "end": [156, 71], "kind": "commanddeclaration"}, {"full_name": "List.continuous_removeNth", "code": "theorem continuous_removeNth {n : \u2115} : Continuous fun l : List \u03b1 => removeNth l n", "start": [159, 1], "end": [160, 62], "kind": "commanddeclaration"}, {"full_name": "List.tendsto_prod", "code": "@[to_additive]\ntheorem tendsto_prod [Monoid \u03b1] [ContinuousMul \u03b1] {l : List \u03b1} :\n    Tendsto List.prod (\ud835\udcdd l) (\ud835\udcdd l.prod)", "start": [163, 1], "end": [171, 43], "kind": "commanddeclaration"}, {"full_name": "List.continuous_prod", "code": "@[to_additive]\ntheorem continuous_prod [Monoid \u03b1] [ContinuousMul \u03b1] : Continuous (prod : List \u03b1 \u2192 \u03b1)", "start": [175, 1], "end": [177, 57], "kind": "commanddeclaration"}, {"full_name": "Vector.tendsto_cons", "code": "theorem tendsto_cons {n : \u2115} {a : \u03b1} {l : Vector \u03b1 n} :\n    Tendsto (fun p : \u03b1 \u00d7 Vector \u03b1 n => p.1 ::\u1d65 p.2) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) (\ud835\udcdd (a ::\u1d65 l))", "start": [189, 1], "end": [192, 77], "kind": "commanddeclaration"}, {"full_name": "Vector.tendsto_insertNth", "code": "theorem tendsto_insertNth {n : \u2115} {i : Fin (n + 1)} {a : \u03b1} :\n    \u2200 {l : Vector \u03b1 n},\n      Tendsto (fun p : \u03b1 \u00d7 Vector \u03b1 n => insertNth p.1 i p.2) (\ud835\udcdd a \u00d7\u02e2 \ud835\udcdd l) (\ud835\udcdd (insertNth a i l))", "start": [195, 1], "end": [201, 101], "kind": "commanddeclaration"}, {"full_name": "Vector.continuous_insertNth'", "code": "theorem continuous_insertNth' {n : \u2115} {i : Fin (n + 1)} :\n    Continuous fun p : \u03b1 \u00d7 Vector \u03b1 n => insertNth p.1 i p.2", "start": [204, 1], "end": [207, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.continuous_insertNth", "code": "theorem continuous_insertNth {n : \u2115} {i : Fin (n + 1)} {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 Vector \u03b1 n}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun b => insertNth (f b) i (g b)", "start": [210, 1], "end": [212, 49], "kind": "commanddeclaration"}, {"full_name": "Vector.continuousAt_removeNth", "code": "theorem continuousAt_removeNth {n : \u2115} {i : Fin (n + 1)} :\n    \u2200 {l : Vector \u03b1 (n + 1)}, ContinuousAt (removeNth i) l", "start": [215, 1], "end": [220, 71], "kind": "commanddeclaration"}, {"full_name": "Vector.continuous_removeNth", "code": "theorem continuous_removeNth {n : \u2115} {i : Fin (n + 1)} :\n    Continuous (removeNth i : Vector \u03b1 (n + 1) \u2192 Vector \u03b1 n)", "start": [223, 1], "end": [225, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Export.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Export.MethodsRefPointed", "code": "private opaque MethodsRefPointed : NonemptyType.{0}", "start": [23, 1], "end": [23, 52], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.MethodsRef", "code": "private def MethodsRef : Type := MethodsRefPointed.type", "start": [25, 1], "end": [25, 56], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.Entry", "code": "inductive Entry\n  | name (n : Name)\n  | level (n : Level)\n  | expr (n : Expr)\n  | defn (n : Name)\nderiving Inhabited", "start": [27, 1], "end": [32, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.Alloc", "code": "structure Alloc (\u03b1) [BEq \u03b1] [Hashable \u03b1] where\n  map : HashMap \u03b1 Nat\n  next : Nat\nderiving Inhabited", "start": [38, 1], "end": [41, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.State", "code": "structure State where\n  names : Alloc Name := \u27e8HashMap.empty.insert Name.anonymous 0, 1\u27e9\n  levels : Alloc Level := \u27e8HashMap.empty.insert levelZero 0, 1\u27e9\n  exprs : Alloc Expr\n  defs : HashSet Name\n  stk : Array (Bool \u00d7 Entry)\nderiving Inhabited", "start": [43, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.OfState", "code": "class OfState (\u03b1 : Type) [BEq \u03b1] [Hashable \u03b1] where\n  get : State \u2192 Alloc \u03b1\n  modify : (Alloc \u03b1 \u2192 Alloc \u03b1) \u2192 State \u2192 State", "start": [51, 1], "end": [53, 47], "kind": "commanddeclaration"}, {"full_name": "Lean.ExportM", "code": "abbrev ExportM := StateT Export.State CoreM", "start": [69, 1], "end": [69, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.alloc", "code": "def alloc {\u03b1} [BEq \u03b1] [Hashable \u03b1] [OfState \u03b1] (a : \u03b1) : ExportM Nat := do\n  let n := (OfState.get (\u03b1 := \u03b1) (\u2190 get)).next\n  modify $ OfState.modify (\u03b1 := \u03b1) fun s \u21a6 {map := s.map.insert a n, next := n+1}\n  pure n", "start": [73, 1], "end": [76, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.exportName", "code": "def exportName (n : Name) : ExportM Nat := do\n  match (\u2190 get).names.map.find? n with\n  | some i => pure i\n  | none => match n with\n    | .anonymous => pure 0\n    | .num p a => let i \u2190 alloc n; IO.println s!\"{i} #NI {\u2190 exportName p} {a}\"; pure i\n    | .str p s => let i \u2190 alloc n; IO.println s!\"{i} #NS {\u2190 exportName p} {s}\"; pure i", "start": [78, 1], "end": [84, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.exportLevel", "code": "def exportLevel (L : Level) : ExportM Nat := do\n  match (\u2190 get).levels.map.find? L with\n  | some i => pure i\n  | none => match L with\n    | .zero => pure 0\n    | .succ l =>\n      let i \u2190 alloc L; IO.println s!\"{i} #US {\u2190 exportLevel l}\"; pure i\n    | .max l\u2081 l\u2082 =>\n      let i \u2190 alloc L; IO.println s!\"{i} #UM {\u2190 exportLevel l\u2081} {\u2190 exportLevel l\u2082}\"; pure i\n    | .imax l\u2081 l\u2082 =>\n      let i \u2190 alloc L; IO.println s!\"{i} #UIM {\u2190 exportLevel l\u2081} {\u2190 exportLevel l\u2082}\"; pure i\n    | .param n =>\n      let i \u2190 alloc L; IO.println s!\"{i} #UP {\u2190 exportName n}\"; pure i\n    | .mvar _ => unreachable!", "start": [86, 1], "end": [99, 30], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.biStr", "code": "def biStr : BinderInfo \u2192 String\n  | BinderInfo.default        => \"#BD\"\n  | BinderInfo.implicit       => \"#BI\"\n  | BinderInfo.strictImplicit => \"#BS\"\n  | BinderInfo.instImplicit   => \"#BC\"", "start": [101, 1], "end": [105, 39], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.exportExpr", "code": "partial def exportExpr (E : Expr) : ExportM Nat := do\n  match (\u2190 get).exprs.map.find? E with\n  | some i => pure i\n  | none => match E with\n    | .bvar n => let i \u2190 alloc E; IO.println s!\"{i} #EV {n}\"; pure i\n    | .fvar _ => unreachable!\n    | .mvar _ => unreachable!\n    | .sort l => let i \u2190 alloc E; IO.println s!\"{i} #ES {\u2190 exportLevel l}\"; pure i\n    | .const n ls =>\n      exportDef n\n      let i \u2190 alloc E\n      let mut s := s!\"{i} #EC {\u2190 exportName n}\"\n      for l in ls do s := s ++ s!\" {\u2190 exportLevel l}\"\n      IO.println s; pure i\n    | .app e\u2081 e\u2082 =>\n      let i \u2190 alloc E; IO.println s!\"{i} #EA {\u2190 exportExpr e\u2081} {\u2190 exportExpr e\u2082}\"; pure i\n    | .lam _ e\u2081 e\u2082 d =>\n      let i \u2190 alloc E\n      IO.println s!\"{i} #EL {biStr d} {\u2190 exportExpr e\u2081} {\u2190 exportExpr e\u2082}\"; pure i\n    | .forallE _ e\u2081 e\u2082 d =>\n      let i \u2190 alloc E\n      IO.println s!\"{i} #EP {biStr d} {\u2190 exportExpr e\u2081} {\u2190 exportExpr e\u2082}\"; pure i\n    | .letE _ e\u2081 e\u2082 e\u2083 _ =>\n      let i \u2190 alloc E\n      IO.println s!\"{i} #EP {\u2190 exportExpr e\u2081} {\u2190 exportExpr e\u2082} {\u2190 exportExpr e\u2083}\"; pure i\n    | .lit (.natVal n) => let i \u2190 alloc E; IO.println s!\"{i} #EN {n}\"; pure i\n    | .lit (.strVal s) => let i \u2190 alloc E; IO.println s!\"{i} #ET {s}\"; pure i\n    | .mdata _ _ => unreachable!\n    | .proj n k e =>\n      let i \u2190 alloc E; IO.println s!\"{i} #EJ {\u2190 exportName n} {k} {\u2190 exportExpr e}\"; pure i", "start": [110, 1], "end": [139, 92], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.exportDef", "code": "partial def exportDef (n : Name) : ExportM Unit := do\n  if (\u2190 get).defs.contains n then return\n  let ci \u2190 getConstInfo n\n  for c in ci.value!.getUsedConstants do\n    unless (\u2190 get).defs.contains c do\n      exportDef c\n  match ci with\n  | axiomInfo   val => axdef \"#AX\" val.name val.type val.levelParams\n  | defnInfo    val => defn \"#DEF\" val.name val.type val.value val.levelParams\n  | thmInfo     val => defn \"#THM\" val.name val.type val.value val.levelParams\n  | opaqueInfo  val => defn \"#CN\" val.name val.type val.value val.levelParams\n  | quotInfo    _ =>\n    IO.println \"#QUOT\"\n    for n in [``Quot, ``Quot.mk, ``Quot.lift, ``Quot.ind] do\n      insert n\n  | inductInfo  val => ind val.all\n  | ctorInfo    val => ind (\u2190 getConstInfoInduct val.induct).all\n  | recInfo     val => ind val.all\nwhere\n  insert (n : Name) : ExportM Unit :=\n    modify fun s \u21a6 { s with defs := s.defs.insert n }\n  defn (ty : String) (n : Name) (t e : Expr) (ls : List Name) : ExportM Unit := do\n    let mut s := s!\"{ty} {\u2190 exportName n} {\u2190 exportExpr t} {\u2190 exportExpr e}\"\n    for l in ls do s := s ++ s!\" {\u2190 exportName l}\"\n    IO.println s\n    insert n\n  axdef (ty : String) (n : Name) (t : Expr) (ls : List Name) : ExportM Unit := do\n    let mut s := s!\"{ty} {\u2190 exportName n} {\u2190 exportExpr t}\"\n    for l in ls do s := s ++ s!\" {\u2190 exportName l}\"\n    IO.println s\n    insert n\n  ind : List Name \u2192 ExportM Unit\n  | [] => unreachable!\n  | is@(i::_) => do\n    let val \u2190 getConstInfoInduct i\n    let mut s := match is.length with\n    | 1 => s!\"#IND {val.numParams}\"\n    | n => s!\"#MUT {val.numParams} {n}\"\n    for j in is do insert j; insert (mkRecName j)\n    for j in is do\n      let val \u2190 getConstInfoInduct j\n      s := s ++ s!\" {\u2190 exportName val.name} {\u2190 exportExpr val.type} {val.ctors.length}\"\n      for c in val.ctors do\n        insert c\n        s := s ++ s!\" {\u2190 exportName c} {\u2190 exportExpr (\u2190 getConstInfoCtor c).type}\"\n    for j in is do s \u2190 indbody j s\n    for l in val.levelParams do s := s ++ s!\" {\u2190 exportName l}\"\n    IO.println s\n  indbody (ind : Name) (s : String) : ExportM String := do\n    let val \u2190 getConstInfoInduct ind\n    let mut s := s ++ s!\" {\u2190 exportName ind} {\u2190 exportExpr val.type} {val.ctors.length}\"\n    for c in val.ctors do\n      s := s ++ s!\" {\u2190 exportName c} {\u2190 exportExpr (\u2190 getConstInfoCtor c).type}\"\n    pure s", "start": [141, 1], "end": [194, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Export.runExportM", "code": "def runExportM (m : ExportM \u03b1) : CoreM \u03b1 := m.run' default", "start": [198, 1], "end": [198, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/OreLocalization/Basic.lean", "imports": ["Mathlib/RingTheory/OreLocalization/OreSet.lean", "Mathlib/Tactic/NoncommRing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/MonoidLocalization.lean", "Mathlib/RingTheory/NonZeroDivisors.lean"], "premises": [{"full_name": "OreLocalization.oreEqv", "code": "def oreEqv : Setoid (R \u00d7 S) where\n  r rs rs' := \u2203 (u : S) (v : R), rs'.1 * u = rs.1 * v \u2227 (rs'.2 : R) * u = rs.2 * v\n  iseqv := by\n    refine \u27e8fun _ => \u27e81, 1, by simp\u27e9, ?_, ?_\u27e9\n    \u00b7 rintro \u27e8r, s\u27e9 \u27e8r', s'\u27e9 \u27e8u, v, hru, hsu\u27e9; dsimp only at *\n      rcases oreCondition (s : R) s' with \u27e8r\u2082, s\u2082, h\u2081\u27e9\n      rcases oreCondition r\u2082 u with \u27e8r\u2083, s\u2083, h\u2082\u27e9\n      have : (s : R) * ((v : R) * r\u2083) = (s : R) * (s\u2082 * s\u2083) := by\n        rw [\u2190 mul_assoc _ (s\u2082 : R), h\u2081, mul_assoc, h\u2082, \u2190 mul_assoc, \u2190 hsu, mul_assoc]\n      rcases ore_left_cancel (v * r\u2083) (s\u2082 * s\u2083) s this with \u27e8w, hw\u27e9\n      refine \u27e8s\u2082 * s\u2083 * w, u * r\u2083 * w, ?_, ?_\u27e9 <;> simp only [Submonoid.coe_mul, \u2190 hw]\n      \u00b7 simp only [\u2190 mul_assoc, hru]\n      \u00b7 simp only [\u2190 mul_assoc, hsu]\n    \u00b7 rintro \u27e8r\u2081, s\u2081\u27e9 \u27e8r\u2082, s\u2082\u27e9 \u27e8r\u2083, s\u2083\u27e9 \u27e8u, v, hur\u2081, hs\u2081u\u27e9 \u27e8u', v', hur\u2082, hs\u2082u\u27e9\n      rcases oreCondition v' u with \u27e8r', s', h\u27e9; dsimp only at *\n      refine \u27e8u' * s', v * r', ?_, ?_\u27e9 <;> simp only [Submonoid.coe_mul, \u2190 mul_assoc]\n      \u00b7 rw [hur\u2082, mul_assoc, h, \u2190 mul_assoc, hur\u2081]\n      \u00b7 rw [hs\u2082u, mul_assoc, h, \u2190 mul_assoc, hs\u2081u]", "start": [49, 1], "end": [68, 51], "kind": "commanddeclaration"}, {"full_name": "OreLocalization", "code": "def OreLocalization (R : Type*) [Monoid R] (S : Submonoid R) [OreSet S] :=\n  Quotient (OreLocalization.oreEqv R S)", "start": [73, 1], "end": [75, 40], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv", "code": "def oreDiv (r : R) (s : S) : R[S\u207b\u00b9] :=\n  Quotient.mk' (r, s)", "start": [94, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.ind", "code": "@[elab_as_elim]\nprotected theorem ind {\u03b2 : R[S\u207b\u00b9] \u2192 Prop} (c : \u2200 (r : R) (s : S), \u03b2 (r /\u2092 s)) : \u2200 q, \u03b2 q", "start": [103, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_eq_iff", "code": "theorem oreDiv_eq_iff {r\u2081 r\u2082 : R} {s\u2081 s\u2082 : S} :\n    r\u2081 /\u2092 s\u2081 = r\u2082 /\u2092 s\u2082 \u2194 \u2203 (u : S) (v : R), r\u2082 * u = r\u2081 * v \u2227 (s\u2082 : R) * u = s\u2081 * v", "start": [110, 1], "end": [112, 16], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.expand", "code": "protected theorem expand (r : R) (s : S) (t : R) (hst : (s : R) * t \u2208 S) :\n    r /\u2092 s = r * t /\u2092 \u27e8s * t, hst\u27e9", "start": [115, 1], "end": [119, 56], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.expand'", "code": "protected theorem expand' (r : R) (s s' : S) : r /\u2092 s = r * s' /\u2092 (s * s')", "start": [122, 1], "end": [124, 70], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.eq_of_num_factor_eq", "code": "protected theorem eq_of_num_factor_eq {r r' r\u2081 r\u2082 : R} {s t : S} (h : r * t = r' * t) :\n    r\u2081 * r * r\u2082 /\u2092 s = r\u2081 * r' * r\u2082 /\u2092 s", "start": [127, 1], "end": [142, 67], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.liftExpand", "code": "def liftExpand {C : Sort*} (P : R \u2192 S \u2192 C)\n    (hP : \u2200 (r t : R) (s : S) (ht : (s : R) * t \u2208 S), P r s = P (r * t) \u27e8s * t, ht\u27e9) : R[S\u207b\u00b9] \u2192 C :=\n  Quotient.lift (fun p : R \u00d7 S => P p.1 p.2) fun (r\u2081, s\u2081) (r\u2082, s\u2082) \u27e8u, v, hr\u2082, hs\u2082\u27e9 => by\n    dsimp at *\n    have s\u2081vS : (s\u2081 : R) * v \u2208 S := by\n      rw [\u2190 hs\u2082, \u2190 S.coe_mul]\n      exact SetLike.coe_mem (s\u2082 * u)\n    replace hs\u2082 : s\u2082 * u = \u27e8(s\u2081 : R) * v, s\u2081vS\u27e9\n    \u00b7 ext; simp [hs\u2082]\n    rw [hP r\u2081 v s\u2081 s\u2081vS, hP r\u2082 u s\u2082 (by norm_cast; rwa [hs\u2082]), hr\u2082]\n    simp only [\u2190 hs\u2082]; rfl", "start": [145, 1], "end": [157, 27], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.liftExpand_of", "code": "@[simp]\ntheorem liftExpand_of {C : Sort*} {P : R \u2192 S \u2192 C}\n    {hP : \u2200 (r t : R) (s : S) (ht : (s : R) * t \u2208 S), P r s = P (r * t) \u27e8s * t, ht\u27e9} (r : R)\n    (s : S) : liftExpand P hP (r /\u2092 s) = P r s", "start": [160, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.lift\u2082Expand", "code": "def lift\u2082Expand {C : Sort*} (P : R \u2192 S \u2192 R \u2192 S \u2192 C)\n    (hP :\n      \u2200 (r\u2081 t\u2081 : R) (s\u2081 : S) (ht\u2081 : (s\u2081 : R) * t\u2081 \u2208 S) (r\u2082 t\u2082 : R) (s\u2082 : S)\n        (ht\u2082 : (s\u2082 : R) * t\u2082 \u2208 S),\n        P r\u2081 s\u2081 r\u2082 s\u2082 = P (r\u2081 * t\u2081) \u27e8s\u2081 * t\u2081, ht\u2081\u27e9 (r\u2082 * t\u2082) \u27e8s\u2082 * t\u2082, ht\u2082\u27e9) :\n    R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] \u2192 C :=\n  liftExpand\n    (fun r\u2081 s\u2081 => liftExpand (P r\u2081 s\u2081) fun r\u2082 t\u2082 s\u2082 ht\u2082 => by\n      have := hP r\u2081 1 s\u2081 (by simp) r\u2082 t\u2082 s\u2082 ht\u2082\n      simp [this])\n    fun r\u2081 t\u2081 s\u2081 ht\u2081 => by\n    ext x; induction' x using OreLocalization.ind with r\u2082 s\u2082\n    dsimp only\n    rw [liftExpand_of, liftExpand_of, hP r\u2081 t\u2081 s\u2081 ht\u2081 r\u2082 1 s\u2082 (by simp)]; simp", "start": [167, 1], "end": [182, 79], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.lift\u2082Expand_of", "code": "@[simp]\ntheorem lift\u2082Expand_of {C : Sort*} {P : R \u2192 S \u2192 R \u2192 S \u2192 C}\n    {hP :\n      \u2200 (r\u2081 t\u2081 : R) (s\u2081 : S) (ht\u2081 : (s\u2081 : R) * t\u2081 \u2208 S) (r\u2082 t\u2082 : R) (s\u2082 : S)\n        (ht\u2082 : (s\u2082 : R) * t\u2082 \u2208 S),\n        P r\u2081 s\u2081 r\u2082 s\u2082 = P (r\u2081 * t\u2081) \u27e8s\u2081 * t\u2081, ht\u2081\u27e9 (r\u2082 * t\u2082) \u27e8s\u2082 * t\u2082, ht\u2082\u27e9}\n    (r\u2081 : R) (s\u2081 : S) (r\u2082 : R) (s\u2082 : S) : lift\u2082Expand P hP (r\u2081 /\u2092 s\u2081) (r\u2082 /\u2092 s\u2082) = P r\u2081 s\u2081 r\u2082 s\u2082", "start": [185, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul'", "code": "private def mul' (r\u2081 : R) (s\u2081 : S) (r\u2082 : R) (s\u2082 : S) : R[S\u207b\u00b9] :=\n  r\u2081 * oreNum r\u2082 s\u2081 /\u2092 (s\u2082 * oreDenom r\u2082 s\u2081)", "start": [195, 1], "end": [196, 45], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul'_char", "code": "private theorem mul'_char (r\u2081 r\u2082 : R) (s\u2081 s\u2082 : S) (u : S) (v : R) (huv : r\u2082 * (u : R) = s\u2081 * v) :\n    OreLocalization.mul' r\u2081 s\u2081 r\u2082 s\u2082 = r\u2081 * v /\u2092 (s\u2082 * u)", "start": [198, 1], "end": [215, 26], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul", "code": "protected def mul : R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] :=\n  lift\u2082Expand mul' fun r\u2082 p s\u2082 hp r\u2081 r s\u2081 hr => by\n    have h\u2081 := ore_eq r\u2081 s\u2082\n    set r\u2081' := oreNum r\u2081 s\u2082\n    set s\u2082' := oreDenom r\u2081 s\u2082\n    rcases oreCondition (\u2191s\u2082 * r\u2081') \u27e8s\u2082 * p, hp\u27e9 with \u27e8p', s_star, h\u2082\u27e9\n    dsimp at h\u2082\n    rcases oreCondition r (s\u2082' * s_star) with \u27e8p_flat, s_flat, h\u2083\u27e9\n    simp only [S.coe_mul] at h\u2083\n    have : r\u2081 * r * s_flat = s\u2082 * p * (p' * p_flat) := by\n      rw [\u2190 mul_assoc, \u2190 h\u2082, \u2190 h\u2081, mul_assoc, h\u2083]\n      simp only [mul_assoc]\n    rw [mul'_char (r\u2082 * p) (r\u2081 * r) \u27e8\u2191s\u2082 * p, hp\u27e9 \u27e8\u2191s\u2081 * r, hr\u27e9 _ _ this]\n    clear this\n    have hsssp : \u2191s\u2081 * \u2191s\u2082' * \u2191s_star * p_flat \u2208 S := by\n      rw [mul_assoc, mul_assoc, \u2190 mul_assoc (s\u2082' : R), \u2190 h\u2083, \u2190 mul_assoc]\n      exact S.mul_mem hr (SetLike.coe_mem s_flat)\n    have : (\u27e8\u2191s\u2081 * r, hr\u27e9 : S) * s_flat = \u27e8s\u2081 * s\u2082' * s_star * p_flat, hsssp\u27e9 := by\n      ext\n      simp only [Submonoid.coe_mul]\n      rw [mul_assoc, h\u2083, \u2190 mul_assoc, \u2190 mul_assoc]\n    rw [this]\n    clear this\n    rcases ore_left_cancel (p * p') (r\u2081' * (s_star : R)) s\u2082 (by simp [\u2190 mul_assoc, h\u2082])\n      with \u27e8s\u2082'', h\u2082''\u27e9\n    rw [\u2190 mul_assoc, mul_assoc r\u2082, OreLocalization.eq_of_num_factor_eq h\u2082'']\n    norm_cast at hsssp \u22a2\n    rw [\u2190 OreLocalization.expand _ _ _ hsssp, \u2190 mul_assoc]\n    apply OreLocalization.expand", "start": [217, 1], "end": [246, 33], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instMulOreLocalization", "code": "instance instMulOreLocalization : Mul R[S\u207b\u00b9] :=\n  \u27e8OreLocalization.mul\u27e9", "start": [249, 1], "end": [250, 24], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_mul_oreDiv", "code": "theorem oreDiv_mul_oreDiv {r\u2081 r\u2082 : R} {s\u2081 s\u2082 : S} :\n    r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r\u2081 * oreNum r\u2082 s\u2081 /\u2092 (s\u2082 * oreDenom r\u2082 s\u2081)", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_mul_char", "code": "theorem oreDiv_mul_char (r\u2081 r\u2082 : R) (s\u2081 s\u2082 : S) (r' : R) (s' : S) (huv : r\u2082 * (s' : R) = s\u2081 * r') :\n    r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r\u2081 * r' /\u2092 (s\u2082 * s')", "start": [257, 1], "end": [261, 34], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDivMulChar'", "code": "def oreDivMulChar' (r\u2081 r\u2082 : R) (s\u2081 s\u2082 : S) :\n    \u03a3'r' : R, \u03a3's' : S, r\u2082 * (s' : R) = s\u2081 * r' \u2227 r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r\u2081 * r' /\u2092 (s\u2082 * s') :=\n  \u27e8oreNum r\u2082 s\u2081, oreDenom r\u2082 s\u2081, ore_eq r\u2082 s\u2081, oreDiv_mul_oreDiv\u27e9", "start": [264, 1], "end": [268, 66], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instOneOreLocalization", "code": "instance instOneOreLocalization : One R[S\u207b\u00b9] :=\n  \u27e81 /\u2092 1\u27e9", "start": [271, 1], "end": [272, 11], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.one_def", "code": "protected theorem one_def : (1 : R[S\u207b\u00b9]) = 1 /\u2092 1", "start": [274, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.div_eq_one'", "code": "@[simp]\nprotected theorem div_eq_one' {r : R} (hr : r \u2208 S) : r /\u2092 \u27e8r, hr\u27e9 = 1", "start": [281, 1], "end": [284, 39], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.div_eq_one", "code": "@[simp]\nprotected theorem div_eq_one {s : S} : (s : R) /\u2092 s = 1", "start": [287, 1], "end": [289, 32], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.one_mul", "code": "protected theorem one_mul (x : R[S\u207b\u00b9]) : 1 * x = x", "start": [292, 1], "end": [294, 84], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_one", "code": "protected theorem mul_one (x : R[S\u207b\u00b9]) : x * 1 = x", "start": [297, 1], "end": [299, 72], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_assoc", "code": "protected theorem mul_assoc (x y z : R[S\u207b\u00b9]) : x * y * z = x * (y * z)", "start": [302, 1], "end": [316, 61], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instMonoidOreLocalization", "code": "instance instMonoidOreLocalization : Monoid R[S\u207b\u00b9] :=\n  { OreLocalization.instMulOreLocalization,\n    OreLocalization.instOneOreLocalization with\n    one_mul := OreLocalization.one_mul\n    mul_one := OreLocalization.mul_one\n    mul_assoc := OreLocalization.mul_assoc }", "start": [319, 1], "end": [324, 45], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_inv", "code": "protected theorem mul_inv (s s' : S) : ((s : R) /\u2092 s') * ((s' : R) /\u2092 s) = 1", "start": [326, 1], "end": [327, 55], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_one_div", "code": "@[simp]\nprotected theorem mul_one_div {r : R} {s t : S} : (r /\u2092 s) * (1 /\u2092 t) = r /\u2092 (t * s)", "start": [330, 1], "end": [332, 47], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_cancel", "code": "@[simp]\nprotected theorem mul_cancel {r : R} {s t : S} : (r /\u2092 s) * ((s : R) /\u2092 t) = r /\u2092 t", "start": [335, 1], "end": [337, 47], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_cancel'", "code": "@[simp]\nprotected theorem mul_cancel' {r\u2081 r\u2082 : R} {s t : S} :\n    (r\u2081 /\u2092 s) * ((s * r\u2082) /\u2092 t) = (r\u2081 * r\u2082) /\u2092 t", "start": [340, 1], "end": [343, 56], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.div_one_mul", "code": "@[simp]\ntheorem div_one_mul {p r : R} {s : S} : (r /\u2092 1) * (p /\u2092 s) = (r * p) /\u2092 s", "start": [346, 1], "end": [349, 47], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.numeratorUnit", "code": "def numeratorUnit (s : S) : Units R[S\u207b\u00b9] where\n  val := (s : R) /\u2092 1\n  inv := (1 : R) /\u2092 s\n  val_inv := OreLocalization.mul_inv s 1\n  inv_val := OreLocalization.mul_inv 1 s", "start": [352, 1], "end": [357, 41], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.numeratorHom", "code": "def numeratorHom : R \u2192* R[S\u207b\u00b9] where\n  toFun r := r /\u2092 1\n  map_one' := rfl\n  map_mul' _ _ := div_one_mul.symm", "start": [360, 1], "end": [365, 35], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.numeratorHom_apply", "code": "theorem numeratorHom_apply {r : R} : numeratorHom r = r /\u2092 (1 : S)", "start": [368, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.numerator_isUnit", "code": "theorem numerator_isUnit (s : S) : IsUnit (numeratorHom (s : R) : R[S\u207b\u00b9])", "start": [372, 1], "end": [373, 25], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalMulHom", "code": "def universalMulHom : R[S\u207b\u00b9] \u2192* T\n    where\n  toFun x :=\n    x.liftExpand (fun r s => f r * ((fS s)\u207b\u00b9 : Units T)) fun r t s ht => by\n      simp only []\n      have : (fS \u27e8s * t, ht\u27e9 : T) = fS s * f t := by\n        simp only [\u2190 hf, MonoidHom.map_mul]\n      conv_rhs =>\n        rw [MonoidHom.map_mul, \u2190 mul_one (f r), \u2190 Units.val_one, \u2190 mul_left_inv (fS s)]\n        rw [Units.val_mul, \u2190 mul_assoc, mul_assoc _ (fS s : T), \u2190 this, mul_assoc]\n      simp only [mul_one, Units.mul_inv]\n  map_one' := by simp only []; rw [OreLocalization.one_def, liftExpand_of]; simp\n  map_mul' x y := by\n    simp only []\n    induction' x using OreLocalization.ind with r\u2081 s\u2081\n    induction' y using OreLocalization.ind with r\u2082 s\u2082\n    rcases oreDivMulChar' r\u2081 r\u2082 s\u2081 s\u2082 with \u27e8ra, sa, ha, ha'\u27e9; rw [ha']; clear ha'\n    rw [liftExpand_of, liftExpand_of, liftExpand_of]\n    conv_rhs =>\n      congr\n      \u00b7 skip\n      congr\n      rw [\u2190 mul_one (f r\u2082), \u2190 (fS sa).mul_inv, \u2190 mul_assoc, \u2190 hf, \u2190 f.map_mul, ha, f.map_mul]\n    rw [mul_assoc, mul_assoc, mul_assoc, \u2190 mul_assoc _ (f s\u2081), hf s\u2081, (fS s\u2081).inv_mul, one_mul,\n      f.map_mul, mul_assoc, fS.map_mul, \u2190 Units.val_mul]\n    rfl", "start": [384, 1], "end": [412, 8], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalMulHom_apply", "code": "theorem universalMulHom_apply {r : R} {s : S} :\n    universalMulHom f fS hf (r /\u2092 s) = f r * ((fS s)\u207b\u00b9 : Units T)", "start": [415, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalMulHom_commutes", "code": "theorem universalMulHom_commutes {r : R} : universalMulHom f fS hf (numeratorHom r) = f r", "start": [420, 1], "end": [421, 51], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalMulHom_unique", "code": "theorem universalMulHom_unique (\u03c6 : R[S\u207b\u00b9] \u2192* T) (huniv : \u2200 r : R, \u03c6 (numeratorHom r) = f r) :\n    \u03c6 = universalMulHom f fS hf", "start": [424, 1], "end": [430, 52], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_mul_oreDiv_comm", "code": "theorem oreDiv_mul_oreDiv_comm {r\u2081 r\u2082 : R} {s\u2081 s\u2082 : S} :\n    r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r\u2081 * r\u2082 /\u2092 (s\u2081 * s\u2082)", "start": [441, 1], "end": [443, 75], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.localizationMap", "code": "protected def localizationMap : S.LocalizationMap R[S\u207b\u00b9]\n    where\n  toFun := numeratorHom\n  map_one' := rfl\n  map_mul' r\u2081 r\u2082 := by simp\n  map_units' := numerator_isUnit\n  surj' z := by\n    induction' z using OreLocalization.ind with r s\n    use (r, s); dsimp\n    rw [numeratorHom_apply, numeratorHom_apply]; simp\n  eq_iff_exists' r\u2081 r\u2082 := by\n    dsimp; constructor\n    \u00b7 intro h\n      rw [numeratorHom_apply, numeratorHom_apply, oreDiv_eq_iff] at h\n      rcases h with \u27e8u, v, h\u2081, h\u2082\u27e9\n      dsimp at h\u2082\n      rw [one_mul, one_mul] at h\u2082\n      subst h\u2082\n      use u\n      simpa only [mul_comm] using h\u2081.symm\n    \u00b7 rintro \u27e8s, h\u27e9\n      rw [numeratorHom_apply, numeratorHom_apply, oreDiv_eq_iff]\n      refine' \u27e8s, s, _, _\u27e9\n      \u00b7 simpa [mul_comm] using h.symm\n      \u00b7 simp [one_mul]", "start": [455, 1], "end": [480, 23], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.equivMonoidLocalization", "code": "protected noncomputable def equivMonoidLocalization : Localization S \u2243* R[S\u207b\u00b9] :=\n  Localization.mulEquivOfQuotient (OreLocalization.localizationMap R S)", "start": [483, 1], "end": [485, 72], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add''", "code": "private def add'' (r\u2081 : R) (s\u2081 : S) (r\u2082 : R) (s\u2082 : S) : R[S\u207b\u00b9] :=\n  (r\u2081 * oreDenom (s\u2081 : R) s\u2082 + r\u2082 * oreNum (s\u2081 : R) s\u2082) /\u2092 (s\u2081 * oreDenom (s\u2081 : R) s\u2082)", "start": [494, 1], "end": [495, 87], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add''_char", "code": "private theorem add''_char (r\u2081 : R) (s\u2081 : S) (r\u2082 : R) (s\u2082 : S) (rb : R) (sb : S)\n    (hb : (s\u2081 : R) * sb = (s\u2082 : R) * rb) :\n    add'' r\u2081 s\u2081 r\u2082 s\u2082 = (r\u2081 * sb + r\u2082 * rb) /\u2092 (s\u2081 * sb)", "start": [497, 1], "end": [526, 17], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add'", "code": "private def add' (r\u2082 : R) (s\u2082 : S) : R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] :=\n  (Quotient.lift\n      fun r\u2081s\u2081 : R \u00d7 S => add'' r\u2081s\u2081.1 r\u2081s\u2081.2 r\u2082 s\u2082) <| by\n    rintro \u27e8r\u2081', s\u2081'\u27e9 \u27e8r\u2081, s\u2081\u27e9 \u27e8sb, rb, hb, hb'\u27e9\n    rcases oreCondition (s\u2081' : R) s\u2082 with \u27e8rc, sc, hc\u27e9\n    rcases oreCondition rb sc with \u27e8rd, sd, hd\u27e9\n    dsimp at *\n    rw [add''_char _ _ _ _ rc sc hc]\n    have : \u2191s\u2081 * \u2191(sb * sd) = \u2191s\u2082 * (rc * rd) := by\n      simp only [Submonoid.coe_mul]\n      rw [\u2190 mul_assoc, hb', mul_assoc, hd, \u2190 mul_assoc, hc, mul_assoc]\n    rw [add''_char _ _ _ _ (rc * rd : R) (sb * sd : S) this]\n    simp only [Submonoid.coe_mul]\n    rw [\u2190 mul_assoc (a := r\u2081) (b := (sb : R)), hb, mul_assoc (a := r\u2081') (b := (rb : R)), hd,\n      \u2190 mul_assoc, \u2190 mul_assoc, \u2190 add_mul, oreDiv_eq_iff]\n    use 1\n    use rd\n    constructor\n    \u00b7 simp\n    \u00b7 simp only [mul_one, Submonoid.coe_one, Submonoid.coe_mul] at this \u22a2\n      rw [hc, this, mul_assoc]", "start": [530, 1], "end": [555, 31], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add'_comm", "code": "private theorem add'_comm (r\u2081 r\u2082 : R) (s\u2081 s\u2082 : S) :\n    add' r\u2081 s\u2081 (r\u2082 /\u2092 s\u2082) = add' r\u2082 s\u2082 (r\u2081 /\u2092 s\u2081)", "start": [557, 1], "end": [586, 26], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add", "code": "private def add : R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] := fun x =>\n  Quotient.lift (fun rs : R \u00d7 S => add' rs.1 rs.2 x)\n    (by\n      rintro \u27e8r\u2081, s\u2081\u27e9 \u27e8r\u2082, s\u2082\u27e9 hyz\n      induction' x using OreLocalization.ind with r\u2083 s\u2083\n      dsimp; rw [add'_comm, add'_comm r\u2082]\n      simp [(\u00b7 /\u2092 \u00b7), Quotient.mk', Quotient.sound hyz])", "start": [588, 1], "end": [596, 57], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instAddOreLocalization", "code": "instance instAddOreLocalization : Add R[S\u207b\u00b9] :=\n  \u27e8add\u27e9", "start": [598, 1], "end": [599, 8], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_add_oreDiv", "code": "theorem oreDiv_add_oreDiv {r r' : R} {s s' : S} :\n    r /\u2092 s + r' /\u2092 s' =\n      (r * oreDenom (s : R) s' + r' * oreNum (s : R) s') /\u2092 (s * oreDenom (s : R) s')", "start": [601, 1], "end": [604, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDiv_add_char", "code": "theorem oreDiv_add_char {r r' : R} (s s' : S) (rb : R) (sb : S) (h : (s : R) * sb = s' * rb) :\n    r /\u2092 s + r' /\u2092 s' = (r * sb + r' * rb) /\u2092 (s * sb)", "start": [607, 1], "end": [611, 31], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDivAddChar'", "code": "def oreDivAddChar' (r r' : R) (s s' : S) :\n    \u03a3'r'' : R,\n      \u03a3's'' : S, (s : R) * s'' = s' * r'' \u2227 r /\u2092 s + r' /\u2092 s' = (r * s'' + r' * r'') /\u2092 (s * s'') :=\n  \u27e8oreNum (s : R) s', oreDenom (s : R) s', ore_eq (s : R) s', oreDiv_add_oreDiv\u27e9", "start": [614, 1], "end": [619, 81], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add_oreDiv", "code": "@[simp]\ntheorem add_oreDiv {r r' : R} {s : S} : r /\u2092 s + r' /\u2092 s = (r + r') /\u2092 s", "start": [622, 1], "end": [624, 43], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add_assoc", "code": "protected theorem add_assoc (x y z : R[S\u207b\u00b9]) : x + y + z = x + (y + z)", "start": [627, 1], "end": [652, 35], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.zero", "code": "private def zero : R[S\u207b\u00b9] :=\n  0 /\u2092 1", "start": [655, 1], "end": [656, 9], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.zero_def", "code": "protected theorem zero_def : (0 : R[S\u207b\u00b9]) = 0 /\u2092 1", "start": [661, 1], "end": [662, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.zero_div_eq_zero", "code": "@[simp]\ntheorem zero_div_eq_zero (s : S) : 0 /\u2092 s = 0", "start": [665, 1], "end": [668, 24], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.zero_add", "code": "protected theorem zero_add (x : R[S\u207b\u00b9]) : 0 + x = x", "start": [671, 1], "end": [673, 44], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add_comm", "code": "protected theorem add_comm (x y : R[S\u207b\u00b9]) : x + y = y + x", "start": [676, 1], "end": [679, 48], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instAddCommMonoidOreLocalization", "code": "instance instAddCommMonoidOreLocalization : AddCommMonoid R[S\u207b\u00b9] :=\n  { OreLocalization.instAddOreLocalization with\n    add_comm := OreLocalization.add_comm\n    add_assoc := OreLocalization.add_assoc\n    zero := zero\n    zero_add := OreLocalization.zero_add\n    add_zero := fun x => by rw [OreLocalization.add_comm, OreLocalization.zero_add] }", "start": [682, 1], "end": [688, 86], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.zero_mul", "code": "protected theorem zero_mul (x : R[S\u207b\u00b9]) : 0 * x = 0", "start": [690, 1], "end": [692, 77], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_zero", "code": "protected theorem mul_zero (x : R[S\u207b\u00b9]) : x * 0 = 0", "start": [695, 1], "end": [697, 77], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.left_distrib", "code": "protected theorem left_distrib (x y z : R[S\u207b\u00b9]) : x * (y + z) = x * y + x * z", "start": [700, 1], "end": [728, 63], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.right_distrib", "code": "theorem right_distrib (x y z : R[S\u207b\u00b9]) : (x + y) * z = x * z + y * z", "start": [731, 1], "end": [740, 34], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instSemiringOreLocalization", "code": "instance instSemiringOreLocalization : Semiring R[S\u207b\u00b9] :=\n  { OreLocalization.instAddCommMonoidOreLocalization,\n    OreLocalization.instMonoidOreLocalization with\n    zero_mul := OreLocalization.zero_mul\n    mul_zero := OreLocalization.mul_zero\n    left_distrib := OreLocalization.left_distrib\n    right_distrib := right_distrib }", "start": [743, 1], "end": [749, 37], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalHom", "code": "def universalHom : R[S\u207b\u00b9] \u2192+* T :=\n  {\n    universalMulHom f.toMonoidHom fS\n      hf with\n    map_zero' := by\n      change (universalMulHom f.toMonoidHom fS hf : R[S\u207b\u00b9] \u2192 T) 0 = 0\n      rw [OreLocalization.zero_def, universalMulHom_apply]\n      simp\n    map_add' := fun x y => by\n      change (universalMulHom f.toMonoidHom fS hf : R[S\u207b\u00b9] \u2192 T) (x + y)\n        = (universalMulHom f.toMonoidHom fS hf : R[S\u207b\u00b9] \u2192 T) x\n        + (universalMulHom f.toMonoidHom fS hf : R[S\u207b\u00b9] \u2192 T) y\n      induction' x using OreLocalization.ind with r\u2081 s\u2081\n      induction' y using OreLocalization.ind with r\u2082 s\u2082\n      rcases oreDivAddChar' r\u2081 r\u2082 s\u2081 s\u2082 with \u27e8r\u2083, s\u2083, h\u2083, h\u2083'\u27e9\n      rw [h\u2083']\n      clear h\u2083'\n      simp only [universalMulHom_apply, RingHom.toMonoidHom_eq_coe, MonoidHom.coe_coe]\n      simp only [mul_inv_rev, MonoidHom.map_mul, RingHom.map_add, RingHom.map_mul, Units.val_mul]\n      rw [add_mul, \u2190 mul_assoc, mul_assoc (f r\u2081), hf, \u2190 Units.val_mul]\n      simp only [mul_one, mul_right_inv, Units.val_one]\n      congr 1\n      rw [mul_assoc]\n      congr 1\n      norm_cast at h\u2083\n      have h\u2083' := Subtype.coe_eq_of_eq_mk h\u2083\n      rw [\u2190 Units.val_mul, \u2190 mul_inv_rev, \u2190 fS.map_mul, h\u2083']\n      have hs\u2082r\u2083 : \u2191s\u2082 * r\u2083 \u2208 S := by\n        rw [\u2190 h\u2083]\n        exact SetLike.coe_mem (s\u2081 * s\u2083)\n      apply (Units.inv_mul_cancel_left (fS s\u2082) _).symm.trans\n      conv_lhs =>\n        congr\n        \u00b7 skip\n        rw [\u2190 Units.mul_inv_cancel_left (fS \u27e8s\u2082 * r\u2083, hs\u2082r\u2083\u27e9) (fS s\u2082), mul_assoc, mul_assoc]\n        congr\n        \u00b7 skip\n        rw [\u2190 hf, \u2190 mul_assoc (f s\u2082), \u2190 f.map_mul]\n        conv =>\n          congr\n          \u00b7 skip\n          congr\n          rw [\u2190 h\u2083]\n        rw [hf, \u2190 mul_assoc, \u2190 h\u2083', Units.inv_mul]\n      rw [one_mul, \u2190 h\u2083', Units.mul_inv, mul_one] }", "start": [759, 1], "end": [808, 52], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalHom_apply", "code": "theorem universalHom_apply {r : R} {s : S} :\n    universalHom f fS hf (r /\u2092 s) = f r * ((fS s)\u207b\u00b9 : Units T)", "start": [811, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalHom_commutes", "code": "theorem universalHom_commutes {r : R} : universalHom f fS hf (numeratorHom r) = f r", "start": [816, 1], "end": [817, 48], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.universalHom_unique", "code": "theorem universalHom_unique (\u03c6 : R[S\u207b\u00b9] \u2192+* T) (huniv : \u2200 r : R, \u03c6 (numeratorHom r) = f r) :\n    \u03c6 = universalHom f fS hf", "start": [820, 1], "end": [822, 101], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.neg", "code": "protected def neg : R[S\u207b\u00b9] \u2192 R[S\u207b\u00b9] :=\n  liftExpand (fun (r : R) (s : S) => -r /\u2092 s) fun r t s ht => by\n    simp only []\n    rw [neg_mul_eq_neg_mul, \u2190 OreLocalization.expand]", "start": [833, 1], "end": [838, 54], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.instNegOreLocalization", "code": "instance instNegOreLocalization : Neg R[S\u207b\u00b9] :=\n  \u27e8OreLocalization.neg\u27e9", "start": [841, 1], "end": [842, 24], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.neg_def", "code": "@[simp]\nprotected theorem neg_def (r : R) (s : S) : -(r /\u2092 s) = -r /\u2092 s", "start": [844, 1], "end": [846, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.add_left_neg", "code": "protected theorem add_left_neg (x : R[S\u207b\u00b9]) : -x + x = 0", "start": [849, 1], "end": [850, 56], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.ring", "code": "instance ring : Ring R[S\u207b\u00b9] :=\n  { OreLocalization.instSemiringOreLocalization,\n    OreLocalization.instNegOreLocalization with\n    add_left_neg := OreLocalization.add_left_neg }", "start": [853, 1], "end": [856, 51], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.numeratorHom_inj", "code": "theorem numeratorHom_inj (hS : S \u2264 R\u2070) : Function.Injective (numeratorHom : R \u2192 R[S\u207b\u00b9])", "start": [860, 1], "end": [865, 91], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.nontrivial_of_nonZeroDivisors", "code": "theorem nontrivial_of_nonZeroDivisors [Nontrivial R] (hS : S \u2264 R\u2070) : Nontrivial R[S\u207b\u00b9]", "start": [868, 1], "end": [871, 73], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.nontrivial", "code": "instance nontrivial : Nontrivial R[R\u2070\u207b\u00b9] :=\n  nontrivial_of_nonZeroDivisors (refl R\u2070)", "start": [884, 1], "end": [885, 42], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.inv", "code": "protected def inv : R[R\u2070\u207b\u00b9] \u2192 R[R\u2070\u207b\u00b9] :=\n  liftExpand\n    (fun r s =>\n      if hr : r = (0 : R) then (0 : R[R\u2070\u207b\u00b9])\n      else s /\u2092 \u27e8r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr\u27e9)\n    (by\n      intro r t s hst\n      by_cases hr : r = 0\n      \u00b7 simp [hr]\n      \u00b7 by_cases ht : t = 0\n        \u00b7 exfalso\n          apply nonZeroDivisors.coe_ne_zero \u27e8_, hst\u27e9\n          simp [ht, mul_zero]\n        \u00b7 simp only [hr, ht, dif_neg, not_false_iff, or_self_iff, mul_eq_zero]\n          apply OreLocalization.expand)", "start": [889, 1], "end": [905, 40], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.inv'", "code": "instance inv' : Inv R[R\u2070\u207b\u00b9] :=\n  \u27e8OreLocalization.inv\u27e9", "start": [908, 1], "end": [909, 24], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.inv_def", "code": "protected theorem inv_def {r : R} {s : R\u2070} :\n    (r /\u2092 s)\u207b\u00b9 =\n      if hr : r = (0 : R) then (0 : R[R\u2070\u207b\u00b9])\n      else s /\u2092 \u27e8r, fun _ => eq_zero_of_ne_zero_of_mul_right_eq_zero hr\u27e9", "start": [911, 1], "end": [915, 6], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.mul_inv_cancel", "code": "protected theorem mul_inv_cancel (x : R[R\u2070\u207b\u00b9]) (h : x \u2260 0) : x * x\u207b\u00b9 = 1", "start": [918, 1], "end": [926, 38], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.inv_zero", "code": "protected theorem inv_zero : (0 : R[R\u2070\u207b\u00b9])\u207b\u00b9 = 0", "start": [929, 1], "end": [931, 7], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.divisionRing", "code": "instance divisionRing : DivisionRing R[R\u2070\u207b\u00b9] :=\n  { OreLocalization.nontrivial,\n    OreLocalization.inv',\n    OreLocalization.ring with\n    mul_inv_cancel := OreLocalization.mul_inv_cancel\n    inv_zero := OreLocalization.inv_zero }", "start": [934, 1], "end": [939, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/NhdsSet.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhdsSet_Ioi", "code": "@[simp] theorem nhdsSet_Ioi : \ud835\udcdd\u02e2 (Ioi a) = \ud835\udcdf (Ioi a)", "start": [32, 1], "end": [32, 78], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Iio", "code": "@[simp] theorem nhdsSet_Iio : \ud835\udcdd\u02e2 (Iio a) = \ud835\udcdf (Iio a)", "start": [33, 1], "end": [33, 78], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Ioo", "code": "@[simp] theorem nhdsSet_Ioo : \ud835\udcdd\u02e2 (Ioo a b) = \ud835\udcdf (Ioo a b)", "start": [34, 1], "end": [34, 82], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Ici", "code": "theorem nhdsSet_Ici : \ud835\udcdd\u02e2 (Ici a) = \ud835\udcdd a \u2294 \ud835\udcdf (Ioi a)", "start": [36, 1], "end": [37, 49], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Iic", "code": "theorem nhdsSet_Iic : \ud835\udcdd\u02e2 (Iic a) = \ud835\udcdd a \u2294 \ud835\udcdf (Iio a)", "start": [39, 1], "end": [39, 77], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Ico", "code": "theorem nhdsSet_Ico (h : a < b) : \ud835\udcdd\u02e2 (Ico a b) = \ud835\udcdd a \u2294 \ud835\udcdf (Ioo a b)", "start": [41, 1], "end": [42, 56], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Ioc", "code": "theorem nhdsSet_Ioc (h : a < b) : \ud835\udcdd\u02e2 (Ioc a b) = \ud835\udcdd b \u2294 \ud835\udcdf (Ioo a b)", "start": [44, 1], "end": [45, 57], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_Icc", "code": "theorem nhdsSet_Icc (h : a \u2264 b) : \ud835\udcdd\u02e2 (Icc a b) = \ud835\udcdd a \u2294 \ud835\udcdd b \u2294 \ud835\udcdf (Ioo a b)", "start": [47, 1], "end": [50, 73], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhdsSet_Ici_iff", "code": "@[simp]\ntheorem Ioi_mem_nhdsSet_Ici_iff : Ioi a \u2208 \ud835\udcdd\u02e2 (Ici b) \u2194 a < b", "start": [56, 1], "end": [58, 46], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhdsSet_Ici", "code": "alias \u27e8_, Ioi_mem_nhdsSet_Ici\u27e9 := Ioi_mem_nhdsSet_Ici_iff", "start": [60, 1], "end": [60, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ici_mem_nhdsSet_Ici", "code": "theorem Ici_mem_nhdsSet_Ici (h : a < b) : Ici a \u2208 \ud835\udcdd\u02e2 (Ici b)", "start": [62, 1], "end": [63, 62], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhdsSet_Iic_iff", "code": "theorem Iio_mem_nhdsSet_Iic_iff : Iio b \u2208 \ud835\udcdd\u02e2 (Iic a) \u2194 a < b", "start": [69, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhdsSet_Iic", "code": "alias \u27e8_, Iio_mem_nhdsSet_Iic\u27e9 := Iio_mem_nhdsSet_Iic_iff", "start": [72, 1], "end": [72, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Iic_mem_nhdsSet_Iic", "code": "theorem Iic_mem_nhdsSet_Iic (h : a < b) : Iic b \u2208 \ud835\udcdd\u02e2 (Iic a)", "start": [74, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhdsSet_Icc", "code": "theorem Ioi_mem_nhdsSet_Icc (h : a < b) : Ioi a \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [81, 1], "end": [82, 60], "kind": "commanddeclaration"}, {"full_name": "Ici_mem_nhdsSet_Icc", "code": "theorem Ici_mem_nhdsSet_Icc (h : a < b) : Ici a \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [84, 1], "end": [85, 62], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhdsSet_Icc", "code": "theorem Iio_mem_nhdsSet_Icc (h : b < c) : Iio c \u2208 \ud835\udcdd\u02e2 (Icc a b)", "start": [87, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "Iic_mem_nhdsSet_Icc", "code": "theorem Iic_mem_nhdsSet_Icc (h : b < c) : Iic c \u2208 \ud835\udcdd\u02e2 (Icc a b)", "start": [90, 1], "end": [91, 62], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsSet_Icc", "code": "theorem Ioo_mem_nhdsSet_Icc (h : a < b) (h' : c < d) : Ioo a d \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [93, 1], "end": [94, 61], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsSet_Icc", "code": "theorem Ico_mem_nhdsSet_Icc (h : a < b) (h' : c < d) : Ico a d \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [96, 1], "end": [97, 61], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsSet_Icc", "code": "theorem Ioc_mem_nhdsSet_Icc (h : a < b) (h' : c < d) : Ioc a d \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [99, 1], "end": [100, 61], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsSet_Icc", "code": "theorem Icc_mem_nhdsSet_Icc (h : a < b) (h' : c < d) : Icc a d \u2208 \ud835\udcdd\u02e2 (Icc b c)", "start": [102, 1], "end": [103, 61], "kind": "commanddeclaration"}, {"full_name": "Ici_mem_nhdsSet_Ico", "code": "theorem Ici_mem_nhdsSet_Ico (h : a < b) : Ici a \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [109, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhdsSet_Ico", "code": "theorem Ioi_mem_nhdsSet_Ico (h : a < b) : Ioi a \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [112, 1], "end": [113, 60], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhdsSet_Ico", "code": "theorem Iio_mem_nhdsSet_Ico (h : b \u2264 c) : Iio c \u2208 \ud835\udcdd\u02e2 (Ico a b)", "start": [115, 1], "end": [116, 47], "kind": "commanddeclaration"}, {"full_name": "Iic_mem_nhdsSet_Ico", "code": "theorem Iic_mem_nhdsSet_Ico (h : b \u2264 c) : Iic c \u2208 \ud835\udcdd\u02e2 (Ico a b)", "start": [118, 1], "end": [119, 62], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsSet_Ico", "code": "theorem Ioo_mem_nhdsSet_Ico (h : a < b) (h' : c \u2264 d) : Ioo a d \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [121, 1], "end": [122, 61], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsSet_Ico", "code": "theorem Icc_mem_nhdsSet_Ico (h : a < b) (h' : c \u2264 d) : Icc a d \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [124, 1], "end": [125, 61], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsSet_Ico", "code": "theorem Ioc_mem_nhdsSet_Ico (h : a < b) (h' : c \u2264 d) : Ioc a d \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [127, 1], "end": [128, 61], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsSet_Ico", "code": "theorem Ico_mem_nhdsSet_Ico (h : a < b) (h' : c \u2264 d) : Ico a d \u2208 \ud835\udcdd\u02e2 (Ico b c)", "start": [130, 1], "end": [131, 61], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhdsSet_Ioc", "code": "theorem Ioi_mem_nhdsSet_Ioc (h : a \u2264 b) : Ioi a \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [137, 1], "end": [138, 47], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhdsSet_Ioc", "code": "theorem Iio_mem_nhdsSet_Ioc (h : b < c) : Iio c \u2208 \ud835\udcdd\u02e2 (Ioc a b)", "start": [140, 1], "end": [141, 60], "kind": "commanddeclaration"}, {"full_name": "Ici_mem_nhdsSet_Ioc", "code": "theorem Ici_mem_nhdsSet_Ioc (h : a \u2264 b) : Ici a \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [143, 1], "end": [144, 62], "kind": "commanddeclaration"}, {"full_name": "Iic_mem_nhdsSet_Ioc", "code": "theorem Iic_mem_nhdsSet_Ioc (h : b < c) : Iic c \u2208 \ud835\udcdd\u02e2 (Ioc a b)", "start": [146, 1], "end": [147, 60], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsSet_Ioc", "code": "theorem Ioo_mem_nhdsSet_Ioc (h : a \u2264 b) (h' : c < d) : Ioo a d \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [149, 1], "end": [150, 61], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsSet_Ioc", "code": "theorem Icc_mem_nhdsSet_Ioc (h : a \u2264 b) (h' : c < d) : Icc a d \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [152, 1], "end": [153, 61], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsSet_Ioc", "code": "theorem Ioc_mem_nhdsSet_Ioc (h : a \u2264 b) (h' : c < d) : Ioc a d \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [155, 1], "end": [156, 61], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsSet_Ioc", "code": "theorem Ico_mem_nhdsSet_Ioc (h : a \u2264 b) (h' : c < d) : Ico a d \u2208 \ud835\udcdd\u02e2 (Ioc b c)", "start": [158, 1], "end": [159, 61], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhdsSet_Iic_Iio", "code": "theorem hasBasis_nhdsSet_Iic_Iio (a : \u03b1) [h : Nonempty (Ioi a)] :\n    HasBasis (\ud835\udcdd\u02e2 (Iic a)) (a < \u00b7) Iio", "start": [169, 1], "end": [174, 73], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhdsSet_Iic_Iic", "code": "theorem hasBasis_nhdsSet_Iic_Iic (a : \u03b1) [NeBot (\ud835\udcdd[>] a)] :\n    HasBasis (\ud835\udcdd\u02e2 (Iic a)) (a < \u00b7) Iic", "start": [176, 1], "end": [182, 91], "kind": "commanddeclaration"}, {"full_name": "Iic_mem_nhdsSet_Iic_iff", "code": "@[simp]\ntheorem Iic_mem_nhdsSet_Iic_iff {a b : \u03b1} [NeBot (\ud835\udcdd[>] b)] : Iic a \u2208 \ud835\udcdd\u02e2 (Iic b) \u2194 b < a", "start": [184, 1], "end": [187, 91], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhdsSet_Ici_Ioi", "code": "theorem hasBasis_nhdsSet_Ici_Ioi (a : \u03b1) [Nonempty (Iio a)] :\n    HasBasis (\ud835\udcdd\u02e2 (Ici a)) (\u00b7 < a) Ioi", "start": [189, 1], "end": [191, 79], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhdsSet_Ici_Ici", "code": "theorem hasBasis_nhdsSet_Ici_Ici (a : \u03b1) [NeBot (\ud835\udcdd[<] a)] :\n    HasBasis (\ud835\udcdd\u02e2 (Ici a)) (\u00b7 < a) Ici", "start": [193, 1], "end": [195, 77], "kind": "commanddeclaration"}, {"full_name": "Ici_mem_nhdsSet_Ici_iff", "code": "@[simp]\ntheorem Ici_mem_nhdsSet_Ici_iff {a b : \u03b1} [NeBot (\ud835\udcdd[<] b)] : Ici a \u2208 \ud835\udcdd\u02e2 (Ici b) \u2194 a < b", "start": [197, 1], "end": [199, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Adjunctions.lean", "imports": ["Mathlib/GroupTheory/FreeAbelianGroup.lean", "Mathlib/Algebra/Category/GroupCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCommGroupCat.free", "code": "def free : Type u \u2964 AddCommGroupCat where\n  obj \u03b1 := of (FreeAbelianGroup \u03b1)\n  map := FreeAbelianGroup.map\n  map_id _ := AddMonoidHom.ext FreeAbelianGroup.map_id_apply\n  map_comp _ _ := AddMonoidHom.ext FreeAbelianGroup.map_comp_apply", "start": [48, 1], "end": [55, 67], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.free_obj_coe", "code": "@[simp]\ntheorem free_obj_coe {\u03b1 : Type u} : (free.obj \u03b1 : Type u) = FreeAbelianGroup \u03b1", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.free_map_coe", "code": "theorem free_map_coe {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} (x : FreeAbelianGroup \u03b1) :\n    (free.map f) x = f <$> x", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.adj", "code": "def adj : free \u22a3 forget AddCommGroupCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X G => FreeAbelianGroup.lift.symm\n      homEquiv_naturality_left_symm := by\n        intros\n        ext\n        simp only [Equiv.symm_symm]\n        apply FreeAbelianGroup.lift_comp }", "start": [71, 1], "end": [81, 43], "kind": "commanddeclaration"}, {"full_name": "GroupCat.free", "code": "def free : Type u \u2964 GroupCat where\n  obj \u03b1 := of (FreeGroup \u03b1)\n  map := FreeGroup.map\n  map_id := by\n    intros; ext1; erw [\u2190FreeGroup.map.unique] <;> intros <;> rfl\n  map_comp := by\n    intros; ext1; erw [\u2190FreeGroup.map.unique] <;> intros <;> rfl", "start": [101, 1], "end": [111, 65], "kind": "commanddeclaration"}, {"full_name": "GroupCat.adj", "code": "def adj : free \u22a3 forget GroupCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X G => FreeGroup.lift.symm\n      homEquiv_naturality_left_symm := by\n        intros\n        ext1\n        simp only [Equiv.symm_symm]\n        apply Eq.symm\n        apply FreeGroup.lift.unique\n        intros\n        apply FreeGroup.lift.of }", "start": [114, 1], "end": [127, 34], "kind": "commanddeclaration"}, {"full_name": "abelianize", "code": "def abelianize : GroupCat.{u} \u2964 CommGroupCat.{u} where\n  obj G :=\n    { \u03b1 := Abelianization G\n      str := by infer_instance }\n  map f :=\n    Abelianization.lift\n      { toFun := fun x => Abelianization.of (f x)\n        map_one' := by simp\n        map_mul' := by simp }\n  map_id := by\n    intros; simp only [MonoidHom.mk_coe, coe_id]\n    apply (Equiv.apply_eq_iff_eq_symm_apply Abelianization.lift).mpr; rfl\n  map_comp := by\n    intros; simp only [coe_comp];\n    apply (Equiv.apply_eq_iff_eq_symm_apply Abelianization.lift).mpr; rfl", "start": [137, 1], "end": [153, 74], "kind": "commanddeclaration"}, {"full_name": "abelianizeAdj", "code": "def abelianizeAdj : abelianize \u22a3 forget\u2082 CommGroupCat.{u} GroupCat.{u} :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun G A => Abelianization.lift.symm\n      homEquiv_naturality_left_symm := by\n        intros\n        ext1\n        simp only [Equiv.symm_symm]\n        apply Eq.symm\n        apply Abelianization.lift.unique\n        intros\n        apply Abelianization.lift.of }", "start": [156, 1], "end": [168, 39], "kind": "commanddeclaration"}, {"full_name": "MonCat.units", "code": "@[simps]\ndef MonCat.units : MonCat.{u} \u2964 GroupCat.{u} where\n  obj R := GroupCat.of R\u02e3\n  map f := GroupCat.ofHom <| Units.map f\n  map_id _ := MonoidHom.ext fun _ => Units.ext rfl\n  map_comp _ _ := MonoidHom.ext fun _ => Units.ext rfl", "start": [173, 1], "end": [179, 55], "kind": "commanddeclaration"}, {"full_name": "GroupCat.forget\u2082MonAdj", "code": "def GroupCat.forget\u2082MonAdj : forget\u2082 GroupCat MonCat \u22a3 MonCat.units.{u} where\n  homEquiv X Y :=\n    { toFun := fun f => MonoidHom.toHomUnits f\n      invFun := fun f => (Units.coeHom Y).comp f\n      left_inv := fun f => MonoidHom.ext fun _ => rfl\n      right_inv := fun f => MonoidHom.ext fun _ => Units.ext rfl }\n  unit :=\n    { app := fun X => { (@toUnits X _).toMonoidHom with }\n      naturality := fun X Y f => MonoidHom.ext fun x => Units.ext rfl }\n  counit :=\n    { app := fun X => Units.coeHom X\n      naturality := by intros; exact MonoidHom.ext fun x => rfl }\n  homEquiv_unit := MonoidHom.ext fun _ => Units.ext rfl\n  homEquiv_counit := MonoidHom.ext fun _ => rfl", "start": [182, 1], "end": [196, 48], "kind": "commanddeclaration"}, {"full_name": "CommMonCat.units", "code": "@[simps]\ndef CommMonCat.units : CommMonCat.{u} \u2964 CommGroupCat.{u} where\n  obj R := CommGroupCat.of R\u02e3\n  map f := CommGroupCat.ofHom <| Units.map f\n  map_id _ := MonoidHom.ext fun _ => Units.ext rfl\n  map_comp _ _ := MonoidHom.ext fun _ => Units.ext rfl", "start": [202, 1], "end": [208, 55], "kind": "commanddeclaration"}, {"full_name": "CommGroupCat.forget\u2082CommMonAdj", "code": "def CommGroupCat.forget\u2082CommMonAdj : forget\u2082 CommGroupCat CommMonCat \u22a3 CommMonCat.units.{u} where\n  homEquiv X Y :=\n    { toFun := fun f => MonoidHom.toHomUnits f\n      invFun := fun f => (Units.coeHom Y).comp f\n      left_inv := fun f => MonoidHom.ext fun _ => rfl\n      right_inv := fun f => MonoidHom.ext fun _ => Units.ext rfl }\n  unit :=\n    { app := fun X => { (@toUnits X _).toMonoidHom with }\n      naturality := fun X Y f => MonoidHom.ext fun x => Units.ext rfl }\n  counit :=\n    { app := fun X => Units.coeHom X\n      naturality := by intros; exact MonoidHom.ext fun x => rfl }\n  homEquiv_unit := MonoidHom.ext fun _ => Units.ext rfl\n  homEquiv_counit := MonoidHom.ext fun _ => rfl", "start": [211, 1], "end": [225, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/RamificationInertia.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.ramificationIdx", "code": "noncomputable def ramificationIdx : \u2115 := sSup {n | map f p \u2264 P ^ n}", "start": [62, 1], "end": [70, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_eq_find", "code": "theorem ramificationIdx_eq_find (h : \u2203 n, \u2200 k, map f p \u2264 P ^ k \u2192 k \u2264 n) :\n    ramificationIdx f p P = Nat.find h", "start": [75, 1], "end": [77, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_eq_zero", "code": "theorem ramificationIdx_eq_zero (h : \u2200 n : \u2115, \u2203 k, map f p \u2264 P ^ k \u2227 n < k) :\n    ramificationIdx f p P = 0", "start": [80, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_spec", "code": "theorem ramificationIdx_spec {n : \u2115} (hle : map f p \u2264 P ^ n) (hgt : \u00acmap f p \u2264 P ^ (n + 1)) :\n    ramificationIdx f p P = n", "start": [85, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_lt", "code": "theorem ramificationIdx_lt {n : \u2115} (hgt : \u00acmap f p \u2264 P ^ n) : ramificationIdx f p P < n", "start": [98, 1], "end": [106, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_bot", "code": "@[simp]\ntheorem ramificationIdx_bot : ramificationIdx f \u22a5 P = 0", "start": [109, 1], "end": [111, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_of_not_le", "code": "@[simp]\ntheorem ramificationIdx_of_not_le (h : \u00acmap f p \u2264 P) : ramificationIdx f p P = 0", "start": [114, 1], "end": [116, 52], "kind": "commanddeclaration"}, {"full_name": "Ideal.ramificationIdx_ne_zero", "code": "theorem ramificationIdx_ne_zero {e : \u2115} (he : e \u2260 0) (hle : map f p \u2264 P ^ e)\n    (hnle : \u00acmap f p \u2264 P ^ (e + 1)) : ramificationIdx f p P \u2260 0", "start": [119, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_pow_of_le_ramificationIdx", "code": "theorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\n    map f p \u2264 P ^ n", "start": [124, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_pow_ramificationIdx", "code": "theorem le_pow_ramificationIdx : map f p \u2264 P ^ ramificationIdx f p P", "start": [130, 1], "end": [131, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_pow_ramificationIdx", "code": "theorem le_comap_pow_ramificationIdx : p \u2264 comap f (P ^ ramificationIdx f p P)", "start": [134, 1], "end": [135, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_of_ramificationIdx_ne_zero", "code": "theorem le_comap_of_ramificationIdx_ne_zero (h : ramificationIdx f p P \u2260 0) : p \u2264 comap f P", "start": [138, 1], "end": [139, 89], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsDedekindDomain.ramificationIdx_eq_normalizedFactors_count", "code": "theorem ramificationIdx_eq_normalizedFactors_count (hp0 : map f p \u2260 \u22a5) (hP : P.IsPrime)\n    (hP0 : P \u2260 \u22a5) : ramificationIdx f p P = (normalizedFactors (map f p)).count P", "start": [146, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsDedekindDomain.ramificationIdx_eq_factors_count", "code": "theorem ramificationIdx_eq_factors_count (hp0 : map f p \u2260 \u22a5) (hP : P.IsPrime) (hP0 : P \u2260 \u22a5) :\n    ramificationIdx f p P = (factors (map f p)).count P", "start": [156, 1], "end": [159, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsDedekindDomain.ramificationIdx_ne_zero", "code": "theorem ramificationIdx_ne_zero (hp0 : map f p \u2260 \u22a5) (hP : P.IsPrime) (le : map f p \u2264 P) :\n    ramificationIdx f p P \u2260 0", "start": [162, 1], "end": [172, 59], "kind": "commanddeclaration"}, {"full_name": "Ideal.inertiaDeg", "code": "noncomputable def inertiaDeg [p.IsMaximal] : \u2115 :=\n  if hPp : comap f P = p then\n    @finrank (R \u29f8 p) (S \u29f8 P) _ _ <|\n      @Algebra.toModule _ _ _ _ <|\n        RingHom.toAlgebra <|\n          Ideal.Quotient.lift p ((Ideal.Quotient.mk P).comp f) fun _ ha =>\n            Quotient.eq_zero_iff_mem.mpr <| mem_comap.mp <| hPp.symm \u25b8 ha\n  else 0", "start": [181, 1], "end": [196, 9], "kind": "commanddeclaration"}, {"full_name": "Ideal.inertiaDeg_of_subsingleton", "code": "@[simp]\ntheorem inertiaDeg_of_subsingleton [hp : p.IsMaximal] [hQ : Subsingleton (S \u29f8 P)] :\n    inertiaDeg f p P = 0", "start": [200, 1], "end": [205, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.inertiaDeg_algebraMap", "code": "@[simp]\ntheorem inertiaDeg_algebraMap [Algebra R S] [Algebra (R \u29f8 p) (S \u29f8 P)]\n    [IsScalarTower R (R \u29f8 p) (S \u29f8 P)] [hp : p.IsMaximal] :\n    inertiaDeg (algebraMap R S) p P = finrank (R \u29f8 p) (S \u29f8 P)", "start": [208, 1], "end": [219, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.FinrankQuotientMap.linearIndependent_of_nontrivial", "code": "theorem FinrankQuotientMap.linearIndependent_of_nontrivial [IsDomain R] [IsDedekindDomain R]\n    (hRS : RingHom.ker (algebraMap R S) \u2260 \u22a4) (f : V'' \u2192\u2097[R] V) (hf : Function.Injective f)\n    (f' : V'' \u2192\u2097[R] V') {\u03b9 : Type*} {b : \u03b9 \u2192 V''} (hb' : LinearIndependent S (f' \u2218 b)) :\n    LinearIndependent K (f \u2218 b)", "start": [246, 1], "end": [284, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.FinrankQuotientMap.span_eq_top", "code": "theorem FinrankQuotientMap.span_eq_top [IsDomain R] [IsDomain S] [Algebra K L] [IsNoetherian R S]\n    [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [IsIntegralClosure S R L]\n    [NoZeroSMulDivisors R K] (hp : p \u2260 \u22a4) (b : Set S)\n    (hb' : Submodule.span R b \u2294 (p.map (algebraMap R S)).restrictScalars R = \u22a4) :\n    Submodule.span K (algebraMap S L '' b) = \u22a4", "start": [291, 1], "end": [394, 78], "kind": "commanddeclaration"}, {"full_name": "Ideal.finrank_quotient_map", "code": "theorem finrank_quotient_map [IsDomain R] [IsDomain S] [IsDedekindDomain R] [Algebra K L]\n    [Algebra R L] [IsScalarTower R K L] [IsScalarTower R S L] [IsIntegralClosure S R L]\n    [hp : p.IsMaximal] [IsNoetherian R S] :\n    finrank (R \u29f8 p) (S \u29f8 map (algebraMap R S) p) = finrank K L", "start": [399, 1], "end": [445, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebraQuotientPowRamificationIdx", "code": "noncomputable instance Quotient.algebraQuotientPowRamificationIdx : Algebra (R \u29f8 p) (S \u29f8 P ^ e) :=\n  Quotient.algebraQuotientOfLEComap (Ideal.map_le_iff_le_comap.mp le_pow_ramificationIdx)", "start": [454, 1], "end": [457, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebraMap_quotient_pow_ramificationIdx", "code": "@[simp]\ntheorem Quotient.algebraMap_quotient_pow_ramificationIdx (x : R) :\n    algebraMap (R \u29f8 p) (S \u29f8 P ^ e) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk _ (f x)", "start": [460, 1], "end": [462, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebraQuotientOfRamificationIdxNeZero", "code": "def Quotient.algebraQuotientOfRamificationIdxNeZero : Algebra (R \u29f8 p) (S \u29f8 P) :=\n  Quotient.algebraQuotientOfLEComap (le_comap_of_ramificationIdx_ne_zero hfp.out)", "start": [467, 1], "end": [472, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebraMap_quotient_of_ramificationIdx_neZero", "code": "@[simp]\ntheorem Quotient.algebraMap_quotient_of_ramificationIdx_neZero (x : R) :\n    algebraMap (R \u29f8 p) (S \u29f8 P) (Ideal.Quotient.mk p x) = Ideal.Quotient.mk _ (f x)", "start": [479, 1], "end": [481, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.powQuotSuccInclusion", "code": "@[simps]\ndef powQuotSuccInclusion (i : \u2115) :\n    Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ (i + 1)) \u2192\u2097[R \u29f8 p]\n    Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i) where\n  toFun x := \u27e8x, Ideal.map_mono (Ideal.pow_le_pow i.le_succ) x.2\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [484, 1], "end": [491, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.powQuotSuccInclusion_injective", "code": "theorem powQuotSuccInclusion_injective (i : \u2115) :\n    Function.Injective (powQuotSuccInclusion f p P i)", "start": [494, 1], "end": [499, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSuccAux", "code": "noncomputable def quotientToQuotientRangePowQuotSuccAux {i : \u2115} {a : S} (a_mem : a \u2208 P ^ i) :\n    S \u29f8 P \u2192\n      (P ^ i).map (Ideal.Quotient.mk (P ^ e)) \u29f8 LinearMap.range (powQuotSuccInclusion f p P i) :=\n  Quotient.map' (fun x : S => \u27e8_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_left _ x a_mem)\u27e9)\n    fun x y h => by\n    rw [Submodule.quotientRel_r_def] at h \u22a2\n    simp only [_root_.map_mul, LinearMap.mem_range]\n    refine' \u27e8\u27e8_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_mul h a_mem)\u27e9, _\u27e9\n    ext\n    rw [powQuotSuccInclusion_apply_coe, Subtype.coe_mk, Submodule.coe_sub, Subtype.coe_mk,\n      Subtype.coe_mk, _root_.map_mul, map_sub, sub_mul]", "start": [502, 1], "end": [516, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSuccAux_mk", "code": "theorem quotientToQuotientRangePowQuotSuccAux_mk {i : \u2115} {a : S} (a_mem : a \u2208 P ^ i) (x : S) :\n    quotientToQuotientRangePowQuotSuccAux f p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk \u27e8_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_left _ x a_mem)\u27e9", "start": [519, 1], "end": [522, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSucc", "code": "noncomputable def quotientToQuotientRangePowQuotSucc {i : \u2115} {a : S} (a_mem : a \u2208 P ^ i) :\n    S \u29f8 P \u2192\u2097[R \u29f8 p]\n      (P ^ i).map (Ideal.Quotient.mk (P ^ e)) \u29f8 LinearMap.range (powQuotSuccInclusion f p P i) where\n  toFun := quotientToQuotientRangePowQuotSuccAux f p P a_mem\n  map_add' := by\n    intro x y; refine' Quotient.inductionOn' x fun x => Quotient.inductionOn' y fun y => _\n    simp only [Submodule.Quotient.mk''_eq_mk, \u2190 Submodule.Quotient.mk_add,\n      quotientToQuotientRangePowQuotSuccAux_mk, add_mul]\n    exact congr_arg Submodule.Quotient.mk rfl\n  map_smul' := by\n    intro x y; refine' Quotient.inductionOn' x fun x => Quotient.inductionOn' y fun y => _\n    simp only [Submodule.Quotient.mk''_eq_mk, RingHom.id_apply,\n      quotientToQuotientRangePowQuotSuccAux_mk]\n    refine congr_arg Submodule.Quotient.mk ?_\n    ext\n    simp only [mul_assoc, _root_.map_mul, Quotient.mk_eq_mk, Submodule.coe_smul_of_tower,\n      Algebra.smul_def, Quotient.algebraMap_quotient_pow_ramificationIdx]", "start": [525, 1], "end": [542, 74], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSucc_mk", "code": "theorem quotientToQuotientRangePowQuotSucc_mk {i : \u2115} {a : S} (a_mem : a \u2208 P ^ i) (x : S) :\n    quotientToQuotientRangePowQuotSucc f p P a_mem (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk \u27e8_, Ideal.mem_map_of_mem _ (Ideal.mul_mem_left _ x a_mem)\u27e9", "start": [545, 1], "end": [548, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSucc_injective", "code": "theorem quotientToQuotientRangePowQuotSucc_injective [IsDomain S] [IsDedekindDomain S] [P.IsPrime]\n    {i : \u2115} (hi : i < e) {a : S} (a_mem : a \u2208 P ^ i) (a_not_mem : a \u2209 P ^ (i + 1)) :\n    Function.Injective (quotientToQuotientRangePowQuotSucc f p P a_mem)", "start": [551, 1], "end": [568, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientToQuotientRangePowQuotSucc_surjective", "code": "theorem quotientToQuotientRangePowQuotSucc_surjective [IsDomain S] [IsDedekindDomain S]\n    (hP0 : P \u2260 \u22a5) [hP : P.IsPrime] {i : \u2115} (hi : i < e) {a : S} (a_mem : a \u2208 P ^ i)\n    (a_not_mem : a \u2209 P ^ (i + 1)) :\n    Function.Surjective (quotientToQuotientRangePowQuotSucc f p P a_mem)", "start": [571, 1], "end": [598, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientRangePowQuotSuccInclusionEquiv", "code": "noncomputable def quotientRangePowQuotSuccInclusionEquiv [IsDomain S] [IsDedekindDomain S]\n    [P.IsPrime] (hP : P \u2260 \u22a5) {i : \u2115} (hi : i < e) :\n    ((P ^ i).map (Ideal.Quotient.mk (P ^ e)) \u29f8 LinearMap.range (powQuotSuccInclusion f p P i))\n      \u2243\u2097[R \u29f8 p] S \u29f8 P := by\n  choose a a_mem a_not_mem using\n    SetLike.exists_of_lt\n      (Ideal.strictAnti_pow P hP (Ideal.IsPrime.ne_top inferInstance) (le_refl i.succ))\n  refine' (LinearEquiv.ofBijective _ \u27e8_, _\u27e9).symm\n  \u00b7 exact quotientToQuotientRangePowQuotSucc f p P a_mem\n  \u00b7 exact quotientToQuotientRangePowQuotSucc_injective f p P hi a_mem a_not_mem\n  \u00b7 exact quotientToQuotientRangePowQuotSucc_surjective f p P hP hi a_mem a_not_mem", "start": [601, 1], "end": [613, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.rank_pow_quot_aux", "code": "theorem rank_pow_quot_aux [IsDomain S] [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime] (hP0 : P \u2260 \u22a5)\n    {i : \u2115} (hi : i < e) :\n    Module.rank (R \u29f8 p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i)) =\n      Module.rank (R \u29f8 p) (S \u29f8 P) +\n        Module.rank (R \u29f8 p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ (i + 1)))", "start": [616, 1], "end": [626, 87], "kind": "commanddeclaration"}, {"full_name": "Ideal.rank_pow_quot", "code": "theorem rank_pow_quot [IsDomain S] [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime] (hP0 : P \u2260 \u22a5)\n    (i : \u2115) (hi : i \u2264 e) :\n    Module.rank (R \u29f8 p) (Ideal.map (Ideal.Quotient.mk (P ^ e)) (P ^ i)) =\n      (e - i) \u2022 Module.rank (R \u29f8 p) (S \u29f8 P)", "start": [629, 1], "end": [644, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.rank_prime_pow_ramificationIdx", "code": "theorem rank_prime_pow_ramificationIdx [IsDomain S] [IsDedekindDomain S] [p.IsMaximal] [P.IsPrime]\n    (hP0 : P \u2260 \u22a5) (he : e \u2260 0) :\n    Module.rank (R \u29f8 p) (S \u29f8 P ^ e) =\n      e \u2022\n        @Module.rank (R \u29f8 p) (S \u29f8 P) _ _\n          (@Algebra.toModule _ _ _ _ <|\n            @Quotient.algebraQuotientOfRamificationIdxNeZero _ _ _ _ _ _ _ \u27e8he\u27e9)", "start": [647, 1], "end": [659, 45], "kind": "commanddeclaration"}, {"full_name": "Ideal.finrank_prime_pow_ramificationIdx", "code": "theorem finrank_prime_pow_ramificationIdx [IsDomain S] [IsDedekindDomain S] (hP0 : P \u2260 \u22a5)\n    [p.IsMaximal] [P.IsPrime] (he : e \u2260 0) :\n    finrank (R \u29f8 p) (S \u29f8 P ^ e) =\n      e *\n        @finrank (R \u29f8 p) (S \u29f8 P) _ _\n          (@Algebra.toModule _ _ _ _ <|\n            @Quotient.algebraQuotientOfRamificationIdxNeZero _ _ _ _ _ _ _ \u27e8he\u27e9)", "start": [662, 1], "end": [682, 14], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.ne_bot", "code": "theorem Factors.ne_bot (P : (factors (map (algebraMap R S) p)).toFinset) : (P : Ideal S) \u2260 \u22a5", "start": [696, 1], "end": [697, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.isPrime", "code": "instance Factors.isPrime (P : (factors (map (algebraMap R S) p)).toFinset) :\n    IsPrime (P : Ideal S) :=\n  Ideal.isPrime_of_prime (prime_of_factor _ (Multiset.mem_toFinset.mp P.2))", "start": [700, 1], "end": [702, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.ramificationIdx_ne_zero", "code": "theorem Factors.ramificationIdx_ne_zero (P : (factors (map (algebraMap R S) p)).toFinset) :\n    ramificationIdx (algebraMap R S) p P \u2260 0", "start": [705, 1], "end": [708, 96], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.fact_ramificationIdx_neZero", "code": "instance Factors.fact_ramificationIdx_neZero (P : (factors (map (algebraMap R S) p)).toFinset) :\n    NeZero (ramificationIdx (algebraMap R S) p P) :=\n  \u27e8Factors.ramificationIdx_ne_zero p P\u27e9", "start": [711, 1], "end": [713, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.isScalarTower", "code": "instance Factors.isScalarTower (P : (factors (map (algebraMap R S) p)).toFinset) :\n    IsScalarTower R (R \u29f8 p) (S \u29f8 (P : Ideal S)) :=\n  IsScalarTower.of_algebraMap_eq fun x => by simp", "start": [720, 1], "end": [722, 50], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.finrank_pow_ramificationIdx", "code": "theorem Factors.finrank_pow_ramificationIdx [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) :\n    finrank (R \u29f8 p) (S \u29f8 (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P) =\n      ramificationIdx (algebraMap R S) p P * inertiaDeg (algebraMap R S) p P", "start": [727, 1], "end": [732, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.finiteDimensional_quotient", "code": "instance Factors.finiteDimensional_quotient [IsNoetherian R S] [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) :\n    FiniteDimensional (R \u29f8 p) (S \u29f8 (P : Ideal S)) :=\n  IsNoetherian.iff_fg.mp <|\n    isNoetherian_of_tower R <|\n      isNoetherian_of_surjective S (Ideal.Quotient.mk\u2090 _ _).toLinearMap <|\n        LinearMap.range_eq_top.mpr Ideal.Quotient.mk_surjective", "start": [735, 1], "end": [741, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.inertiaDeg_ne_zero", "code": "theorem Factors.inertiaDeg_ne_zero [IsNoetherian R S] [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) : inertiaDeg (algebraMap R S) p P \u2260 0", "start": [744, 1], "end": [746, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.finiteDimensional_quotient_pow", "code": "instance Factors.finiteDimensional_quotient_pow [IsNoetherian R S] [p.IsMaximal]\n    (P : (factors (map (algebraMap R S) p)).toFinset) :\n    FiniteDimensional (R \u29f8 p) (S \u29f8 (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P) := by\n  refine FiniteDimensional.finiteDimensional_of_finrank ?_\n  rw [pos_iff_ne_zero, Factors.finrank_pow_ramificationIdx]\n  exact mul_ne_zero (Factors.ramificationIdx_ne_zero p P) (Factors.inertiaDeg_ne_zero p P)", "start": [749, 1], "end": [754, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.piQuotientEquiv", "code": "noncomputable def Factors.piQuotientEquiv (p : Ideal R) (hp : map (algebraMap R S) p \u2260 \u22a5) :\n    S \u29f8 map (algebraMap R S) p \u2243+*\n      \u2200 P : (factors (map (algebraMap R S) p)).toFinset,\n        S \u29f8 (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P :=\n  (IsDedekindDomain.quotientEquivPiFactors hp).trans <|\n    @RingEquiv.piCongrRight (factors (map (algebraMap R S) p)).toFinset\n      (fun P => S \u29f8 (P : Ideal S) ^ (factors (map (algebraMap R S) p)).count (P : Ideal S))\n      (fun P => S \u29f8 (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P) _ _\n      fun P : (factors (map (algebraMap R S) p)).toFinset =>\n      Ideal.quotEquivOfEq <| by\n        rw [IsDedekindDomain.ramificationIdx_eq_factors_count hp (Factors.isPrime p P)\n            (Factors.ne_bot p P)]", "start": [759, 1], "end": [772, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.piQuotientEquiv_mk", "code": "@[simp]\ntheorem Factors.piQuotientEquiv_mk (p : Ideal R) (hp : map (algebraMap R S) p \u2260 \u22a5) (x : S) :\n    Factors.piQuotientEquiv p hp (Ideal.Quotient.mk _ x) = fun _ => Ideal.Quotient.mk _ x", "start": [775, 1], "end": [777, 97], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.piQuotientEquiv_map", "code": "@[simp]\ntheorem Factors.piQuotientEquiv_map (p : Ideal R) (hp : map (algebraMap R S) p \u2260 \u22a5) (x : R) :\n    Factors.piQuotientEquiv p hp (algebraMap _ _ x) = fun _ =>\n      Ideal.Quotient.mk _ (algebraMap _ _ x)", "start": [780, 1], "end": [783, 52], "kind": "commanddeclaration"}, {"full_name": "Ideal.Factors.piQuotientLinearEquiv", "code": "noncomputable def Factors.piQuotientLinearEquiv (p : Ideal R) (hp : map (algebraMap R S) p \u2260 \u22a5) :\n    (S \u29f8 map (algebraMap R S) p) \u2243\u2097[R \u29f8 p]\n      \u2200 P : (factors (map (algebraMap R S) p)).toFinset,\n        S \u29f8 (P : Ideal S) ^ ramificationIdx (algebraMap R S) p P :=\n  { Factors.piQuotientEquiv p hp with\n    map_smul' := by\n      rintro \u27e8c\u27e9 \u27e8x\u27e9; ext P\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, Algebra.smul_def,\n        Quotient.algebraMap_quotient_map_quotient, Quotient.mk_algebraMap,\n        RingHomCompTriple.comp_apply, Pi.mul_apply, Pi.algebraMap_apply]\n      congr }", "start": [788, 1], "end": [801, 14], "kind": "commanddeclaration"}, {"full_name": "Ideal.sum_ramification_inertia", "code": "theorem sum_ramification_inertia (K L : Type*) [Field K] [Field L] [IsDomain R]\n    [IsDedekindDomain R] [Algebra R K] [IsFractionRing R K] [Algebra S L] [IsFractionRing S L]\n    [Algebra K L] [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [IsNoetherian R S]\n    [IsIntegralClosure S R L] [p.IsMaximal] (hp0 : p \u2260 \u22a5) :\n    (\u2211 P in (factors (map (algebraMap R S) p)).toFinset,\n        ramificationIdx (algebraMap R S) p P * inertiaDeg (algebraMap R S) p P) =\n      finrank K L", "start": [808, 1], "end": [844, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Grading.lean", "imports": ["Mathlib/Algebra/DirectSum/Internal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/MonoidAlgebra/Support.lean", "Mathlib/RingTheory/GradedAlgebra/Basic.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "AddMonoidAlgebra.gradeBy", "code": "abbrev gradeBy (f : M \u2192 \u03b9) (i : \u03b9) : Submodule R R[M] where\n  carrier := { a | \u2200 m, m \u2208 a.support \u2192 f m = i }\n  zero_mem' m h := by cases h\n  add_mem' {a b} ha hb m h := Or.recOn (Finset.mem_union.mp (Finsupp.support_add h)) (ha m) (hb m)\n  smul_mem' a m h := Set.Subset.trans Finsupp.support_smul h", "start": [46, 1], "end": [51, 61], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade", "code": "abbrev grade (m : M) : Submodule R R[M] :=\n  gradeBy R id m", "start": [54, 1], "end": [56, 17], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.gradeBy_id", "code": "theorem gradeBy_id : gradeBy R (id : M \u2192 M) = grade R", "start": [59, 1], "end": [59, 61], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_gradeBy_iff", "code": "theorem mem_gradeBy_iff (f : M \u2192 \u03b9) (i : \u03b9) (a : R[M]) :\n    a \u2208 gradeBy R f i \u2194 (a.support : Set M) \u2286 f \u207b\u00b9' {i}", "start": [62, 1], "end": [63, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_grade_iff", "code": "theorem mem_grade_iff (m : M) (a : R[M]) : a \u2208 grade R m \u2194 a.support \u2286 {m}", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_grade_iff'", "code": "theorem mem_grade_iff' (m : M) (a : R[M]) :\n    a \u2208 grade R m \u2194 a \u2208 (LinearMap.range (Finsupp.lsingle m : R \u2192\u2097[R] M \u2192\u2080 R) :\n      Submodule R R[M])", "start": [71, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade_eq_lsingle_range", "code": "theorem grade_eq_lsingle_range (m : M) :\n    grade R m = LinearMap.range (Finsupp.lsingle m : R \u2192\u2097[R] M \u2192\u2080 R)", "start": [80, 1], "end": [82, 37], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mem_gradeBy", "code": "theorem single_mem_gradeBy {R} [CommSemiring R] (f : M \u2192 \u03b9) (m : M) (r : R) :\n    Finsupp.single m r \u2208 gradeBy R f (f m)", "start": [85, 1], "end": [88, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mem_grade", "code": "theorem single_mem_grade {R} [CommSemiring R] (i : M) (r : R) : Finsupp.single i r \u2208 grade R i", "start": [91, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.gradeBy.gradedMonoid", "code": "instance gradeBy.gradedMonoid [AddMonoid M] [AddMonoid \u03b9] [CommSemiring R] (f : M \u2192+ \u03b9) :\n    SetLike.GradedMonoid (gradeBy R f : \u03b9 \u2192 Submodule R R[M]) where\n  one_mem m h := by\n    rw [one_def] at h\n    by_cases H : (1 : R) = (0 : R)\n    \u00b7 rw [H, single, Finsupp.single_zero] at h\n      cases h\n    \u00b7 rw [Finsupp.support_single_ne_zero _ H, Finset.mem_singleton] at h\n      rw [h, AddMonoidHom.map_zero]\n  mul_mem i j a b ha hb c hc := by\n    set h := support_mul a b hc\n    simp only [Finset.mem_biUnion] at h\n    rcases h with \u27e8ma, \u27e8hma, \u27e8mb, \u27e8hmb, hmc\u27e9\u27e9\u27e9\u27e9\n    rw [\u2190 ha ma hma, \u2190 hb mb hmb, Finset.mem_singleton.mp hmc]\n    apply AddMonoidHom.map_add", "start": [99, 1], "end": [113, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade.gradedMonoid", "code": "instance grade.gradedMonoid [AddMonoid M] [CommSemiring R] :\n    SetLike.GradedMonoid (grade R : M \u2192 Submodule R R[M]) := by\n  apply gradeBy.gradedMonoid (AddMonoidHom.id _)", "start": [116, 1], "end": [118, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.decomposeAux", "code": "def decomposeAux : R[M] \u2192\u2090[R] \u2a01 i : \u03b9, gradeBy R f i :=\n  AddMonoidAlgebra.lift R M _\n    { toFun := fun m =>\n        DirectSum.of (fun i : \u03b9 => gradeBy R f i) (f (Multiplicative.toAdd m))\n          \u27e8Finsupp.single (Multiplicative.toAdd m) 1, single_mem_gradeBy _ _ _\u27e9\n      map_one' :=\n        DirectSum.of_eq_of_gradedMonoid_eq\n          (by congr 2 <;> simp)\n      map_mul' := fun i j => by\n        symm\n        dsimp only [toAdd_one, Eq.ndrec, Set.mem_setOf_eq, ne_eq, OneHom.toFun_eq_coe,\n          OneHom.coe_mk, toAdd_mul]\n        convert DirectSum.of_mul_of (A := (fun i : \u03b9 => gradeBy R f i)) _ _\n        repeat { rw [ AddMonoidHom.map_add] }\n        simp only [SetLike.coe_gMul]\n        refine Eq.trans (by rw [one_mul]) single_mul_single.symm }", "start": [123, 1], "end": [140, 67], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.decomposeAux_single", "code": "theorem decomposeAux_single (m : M) (r : R) :\n    decomposeAux f (Finsupp.single m r) =\n      DirectSum.of (fun i : \u03b9 => gradeBy R f i) (f m)\n        \u27e8Finsupp.single m r, single_mem_gradeBy _ _ _\u27e9", "start": [143, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.decomposeAux_coe", "code": "theorem decomposeAux_coe {i : \u03b9} (x : gradeBy R f i) :\n    decomposeAux f \u2191x = DirectSum.of (fun i => gradeBy R f i) i x", "start": [156, 1], "end": [179, 12], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.gradeBy.gradedAlgebra", "code": "instance gradeBy.gradedAlgebra : GradedAlgebra (gradeBy R f) :=\n  GradedAlgebra.ofAlgHom _ (decomposeAux f)\n    (by\n      ext : 2\n      simp only [MonoidHom.coe_comp, MonoidHom.coe_coe, AlgHom.coe_comp, Function.comp_apply,\n        of_apply, AlgHom.coe_id, id_eq]\n      rw [decomposeAux_single, DirectSum.coeAlgHom_of, Subtype.coe_mk])\n    fun i x => by rw [decomposeAux_coe f x]", "start": [182, 1], "end": [189, 44], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.gradeBy.decomposition", "code": "instance gradeBy.decomposition : DirectSum.Decomposition (gradeBy R f) := by infer_instance", "start": [193, 1], "end": [193, 92], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.decomposeAux_eq_decompose", "code": "@[simp]\ntheorem decomposeAux_eq_decompose :\n    \u21d1(decomposeAux f : R[M] \u2192\u2090[R] \u2a01 i : \u03b9, gradeBy R f i) =\n      DirectSum.decompose (gradeBy R f)", "start": [196, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.GradesBy.decompose_single", "code": "@[simp]\ntheorem GradesBy.decompose_single (m : M) (r : R) :\n    DirectSum.decompose (gradeBy R f) (Finsupp.single m r : R[M]) =\n      DirectSum.of (fun i : \u03b9 => gradeBy R f i) (f m)\n        \u27e8Finsupp.single m r, single_mem_gradeBy _ _ _\u27e9", "start": [203, 1], "end": [208, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade.gradedAlgebra", "code": "instance grade.gradedAlgebra : GradedAlgebra (grade R : \u03b9 \u2192 Submodule _ _) :=\n  AddMonoidAlgebra.gradeBy.gradedAlgebra (AddMonoidHom.id _)", "start": [211, 1], "end": [212, 61], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade.decomposition", "code": "instance grade.decomposition : DirectSum.Decomposition (grade R : \u03b9 \u2192 Submodule _ _) := by\n  infer_instance", "start": [216, 1], "end": [217, 17], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade.decompose_single", "code": "@[simp]\ntheorem grade.decompose_single (i : \u03b9) (r : R) :\n    DirectSum.decompose (grade R : \u03b9 \u2192 Submodule _ _) (Finsupp.single i r : AddMonoidAlgebra _ _) =\n      DirectSum.of (fun i : \u03b9 => grade R i) i \u27e8Finsupp.single i r, single_mem_grade _ _\u27e9", "start": [220, 1], "end": [224, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.gradeBy.isInternal", "code": "theorem gradeBy.isInternal : DirectSum.IsInternal (gradeBy R f)", "start": [227, 1], "end": [229, 39], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.grade.isInternal", "code": "theorem grade.isInternal : DirectSum.IsInternal (grade R : \u03b9 \u2192 Submodule R _)", "start": [232, 1], "end": [234, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Sphere/Ptolemy.lean", "imports": ["Mathlib/Geometry/Euclidean/Triangle.lean", "Mathlib/Geometry/Euclidean/Sphere/Power.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.mul_dist_add_mul_dist_eq_mul_dist_of_cospherical", "code": "theorem mul_dist_add_mul_dist_eq_mul_dist_of_cospherical {a b c d p : P}\n    (h : Cospherical ({a, b, c, d} : Set P)) (hapc : \u2220 a p c = \u03c0) (hbpd : \u2220 b p d = \u03c0) :\n    dist a b * dist c d + dist b c * dist d a = dist a c * dist b d", "start": [53, 1], "end": [71, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "imports": ["Mathlib/Data/MvPolynomial/Cardinal.lean", "Mathlib/Data/Polynomial/Cardinal.lean", "Mathlib/Data/ZMod/Algebra.lean", "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/AlgebraicIndependent.lean"], "premises": [{"full_name": "Algebra.IsAlgebraic.cardinal_mk_le_sigma_polynomial", "code": "theorem cardinal_mk_le_sigma_polynomial :\n    #L \u2264 #(\u03a3 p : R[X], { x : L // x \u2208 p.aroots L })", "start": [42, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.IsAlgebraic.cardinal_mk_le_max", "code": "theorem cardinal_mk_le_max : #L \u2264 max #R \u2135\u2080", "start": [63, 1], "end": [77, 87], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.isAlgClosure_of_transcendence_basis", "code": "theorem isAlgClosure_of_transcendence_basis [IsAlgClosed K] (hv : IsTranscendenceBasis R v) :\n    IsAlgClosure (Algebra.adjoin R (Set.range v)) K", "start": [102, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.equivOfTranscendenceBasis", "code": "def equivOfTranscendenceBasis [IsAlgClosed K] [IsAlgClosed L] (e : \u03b9 \u2243 \u03ba)\n    (hv : IsTranscendenceBasis R v) (hw : IsTranscendenceBasis R w) : K \u2243+* L := by\n  letI := isAlgClosure_of_transcendence_basis v hv\n  letI := isAlgClosure_of_transcendence_basis w hw\n  have e : Algebra.adjoin R (Set.range v) \u2243+* Algebra.adjoin R (Set.range w)\n  \u00b7 refine' hv.1.aevalEquiv.symm.toRingEquiv.trans _\n    refine' (AlgEquiv.ofAlgHom (MvPolynomial.rename e)\n      (MvPolynomial.rename e.symm) _ _).toRingEquiv.trans _\n    \u00b7 ext; simp\n    \u00b7 ext; simp\n    exact hw.1.aevalEquiv.toRingEquiv\n  exact IsAlgClosure.equivOfEquiv K L e", "start": [111, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.cardinal_le_max_transcendence_basis", "code": "theorem cardinal_le_max_transcendence_basis (hv : IsTranscendenceBasis R v) :\n    #K \u2264 max (max #R #\u03b9) \u2135\u2080", "start": [142, 1], "end": [150, 33], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt", "code": "theorem cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt [Nontrivial R]\n    (hv : IsTranscendenceBasis R v) (hR : #R \u2264 \u2135\u2080) (hK : \u2135\u2080 < #K) : #K = #\u03b9", "start": [153, 1], "end": [168, 73], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.ringEquivOfCardinalEqOfCharZero", "code": "theorem ringEquivOfCardinalEqOfCharZero [CharZero K] [CharZero L] (hK : \u2135\u2080 < #K)\n    (hKL : #K = #L) : Nonempty (K \u2243+* L)", "start": [175, 1], "end": [188, 48], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.ringEquivOfCardinalEqOfCharP", "code": "private theorem ringEquivOfCardinalEqOfCharP (p : \u2115) [Fact p.Prime] [CharP K p] [CharP L p]\n    (hK : \u2135\u2080 < #K) (hKL : #K = #L) : Nonempty (K \u2243+* L)", "start": [191, 1], "end": [206, 48], "kind": "commanddeclaration"}, {"full_name": "IsAlgClosed.ringEquivOfCardinalEqOfCharEq", "code": "theorem ringEquivOfCardinalEqOfCharEq (p : \u2115) [CharP K p] [CharP L p] (hK : \u2135\u2080 < #K)\n    (hKL : #K = #L) : Nonempty (K \u2243+* L)", "start": [208, 1], "end": [218, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/RegularExpressions.lean", "imports": ["Mathlib/Computability/Language.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RegularExpression", "code": "inductive RegularExpression (\u03b1 : Type u) : Type u\n  | zero : RegularExpression \u03b1\n  | epsilon : RegularExpression \u03b1\n  | char : \u03b1 \u2192 RegularExpression \u03b1\n  | plus : RegularExpression \u03b1 \u2192 RegularExpression \u03b1 \u2192 RegularExpression \u03b1\n  | comp : RegularExpression \u03b1 \u2192 RegularExpression \u03b1 \u2192 RegularExpression \u03b1\n  | star : RegularExpression \u03b1 \u2192 RegularExpression \u03b1", "start": [34, 1], "end": [49, 53], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.zero_def", "code": "@[simp]\ntheorem zero_def : (zero : RegularExpression \u03b1) = 0", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.one_def", "code": "@[simp]\ntheorem one_def : (epsilon : RegularExpression \u03b1) = 1", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.plus_def", "code": "@[simp]\ntheorem plus_def (P Q : RegularExpression \u03b1) : plus P Q = P + Q", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.comp_def", "code": "@[simp]\ntheorem comp_def (P Q : RegularExpression \u03b1) : comp P Q = P * Q", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'", "code": "def matches' : RegularExpression \u03b1 \u2192 Language \u03b1\n  | 0 => 0\n  | 1 => 1\n  | char a => {[a]}\n  | P + Q => P.matches' + Q.matches'\n  | P * Q => P.matches' * Q.matches'\n  | star P => P.matches'\u2217", "start": [107, 1], "end": [116, 26], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_zero", "code": "@[simp]\ntheorem matches'_zero : (0 : RegularExpression \u03b1).matches' = 0", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_epsilon", "code": "@[simp]\ntheorem matches'_epsilon : (1 : RegularExpression \u03b1).matches' = 1", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_char", "code": "@[simp]\ntheorem matches'_char (a : \u03b1) : (char a).matches' = {[a]}", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_add", "code": "@[simp]\ntheorem matches'_add (P Q : RegularExpression \u03b1) : (P + Q).matches' = P.matches' + Q.matches'", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_mul", "code": "@[simp]\ntheorem matches'_mul (P Q : RegularExpression \u03b1) : (P * Q).matches' = P.matches' * Q.matches'", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_pow", "code": "@[simp]\ntheorem matches'_pow (P : RegularExpression \u03b1) : \u2200 n : \u2115, (P ^ n).matches' = P.matches' ^ n", "start": [144, 1], "end": [148, 68], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_star", "code": "@[simp]\ntheorem matches'_star (P : RegularExpression \u03b1) : P.star.matches' = P.matches'\u2217", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matchEpsilon", "code": "def matchEpsilon : RegularExpression \u03b1 \u2192 Bool\n  | 0 => false\n  | 1 => true\n  | char _ => false\n  | P + Q => P.matchEpsilon || Q.matchEpsilon\n  | P * Q => P.matchEpsilon && Q.matchEpsilon\n  | star _P => true", "start": [156, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv", "code": "def deriv : RegularExpression \u03b1 \u2192 \u03b1 \u2192 RegularExpression \u03b1\n  | 0, _ => 0\n  | 1, _ => 0\n  | char a\u2081, a\u2082 => if a\u2081 = a\u2082 then 1 else 0\n  | P + Q, a => deriv P a + deriv Q a\n  | P * Q, a => if P.matchEpsilon then deriv P a * Q + deriv Q a else deriv P a * Q\n  | star P, a => deriv P a * star P", "start": [167, 1], "end": [175, 36], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_zero", "code": "@[simp]\ntheorem deriv_zero (a : \u03b1) : deriv 0 a = 0", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_one", "code": "@[simp]\ntheorem deriv_one (a : \u03b1) : deriv 1 a = 0", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_char_self", "code": "@[simp]\ntheorem deriv_char_self (a : \u03b1) : deriv (char a) a = 1", "start": [188, 1], "end": [190, 13], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_char_of_ne", "code": "@[simp]\ntheorem deriv_char_of_ne (h : a \u2260 b) : deriv (char a) b = 0", "start": [193, 1], "end": [195, 11], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_add", "code": "@[simp]\ntheorem deriv_add (P Q : RegularExpression \u03b1) (a : \u03b1) : deriv (P + Q) a = deriv P a + deriv Q a", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.deriv_star", "code": "@[simp]\ntheorem deriv_star (P : RegularExpression \u03b1) (a : \u03b1) : deriv P.star a = deriv P a * star P", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.rmatch", "code": "def rmatch : RegularExpression \u03b1 \u2192 List \u03b1 \u2192 Bool\n  | P, [] => matchEpsilon P\n  | P, a :: as => rmatch (P.deriv a) as", "start": [208, 1], "end": [212, 40], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.zero_rmatch", "code": "@[simp]\ntheorem zero_rmatch (x : List \u03b1) : rmatch 0 x = false", "start": [215, 1], "end": [217, 49], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.one_rmatch_iff", "code": "theorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = []", "start": [220, 1], "end": [221, 49], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.char_rmatch_iff", "code": "theorem char_rmatch_iff (a : \u03b1) (x : List \u03b1) : rmatch (char a) x \u2194 x = [a]", "start": [224, 1], "end": [235, 65], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.add_rmatch_iff", "code": "theorem add_rmatch_iff (P Q : RegularExpression \u03b1) (x : List \u03b1) :\n    (P + Q).rmatch x \u2194 P.rmatch x \u2228 Q.rmatch x", "start": [238, 1], "end": [244, 17], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.mul_rmatch_iff", "code": "theorem mul_rmatch_iff (P Q : RegularExpression \u03b1) (x : List \u03b1) :\n    (P * Q).rmatch x \u2194 \u2203 t u : List \u03b1, x = t ++ u \u2227 P.rmatch t \u2227 Q.rmatch u", "start": [247, 1], "end": [290, 20], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.star_rmatch_iff", "code": "theorem star_rmatch_iff (P : RegularExpression \u03b1) :\n    \u2200 x : List \u03b1, (star P).rmatch x \u2194 \u2203 S : List (List \u03b1), x\n          = S.join \u2227 \u2200 t \u2208 S, t \u2260 [] \u2227 P.rmatch t", "start": [293, 1], "end": [346, 53], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.rmatch_iff_matches'", "code": "@[simp]\ntheorem rmatch_iff_matches' (P : RegularExpression \u03b1) :\n    \u2200 x : List \u03b1, P.rmatch x \u2194 x \u2208 P.matches'", "start": [349, 1], "end": [395, 12], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.map", "code": "@[simp]\ndef map (f : \u03b1 \u2192 \u03b2) : RegularExpression \u03b1 \u2192 RegularExpression \u03b2\n  | 0 => 0\n  | 1 => 1\n  | char a => char (f a)\n  | R + S => map f R + map f S\n  | R * S => map f R * map f S\n  | star R => star (map f R)", "start": [401, 1], "end": [409, 29], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.map_pow", "code": "@[simp]\nprotected theorem map_pow (f : \u03b1 \u2192 \u03b2) (P : RegularExpression \u03b1) :\n    \u2200 n : \u2115, map f (P ^ n) = map f P ^ n", "start": [412, 1], "end": [416, 83], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.map_id", "code": "@[simp]\ntheorem map_id : \u2200 P : RegularExpression \u03b1, P.map id = P", "start": [419, 1], "end": [426, 39], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) : \u2200 P : RegularExpression \u03b1, (P.map f).map g = P.map (g \u2218 f)", "start": [429, 1], "end": [436, 63], "kind": "commanddeclaration"}, {"full_name": "RegularExpression.matches'_map", "code": "@[simp]\ntheorem matches'_map (f : \u03b1 \u2192 \u03b2) :\n    \u2200 P : RegularExpression \u03b1, (P.map f).matches' = Language.map f P.matches'", "start": [439, 1], "end": [455, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Distributions/Gaussian.lean", "imports": ["Mathlib/Probability/Notation.lean", "Mathlib/Analysis/SpecialFunctions/Gaussian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.gaussianPdfReal", "code": "noncomputable\ndef gaussianPdfReal (\u03bc : \u211d) (v : \u211d\u22650) (x : \u211d) : \u211d :=\n  (Real.sqrt (2 * \u03c0 * v))\u207b\u00b9 * rexp (- (x - \u03bc)^2 / (2 * v))", "start": [36, 1], "end": [39, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.gaussianPdfReal_def", "code": "lemma gaussianPdfReal_def (\u03bc : \u211d) (v : \u211d\u22650) :\n    gaussianPdfReal \u03bc v =\n      fun x \u21a6 (Real.sqrt (2 * \u03c0 * v))\u207b\u00b9 * rexp (- (x - \u03bc)^2 / (2 * v)) := rfl", "start": [41, 1], "end": [43, 78], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdfReal_zero_var", "code": "@[simp]\nlemma gaussianPdfReal_zero_var (m : \u211d) : gaussianPdfReal m 0 = 0 := by\n  ext1 x\n  simp [gaussianPdfReal]", "start": [45, 1], "end": [48, 25], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdfReal_pos", "code": "lemma gaussianPdfReal_pos (\u03bc : \u211d) (v : \u211d\u22650) (x : \u211d) (hv : v \u2260 0) : 0 < gaussianPdfReal \u03bc v x := by\n  rw [gaussianPdfReal]\n  positivity", "start": [50, 1], "end": [53, 13], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdfReal_nonneg", "code": "lemma gaussianPdfReal_nonneg (\u03bc : \u211d) (v : \u211d\u22650) (x : \u211d) : 0 \u2264 gaussianPdfReal \u03bc v x := by\n  rw [gaussianPdfReal]\n  positivity", "start": [55, 1], "end": [58, 13], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.measurable_gaussianPdfReal", "code": "lemma measurable_gaussianPdfReal (\u03bc : \u211d) (v : \u211d\u22650) : Measurable (gaussianPdfReal \u03bc v) :=\n  (((measurable_id.add_const _).pow_const _).neg.div_const _).exp.const_mul _", "start": [60, 1], "end": [62, 78], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.stronglyMeasurable_gaussianPdfReal", "code": "lemma stronglyMeasurable_gaussianPdfReal (\u03bc : \u211d) (v : \u211d\u22650) :\n    StronglyMeasurable (gaussianPdfReal \u03bc v) :=\n  (measurable_gaussianPdfReal \u03bc v).stronglyMeasurable", "start": [64, 1], "end": [67, 54], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.integrable_gaussianPdfReal", "code": "lemma integrable_gaussianPdfReal (\u03bc : \u211d) (v : \u211d\u22650) :\n    Integrable (gaussianPdfReal \u03bc v) := by\n  rw [gaussianPdfReal_def]\n  by_cases hv : v = 0\n  \u00b7 simp [hv]\n  let g : \u211d \u2192 \u211d := fun x \u21a6 (Real.sqrt (2 * \u03c0 * v))\u207b\u00b9 * rexp (- x ^ 2 / (2 * v))\n  have hg : Integrable g := by\n    suffices g = fun x \u21a6 (Real.sqrt (2 * \u03c0 * v))\u207b\u00b9 * rexp (- (2 * v)\u207b\u00b9 * x ^ 2) by\n      rw [this]\n      refine (integrable_exp_neg_mul_sq ?_).const_mul (Real.sqrt (2 * \u03c0 * v))\u207b\u00b9\n      simp [lt_of_le_of_ne (zero_le _) (Ne.symm hv)]\n    ext x\n    simp only [gt_iff_lt, zero_lt_two, zero_le_mul_left, NNReal.zero_le_coe, Real.sqrt_mul',\n      mul_inv_rev, NNReal.coe_mul, NNReal.coe_inv, NNReal.coe_ofNat, neg_mul, mul_eq_mul_left_iff,\n      Real.exp_eq_exp, mul_eq_zero, inv_eq_zero, Real.sqrt_eq_zero, NNReal.coe_eq_zero, hv,\n      false_or]\n    rw [mul_comm]\n    left\n    field_simp\n  exact Integrable.comp_sub_right hg \u03bc", "start": [69, 1], "end": [88, 39], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.lintegral_gaussianPdfReal_eq_one", "code": "lemma lintegral_gaussianPdfReal_eq_one (\u03bc : \u211d) {v : \u211d\u22650} (h : v \u2260 0) :\n    \u222b\u207b x, ENNReal.ofReal (gaussianPdfReal \u03bc v x) = 1 := by\n  rw [\u2190ENNReal.toReal_eq_one_iff]\n  have hfm : AEStronglyMeasurable (gaussianPdfReal \u03bc v) volume :=\n    (stronglyMeasurable_gaussianPdfReal \u03bc v).aestronglyMeasurable\n  have hf : 0 \u2264\u2090\u209b gaussianPdfReal \u03bc v := ae_of_all _ (gaussianPdfReal_nonneg \u03bc v)\n  rw [\u2190 integral_eq_lintegral_of_nonneg_ae hf hfm]\n  simp only [gaussianPdfReal, gt_iff_lt, zero_lt_two, zero_le_mul_right, ge_iff_le, one_div,\n    Nat.cast_ofNat, integral_mul_left]\n  rw [integral_sub_right_eq_self (\u03bc := volume) (fun a \u21a6 rexp (-a ^ 2 / ((2 : \u211d) * v))) \u03bc]\n  simp only [gt_iff_lt, zero_lt_two, zero_le_mul_right, ge_iff_le, div_eq_inv_mul, mul_inv_rev,\n    mul_neg]\n  simp_rw [\u2190neg_mul]\n  rw [neg_mul, integral_gaussian, \u2190 Real.sqrt_inv, \u2190Real.sqrt_mul]\n  \u00b7 field_simp\n    ring\n  \u00b7 positivity", "start": [90, 1], "end": [107, 15], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.integral_gaussianPdfReal_eq_one", "code": "lemma integral_gaussianPdfReal_eq_one (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) :\n    \u222b x, gaussianPdfReal \u03bc v x = 1 := by\n  have h := lintegral_gaussianPdfReal_eq_one \u03bc hv\n  rw [\u2190 ofReal_integral_eq_lintegral_ofReal (integrable_gaussianPdfReal _ _)\n    (ae_of_all _ (gaussianPdfReal_nonneg _ _)), \u2190 ENNReal.ofReal_one] at h\n  rwa [\u2190 ENNReal.ofReal_eq_ofReal_iff (integral_nonneg (gaussianPdfReal_nonneg _ _)) zero_le_one]", "start": [109, 1], "end": [115, 98], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdf", "code": "noncomputable\ndef gaussianPdf (\u03bc : \u211d) (v : \u211d\u22650) (x : \u211d) : \u211d\u22650\u221e := ENNReal.ofReal (gaussianPdfReal \u03bc v x)", "start": [117, 1], "end": [119, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.gaussianPdf_def", "code": "lemma gaussianPdf_def (\u03bc : \u211d) (v : \u211d\u22650) :\n    gaussianPdf \u03bc v = fun x \u21a6 ENNReal.ofReal (gaussianPdfReal \u03bc v x) := rfl", "start": [121, 1], "end": [122, 76], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdf_zero_var", "code": "@[simp]\nlemma gaussianPdf_zero_var (\u03bc : \u211d) : gaussianPdf \u03bc 0 = 0 := by\n  ext\n  simp [gaussianPdf]", "start": [124, 1], "end": [127, 21], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianPdf_pos", "code": "lemma gaussianPdf_pos (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) (x : \u211d) : 0 < gaussianPdf \u03bc v x := by\n  rw [gaussianPdf, ENNReal.ofReal_pos]\n  exact gaussianPdfReal_pos _ _ _ hv", "start": [129, 1], "end": [131, 37], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.measurable_gaussianPdf", "code": "@[measurability]\nlemma measurable_gaussianPdf (\u03bc : \u211d) (v : \u211d\u22650) : Measurable (gaussianPdf \u03bc v) :=\n  (measurable_gaussianPdfReal _ _).ennreal_ofReal", "start": [133, 1], "end": [135, 50], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.lintegral_gaussianPdf_eq_one", "code": "@[simp]\nlemma lintegral_gaussianPdf_eq_one (\u03bc : \u211d) {v : \u211d\u22650} (h : v \u2260 0) :\n    \u222b\u207b x, gaussianPdf \u03bc v x = 1 :=\n  lintegral_gaussianPdfReal_eq_one \u03bc h", "start": [137, 1], "end": [140, 39], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianReal", "code": "noncomputable\ndef gaussianReal (\u03bc : \u211d) (v : \u211d\u22650) : Measure \u211d :=\n  if v = 0 then Measure.dirac \u03bc else volume.withDensity (gaussianPdf \u03bc v)", "start": [146, 1], "end": [149, 74], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.gaussianReal_of_var_ne_zero", "code": "lemma gaussianReal_of_var_ne_zero (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) :\n    gaussianReal \u03bc v = volume.withDensity (gaussianPdf \u03bc v) := if_neg hv", "start": [151, 1], "end": [152, 73], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianReal_zero_var", "code": "@[simp]\nlemma gaussianReal_zero_var (\u03bc : \u211d) : gaussianReal \u03bc 0 = Measure.dirac \u03bc := if_pos rfl", "start": [154, 1], "end": [155, 87], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.instIsProbabilityMeasureGaussianReal", "code": "instance instIsProbabilityMeasureGaussianReal (\u03bc : \u211d) (v : \u211d\u22650) :\n    IsProbabilityMeasure (gaussianReal \u03bc v) where\n  measure_univ := by by_cases h : v = 0 <;> simp [gaussianReal_of_var_ne_zero, h]", "start": [157, 1], "end": [159, 82], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.gaussianReal_apply", "code": "lemma gaussianReal_apply (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) {s : Set \u211d} (hs : MeasurableSet s) :\n    gaussianReal \u03bc v s = \u222b\u207b x in s, gaussianPdf \u03bc v x := by\n  rw [gaussianReal_of_var_ne_zero _ hv, withDensity_apply _ hs]", "start": [161, 1], "end": [163, 64], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianReal_apply_eq_integral", "code": "lemma gaussianReal_apply_eq_integral (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0)\n    {s : Set \u211d} (hs : MeasurableSet s) :\n    gaussianReal \u03bc v s = ENNReal.ofReal (\u222b x in s, gaussianPdfReal \u03bc v x) := by\n  rw [gaussianReal_apply _ hv hs, ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rfl\n  \u00b7 exact (integrable_gaussianPdfReal _ _).restrict\n  \u00b7 exact ae_of_all _ (gaussianPdfReal_nonneg _ _)", "start": [165, 1], "end": [171, 51], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianReal_absolutelyContinuous", "code": "lemma gaussianReal_absolutelyContinuous (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) :\n    gaussianReal \u03bc v \u226a volume := by\n  rw [gaussianReal_of_var_ne_zero _ hv]\n  exact withDensity_absolutelyContinuous _ _", "start": [173, 1], "end": [176, 45], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.gaussianReal_absolutelyContinuous'", "code": "lemma gaussianReal_absolutelyContinuous' (\u03bc : \u211d) {v : \u211d\u22650} (hv : v \u2260 0) :\n    volume \u226a gaussianReal \u03bc v := by\n  rw [gaussianReal_of_var_ne_zero _ hv]\n  refine withDensity_absolutelyContinuous' ?_ ?_ ?_\n  \u00b7 exact (measurable_gaussianPdf _ _).aemeasurable\n  \u00b7 exact ae_of_all _ (fun _ \u21a6 (gaussianPdf_pos _ hv _).ne')\n  \u00b7 exact ae_of_all _ (fun _ \u21a6 ENNReal.ofReal_ne_top)", "start": [178, 1], "end": [184, 54], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.rnDeriv_gaussianReal", "code": "lemma rnDeriv_gaussianReal (\u03bc : \u211d) (v : \u211d\u22650) :\n    \u2202(gaussianReal \u03bc v)/\u2202volume =\u2090\u209b gaussianPdf \u03bc v := by\n  by_cases hv : v = 0\n  \u00b7 simp only [hv, gaussianReal_zero_var, gaussianPdf_zero_var]\n    refine (Measure.eq_rnDeriv measurable_zero (mutuallySingular_dirac \u03bc volume) ?_).symm\n    rw [withDensity_zero, add_zero]\n  \u00b7 rw [gaussianReal_of_var_ne_zero _ hv]\n    exact Measure.rnDeriv_withDensity _ (measurable_gaussianPdf \u03bc v)", "start": [186, 1], "end": [193, 69], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean", "imports": ["Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Arsinh.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UpperHalfPlane.dist_eq", "code": "theorem dist_eq (z w : \u210d) : dist z w = 2 * arsinh (dist (z : \u2102) w / (2 * sqrt (z.im * w.im)))", "start": [41, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.sinh_half_dist", "code": "theorem sinh_half_dist (z w : \u210d) :\n    sinh (dist z w / 2) = dist (z : \u2102) w / (2 * sqrt (z.im * w.im))", "start": [45, 1], "end": [47, 72], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.cosh_half_dist", "code": "theorem cosh_half_dist (z w : \u210d) :\n    cosh (dist z w / 2) = dist (z : \u2102) (conj (w : \u2102)) / (2 * sqrt (z.im * w.im))", "start": [50, 1], "end": [60, 7], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.tanh_half_dist", "code": "theorem tanh_half_dist (z w : \u210d) :\n    tanh (dist z w / 2) = dist (z : \u2102) w / dist (z : \u2102) (conj \u2191w)", "start": [63, 1], "end": [66, 81], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.exp_half_dist", "code": "theorem exp_half_dist (z w : \u210d) :\n    exp (dist z w / 2) = (dist (z : \u2102) w + dist (z : \u2102) (conj \u2191w)) / (2 * sqrt (z.im * w.im))", "start": [69, 1], "end": [71, 64], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.cosh_dist", "code": "theorem cosh_dist (z w : \u210d) : cosh (dist z w) = 1 + dist (z : \u2102) w ^ 2 / (2 * z.im * w.im)", "start": [74, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.sinh_half_dist_add_dist", "code": "theorem sinh_half_dist_add_dist (a b c : \u210d) : sinh ((dist a b + dist b c) / 2) =\n    (dist (a : \u2102) b * dist (c : \u2102) (conj \u2191b) + dist (b : \u2102) c * dist (a : \u2102) (conj \u2191b)) /\n      (2 * sqrt (a.im * c.im) * dist (b : \u2102) (conj \u2191b))", "start": [80, 1], "end": [88, 40], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_comm", "code": "protected theorem dist_comm (z w : \u210d) : dist z w = dist w z", "start": [91, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_le_iff_le_sinh", "code": "theorem dist_le_iff_le_sinh :\n    dist z w \u2264 r \u2194 dist (z : \u2102) w / (2 * sqrt (z.im * w.im)) \u2264 sinh (r / 2)", "start": [95, 1], "end": [97, 75], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_eq_iff_eq_sinh", "code": "theorem dist_eq_iff_eq_sinh :\n    dist z w = r \u2194 dist (z : \u2102) w / (2 * sqrt (z.im * w.im)) = sinh (r / 2)", "start": [100, 1], "end": [102, 68], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_eq_iff_eq_sq_sinh", "code": "theorem dist_eq_iff_eq_sq_sinh (hr : 0 \u2264 r) :\n    dist z w = r \u2194 dist (z : \u2102) w ^ 2 / (4 * z.im * w.im) = sinh (r / 2) ^ 2", "start": [105, 1], "end": [111, 56], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_triangle", "code": "protected theorem dist_triangle (a b c : \u210d) : dist a c \u2264 dist a b + dist b c", "start": [114, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_le_dist_coe_div_sqrt", "code": "theorem dist_le_dist_coe_div_sqrt (z w : \u210d) : dist z w \u2264 dist (z : \u2102) w / sqrt (z.im * w.im)", "start": [123, 1], "end": [125, 72], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.metricSpaceAux", "code": "def metricSpaceAux : MetricSpace \u210d where\n  dist := dist\n  dist_self z := by rw [dist_eq, dist_self, zero_div, arsinh_zero, mul_zero]\n  dist_comm := UpperHalfPlane.dist_comm\n  dist_triangle := UpperHalfPlane.dist_triangle\n  eq_of_dist_eq_zero {z w} h := by\n    simpa [dist_eq, Real.sqrt_eq_zero', (mul_pos z.im_pos w.im_pos).not_le, ext_iff] using h\n  edist_dist _ _ := by exact ENNReal.coe_nnreal_eq _", "start": [128, 1], "end": [137, 53], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.cosh_dist'", "code": "theorem cosh_dist' (z w : \u210d) :\n    Real.cosh (dist z w) = ((z.re - w.re) ^ 2 + z.im ^ 2 + w.im ^ 2) / (2 * z.im * w.im)", "start": [142, 1], "end": [146, 7], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.center", "code": "def center (z : \u210d) (r : \u211d) : \u210d :=\n  \u27e8\u27e8z.re, z.im * Real.cosh r\u27e9, mul_pos z.im_pos (cosh_pos _)\u27e9", "start": [149, 1], "end": [151, 62], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.center_re", "code": "@[simp]\ntheorem center_re (z r) : (center z r).re = z.re", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.center_im", "code": "@[simp]\ntheorem center_im (z r) : (center z r).im = z.im * Real.cosh r", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.center_zero", "code": "@[simp]\ntheorem center_zero (z : \u210d) : center z 0 = z", "start": [164, 1], "end": [166, 57], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_coe_center_sq", "code": "theorem dist_coe_center_sq (z w : \u210d) (r : \u211d) : dist (z : \u2102) (w.center r) ^ 2 =\n    2 * z.im * w.im * (Real.cosh (dist z w) - Real.cosh r) + (w.im * Real.sinh r) ^ 2", "start": [169, 1], "end": [175, 7], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_coe_center", "code": "theorem dist_coe_center (z w : \u210d) (r : \u211d) : dist (z : \u2102) (w.center r) =\n    sqrt (2 * z.im * w.im * (Real.cosh (dist z w) - Real.cosh r) + (w.im * Real.sinh r) ^ 2)", "start": [178, 1], "end": [180, 49], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.cmp_dist_eq_cmp_dist_coe_center", "code": "theorem cmp_dist_eq_cmp_dist_coe_center (z w : \u210d) (r : \u211d) :\n    cmp (dist z w) r = cmp (dist (z : \u2102) (w.center r)) (w.im * Real.sinh r)", "start": [183, 1], "end": [194, 85], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_eq_iff_dist_coe_center_eq", "code": "theorem dist_eq_iff_dist_coe_center_eq :\n    dist z w = r \u2194 dist (z : \u2102) (w.center r) = w.im * Real.sinh r", "start": [197, 1], "end": [199, 66], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_self_center", "code": "@[simp]\ntheorem dist_self_center (z : \u210d) (r : \u211d) :\n    dist (z : \u2102) (z.center r) = z.im * (Real.cosh r - 1)", "start": [202, 1], "end": [206, 91], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_center_dist", "code": "@[simp]\ntheorem dist_center_dist (z w : \u210d) :\n    dist (z : \u2102) (w.center (dist z w)) = w.im * Real.sinh (dist z w)", "start": [209, 1], "end": [212, 39], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_lt_iff_dist_coe_center_lt", "code": "theorem dist_lt_iff_dist_coe_center_lt :\n    dist z w < r \u2194 dist (z : \u2102) (w.center r) < w.im * Real.sinh r", "start": [215, 1], "end": [217, 66], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.lt_dist_iff_lt_dist_coe_center", "code": "theorem lt_dist_iff_lt_dist_coe_center :\n    r < dist z w \u2194 w.im * Real.sinh r < dist (z : \u2102) (w.center r)", "start": [220, 1], "end": [222, 87], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_le_iff_dist_coe_center_le", "code": "theorem dist_le_iff_dist_coe_center_le :\n    dist z w \u2264 r \u2194 dist (z : \u2102) (w.center r) \u2264 w.im * Real.sinh r", "start": [225, 1], "end": [227, 66], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.le_dist_iff_le_dist_coe_center", "code": "theorem le_dist_iff_le_dist_coe_center :\n    r < dist z w \u2194 w.im * Real.sinh r < dist (z : \u2102) (w.center r)", "start": [230, 1], "end": [232, 87], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_of_re_eq", "code": "nonrec theorem dist_of_re_eq (h : z.re = w.re) : dist z w = dist (log z.im) (log w.im)", "start": [235, 1], "end": [246, 7], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_log_im_le", "code": "theorem dist_log_im_le (z w : \u210d) : dist (log z.im) (log w.im) \u2264 dist z w", "start": [249, 1], "end": [257, 80], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.im_le_im_mul_exp_dist", "code": "theorem im_le_im_mul_exp_dist (z w : \u210d) : z.im \u2264 w.im * Real.exp (dist z w)", "start": [260, 1], "end": [262, 51], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.im_div_exp_dist_le", "code": "theorem im_div_exp_dist_le (z w : \u210d) : z.im / Real.exp (dist z w) \u2264 w.im", "start": [265, 1], "end": [266, 57], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.dist_coe_le", "code": "theorem dist_coe_le (z w : \u210d) : dist (z : \u2102) w \u2264 w.im * (Real.exp (dist z w) - 1)", "start": [269, 1], "end": [276, 94], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.le_dist_coe", "code": "theorem le_dist_coe (z w : \u210d) : w.im * (1 - Real.exp (-dist z w)) \u2264 dist (z : \u2102) w", "start": [279, 1], "end": [286, 69], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.im_pos_of_dist_center_le", "code": "theorem im_pos_of_dist_center_le {z : \u210d} {r : \u211d} {w : \u2102}\n    (h : dist w (center z r) \u2264 z.im * Real.sinh r) : 0 < w.im", "start": [311, 1], "end": [317, 89], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.image_coe_closedBall", "code": "theorem image_coe_closedBall (z : \u210d) (r : \u211d) :\n    ((\u2191) : \u210d \u2192 \u2102) '' closedBall (\u03b1 := \u210d) z r = closedBall \u2191(z.center r) (z.im * Real.sinh r)", "start": [320, 1], "end": [327, 67], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.image_coe_ball", "code": "theorem image_coe_ball (z : \u210d) (r : \u211d) :\n    ((\u2191) : \u210d \u2192 \u2102) '' ball (\u03b1 := \u210d) z r = ball \u2191(z.center r) (z.im * Real.sinh r)", "start": [330, 1], "end": [337, 67], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.image_coe_sphere", "code": "theorem image_coe_sphere (z : \u210d) (r : \u211d) :\n    ((\u2191) : \u210d \u2192 \u2102) '' sphere (\u03b1 := \u210d) z r = sphere \u2191(z.center r) (z.im * Real.sinh r)", "start": [340, 1], "end": [347, 67], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.isometry_vertical_line", "code": "theorem isometry_vertical_line (a : \u211d) : Isometry fun y => mk \u27e8a, exp y\u27e9 (exp_pos y)", "start": [355, 1], "end": [358, 53], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.isometry_real_vadd", "code": "theorem isometry_real_vadd (a : \u211d) : Isometry ((\u00b7 +\u1d65 \u00b7) a : \u210d \u2192 \u210d)", "start": [361, 1], "end": [362, 92], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.isometry_pos_mul", "code": "theorem isometry_pos_mul (a : { x : \u211d // 0 < x }) : Isometry ((\u00b7 \u2022 \u00b7) a : \u210d \u2192 \u210d)", "start": [365, 1], "end": [370, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Internal/Limits.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Internal/FunctorCategory.lean", "Mathlib/CategoryTheory/Monoidal/Limits.lean", "Mathlib/CategoryTheory/Limits/Preserves/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mon_.limit", "code": "@[simps!]\ndef limit (F : J \u2964 Mon_ C) : Mon_ C :=\n  limLax.mapMon.obj (MonFunctorCategoryEquivalence.inverse.obj F)", "start": [34, 1], "end": [41, 66], "kind": "commanddeclaration"}, {"full_name": "Mon_.limitCone", "code": "@[simps]\ndef limitCone (F : J \u2964 Mon_ C) : Cone F where\n  pt := limit F\n  \u03c0 :=\n    { app := fun j => { hom := limit.\u03c0 (F \u22d9 Mon_.forget C) j }\n      naturality := fun j j' f => by ext; exact (limit.cone (F \u22d9 Mon_.forget C)).\u03c0.naturality f }", "start": [45, 1], "end": [52, 98], "kind": "commanddeclaration"}, {"full_name": "Mon_.forgetMapConeLimitConeIso", "code": "def forgetMapConeLimitConeIso (F : J \u2964 Mon_ C) :\n    (forget C).mapCone (limitCone F) \u2245 limit.cone (F \u22d9 forget C) :=\n  Cones.ext (Iso.refl _) (by aesop_cat)", "start": [56, 1], "end": [61, 40], "kind": "commanddeclaration"}, {"full_name": "Mon_.limitConeIsLimit", "code": "@[simps]\ndef limitConeIsLimit (F : J \u2964 Mon_ C) : IsLimit (limitCone F) where\n  lift s :=\n    { hom := limit.lift (F \u22d9 Mon_.forget C) ((Mon_.forget C).mapCone s)\n      mul_hom := by\n        dsimp\n        ext\n        simp only [Functor.comp_obj, forget_obj, Category.assoc, limit.lift_\u03c0, Functor.mapCone_pt,\n          Functor.mapCone_\u03c0_app, forget_map, Hom.mul_hom, limit_mul, Cones.postcompose_obj_pt,\n          Cones.postcompose_obj_\u03c0, NatTrans.comp_app, Functor.const_obj_obj, tensorObj_obj,\n          MonFunctorCategoryEquivalence.Inverse.obj_mul_app]\n        slice_rhs 1 2 => rw [\u2190 MonoidalCategory.tensor_comp, limit.lift_\u03c0] }\n  fac s h := by ext; simp\n  uniq s m w := by\n    ext1\n    refine' limit.hom_ext (fun j => _)\n    dsimp; simp only [Mon_.forget_map, limit.lift_\u03c0, Functor.mapCone_\u03c0_app]\n    exact congr_arg Mon_.Hom.hom (w j)", "start": [65, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "Mon_.hasLimits", "code": "instance hasLimits : HasLimits (Mon_ C) where\n  has_limits_of_shape _ _ :=\n    { has_limit := fun F =>\n        HasLimit.mk\n          { cone := limitCone F\n            isLimit := limitConeIsLimit F } }", "start": [89, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "Mon_.forgetPreservesLimits", "code": "instance forgetPreservesLimits : PreservesLimits (Mon_.forget C) where\n  preservesLimitsOfShape :=\n    { preservesLimit := fun {F} =>\n        preservesLimitOfPreservesLimitCone (limitConeIsLimit F)\n          (IsLimit.ofIsoLimit (limit.isLimit (F \u22d9 Mon_.forget C))\n            (forgetMapConeLimitConeIso F).symm) }", "start": [98, 1], "end": [103, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Complex.lean", "imports": ["Mathlib/RingTheory/Trace.lean", "Mathlib/Data/Complex/Module.lean", "Mathlib/RingTheory/Norm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.leftMulMatrix_complex", "code": "theorem Algebra.leftMulMatrix_complex (z : \u2102) :\n    Algebra.leftMulMatrix Complex.basisOneI z = !![z.re, -z.im; z.im, z.re]", "start": [17, 1], "end": [28, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.trace_complex_apply", "code": "theorem Algebra.trace_complex_apply (z : \u2102) : Algebra.trace \u211d \u2102 z = 2 * z.re", "start": [31, 1], "end": [34, 25], "kind": "commanddeclaration"}, {"full_name": "Algebra.norm_complex_apply", "code": "theorem Algebra.norm_complex_apply (z : \u2102) : Algebra.norm \u211d z = Complex.normSq z", "start": [37, 1], "end": [40, 7], "kind": "commanddeclaration"}, {"full_name": "Algebra.norm_complex_eq", "code": "theorem Algebra.norm_complex_eq : Algebra.norm \u211d = normSq.toMonoidHom", "start": [43, 1], "end": [44, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/Monotone.lean", "imports": ["Mathlib/Data/Fin/VecNotation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "liftFun_vecCons", "code": "theorem liftFun_vecCons {n : \u2115} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] {f : Fin (n + 1) \u2192 \u03b1} {a : \u03b1} :\n    ((\u00b7 < \u00b7) \u21d2 r) (vecCons a f) (vecCons a f) \u2194 r a (f 0) \u2227 ((\u00b7 < \u00b7) \u21d2 r) f f", "start": [21, 1], "end": [24, 19], "kind": "commanddeclaration"}, {"full_name": "strictMono_vecCons", "code": "@[simp]\ntheorem strictMono_vecCons : StrictMono (vecCons a f) \u2194 a < f 0 \u2227 StrictMono f", "start": [29, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "monotone_vecCons", "code": "@[simp]\ntheorem monotone_vecCons : Monotone (vecCons a f) \u2194 a \u2264 f 0 \u2227 Monotone f", "start": [34, 1], "end": [36, 79], "kind": "commanddeclaration"}, {"full_name": "monotone_vecEmpty", "code": "@[simp]\ntheorem monotone_vecEmpty : Monotone (vecCons a vecEmpty)", "start": [40, 1], "end": [42, 35], "kind": "commanddeclaration"}, {"full_name": "strictMono_vecEmpty", "code": "@[simp]\ntheorem strictMono_vecEmpty : StrictMono (vecCons a vecEmpty)", "start": [45, 1], "end": [47, 43], "kind": "commanddeclaration"}, {"full_name": "strictAnti_vecCons", "code": "@[simp]\ntheorem strictAnti_vecCons : StrictAnti (vecCons a f) \u2194 f 0 < a \u2227 StrictAnti f", "start": [49, 1], "end": [51, 26], "kind": "commanddeclaration"}, {"full_name": "antitone_vecCons", "code": "@[simp]\ntheorem antitone_vecCons : Antitone (vecCons a f) \u2194 f 0 \u2264 a \u2227 Antitone f", "start": [54, 1], "end": [56, 32], "kind": "commanddeclaration"}, {"full_name": "antitone_vecEmpty", "code": "@[simp]\ntheorem antitone_vecEmpty : Antitone (vecCons a vecEmpty)", "start": [60, 1], "end": [62, 35], "kind": "commanddeclaration"}, {"full_name": "strictAnti_vecEmpty", "code": "@[simp]\ntheorem strictAnti_vecEmpty : StrictAnti (vecCons a vecEmpty)", "start": [65, 1], "end": [67, 43], "kind": "commanddeclaration"}, {"full_name": "StrictMono.vecCons", "code": "theorem StrictMono.vecCons (hf : StrictMono f) (ha : a < f 0) : StrictMono (vecCons a f)", "start": [69, 1], "end": [70, 32], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.vecCons", "code": "theorem StrictAnti.vecCons (hf : StrictAnti f) (ha : f 0 < a) : StrictAnti (vecCons a f)", "start": [73, 1], "end": [74, 32], "kind": "commanddeclaration"}, {"full_name": "Monotone.vecCons", "code": "theorem Monotone.vecCons (hf : Monotone f) (ha : a \u2264 f 0) : Monotone (vecCons a f)", "start": [77, 1], "end": [78, 30], "kind": "commanddeclaration"}, {"full_name": "Antitone.vecCons", "code": "theorem Antitone.vecCons (hf : Antitone f) (ha : f 0 \u2264 a) : Antitone (vecCons a f)", "start": [81, 1], "end": [82, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/KreinMilman.lean", "imports": ["Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean", "Mathlib/Analysis/Convex/Exposed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsCompact.has_extreme_point", "code": "theorem IsCompact.has_extreme_point (hscomp : IsCompact s) (hsnemp : s.Nonempty) :\n    (s.extremePoints \u211d).Nonempty", "start": [62, 1], "end": [90, 54], "kind": "commanddeclaration"}, {"full_name": "closure_convexHull_extremePoints", "code": "theorem closure_convexHull_extremePoints (hscomp : IsCompact s) (hAconv : Convex \u211d s) :\n    closure (convexHull \u211d <| s.extremePoints \u211d) = s", "start": [93, 1], "end": [106, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/Indicator.lean", "imports": ["Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean", "Mathlib/MeasureTheory/Integral/Lebesgue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.tendsto_measure_of_tendsto_indicator", "code": "lemma tendsto_measure_of_tendsto_indicator [NeBot L] {\u03bc : Measure \u03b1}\n    (As_mble : \u2200 i, MeasurableSet (As i)) {B : Set \u03b1} (B_mble : MeasurableSet B)\n    (B_finmeas : \u03bc B \u2260 \u221e) (As_le_B : \u2200\u1da0 i in L, As i \u2286 B)\n    (h_lim : Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e)) L (\ud835\udcdd (A.indicator 1))) :\n    Tendsto (fun i \u21a6 \u03bc (As i)) L (\ud835\udcdd (\u03bc A)) := by\n  apply tendsto_measure_of_ae_tendsto_indicator L ?_ As_mble B_mble B_finmeas As_le_B\n  \u00b7 exact eventually_of_forall (by simpa only [tendsto_pi_nhds] using h_lim)\n  \u00b7 exact measurableSet_of_tendsto_indicator L As_mble h_lim", "start": [39, 1], "end": [49, 61], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.tendsto_measure_of_tendsto_indicator_of_isFiniteMeasure", "code": "lemma tendsto_measure_of_tendsto_indicator_of_isFiniteMeasure [NeBot L]\n    (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (As_mble : \u2200 i, MeasurableSet (As i))\n    (h_lim : Tendsto (fun i \u21a6 (As i).indicator (1 : \u03b1 \u2192 \u211d\u22650\u221e)) L (\ud835\udcdd (A.indicator 1))) :\n    Tendsto (fun i \u21a6 \u03bc (As i)) L (\ud835\udcdd (\u03bc A)) := by\n  apply tendsto_measure_of_ae_tendsto_indicator_of_isFiniteMeasure L ?_ As_mble\n  \u00b7 exact eventually_of_forall (by simpa only [tendsto_pi_nhds] using h_lim)\n  \u00b7 exact measurableSet_of_tendsto_indicator L As_mble h_lim", "start": [51, 1], "end": [59, 61], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Combinatorics/Derangements/Exponential.lean", "imports": ["Mathlib/Order/Filter/Basic.lean", "Mathlib/Combinatorics/Derangements/Finite.lean", "Mathlib/Analysis/SpecialFunctions/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "numDerangements_tendsto_inv_e", "code": "theorem numDerangements_tendsto_inv_e :\n    Tendsto (fun n => (numDerangements n : \u211d) / n.factorial) atTop (\ud835\udcdd (Real.exp (-1)))", "start": [26, 1], "end": [54, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Dual.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/LinearAlgebra/Dual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.toMatrix_transpose", "code": "@[simp]\ntheorem LinearMap.toMatrix_transpose (u : V\u2081 \u2192\u2097[K] V\u2082) :\n    LinearMap.toMatrix B\u2082.dualBasis B\u2081.dualBasis (Module.Dual.transpose (R := K) u) =\n      (LinearMap.toMatrix B\u2081 B\u2082 u)\u1d40", "start": [31, 1], "end": [37, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_transpose", "code": "@[simp]\ntheorem Matrix.toLin_transpose (M : Matrix \u03b9\u2081 \u03b9\u2082 K) : Matrix.toLin B\u2081.dualBasis B\u2082.dualBasis M\u1d40 =\n    Module.Dual.transpose (R := K) (Matrix.toLin B\u2082 B\u2081 M)", "start": [40, 1], "end": [44, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Sigma.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sigma.smul_def", "code": "@[to_additive]\ntheorem smul_def : a \u2022 x = x.map id fun _ => (\u00b7 \u2022 \u00b7) a", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Sigma.smul_mk", "code": "@[to_additive (attr := simp)]\ntheorem smul_mk : a \u2022 mk i b = \u27e8i, a \u2022 b\u27e9", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Sigma.FaithfulSMul'", "code": "@[to_additive \"This is not an instance because `i` becomes a metavariable.\"]\nprotected theorem FaithfulSMul' [FaithfulSMul M (\u03b1 i)] : FaithfulSMul M (\u03a3i, \u03b1 i)", "start": [65, 1], "end": [68, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Liouville/Measure.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean", "Mathlib/Analysis/PSeries.lean", "Mathlib/NumberTheory/Liouville/LiouvilleWith.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/Liouville/Residual.lean"], "premises": [{"full_name": "setOf_liouvilleWith_subset_aux", "code": "theorem setOf_liouvilleWith_subset_aux :\n    { x : \u211d | \u2203 p > 2, LiouvilleWith p x } \u2286\n      \u22c3 m : \u2124, (\u00b7 + (m : \u211d)) \u207b\u00b9' \u22c3 n > (0 : \u2115),\n        { x : \u211d | \u2203\u1da0 b : \u2115 in atTop, \u2203 a \u2208 Finset.Icc (0 : \u2124) b,\n          |x - (a : \u2124) / b| < 1 / (b : \u211d) ^ (2 + 1 / n : \u211d) }", "start": [36, 1], "end": [73, 49], "kind": "commanddeclaration"}, {"full_name": "volume_iUnion_setOf_liouvilleWith", "code": "@[simp]\ntheorem volume_iUnion_setOf_liouvilleWith :\n    volume (\u22c3 (p : \u211d) (_hp : 2 < p), { x : \u211d | LiouvilleWith p x }) = 0", "start": [76, 1], "end": [108, 90], "kind": "commanddeclaration"}, {"full_name": "ae_not_liouvilleWith", "code": "theorem ae_not_liouvilleWith : \u2200\u1d50 x, \u2200 p > (2 : \u211d), \u00acLiouvilleWith p x", "start": [111, 1], "end": [113, 38], "kind": "commanddeclaration"}, {"full_name": "ae_not_liouville", "code": "theorem ae_not_liouville : \u2200\u1d50 x, \u00acLiouville x", "start": [116, 1], "end": [117, 83], "kind": "commanddeclaration"}, {"full_name": "volume_setOf_liouville", "code": "@[simp]\ntheorem volume_setOf_liouville : volume { x : \u211d | Liouville x } = 0", "start": [120, 1], "end": [123, 64], "kind": "commanddeclaration"}, {"full_name": "Real.disjoint_residual_ae", "code": "theorem Real.disjoint_residual_ae : Disjoint (residual \u211d) volume.ae", "start": [126, 1], "end": [129, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/EquivMon.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Mon_.lean", "Mathlib/CategoryTheory/Monoidal/End.lean", "Mathlib/CategoryTheory/Monad/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monad.toMon", "code": "@[simps]\ndef toMon (M : Monad C) : Mon_ (C \u2964 C) where\n  X := (M : C \u2964 C)\n  one := M.\u03b7\n  mul := M.\u03bc\n  mul_assoc := by ext; simp [M.assoc]", "start": [41, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadToMon", "code": "@[simps]\ndef monadToMon : Monad C \u2964 Mon_ (C \u2964 C) where\n  obj := toMon\n  map f := { hom := f.toNatTrans }", "start": [52, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.ofMon", "code": "@[simps \u03b7 \u03bc]\ndef ofMon (M : Mon_ (C \u2964 C)) : Monad C where\n  toFunctor := M.X\n  \u03b7' := M.one\n  \u03bc' := M.mul\n  left_unit' := fun X => by\n    erw [\u2190 NatTrans.id_hcomp_app M.one, \u2190 NatTrans.comp_app, M.mul_one]\n    rfl\n  right_unit' := fun X => by\n    erw [\u2190 NatTrans.hcomp_id_app M.one, \u2190 NatTrans.comp_app, M.one_mul]\n    rfl\n  assoc' := fun X => by\n    rw [\u2190 NatTrans.hcomp_id_app, \u2190 NatTrans.comp_app]\n    erw [M.mul_assoc]\n    simp", "start": [61, 1], "end": [79, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.ofMon_obj", "code": "@[simp] lemma ofMon_obj (M : Mon_ (C \u2964 C)) (X : C) : (ofMon M).obj X = M.X.obj X := rfl", "start": [83, 1], "end": [83, 88], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Monad.monToMonad", "code": "@[simps]\ndef monToMonad : Mon_ (C \u2964 C) \u2964 Monad C where\n  obj := ofMon\n  map {X Y} f :=\n    { f.hom with\n      app_\u03b7 := by\n        intro X\n        erw [\u2190 NatTrans.comp_app, f.one_hom]\n        rfl\n      app_\u03bc := by\n        intro Z\n        erw [\u2190 NatTrans.comp_app, f.mul_hom]\n        dsimp\n        simp only [NatTrans.naturality, NatTrans.hcomp_app, assoc, NatTrans.comp_app,\n          ofMon_\u03bc] }", "start": [87, 1], "end": [102, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.monadMonEquiv", "code": "@[simps]\ndef monadMonEquiv : Monad C \u224c Mon_ (C \u2964 C) where\n  functor := monadToMon _\n  inverse := monToMonad _\n  unitIso :=\n  { hom := { app := fun _ => { app := fun _ => \ud835\udfd9 _ } }\n    inv := { app := fun _ => { app := fun _ => \ud835\udfd9 _ } } }\n  counitIso :=\n  { hom := { app := fun _ => { hom := \ud835\udfd9 _ } }\n    inv := { app := fun _ => { hom := \ud835\udfd9 _ } } }", "start": [105, 1], "end": [115, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/CategoryTheory.lean", "imports": ["Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean", "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticModuleCat.cliffordAlgebra", "code": "@[simps]\ndef QuadraticModuleCat.cliffordAlgebra : QuadraticModuleCat.{u} R \u2964 AlgebraCat.{u} R where\n  obj M := { carrier := CliffordAlgebra M.form }\n  map {_M _N} f := CliffordAlgebra.map f.toIsometry\n  map_id _M := CliffordAlgebra.map_id _\n  map_comp {_M _N _P} f g := (CliffordAlgebra.map_comp_map g.toIsometry f.toIsometry).symm", "start": [21, 1], "end": [30, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/BaseChange.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean", "Mathlib/RingTheory/TensorProduct.lean", "Mathlib/LinearAlgebra/TensorProduct/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "Mathlib/Data/Complex/Module.lean"], "premises": [{"full_name": "CliffordAlgebra.ofBaseChangeAux", "code": "noncomputable def ofBaseChangeAux (Q : QuadraticForm R V) :\n    CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra (Q.baseChange A) :=\n  CliffordAlgebra.lift Q <| by\n    refine \u27e8(\u03b9 (Q.baseChange A)).restrictScalars R \u2218\u2097 TensorProduct.mk R A V 1, fun v => ?_\u27e9\n    refine (CliffordAlgebra.\u03b9_sq_scalar (Q.baseChange A) (1 \u2297\u209c v)).trans ?_\n    rw [QuadraticForm.baseChange_tmul, one_mul, \u2190Algebra.algebraMap_eq_smul_one,\n      \u2190IsScalarTower.algebraMap_apply]", "start": [45, 1], "end": [53, 39], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChangeAux_\u03b9", "code": "@[simp] theorem ofBaseChangeAux_\u03b9 (Q : QuadraticForm R V) (v : V) :\n    ofBaseChangeAux A Q (\u03b9 Q v) = \u03b9 (Q.baseChange A) (1 \u2297\u209c v)", "start": [55, 1], "end": [57, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChange", "code": "noncomputable def ofBaseChange (Q : QuadraticForm R V) :\n    A \u2297[R] CliffordAlgebra Q \u2192\u2090[A] CliffordAlgebra (Q.baseChange A) :=\n  Algebra.TensorProduct.lift (Algebra.ofId _ _) (ofBaseChangeAux A Q)\n    fun _a _x => Algebra.commutes _ _", "start": [59, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChange_tmul_\u03b9", "code": "@[simp] theorem ofBaseChange_tmul_\u03b9 (Q : QuadraticForm R V) (z : A) (v : V) :\n    ofBaseChange A Q (z \u2297\u209c \u03b9 Q v) = \u03b9 (Q.baseChange A) (z \u2297\u209c v)", "start": [67, 1], "end": [71, 13], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChange_tmul_one", "code": "@[simp] theorem ofBaseChange_tmul_one (Q : QuadraticForm R V) (z : A) :\n    ofBaseChange A Q (z \u2297\u209c 1) = algebraMap _ _ z", "start": [73, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange", "code": "noncomputable def toBaseChange (Q : QuadraticForm R V) :\n    CliffordAlgebra (Q.baseChange A) \u2192\u2090[A] A \u2297[R] CliffordAlgebra Q :=\n  CliffordAlgebra.lift _ <| by\n    refine \u27e8TensorProduct.AlgebraTensorModule.map (LinearMap.id : A \u2192\u2097[A] A) (\u03b9 Q), ?_\u27e9\n    letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm\n    letI : Invertible (2 : A \u2297[R] CliffordAlgebra Q) :=\n      (Invertible.map (algebraMap R _) 2).copy 2 (map_ofNat _ _).symm\n    suffices hpure_tensor : \u2200 v w, (1 * 1) \u2297\u209c[R] (\u03b9 Q v * \u03b9 Q w) + (1 * 1) \u2297\u209c[R] (\u03b9 Q w * \u03b9 Q v) =\n        QuadraticForm.polarBilin (Q.baseChange A) (1 \u2297\u209c[R] v) (1 \u2297\u209c[R] w) \u2297\u209c[R] 1 by\n      rw [CliffordAlgebra.forall_mul_self_eq_iff (isUnit_of_invertible _)]\n      refine TensorProduct.AlgebraTensorModule.curry_injective ?_\n      ext v w\n      exact hpure_tensor v w\n    intros v w\n    rw [\u2190 TensorProduct.tmul_add, CliffordAlgebra.\u03b9_mul_\u03b9_add_swap,\n      QuadraticForm.polarBilin_baseChange, BilinForm.baseChange_tmul, one_mul,\n      TensorProduct.smul_tmul, Algebra.algebraMap_eq_smul_one, QuadraticForm.polarBilin_apply]", "start": [78, 1], "end": [99, 95], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_\u03b9", "code": "@[simp] theorem toBaseChange_\u03b9 (Q : QuadraticForm R V) (z : A) (v : V) :\n    toBaseChange A Q (\u03b9 (Q.baseChange A) (z \u2297\u209c v)) = z \u2297\u209c \u03b9 Q v", "start": [101, 1], "end": [103, 37], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_comp_involute", "code": "theorem toBaseChange_comp_involute (Q : QuadraticForm R V) :\n    (toBaseChange A Q).comp (involute : CliffordAlgebra (Q.baseChange A) \u2192\u2090[A] _) =\n      (Algebra.TensorProduct.map (AlgHom.id _ _) involute).comp (toBaseChange A Q)", "start": [105, 1], "end": [114, 89], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_involute", "code": "theorem toBaseChange_involute (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    toBaseChange A Q (involute x) =\n      TensorProduct.map LinearMap.id (involute.toLinearMap) (toBaseChange A Q x)", "start": [116, 1], "end": [120, 55], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_comp_reverseOp", "code": "theorem toBaseChange_comp_reverseOp (Q : QuadraticForm R V) :\n    (toBaseChange A Q).op.comp (reverseOp) =\n      ((Algebra.TensorProduct.opAlgEquiv R A A (CliffordAlgebra Q)).toAlgHom.comp <|\n        (Algebra.TensorProduct.map\n          (AlgEquiv.toOpposite A A).toAlgHom (reverseOp (Q := Q))).comp\n        (toBaseChange A Q))", "start": [124, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_reverse", "code": "theorem toBaseChange_reverse (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    toBaseChange A Q (reverse x) =\n      TensorProduct.map LinearMap.id reverse (toBaseChange A Q x)", "start": [140, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_comp_ofBaseChange", "code": "theorem toBaseChange_comp_ofBaseChange (Q : QuadraticForm R V) :\n    (toBaseChange A Q).comp (ofBaseChange A Q) = AlgHom.id _ _", "start": [156, 1], "end": [164, 45], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.toBaseChange_ofBaseChange", "code": "@[simp] theorem toBaseChange_ofBaseChange (Q : QuadraticForm R V) (x : A \u2297[R] CliffordAlgebra Q) :\n    toBaseChange A Q (ofBaseChange A Q x) = x", "start": [166, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChange_comp_toBaseChange", "code": "theorem ofBaseChange_comp_toBaseChange (Q : QuadraticForm R V) :\n    (ofBaseChange A Q).comp (toBaseChange A Q) = AlgHom.id _ _", "start": [170, 1], "end": [175, 43], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.ofBaseChange_toBaseChange", "code": "@[simp] theorem ofBaseChange_toBaseChange\n    (Q : QuadraticForm R V) (x : CliffordAlgebra (Q.baseChange A)) :\n    ofBaseChange A Q (toBaseChange A Q x) = x", "start": [177, 1], "end": [180, 62], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.equivBaseChange", "code": "@[simps!]\nnoncomputable def equivBaseChange (Q : QuadraticForm R V) :\n    CliffordAlgebra (Q.baseChange A) \u2243\u2090[A] A \u2297[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom (toBaseChange A Q) (ofBaseChange A Q)\n    (toBaseChange_comp_ofBaseChange A Q)\n    (ofBaseChange_comp_toBaseChange A Q)", "start": [182, 1], "end": [192, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/DenselyOrdered.lean", "imports": ["Mathlib/Algebra/Order/Monoid/OrderDual.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "le_of_forall_lt_one_mul_le", "code": "@[to_additive]\ntheorem le_of_forall_lt_one_mul_le (h : \u2200 \u03b5 < 1, a * \u03b5 \u2264 b) : a \u2264 b", "start": [27, 1], "end": [29, 52], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_one_lt_div_le", "code": "@[to_additive]\ntheorem le_of_forall_one_lt_div_le (h : \u2200 \u03b5 : \u03b1, 1 < \u03b5 \u2192 a / \u03b5 \u2264 b) : a \u2264 b", "start": [33, 1], "end": [36, 80], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_one_lt_le_mul", "code": "@[to_additive]\ntheorem le_iff_forall_one_lt_le_mul : a \u2264 b \u2194 \u2200 \u03b5, 1 < \u03b5 \u2192 a \u2264 b * \u03b5", "start": [40, 1], "end": [42, 83], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_lt_one_mul_le", "code": "@[to_additive]\ntheorem le_iff_forall_lt_one_mul_le : a \u2264 b \u2194 \u2200 \u03b5 < 1, a * \u03b5 \u2264 b", "start": [46, 1], "end": [48, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/MixedCharZero.lean", "imports": ["Mathlib/RingTheory/Ideal/Quotient.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CharP/LocalRing.lean", "Mathlib/Algebra/CharP/Algebra.lean"], "premises": [{"full_name": "MixedCharZero", "code": "class MixedCharZero (p : \u2115) : Prop where\n  [toCharZero : CharZero R]\n  charP_quotient : \u2203 I : Ideal R, I \u2260 \u22a4 \u2227 CharP (R \u29f8 I) p", "start": [65, 1], "end": [77, 58], "kind": "commanddeclaration"}, {"full_name": "MixedCharZero.reduce_to_p_prime", "code": "theorem reduce_to_p_prime {P : Prop} :\n    (\u2200 p > 0, MixedCharZero R p \u2192 P) \u2194 \u2200 p : \u2115, p.Prime \u2192 MixedCharZero R p \u2192 P", "start": [82, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "MixedCharZero.reduce_to_maximal_ideal", "code": "theorem reduce_to_maximal_ideal {p : \u2115} (hp : Nat.Prime p) :\n    (\u2203 I : Ideal R, I \u2260 \u22a4 \u2227 CharP (R \u29f8 I) p) \u2194 \u2203 I : Ideal R, I.IsMaximal \u2227 CharP (R \u29f8 I) p", "start": [109, 1], "end": [137, 51], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.of_algebraRat", "code": "theorem of_algebraRat [Algebra \u211a R] : \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)", "start": [161, 1], "end": [170, 75], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.PNat.isUnit_natCast", "code": "theorem PNat.isUnit_natCast [h : Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))]\n    (n : \u2115+) : IsUnit (n : R)", "start": [178, 1], "end": [190, 48], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.pnatCast", "code": "@[coe]\nnoncomputable def pnatCast [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] : \u2115+ \u2192 R\u02e3 :=\n  fun n => (PNat.isUnit_natCast n).unit", "start": [193, 1], "end": [195, 40], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.coePNatUnits", "code": "noncomputable instance coePNatUnits\n    [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] : Coe \u2115+ R\u02e3 :=\n  \u27e8EqualCharZero.pnatCast\u27e9", "start": [197, 1], "end": [200, 27], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.pnatCast_one", "code": "@[simp]\ntheorem pnatCast_one [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] : ((1 : \u2115+) : R\u02e3) = 1", "start": [203, 1], "end": [210, 34], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.pnatCast_eq_natCast", "code": "@[simp]\ntheorem pnatCast_eq_natCast [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] (n : \u2115+) :\n    ((n : R\u02e3) : R) = \u2191n", "start": [213, 1], "end": [218, 31], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.algebraRat", "code": "noncomputable def algebraRat (h : \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) :\n    Algebra \u211a R :=\n  haveI : Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) := \u27e8h\u27e9\n  RingHom.toAlgebra\n  { toFun := fun x => x.num /\u209a \u2191x.pnatDen\n    map_zero' := by simp [divp]\n    map_one' := by simp\n    map_mul' := by\n      intro a b\n      field_simp\n      trans (\u2191((a * b).num * a.den * b.den) : R)\n      \u00b7 simp_rw [Int.cast_mul, Int.cast_ofNat]\n        ring\n      rw [Rat.mul_num_den' a b]\n      simp\n    map_add' := by\n      intro a b\n      field_simp\n      trans (\u2191((a + b).num * a.den * b.den) : R)\n      \u00b7 simp_rw [Int.cast_mul, Int.cast_ofNat]\n        ring\n      rw [Rat.add_num_den' a b]\n      simp }", "start": [221, 1], "end": [244, 13], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.of_not_mixedCharZero", "code": "theorem of_not_mixedCharZero [CharZero R] (h : \u2200 p > 0, \u00acMixedCharZero R p) :\n    \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)", "start": [250, 1], "end": [262, 49], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.to_not_mixedCharZero", "code": "theorem to_not_mixedCharZero (h : \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) :\n    \u2200 p > 0, \u00acMixedCharZero R p", "start": [265, 1], "end": [272, 64], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.iff_not_mixedCharZero", "code": "theorem iff_not_mixedCharZero [CharZero R] :\n    (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) \u2194 \u2200 p > 0, \u00acMixedCharZero R p", "start": [275, 1], "end": [281, 51], "kind": "commanddeclaration"}, {"full_name": "EqualCharZero.nonempty_algebraRat_iff", "code": "theorem nonempty_algebraRat_iff :\n    Nonempty (Algebra \u211a R) \u2194 \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)", "start": [284, 1], "end": [293, 23], "kind": "commanddeclaration"}, {"full_name": "isEmpty_algebraRat_iff_mixedCharZero", "code": "theorem isEmpty_algebraRat_iff_mixedCharZero [CharZero R] :\n    IsEmpty (Algebra \u211a R) \u2194 \u2203 p > 0, MixedCharZero R p", "start": [299, 1], "end": [307, 46], "kind": "commanddeclaration"}, {"full_name": "split_equalCharZero_mixedCharZero", "code": "theorem split_equalCharZero_mixedCharZero [CharZero R] (h_equal : Algebra \u211a R \u2192 P)\n    (h_mixed : \u2200 p : \u2115, Nat.Prime p \u2192 MixedCharZero R p \u2192 P) : P", "start": [325, 1], "end": [334, 17], "kind": "commanddeclaration"}, {"full_name": "split_by_characteristic", "code": "theorem split_by_characteristic (h_pos : \u2200 p : \u2115, p \u2260 0 \u2192 CharP R p \u2192 P) (h_equal : Algebra \u211a R \u2192 P)\n    (h_mixed : \u2200 p : \u2115, Nat.Prime p \u2192 MixedCharZero R p \u2192 P) : P", "start": [340, 1], "end": [354, 30], "kind": "commanddeclaration"}, {"full_name": "split_by_characteristic_domain", "code": "theorem split_by_characteristic_domain [IsDomain R] (h_pos : \u2200 p : \u2115, Nat.Prime p \u2192 CharP R p \u2192 P)\n    (h_equal : Algebra \u211a R \u2192 P) (h_mixed : \u2200 p : \u2115, Nat.Prime p \u2192 MixedCharZero R p \u2192 P) : P", "start": [357, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "split_by_characteristic_localRing", "code": "theorem split_by_characteristic_localRing [LocalRing R]\n    (h_pos : \u2200 p : \u2115, IsPrimePow p \u2192 CharP R p \u2192 P) (h_equal : Algebra \u211a R \u2192 P)\n    (h_mixed : \u2200 p : \u2115, Nat.Prime p \u2192 MixedCharZero R p \u2192 P) : P", "start": [371, 2], "end": [383, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/EditDistance/Estimator.lean", "imports": ["Mathlib/Data/List/EditDistance/Bounds.lean", "Mathlib/Order/Estimator.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LevenshteinEstimator'", "code": "structure LevenshteinEstimator' : Type where\n  \n  pre_rev : List \u03b2\n  \n  suff : List \u03b2\n  \n  split : pre_rev.reverse ++ suff = ys\n  \n  distances : {r : List \u03b4 // 0 < r.length}\n  \n  distances_eq : distances = suffixLevenshtein C xs suff\n  \n  bound : \u03b4 \u00d7 \u2115\n  \n  bound_eq : bound = match pre_rev with\n    | [] => (distances.1[0]'(distances.2), ys.length)\n    | _ => (List.minimum_of_length_pos distances.2, suff.length)", "start": [31, 1], "end": [60, 65], "kind": "commanddeclaration"}, {"full_name": "estimator'", "code": "instance estimator' :\n    Estimator (Thunk.mk fun _ => (levenshtein C xs ys, ys.length))\n      (LevenshteinEstimator' C xs ys) where\n  bound_le e := match e.pre_rev, e.split, e.bound_eq with\n  | [], split, eq => by\n    simp only [List.reverse_nil, List.nil_append] at split\n    rw [e.distances_eq] at eq\n    simp only [List.getElem_eq_get] at eq\n    rw [split] at eq\n    exact eq.le\n  | y :: t, split, eq => by\n    rw [e.distances_eq] at eq\n    simp only at eq\n    dsimp [EstimatorData.bound]\n    rw [eq]\n    simp only [\u2190split]\n    constructor\n    \u00b7 simp only [List.minimum_of_length_pos_le_iff]\n      exact suffixLevenshtein_minimum_le_levenshtein_append _ _ _\n    \u00b7 exact List.length_le_of_sublist (List.sublist_append_right _ _)\n  improve_spec e := by\n    dsimp [EstimatorData.improve]\n    match e.pre_rev, e.split, e.bound_eq, e.distances_eq with\n    | [], split, eq, _ =>\n      simp only [List.reverse_nil, List.nil_append] at split\n      rw [e.distances_eq] at eq\n      simp only [List.getElem_eq_get] at eq\n      rw [split] at eq\n      exact eq\n    | [y], split, b_eq, d_eq =>\n      simp only [EstimatorData.bound, Prod.lt_iff, List.reverse_nil, List.nil_append]\n      right\n      have b_eq : e.bound = (List.minimum_of_length_pos _, List.length e.suff) := by\n        simpa using b_eq\n      rw [b_eq]\n      constructor\n      \u00b7 refine (?_ : _ \u2264 _).trans (List.minimum_of_length_pos_le_getElem _)\n        simp only [List.minimum_of_length_pos_le_iff, List.coe_minimum_of_length_pos, d_eq]\n        apply le_suffixLevenshtein_cons_minimum\n      \u00b7 simp [\u2190split]\n    | y\u2081 :: y\u2082 :: t, split, b_eq, d_eq =>\n      simp only [EstimatorData.bound, Prod.lt_iff]\n      right\n      have b_eq : e.bound = (List.minimum_of_length_pos _, List.length e.suff) := by\n        simpa using b_eq\n      rw [b_eq]\n      constructor\n      \u00b7 simp only [d_eq, List.minimum_of_length_pos_le_iff, List.coe_minimum_of_length_pos]\n        apply le_suffixLevenshtein_cons_minimum\n      \u00b7 exact Nat.lt.base _", "start": [76, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "LevenshteinEstimator", "code": "def LevenshteinEstimator : Type _ :=\n  Estimator.fst (Thunk.mk fun _ => (levenshtein C xs ys, ys.length)) (LevenshteinEstimator' C xs ys)", "start": [127, 1], "end": [129, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean", "imports": ["Mathlib/Topology/Algebra/Polynomial.lean", "Mathlib/Analysis/Calculus/LocalExtr/Rolle.lean", "Mathlib/Analysis/Calculus/Deriv/Polynomial.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.card_roots_toFinset_le_card_roots_derivative_diff_roots_succ", "code": "theorem card_roots_toFinset_le_card_roots_derivative_diff_roots_succ (p : \u211d[X]) :\n    p.roots.toFinset.card \u2264 (p.derivative.roots.toFinset \\ p.roots.toFinset).card + 1", "start": [36, 1], "end": [48, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_toFinset_le_derivative", "code": "theorem card_roots_toFinset_le_derivative (p : \u211d[X]) :\n    p.roots.toFinset.card \u2264 p.derivative.roots.toFinset.card + 1", "start": [51, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_le_derivative", "code": "theorem card_roots_le_derivative (p : \u211d[X]) :\n    Multiset.card p.roots \u2264 Multiset.card (derivative p).roots + 1", "start": [59, 1], "end": [88, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_rootSet_le_derivative", "code": "theorem card_rootSet_le_derivative {F : Type*} [CommRing F] [Algebra F \u211d] (p : F[X]) :\n    Fintype.card (p.rootSet \u211d) \u2264 Fintype.card (p.derivative.rootSet \u211d) + 1", "start": [91, 1], "end": [96, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Opposite.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.MonoidalOpposite", "code": "def MonoidalOpposite (C : Type u\u2081) :=\n  C", "start": [25, 1], "end": [28, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.mop", "code": "def mop (X : C) : C\u1d39\u1d52\u1d56 :=\n  X", "start": [35, 1], "end": [38, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.unmop", "code": "def unmop (X : C\u1d39\u1d52\u1d56) : C :=\n  X", "start": [41, 1], "end": [44, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.op_injective", "code": "theorem op_injective : Function.Injective (mop : C \u2192 C\u1d39\u1d52\u1d56)", "start": [47, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.unop_injective", "code": "theorem unop_injective : Function.Injective (unmop : C\u1d39\u1d52\u1d56 \u2192 C)", "start": [51, 1], "end": [52, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.op_inj_iff", "code": "@[simp]\ntheorem op_inj_iff (x y : C) : mop x = mop y \u2194 x = y", "start": [55, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.unop_inj_iff", "code": "@[simp]\ntheorem unop_inj_iff (x y : C\u1d39\u1d52\u1d56) : unmop x = unmop y \u2194 x = y", "start": [60, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.mop_unmop", "code": "@[simp]\ntheorem mop_unmop (X : C\u1d39\u1d52\u1d56) : mop (unmop X) = X", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.unmop_mop", "code": "@[simp]\ntheorem unmop_mop (X : C) : unmop (mop X) = X", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.MonoidalOpposite.monoidalOppositeCategory", "code": "instance monoidalOppositeCategory [Category.{v\u2081} C] : Category C\u1d39\u1d52\u1d56 :=\n  InducedCategory.category unmop", "start": [75, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.mop", "code": "def Quiver.Hom.mop {X Y : C} (f : X \u27f6 Y) : @Quiver.Hom C\u1d39\u1d52\u1d56 _ (mop X) (mop Y) :=\n  f", "start": [89, 1], "end": [91, 4], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.unmop", "code": "def Quiver.Hom.unmop {X Y : C\u1d39\u1d52\u1d56} (f : X \u27f6 Y) : unmop X \u27f6 unmop Y :=\n  f", "start": [94, 1], "end": [96, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_inj", "code": "theorem mop_inj {X Y : C} : Function.Injective (Quiver.Hom.mop : (X \u27f6 Y) \u2192 (mop X \u27f6 mop Y))", "start": [101, 1], "end": [102, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unmop_inj", "code": "theorem unmop_inj {X Y : C\u1d39\u1d52\u1d56} :\n    Function.Injective (Quiver.Hom.unmop : (X \u27f6 Y) \u2192 (unmop X \u27f6 unmop Y))", "start": [105, 1], "end": [107, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unmop_mop", "code": "@[simp]\ntheorem unmop_mop {X Y : C} {f : X \u27f6 Y} : f.mop.unmop = f", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_unmop", "code": "@[simp]\ntheorem mop_unmop {X Y : C\u1d39\u1d52\u1d56} {f : X \u27f6 Y} : f.unmop.mop = f", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_comp", "code": "@[simp]\ntheorem mop_comp {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).mop = f.mop \u226b g.mop", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_id", "code": "@[simp]\ntheorem mop_id {X : C} : (\ud835\udfd9 X).mop = \ud835\udfd9 (mop X)", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unmop_comp", "code": "@[simp]\ntheorem unmop_comp {X Y Z : C\u1d39\u1d52\u1d56} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).unmop = f.unmop \u226b g.unmop", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unmop_id", "code": "@[simp]\ntheorem unmop_id {X : C\u1d39\u1d52\u1d56} : (\ud835\udfd9 X).unmop = \ud835\udfd9 (unmop X)", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unmop_id_mop", "code": "@[simp]\ntheorem unmop_id_mop {X : C} : (\ud835\udfd9 (mop X)).unmop = \ud835\udfd9 X", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_id_unmop", "code": "@[simp]\ntheorem mop_id_unmop {X : C\u1d39\u1d52\u1d56} : (\ud835\udfd9 (unmop X)).mop = \ud835\udfd9 X", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.mop", "code": "@[simps]\ndef mop (f : X \u2245 Y) : mop X \u2245 mop Y where\n  hom := f.hom.mop\n  inv := f.inv.mop\n  hom_inv_id := unmop_inj (by simp)\n  inv_hom_id := unmop_inj (by simp)", "start": [154, 1], "end": [162, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalCategoryOp", "code": "instance monoidalCategoryOp : MonoidalCategory C\u1d52\u1d56 where\n  tensorObj X Y := op (unop X \u2297 unop Y)\n  whiskerLeft X _ _ f := (X.unop \u25c1 f.unop).op\n  whiskerRight f X := (f.unop \u25b7 X.unop).op\n  tensorHom f g := (f.unop \u2297 g.unop).op\n  tensorHom_def f g := Quiver.Hom.unop_inj (tensorHom_def' _ _)\n  tensorUnit' := op (\ud835\udfd9_ C)\n  associator X Y Z := (\u03b1_ (unop X) (unop Y) (unop Z)).symm.op\n  leftUnitor X := (\u03bb_ (unop X)).symm.op\n  rightUnitor X := (\u03c1_ (unop X)).symm.op\n  associator_naturality f g h := Quiver.Hom.unop_inj (by simp)\n  leftUnitor_naturality f := Quiver.Hom.unop_inj (by simp)\n  rightUnitor_naturality f := Quiver.Hom.unop_inj (by simp)\n  triangle X Y := Quiver.Hom.unop_inj (by dsimp; coherence)\n  pentagon W X Y Z := Quiver.Hom.unop_inj (by dsimp; coherence)", "start": [171, 1], "end": [185, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_tensorObj", "code": "theorem op_tensorObj (X Y : C\u1d52\u1d56) : X \u2297 Y = op (unop X \u2297 unop Y)", "start": [188, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_tensorUnit", "code": "theorem op_tensorUnit : \ud835\udfd9_ C\u1d52\u1d56 = op (\ud835\udfd9_ C)", "start": [192, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalCategoryMop", "code": "instance monoidalCategoryMop : MonoidalCategory C\u1d39\u1d52\u1d56 where\n  tensorObj X Y := mop (unmop Y \u2297 unmop X)\n  whiskerLeft X _ _ f := (f.unmop \u25b7 X.unmop).mop\n  whiskerRight f X := (X.unmop \u25c1 f.unmop).mop\n  tensorHom f g := (g.unmop \u2297 f.unmop).mop\n  tensorHom_def f g := unmop_inj (tensorHom_def' _ _)\n  tensorUnit' := mop (\ud835\udfd9_ C)\n  associator X Y Z := (\u03b1_ (unmop Z) (unmop Y) (unmop X)).symm.mop\n  leftUnitor X := (\u03c1_ (unmop X)).mop\n  rightUnitor X := (\u03bb_ (unmop X)).mop\n  associator_naturality f g h := unmop_inj (by simp)\n  leftUnitor_naturality f := unmop_inj (by simp)\n  rightUnitor_naturality f := unmop_inj (by simp)\n  triangle X Y := unmop_inj (by simp) pentagon W X Y Z := unmop_inj (by dsimp; coherence)", "start": [196, 1], "end": [210, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_tensorObj", "code": "theorem mop_tensorObj (X Y : C\u1d39\u1d52\u1d56) : X \u2297 Y = mop (unmop Y \u2297 unmop X)", "start": [213, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mop_tensorUnit", "code": "theorem mop_tensorUnit : \ud835\udfd9_ C\u1d39\u1d52\u1d56 = mop (\ud835\udfd9_ C)", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/LinearPMap.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Algebra/Module/LinearPMap.lean", "Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearPMap.IsFormalAdjoint", "code": "def IsFormalAdjoint (T : E \u2192\u2097.[\ud835\udd5c] F) (S : F \u2192\u2097.[\ud835\udd5c] E) : Prop :=\n  \u2200 (x : T.domain) (y : S.domain), \u27eaT x, y\u27eb = \u27ea(x : E), S y\u27eb", "start": [68, 1], "end": [71, 61], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsFormalAdjoint.symm", "code": "@[symm]\nprotected theorem IsFormalAdjoint.symm (h : T.IsFormalAdjoint S) :\n    S.IsFormalAdjoint T", "start": [76, 1], "end": [79, 55], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointDomain", "code": "def adjointDomain : Submodule \ud835\udd5c F where\n  carrier := {y | Continuous ((inner\u209b\u2097 \ud835\udd5c y).comp T.toFun)}\n  zero_mem' := by\n    rw [Set.mem_setOf_eq, LinearMap.map_zero, LinearMap.zero_comp]\n    exact continuous_zero\n  add_mem' hx hy := by rw [Set.mem_setOf_eq, LinearMap.map_add] at *; exact hx.add hy\n  smul_mem' a x hx := by\n    rw [Set.mem_setOf_eq, LinearMap.map_smul\u209b\u2097] at *\n    exact hx.const_smul (conj a)", "start": [84, 1], "end": [96, 33], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointDomainMkClm", "code": "def adjointDomainMkClm (y : T.adjointDomain) : T.domain \u2192L[\ud835\udd5c] \ud835\udd5c :=\n  \u27e8(inner\u209b\u2097 \ud835\udd5c (y : F)).comp T.toFun, y.prop\u27e9", "start": [99, 1], "end": [102, 45], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointDomainMkClm_apply", "code": "theorem adjointDomainMkClm_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkClm T y x = \u27ea(y : F), T x\u27eb", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointDomainMkClmExtend", "code": "def adjointDomainMkClmExtend (y : T.adjointDomain) : E \u2192L[\ud835\udd5c] \ud835\udd5c :=\n  (T.adjointDomainMkClm y).extend (Submodule.subtypeL T.domain) hT.denseRange_val\n    uniformEmbedding_subtype_val.toUniformInducing", "start": [114, 1], "end": [117, 51], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointDomainMkClmExtend_apply", "code": "@[simp]\ntheorem adjointDomainMkClmExtend_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkClmExtend hT y (x : E) = \u27ea(y : F), T x\u27eb", "start": [120, 1], "end": [123, 42], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointAux", "code": "def adjointAux : T.adjointDomain \u2192\u2097[\ud835\udd5c] E where\n  toFun y := (InnerProductSpace.toDual \ud835\udd5c E).symm (adjointDomainMkClmExtend hT y)\n  map_add' x y :=\n    hT.eq_of_inner_left fun _ => by\n      simp only [inner_add_left, Submodule.coe_add, InnerProductSpace.toDual_symm_apply,\n        adjointDomainMkClmExtend_apply]\n  map_smul' _ _ :=\n    hT.eq_of_inner_left fun _ => by\n      simp only [inner_smul_left, Submodule.coe_smul_of_tower, RingHom.id_apply,\n        InnerProductSpace.toDual_symm_apply, adjointDomainMkClmExtend_apply]", "start": [128, 1], "end": [141, 77], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointAux_inner", "code": "theorem adjointAux_inner (y : T.adjointDomain) (x : T.domain) :\n    \u27eaadjointAux hT y, x\u27eb = \u27ea(y : F), T x\u27eb", "start": [144, 1], "end": [151, 38], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjointAux_unique", "code": "theorem adjointAux_unique (y : T.adjointDomain) {x\u2080 : E}\n    (hx\u2080 : \u2200 x : T.domain, \u27eax\u2080, x\u27eb = \u27ea(y : F), T x\u27eb) : adjointAux hT y = x\u2080", "start": [154, 1], "end": [156, 76], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjoint", "code": "def adjoint : F \u2192\u2097.[\ud835\udd5c] E where\n  domain := T.adjointDomain\n  toFun := if hT : Dense (T.domain : Set E) then adjointAux hT else 0", "start": [161, 1], "end": [164, 70], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_adjoint_domain_iff", "code": "theorem mem_adjoint_domain_iff (y : F) : y \u2208 T\u2020.domain \u2194 Continuous ((inner\u209b\u2097 \ud835\udd5c y).comp T.toFun)", "start": [169, 1], "end": [170, 10], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_adjoint_domain_of_exists", "code": "theorem mem_adjoint_domain_of_exists (y : F) (h : \u2203 w : E, \u2200 x : T.domain, \u27eaw, x\u27eb = \u27eay, T x\u27eb) :\n    y \u2208 T\u2020.domain", "start": [175, 1], "end": [182, 36], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjoint_apply_of_not_dense", "code": "theorem adjoint_apply_of_not_dense (hT : \u00acDense (T.domain : Set E)) (y : T\u2020.domain) : T\u2020 y = 0", "start": [185, 1], "end": [187, 63], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjoint_apply_of_dense", "code": "theorem adjoint_apply_of_dense (y : T\u2020.domain) : T\u2020 y = adjointAux hT y", "start": [190, 1], "end": [192, 44], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjoint_apply_eq", "code": "theorem adjoint_apply_eq (y : T\u2020.domain) {x\u2080 : E} (hx\u2080 : \u2200 x : T.domain, \u27eax\u2080, x\u27eb = \u27ea(y : F), T x\u27eb) :\n    T\u2020 y = x\u2080", "start": [195, 1], "end": [197, 66], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.adjoint_isFormalAdjoint", "code": "theorem adjoint_isFormalAdjoint : T\u2020.IsFormalAdjoint T", "start": [200, 1], "end": [202, 61], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsFormalAdjoint.le_adjoint", "code": "theorem IsFormalAdjoint.le_adjoint (h : T.IsFormalAdjoint S) : S \u2264 T\u2020", "start": [205, 1], "end": [212, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toPMap_adjoint_eq_adjoint_toPMap_of_dense", "code": "theorem toPMap_adjoint_eq_adjoint_toPMap_of_dense (hp : Dense (p : Set E)) :\n    (A.toPMap p).adjoint = A.adjoint.toPMap \u22a4", "start": [223, 1], "end": [234, 73], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instStar", "code": "instance instStar : Star (E \u2192\u2097.[\ud835\udd5c] E) where\n  star := fun A \u21a6 A.adjoint", "start": [245, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.isSelfAdjoint_def", "code": "theorem isSelfAdjoint_def : IsSelfAdjoint A \u2194 A\u2020 = A", "start": [250, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.dense_domain", "code": "theorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E)", "start": [252, 1], "end": [266, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sum/Interval.lean", "imports": ["Mathlib/Data/Sum/Order.lean", "Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.sumLift\u2082", "code": "@[simp]\ndef sumLift\u2082 : \u2200 (_ : Sum \u03b1\u2081 \u03b1\u2082) (_ : Sum \u03b2\u2081 \u03b2\u2082), Finset (Sum \u03b3\u2081 \u03b3\u2082)\n  | inl a, inl b => (f a b).map Embedding.inl\n  | inl _, inr _ => \u2205\n  | inr _, inl _ => \u2205\n  | inr a, inr b => (g a b).map Embedding.inr", "start": [32, 1], "end": [40, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sumLift\u2082", "code": "theorem mem_sumLift\u2082 :\n    c \u2208 sumLift\u2082 f g a b \u2194\n      (\u2203 a\u2081 b\u2081 c\u2081, a = inl a\u2081 \u2227 b = inl b\u2081 \u2227 c = inl c\u2081 \u2227 c\u2081 \u2208 f a\u2081 b\u2081) \u2228\n        \u2203 a\u2082 b\u2082 c\u2082, a = inr a\u2082 \u2227 b = inr b\u2082 \u2227 c = inr c\u2082 \u2227 c\u2082 \u2208 g a\u2082 b\u2082", "start": [45, 1], "end": [59, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.inl_mem_sumLift\u2082", "code": "theorem inl_mem_sumLift\u2082 {c\u2081 : \u03b3\u2081} :\n    inl c\u2081 \u2208 sumLift\u2082 f g a b \u2194 \u2203 a\u2081 b\u2081, a = inl a\u2081 \u2227 b = inl b\u2081 \u2227 c\u2081 \u2208 f a\u2081 b\u2081", "start": [62, 1], "end": [67, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inr_mem_sumLift\u2082", "code": "theorem inr_mem_sumLift\u2082 {c\u2082 : \u03b3\u2082} :\n    inr c\u2082 \u2208 sumLift\u2082 f g a b \u2194 \u2203 a\u2082 b\u2082, a = inr a\u2082 \u2227 b = inr b\u2082 \u2227 c\u2082 \u2208 g a\u2082 b\u2082", "start": [70, 1], "end": [75, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.sumLift\u2082_eq_empty", "code": "theorem sumLift\u2082_eq_empty :\n    sumLift\u2082 f g a b = \u2205 \u2194\n      (\u2200 a\u2081 b\u2081, a = inl a\u2081 \u2192 b = inl b\u2081 \u2192 f a\u2081 b\u2081 = \u2205) \u2227\n        \u2200 a\u2082 b\u2082, a = inr a\u2082 \u2192 b = inr b\u2082 \u2192 g a\u2082 b\u2082 = \u2205", "start": [78, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.sumLift\u2082_nonempty", "code": "theorem sumLift\u2082_nonempty :\n    (sumLift\u2082 f g a b).Nonempty \u2194\n      (\u2203 a\u2081 b\u2081, a = inl a\u2081 \u2227 b = inl b\u2081 \u2227 (f a\u2081 b\u2081).Nonempty) \u2228\n        \u2203 a\u2082 b\u2082, a = inr a\u2082 \u2227 b = inr b\u2082 \u2227 (g a\u2082 b\u2082).Nonempty", "start": [93, 1], "end": [97, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.sumLift\u2082_mono", "code": "theorem sumLift\u2082_mono (h\u2081 : \u2200 a b, f\u2081 a b \u2286 g\u2081 a b) (h\u2082 : \u2200 a b, f\u2082 a b \u2286 g\u2082 a b) :\n    \u2200 a b, sumLift\u2082 f\u2081 f\u2082 a b \u2286 sumLift\u2082 g\u2081 g\u2082 a b", "start": [100, 1], "end": [105, 46], "kind": "commanddeclaration"}, {"full_name": "Sum.Icc_inl_inl", "code": "theorem Icc_inl_inl : Icc (inl a\u2081 : Sum \u03b1 \u03b2) (inl a\u2082) = (Icc a\u2081 a\u2082).map Embedding.inl", "start": [138, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ico_inl_inl", "code": "theorem Ico_inl_inl : Ico (inl a\u2081 : Sum \u03b1 \u03b2) (inl a\u2082) = (Ico a\u2081 a\u2082).map Embedding.inl", "start": [142, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioc_inl_inl", "code": "theorem Ioc_inl_inl : Ioc (inl a\u2081 : Sum \u03b1 \u03b2) (inl a\u2082) = (Ioc a\u2081 a\u2082).map Embedding.inl", "start": [146, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioo_inl_inl", "code": "theorem Ioo_inl_inl : Ioo (inl a\u2081 : Sum \u03b1 \u03b2) (inl a\u2082) = (Ioo a\u2081 a\u2082).map Embedding.inl", "start": [150, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Icc_inl_inr", "code": "@[simp]\ntheorem Icc_inl_inr : Icc (inl a\u2081) (inr b\u2082) = \u2205", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ico_inl_inr", "code": "@[simp]\ntheorem Ico_inl_inr : Ico (inl a\u2081) (inr b\u2082) = \u2205", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioc_inl_inr", "code": "@[simp]\ntheorem Ioc_inl_inr : Ioc (inl a\u2081) (inr b\u2082) = \u2205", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioo_inl_inr", "code": "@[simp, nolint simpNF] theorem Ioo_inl_inr : Ioo (inl a\u2081) (inr b\u2082) = \u2205", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Icc_inr_inl", "code": "@[simp]\ntheorem Icc_inr_inl : Icc (inr b\u2081) (inl a\u2082) = \u2205", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ico_inr_inl", "code": "@[simp]\ntheorem Ico_inr_inl : Ico (inr b\u2081) (inl a\u2082) = \u2205", "start": [179, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioc_inr_inl", "code": "@[simp]\ntheorem Ioc_inr_inl : Ioc (inr b\u2081) (inl a\u2082) = \u2205", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioo_inr_inl", "code": "@[simp, nolint simpNF] theorem Ioo_inr_inl : Ioo (inr b\u2081) (inl a\u2082) = \u2205", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Icc_inr_inr", "code": "theorem Icc_inr_inr : Icc (inr b\u2081 : Sum \u03b1 \u03b2) (inr b\u2082) = (Icc b\u2081 b\u2082).map Embedding.inr", "start": [194, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ico_inr_inr", "code": "theorem Ico_inr_inr : Ico (inr b\u2081 : Sum \u03b1 \u03b2) (inr b\u2082) = (Ico b\u2081 b\u2082).map Embedding.inr", "start": [198, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioc_inr_inr", "code": "theorem Ioc_inr_inr : Ioc (inr b\u2081 : Sum \u03b1 \u03b2) (inr b\u2082) = (Ioc b\u2081 b\u2082).map Embedding.inr", "start": [202, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Ioo_inr_inr", "code": "theorem Ioo_inr_inr : Ioo (inr b\u2081 : Sum \u03b1 \u03b2) (inr b\u2082) = (Ioo b\u2081 b\u2082).map Embedding.inr", "start": [206, 1], "end": [207, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Surreal/Dyadic.lean", "imports": ["Mathlib/SetTheory/Game/Birthday.lean", "Mathlib/SetTheory/Surreal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Localization/Basic.lean", "Mathlib/Algebra/Algebra/Basic.lean"], "premises": [{"full_name": "SetTheory.PGame.powHalf", "code": "def powHalf : \u2115 \u2192 PGame\n  | 0 => 1\n  | n + 1 => \u27e8PUnit, PUnit, 0, fun _ => powHalf n\u27e9", "start": [36, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_zero", "code": "@[simp]\ntheorem powHalf_zero : powHalf 0 = 1", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_leftMoves", "code": "theorem powHalf_leftMoves (n) : (powHalf n).LeftMoves = PUnit", "start": [50, 1], "end": [50, 84], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_zero_rightMoves", "code": "theorem powHalf_zero_rightMoves : (powHalf 0).RightMoves = PEmpty", "start": [53, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_succ_rightMoves", "code": "theorem powHalf_succ_rightMoves (n) : (powHalf (n + 1)).RightMoves = PUnit", "start": [57, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_moveLeft", "code": "@[simp]\ntheorem powHalf_moveLeft (n i) : (powHalf n).moveLeft i = 0", "start": [61, 1], "end": [62, 94], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_succ_moveRight", "code": "@[simp]\ntheorem powHalf_succ_moveRight (n i) : (powHalf (n + 1)).moveRight i = powHalf n", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.uniquePowHalfLeftMoves", "code": "instance uniquePowHalfLeftMoves (n) : Unique (powHalf n).LeftMoves := by\n  cases n <;> exact PUnit.unique", "start": [70, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.isEmpty_powHalf_zero_rightMoves", "code": "instance isEmpty_powHalf_zero_rightMoves : IsEmpty (powHalf 0).RightMoves :=\n  inferInstanceAs (IsEmpty PEmpty)", "start": [74, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.uniquePowHalfSuccRightMoves", "code": "instance uniquePowHalfSuccRightMoves (n) : Unique (powHalf (n + 1)).RightMoves :=\n  PUnit.unique", "start": [78, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.birthday_half", "code": "@[simp]\ntheorem birthday_half : birthday (powHalf 1) = 2", "start": [82, 1], "end": [84, 68], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_powHalf", "code": "theorem numeric_powHalf (n) : (powHalf n).Numeric", "start": [87, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_succ_lt_powHalf", "code": "theorem powHalf_succ_lt_powHalf (n : \u2115) : powHalf (n + 1) < powHalf n", "start": [96, 1], "end": [97, 49], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_succ_le_powHalf", "code": "theorem powHalf_succ_le_powHalf (n : \u2115) : powHalf (n + 1) \u2264 powHalf n", "start": [100, 1], "end": [101, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_le_one", "code": "theorem powHalf_le_one (n : \u2115) : powHalf n \u2264 1", "start": [104, 1], "end": [107, 47], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_succ_lt_one", "code": "theorem powHalf_succ_lt_one (n : \u2115) : powHalf (n + 1) < 1", "start": [110, 1], "end": [111, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.powHalf_pos", "code": "theorem powHalf_pos (n : \u2115) : 0 < powHalf n", "start": [114, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.zero_le_powHalf", "code": "theorem zero_le_powHalf (n : \u2115) : 0 \u2264 powHalf n", "start": [118, 1], "end": [119, 21], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.add_powHalf_succ_self_eq_powHalf", "code": "theorem add_powHalf_succ_self_eq_powHalf (n) : powHalf (n + 1) + powHalf (n + 1) \u2248 powHalf n", "start": [122, 1], "end": [153, 79], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.half_add_half_equiv_one", "code": "theorem half_add_half_equiv_one : powHalf 1 + powHalf 1 \u2248 1", "start": [156, 1], "end": [157, 37], "kind": "commanddeclaration"}, {"full_name": "Surreal.powHalf", "code": "def powHalf (n : \u2115) : Surreal :=\n  \u27e6\u27e8PGame.powHalf n, PGame.numeric_powHalf n\u27e9\u27e7", "start": [168, 1], "end": [170, 47], "kind": "commanddeclaration"}, {"full_name": "Surreal.powHalf_zero", "code": "@[simp]\ntheorem powHalf_zero : powHalf 0 = 1", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Surreal.double_powHalf_succ_eq_powHalf", "code": "@[simp]\ntheorem double_powHalf_succ_eq_powHalf (n : \u2115) : 2 \u2022 powHalf n.succ = powHalf n", "start": [178, 1], "end": [180, 82], "kind": "commanddeclaration"}, {"full_name": "Surreal.nsmul_pow_two_powHalf", "code": "@[simp]\ntheorem nsmul_pow_two_powHalf (n : \u2115) : 2 ^ n \u2022 powHalf n = 1", "start": [183, 1], "end": [188, 16], "kind": "commanddeclaration"}, {"full_name": "Surreal.nsmul_pow_two_powHalf'", "code": "@[simp]\ntheorem nsmul_pow_two_powHalf' (n k : \u2115) : 2 ^ n \u2022 powHalf (n + k) = powHalf k", "start": [191, 1], "end": [198, 44], "kind": "commanddeclaration"}, {"full_name": "Surreal.zsmul_pow_two_powHalf", "code": "theorem zsmul_pow_two_powHalf (m : \u2124) (n k : \u2115) :\n    (m * 2 ^ n) \u2022 powHalf (n + k) = m \u2022 powHalf k", "start": [201, 1], "end": [206, 35], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadic_aux", "code": "theorem dyadic_aux {m\u2081 m\u2082 : \u2124} {y\u2081 y\u2082 : \u2115} (h\u2082 : m\u2081 * 2 ^ y\u2081 = m\u2082 * 2 ^ y\u2082) :\n    m\u2081 \u2022 powHalf y\u2082 = m\u2082 \u2022 powHalf y\u2081", "start": [209, 1], "end": [220, 30], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadicMap", "code": "def dyadicMap : Localization.Away (2 : \u2124) \u2192+ Surreal where\n  toFun x :=\n    (Localization.liftOn x fun x y => x \u2022 powHalf (Submonoid.log y)) <| by\n      intro m\u2081 m\u2082 n\u2081 n\u2082 h\u2081\n      obtain \u27e8\u27e8n\u2083, y\u2083, hn\u2083\u27e9, h\u2082\u27e9 := Localization.r_iff_exists.mp h\u2081\n      simp only [Subtype.coe_mk, mul_eq_mul_left_iff] at h\u2082\n      cases h\u2082\n      \u00b7 obtain \u27e8a\u2081, ha\u2081\u27e9 := n\u2081.prop\n        obtain \u27e8a\u2082, ha\u2082\u27e9 := n\u2082.prop\n        simp only at ha\u2081 ha\u2082 \u22a2\n        have hn\u2081 : n\u2081 = Submonoid.pow 2 a\u2081 := Subtype.ext ha\u2081.symm\n        have hn\u2082 : n\u2082 = Submonoid.pow 2 a\u2082 := Subtype.ext ha\u2082.symm\n        have h\u2082 : 1 < (2 : \u2124).natAbs := one_lt_two\n        rw [hn\u2081, hn\u2082, Submonoid.log_pow_int_eq_self h\u2082, Submonoid.log_pow_int_eq_self h\u2082]\n        apply dyadic_aux\n        rwa [ha\u2081, ha\u2082, mul_comm, mul_comm m\u2082]\n      \u00b7 have : (1 : \u2124) \u2264 2 ^ y\u2083 := by exact_mod_cast Nat.one_le_pow y\u2083 2 Nat.succ_pos'\n        linarith\n  map_zero' := Localization.liftOn_zero _ _\n  map_add' x y :=\n    Localization.induction_on\u2082 x y <| by\n      rintro \u27e8a, \u27e8b, \u27e8b', rfl\u27e9\u27e9\u27e9 \u27e8c, \u27e8d, \u27e8d', rfl\u27e9\u27e9\u27e9\n      have h\u2082 : 1 < (2 : \u2124).natAbs := one_lt_two\n      have hpow\u2082 := Submonoid.log_pow_int_eq_self h\u2082\n      simp_rw [Submonoid.pow_apply] at hpow\u2082\n      simp_rw [Localization.add_mk, Localization.liftOn_mk,\n        Submonoid.log_mul (Int.pow_right_injective h\u2082), hpow\u2082]\n      calc\n        (2 ^ b' * c + 2 ^ d' * a) \u2022 powHalf (b' + d') =\n            (c * 2 ^ b') \u2022 powHalf (b' + d') + (a * 2 ^ d') \u2022 powHalf (d' + b') := by\n          simp only [add_smul, mul_comm, add_comm]\n        _ = c \u2022 powHalf d' + a \u2022 powHalf b' := by simp only [zsmul_pow_two_powHalf]\n        _ = a \u2022 powHalf b' + c \u2022 powHalf d' := add_comm _ _", "start": [223, 1], "end": [256, 60], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadicMap_apply", "code": "@[simp]\ntheorem dyadicMap_apply (m : \u2124) (p : Submonoid.powers (2 : \u2124)) :\n    dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m p) =\n      m \u2022 powHalf (Submonoid.log p)", "start": [259, 1], "end": [263, 37], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadicMap_apply_pow", "code": "theorem dyadicMap_apply_pow (m : \u2124) (n : \u2115) :\n    dyadicMap (IsLocalization.mk' (Localization (Submonoid.powers 2)) m (Submonoid.pow 2 n)) =\n      m \u2022 powHalf n", "start": [267, 1], "end": [270, 68], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadicMap_apply_pow'", "code": "@[simp]\ntheorem dyadicMap_apply_pow' (m : \u2124) (n : \u2115) :\n    m \u2022 Surreal.powHalf (Submonoid.log (Submonoid.pow (2 : \u2124) n)) = m \u2022 powHalf n", "start": [273, 1], "end": [276, 51], "kind": "commanddeclaration"}, {"full_name": "Surreal.dyadic", "code": "def dyadic : Set Surreal :=\n  Set.range dyadicMap", "start": [278, 1], "end": [280, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Quot.lean", "imports": ["Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.quotientQPF", "code": "def quotientQPF (FG_abs_repr : \u2200 {\u03b1} (x : G \u03b1), FG_abs (FG_repr x) = x)\n    (FG_abs_map : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u27f9 \u03b2) (x : F \u03b1), FG_abs (f <$$> x) = f <$$> FG_abs x) : MvQPF G\n    where\n  P := q.P\n  abs p := FG_abs (abs p)\n  repr x := repr (FG_repr x)\n  abs_repr x := by dsimp; rw [abs_repr, FG_abs_repr]\n  abs_map f p := by dsimp; rw [abs_map, FG_abs_map]", "start": [39, 1], "end": [49, 52], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Quot1", "code": "def Quot1 (\u03b1 : TypeVec n) :=\n  Quot (@R \u03b1)", "start": [58, 1], "end": [60, 14], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Quot1.inhabited", "code": "instance Quot1.inhabited {\u03b1 : TypeVec n} [Inhabited <| F \u03b1] : Inhabited (Quot1 R \u03b1) :=\n  \u27e8Quot.mk _ default\u27e9", "start": [63, 1], "end": [64, 22], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Quot1.map", "code": "def Quot1.map \u2983\u03b1 \u03b2\u2984 (f : \u03b1 \u27f9 \u03b2) : Quot1.{u} R \u03b1 \u2192 Quot1.{u} R \u03b2 :=\n  Quot.lift (fun x : F \u03b1 => Quot.mk _ (f <$$> x : F \u03b2)) fun a b h => Quot.sound <| Hfunc a b _ h", "start": [71, 1], "end": [73, 97], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Quot1.mvFunctor", "code": "def Quot1.mvFunctor : MvFunctor (Quot1 R) where map := @Quot1.map _ _ R _ Hfunc", "start": [76, 1], "end": [77, 80], "kind": "commanddeclaration"}, {"full_name": "MvQPF.relQuot", "code": "noncomputable def relQuot : @MvQPF _ (Quot1 R) (MvQPF.Quot1.mvFunctor R Hfunc) :=\n  @quotientQPF n F _ q _ (MvQPF.Quot1.mvFunctor R Hfunc) (fun x => Quot.mk _ x)\n    Quot.out (fun _x => Quot.out_eq _) fun _f _x => rfl", "start": [80, 1], "end": [83, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/Augment.lean", "imports": ["Mathlib/Algebra/Homology/Single.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ChainComplex.truncate", "code": "@[simps]\ndef truncate [HasZeroMorphisms V] : ChainComplex V \u2115 \u2964 ChainComplex V \u2115 where\n  obj C :=\n    { X := fun i => C.X (i + 1)\n      d := fun i j => C.d (i + 1) (j + 1)\n      shape := fun i j w => C.shape _ _ <| by simpa }\n  map f := { f := fun i => f.f (i + 1) }", "start": [25, 1], "end": [34, 41], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.truncateTo", "code": "def truncateTo [HasZeroObject V] [HasZeroMorphisms V] (C : ChainComplex V \u2115) :\n    truncate.obj C \u27f6 (single\u2080 V).obj (C.X 0) :=\n  (toSingle\u2080Equiv (truncate.obj C) (C.X 0)).symm \u27e8C.d 1 0, by aesop\u27e9", "start": [37, 1], "end": [43, 69], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augment", "code": "def augment (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0) :\n    ChainComplex V \u2115 where\n  X | 0 => X\n    | i + 1 => C.X i\n  d | 1, 0 => f\n    | i + 1, j + 1 => C.d i j\n    | _, _ => 0\n  shape\n    | 1, 0, h => absurd rfl h\n    | i + 2, 0, _ => rfl\n    | 0, _, _ => rfl\n    | i + 1, j + 1, h => by simp only; exact C.shape i j (Nat.succ_ne_succ.1 h)\n  d_comp_d'\n    | _, _, 0, rfl, rfl => w\n    | _, _, k + 1, rfl, rfl => C.d_comp_d _ _ _", "start": [50, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augment_X_zero", "code": "@[simp]\ntheorem augment_X_zero (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0) :\n    (augment C f w).X 0 = X", "start": [70, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augment_X_succ", "code": "@[simp]\ntheorem augment_X_succ (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0)\n    (i : \u2115) : (augment C f w).X (i + 1) = C.X i", "start": [77, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augment_d_one_zero", "code": "@[simp]\ntheorem augment_d_one_zero (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0) :\n    (augment C f w).d 1 0 = f", "start": [84, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augment_d_succ_succ", "code": "@[simp]\ntheorem augment_d_succ_succ (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0)\n    (i j : \u2115) : (augment C f w).d (i + 1) (j + 1) = C.d i j", "start": [90, 1], "end": [93, 18], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.truncateAugment", "code": "def truncateAugment (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0) :\n    truncate.obj (augment C f w) \u2245 C where\n  hom := { f := fun i => \ud835\udfd9 _ }\n  inv :=\n    { f := fun i => \ud835\udfd9 _\n      comm' := fun i j => by\n        cases j <;>\n          \u00b7 dsimp\n            simp }\n  hom_inv_id := by\n    ext (_ | i) <;>\n      \u00b7 dsimp\n        simp\n  inv_hom_id := by\n    ext (_ | i) <;>\n      \u00b7 dsimp\n        simp", "start": [96, 1], "end": [115, 13], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.truncateAugment_hom_f", "code": "@[simp]\ntheorem truncateAugment_hom_f (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0)\n    (i : \u2115) : (truncateAugment C f w).hom.f i = \ud835\udfd9 (C.X i)", "start": [118, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.truncateAugment_inv_f", "code": "@[simp]\ntheorem truncateAugment_inv_f (C : ChainComplex V \u2115) {X : V} (f : C.X 0 \u27f6 X) (w : C.d 1 0 \u226b f = 0)\n    (i : \u2115) : (truncateAugment C f w).inv.f i = \ud835\udfd9 ((truncate.obj (augment C f w)).X i)", "start": [124, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.chainComplex_d_succ_succ_zero", "code": "@[simp]\ntheorem chainComplex_d_succ_succ_zero (C : ChainComplex V \u2115) (i : \u2115) : C.d (i + 2) 0 = 0", "start": [130, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augmentTruncate", "code": "def augmentTruncate (C : ChainComplex V \u2115) :\n    augment (truncate.obj C) (C.d 1 0) (C.d_comp_d _ _ _) \u2245 C where\n  hom :=\n    { f := fun i => by cases i <;> exact \ud835\udfd9 _\n      comm' := fun i j => by\n        match i with\n        | 0 | 1 | n+2 => cases' j with j <;> dsimp [augment, truncate] <;> simp }\n  inv :=\n    { f := fun i => by cases i <;> exact \ud835\udfd9 _\n      comm' := fun i j => by\n        match i with\n        | 0 | 1 | n+2 => cases' j with j <;> dsimp [augment, truncate] <;> simp }\n  hom_inv_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp\n  inv_hom_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp", "start": [136, 1], "end": [162, 13], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augmentTruncate_hom_f_zero", "code": "@[simp]\ntheorem augmentTruncate_hom_f_zero (C : ChainComplex V \u2115) :\n    (augmentTruncate C).hom.f 0 = \ud835\udfd9 (C.X 0)", "start": [165, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augmentTruncate_hom_f_succ", "code": "@[simp]\ntheorem augmentTruncate_hom_f_succ (C : ChainComplex V \u2115) (i : \u2115) :\n    (augmentTruncate C).hom.f (i + 1) = \ud835\udfd9 (C.X (i + 1))", "start": [171, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augmentTruncate_inv_f_zero", "code": "@[simp]\ntheorem augmentTruncate_inv_f_zero (C : ChainComplex V \u2115) :\n    (augmentTruncate C).inv.f 0 = \ud835\udfd9 (C.X 0)", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.augmentTruncate_inv_f_succ", "code": "@[simp]\ntheorem augmentTruncate_inv_f_succ (C : ChainComplex V \u2115) (i : \u2115) :\n    (augmentTruncate C).inv.f (i + 1) = \ud835\udfd9 (C.X (i + 1))", "start": [183, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "ChainComplex.toSingle\u2080AsComplex", "code": "def toSingle\u2080AsComplex [HasZeroObject V] (C : ChainComplex V \u2115) (X : V)\n    (f : C \u27f6 (single\u2080 V).obj X) : ChainComplex V \u2115 :=\n  let \u27e8f, w\u27e9 := toSingle\u2080Equiv C X f\n  augment C f w", "start": [189, 1], "end": [197, 16], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.truncate", "code": "@[simps]\ndef truncate [HasZeroMorphisms V] : CochainComplex V \u2115 \u2964 CochainComplex V \u2115 where\n  obj C :=\n    { X := fun i => C.X (i + 1)\n      d := fun i j => C.d (i + 1) (j + 1)\n      shape := fun i j w => by\n        apply C.shape\n        simpa }\n  map f := { f := fun i => f.f (i + 1) }", "start": [204, 1], "end": [215, 41], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.toTruncate", "code": "def toTruncate [HasZeroObject V] [HasZeroMorphisms V] (C : CochainComplex V \u2115) :\n    (single\u2080 V).obj (C.X 0) \u27f6 truncate.obj C :=\n  (fromSingle\u2080Equiv (truncate.obj C) (C.X 0)).symm \u27e8C.d 0 1, by aesop\u27e9", "start": [218, 1], "end": [224, 71], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augment", "code": "def augment (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) :\n    CochainComplex V \u2115 where\n  X | 0 => X\n    | i + 1 => C.X i\n  d | 0, 1 => f\n    | i + 1, j + 1 => C.d i j\n    | _, _ => 0\n  shape i j s := by\n    simp at s\n    rcases j with (_ | _ | j) <;> cases i <;> try simp\n    \u00b7 simp at s\n    \u00b7 rw [C.shape]\n      simp only [ComplexShape.up_Rel]\n      contrapose! s\n      rw [\u2190 s]\n      rfl\n  d_comp_d' i j k hij hjk := by\n    rcases k with (_ | _ | k) <;> rcases j with (_ | _ | j) <;> cases i <;> try simp\n    cases k\n    \u00b7 exact w\n    \u00b7 rw [C.shape, comp_zero]\n      simp only [Nat.zero_eq, ComplexShape.up_Rel, zero_add]\n      exact (Nat.one_lt_succ_succ _).ne", "start": [229, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augment_X_zero", "code": "@[simp]\ntheorem augment_X_zero (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) :\n    (augment C f w).X 0 = X", "start": [257, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augment_X_succ", "code": "@[simp]\ntheorem augment_X_succ (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0)\n    (i : \u2115) : (augment C f w).X (i + 1) = C.X i", "start": [264, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augment_d_zero_one", "code": "@[simp]\ntheorem augment_d_zero_one (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) :\n    (augment C f w).d 0 1 = f", "start": [271, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augment_d_succ_succ", "code": "@[simp]\ntheorem augment_d_succ_succ (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0)\n    (i j : \u2115) : (augment C f w).d (i + 1) (j + 1) = C.d i j", "start": [277, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.truncateAugment", "code": "def truncateAugment (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0) (w : f \u226b C.d 0 1 = 0) :\n    truncate.obj (augment C f w) \u2245 C where\n  hom := { f := fun i => \ud835\udfd9 _ }\n  inv :=\n    { f := fun i => \ud835\udfd9 _\n      comm' := fun i j => by\n        cases j <;>\n          \u00b7 dsimp\n            simp }\n  hom_inv_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp\n  inv_hom_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp", "start": [283, 1], "end": [304, 13], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.truncateAugment_hom_f", "code": "@[simp]\ntheorem truncateAugment_hom_f (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0)\n    (w : f \u226b C.d 0 1 = 0) (i : \u2115) : (truncateAugment C f w).hom.f i = \ud835\udfd9 (C.X i)", "start": [307, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.truncateAugment_inv_f", "code": "@[simp]\ntheorem truncateAugment_inv_f (C : CochainComplex V \u2115) {X : V} (f : X \u27f6 C.X 0)\n    (w : f \u226b C.d 0 1 = 0) (i : \u2115) :\n    (truncateAugment C f w).inv.f i = \ud835\udfd9 ((truncate.obj (augment C f w)).X i)", "start": [313, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.cochainComplex_d_succ_succ_zero", "code": "@[simp]\ntheorem cochainComplex_d_succ_succ_zero (C : CochainComplex V \u2115) (i : \u2115) : C.d 0 (i + 2) = 0", "start": [320, 1], "end": [324, 36], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augmentTruncate", "code": "def augmentTruncate (C : CochainComplex V \u2115) :\n    augment (truncate.obj C) (C.d 0 1) (C.d_comp_d _ _ _) \u2245 C where\n  hom :=\n    { f := fun i => by cases i <;> exact \ud835\udfd9 _\n      comm' := fun i j => by\n        rcases j with (_ | _ | j) <;> cases i <;>\n          \u00b7 dsimp\n            aesop }\n  inv :=\n    { f := fun i => by cases i <;> exact \ud835\udfd9 _\n      comm' := fun i j => by\n        rcases j with (_ | _ | j) <;> cases' i with i <;>\n          \u00b7 dsimp\n            aesop }\n  hom_inv_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp\n  inv_hom_id := by\n    ext i\n    cases i <;>\n      \u00b7 dsimp\n        simp", "start": [327, 1], "end": [355, 13], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augmentTruncate_hom_f_zero", "code": "@[simp]\ntheorem augmentTruncate_hom_f_zero (C : CochainComplex V \u2115) :\n    (augmentTruncate C).hom.f 0 = \ud835\udfd9 (C.X 0)", "start": [358, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augmentTruncate_hom_f_succ", "code": "@[simp]\ntheorem augmentTruncate_hom_f_succ (C : CochainComplex V \u2115) (i : \u2115) :\n    (augmentTruncate C).hom.f (i + 1) = \ud835\udfd9 (C.X (i + 1))", "start": [364, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augmentTruncate_inv_f_zero", "code": "@[simp]\ntheorem augmentTruncate_inv_f_zero (C : CochainComplex V \u2115) :\n    (augmentTruncate C).inv.f 0 = \ud835\udfd9 (C.X 0)", "start": [370, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.augmentTruncate_inv_f_succ", "code": "@[simp]\ntheorem augmentTruncate_inv_f_succ (C : CochainComplex V \u2115) (i : \u2115) :\n    (augmentTruncate C).inv.f (i + 1) = \ud835\udfd9 (C.X (i + 1))", "start": [376, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "CochainComplex.fromSingle\u2080AsComplex", "code": "def fromSingle\u2080AsComplex [HasZeroObject V] (C : CochainComplex V \u2115) (X : V)\n    (f : (single\u2080 V).obj X \u27f6 C) : CochainComplex V \u2115 :=\n  let \u27e8f, w\u27e9 := fromSingle\u2080Equiv C X f\n  augment C f w", "start": [382, 1], "end": [390, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/Compare.lean", "imports": ["Mathlib/NumberTheory/Padics/RingHoms.lean", "Mathlib/RingTheory/WittVector/Truncated.lean", "Mathlib/RingTheory/WittVector/Identities.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TruncatedWittVector.eq_of_le_of_cast_pow_eq_zero", "code": "theorem eq_of_le_of_cast_pow_eq_zero [CharP R p] (i : \u2115) (hin : i \u2264 n)\n    (hpi : (p : TruncatedWittVector p n R) ^ i = 0) : i = n", "start": [43, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.card_zmod", "code": "theorem card_zmod : Fintype.card (TruncatedWittVector p n (ZMod p)) = p ^ n", "start": [60, 1], "end": [61, 23], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.charP_zmod", "code": "theorem charP_zmod : CharP (TruncatedWittVector p n (ZMod p)) (p ^ n)", "start": [64, 1], "end": [65, 97], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.zmodEquivTrunc", "code": "def zmodEquivTrunc : ZMod (p ^ n) \u2243+* TruncatedWittVector p n (ZMod p) :=\n  ZMod.ringEquiv (TruncatedWittVector p n (ZMod p)) (card_zmod _ _)", "start": [70, 1], "end": [76, 68], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.zmodEquivTrunc_apply", "code": "theorem zmodEquivTrunc_apply {x : ZMod (p ^ n)} :\n    zmodEquivTrunc p n x = ZMod.castHom (by rfl) (TruncatedWittVector p n (ZMod p)) x", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.commutes", "code": "theorem commutes {m : \u2115} (hm : n \u2264 m) :\n    (truncate hm).comp (zmodEquivTrunc p m).toRingHom =\n      (zmodEquivTrunc p n).toRingHom.comp (ZMod.castHom (pow_dvd_pow p hm) _)", "start": [84, 1], "end": [99, 23], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.commutes'", "code": "theorem commutes' {m : \u2115} (hm : n \u2264 m) (x : ZMod (p ^ m)) :\n    truncate hm (zmodEquivTrunc p m x) = zmodEquivTrunc p n (ZMod.castHom (pow_dvd_pow p hm) _ x)", "start": [102, 1], "end": [104, 92], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.commutes_symm'", "code": "theorem commutes_symm' {m : \u2115} (hm : n \u2264 m) (x : TruncatedWittVector p m (ZMod p)) :\n    (zmodEquivTrunc p n).symm (truncate hm x) =\n      ZMod.castHom (pow_dvd_pow p hm) _ ((zmodEquivTrunc p m).symm x)", "start": [107, 1], "end": [112, 7], "kind": "commanddeclaration"}, {"full_name": "TruncatedWittVector.commutes_symm", "code": "theorem commutes_symm {m : \u2115} (hm : n \u2264 m) :\n    (zmodEquivTrunc p n).symm.toRingHom.comp (truncate hm) =\n      (ZMod.castHom (pow_dvd_pow p hm) _).comp (zmodEquivTrunc p m).symm.toRingHom", "start": [115, 1], "end": [130, 31], "kind": "commanddeclaration"}, {"full_name": "WittVector.toZModPow", "code": "def toZModPow (k : \u2115) : \ud835\udd4e (ZMod p) \u2192+* ZMod (p ^ k) :=\n  (zmodEquivTrunc p k).symm.toRingHom.comp (truncate k)", "start": [143, 1], "end": [146, 56], "kind": "commanddeclaration"}, {"full_name": "WittVector.toZModPow_compat", "code": "theorem toZModPow_compat (m n : \u2115) (h : m \u2264 n) :\n    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (toZModPow p n) = toZModPow p m", "start": [149, 1], "end": [157, 65], "kind": "commanddeclaration"}, {"full_name": "WittVector.toPadicInt", "code": "def toPadicInt : \ud835\udd4e (ZMod p) \u2192+* \u2124_[p] :=\n  PadicInt.lift <| toZModPow_compat p", "start": [160, 1], "end": [164, 38], "kind": "commanddeclaration"}, {"full_name": "WittVector.zmodEquivTrunc_compat", "code": "theorem zmodEquivTrunc_compat (k\u2081 k\u2082 : \u2115) (hk : k\u2081 \u2264 k\u2082) :\n    (TruncatedWittVector.truncate hk).comp\n        ((zmodEquivTrunc p k\u2082).toRingHom.comp (PadicInt.toZModPow k\u2082)) =\n      (zmodEquivTrunc p k\u2081).toRingHom.comp (PadicInt.toZModPow k\u2081)", "start": [167, 1], "end": [172, 46], "kind": "commanddeclaration"}, {"full_name": "WittVector.fromPadicInt", "code": "def fromPadicInt : \u2124_[p] \u2192+* \ud835\udd4e (ZMod p) :=\n  (WittVector.lift fun k => (zmodEquivTrunc p k).toRingHom.comp (PadicInt.toZModPow k)) <|\n    zmodEquivTrunc_compat _", "start": [175, 1], "end": [180, 28], "kind": "commanddeclaration"}, {"full_name": "WittVector.toPadicInt_comp_fromPadicInt", "code": "theorem toPadicInt_comp_fromPadicInt : (toPadicInt p).comp (fromPadicInt p) = RingHom.id \u2124_[p]", "start": [183, 1], "end": [189, 71], "kind": "commanddeclaration"}, {"full_name": "WittVector.toPadicInt_comp_fromPadicInt_ext", "code": "theorem toPadicInt_comp_fromPadicInt_ext (x) :\n    (toPadicInt p).comp (fromPadicInt p) x = RingHom.id \u2124_[p] x", "start": [192, 1], "end": [194, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.fromPadicInt_comp_toPadicInt", "code": "theorem fromPadicInt_comp_toPadicInt :\n    (fromPadicInt p).comp (toPadicInt p) = RingHom.id (\ud835\udd4e (ZMod p))", "start": [197, 1], "end": [203, 65], "kind": "commanddeclaration"}, {"full_name": "WittVector.fromPadicInt_comp_toPadicInt_ext", "code": "theorem fromPadicInt_comp_toPadicInt_ext (x) :\n    (fromPadicInt p).comp (toPadicInt p) x = RingHom.id (\ud835\udd4e (ZMod p)) x", "start": [206, 1], "end": [208, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.equiv", "code": "def equiv : \ud835\udd4e (ZMod p) \u2243+* \u2124_[p] where\n  toFun := toPadicInt p\n  invFun := fromPadicInt p\n  left_inv := fromPadicInt_comp_toPadicInt_ext _\n  right_inv := toPadicInt_comp_fromPadicInt_ext _\n  map_mul' := RingHom.map_mul _\n  map_add' := RingHom.map_add _", "start": [211, 1], "end": [220, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/EvenOddRec.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "Mathlib/Init/Data/Nat/Bitwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.evenOddRec", "code": "@[elab_as_elim]\ndef evenOddRec {P : \u2115 \u2192 Sort*} (h0 : P 0) (h_even : \u2200 (n) (_ : P n), P (2 * n))\n    (h_odd : \u2200 (n) (_ : P n), P (2 * n + 1)) (n : \u2115) : P n :=\n  binaryRec h0 (fun\n    | false, i, hi => (bit0_val i \u25b8 h_even i hi : P (bit0 i))\n    | true, i, hi => (bit1_val i \u25b8 h_odd i hi : P (bit1 i))) n", "start": [18, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.evenOddRec_zero", "code": "@[simp]\ntheorem evenOddRec_zero (P : \u2115 \u2192 Sort*) (h0 : P 0) (h_even : \u2200 i, P i \u2192 P (2 * i))\n    (h_odd : \u2200 i, P i \u2192 P (2 * i + 1)) : @evenOddRec _ h0 h_even h_odd 0 = h0", "start": [31, 1], "end": [34, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.evenOddRec_even", "code": "@[simp]\ntheorem evenOddRec_even (n : \u2115) (P : \u2115 \u2192 Sort*) (h0 : P 0) (h_even : \u2200 i, P i \u2192 P (2 * i))\n    (h_odd : \u2200 i, P i \u2192 P (2 * i + 1)) (H : h_even 0 h0 = h0) :\n    @evenOddRec _ h0 h_even h_odd (2 * n) = h_even n (evenOddRec h0 h_even h_odd n)", "start": [37, 1], "end": [44, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.evenOddRec_odd", "code": "@[simp]\ntheorem evenOddRec_odd (n : \u2115) (P : \u2115 \u2192 Sort*) (h0 : P 0) (h_even : \u2200 i, P i \u2192 P (2 * i))\n    (h_odd : \u2200 i, P i \u2192 P (2 * i + 1)) (H : h_even 0 h0 = h0) :\n    @evenOddRec _ h0 h_even h_odd (2 * n + 1) = h_odd n (evenOddRec h0 h_even h_odd n)", "start": [47, 1], "end": [54, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Localization.lean", "imports": ["Mathlib/RingTheory/Localization/Basic.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Localization.ringTopology", "code": "def Localization.ringTopology : RingTopology (Localization M) :=\n  RingTopology.coinduced (Localization.monoidOf M).toFun", "start": [29, 1], "end": [32, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Rademacher.lean", "imports": ["Mathlib/Analysis/BoundedVariation.lean", "Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean", "Mathlib/Analysis/Calculus/LineDeriv/Measurable.lean", "Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Group/Integral.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean"], "premises": [{"full_name": "LipschitzWith.ae_lineDifferentiableAt", "code": "theorem ae_lineDifferentiableAt (hf : LipschitzWith C f) (v : E) :\n    \u2200\u1d50 p \u2202\u03bc, LineDifferentiableAt \u211d f p v", "start": [63, 1], "end": [77, 77], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mem\u2112p_lineDeriv", "code": "theorem mem\u2112p_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    Mem\u2112p (fun x \u21a6 lineDeriv \u211d f x v) \u221e \u03bc", "start": [79, 1], "end": [82, 84], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.locallyIntegrable_lineDeriv", "code": "theorem locallyIntegrable_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    LocallyIntegrable (fun x \u21a6 lineDeriv \u211d f x v) \u03bc", "start": [84, 1], "end": [86, 50], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul", "code": "theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul\n    (hf : LipschitzWith C f) (hg : Integrable g \u03bc) (v : E) :\n    Tendsto (fun (t : \u211d) \u21a6 \u222b x, (t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) * g x \u2202\u03bc) (\ud835\udcdd[>] 0)\n      (\ud835\udcdd (\u222b x, lineDeriv \u211d f x v * g x \u2202\u03bc))", "start": [97, 1], "end": [117, 76], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'", "code": "theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'\n    (hf : LipschitzWith C f) (h'f : HasCompactSupport f) (hg : Continuous g) (v : E) :\n    Tendsto (fun (t : \u211d) \u21a6 \u222b x, (t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) * g x \u2202\u03bc) (\ud835\udcdd[>] 0)\n      (\ud835\udcdd (\u222b x, lineDeriv \u211d f x v * g x \u2202\u03bc))", "start": [119, 1], "end": [160, 76], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.integral_lineDeriv_mul_eq", "code": "theorem integral_lineDeriv_mul_eq\n    (hf : LipschitzWith C f) (hg : LipschitzWith D g) (h'g : HasCompactSupport g) (v : E) :\n    \u222b x, lineDeriv \u211d f x v * g x \u2202\u03bc = \u222b x, lineDeriv \u211d g x (-v) * f x \u2202\u03bc", "start": [162, 1], "end": [195, 89], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ae_lineDeriv_sum_eq", "code": "theorem ae_lineDeriv_sum_eq\n    (hf : LipschitzWith C f) {\u03b9 : Type*} (s : Finset \u03b9) (a : \u03b9 \u2192 \u211d) (v : \u03b9 \u2192 E) :\n    \u2200\u1d50 x \u2202\u03bc, lineDeriv \u211d f x (\u2211 i in s, a i \u2022 v i) = \u2211 i in s, a i \u2022 lineDeriv \u211d f x (v i)", "start": [197, 1], "end": [233, 54], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ae_exists_fderiv_of_countable", "code": "theorem ae_exists_fderiv_of_countable\n    (hf : LipschitzWith C f) {s : Set E} (hs : s.Countable) :\n    \u2200\u1d50 x \u2202\u03bc, \u2203 (L : E \u2192L[\u211d] \u211d), \u2200 v \u2208 s, HasLineDerivAt \u211d f (L v) x v", "start": [239, 1], "end": [253, 44], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.hasFderivAt_of_hasLineDerivAt_of_closure", "code": "theorem hasFderivAt_of_hasLineDerivAt_of_closure {f : E \u2192 F}\n    (hf : LipschitzWith C f) {s : Set E} (hs : sphere 0 1 \u2286 closure s)\n    {L : E \u2192L[\u211d] F} {x : E} (hL : \u2200 v \u2208 s, HasLineDerivAt \u211d f (L v) x v) :\n    HasFDerivAt f L x", "start": [255, 1], "end": [307, 34], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ae_differentiableAt_of_real", "code": "theorem ae_differentiableAt_of_real (hf : LipschitzWith C f) :\n    \u2200\u1d50 x \u2202\u03bc, DifferentiableAt \u211d f x", "start": [309, 1], "end": [320, 77], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt_of_mem_of_real", "code": "theorem ae_differentiableWithinAt_of_mem_of_real (hf : LipschitzOnWith C f s) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [328, 1], "end": [336, 51], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt_of_mem_pi", "code": "theorem ae_differentiableWithinAt_of_mem_pi\n    {\u03b9 : Type*} [Fintype \u03b9] {f : E \u2192 \u03b9 \u2192 \u211d} {s : Set E}\n    (hf : LipschitzOnWith C f s) : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [338, 1], "end": [350, 54], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt_of_mem", "code": "theorem ae_differentiableWithinAt_of_mem {f : E \u2192 F} (hf : LipschitzOnWith C f s) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [352, 1], "end": [364, 44], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt", "code": "theorem ae_differentiableWithinAt {f : E \u2192 F} (hf : LipschitzOnWith C f s)\n    (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202(\u03bc.restrict s), DifferentiableWithinAt \u211d f s x", "start": [366, 1], "end": [372, 44], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ae_differentiableAt", "code": "theorem LipschitzWith.ae_differentiableAt {f : E \u2192 F} (h : LipschitzWith C f) :\n    \u2200\u1d50 x \u2202\u03bc, DifferentiableAt \u211d f x", "start": [376, 1], "end": [381, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Padics/Harmonic.lean", "imports": ["Mathlib/NumberTheory/Padics/PadicIntegers.lean", "Mathlib/Data/Int/Log.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "harmonic", "code": "def harmonic : \u2115 \u2192 \u211a := fun n => \u2211 i in Finset.range n, (\u2191(i + 1))\u207b\u00b9", "start": [23, 1], "end": [24, 69], "kind": "commanddeclaration"}, {"full_name": "harmonic_zero", "code": "@[simp]\nlemma harmonic_zero : harmonic 0 = 0 :=\n  rfl", "start": [26, 1], "end": [28, 6], "kind": "mathlibtacticlemma"}, {"full_name": "harmonic_succ", "code": "@[simp]\nlemma harmonic_succ (n : \u2115) : harmonic (n + 1) = harmonic n + (\u2191(n + 1))\u207b\u00b9 := by\n  apply Finset.sum_range_succ", "start": [30, 1], "end": [32, 30], "kind": "mathlibtacticlemma"}, {"full_name": "harmonic_pos", "code": "lemma harmonic_pos {n : \u2115} (Hn : n \u2260 0) : 0 < harmonic n :=\n  Finset.sum_pos (fun _ _ => inv_pos.mpr (by norm_cast; linarith))\n  (by rwa [Finset.nonempty_range_iff])", "start": [34, 1], "end": [36, 39], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat_two_harmonic", "code": "theorem padicValRat_two_harmonic (n : \u2115) : padicValRat 2 (harmonic n) = -Nat.log 2 n", "start": [38, 1], "end": [52, 53], "kind": "commanddeclaration"}, {"full_name": "padicNorm_two_harmonic", "code": "lemma padicNorm_two_harmonic {n : \u2115} (hn : n \u2260 0) :\n    \u2016(harmonic n : \u211a_[2])\u2016 = 2 ^ (Nat.log 2 n) := by\n  rw [padicNormE.eq_padicNorm, padicNorm.eq_zpow_of_nonzero (harmonic_pos hn).ne',\n    padicValRat_two_harmonic, neg_neg, zpow_coe_nat, Rat.cast_pow, Rat.cast_coe_nat, Nat.cast_ofNat]", "start": [54, 1], "end": [58, 101], "kind": "mathlibtacticlemma"}, {"full_name": "harmonic_not_int", "code": "theorem harmonic_not_int {n : \u2115} (h : 2 \u2264 n) : \u00ac (harmonic n).isInt", "start": [60, 1], "end": [65, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector/MapLemmas.lean", "imports": ["Mathlib/Data/Vector/Snoc.lean", "Mathlib/Data/Vector/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector.mapAccumr_mapAccumr", "code": "@[simp]\ntheorem mapAccumr_mapAccumr :\n    mapAccumr f\u2081 (mapAccumr f\u2082 xs s\u2082).snd s\u2081\n    = let m := (mapAccumr (fun x s =>\n        let r\u2082 := f\u2082 x s.snd\n        let r\u2081 := f\u2081 r\u2082.snd s.fst\n        ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n      ) xs (s\u2081, s\u2082))\n      (m.fst.fst, m.snd)", "start": [26, 1], "end": [35, 75], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_map", "code": "@[simp]\ntheorem mapAccumr_map (f\u2082 : \u03b1 \u2192 \u03b2) :\n    (mapAccumr f\u2081 (map f\u2082 xs) s) = (mapAccumr (fun x s => f\u2081 (f\u2082 x) s) xs s)", "start": [37, 1], "end": [40, 71], "kind": "commanddeclaration"}, {"full_name": "Vector.map_mapAccumr", "code": "@[simp]\ntheorem map_mapAccumr (f\u2081 : \u03b2 \u2192 \u03b3) :\n    (map f\u2081 (mapAccumr f\u2082 xs s).snd) = (mapAccumr (fun x s =>\n        let r := (f\u2082 x s); (r.fst, f\u2081 r.snd)\n      ) xs s).snd", "start": [42, 1], "end": [47, 71], "kind": "commanddeclaration"}, {"full_name": "Vector.map_map", "code": "@[simp]\ntheorem map_map (f\u2081 : \u03b2 \u2192 \u03b3) (f\u2082 : \u03b1 \u2192 \u03b2) :\n    map f\u2081 (map f\u2082 xs) = map (fun x => f\u2081 <| f\u2082 x) xs", "start": [49, 1], "end": [52, 53], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr_left", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr_left (f\u2081 : \u03b3 \u2192 \u03b2 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b6) (f\u2082 : \u03b1 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 (mapAccumr f\u2082 xs s\u2082).snd ys s\u2081)\n    = let m := (mapAccumr\u2082 (fun x y s =>\n          let r\u2082 := f\u2082 x s.snd\n          let r\u2081 := f\u2081 r\u2082.snd y s.fst\n          ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n        ) xs ys (s\u2081, s\u2082))\n      (m.fst.fst, m.snd)", "start": [59, 1], "end": [68, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_map_left", "code": "@[simp]\ntheorem map\u2082_map_left (f\u2081 : \u03b3 \u2192 \u03b2 \u2192 \u03b6) (f\u2082 : \u03b1 \u2192 \u03b3) :\n    map\u2082 f\u2081 (map f\u2082 xs) ys = map\u2082 (fun x y => f\u2081 (f\u2082 x) y) xs ys", "start": [70, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr_right", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr_right (f\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b6) (f\u2082 : \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 xs (mapAccumr f\u2082 ys s\u2082).snd s\u2081)\n    = let m := (mapAccumr\u2082 (fun x y s =>\n          let r\u2082 := f\u2082 y s.snd\n          let r\u2081 := f\u2081 x r\u2082.snd s.fst\n          ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n        ) xs ys (s\u2081, s\u2082))\n      (m.fst.fst, m.snd)", "start": [75, 1], "end": [84, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_map_right", "code": "@[simp]\ntheorem map\u2082_map_right (f\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b6) (f\u2082 : \u03b2 \u2192 \u03b3) :\n    map\u2082 f\u2081 xs (map f\u2082 ys) = map\u2082 (fun x y => f\u2081 x (f\u2082 y)) xs ys", "start": [86, 1], "end": [89, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_mapAccumr\u2082", "code": "@[simp]\ntheorem mapAccumr_mapAccumr\u2082 (f\u2081 : \u03b3 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr f\u2081 (mapAccumr\u2082 f\u2082 xs ys s\u2082).snd s\u2081)\n    = let m := mapAccumr\u2082 (fun x y s =>\n          let r\u2082 := f\u2082 x y s.snd\n          let r\u2081 := f\u2081 r\u2082.snd s.fst\n          ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n        ) xs ys (s\u2081, s\u2082)\n      (m.fst.fst, m.snd)", "start": [91, 1], "end": [100, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.map_map\u2082", "code": "@[simp]\ntheorem map_map\u2082 (f\u2081 : \u03b3 \u2192 \u03b6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    map f\u2081 (map\u2082 f\u2082 xs ys) = map\u2082 (fun x y => f\u2081 <| f\u2082 x y) xs ys", "start": [102, 1], "end": [105, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr\u2082_left_left", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr\u2082_left_left (f\u2081 : \u03b3 \u2192 \u03b1 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03c6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 (mapAccumr\u2082 f\u2082 xs ys s\u2082).snd xs s\u2081)\n    = let m := mapAccumr\u2082 (fun x y (s\u2081, s\u2082) =>\n                let r\u2082 := f\u2082 x y s\u2082\n                let r\u2081 := f\u2081 r\u2082.snd x s\u2081\n                ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n              )\n            xs ys (s\u2081, s\u2082)\n    (m.fst.fst, m.snd)", "start": [107, 1], "end": [117, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr\u2082_left_right", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr\u2082_left_right\n    (f\u2081 : \u03b3 \u2192 \u03b2 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03c6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 (mapAccumr\u2082 f\u2082 xs ys s\u2082).snd ys s\u2081)\n    = let m := mapAccumr\u2082 (fun x y (s\u2081, s\u2082) =>\n                let r\u2082 := f\u2082 x y s\u2082\n                let r\u2081 := f\u2081 r\u2082.snd y s\u2081\n                ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n              )\n            xs ys (s\u2081, s\u2082)\n    (m.fst.fst, m.snd)", "start": [119, 1], "end": [130, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr\u2082_right_left", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr\u2082_right_left (f\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03c6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 xs (mapAccumr\u2082 f\u2082 xs ys s\u2082).snd s\u2081)\n    = let m := mapAccumr\u2082 (fun x y (s\u2081, s\u2082) =>\n                let r\u2082 := f\u2082 x y s\u2082\n                let r\u2081 := f\u2081 x r\u2082.snd s\u2081\n                ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n              )\n            xs ys (s\u2081, s\u2082)\n    (m.fst.fst, m.snd)", "start": [132, 1], "end": [142, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_mapAccumr\u2082_right_right", "code": "@[simp]\ntheorem mapAccumr\u2082_mapAccumr\u2082_right_right (f\u2081 : \u03b2 \u2192 \u03b3 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03c6) (f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3) :\n    (mapAccumr\u2082 f\u2081 ys (mapAccumr\u2082 f\u2082 xs ys s\u2082).snd s\u2081)\n    = let m := mapAccumr\u2082 (fun x y (s\u2081, s\u2082) =>\n                let r\u2082 := f\u2082 x y s\u2082\n                let r\u2081 := f\u2081 y r\u2082.snd s\u2081\n                ((r\u2081.fst, r\u2082.fst), r\u2081.snd)\n              )\n            xs ys (s\u2081, s\u2082)\n    (m.fst.fst, m.snd)", "start": [144, 1], "end": [154, 80], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_bisim", "code": "theorem mapAccumr_bisim {f\u2081 : \u03b1 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b2} {f\u2082 : \u03b1 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b2} {s\u2081 : \u03c3\u2081} {s\u2082 : \u03c3\u2082}\n    (R : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop) (h\u2080 : R s\u2081 s\u2082)\n    (hR : \u2200 {s q} a, R s q \u2192 R (f\u2081 a s).1 (f\u2082 a q).1 \u2227 (f\u2081 a s).2 = (f\u2082 a q).2) :\n    R (mapAccumr f\u2081 xs s\u2081).fst (mapAccumr f\u2082 xs s\u2082).fst\n    \u2227 (mapAccumr f\u2081 xs s\u2081).snd = (mapAccumr f\u2082 xs s\u2082).snd", "start": [173, 1], "end": [183, 12], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_bisim_tail", "code": "theorem mapAccumr_bisim_tail {f\u2081 : \u03b1 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b2} {f\u2082 : \u03b1 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b2} {s\u2081 : \u03c3\u2081} {s\u2082 : \u03c3\u2082}\n    (h : \u2203 R : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop, R s\u2081 s\u2082 \u2227\n      \u2200 {s q} a, R s q \u2192 R (f\u2081 a s).1 (f\u2082 a q).1 \u2227 (f\u2081 a s).2 = (f\u2082 a q).2) :\n    (mapAccumr f\u2081 xs s\u2081).snd = (mapAccumr f\u2082 xs s\u2082).snd", "start": [185, 1], "end": [190, 36], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_bisim", "code": "theorem mapAccumr\u2082_bisim {ys : Vector \u03b2 n} {f\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b3}\n    {f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3} {s\u2081 : \u03c3\u2081} {s\u2082 : \u03c3\u2082}\n    (R : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop) (h\u2080 : R s\u2081 s\u2082)\n    (hR :  \u2200 {s q} a b, R s q \u2192 R (f\u2081 a b s).1 (f\u2082 a b q).1 \u2227 (f\u2081 a b s).2 = (f\u2082 a b q).2) :\n    R (mapAccumr\u2082 f\u2081 xs ys s\u2081).1 (mapAccumr\u2082 f\u2082 xs ys s\u2082).1\n    \u2227 (mapAccumr\u2082 f\u2081 xs ys s\u2081).2 = (mapAccumr\u2082 f\u2082 xs ys s\u2082).2", "start": [192, 1], "end": [203, 12], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_bisim_tail", "code": "theorem mapAccumr\u2082_bisim_tail {ys : Vector \u03b2 n} {f\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2081 \u2192 \u03c3\u2081 \u00d7 \u03b3}\n    {f\u2082 : \u03b1 \u2192 \u03b2 \u2192 \u03c3\u2082 \u2192 \u03c3\u2082 \u00d7 \u03b3} {s\u2081 : \u03c3\u2081} {s\u2082 : \u03c3\u2082}\n    (h : \u2203 R : \u03c3\u2081 \u2192 \u03c3\u2082 \u2192 Prop, R s\u2081 s\u2082 \u2227\n      \u2200 {s q} a b, R s q \u2192 R (f\u2081 a b s).1 (f\u2082 a b q).1 \u2227 (f\u2081 a b s).2 = (f\u2082 a b q).2) :\n    (mapAccumr\u2082 f\u2081 xs ys s\u2081).2 = (mapAccumr\u2082 f\u2082 xs ys s\u2082).2", "start": [205, 1], "end": [211, 37], "kind": "commanddeclaration"}, {"full_name": "Vector.map_eq_mapAccumr", "code": "protected theorem map_eq_mapAccumr :\n    map f xs = (mapAccumr (fun x (_ : Unit) \u21a6 ((), f x)) xs ()).snd", "start": [224, 1], "end": [227, 56], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_eq_map", "code": "theorem mapAccumr_eq_map {f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2} {s\u2080 : \u03c3} (S : Set \u03c3) (h\u2080 : s\u2080 \u2208 S)\n    (closure : \u2200 a s, s \u2208 S \u2192 (f a s).1 \u2208 S)\n    (out : \u2200 a s s', s \u2208 S \u2192 s' \u2208 S \u2192 (f a s).2 = (f a s').2) :\n    (mapAccumr f xs s\u2080).snd = map (f \u00b7 s\u2080 |>.snd) xs", "start": [229, 1], "end": [241, 58], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_eq_mapAccumr\u2082", "code": "protected theorem map\u2082_eq_mapAccumr\u2082 :\n    map\u2082 f xs ys = (mapAccumr\u2082 (fun x y (_ : Unit) \u21a6 ((), f x y)) xs ys ()).snd", "start": [243, 1], "end": [245, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_eq_map\u2082", "code": "theorem mapAccumr\u2082_eq_map\u2082 {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3} {s\u2080 : \u03c3} (S : Set \u03c3) (h\u2080 : s\u2080 \u2208 S)\n    (closure : \u2200 a b s, s \u2208 S \u2192 (f a b s).1 \u2208 S)\n    (out : \u2200 a b s s', s \u2208 S \u2192 s' \u2208 S \u2192 (f a b s).2 = (f a b s').2) :\n    (mapAccumr\u2082 f xs ys s\u2080).snd = map\u2082 (f \u00b7 \u00b7 s\u2080 |>.snd) xs ys", "start": [247, 1], "end": [259, 64], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_eq_map_of_constant_state", "code": "@[simp]\ntheorem mapAccumr_eq_map_of_constant_state (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) (s : \u03c3) (h : \u2200 a, (f a s).fst = s) :\n    mapAccumr f xs s = (s, (map (fun x => (f x s).snd) xs))", "start": [261, 1], "end": [269, 49], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_eq_map\u2082_of_constant_state", "code": "@[simp]\ntheorem mapAccumr\u2082_eq_map\u2082_of_constant_state (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3) (s : \u03c3)\n    (h : \u2200 a b, (f a b s).fst = s) :\n    mapAccumr\u2082 f xs ys s = (s, (map\u2082 (fun x y => (f x y s).snd) xs ys))", "start": [271, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_eq_map_of_unused_state", "code": "@[simp]\ntheorem mapAccumr_eq_map_of_unused_state (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) (s : \u03c3)\n    (h : \u2200 a s s', (f a s).snd = (f a s').snd) :\n    (mapAccumr f xs s).snd = (map (fun x => (f x s).snd) xs)", "start": [281, 1], "end": [289, 87], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_eq_map\u2082_of_unused_state", "code": "@[simp]\ntheorem mapAccumr\u2082_eq_map\u2082_of_unused_state (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3) (s : \u03c3)\n    (h : \u2200 a b s s', (f a b s).snd = (f a b s').snd) :\n    (mapAccumr\u2082 f xs ys s).snd = (map\u2082 (fun x y => (f x y s).snd) xs ys)", "start": [292, 1], "end": [300, 95], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_redundant_pair", "code": "@[simp]\ntheorem mapAccumr_redundant_pair (f : \u03b1 \u2192 (\u03c3 \u00d7 \u03c3) \u2192 (\u03c3 \u00d7 \u03c3) \u00d7 \u03b2)\n    (h : \u2200 x s, (f x (s, s)).fst.fst = (f x (s, s)).fst.snd) :\n    (mapAccumr f xs (s, s)).snd = (mapAccumr (fun x (s : \u03c3) =>\n      (f x (s, s) |>.fst.fst, f x (s, s) |>.snd)\n    ) xs s).snd", "start": [303, 1], "end": [314, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_redundant_pair", "code": "@[simp]\ntheorem mapAccumr\u2082_redundant_pair (f : \u03b1 \u2192 \u03b2 \u2192 (\u03c3 \u00d7 \u03c3) \u2192 (\u03c3 \u00d7 \u03c3) \u00d7 \u03b3)\n    (h : \u2200 x y s, let s' := (f x y (s, s)).fst; s'.fst = s'.snd) :\n    (mapAccumr\u2082 f xs ys (s, s)).snd = (mapAccumr\u2082 (fun x y (s : \u03c3) =>\n      (f x y (s, s) |>.fst.fst, f x y (s, s) |>.snd)\n    ) xs ys s).snd", "start": [316, 1], "end": [327, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_unused_input_left", "code": "@[simp]\ntheorem mapAccumr\u2082_unused_input_left [Inhabited \u03b1] (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3)\n    (h : \u2200 a b s, f default b s = f a b s) :\n    mapAccumr\u2082 f xs ys s = mapAccumr (fun b s => f default b s) ys s", "start": [337, 1], "end": [348, 22], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_unused_input_right", "code": "@[simp]\ntheorem mapAccumr\u2082_unused_input_right [Inhabited \u03b2] (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3)\n    (h : \u2200 a b s, f a default s = f a b s) :\n    mapAccumr\u2082 f xs ys s = mapAccumr (fun a s => f a default s) xs s", "start": [350, 1], "end": [361, 22], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_comm", "code": "theorem map\u2082_comm (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (comm : \u2200 a\u2081 a\u2082, f a\u2081 a\u2082 = f a\u2082 a\u2081) :\n    map\u2082 f xs ys = map\u2082 f ys xs", "start": [371, 1], "end": [373, 58], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_comm", "code": "theorem mapAccumr\u2082_comm (f : \u03b1 \u2192 \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3) (comm : \u2200 a\u2081 a\u2082 s, f a\u2081 a\u2082 s = f a\u2082 a\u2081 s) :\n    mapAccumr\u2082 f xs ys s = mapAccumr\u2082 f ys xs s", "start": [375, 1], "end": [377, 73], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_flip", "code": "theorem map\u2082_flip (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    map\u2082 f xs ys = map\u2082 (flip f) ys xs", "start": [387, 1], "end": [389, 64], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_flip", "code": "theorem mapAccumr\u2082_flip (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b3) :\n    mapAccumr\u2082 f xs ys s = mapAccumr\u2082 (flip f) ys xs s", "start": [391, 1], "end": [393, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/NatAntidiagonal.lean", "imports": ["Mathlib/Data/Finset/NatAntidiagonal.lean", "Mathlib/Logic/Equiv/Fin.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "List.Nat.antidiagonalTuple", "code": "def antidiagonalTuple : \u2200 k, \u2115 \u2192 List (Fin k \u2192 \u2115)\n  | 0, 0 => [![]]\n  | 0, _ + 1 => []\n  | k + 1, n =>\n    (List.Nat.antidiagonal n).bind fun ni =>\n      (antidiagonalTuple k ni.2).map fun x => Fin.cons ni.1 x", "start": [52, 1], "end": [68, 62], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_zero_zero", "code": "@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = [![]]", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_zero_succ", "code": "@[simp]\ntheorem antidiagonalTuple_zero_succ (n : \u2115) : antidiagonalTuple 0 n.succ = []", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "List.Nat.mem_antidiagonalTuple", "code": "theorem mem_antidiagonalTuple {n : \u2115} {k : \u2115} {x : Fin k \u2192 \u2115} :\n    x \u2208 antidiagonalTuple k n \u2194 \u2211 i, x i = n", "start": [81, 1], "end": [94, 60], "kind": "commanddeclaration"}, {"full_name": "List.Nat.nodup_antidiagonalTuple", "code": "theorem nodup_antidiagonalTuple (k n : \u2115) : List.Nodup (antidiagonalTuple k n)", "start": [97, 1], "end": [121, 70], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_zero_right", "code": "theorem antidiagonalTuple_zero_right : \u2200 k, antidiagonalTuple k 0 = [0]", "start": [124, 1], "end": [129, 57], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_one", "code": "@[simp]\ntheorem antidiagonalTuple_one (n : \u2115) : antidiagonalTuple 1 n = [![n]]", "start": [132, 1], "end": [141, 68], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_two", "code": "theorem antidiagonalTuple_two (n : \u2115) :\n    antidiagonalTuple 2 n = (antidiagonal n).map fun i => ![i.1, i.2]", "start": [144, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonalTuple_pairwise_pi_lex", "code": "theorem antidiagonalTuple_pairwise_pi_lex :\n    \u2200 k n, (antidiagonalTuple k n).Pairwise (Pi.Lex (\u00b7 < \u00b7) @fun _ => (\u00b7 < \u00b7))", "start": [152, 1], "end": [173, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple", "code": "def antidiagonalTuple (k n : \u2115) : Multiset (Fin k \u2192 \u2115) :=\n  List.Nat.antidiagonalTuple k n", "start": [183, 1], "end": [185, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple_zero_zero", "code": "@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = {![]}", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple_zero_succ", "code": "@[simp]\ntheorem antidiagonalTuple_zero_succ (n : \u2115) : antidiagonalTuple 0 n.succ = 0", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.mem_antidiagonalTuple", "code": "theorem mem_antidiagonalTuple {n : \u2115} {k : \u2115} {x : Fin k \u2192 \u2115} :\n    x \u2208 antidiagonalTuple k n \u2194 \u2211 i, x i = n", "start": [198, 1], "end": [200, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.nodup_antidiagonalTuple", "code": "theorem nodup_antidiagonalTuple (k n : \u2115) : (antidiagonalTuple k n).Nodup", "start": [203, 1], "end": [204, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple_zero_right", "code": "theorem antidiagonalTuple_zero_right (k : \u2115) : antidiagonalTuple k 0 = {0}", "start": [207, 1], "end": [208, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple_one", "code": "@[simp]\ntheorem antidiagonalTuple_one (n : \u2115) : antidiagonalTuple 1 n = {![n]}", "start": [211, 1], "end": [213, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonalTuple_two", "code": "theorem antidiagonalTuple_two (n : \u2115) :\n    antidiagonalTuple 2 n = (antidiagonal n).map fun i => ![i.1, i.2]", "start": [216, 1], "end": [218, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple", "code": "def antidiagonalTuple (k n : \u2115) : Finset (Fin k \u2192 \u2115) :=\n  \u27e8Multiset.Nat.antidiagonalTuple k n, Multiset.Nat.nodup_antidiagonalTuple k n\u27e9", "start": [228, 1], "end": [230, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple_zero_zero", "code": "@[simp]\ntheorem antidiagonalTuple_zero_zero : antidiagonalTuple 0 0 = {![]}", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple_zero_succ", "code": "@[simp]\ntheorem antidiagonalTuple_zero_succ (n : \u2115) : antidiagonalTuple 0 n.succ = \u2205", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.mem_antidiagonalTuple", "code": "theorem mem_antidiagonalTuple {n : \u2115} {k : \u2115} {x : Fin k \u2192 \u2115} :\n    x \u2208 antidiagonalTuple k n \u2194 \u2211 i, x i = n", "start": [243, 1], "end": [245, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple_zero_right", "code": "theorem antidiagonalTuple_zero_right (k : \u2115) : antidiagonalTuple k 0 = {0}", "start": [248, 1], "end": [249, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple_one", "code": "@[simp]\ntheorem antidiagonalTuple_one (n : \u2115) : antidiagonalTuple 1 n = {![n]}", "start": [252, 1], "end": [254, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalTuple_two", "code": "theorem antidiagonalTuple_two (n : \u2115) :\n    antidiagonalTuple 2 n = (antidiagonal n).map (piFinTwoEquiv fun _ => \u2115).symm.toEmbedding", "start": [257, 1], "end": [259, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.sigmaAntidiagonalTupleEquivTuple", "code": "@[simps]\ndef sigmaAntidiagonalTupleEquivTuple (k : \u2115) : (\u03a3 n, antidiagonalTuple k n) \u2243 (Fin k \u2192 \u2115)\n    where\n  toFun x := x.2\n  invFun x := \u27e8\u2211 i, x i, x, mem_antidiagonalTuple.mpr rfl\u27e9\n  left_inv := fun \u27e8_, _, h\u27e9 => Sigma.subtype_ext (mem_antidiagonalTuple.mp h) rfl\n  right_inv _ := rfl", "start": [264, 1], "end": [274, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Cone/Proper.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "Mathlib/Analysis/Convex/Cone/Dual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexCone.closure", "code": "protected def closure (K : ConvexCone \ud835\udd5c E) : ConvexCone \ud835\udd5c E where\n  carrier := closure \u2191K\n  smul_mem' c hc _ h\u2081 :=\n    map_mem_closure (continuous_id'.const_smul c) h\u2081 fun _ h\u2082 => K.smul_mem hc h\u2082\n  add_mem' _ h\u2081 _ h\u2082 := map_mem_closure\u2082 continuous_add h\u2081 h\u2082 K.add_mem", "start": [45, 1], "end": [51, 72], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.coe_closure", "code": "@[simp, norm_cast]\ntheorem coe_closure (K : ConvexCone \ud835\udd5c E) : (K.closure : Set E) = closure K", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.mem_closure", "code": "@[simp]\nprotected theorem mem_closure {K : ConvexCone \ud835\udd5c E} {a : E} :\n    a \u2208 K.closure \u2194 a \u2208 closure (K : Set E)", "start": [59, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.closure_eq", "code": "@[simp]\ntheorem closure_eq {K L : ConvexCone \ud835\udd5c E} : K.closure = L \u2194 closure (K : Set E) = L", "start": [65, 1], "end": [67, 19], "kind": "commanddeclaration"}, {"full_name": "ProperCone", "code": "structure ProperCone (\ud835\udd5c : Type*) (E : Type*) [OrderedSemiring \ud835\udd5c] [AddCommMonoid E]\n    [TopologicalSpace E] [SMul \ud835\udd5c E] extends ConvexCone \ud835\udd5c E where\n  nonempty' : (carrier : Set E).Nonempty\n  is_closed' : IsClosed (carrier : Set E)", "start": [72, 1], "end": [78, 42], "kind": "commanddeclaration"}, {"full_name": "ProperCone.ext'", "code": "theorem ext' : Function.Injective ((\u2191) : ProperCone \ud835\udd5c E \u2192 ConvexCone \ud835\udd5c E)", "start": [98, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "ProperCone.ext", "code": "@[ext]\ntheorem ext {S T : ProperCone \ud835\udd5c E} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [107, 1], "end": [109, 16], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_coe", "code": "@[simp]\ntheorem mem_coe {x : E} {K : ProperCone \ud835\udd5c E} : x \u2208 (K : ConvexCone \ud835\udd5c E) \u2194 x \u2208 K", "start": [112, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "ProperCone.nonempty", "code": "protected theorem nonempty (K : ProperCone \ud835\udd5c E) : (K : Set E).Nonempty", "start": [117, 1], "end": [118, 14], "kind": "commanddeclaration"}, {"full_name": "ProperCone.isClosed", "code": "protected theorem isClosed (K : ProperCone \ud835\udd5c E) : IsClosed (K : Set E)", "start": [121, 1], "end": [122, 15], "kind": "commanddeclaration"}, {"full_name": "ProperCone.positive", "code": "def positive : ProperCone \ud835\udd5c E where\n  toConvexCone := ConvexCone.positive \ud835\udd5c E\n  nonempty' := \u27e80, ConvexCone.pointed_positive _ _\u27e9\n  is_closed' := isClosed_Ici", "start": [133, 1], "end": [138, 29], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_positive", "code": "@[simp]\ntheorem mem_positive {x : E} : x \u2208 positive \ud835\udd5c E \u2194 0 \u2264 x", "start": [140, 1], "end": [142, 10], "kind": "commanddeclaration"}, {"full_name": "ProperCone.coe_positive", "code": "@[simp]\ntheorem coe_positive : \u2191(positive \ud835\udd5c E) = ConvexCone.positive \ud835\udd5c E", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_zero", "code": "@[simp]\ntheorem mem_zero (x : E) : x \u2208 (0 : ProperCone \ud835\udd5c E) \u2194 x = 0", "start": [164, 1], "end": [166, 10], "kind": "commanddeclaration"}, {"full_name": "ProperCone.coe_zero", "code": "@[simp] theorem coe_zero : \u2191(0 : ProperCone \ud835\udd5c E) = (0 : ConvexCone \ud835\udd5c E)", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "ProperCone.pointed_zero", "code": "theorem pointed_zero : (0 : ProperCone \ud835\udd5c E).Pointed", "start": [174, 1], "end": [174, 89], "kind": "commanddeclaration"}, {"full_name": "ProperCone.pointed", "code": "protected theorem pointed (K : ProperCone \u211d E) : (K : ConvexCone \u211d E).Pointed", "start": [187, 1], "end": [188, 78], "kind": "commanddeclaration"}, {"full_name": "ProperCone.map", "code": "noncomputable def map (f : E \u2192L[\u211d] F) (K : ProperCone \u211d E) : ProperCone \u211d F where\n  toConvexCone := ConvexCone.closure (ConvexCone.map (f : E \u2192\u2097[\u211d] F) \u2191K)\n  nonempty' :=\n    \u27e80, subset_closure <| SetLike.mem_coe.2 <| ConvexCone.mem_map.2 \u27e80, K.pointed, map_zero _\u27e9\u27e9\n  is_closed' := isClosed_closure", "start": [191, 1], "end": [197, 33], "kind": "commanddeclaration"}, {"full_name": "ProperCone.coe_map", "code": "@[simp] theorem coe_map (f : E \u2192L[\u211d] F) (K : ProperCone \u211d E) :\n    \u2191(K.map f) = (ConvexCone.map (f : E \u2192\u2097[\u211d] F) \u2191K).closure", "start": [200, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_map", "code": "@[simp]\ntheorem mem_map {f : E \u2192L[\u211d] F} {K : ProperCone \u211d E} {y : F} :\n    y \u2208 K.map f \u2194 y \u2208 (ConvexCone.map (f : E \u2192\u2097[\u211d] F) \u2191K).closure", "start": [206, 1], "end": [209, 10], "kind": "commanddeclaration"}, {"full_name": "ProperCone.map_id", "code": "@[simp]\ntheorem map_id (K : ProperCone \u211d E) : K.map (ContinuousLinearMap.id \u211d E) = K", "start": [212, 1], "end": [214, 67], "kind": "commanddeclaration"}, {"full_name": "ProperCone.dual", "code": "def dual (K : ProperCone \u211d E) : ProperCone \u211d E where\n  toConvexCone := (K : Set E).innerDualCone\n  nonempty' := \u27e80, pointed_innerDualCone _\u27e9\n  is_closed' := isClosed_innerDualCone _", "start": [217, 1], "end": [221, 41], "kind": "commanddeclaration"}, {"full_name": "ProperCone.coe_dual", "code": "@[simp] theorem coe_dual (K : ProperCone \u211d E) : \u2191(dual K) = (K : Set E).innerDualCone", "start": [224, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_dual", "code": "@[simp]\ntheorem mem_dual {K : ProperCone \u211d E} {y : E} : y \u2208 dual K \u2194 \u2200 \u2983x\u2984, x \u2208 K \u2192 0 \u2264 \u27eax, y\u27eb_\u211d", "start": [229, 1], "end": [231, 55], "kind": "commanddeclaration"}, {"full_name": "ProperCone.comap", "code": "noncomputable def comap (f : E \u2192L[\u211d] F) (S : ProperCone \u211d F) : ProperCone \u211d E\n    where\n  toConvexCone := ConvexCone.comap (f : E \u2192\u2097[\u211d] F) S\n  nonempty' :=\n    \u27e80, by\n      simp only [ConvexCone.comap, mem_preimage, map_zero, SetLike.mem_coe, mem_coe]\n      apply ProperCone.pointed\u27e9\n  is_closed' := by\n    simp only [ConvexCone.comap, ContinuousLinearMap.coe_coe]\n    apply IsClosed.preimage f.2 S.isClosed", "start": [234, 1], "end": [244, 43], "kind": "commanddeclaration"}, {"full_name": "ProperCone.coe_comap", "code": "@[simp]\ntheorem coe_comap (f : E \u2192L[\u211d] F) (S : ProperCone \u211d F) : (S.comap f : Set E) = f \u207b\u00b9' S", "start": [247, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "ProperCone.comap_id", "code": "@[simp]\ntheorem comap_id (S : ConvexCone \u211d E) : S.comap LinearMap.id = S", "start": [252, 1], "end": [254, 36], "kind": "commanddeclaration"}, {"full_name": "ProperCone.comap_comap", "code": "theorem comap_comap (g : F \u2192L[\u211d] G) (f : E \u2192L[\u211d] F) (S : ProperCone \u211d G) :\n    (S.comap g).comap f = S.comap (g.comp f)", "start": [257, 1], "end": [259, 36], "kind": "commanddeclaration"}, {"full_name": "ProperCone.mem_comap", "code": "@[simp]\ntheorem mem_comap {f : E \u2192L[\u211d] F} {S : ProperCone \u211d F} {x : E} : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [262, 1], "end": [264, 10], "kind": "commanddeclaration"}, {"full_name": "ProperCone.dual_dual", "code": "@[simp]\ntheorem dual_dual (K : ProperCone \u211d E) : K.dual.dual = K", "start": [275, 1], "end": [279, 87], "kind": "commanddeclaration"}, {"full_name": "ProperCone.hyperplane_separation", "code": "theorem hyperplane_separation (K : ProperCone \u211d E) {f : E \u2192L[\u211d] F} {b : F} :\n    b \u2208 K.map f \u2194 \u2200 y : F, adjoint f y \u2208 K.dual \u2192 0 \u2264 \u27eay, b\u27eb_\u211d", "start": [282, 1], "end": [321, 41], "kind": "commanddeclaration"}, {"full_name": "ProperCone.hyperplane_separation_of_nmem", "code": "theorem hyperplane_separation_of_nmem (K : ProperCone \u211d E) {f : E \u2192L[\u211d] F} {b : F}\n    (disj : b \u2209 K.map f) : \u2203 y : F, adjoint f y \u2208 K.dual \u2227 \u27eay, b\u27eb_\u211d < 0", "start": [324, 1], "end": [326, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Heyting/Regular.lean", "imports": ["Mathlib/Order/GaloisConnection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Heyting.IsRegular", "code": "def IsRegular (a : \u03b1) : Prop :=\n  a\u1d9c\u1d9c = a", "start": [41, 1], "end": [43, 10], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.eq", "code": "protected theorem IsRegular.eq : IsRegular a \u2192 a\u1d9c\u1d9c = a", "start": [46, 1], "end": [47, 5], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.decidablePred", "code": "instance IsRegular.decidablePred [DecidableEq \u03b1] : @DecidablePred \u03b1 IsRegular := fun _ =>\n  \u2039DecidableEq \u03b1\u203a _ _", "start": [50, 1], "end": [51, 22], "kind": "commanddeclaration"}, {"full_name": "Heyting.isRegular_bot", "code": "theorem isRegular_bot : IsRegular (\u22a5 : \u03b1)", "start": [60, 1], "end": [60, 85], "kind": "commanddeclaration"}, {"full_name": "Heyting.isRegular_top", "code": "theorem isRegular_top : IsRegular (\u22a4 : \u03b1)", "start": [63, 1], "end": [63, 85], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.inf", "code": "theorem IsRegular.inf (ha : IsRegular a) (hb : IsRegular b) : IsRegular (a \u2293 b)", "start": [66, 1], "end": [67, 56], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.himp", "code": "theorem IsRegular.himp (ha : IsRegular a) (hb : IsRegular b) : IsRegular (a \u21e8 b)", "start": [70, 1], "end": [71, 57], "kind": "commanddeclaration"}, {"full_name": "Heyting.isRegular_compl", "code": "theorem isRegular_compl (a : \u03b1) : IsRegular a\u1d9c", "start": [74, 1], "end": [75, 22], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.disjoint_compl_left_iff", "code": "protected theorem IsRegular.disjoint_compl_left_iff (ha : IsRegular a) : Disjoint a\u1d9c b \u2194 b \u2264 a", "start": [78, 1], "end": [79, 46], "kind": "commanddeclaration"}, {"full_name": "Heyting.IsRegular.disjoint_compl_right_iff", "code": "protected theorem IsRegular.disjoint_compl_right_iff (hb : IsRegular b) : Disjoint a b\u1d9c \u2194 a \u2264 b", "start": [82, 1], "end": [83, 47], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.ofRegular", "code": "@[reducible]\ndef _root_.BooleanAlgebra.ofRegular (h : \u2200 a : \u03b1, IsRegular (a \u2294 a\u1d9c)) : BooleanAlgebra \u03b1 :=\n  have : \u2200 a : \u03b1, IsCompl a a\u1d9c := fun a =>\n    \u27e8disjoint_compl_right,\n      codisjoint_iff.2 <| by erw [\u2190 (h a), compl_sup, inf_compl_eq_bot, compl_bot]\u27e9\n  { \u2039HeytingAlgebra \u03b1\u203a,\n    GeneralizedHeytingAlgebra.toDistribLattice with\n    himp_eq := fun a b =>\n      eq_of_forall_le_iff fun c => le_himp_iff.trans (this _).le_sup_right_iff_inf_left_le.symm\n    inf_compl_le_bot := fun a => (this _).1.le_bot\n    top_le_sup_compl := fun a => (this _).2.top_le }", "start": [87, 1], "end": [98, 53], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular", "code": "def Regular : Type _ :=\n  { a : \u03b1 // IsRegular a }", "start": [103, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.val", "code": "@[coe] def val : Regular \u03b1 \u2192 \u03b1 :=\n  Subtype.val", "start": [113, 1], "end": [115, 14], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.prop", "code": "theorem prop : \u2200 a : Regular \u03b1, IsRegular a.val", "start": [117, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : Regular \u03b1 \u2192 \u03b1)", "start": [121, 1], "end": [122, 24], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_inj", "code": "@[simp]\ntheorem coe_inj {a b : Regular \u03b1} : (a : \u03b1) = b \u2194 a = b", "start": [125, 1], "end": [127, 18], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.top", "code": "instance top : Top (Regular \u03b1) :=\n  \u27e8\u27e8\u22a4, isRegular_top\u27e9\u27e9", "start": [130, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.bot", "code": "instance bot : Bot (Regular \u03b1) :=\n  \u27e8\u27e8\u22a5, isRegular_bot\u27e9\u27e9", "start": [133, 1], "end": [134, 23], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.inf", "code": "instance inf : Inf (Regular \u03b1) :=\n  \u27e8fun a b => \u27e8a \u2293 b, a.2.inf b.2\u27e9\u27e9", "start": [136, 1], "end": [137, 36], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.himp", "code": "instance himp : HImp (Regular \u03b1) :=\n  \u27e8fun a b => \u27e8a \u21e8 b, a.2.himp b.2\u27e9\u27e9", "start": [139, 1], "end": [140, 37], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.hasCompl", "code": "instance hasCompl : HasCompl (Regular \u03b1) :=\n  \u27e8fun a => \u27e8a\u1d9c, isRegular_compl _\u27e9\u27e9", "start": [142, 1], "end": [143, 37], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : Regular \u03b1) : \u03b1) = \u22a4", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : Regular \u03b1) : \u03b1) = \u22a5", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (a b : Regular \u03b1) : (\u2191(a \u2293 b) : \u03b1) = (a : \u03b1) \u2293 b", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_himp", "code": "@[simp, norm_cast]\ntheorem coe_himp (a b : Regular \u03b1) : (\u2191(a \u21e8 b) : \u03b1) = (a : \u03b1) \u21e8 b", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_compl", "code": "@[simp, norm_cast]\ntheorem coe_compl (a : Regular \u03b1) : (\u2191a\u1d9c : \u03b1) = (a : \u03b1)\u1d9c", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.boundedOrder", "code": "instance boundedOrder : BoundedOrder (Regular \u03b1) :=\n  BoundedOrder.lift ((\u2191) : Regular \u03b1 \u2192 \u03b1) (fun _ _ => id) coe_top coe_bot", "start": [176, 1], "end": [177, 74], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {a b : Regular \u03b1} : (a : \u03b1) \u2264 b \u2194 a \u2264 b", "start": [179, 1], "end": [181, 10], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe {a b : Regular \u03b1} : (a : \u03b1) < b \u2194 a < b", "start": [184, 1], "end": [186, 10], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.toRegular", "code": "def toRegular : \u03b1 \u2192o Regular \u03b1 :=\n  \u27e8fun a => \u27e8a\u1d9c\u1d9c, isRegular_compl _\u27e9, fun _ _ h =>\n    coe_le_coe.1 <| compl_le_compl <| compl_le_compl h\u27e9", "start": [189, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_toRegular", "code": "@[simp, norm_cast]\ntheorem coe_toRegular (a : \u03b1) : (toRegular a : \u03b1) = a\u1d9c\u1d9c", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.toRegular_coe", "code": "@[simp]\ntheorem toRegular_coe (a : Regular \u03b1) : toRegular (a : \u03b1) = a", "start": [200, 1], "end": [202, 20], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.gi", "code": "def gi : GaloisInsertion toRegular ((\u2191) : Regular \u03b1 \u2192 \u03b1)\n    where\n  choice a ha := \u27e8a, ha.antisymm le_compl_compl\u27e9\n  gc _ b :=\n    coe_le_coe.symm.trans <|\n      \u27e8le_compl_compl.trans, fun h => (compl_anti <| compl_anti h).trans_eq b.2\u27e9\n  le_l_u _ := le_compl_compl\n  choice_eq _ ha := coe_injective <| le_compl_compl.antisymm ha", "start": [205, 1], "end": [213, 64], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.lattice", "code": "instance lattice : Lattice (Regular \u03b1) :=\n  gi.liftLattice", "start": [216, 1], "end": [217, 17], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (a b : Regular \u03b1) : (\u2191(a \u2294 b) : \u03b1) = ((a : \u03b1) \u2294 b)\u1d9c\u1d9c", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.Regular.coe_sdiff", "code": "@[simp, norm_cast]\ntheorem coe_sdiff (a b : Regular \u03b1) : (\u2191(a \\ b) : \u03b1) = (a : \u03b1) \u2293 b\u1d9c", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "Heyting.isRegular_of_boolean", "code": "theorem isRegular_of_boolean : \u2200 a : \u03b1, IsRegular a", "start": [256, 1], "end": [257, 14], "kind": "commanddeclaration"}, {"full_name": "Heyting.isRegular_of_decidable", "code": "theorem isRegular_of_decidable (p : Prop) [Decidable p] : IsRegular p", "start": [260, 1], "end": [263, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/CoprodI.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean", "Mathlib/Data/List/Chain.lean", "Mathlib/GroupTheory/Congruence.lean"], "premises": [{"full_name": "Monoid.CoprodI.Rel", "code": "inductive Monoid.CoprodI.Rel : FreeMonoid (\u03a3i, M i) \u2192 FreeMonoid (\u03a3i, M i) \u2192 Prop\n  | of_one (i : \u03b9) : Monoid.CoprodI.Rel (FreeMonoid.of \u27e8i, 1\u27e9) 1\n  | of_mul {i : \u03b9} (x y : M i) :\n    Monoid.CoprodI.Rel (FreeMonoid.of \u27e8i, x\u27e9 * FreeMonoid.of \u27e8i, y\u27e9) (FreeMonoid.of \u27e8i, x * y\u27e9)", "start": [88, 1], "end": [93, 96], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI", "code": "def Monoid.CoprodI : Type _ := (conGen (Monoid.CoprodI.Rel M)).Quotient", "start": [96, 1], "end": [97, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word", "code": "@[ext]\nstructure Word where\n  \n  toList : List (\u03a3i, M i)\n  \n  ne_one : \u2200 l \u2208 toList, Sigma.snd l \u2260 1\n  \n  chain_ne : toList.Chain' fun l l' => Sigma.fst l \u2260 Sigma.fst l'", "start": [109, 1], "end": [119, 66], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.of", "code": "def of {i : \u03b9} : M i \u2192* CoprodI M where\n  toFun x := Con.mk' _ (FreeMonoid.of <| Sigma.mk i x)\n  map_one' := (Con.eq _).mpr (ConGen.Rel.of _ _ (CoprodI.Rel.of_one i))\n  map_mul' x y := Eq.symm <| (Con.eq _).mpr (ConGen.Rel.of _ _ (CoprodI.Rel.of_mul x y))", "start": [124, 1], "end": [128, 89], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.of_apply", "code": "theorem of_apply {i} (m : M i) : of m = Con.mk' _ (FreeMonoid.of <| Sigma.mk i m)", "start": [131, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.ext_hom", "code": "@[ext 1100]\ntheorem ext_hom (f g : CoprodI M \u2192* N) (h : \u2200 i, f.comp (of : M i \u2192* _) = g.comp of) : f = g", "start": [137, 1], "end": [145, 38], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift", "code": "@[simps symm_apply]\ndef lift : (\u2200 i, M i \u2192* N) \u2243 (CoprodI M \u2192* N) where\n  toFun fi :=\n    Con.lift _ (FreeMonoid.lift fun p : \u03a3i, M i => fi p.fst p.snd) <|\n      Con.conGen_le <| by\n        simp_rw [Con.rel_eq_coe, Con.ker_rel]\n        rintro _ _ (i | \u27e8x, y\u27e9)\n        \u00b7 change FreeMonoid.lift _ (FreeMonoid.of _) = FreeMonoid.lift _ 1\n          simp only [MonoidHom.map_one, FreeMonoid.lift_eval_of]\n        \u00b7 change\n            FreeMonoid.lift _ (FreeMonoid.of _ * FreeMonoid.of _) =\n              FreeMonoid.lift _ (FreeMonoid.of _)\n          simp only [MonoidHom.map_mul, FreeMonoid.lift_eval_of]\n  invFun f i := f.comp of\n  left_inv := by\n    intro fi\n    ext i x\n    erw [MonoidHom.comp_apply, of_apply, Con.lift_mk', FreeMonoid.lift_eval_of]\n  right_inv := by\n    intro f\n    ext i x\n    rfl", "start": [148, 1], "end": [172, 8], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_of", "code": "@[simp]\ntheorem lift_of {N} [Monoid N] (fi : \u2200 i, M i \u2192* N) {i} (m : M i) : lift fi (of m) = fi i m", "start": [175, 1], "end": [177, 85], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {C : CoprodI M \u2192 Prop} (m : CoprodI M) (h_one : C 1)\n    (h_of : \u2200 (i) (m : M i), C (of m)) (h_mul : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C m", "start": [180, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.of_leftInverse", "code": "theorem of_leftInverse [DecidableEq \u03b9] (i : \u03b9) :\n    Function.LeftInverse (lift <| Pi.mulSingle i (MonoidHom.id (M i))) of", "start": [195, 1], "end": [197, 64], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.of_injective", "code": "theorem of_injective (i : \u03b9) : Function.Injective (of : M i \u2192* _)", "start": [200, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_mrange_le", "code": "theorem lift_mrange_le {N} [Monoid N] (f : \u2200 i, M i \u2192* N) {s : Submonoid N}\n    (h : \u2200 i, MonoidHom.mrange (f i) \u2264 s) : MonoidHom.mrange (lift f) \u2264 s", "start": [204, 1], "end": [212, 26], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.mrange_eq_iSup", "code": "theorem mrange_eq_iSup {N} [Monoid N] (f : \u2200 i, M i \u2192* N) :\n    MonoidHom.mrange (lift f) = \u2a06 i, MonoidHom.mrange (f i)", "start": [215, 1], "end": [220, 39], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.inv_def", "code": "theorem inv_def (x : CoprodI G) :\n    x\u207b\u00b9 =\n      MulOpposite.unop\n        (lift (fun i => (of : G i \u2192* _).op.comp (MulEquiv.inv' (G i)).toMonoidHom) x)", "start": [231, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_range_le", "code": "theorem lift_range_le {N} [Group N] (f : \u2200 i, G i \u2192* N) {s : Subgroup N}\n    (h : \u2200 i, (f i).range \u2264 s) : (lift f).range \u2264 s", "start": [251, 1], "end": [259, 26], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.range_eq_iSup", "code": "theorem range_eq_iSup {N} [Group N] (f : \u2200 i, G i \u2192* N) : (lift f).range = \u2a06 i, (f i).range", "start": [262, 1], "end": [266, 39], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.empty", "code": "@[simps]\ndef empty : Word M where\n  toList := []\n  ne_one := by simp\n  chain_ne := List.chain'_nil", "start": [273, 1], "end": [278, 30], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.prod", "code": "def prod (w : Word M) : CoprodI M :=\n  List.prod (w.toList.map fun l => of l.snd)", "start": [284, 1], "end": [286, 45], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.prod_empty", "code": "@[simp]\ntheorem prod_empty : prod (empty : Word M) = 1", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.fstIdx", "code": "def fstIdx (w : Word M) : Option \u03b9 :=\n  w.toList.head?.map Sigma.fst", "start": [294, 1], "end": [297, 31], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.fstIdx_ne_iff", "code": "theorem fstIdx_ne_iff {w : Word M} {i} :\n    fstIdx w \u2260 some i \u2194 \u2200 l \u2208 w.toList.head?, i \u2260 Sigma.fst l", "start": [300, 1], "end": [302, 37], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.Pair", "code": "@[ext]\nstructure Pair (i : \u03b9) where\n  \n  head : M i\n  \n  tail : Word M\n  \n  fstIdx_ne : fstIdx tail \u2260 some i", "start": [307, 1], "end": [318, 35], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.cons", "code": "@[simps]\ndef cons {i} (m : M i) (w : Word M) (hmw : w.fstIdx \u2260 some i) (h1 : m \u2260 1) : Word M :=\n  { toList := \u27e8i, m\u27e9 :: w.toList,\n    ne_one := by\n      simp only [List.mem_cons]\n      rintro l (rfl | hl)\n      exact h1\n      exact w.ne_one l hl\n    chain_ne := w.chain_ne.cons' (fstIdx_ne_iff.mp hmw) }", "start": [328, 1], "end": [338, 58], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.rcons", "code": "def rcons {i} (p : Pair M i) : Word M :=\n  if h : p.head = 1 then p.tail\n  else cons p.head p.tail p.fstIdx_ne h", "start": [341, 1], "end": [345, 40], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.prod_rcons", "code": "@[simp]\ntheorem prod_rcons {i} (p : Pair M i) : prod (rcons p) = of p.head * prod p.tail", "start": [350, 1], "end": [353, 82], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.rcons_inj", "code": "theorem rcons_inj {i} : Function.Injective (rcons : Pair M i \u2192 Word M)", "start": [356, 1], "end": [374, 25], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.mem_rcons_iff", "code": "theorem mem_rcons_iff {i j : \u03b9} (p : Pair M i) (m : M j) :\n    \u27e8_, m\u27e9 \u2208 (rcons p).toList \u2194 \u27e8_, m\u27e9 \u2208 p.tail.toList \u2228\n      m \u2260 1 \u2227 (\u2203 h : i = j, m = h \u25b8 p.head)", "start": [377, 1], "end": [387, 41], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.fstIdx_cons", "code": "@[simp]\ntheorem fstIdx_cons {i} (m : M i) (w : Word M) (hmw : w.fstIdx \u2260 some i) (h1 : m \u2260 1) :\n    fstIdx (cons m w hmw h1) = some i", "start": [389, 1], "end": [391, 64], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.prod_cons", "code": "@[simp]\ntheorem prod_cons (i) (m : M i) (w : Word M) (h1 : m \u2260 1) (h2 : w.fstIdx \u2260 some i) :\n    prod (cons m w h2 h1) = of m * prod w", "start": [393, 1], "end": [396, 51], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.consRecOn", "code": "@[elab_as_elim]\ndef consRecOn {motive : Word M \u2192 Sort*} (w : Word M) (h_empty : motive empty)\n    (h_cons : \u2200 (i) (m : M i) (w) h1 h2, motive w \u2192 motive (cons m w h1 h2)) :\n    motive w := by\n  rcases w with \u27e8w, h1, h2\u27e9\n  induction w with\n  | nil => exact h_empty\n  | cons m w ih =>\n    refine h_cons m.1 m.2 \u27e8w, fun _ hl => h1 _ (List.mem_cons_of_mem _ hl), h2.tail\u27e9 ?_ ?_ (ih _ _)\n    \u00b7 rw [List.chain'_cons'] at h2\n      simp only [fstIdx, ne_eq, Option.map_eq_some',\n        Sigma.exists, exists_and_right, exists_eq_right, not_exists]\n      intro m' hm'\n      exact h2.1 _ hm' rfl\n    \u00b7 exact h1 _ (List.mem_cons_self _ _)", "start": [398, 1], "end": [414, 42], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.consRecOn_empty", "code": "@[simp]\ntheorem consRecOn_empty {motive : Word M \u2192 Sort*} (h_empty : motive empty)\n    (h_cons : \u2200 (i) (m : M i) (w) h1 h2, motive w \u2192 motive (cons m w h1 h2)) :\n    consRecOn empty h_empty h_cons = h_empty", "start": [416, 1], "end": [419, 52], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.consRecOn_cons", "code": "@[simp]\ntheorem consRecOn_cons {motive : Word M \u2192 Sort*} (i) (m : M i) (w : Word M) h1 h2\n    (h_empty : motive empty)\n    (h_cons : \u2200 (i) (m : M i) (w) h1 h2, motive w \u2192 motive (cons m w h1 h2)) :\n    consRecOn (cons m w h1 h2) h_empty h_cons = h_cons i m w h1 h2\n      (consRecOn w h_empty h_cons)", "start": [421, 1], "end": [426, 42], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPairAux", "code": "private def equivPairAux (i) (w : Word M) : { p : Pair M i // rcons p = w } :=\n  consRecOn w \u27e8\u27e81, .empty, by simp [fstIdx, empty]\u27e9, by simp [rcons]\u27e9 <|\n    fun j m w h1 h2 _ =>\n      if ij : i = j then\n        { val :=\n          { head := ij \u25b8 m\n            tail := w\n            fstIdx_ne := ij \u25b8 h1 }\n          property := by subst ij; simp [rcons, h2] }\n      else \u27e8\u27e81, cons m w h1 h2, by simp [cons, fstIdx, Ne.symm ij]\u27e9,  by simp [rcons]\u27e9", "start": [433, 1], "end": [443, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair", "code": "def equivPair (i) : Word M \u2243 Pair M i where\n  toFun w := (equivPairAux i w).val\n  invFun := rcons\n  left_inv w := (equivPairAux i w).property\n  right_inv _ := rcons_inj (equivPairAux i _).property", "start": [445, 1], "end": [451, 55], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_symm", "code": "theorem equivPair_symm (i) (p : Pair M i) : (equivPair i).symm p = rcons p", "start": [454, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_eq_of_fstIdx_ne", "code": "theorem equivPair_eq_of_fstIdx_ne {i} {w : Word M} (h : fstIdx w \u2260 some i) :\n    equivPair i w = \u27e81, w, h\u27e9", "start": [458, 1], "end": [460, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.mem_equivPair_tail_iff", "code": "theorem mem_equivPair_tail_iff {i j : \u03b9} {w : Word M} (m : M i) :\n    (\u27e8i, m\u27e9 \u2208 (equivPair j w).tail.toList) \u2194 \u27e8i, m\u27e9 \u2208 w.toList.tail\n      \u2228 i \u2260 j \u2227 \u2203 h : w.toList \u2260 [], w.toList.head h = \u27e8i, m\u27e9", "start": [463, 1], "end": [476, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.mem_of_mem_equivPair_tail", "code": "theorem mem_of_mem_equivPair_tail {i j : \u03b9} {w : Word M} (m : M i) :\n    (\u27e8i, m\u27e9 \u2208 (equivPair j w).tail.toList) \u2192 \u27e8i, m\u27e9 \u2208 w.toList", "start": [478, 1], "end": [483, 71], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_head", "code": "theorem equivPair_head {i : \u03b9} {w : Word M} :\n    (equivPair i w).head =\n      if h : \u2203 (h : w.toList \u2260 []), (w.toList.head h).1 = i\n      then h.snd \u25b8 (w.toList.head h.1).2\n      else 1", "start": [485, 1], "end": [496, 28], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.summandAction", "code": "instance summandAction (i) : MulAction (M i) (Word M) where\n  smul m w := rcons { equivPair i w with head := m * (equivPair i w).head }\n  one_smul w := by\n    apply (equivPair i).symm_apply_eq.mpr\n    simp [equivPair]\n  mul_smul m m' w := by\n    dsimp [instHSMul]\n    simp [mul_assoc, \u2190 equivPair_symm, Equiv.apply_symm_apply]", "start": [498, 1], "end": [505, 63], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.smul_def", "code": "theorem smul_def {i} (m : M i) (w : Word M) :\n    m \u2022 w = rcons { equivPair i w with head := m * (equivPair i w).head }", "start": [511, 1], "end": [513, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.of_smul_def", "code": "theorem of_smul_def (i) (w : Word M) (m : M i) :\n    of m \u2022 w = rcons { equivPair i w with head := m * (equivPair i w).head }", "start": [515, 1], "end": [517, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_smul_same", "code": "theorem equivPair_smul_same {i} (m : M i) (w : Word M) :\n    equivPair i (of m \u2022 w) = \u27e8m * (equivPair i w).head, (equivPair i w).tail,\n      (equivPair i w).fstIdx_ne\u27e9", "start": [520, 1], "end": [524, 7], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_tail", "code": "@[simp]\ntheorem equivPair_tail {i} (p : Pair M i) :\n    equivPair i p.tail = \u27e81, p.tail, p.fstIdx_ne\u27e9", "start": [526, 1], "end": [529, 30], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.smul_eq_of_smul", "code": "theorem smul_eq_of_smul {i} (m : M i) (w : Word M) :\n    m \u2022 w = of m \u2022 w", "start": [531, 1], "end": [532, 28], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.mem_smul_iff", "code": "theorem mem_smul_iff {i j : \u03b9} {m\u2081 : M i} {m\u2082 : M j} {w : Word M} :\n    \u27e8_, m\u2081\u27e9 \u2208 (of m\u2082 \u2022 w).toList \u2194\n      (\u00aci = j \u2227 \u27e8i, m\u2081\u27e9 \u2208 w.toList)\n      \u2228 (m\u2081 \u2260 1 \u2227 \u2203 (hij : i = j),(\u27e8i, m\u2081\u27e9 \u2208 w.toList.tail) \u2228\n        (\u2203 m', \u27e8j, m'\u27e9 \u2208 w.toList.head? \u2227 m\u2081 = hij \u25b8 (m\u2082 * m')) \u2228\n        (w.fstIdx \u2260 some j \u2227 m\u2081 = hij \u25b8 m\u2082))", "start": [534, 1], "end": [567, 46], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.mem_smul_iff_of_ne", "code": "theorem mem_smul_iff_of_ne {i j : \u03b9} (hij : i \u2260 j) {m\u2081 : M i} {m\u2082 : M j} {w : Word M} :\n    \u27e8_, m\u2081\u27e9 \u2208 (of m\u2082 \u2022 w).toList \u2194 \u27e8i, m\u2081\u27e9 \u2208 w.toList", "start": [569, 1], "end": [571, 25], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.cons_eq_smul", "code": "theorem cons_eq_smul {i} {m : M i} {ls h1 h2} :\n    cons m ls h1 h2 = of m \u2022 ls", "start": [573, 1], "end": [577, 13], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.rcons_eq_smul", "code": "theorem rcons_eq_smul {i} (p : Pair M i) :\n    rcons p = of p.head \u2022 p.tail", "start": [580, 1], "end": [582, 21], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_head_smul_equivPair_tail", "code": "@[simp]\ntheorem equivPair_head_smul_equivPair_tail {i : \u03b9} (w : Word M) :\n    of (equivPair i w).head \u2022 (equivPair i w).tail = w", "start": [584, 1], "end": [587, 65], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equivPair_tail_eq_inv_smul", "code": "theorem equivPair_tail_eq_inv_smul {G : \u03b9 \u2192 Type*} [\u2200 i, Group (G i)]\n    [\u2200i, DecidableEq (G i)] {i} (w : Word G) :\n    (equivPair i w).tail = (of (equivPair i w).head)\u207b\u00b9 \u2022 w", "start": [589, 1], "end": [592, 75], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.smul_induction", "code": "theorem smul_induction {C : Word M \u2192 Prop} (h_empty : C empty)\n    (h_smul : \u2200 (i) (m : M i) (w), C w \u2192 C (of m \u2022 w)) (w : Word M) : C w", "start": [594, 1], "end": [600, 26], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.prod_smul", "code": "@[simp]\ntheorem prod_smul (m) : \u2200 w : Word M, prod (m \u2022 w) = m * prod w", "start": [603, 1], "end": [615, 37], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.Word.equiv", "code": "def equiv : CoprodI M \u2243 Word M where\n  toFun m := m \u2022 empty\n  invFun w := prod w\n  left_inv m := by dsimp only; rw [prod_smul, prod_empty, mul_one]\n  right_inv := by\n    apply smul_induction\n    \u00b7 dsimp only\n      rw [prod_empty, one_smul]\n    \u00b7 dsimp only\n      intro i m w ih\n      rw [prod_smul, mul_smul, ih]", "start": [618, 1], "end": [629, 35], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord", "code": "inductive NeWord : \u03b9 \u2192 \u03b9 \u2192 Type _\n  | singleton : \u2200 {i : \u03b9} (x : M i), x \u2260 1 \u2192 NeWord i i\n  | append : \u2200 {i j k l} (_w\u2081 : NeWord i j) (_hne : j \u2260 k) (_w\u2082 : NeWord k l), NeWord i l", "start": [642, 1], "end": [648, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.toList", "code": "@[simp]\ndef toList : \u2200 {i j} (_w : NeWord M i j), List (\u03a3i, M i)\n  | i, _, singleton x _ => [\u27e8i, x\u27e9]\n  | _, _, append w\u2081 _ w\u2082 => w\u2081.toList ++ w\u2082.toList", "start": [657, 1], "end": [661, 51], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.toList_ne_nil", "code": "theorem toList_ne_nil {i j} (w : NeWord M i j) : w.toList \u2260 List.nil", "start": [664, 1], "end": [668, 15], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.head", "code": "@[simp]\ndef head : \u2200 {i j} (_w : NeWord M i j), M i\n  | _, _, singleton x _ => x\n  | _, _, append w\u2081 _ _ => w\u2081.head", "start": [671, 1], "end": [675, 35], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.last", "code": "@[simp]\ndef last : \u2200 {i j} (_w : NeWord M i j), M j\n  | _, _, singleton x _hne1 => x\n  | _, _, append _w\u2081 _hne w\u2082 => w\u2082.last", "start": [678, 1], "end": [682, 40], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.toList_head?", "code": "@[simp]\ntheorem toList_head? {i j} (w : NeWord M i j) : w.toList.head? = Option.some \u27e8i, w.head\u27e9", "start": [685, 1], "end": [691, 44], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.toList_getLast?", "code": "@[simp]\ntheorem toList_getLast? {i j} (w : NeWord M i j) : w.toList.getLast? = Option.some \u27e8j, w.last\u27e9", "start": [694, 1], "end": [700, 47], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.toWord", "code": "def toWord {i j} (w : NeWord M i j) : Word M\n    where\n  toList := w.toList\n  ne_one := by\n    induction w\n    \u00b7 simpa only [toList, List.mem_singleton, ne_eq, forall_eq]\n    \u00b7 intro l h\n      simp only [toList, List.mem_append] at h\n      cases h <;> aesop\n  chain_ne := by\n    induction w\n    \u00b7 exact List.chain'_singleton _\n    \u00b7 refine List.Chain'.append (by assumption) (by assumption) ?_\n      intro x hx y hy\n      rw [toList_getLast?, Option.mem_some_iff] at hx\n      rw [toList_head?, Option.mem_some_iff] at hy\n      subst hx\n      subst hy\n      assumption", "start": [703, 1], "end": [722, 17], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.of_word", "code": "theorem of_word (w : Word M) (h : w \u2260 empty) : \u2203 (i j : _) (w' : NeWord M i j), w'.toWord = w", "start": [725, 1], "end": [744, 33], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.prod", "code": "def prod {i j} (w : NeWord M i j) :=\n  w.toWord.prod", "start": [747, 1], "end": [749, 16], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.singleton_head", "code": "@[simp]\ntheorem singleton_head {i} (x : M i) (hne_one : x \u2260 1) : (singleton x hne_one).head = x", "start": [752, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.singleton_last", "code": "@[simp]\ntheorem singleton_last {i} (x : M i) (hne_one : x \u2260 1) : (singleton x hne_one).last = x", "start": [757, 1], "end": [759, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.prod_singleton", "code": "@[simp]\ntheorem prod_singleton {i} (x : M i) (hne_one : x \u2260 1) : (singleton x hne_one).prod = of x", "start": [762, 1], "end": [764, 33], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.append_head", "code": "@[simp]\ntheorem append_head {i j k l} {w\u2081 : NeWord M i j} {hne : j \u2260 k} {w\u2082 : NeWord M k l} :\n    (append w\u2081 hne w\u2082).head = w\u2081.head", "start": [767, 1], "end": [770, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.append_last", "code": "@[simp]\ntheorem append_last {i j k l} {w\u2081 : NeWord M i j} {hne : j \u2260 k} {w\u2082 : NeWord M k l} :\n    (append w\u2081 hne w\u2082).last = w\u2082.last", "start": [773, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.append_prod", "code": "@[simp]\ntheorem append_prod {i j k l} {w\u2081 : NeWord M i j} {hne : j \u2260 k} {w\u2082 : NeWord M k l} :\n    (append w\u2081 hne w\u2082).prod = w\u2081.prod * w\u2082.prod", "start": [779, 1], "end": [781, 85], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.replaceHead", "code": "def replaceHead : \u2200 {i j : \u03b9} (x : M i) (_hnotone : x \u2260 1) (_w : NeWord M i j), NeWord M i j\n  | _, _, x, h, singleton _ _ => singleton x h\n  | _, _, x, h, append w\u2081 hne w\u2082 => append (replaceHead x h w\u2081) hne w\u2082", "start": [784, 1], "end": [788, 71], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.replaceHead_head", "code": "@[simp]\ntheorem replaceHead_head {i j : \u03b9} (x : M i) (hnotone : x \u2260 1) (w : NeWord M i j) :\n    (replaceHead x hnotone w).head = x", "start": [791, 1], "end": [796, 11], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.mulHead", "code": "def mulHead {i j : \u03b9} (w : NeWord M i j) (x : M i) (hnotone : x * w.head \u2260 1) : NeWord M i j :=\n  replaceHead (x * w.head) hnotone w", "start": [799, 1], "end": [802, 37], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.mulHead_head", "code": "@[simp]\ntheorem mulHead_head {i j : \u03b9} (w : NeWord M i j) (x : M i) (hnotone : x * w.head \u2260 1) :\n    (mulHead w x hnotone).head = x * w.head", "start": [805, 1], "end": [810, 11], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.mulHead_prod", "code": "@[simp]\ntheorem mulHead_prod {i j : \u03b9} (w : NeWord M i j) (x : M i) (hnotone : x * w.head \u2260 1) :\n    (mulHead w x hnotone).prod = of x * w.prod", "start": [813, 1], "end": [822, 12], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.inv", "code": "def inv : \u2200 {i j} (_w : NeWord G i j), NeWord G j i\n  | _, _, singleton x h => singleton x\u207b\u00b9 (mt inv_eq_one.mp h)\n  | _, _, append w\u2081 h w\u2082 => append w\u2082.inv h.symm w\u2081.inv", "start": [829, 1], "end": [832, 56], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.inv_prod", "code": "@[simp]\ntheorem inv_prod {i j} (w : NeWord G i j) : w.inv.prod = w.prod\u207b\u00b9", "start": [835, 1], "end": [837, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.inv_head", "code": "@[simp]\ntheorem inv_head {i j} (w : NeWord G i j) : w.inv.head = w.last\u207b\u00b9", "start": [840, 1], "end": [842, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.NeWord.inv_last", "code": "@[simp]\ntheorem inv_last {i j} (w : NeWord G i j) : w.inv.last = w.head\u207b\u00b9", "start": [845, 1], "end": [847, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_word_ping_pong", "code": "theorem lift_word_ping_pong {i j k} (w : NeWord H i j) (hk : j \u2260 k) :\n    lift f w.prod \u2022 X k \u2286 X i", "start": [884, 1], "end": [892, 26], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_word_prod_nontrivial_of_other_i", "code": "theorem lift_word_prod_nontrivial_of_other_i {i j k} (w : NeWord H i j) (hhead : k \u2260 i)\n    (hlast : k \u2260 j) : lift f w.prod \u2260 1", "start": [897, 1], "end": [902, 44], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_word_prod_nontrivial_of_head_eq_last", "code": "theorem lift_word_prod_nontrivial_of_head_eq_last {i} (w : NeWord H i i) : lift f w.prod \u2260 1", "start": [907, 1], "end": [909, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_word_prod_nontrivial_of_head_card", "code": "theorem lift_word_prod_nontrivial_of_head_card {i j} (w : NeWord H i j) (hcard : 3 \u2264 #(H i))\n    (hheadtail : i \u2260 j) : lift f w.prod \u2260 1", "start": [912, 1], "end": [925, 14], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_word_prod_nontrivial_of_not_empty", "code": "theorem lift_word_prod_nontrivial_of_not_empty {i j} (w : NeWord H i j) : lift f w.prod \u2260 1", "start": [930, 1], "end": [960, 20], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.empty_of_word_prod_eq_one", "code": "theorem empty_of_word_prod_eq_one {w : Word H} (h : lift f w.prod = 1) : w = Word.empty", "start": [963, 1], "end": [966, 83], "kind": "commanddeclaration"}, {"full_name": "Monoid.CoprodI.lift_injective_of_ping_pong", "code": "theorem lift_injective_of_ping_pong : Function.Injective (lift f)", "start": [969, 1], "end": [989, 12], "kind": "commanddeclaration"}, {"full_name": "freeGroupEquivCoprodI", "code": "@[simps!]\ndef _root_.freeGroupEquivCoprodI {\u03b9 : Type u_1} :\n    FreeGroup \u03b9 \u2243* CoprodI fun _ : \u03b9 => FreeGroup Unit := by\n  refine' MonoidHom.toMulEquiv _ _ _ _\n  exact FreeGroup.lift fun i => @CoprodI.of \u03b9 _ _ i (FreeGroup.of Unit.unit)\n  exact CoprodI.lift fun i => FreeGroup.lift fun _ => FreeGroup.of i\n  \u00b7 ext; simp\n  \u00b7 ext i a; cases a; simp", "start": [1012, 1], "end": [1020, 27], "kind": "commanddeclaration"}, {"full_name": "FreeGroup.injective_lift_of_ping_pong", "code": "theorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a)", "start": [1050, 1], "end": [1149, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/FLT/Four.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "Mathlib/NumberTheory/PythagoreanTriples.lean", "Mathlib/RingTheory/Coprime/Lemmas.lean", "Mathlib/NumberTheory/FLT/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fermat42", "code": "def Fermat42 (a b c : \u2124) : Prop :=\n  a \u2260 0 \u2227 b \u2260 0 \u2227 a ^ 4 + b ^ 4 = c ^ 2", "start": [23, 1], "end": [27, 40], "kind": "commanddeclaration"}, {"full_name": "Fermat42.comm", "code": "theorem comm {a b c : \u2124} : Fermat42 a b c \u2194 Fermat42 b a c", "start": [32, 1], "end": [35, 8], "kind": "commanddeclaration"}, {"full_name": "Fermat42.mul", "code": "theorem mul {a b c k : \u2124} (hk0 : k \u2260 0) :\n    Fermat42 a b c \u2194 Fermat42 (k * a) (k * b) (k ^ 2 * c)", "start": [38, 1], "end": [55, 31], "kind": "commanddeclaration"}, {"full_name": "Fermat42.ne_zero", "code": "theorem ne_zero {a b c : \u2124} (h : Fermat42 a b c) : c \u2260 0", "start": [58, 1], "end": [62, 98], "kind": "commanddeclaration"}, {"full_name": "Fermat42.Minimal", "code": "def Minimal (a b c : \u2124) : Prop :=\n  Fermat42 a b c \u2227 \u2200 a1 b1 c1 : \u2124, Fermat42 a1 b1 c1 \u2192 Int.natAbs c \u2264 Int.natAbs c1", "start": [65, 1], "end": [68, 84], "kind": "commanddeclaration"}, {"full_name": "Fermat42.exists_minimal", "code": "theorem exists_minimal {a b c : \u2124} (h : Fermat42 a b c) : \u2203 a0 b0 c0, Minimal a0 b0 c0", "start": [71, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Fermat42.coprime_of_minimal", "code": "theorem coprime_of_minimal {a b c : \u2124} (h : Minimal a b c) : IsCoprime a b", "start": [88, 1], "end": [105, 65], "kind": "commanddeclaration"}, {"full_name": "Fermat42.minimal_comm", "code": "theorem minimal_comm {a b c : \u2124} : Minimal a b c \u2192 Minimal b a c", "start": [108, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "Fermat42.neg_of_minimal", "code": "theorem neg_of_minimal {a b c : \u2124} : Minimal a b c \u2192 Minimal a b (-c)", "start": [113, 1], "end": [120, 25], "kind": "commanddeclaration"}, {"full_name": "Fermat42.exists_odd_minimal", "code": "theorem exists_odd_minimal {a b c : \u2124} (h : Fermat42 a b c) :\n    \u2203 a0 b0 c0, Minimal a0 b0 c0 \u2227 a0 % 2 = 1", "start": [123, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Fermat42.exists_pos_odd_minimal", "code": "theorem exists_pos_odd_minimal {a b c : \u2124} (h : Fermat42 a b c) :\n    \u2203 a0 b0 c0, Minimal a0 b0 c0 \u2227 a0 % 2 = 1 \u2227 0 < c0", "start": [139, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "Int.coprime_of_sq_sum", "code": "theorem Int.coprime_of_sq_sum {r s : \u2124} (h2 : IsCoprime s r) : IsCoprime (r ^ 2 + s ^ 2) r", "start": [154, 1], "end": [156, 55], "kind": "commanddeclaration"}, {"full_name": "Int.coprime_of_sq_sum'", "code": "theorem Int.coprime_of_sq_sum' {r s : \u2124} (h : IsCoprime r s) :\n    IsCoprime (r ^ 2 + s ^ 2) (r * s)", "start": [159, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "Fermat42.not_minimal", "code": "theorem not_minimal {a b c : \u2124} (h : Minimal a b c) (ha2 : a % 2 = 1) (hc : 0 < c) : False", "start": [169, 1], "end": [296, 53], "kind": "commanddeclaration"}, {"full_name": "not_fermat_42", "code": "theorem not_fermat_42 {a b c : \u2124} (ha : a \u2260 0) (hb : b \u2260 0) : a ^ 4 + b ^ 4 \u2260 c ^ 2", "start": [301, 1], "end": [305, 38], "kind": "commanddeclaration"}, {"full_name": "fermatLastTheoremFour", "code": "theorem fermatLastTheoremFour : FermatLastTheoremFor 4", "start": [308, 1], "end": [312, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Circulant.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.circulant", "code": "def circulant [Sub n] (v : n \u2192 \u03b1) : Matrix n n \u03b1 :=\n  of fun i j => v (i - j)", "start": [43, 1], "end": [47, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_apply", "code": "@[simp]\ntheorem circulant_apply [Sub n] (v : n \u2192 \u03b1) (i j) : circulant v i j = v (i - j)", "start": [51, 1], "end": [52, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_col_zero_eq", "code": "theorem circulant_col_zero_eq [AddGroup n] (v : n \u2192 \u03b1) (i : n) : circulant v i 0 = v i", "start": [55, 1], "end": [56, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_injective", "code": "theorem circulant_injective [AddGroup n] : Injective (circulant : (n \u2192 \u03b1) \u2192 Matrix n n \u03b1)", "start": [59, 1], "end": [62, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_injective", "code": "theorem Fin.circulant_injective : \u2200 n, Injective fun v : Fin n \u2192 \u03b1 => circulant v", "start": [65, 1], "end": [67, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_inj", "code": "@[simp]\ntheorem circulant_inj [AddGroup n] {v w : n \u2192 \u03b1} : circulant v = circulant w \u2194 v = w", "start": [70, 1], "end": [72, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_inj", "code": "@[simp]\ntheorem Fin.circulant_inj {n} {v w : Fin n \u2192 \u03b1} : circulant v = circulant w \u2194 v = w", "start": [75, 1], "end": [77, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_circulant", "code": "theorem transpose_circulant [AddGroup n] (v : n \u2192 \u03b1) :\n    (circulant v)\u1d40 = circulant fun i => v (-i)", "start": [80, 1], "end": [81, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_circulant", "code": "theorem conjTranspose_circulant [Star \u03b1] [AddGroup n] (v : n \u2192 \u03b1) :\n    (circulant v)\u1d34 = circulant (star fun i => v (-i))", "start": [84, 1], "end": [85, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.transpose_circulant", "code": "theorem Fin.transpose_circulant : \u2200 {n} (v : Fin n \u2192 \u03b1), (circulant v)\u1d40 = circulant fun i => v (-i)", "start": [88, 1], "end": [90, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.conjTranspose_circulant", "code": "theorem Fin.conjTranspose_circulant [Star \u03b1] :\n    \u2200 {n} (v : Fin n \u2192 \u03b1), (circulant v)\u1d34 = circulant (star fun i => v (-i))", "start": [93, 1], "end": [96, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_circulant", "code": "theorem map_circulant [Sub n] (v : n \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (circulant v).map f = circulant fun i => f (v i)", "start": [99, 1], "end": [101, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_neg", "code": "theorem circulant_neg [Neg \u03b1] [Sub n] (v : n \u2192 \u03b1) : circulant (-v) = -circulant v", "start": [104, 1], "end": [105, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_zero", "code": "@[simp]\ntheorem circulant_zero (\u03b1 n) [Zero \u03b1] [Sub n] : circulant 0 = (0 : Matrix n n \u03b1)", "start": [108, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_add", "code": "theorem circulant_add [Add \u03b1] [Sub n] (v w : n \u2192 \u03b1) :\n    circulant (v + w) = circulant v + circulant w", "start": [113, 1], "end": [115, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_sub", "code": "theorem circulant_sub [Sub \u03b1] [Sub n] (v w : n \u2192 \u03b1) :\n    circulant (v - w) = circulant v - circulant w", "start": [118, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_mul", "code": "theorem circulant_mul [Semiring \u03b1] [Fintype n] [AddGroup n] (v w : n \u2192 \u03b1) :\n    circulant v * circulant w = circulant (mulVec (circulant v) w)", "start": [123, 1], "end": [131, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_mul", "code": "theorem Fin.circulant_mul [Semiring \u03b1] :\n    \u2200 {n} (v w : Fin n \u2192 \u03b1), circulant v * circulant w = circulant (mulVec (circulant v) w)", "start": [134, 1], "end": [137, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_mul_comm", "code": "theorem circulant_mul_comm [CommSemigroup \u03b1] [AddCommMonoid \u03b1] [Fintype n] [AddCommGroup n]\n    (v w : n \u2192 \u03b1) : circulant v * circulant w = circulant w * circulant v", "start": [140, 1], "end": [149, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_mul_comm", "code": "theorem Fin.circulant_mul_comm [CommSemigroup \u03b1] [AddCommMonoid \u03b1] :\n    \u2200 {n} (v w : Fin n \u2192 \u03b1), circulant v * circulant w = circulant w * circulant v", "start": [152, 1], "end": [155, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_smul", "code": "theorem circulant_smul [Sub n] [SMul R \u03b1] (k : R) (v : n \u2192 \u03b1) :\n    circulant (k \u2022 v) = k \u2022 circulant v", "start": [158, 1], "end": [160, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_single_one", "code": "@[simp]\ntheorem circulant_single_one (\u03b1 n) [Zero \u03b1] [One \u03b1] [DecidableEq n] [AddGroup n] :\n    circulant (Pi.single 0 1 : n \u2192 \u03b1) = (1 : Matrix n n \u03b1)", "start": [163, 1], "end": [167, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_single", "code": "@[simp]\ntheorem circulant_single (n) [Semiring \u03b1] [DecidableEq n] [AddGroup n] [Fintype n] (a : \u03b1) :\n    circulant (Pi.single 0 a : n \u2192 \u03b1) = scalar n a", "start": [170, 1], "end": [174, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_ite", "code": "theorem Fin.circulant_ite (\u03b1) [Zero \u03b1] [One \u03b1] :\n    \u2200 n, circulant (fun i => ite (i.1 = 0) 1 0 : Fin n \u2192 \u03b1) = 1", "start": [177, 1], "end": [185, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_isSymm_iff", "code": "theorem circulant_isSymm_iff [AddGroup n] {v : n \u2192 \u03b1} :\n    (circulant v).IsSymm \u2194 \u2200 i, v (-i) = v i", "start": [188, 1], "end": [191, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_isSymm_iff", "code": "theorem Fin.circulant_isSymm_iff : \u2200 {n} {v : Fin n \u2192 \u03b1}, (circulant v).IsSymm \u2194 \u2200 i, v (-i) = v i", "start": [194, 1], "end": [196, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.circulant_isSymm_apply", "code": "theorem circulant_isSymm_apply [AddGroup n] {v : n \u2192 \u03b1} (h : (circulant v).IsSymm) (i : n) :\n    v (-i) = v i", "start": [199, 1], "end": [202, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.Fin.circulant_isSymm_apply", "code": "theorem Fin.circulant_isSymm_apply {n} {v : Fin n \u2192 \u03b1} (h : (circulant v).IsSymm) (i : Fin n) :\n    v (-i) = v i", "start": [205, 1], "end": [207, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Seq/Parallel.lean", "imports": ["Mathlib/Data/Seq/WSeq.lean", "Mathlib/Init/Data/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Computation.parallel.aux2", "code": "def parallel.aux2 : List (Computation \u03b1) \u2192 Sum \u03b1 (List (Computation \u03b1)) :=\n  List.foldr\n    (fun c o =>\n      match o with\n      | Sum.inl a => Sum.inl a\n      | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))\n    (Sum.inr [])", "start": [29, 1], "end": [35, 17], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel.aux1", "code": "def parallel.aux1 :\n    List (Computation \u03b1) \u00d7 WSeq (Computation \u03b1) \u2192\n      Sum \u03b1 (List (Computation \u03b1) \u00d7 WSeq (Computation \u03b1))\n  | (l, S) =>\n    rmap\n      (fun l' =>\n        match Seq.destruct S with\n        | none => (l', Seq.nil)\n        | some (none, S') => (l', S')\n        | some (some c, S') => (c :: l', S'))\n      (parallel.aux2 l)", "start": [38, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel", "code": "def parallel (S : WSeq (Computation \u03b1)) : Computation \u03b1 :=\n  corec parallel.aux1 ([], S)", "start": [51, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_parallel.aux", "code": "theorem terminates_parallel.aux :\n    \u2200 {l : List (Computation \u03b1)} {S c},\n      c \u2208 l \u2192 Terminates c \u2192 Terminates (corec parallel.aux1 (l, S))", "start": [57, 1], "end": [127, 20], "kind": "commanddeclaration"}, {"full_name": "Computation.terminates_parallel", "code": "theorem terminates_parallel {S : WSeq (Computation \u03b1)} {c} (h : c \u2208 S) [T : Terminates c] :\n    Terminates (parallel S)", "start": [130, 1], "end": [202, 53], "kind": "commanddeclaration"}, {"full_name": "Computation.exists_of_mem_parallel", "code": "theorem exists_of_mem_parallel {S : WSeq (Computation \u03b1)} {a} (h : a \u2208 parallel S) :\n    \u2203 c \u2208 S, a \u2208 c", "start": [205, 1], "end": [282, 40], "kind": "commanddeclaration"}, {"full_name": "Computation.map_parallel", "code": "theorem map_parallel (f : \u03b1 \u2192 \u03b2) (S) : map f (parallel S) = parallel (S.map (map f))", "start": [285, 1], "end": [312, 31], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel_empty", "code": "theorem parallel_empty (S : WSeq (Computation \u03b1)) (h : S.head ~> none) : parallel S = empty _", "start": [315, 1], "end": [320, 19], "kind": "commanddeclaration"}, {"full_name": "Computation.parallelRec", "code": "def parallelRec {S : WSeq (Computation \u03b1)} (C : \u03b1 \u2192 Sort v) (H : \u2200 s \u2208 S, \u2200 a \u2208 s, C a) {a}\n    (h : a \u2208 parallel S) : C a := by\n  let T : WSeq (Computation (\u03b1 \u00d7 Computation \u03b1)) := S.map fun c => c.map fun a => (a, c)\n  have : S = T.map (map fun c => c.1) := by\n    rw [\u2190 WSeq.map_comp]\n    refine' (WSeq.map_id _).symm.trans (congr_arg (fun f => WSeq.map f S) _)\n    funext c\n    dsimp [id, Function.comp]\n    rw [\u2190 map_comp]\n    exact (map_id _).symm\n  have pe := congr_arg parallel this\n  rw [\u2190 map_parallel] at pe\n  have h' := h\n  rw [pe] at h'\n  haveI : Terminates (parallel T) := (terminates_map_iff _ _).1 \u27e8\u27e8_, h'\u27e9\u27e9\n  induction' e : get (parallel T) with a' c\n  have : a \u2208 c \u2227 c \u2208 S := by\n    rcases exists_of_mem_map h' with \u27e8d, dT, cd\u27e9\n    rw [get_eq_of_mem _ dT] at e\n    cases e\n    dsimp at cd\n    cases cd\n    rcases exists_of_mem_parallel dT with \u27e8d', dT', ad'\u27e9\n    rcases WSeq.exists_of_mem_map dT' with \u27e8c', cs', e'\u27e9\n    rw [\u2190 e'] at ad'\n    rcases exists_of_mem_map ad' with \u27e8a', ac', e'\u27e9\n    injection e' with i1 i2\n    constructor\n    rwa [i1, i2] at ac'\n    rwa [i2] at cs'\n  cases' this with ac cs\n  apply H _ cs _ ac", "start": [324, 1], "end": [355, 20], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel_promises", "code": "theorem parallel_promises {S : WSeq (Computation \u03b1)} {a} (H : \u2200 s \u2208 S, s ~> a) : parallel S ~> a", "start": [358, 1], "end": [361, 12], "kind": "commanddeclaration"}, {"full_name": "Computation.mem_parallel", "code": "theorem mem_parallel {S : WSeq (Computation \u03b1)} {a} (H : \u2200 s \u2208 S, s ~> a) {c} (cs : c \u2208 S)\n    (ac : a \u2208 c) : a \u2208 parallel S", "start": [364, 1], "end": [368, 48], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel_congr_lem", "code": "theorem parallel_congr_lem {S T : WSeq (Computation \u03b1)} {a} (H : S.LiftRel Equiv T) :\n    (\u2200 s \u2208 S, s ~> a) \u2194 \u2200 t \u2208 T, t ~> a", "start": [371, 1], "end": [378, 39], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel_congr_left", "code": "theorem parallel_congr_left {S T : WSeq (Computation \u03b1)} {a} (h1 : \u2200 s \u2208 S, s ~> a)\n    (H : S.LiftRel Equiv T) : parallel S ~ parallel T", "start": [382, 1], "end": [403, 29], "kind": "commanddeclaration"}, {"full_name": "Computation.parallel_congr_right", "code": "theorem parallel_congr_right {S T : WSeq (Computation \u03b1)} {a} (h2 : \u2200 t \u2208 T, t ~> a)\n    (H : S.LiftRel Equiv T) : parallel S ~ parallel T", "start": [406, 1], "end": [408, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Concept.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "intentClosure", "code": "def intentClosure (s : Set \u03b1) : Set \u03b2 :=\n  { b | \u2200 \u2983a\u2984, a \u2208 s \u2192 r a b }", "start": [48, 1], "end": [51, 31], "kind": "commanddeclaration"}, {"full_name": "extentClosure", "code": "def extentClosure (t : Set \u03b2) : Set \u03b1 :=\n  { a | \u2200 \u2983b\u2984, b \u2208 t \u2192 r a b }", "start": [54, 1], "end": [57, 31], "kind": "commanddeclaration"}, {"full_name": "subset_intentClosure_iff_subset_extentClosure", "code": "theorem subset_intentClosure_iff_subset_extentClosure :\n    t \u2286 intentClosure r s \u2194 s \u2286 extentClosure r t", "start": [62, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "gc_intentClosure_extentClosure", "code": "theorem gc_intentClosure_extentClosure :\n    GaloisConnection (toDual \u2218 intentClosure r) (extentClosure r \u2218 ofDual)", "start": [69, 1], "end": [71, 48], "kind": "commanddeclaration"}, {"full_name": "intentClosure_swap", "code": "theorem intentClosure_swap (t : Set \u03b2) : intentClosure (swap r) t = extentClosure r t", "start": [74, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "extentClosure_swap", "code": "theorem extentClosure_swap (s : Set \u03b1) : extentClosure (swap r) s = intentClosure r s", "start": [78, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "intentClosure_empty", "code": "@[simp]\ntheorem intentClosure_empty : intentClosure r \u2205 = univ", "start": [82, 1], "end": [84, 42], "kind": "commanddeclaration"}, {"full_name": "extentClosure_empty", "code": "@[simp]\ntheorem extentClosure_empty : extentClosure r \u2205 = univ", "start": [87, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "intentClosure_union", "code": "@[simp]\ntheorem intentClosure_union (s\u2081 s\u2082 : Set \u03b1) :\n    intentClosure r (s\u2081 \u222a s\u2082) = intentClosure r s\u2081 \u2229 intentClosure r s\u2082", "start": [92, 1], "end": [95, 32], "kind": "commanddeclaration"}, {"full_name": "extentClosure_union", "code": "@[simp]\ntheorem extentClosure_union (t\u2081 t\u2082 : Set \u03b2) :\n    extentClosure r (t\u2081 \u222a t\u2082) = extentClosure r t\u2081 \u2229 extentClosure r t\u2082", "start": [98, 1], "end": [101, 28], "kind": "commanddeclaration"}, {"full_name": "intentClosure_iUnion", "code": "@[simp]\ntheorem intentClosure_iUnion (f : \u03b9 \u2192 Set \u03b1) :\n    intentClosure r (\u22c3 i, f i) = \u22c2 i, intentClosure r (f i)", "start": [104, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "extentClosure_iUnion", "code": "@[simp]\ntheorem extentClosure_iUnion (f : \u03b9 \u2192 Set \u03b2) :\n    extentClosure r (\u22c3 i, f i) = \u22c2 i, extentClosure r (f i)", "start": [110, 1], "end": [113, 27], "kind": "commanddeclaration"}, {"full_name": "intentClosure_iUnion\u2082", "code": "theorem intentClosure_iUnion\u2082 (f : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    intentClosure r (\u22c3 (i) (j), f i j) = \u22c2 (i) (j), intentClosure r (f i j)", "start": [120, 1], "end": [122, 45], "kind": "commanddeclaration"}, {"full_name": "extentClosure_iUnion\u2082", "code": "theorem extentClosure_iUnion\u2082 (f : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    extentClosure r (\u22c3 (i) (j), f i j) = \u22c2 (i) (j), extentClosure r (f i j)", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "subset_extentClosure_intentClosure", "code": "theorem subset_extentClosure_intentClosure (s : Set \u03b1) :\n    s \u2286 extentClosure r (intentClosure r s)", "start": [134, 1], "end": [136, 46], "kind": "commanddeclaration"}, {"full_name": "subset_intentClosure_extentClosure", "code": "theorem subset_intentClosure_extentClosure (t : Set \u03b2) :\n    t \u2286 intentClosure r (extentClosure r t)", "start": [139, 1], "end": [141, 41], "kind": "commanddeclaration"}, {"full_name": "intentClosure_extentClosure_intentClosure", "code": "@[simp]\ntheorem intentClosure_extentClosure_intentClosure (s : Set \u03b1) :\n    intentClosure r (extentClosure r <| intentClosure r s) = intentClosure r s", "start": [144, 1], "end": [147, 50], "kind": "commanddeclaration"}, {"full_name": "extentClosure_intentClosure_extentClosure", "code": "@[simp]\ntheorem extentClosure_intentClosure_extentClosure (t : Set \u03b2) :\n    extentClosure r (intentClosure r <| extentClosure r t) = extentClosure r t", "start": [150, 1], "end": [153, 48], "kind": "commanddeclaration"}, {"full_name": "intentClosure_anti", "code": "theorem intentClosure_anti : Antitone (intentClosure r)", "start": [156, 1], "end": [157, 48], "kind": "commanddeclaration"}, {"full_name": "extentClosure_anti", "code": "theorem extentClosure_anti : Antitone (extentClosure r)", "start": [160, 1], "end": [161, 23], "kind": "commanddeclaration"}, {"full_name": "Concept", "code": "structure Concept extends Set \u03b1 \u00d7 Set \u03b2 where\n  \n  closure_fst : intentClosure r fst = snd\n  \n  closure_snd : extentClosure r snd = fst", "start": [169, 1], "end": [176, 42], "kind": "commanddeclaration"}, {"full_name": "Concept.ext", "code": "@[ext]\ntheorem ext (h : c.fst = d.fst) : c = d", "start": [187, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.ext'", "code": "theorem ext' (h : c.snd = d.snd) : c = d", "start": [196, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.fst_injective", "code": "theorem fst_injective : Injective fun c : Concept \u03b1 \u03b2 r => c.fst", "start": [204, 1], "end": [204, 83], "kind": "commanddeclaration"}, {"full_name": "Concept.snd_injective", "code": "theorem snd_injective : Injective fun c : Concept \u03b1 \u03b2 r => c.snd", "start": [207, 1], "end": [207, 84], "kind": "commanddeclaration"}, {"full_name": "Concept.instSupConcept", "code": "instance instSupConcept : Sup (Concept \u03b1 \u03b2 r) :=\n  \u27e8fun c d =>\n    { fst := extentClosure r (c.snd \u2229 d.snd)\n      snd := c.snd \u2229 d.snd\n      closure_fst := by\n        rw [\u2190 c.closure_fst, \u2190 d.closure_fst, \u2190 intentClosure_union,\n          intentClosure_extentClosure_intentClosure]\n      closure_snd := rfl }\u27e9", "start": [210, 1], "end": [217, 28], "kind": "commanddeclaration"}, {"full_name": "Concept.instInfConcept", "code": "instance instInfConcept : Inf (Concept \u03b1 \u03b2 r) :=\n  \u27e8fun c d =>\n    { fst := c.fst \u2229 d.fst\n      snd := intentClosure r (c.fst \u2229 d.fst)\n      closure_fst := rfl\n      closure_snd := by\n        rw [\u2190 c.closure_snd, \u2190 d.closure_snd, \u2190 extentClosure_union,\n          extentClosure_intentClosure_extentClosure] }\u27e9", "start": [219, 1], "end": [226, 56], "kind": "commanddeclaration"}, {"full_name": "Concept.instSemilatticeInfConcept", "code": "instance instSemilatticeInfConcept : SemilatticeInf (Concept \u03b1 \u03b2 r) :=\n  (fst_injective.semilatticeInf _) fun _ _ => rfl", "start": [228, 1], "end": [229, 50], "kind": "commanddeclaration"}, {"full_name": "Concept.fst_subset_fst_iff", "code": "@[simp]\ntheorem fst_subset_fst_iff : c.fst \u2286 d.fst \u2194 c \u2264 d", "start": [231, 1], "end": [233, 10], "kind": "commanddeclaration"}, {"full_name": "Concept.fst_ssubset_fst_iff", "code": "@[simp]\ntheorem fst_ssubset_fst_iff : c.fst \u2282 d.fst \u2194 c < d", "start": [236, 1], "end": [238, 10], "kind": "commanddeclaration"}, {"full_name": "Concept.snd_subset_snd_iff", "code": "@[simp]\ntheorem snd_subset_snd_iff : c.snd \u2286 d.snd \u2194 d \u2264 c", "start": [241, 1], "end": [247, 33], "kind": "commanddeclaration"}, {"full_name": "Concept.snd_ssubset_snd_iff", "code": "@[simp]\ntheorem snd_ssubset_snd_iff : c.snd \u2282 d.snd \u2194 d < c", "start": [250, 1], "end": [252, 95], "kind": "commanddeclaration"}, {"full_name": "Concept.strictMono_fst", "code": "theorem strictMono_fst : StrictMono (Prod.fst \u2218 toProd : Concept \u03b1 \u03b2 r \u2192 Set \u03b1)", "start": [255, 1], "end": [256, 24], "kind": "commanddeclaration"}, {"full_name": "Concept.strictAnti_snd", "code": "theorem strictAnti_snd : StrictAnti (Prod.snd \u2218 toProd : Concept \u03b1 \u03b2 r \u2192 Set \u03b2)", "start": [259, 1], "end": [260, 24], "kind": "commanddeclaration"}, {"full_name": "Concept.instLatticeConcept", "code": "instance instLatticeConcept : Lattice (Concept \u03b1 \u03b2 r) :=\n  { Concept.instSemilatticeInfConcept with\n    sup := (\u00b7 \u2294 \u00b7)\n    le_sup_left := fun c d => snd_subset_snd_iff.1 <| inter_subset_left _ _\n    le_sup_right := fun c d => snd_subset_snd_iff.1 <| inter_subset_right _ _\n    sup_le := fun c d e => by\n      simp_rw [\u2190 snd_subset_snd_iff]\n      exact subset_inter }", "start": [263, 1], "end": [270, 27], "kind": "commanddeclaration"}, {"full_name": "Concept.instBoundedOrderConcept", "code": "instance instBoundedOrderConcept : BoundedOrder (Concept \u03b1 \u03b2 r) where\n  top := \u27e8\u27e8univ, intentClosure r univ\u27e9, rfl, eq_univ_of_forall fun _ _ hb => hb trivial\u27e9\n  le_top _ := subset_univ _\n  bot := \u27e8\u27e8extentClosure r univ, univ\u27e9, eq_univ_of_forall fun _ _ ha => ha trivial, rfl\u27e9\n  bot_le _ := snd_subset_snd_iff.1 <| subset_univ _", "start": [272, 1], "end": [276, 52], "kind": "commanddeclaration"}, {"full_name": "Concept.top_fst", "code": "@[simp]\ntheorem top_fst : (\u22a4 : Concept \u03b1 \u03b2 r).fst = univ", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.top_snd", "code": "@[simp]\ntheorem top_snd : (\u22a4 : Concept \u03b1 \u03b2 r).snd = intentClosure r univ", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.bot_fst", "code": "@[simp]\ntheorem bot_fst : (\u22a5 : Concept \u03b1 \u03b2 r).fst = extentClosure r univ", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.bot_snd", "code": "@[simp]\ntheorem bot_snd : (\u22a5 : Concept \u03b1 \u03b2 r).snd = univ", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sup_fst", "code": "@[simp]\ntheorem sup_fst (c d : Concept \u03b1 \u03b2 r) : (c \u2294 d).fst = extentClosure r (c.snd \u2229 d.snd)", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sup_snd", "code": "@[simp]\ntheorem sup_snd (c d : Concept \u03b1 \u03b2 r) : (c \u2294 d).snd = c.snd \u2229 d.snd", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.inf_fst", "code": "@[simp]\ntheorem inf_fst (c d : Concept \u03b1 \u03b2 r) : (c \u2293 d).fst = c.fst \u2229 d.fst", "start": [337, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.inf_snd", "code": "@[simp]\ntheorem inf_snd (c d : Concept \u03b1 \u03b2 r) : (c \u2293 d).snd = intentClosure r (c.fst \u2229 d.fst)", "start": [342, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sSup_fst", "code": "@[simp]\ntheorem sSup_fst (S : Set (Concept \u03b1 \u03b2 r)) :\n    (sSup S).fst = extentClosure r (\u22c2 c \u2208 S, (c : Concept _ _ _).snd)", "start": [347, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sSup_snd", "code": "@[simp]\ntheorem sSup_snd (S : Set (Concept \u03b1 \u03b2 r)) : (sSup S).snd = \u22c2 c \u2208 S, (c : Concept _ _ _).snd", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sInf_fst", "code": "@[simp]\ntheorem sInf_fst (S : Set (Concept \u03b1 \u03b2 r)) : (sInf S).fst = \u22c2 c \u2208 S, (c : Concept _ _ _).fst", "start": [358, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.sInf_snd", "code": "@[simp]\ntheorem sInf_snd (S : Set (Concept \u03b1 \u03b2 r)) :\n    (sInf S).snd = intentClosure r (\u22c2 c \u2208 S, (c : Concept _ _ _).fst)", "start": [363, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "Concept.swap", "code": "@[simps]\ndef swap (c : Concept \u03b1 \u03b2 r) : Concept \u03b2 \u03b1 (swap r) :=\n  \u27e8c.toProd.swap, c.closure_snd, c.closure_fst\u27e9", "start": [372, 1], "end": [375, 48], "kind": "commanddeclaration"}, {"full_name": "Concept.swap_swap", "code": "@[simp]\ntheorem swap_swap (c : Concept \u03b1 \u03b2 r) : c.swap.swap = c", "start": [379, 1], "end": [381, 10], "kind": "commanddeclaration"}, {"full_name": "Concept.swap_le_swap_iff", "code": "@[simp]\ntheorem swap_le_swap_iff : c.swap \u2264 d.swap \u2194 d \u2264 c", "start": [384, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "Concept.swap_lt_swap_iff", "code": "@[simp]\ntheorem swap_lt_swap_iff : c.swap < d.swap \u2194 d < c", "start": [389, 1], "end": [391, 22], "kind": "commanddeclaration"}, {"full_name": "Concept.swapEquiv", "code": "@[simps]\ndef swapEquiv : (Concept \u03b1 \u03b2 r)\u1d52\u1d48 \u2243o Concept \u03b2 \u03b1 (Function.swap r) where\n  toFun := swap \u2218 ofDual\n  invFun := toDual \u2218 swap\n  left_inv := swap_swap\n  right_inv := swap_swap\n  map_rel_iff' := swap_le_swap_iff", "start": [394, 1], "end": [401, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Derivation.lean", "imports": ["Mathlib/RingTheory/Derivation/Basic.lean", "Mathlib/Data/Polynomial/Derivative.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.derivative'", "code": "@[simps]\ndef derivative' : Derivation R R[X] R[X] where\n  toFun := derivative\n  map_add' _ _ := derivative_add\n  map_smul' := derivative_smul\n  map_one_eq_zero' := derivative_one\n  leibniz' f g := by simp [mul_comm, add_comm, derivative_mul]", "start": [27, 1], "end": [34, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivation_C", "code": "@[simp]\ntheorem derivation_C (D : Derivation R R[X] A) (a : R) : D (C a) = 0", "start": [38, 1], "end": [40, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_smul_derivation_apply", "code": "@[simp]\ntheorem C_smul_derivation_apply (D : Derivation R R[X] A) (a : R) (f : R[X]) :\n    C a \u2022 D f = a \u2022 D f", "start": [42, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivation_ext", "code": "@[ext]\ntheorem derivation_ext {D\u2081 D\u2082 : Derivation R R[X] A} (h : D\u2081 X = D\u2082 X) : D\u2081 = D\u2082", "start": [48, 1], "end": [51, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mkDerivation", "code": "def mkDerivation : A \u2192\u2097[R] Derivation R R[X] A where\n  toFun := fun a \u21a6 (LinearMap.toSpanSingleton R[X] A a).compDer derivative'\n  map_add' := fun a b \u21a6 by ext; simp\n  map_smul' := fun t a \u21a6 by ext; simp", "start": [57, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mkDerivation_apply", "code": "lemma mkDerivation_apply (a : A) (f : R[X]) :\n    mkDerivation R a f = derivative f \u2022 a := by\n  rfl", "start": [63, 1], "end": [65, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.mkDerivation_X", "code": "@[simp]\ntheorem mkDerivation_X (a : A) : mkDerivation R a X = a", "start": [67, 1], "end": [68, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mkDerivation_one_eq_derivative'", "code": "lemma mkDerivation_one_eq_derivative' : mkDerivation R (1 : R[X]) = derivative' := by\n  ext : 1\n  simp [derivative']", "start": [70, 1], "end": [72, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.mkDerivation_one_eq_derivative", "code": "lemma mkDerivation_one_eq_derivative (f : R[X]) : mkDerivation R (1 : R[X]) f = derivative f := by\n  rw [mkDerivation_one_eq_derivative']\n  rfl", "start": [74, 1], "end": [76, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.mkDerivationEquiv", "code": "def mkDerivationEquiv : A \u2243\u2097[R] Derivation R R[X] A :=\n  LinearEquiv.symm <|\n    { invFun := mkDerivation R\n      toFun := fun D => D X\n      map_add' := fun _ _ => rfl\n      map_smul' := fun _ _ => rfl\n      left_inv := fun _ => derivation_ext <| mkDerivation_X _ _\n      right_inv := fun _ => mkDerivation_X _ _ }", "start": [78, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mkDerivationEquiv_apply", "code": "@[simp] lemma mkDerivationEquiv_apply (a : A) :\n    mkDerivationEquiv R a = mkDerivation R a := by\n  rfl", "start": [88, 1], "end": [90, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.mkDerivationEquiv_symm_apply", "code": "@[simp] lemma mkDerivationEquiv_symm_apply (D : Derivation R R[X] A) :\n    (mkDerivationEquiv R).symm D = D X := rfl", "start": [92, 1], "end": [93, 46], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/LocallyConvex/WeakDual.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "Mathlib/Topology/Algebra/Module/WeakDual.lean", "Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.toSeminorm", "code": "def toSeminorm (f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c) : Seminorm \ud835\udd5c E :=\n  (normSeminorm \ud835\udd5c \ud835\udd5c).comp f", "start": [53, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toSeminorm", "code": "theorem coe_toSeminorm {f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c} : \u21d1f.toSeminorm = fun x => \u2016f x\u2016", "start": [59, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSeminorm_apply", "code": "@[simp]\ntheorem toSeminorm_apply {f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c} {x : E} : f.toSeminorm x = \u2016f x\u2016", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSeminorm_ball_zero", "code": "theorem toSeminorm_ball_zero {f : E \u2192\u2097[\ud835\udd5c] \ud835\udd5c} {r : \u211d} :\n    Seminorm.ball f.toSeminorm 0 r = { x : E | \u2016f x\u2016 < r }", "start": [68, 1], "end": [70, 54], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSeminorm_comp", "code": "theorem toSeminorm_comp (f : F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) (g : E \u2192\u2097[\ud835\udd5c] F) :\n    f.toSeminorm.comp g = (f.comp g).toSeminorm", "start": [73, 1], "end": [76, 83], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSeminormFamily", "code": "def toSeminormFamily (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) : SeminormFamily \ud835\udd5c E F := fun y =>\n  (B.flip y).toSeminorm", "start": [79, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSeminormFamily_apply", "code": "@[simp]\ntheorem toSeminormFamily_apply {B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c} {x y} : (B.toSeminormFamily y) x = \u2016B x y\u2016", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.hasBasis_weakBilin", "code": "theorem LinearMap.hasBasis_weakBilin (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :\n    (\ud835\udcdd (0 : WeakBilin B)).HasBasis B.toSeminormFamily.basisSets _root_.id", "start": [101, 1], "end": [137, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.weakBilin_withSeminorms", "code": "theorem LinearMap.weakBilin_withSeminorms (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :\n    WithSeminorms (LinearMap.toSeminormFamily B : F \u2192 Seminorm \ud835\udd5c (WeakBilin B))", "start": [140, 1], "end": [142, 66], "kind": "commanddeclaration"}, {"full_name": "WeakBilin.locallyConvexSpace", "code": "instance WeakBilin.locallyConvexSpace {B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c} :\n    LocallyConvexSpace \u211d (WeakBilin B) :=\n  B.weakBilin_withSeminorms.toLocallyConvexSpace", "start": [153, 1], "end": [155, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/Functor.lean", "imports": ["Mathlib/Algebra/Homology/HomologicalComplex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HomologicalComplex.asFunctor", "code": "@[simps obj map]\ndef asFunctor {T : Type*} [Category T] (C : HomologicalComplex (T \u2964 V) c) :\n    T \u2964 HomologicalComplex V c where\n  obj t :=\n    { X := fun i => (C.X i).obj t\n      d := fun i j => (C.d i j).app t\n      d_comp_d' := fun i j k _ _ => by\n        have := C.d_comp_d i j k\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t\n      shape := fun i j h => by\n        have := C.shape _ _ h\n        rw [NatTrans.ext_iff, Function.funext_iff] at this\n        exact this t }\n  map h :=\n    { f := fun i => (C.X i).map h\n      comm' := fun i j _ => NatTrans.naturality _ _ }\n  map_id t := by\n    ext i\n    dsimp\n    rw [(C.X i).map_id]\n  map_comp h\u2081 h\u2082 := by\n    ext i\n    dsimp\n    rw [Functor.map_comp]", "start": [34, 1], "end": [59, 26], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.complexOfFunctorsToFunctorToComplex", "code": "@[simps]\ndef complexOfFunctorsToFunctorToComplex {T : Type*} [Category T] :\n    HomologicalComplex (T \u2964 V) c \u2964 T \u2964 HomologicalComplex V c where\n  obj C := C.asFunctor\n  map f :=\n    { app := fun t =>\n        { f := fun i => (f.f i).app t\n          comm' := fun i j _ => NatTrans.congr_app (f.comm i j) t }\n      naturality := fun t t' g => by\n        ext i\n        exact (f.f i).naturality g }", "start": [63, 1], "end": [74, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/Zero.lean", "imports": ["Mathlib/CategoryTheory/Conj.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "Mathlib/CategoryTheory/PUnit.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Closed/Cartesian.lean"], "premises": [{"full_name": "CategoryTheory.uniqueHomsetOfInitialIsoTerminal", "code": "def uniqueHomsetOfInitialIsoTerminal [HasInitial C] (i : \u22a5_ C \u2245 \u22a4_ C) (X Y : C) : Unique (X \u27f6 Y) :=\n  Equiv.unique <|\n    calc\n      (X \u27f6 Y) \u2243 (X \u2a2f \u22a4_ C \u27f6 Y) := Iso.homCongr (prod.rightUnitor _).symm (Iso.refl _)\n      _ \u2243 (X \u2a2f \u22a5_ C \u27f6 Y) := (Iso.homCongr (prod.mapIso (Iso.refl _) i.symm) (Iso.refl _))\n      _ \u2243 (\u22a5_ C \u27f6 Y ^^ X) := (exp.adjunction _).homEquiv _ _", "start": [38, 1], "end": [46, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uniqueHomsetOfZero", "code": "def uniqueHomsetOfZero [HasZeroObject C] (X Y : C) : Unique (X \u27f6 Y) := by\n  haveI : HasInitial C := HasZeroObject.hasInitial\n  apply uniqueHomsetOfInitialIsoTerminal _ X Y\n  refine' \u27e8default, (default : \u22a4_ C \u27f6 0) \u226b default, _, _\u27e9 <;> simp", "start": [51, 1], "end": [55, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivPUnit", "code": "def equivPUnit [HasZeroObject C] : C \u224c Discrete PUnit.{w + 1} :=\n  Equivalence.mk (Functor.star C) (Functor.fromPUnit 0)\n    (NatIso.ofComponents\n      (fun X =>\n        { hom := default\n          inv := default })\n      fun f => Subsingleton.elim _ _)\n    (Functor.punitExt _ _)", "start": [60, 1], "end": [70, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/QuaternionExponential.lean", "imports": ["Mathlib/Analysis/NormedSpace/Exponential.lean", "Mathlib/Analysis/Quaternion.lean", "Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quaternion.exp_coe", "code": "@[simp, norm_cast]\ntheorem exp_coe (r : \u211d) : exp \u211d (r : \u210d[\u211d]) = \u2191(exp \u211d r)", "start": [32, 1], "end": [34, 69], "kind": "commanddeclaration"}, {"full_name": "Quaternion.hasSum_expSeries_of_imaginary", "code": "theorem hasSum_expSeries_of_imaginary {q : Quaternion \u211d} (hq : q.re = 0) {c s : \u211d}\n    (hc : HasSum (fun n => (-1 : \u211d) ^ n * \u2016q\u2016 ^ (2 * n) / (2 * n)!) c)\n    (hs : HasSum (fun n => (-1 : \u211d) ^ n * \u2016q\u2016 ^ (2 * n + 1) / (2 * n + 1)!) s) :\n    HasSum (fun n => expSeries \u211d (Quaternion \u211d) n fun _ => q) (\u2191c + (s / \u2016q\u2016) \u2022 q)", "start": [39, 1], "end": [88, 11], "kind": "commanddeclaration"}, {"full_name": "Quaternion.exp_of_re_eq_zero", "code": "theorem exp_of_re_eq_zero (q : Quaternion \u211d) (hq : q.re = 0) :\n    exp \u211d q = \u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q", "start": [91, 1], "end": [97, 81], "kind": "commanddeclaration"}, {"full_name": "Quaternion.exp_eq", "code": "theorem exp_eq (q : Quaternion \u211d) :\n    exp \u211d q = exp \u211d q.re \u2022 (\u2191(Real.cos \u2016q.im\u2016) + (Real.sin \u2016q.im\u2016 / \u2016q.im\u2016) \u2022 q.im)", "start": [100, 1], "end": [105, 41], "kind": "commanddeclaration"}, {"full_name": "Quaternion.re_exp", "code": "theorem re_exp (q : \u210d[\u211d]) : (exp \u211d q).re = exp \u211d q.re * Real.cos \u2016q - q.re\u2016", "start": [108, 1], "end": [108, 96], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_exp", "code": "theorem im_exp (q : \u210d[\u211d]) : (exp \u211d q).im = (exp \u211d q.re * (Real.sin \u2016q.im\u2016 / \u2016q.im\u2016)) \u2022 q.im", "start": [111, 1], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_exp", "code": "theorem normSq_exp (q : \u210d[\u211d]) : normSq (exp \u211d q) = exp \u211d q.re ^ 2", "start": [115, 1], "end": [129, 66], "kind": "commanddeclaration"}, {"full_name": "Quaternion.norm_exp", "code": "@[simp]\ntheorem norm_exp (q : \u210d[\u211d]) : \u2016exp \u211d q\u2016 = \u2016exp \u211d q.re\u2016", "start": [133, 1], "end": [138, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/HahnBanach/SeparatingDual.lean", "imports": ["Mathlib/Analysis/NormedSpace/HahnBanach/Extension.lean", "Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SeparatingDual", "code": "class SeparatingDual (R V : Type*) [Ring R] [AddCommGroup V] [TopologicalSpace V]\n    [TopologicalSpace R] [Module R V] : Prop :=\n  \n  exists_ne_zero' : \u2200 (x : V), x \u2260 0 \u2192 \u2203 f : V \u2192L[R] R, f x \u2260 0", "start": [23, 1], "end": [28, 64], "kind": "commanddeclaration"}, {"full_name": "SeparatingDual.exists_ne_zero", "code": "lemma exists_ne_zero {x : V} (hx : x \u2260 0) :\n    \u2203 f : V \u2192L[R] R, f x \u2260 0 :=\n  exists_ne_zero' x hx", "start": [50, 1], "end": [52, 23], "kind": "mathlibtacticlemma"}, {"full_name": "SeparatingDual.exists_separating_of_ne", "code": "theorem exists_separating_of_ne {x y : V} (h : x \u2260 y) :\n    \u2203 f : V \u2192L[R] R, f x \u2260 f y", "start": [54, 1], "end": [57, 45], "kind": "commanddeclaration"}, {"full_name": "SeparatingDual.t1Space", "code": "protected theorem t1Space [T1Space R] : T1Space V", "start": [59, 1], "end": [62, 82], "kind": "commanddeclaration"}, {"full_name": "SeparatingDual.t2Space", "code": "protected theorem t2Space [T2Space R] : T2Space V", "start": [64, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "SeparatingDual.exists_eq_one", "code": "lemma exists_eq_one {x : V} (hx : x \u2260 0) :\n    \u2203 f : V \u2192L[R] R, f x = 1 := by\n  rcases exists_ne_zero (R := R) hx with \u27e8f, hf\u27e9\n  exact \u27e8(f x)\u207b\u00b9 \u2022 f, inv_mul_cancel hf\u27e9", "start": [76, 1], "end": [79, 41], "kind": "mathlibtacticlemma"}, {"full_name": "SeparatingDual.exists_eq_one_ne_zero_of_ne_zero_pair", "code": "theorem exists_eq_one_ne_zero_of_ne_zero_pair {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    \u2203 f : V \u2192L[R] R, f x = 1 \u2227 f y \u2260 0", "start": [81, 1], "end": [89, 54], "kind": "commanddeclaration"}, {"full_name": "SeparatingDual.exists_continuousLinearEquiv_apply_eq", "code": "theorem exists_continuousLinearEquiv_apply_eq [ContinuousSMul R V]\n    {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    \u2203 A : V \u2243L[R] V, A x = y", "start": [91, 1], "end": [119, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/PerfectPairing.lean", "imports": ["Mathlib/LinearAlgebra/Dual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearEquiv.flip", "code": "noncomputable def flip : M \u2243\u2097[R] Dual R N :=\n(evalEquiv R M).trans e.dualMap", "start": [33, 1], "end": [36, 32], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toLinearMap_flip", "code": "@[simp] lemma coe_toLinearMap_flip : e.flip = (\u2191e : N \u2192\u2097[R] Dual R M).flip := rfl", "start": [38, 1], "end": [38, 82], "kind": "mathlibtacticlemma"}, {"full_name": "LinearEquiv.flip_apply", "code": "@[simp] lemma flip_apply (m : M) (n : N) : e.flip m n = e n m := rfl", "start": [40, 1], "end": [40, 69], "kind": "mathlibtacticlemma"}, {"full_name": "LinearEquiv.symm_flip", "code": "@[simp] lemma symm_flip : e.flip.symm = e.symm.dualMap.trans (evalEquiv R M).symm := rfl", "start": [42, 1], "end": [42, 89], "kind": "mathlibtacticlemma"}, {"full_name": "LinearEquiv.trans_dualMap_symm_flip", "code": "lemma trans_dualMap_symm_flip : e.trans e.flip.symm.dualMap = Dual.eval R N := by ext; simp", "start": [44, 1], "end": [44, 92], "kind": "mathlibtacticlemma"}, {"full_name": "LinearEquiv.isReflexive_of_equiv_dual_of_isReflexive", "code": "lemma isReflexive_of_equiv_dual_of_isReflexive : IsReflexive R N := by\n  constructor\n  rw [\u2190 trans_dualMap_symm_flip e]\n  exact LinearEquiv.bijective _", "start": [46, 1], "end": [50, 32], "kind": "mathlibtacticlemma"}, {"full_name": "LinearEquiv.flip_flip", "code": "@[simp] lemma flip_flip (h : IsReflexive R N := isReflexive_of_equiv_dual_of_isReflexive e) :\n  e.flip.flip = e :=\nby ext; rfl", "start": [52, 1], "end": [54, 12], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Finset/PImage.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/Data/Part.lean", "Mathlib/Data/Finset/Option.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Part.toFinset", "code": "def toFinset (o : Part \u03b1) [Decidable o.Dom] : Finset \u03b1 :=\n  o.toOption.toFinset", "start": [28, 1], "end": [30, 22], "kind": "commanddeclaration"}, {"full_name": "Part.mem_toFinset", "code": "@[simp]\ntheorem mem_toFinset {o : Part \u03b1} [Decidable o.Dom] {x : \u03b1} : x \u2208 o.toFinset \u2194 x \u2208 o", "start": [33, 1], "end": [35, 18], "kind": "commanddeclaration"}, {"full_name": "Part.toFinset_none", "code": "@[simp]\ntheorem toFinset_none [Decidable (none : Part \u03b1).Dom] : none.toFinset = (\u2205 : Finset \u03b1)", "start": [38, 1], "end": [40, 18], "kind": "commanddeclaration"}, {"full_name": "Part.toFinset_some", "code": "@[simp]\ntheorem toFinset_some {a : \u03b1} [Decidable (some a).Dom] : (some a).toFinset = {a}", "start": [43, 1], "end": [45, 18], "kind": "commanddeclaration"}, {"full_name": "Part.coe_toFinset", "code": "@[simp]\ntheorem coe_toFinset (o : Part \u03b1) [Decidable o.Dom] : (o.toFinset : Set \u03b1) = { x | x \u2208 o }", "start": [48, 1], "end": [50, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage", "code": "def pimage (f : \u03b1 \u2192. \u03b2) [\u2200 x, Decidable (f x).Dom] (s : Finset \u03b1) : Finset \u03b2 :=\n  s.biUnion fun x => (f x).toFinset", "start": [60, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_pimage", "code": "@[simp]\ntheorem mem_pimage : b \u2208 s.pimage f \u2194 \u2203 a \u2208 s, b \u2208 f a", "start": [65, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_pimage", "code": "@[simp, norm_cast]\ntheorem coe_pimage : (s.pimage f : Set \u03b2) = f.image s", "start": [70, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_some", "code": "@[simp]\ntheorem pimage_some (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) [\u2200 x, Decidable (Part.some <| f x).Dom] :\n    (s.pimage fun x => Part.some (f x)) = s.image f", "start": [75, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_congr", "code": "theorem pimage_congr (h\u2081 : s = t) (h\u2082 : \u2200 x \u2208 t, f x = g x) : s.pimage f = t.pimage g", "start": [82, 1], "end": [86, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_eq_image_filter", "code": "theorem pimage_eq_image_filter : s.pimage f =\n    (filter (fun x => (f x).Dom) s).attach.image\n      fun x : { x // x \u2208 filter (fun x => (f x).Dom) s } =>\n        (f x).get (mem_filter.mp x.coe_prop).2", "start": [89, 1], "end": [97, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_union", "code": "theorem pimage_union [DecidableEq \u03b1] : (s \u222a t).pimage f = s.pimage f \u222a t.pimage f", "start": [100, 1], "end": [102, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_empty", "code": "@[simp]\ntheorem pimage_empty : pimage f \u2205 = \u2205", "start": [105, 1], "end": [108, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_subset", "code": "theorem pimage_subset {t : Finset \u03b2} : s.pimage f \u2286 t \u2194 \u2200 x \u2208 s, \u2200 y \u2208 f x, y \u2208 t", "start": [111, 1], "end": [112, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_mono", "code": "@[mono]\ntheorem pimage_mono (h : s \u2286 t) : s.pimage f \u2286 t.pimage f", "start": [115, 1], "end": [117, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.pimage_inter", "code": "theorem pimage_inter [DecidableEq \u03b1] : (s \u2229 t).pimage f \u2286 s.pimage f \u2229 t.pimage f", "start": [120, 1], "end": [121, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Support.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulAction.Supports", "code": "@[to_additive \"A set `s` supports `b` if `g +\u1d65 b = b` whenever `g +\u1d65 a = a` for all `a \u2208 s`.\"]\ndef Supports (s : Set \u03b1) (b : \u03b2) :=\n  \u2200 g : G, (\u2200 \u2983a\u2984, a \u2208 s \u2192 g \u2022 a = a) \u2192 g \u2022 b = b", "start": [29, 1], "end": [32, 50], "kind": "commanddeclaration"}, {"full_name": "MulAction.supports_of_mem", "code": "@[to_additive]\ntheorem supports_of_mem (ha : a \u2208 s) : Supports G s a", "start": [38, 1], "end": [39, 73], "kind": "commanddeclaration"}, {"full_name": "MulAction.Supports.mono", "code": "@[to_additive]\ntheorem Supports.mono (h : s \u2286 t) (hs : Supports G s b) : Supports G t b", "start": [45, 1], "end": [47, 32], "kind": "commanddeclaration"}, {"full_name": "MulAction.Supports.smul", "code": "@[to_additive]\ntheorem Supports.smul (g : H) (h : Supports G s b) : Supports G (g \u2022 s) (g \u2022 b)", "start": [57, 1], "end": [63, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Algebra/LeftInvariantDerivation.lean", "imports": ["Mathlib/Geometry/Manifold/DerivationBundle.lean", "Mathlib/RingTheory/Derivation/Lie.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LeftInvariantDerivation", "code": "structure LeftInvariantDerivation extends Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef where\n  left_invariant'' :\n    \u2200 g, \ud835\udc85\u2095 (smoothLeftMul_one I g) (Derivation.evalAt 1 toDerivation) =\n      Derivation.evalAt g toDerivation", "start": [38, 1], "end": [46, 39], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.toDerivation_injective", "code": "theorem toDerivation_injective :\n    Function.Injective (toDerivation : LeftInvariantDerivation I G \u2192 _)", "start": [58, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.toFun_eq_coe", "code": "theorem toFun_eq_coe : X.toFun = \u21d1X", "start": [75, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_injective", "code": "theorem coe_injective :\n    @Function.Injective (LeftInvariantDerivation I G) (_ \u2192 C^\u221e\u27eeI, G; \ud835\udd5c\u27ef) FunLike.coe", "start": [84, 1], "end": [86, 24], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.ext", "code": "@[ext]\ntheorem ext (h : \u2200 f, X f = Y f) : X = Y", "start": [89, 1], "end": [90, 62], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_derivation", "code": "theorem coe_derivation :\n    \u21d1(X : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef) = (X : C^\u221e\u27eeI, G; \ud835\udd5c\u27ef \u2192 C^\u221e\u27eeI, G; \ud835\udd5c\u27ef)", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.left_invariant'", "code": "theorem left_invariant' :\n    \ud835\udc85\u2095 (smoothLeftMul_one I g) (Derivation.evalAt (1 : G) \u2191X) = Derivation.evalAt g \u2191X", "start": [100, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.map_add", "code": "protected theorem map_add : X (f + f') = X f + X f'", "start": [107, 1], "end": [107, 70], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.map_zero", "code": "protected theorem map_zero : X 0 = 0", "start": [111, 1], "end": [111, 51], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.map_neg", "code": "protected theorem map_neg : X (-f) = -X f", "start": [115, 1], "end": [115, 57], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.map_sub", "code": "protected theorem map_sub : X (f - f') = X f - X f'", "start": [119, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.map_smul", "code": "protected theorem map_smul : X (r \u2022 f) = r \u2022 X f", "start": [123, 1], "end": [123, 67], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.leibniz", "code": "@[simp]\ntheorem leibniz : X (f * f') = f \u2022 X f' + f' \u2022 X f", "start": [126, 1], "end": [128, 17], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_add", "code": "@[simp]\ntheorem coe_add : \u21d1(X + Y) = X + Y", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : LeftInvariantDerivation I G) = 0", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_neg", "code": "@[simp]\ntheorem coe_neg : \u21d1(-X) = -X", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_sub", "code": "@[simp]\ntheorem coe_sub : \u21d1(X - Y) = X - Y", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.lift_add", "code": "@[simp, norm_cast]\ntheorem lift_add : (\u2191(X + Y) : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef) = X + Y", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.lift_zero", "code": "@[simp, norm_cast]\ntheorem lift_zero :\n    (\u2191(0 : LeftInvariantDerivation I G) : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef) = 0", "start": [181, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.hasNatScalar", "code": "instance hasNatScalar : SMul \u2115 (LeftInvariantDerivation I G) where\n  smul r X := \u27e8r \u2022 X.1, fun g => by simp_rw [LinearMap.map_smul_of_tower _ r, left_invariant']\u27e9", "start": [187, 1], "end": [188, 96], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.hasIntScalar", "code": "instance hasIntScalar : SMul \u2124 (LeftInvariantDerivation I G) where\n  smul r X := \u27e8r \u2022 X.1, fun g => by simp_rw [LinearMap.map_smul_of_tower _ r, left_invariant']\u27e9", "start": [191, 1], "end": [192, 96], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coe_smul", "code": "@[simp]\ntheorem coe_smul : \u21d1(r \u2022 X) = r \u2022 \u21d1X", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.lift_smul", "code": "@[simp]\ntheorem lift_smul (k : \ud835\udd5c) : (k \u2022 X).1 = k \u2022 X.1", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.coeFnAddMonoidHom", "code": "@[simps]\ndef coeFnAddMonoidHom : LeftInvariantDerivation I G \u2192+ C^\u221e\u27eeI, G; \ud835\udd5c\u27ef \u2192 C^\u221e\u27eeI, G; \ud835\udd5c\u27ef :=\n  \u27e8\u27e8FunLike.coe, coe_zero\u27e9, coe_add\u27e9", "start": [215, 1], "end": [218, 37], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.evalAt", "code": "def evalAt : LeftInvariantDerivation I G \u2192\u2097[\ud835\udd5c] PointDerivation I g where\n  toFun X := Derivation.evalAt g X.1\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [226, 1], "end": [231, 23], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.evalAt_apply", "code": "theorem evalAt_apply : evalAt g X f = (X f) g", "start": [234, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.evalAt_coe", "code": "@[simp]\ntheorem evalAt_coe : Derivation.evalAt g \u2191X = evalAt g X", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.left_invariant", "code": "theorem left_invariant : \ud835\udc85\u2095 (smoothLeftMul_one I g) (evalAt (1 : G) X) = evalAt g X", "start": [243, 1], "end": [244, 23], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.evalAt_mul", "code": "theorem evalAt_mul : evalAt (g * h) X = \ud835\udc85\u2095 (L_apply I g h) (evalAt h X)", "start": [247, 1], "end": [254, 68], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.comp_L", "code": "theorem comp_L : (X f).comp (\ud835\udc73 I g) = X (f.comp (\ud835\udc73 I g))", "start": [257, 1], "end": [260, 39], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.commutator_coe_derivation", "code": "@[simp]\ntheorem commutator_coe_derivation :\n    \u21d1\u2045X, Y\u2046 =\n      (\u2045(X : Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef), Y\u2046 :\n        Derivation \ud835\udd5c C^\u221e\u27eeI, G; \ud835\udd5c\u27ef C^\u221e\u27eeI, G; \ud835\udd5c\u27ef)", "start": [277, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "LeftInvariantDerivation.commutator_apply", "code": "theorem commutator_apply : \u2045X, Y\u2046 f = X (Y f) - Y (X f)", "start": [285, 1], "end": [286, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/OmegaCompletePartialOrder.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Topology/Basic.lean", "Mathlib/Order/OmegaCompletePartialOrder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Scott.Is\u03c9Sup", "code": "def Is\u03c9Sup {\u03b1 : Type u} [Preorder \u03b1] (c : Chain \u03b1) (x : \u03b1) : Prop :=\n  (\u2200 i, c i \u2264 x) \u2227 \u2200 y, (\u2200 i, c i \u2264 y) \u2192 x \u2264 y", "start": [36, 1], "end": [38, 47], "kind": "commanddeclaration"}, {"full_name": "Scott.is\u03c9Sup_iff_isLUB", "code": "theorem is\u03c9Sup_iff_isLUB {\u03b1 : Type u} [Preorder \u03b1] {c : Chain \u03b1} {x : \u03b1} :\n    Is\u03c9Sup c x \u2194 IsLUB (range c) x", "start": [41, 1], "end": [43, 58], "kind": "commanddeclaration"}, {"full_name": "Scott.IsOpen", "code": "def IsOpen (s : Set \u03b1) : Prop :=\n  Continuous' fun x \u21a6 x \u2208 s", "start": [48, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "Scott.isOpen_univ", "code": "theorem isOpen_univ : IsOpen \u03b1 univ", "start": [54, 1], "end": [55, 73], "kind": "commanddeclaration"}, {"full_name": "Scott.IsOpen.inter", "code": "theorem IsOpen.inter (s t : Set \u03b1) : IsOpen \u03b1 s \u2192 IsOpen \u03b1 t \u2192 IsOpen \u03b1 (s \u2229 t)", "start": [58, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "Scott.isOpen_sUnion", "code": "theorem isOpen_sUnion (s : Set (Set \u03b1)) (hs : \u2200 t \u2208 s, IsOpen \u03b1 t) : IsOpen \u03b1 (\u22c3\u2080 s)", "start": [62, 1], "end": [66, 59], "kind": "commanddeclaration"}, {"full_name": "Scott.IsOpen.isUpperSet", "code": "theorem IsOpen.isUpperSet {s : Set \u03b1} (hs : IsOpen \u03b1 s) : IsUpperSet s", "start": [69, 1], "end": [69, 81], "kind": "commanddeclaration"}, {"full_name": "Scott", "code": "@[reducible]\ndef Scott (\u03b1 : Type u) := \u03b1", "start": [73, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "Scott.topologicalSpace", "code": "instance Scott.topologicalSpace (\u03b1 : Type u) [OmegaCompletePartialOrder \u03b1] :\n    TopologicalSpace (Scott \u03b1) where\n  IsOpen := Scott.IsOpen \u03b1\n  isOpen_univ := Scott.isOpen_univ \u03b1\n  isOpen_inter := Scott.IsOpen.inter \u03b1\n  isOpen_sUnion := Scott.isOpen_sUnion \u03b1", "start": [80, 1], "end": [85, 41], "kind": "commanddeclaration"}, {"full_name": "notBelow", "code": "def notBelow :=\n  { x | \u00acx \u2264 y }", "start": [92, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "notBelow_isOpen", "code": "theorem notBelow_isOpen : IsOpen (notBelow y)", "start": [98, 1], "end": [102, 49], "kind": "commanddeclaration"}, {"full_name": "is\u03c9Sup_\u03c9Sup", "code": "theorem is\u03c9Sup_\u03c9Sup {\u03b1} [OmegaCompletePartialOrder \u03b1] (c : Chain \u03b1) : Is\u03c9Sup c (\u03c9Sup c)", "start": [111, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "scottContinuous_of_continuous", "code": "theorem scottContinuous_of_continuous {\u03b1 \u03b2} [OmegaCompletePartialOrder \u03b1]\n    [OmegaCompletePartialOrder \u03b2] (f : Scott \u03b1 \u2192 Scott \u03b2) (hf : Continuous f) :\n    OmegaCompletePartialOrder.Continuous' f", "start": [117, 1], "end": [130, 8], "kind": "commanddeclaration"}, {"full_name": "continuous_of_scottContinuous", "code": "theorem continuous_of_scottContinuous {\u03b1 \u03b2} [OmegaCompletePartialOrder \u03b1]\n    [OmegaCompletePartialOrder \u03b2] (f : Scott \u03b1 \u2192 Scott \u03b2)\n    (hf : OmegaCompletePartialOrder.Continuous' f) : Continuous f", "start": [133, 1], "end": [142, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/Exact.lean", "imports": ["Mathlib/CategoryTheory/MorphismProperty.lean", "Mathlib/Algebra/Homology/ShortComplex/Abelian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Abelian/Exact.lean", "Mathlib/Algebra/Homology/ShortComplex/PreservesHomology.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.Exact", "code": "structure Exact : Prop where\n  \n  condition : \u2203 (h : S.HomologyData), IsZero h.left.H", "start": [38, 1], "end": [41, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.Exact.hasHomology", "code": "lemma Exact.hasHomology (h : S.Exact) : S.HasHomology :=\n  HasHomology.mk' h.condition.choose", "start": [45, 1], "end": [46, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.hasZeroObject", "code": "lemma Exact.hasZeroObject (h : S.Exact) : HasZeroObject C :=\n  \u27e8h.condition.choose.left.H, h.condition.choose_spec\u27e9", "start": [48, 1], "end": [49, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_isZero_homology", "code": "lemma exact_iff_isZero_homology [S.HasHomology] :\n    S.Exact \u2194 IsZero S.homology := by\n  constructor\n  \u00b7 rintro \u27e8\u27e8h', z\u27e9\u27e9\n    exact IsZero.of_iso z h'.left.homologyIso\n  \u00b7 intro h\n    exact \u27e8\u27e8_, h\u27e9\u27e9", "start": [53, 1], "end": [59, 19], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.exact_iff", "code": "lemma LeftHomologyData.exact_iff [S.HasHomology]\n    (h : S.LeftHomologyData) :\n    S.Exact \u2194 IsZero h.H := by\n  rw [S.exact_iff_isZero_homology]\n  exact Iso.isZero_iff h.homologyIso", "start": [63, 1], "end": [67, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.exact_iff", "code": "lemma RightHomologyData.exact_iff [S.HasHomology]\n    (h : S.RightHomologyData) :\n    S.Exact \u2194 IsZero h.H := by\n  rw [S.exact_iff_isZero_homology]\n  exact Iso.isZero_iff h.homologyIso", "start": [69, 1], "end": [73, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_isZero_leftHomology", "code": "lemma exact_iff_isZero_leftHomology [S.HasHomology] :\n    S.Exact \u2194 IsZero S.leftHomology :=\n  LeftHomologyData.exact_iff _", "start": [77, 1], "end": [79, 31], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_isZero_rightHomology", "code": "lemma exact_iff_isZero_rightHomology [S.HasHomology] :\n    S.Exact \u2194 IsZero S.rightHomology :=\n  RightHomologyData.exact_iff _", "start": [81, 1], "end": [83, 32], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.exact_iff", "code": "lemma HomologyData.exact_iff (h : S.HomologyData) :\n    S.Exact \u2194 IsZero h.left.H := by\n  haveI := HasHomology.mk' h\n  exact LeftHomologyData.exact_iff h.left", "start": [87, 1], "end": [90, 42], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.exact_iff'", "code": "lemma HomologyData.exact_iff' (h : S.HomologyData) :\n    S.Exact \u2194 IsZero h.right.H := by\n  haveI := HasHomology.mk' h\n  exact RightHomologyData.exact_iff h.right", "start": [92, 1], "end": [95, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_homology_iso_zero", "code": "lemma exact_iff_homology_iso_zero [S.HasHomology] [HasZeroObject C] :\n    S.Exact \u2194 Nonempty (S.homology \u2245 0) := by\n  rw [exact_iff_isZero_homology]\n  constructor\n  \u00b7 intro h\n    exact \u27e8h.isoZero\u27e9\n  \u00b7 rintro \u27e8e\u27e9\n    exact IsZero.of_iso (isZero_zero C) e", "start": [99, 1], "end": [106, 42], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_of_iso", "code": "lemma exact_of_iso (e : S\u2081 \u2245 S\u2082) (h : S\u2081.Exact) : S\u2082.Exact := by\n  obtain \u27e8\u27e8h, z\u27e9\u27e9 := h\n  exact \u27e8\u27e8HomologyData.ofIso e h, z\u27e9\u27e9", "start": [108, 1], "end": [110, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_of_iso", "code": "lemma exact_iff_of_iso (e : S\u2081 \u2245 S\u2082) : S\u2081.Exact \u2194 S\u2082.Exact :=\n  \u27e8exact_of_iso e, exact_of_iso e.symm\u27e9", "start": [112, 1], "end": [113, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_of_isZero_X\u2082", "code": "lemma exact_of_isZero_X\u2082 (h : IsZero S.X\u2082) : S.Exact := by\n  rw [(HomologyData.ofZeros S (IsZero.eq_of_tgt h _ _) (IsZero.eq_of_src h _ _)).exact_iff]\n  exact h", "start": [115, 1], "end": [117, 10], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_of_epi_of_isIso_of_mono", "code": "lemma exact_iff_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082) [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    S\u2081.Exact \u2194 S\u2082.Exact := by\n  constructor\n  \u00b7 rintro \u27e8h\u2081, z\u2081\u27e9\n    exact \u27e8HomologyData.ofEpiOfIsIsoOfMono \u03c6 h\u2081, z\u2081\u27e9\n  \u00b7 rintro \u27e8h\u2082, z\u2082\u27e9\n    exact \u27e8HomologyData.ofEpiOfIsIsoOfMono' \u03c6 h\u2082, z\u2082\u27e9", "start": [119, 1], "end": [125, 54], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.exact_iff_i_p_zero", "code": "lemma HomologyData.exact_iff_i_p_zero (h : S.HomologyData) :\n    S.Exact \u2194 h.left.i \u226b h.right.p = 0 := by\n  haveI := HasHomology.mk' h\n  rw [h.left.exact_iff, \u2190 h.comm]\n  constructor\n  \u00b7 intro z\n    rw [IsZero.eq_of_src z h.iso.hom 0, zero_comp, comp_zero]\n  \u00b7 intro eq\n    simp only [IsZero.iff_id_eq_zero, \u2190 cancel_mono h.iso.hom, id_comp, \u2190 cancel_mono h.right.\u03b9,\n      \u2190 cancel_epi h.left.\u03c0, eq, zero_comp, comp_zero]", "start": [129, 1], "end": [138, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_i_p_zero", "code": "lemma exact_iff_i_p_zero [S.HasHomology] (h\u2081 : S.LeftHomologyData)\n    (h\u2082 : S.RightHomologyData) :\n    S.Exact \u2194 h\u2081.i \u226b h\u2082.p = 0 :=\n  (HomologyData.ofIsIsoLeftRightHomologyComparison' h\u2081 h\u2082).exact_iff_i_p_zero", "start": [142, 1], "end": [145, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_iCycles_pOpcycles_zero", "code": "lemma exact_iff_iCycles_pOpcycles_zero [S.HasHomology] :\n    S.Exact \u2194 S.iCycles \u226b S.pOpcycles = 0 :=\n  S.exact_iff_i_p_zero _ _", "start": [147, 1], "end": [149, 27], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_kernel_\u03b9_comp_cokernel_\u03c0_zero", "code": "lemma exact_iff_kernel_\u03b9_comp_cokernel_\u03c0_zero [S.HasHomology]\n    [HasKernel S.g] [HasCokernel S.f] :\n    S.Exact \u2194 kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f = 0 := by\n  haveI := HasLeftHomology.hasCokernel S\n  haveI := HasRightHomology.hasKernel S\n  exact S.exact_iff_i_p_zero (LeftHomologyData.ofHasKernelOfHasCokernel S)\n    (RightHomologyData.ofHasCokernelOfHasKernel S)", "start": [151, 1], "end": [157, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.exact_iff_shortComplex_exact", "code": "lemma _root_.CategoryTheory.exact_iff_shortComplex_exact\n    {A : Type*} [Category A] [Abelian A] (S : ShortComplex A) :\n    CategoryTheory.Exact S.f S.g \u2194 S.Exact := by\n  simp only [Abelian.exact_iff, S.zero,\n    S.exact_iff_kernel_\u03b9_comp_cokernel_\u03c0_zero, true_and]", "start": [159, 1], "end": [166, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.op", "code": "lemma Exact.op (h : S.Exact) : S.op.Exact := by\n  obtain \u27e8h, z\u27e9 := h\n  exact \u27e8\u27e8h.op, (IsZero.of_iso z h.iso.symm).op\u27e9\u27e9", "start": [170, 1], "end": [172, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.unop", "code": "lemma Exact.unop {S : ShortComplex C\u1d52\u1d56} (h : S.Exact) : S.unop.Exact := by\n  obtain \u27e8h, z\u27e9 := h\n  exact \u27e8\u27e8h.unop, (IsZero.of_iso z h.iso.symm).unop\u27e9\u27e9", "start": [174, 1], "end": [176, 54], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_op_iff", "code": "@[simp]\nlemma exact_op_iff : S.op.Exact \u2194 S.Exact :=\n  \u27e8Exact.unop, Exact.op\u27e9", "start": [180, 1], "end": [182, 25], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_unop_iff", "code": "@[simp]\nlemma exact_unop_iff (S : ShortComplex C\u1d52\u1d56) : S.unop.Exact \u2194 S.Exact :=\n  S.unop.exact_op_iff.symm", "start": [184, 1], "end": [186, 27], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.exact_map_iff", "code": "lemma LeftHomologyData.exact_map_iff (h : S.LeftHomologyData) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [h.IsPreservedBy F] [(S.map F).HasHomology] :\n    (S.map F).Exact \u2194 IsZero (F.obj h.H) :=\n  (h.map F).exact_iff", "start": [190, 1], "end": [193, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.exact_map_iff", "code": "lemma RightHomologyData.exact_map_iff (h : S.RightHomologyData) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [h.IsPreservedBy F] [(S.map F).HasHomology] :\n    (S.map F).Exact \u2194 IsZero (F.obj h.H) :=\n  (h.map F).exact_iff", "start": [195, 1], "end": [198, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.map_of_preservesLeftHomologyOf", "code": "lemma Exact.map_of_preservesLeftHomologyOf (h : S.Exact) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [(S.map F).HasHomology] : (S.map F).Exact := by\n  have := h.hasHomology\n  rw [S.leftHomologyData.exact_iff, IsZero.iff_id_eq_zero] at h\n  rw [S.leftHomologyData.exact_map_iff F, IsZero.iff_id_eq_zero,\n    \u2190 F.map_id, h, F.map_zero]", "start": [200, 1], "end": [206, 31], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.map_of_preservesRightHomologyOf", "code": "lemma Exact.map_of_preservesRightHomologyOf (h : S.Exact) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [F.PreservesRightHomologyOf S]\n    [(S.map F).HasHomology] : (S.map F).Exact := by\n  have : S.HasHomology := h.hasHomology\n  rw [S.rightHomologyData.exact_iff, IsZero.iff_id_eq_zero] at h\n  rw [S.rightHomologyData.exact_map_iff F, IsZero.iff_id_eq_zero,\n    \u2190 F.map_id, h, F.map_zero]", "start": [208, 1], "end": [214, 31], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.map", "code": "lemma Exact.map (h : S.Exact) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] : (S.map F).Exact := by\n  have := h.hasHomology\n  exact h.map_of_preservesLeftHomologyOf F", "start": [216, 1], "end": [220, 43], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_map_iff_of_faithful", "code": "lemma exact_map_iff_of_faithful [S.HasHomology]\n    (F : C \u2964 D) [F.PreservesZeroMorphisms] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] [Faithful F] :\n    (S.map F).Exact \u2194 S.Exact := by\n  constructor\n  \u00b7 intro h\n    rw [S.leftHomologyData.exact_iff, IsZero.iff_id_eq_zero]\n    rw [(S.leftHomologyData.map F).exact_iff, IsZero.iff_id_eq_zero,\n      LeftHomologyData.map_H] at h\n    apply F.map_injective\n    rw [F.map_id, F.map_zero, h]\n  \u00b7 intro h\n    exact h.map F", "start": [224, 1], "end": [236, 18], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.comp_eq_zero", "code": "@[reassoc]\nlemma Exact.comp_eq_zero (h : S.Exact) {X Y : C} {a : X \u27f6 S.X\u2082} (ha : a \u226b S.g = 0)\n    {b : S.X\u2082 \u27f6 Y} (hb : S.f \u226b b = 0) : a \u226b b = 0 := by\n  have := h.hasHomology\n  have eq := h\n  rw [exact_iff_iCycles_pOpcycles_zero] at eq\n  rw [\u2190 S.liftCycles_i a ha, \u2190 S.p_descOpcycles b hb, assoc, reassoc_of% eq,\n    zero_comp, comp_zero]", "start": [240, 1], "end": [247, 26], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.isZero_of_both_zeros", "code": "lemma Exact.isZero_of_both_zeros (ex : S.Exact) (hf : S.f = 0) (hg : S.g = 0) :\n    IsZero S.X\u2082 :=\n  (ShortComplex.HomologyData.ofZeros S hf hg).exact_iff.1 ex", "start": [249, 1], "end": [251, 61], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_mono", "code": "lemma exact_iff_mono [HasZeroObject C] (hf : S.f = 0) :\n    S.Exact \u2194 Mono S.g := by\n  constructor\n  \u00b7 intro h\n    have := h.hasHomology\n    simp only [exact_iff_isZero_homology] at h\n    have := S.isIso_pOpcycles hf\n    have := mono_of_isZero_kernel' _ S.homologyIsKernel h\n    rw [\u2190 S.p_fromOpcycles]\n    apply mono_comp\n  \u00b7 intro\n    rw [(HomologyData.ofIsLimitKernelFork S hf _\n      (KernelFork.IsLimit.ofMonoOfIsZero (KernelFork.of\u03b9 (0 : 0 \u27f6 S.X\u2082) zero_comp)\n        inferInstance (isZero_zero C))).exact_iff]\n    exact isZero_zero C", "start": [259, 1], "end": [273, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_epi", "code": "lemma exact_iff_epi [HasZeroObject C] (hg : S.g = 0) :\n    S.Exact \u2194 Epi S.f := by\n  constructor\n  \u00b7 intro h\n    have := h.hasHomology\n    simp only [exact_iff_isZero_homology] at h\n    haveI := S.isIso_iCycles hg\n    haveI : Epi S.toCycles := epi_of_isZero_cokernel' _ S.homologyIsCokernel h\n    rw [\u2190 S.toCycles_i]\n    apply epi_comp\n  \u00b7 intro\n    rw [(HomologyData.ofIsColimitCokernelCofork S hg _\n      (CokernelCofork.IsColimit.ofEpiOfIsZero (CokernelCofork.of\u03c0 (0 : S.X\u2082 \u27f6 0) comp_zero)\n        inferInstance (isZero_zero C))).exact_iff]\n    exact isZero_zero C", "start": [275, 1], "end": [289, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.epi_f'", "code": "lemma Exact.epi_f' (hS : S.Exact) (h : LeftHomologyData S) : Epi h.f' :=\n  epi_of_isZero_cokernel' _ h.h\u03c0 (by\n    haveI := hS.hasHomology\n    dsimp\n    simpa only [\u2190 h.exact_iff] using hS)", "start": [293, 1], "end": [297, 41], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.mono_g'", "code": "lemma Exact.mono_g' (hS : S.Exact) (h : RightHomologyData S) : Mono h.g' :=\n  mono_of_isZero_kernel' _ h.h\u03b9 (by\n    haveI := hS.hasHomology\n    dsimp\n    simpa only [\u2190 h.exact_iff] using hS)", "start": [299, 1], "end": [303, 41], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.epi_toCycles", "code": "lemma Exact.epi_toCycles (hS : S.Exact) [S.HasLeftHomology] : Epi S.toCycles :=\n  hS.epi_f' _", "start": [305, 1], "end": [306, 14], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.mono_fromOpcycles", "code": "lemma Exact.mono_fromOpcycles (hS : S.Exact) [S.HasRightHomology] : Mono S.fromOpcycles :=\n  hS.mono_g' _", "start": [308, 1], "end": [309, 15], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.exact_iff_epi_f'", "code": "lemma LeftHomologyData.exact_iff_epi_f' [S.HasHomology] (h : LeftHomologyData S) :\n    S.Exact \u2194 Epi h.f' := by\n  constructor\n  \u00b7 intro hS\n    exact hS.epi_f' h\n  \u00b7 intro\n    simp only [h.exact_iff, IsZero.iff_id_eq_zero, \u2190 cancel_epi h.\u03c0, \u2190 cancel_epi h.f',\n      comp_id, h.f'_\u03c0, comp_zero]", "start": [311, 1], "end": [318, 34], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.exact_iff_mono_g'", "code": "lemma RightHomologyData.exact_iff_mono_g' [S.HasHomology] (h : RightHomologyData S) :\n    S.Exact \u2194 Mono h.g' := by\n  constructor\n  \u00b7 intro hS\n    exact hS.mono_g' h\n  \u00b7 intro\n    simp only [h.exact_iff, IsZero.iff_id_eq_zero, \u2190 cancel_mono h.\u03b9, \u2190 cancel_mono h.g',\n      id_comp, h.\u03b9_g', zero_comp]", "start": [320, 1], "end": [327, 34], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.Exact.leftHomologyDataOfIsLimitKernelFork", "code": "@[simps]\nnoncomputable def Exact.leftHomologyDataOfIsLimitKernelFork\n    (hS : S.Exact) [HasZeroObject C] (kf : KernelFork S.g) (hkf : IsLimit kf) :\n    S.LeftHomologyData where\n  K := kf.pt\n  H := 0\n  i := kf.\u03b9\n  \u03c0 := 0\n  wi := kf.condition\n  hi := IsLimit.ofIsoLimit hkf (Fork.ext (Iso.refl _) (by simp))\n  w\u03c0 := comp_zero\n  h\u03c0 := CokernelCofork.IsColimit.ofEpiOfIsZero _ (by\n    have := hS.hasHomology\n    refine' ((MorphismProperty.RespectsIso.epimorphisms C).arrow_mk_iso_iff _).1\n      hS.epi_toCycles\n    refine' Arrow.isoMk (Iso.refl _)\n      (IsLimit.conePointUniqueUpToIso S.cyclesIsKernel hkf) _\n    apply Fork.IsLimit.hom_ext hkf\n    simp [IsLimit.conePointUniqueUpToIso]) (isZero_zero C)", "start": [329, 1], "end": [349, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.Exact.rightHomologyDataOfIsColimitCokernelCofork", "code": "@[simps]\nnoncomputable def Exact.rightHomologyDataOfIsColimitCokernelCofork\n    (hS : S.Exact) [HasZeroObject C] (cc : CokernelCofork S.f) (hcc : IsColimit cc) :\n    S.RightHomologyData where\n  Q := cc.pt\n  H := 0\n  p := cc.\u03c0\n  \u03b9 := 0\n  wp := cc.condition\n  hp := IsColimit.ofIsoColimit hcc (Cofork.ext (Iso.refl _) (by simp))\n  w\u03b9 := zero_comp\n  h\u03b9 := KernelFork.IsLimit.ofMonoOfIsZero _ (by\n    have := hS.hasHomology\n    refine' ((MorphismProperty.RespectsIso.monomorphisms C).arrow_mk_iso_iff _).2\n      hS.mono_fromOpcycles\n    refine' Arrow.isoMk (IsColimit.coconePointUniqueUpToIso hcc S.opcyclesIsCokernel)\n      (Iso.refl _) _\n    apply Cofork.IsColimit.hom_ext hcc\n    simp [IsColimit.coconePointUniqueUpToIso]) (isZero_zero C)", "start": [351, 1], "end": [371, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_epi_toCycles", "code": "lemma exact_iff_epi_toCycles [S.HasHomology] : S.Exact \u2194 Epi S.toCycles :=\n  S.leftHomologyData.exact_iff_epi_f'", "start": [375, 1], "end": [376, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_mono_fromOpcycles", "code": "lemma exact_iff_mono_fromOpcycles [S.HasHomology] : S.Exact \u2194 Mono S.fromOpcycles :=\n  S.rightHomologyData.exact_iff_mono_g'", "start": [378, 1], "end": [379, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_epi_kernel_lift", "code": "lemma exact_iff_epi_kernel_lift [S.HasHomology] [HasKernel S.g] :\n    S.Exact \u2194 Epi (kernel.lift S.g S.f S.zero) := by\n  rw [exact_iff_epi_toCycles]\n  apply (MorphismProperty.RespectsIso.epimorphisms C).arrow_mk_iso_iff\n  exact Arrow.isoMk (Iso.refl _) S.cyclesIsoKernel (by aesop_cat)", "start": [381, 1], "end": [385, 66], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.exact_iff_mono_cokernel_desc", "code": "lemma exact_iff_mono_cokernel_desc [S.HasHomology] [HasCokernel S.f] :\n    S.Exact \u2194 Mono (cokernel.desc S.f S.g S.zero) := by\n  rw [exact_iff_mono_fromOpcycles]\n  refine' (MorphismProperty.RespectsIso.monomorphisms C).arrow_mk_iso_iff (Iso.symm _)\n  exact Arrow.isoMk S.opcyclesIsoCokernel.symm (Iso.refl _) (by aesop_cat)", "start": [387, 1], "end": [391, 75], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/Limits.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "Mathlib/Algebra/Homology/ShortComplex/FunctorEquivalence.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Preserves/Finite.lean", "Mathlib/CategoryTheory/Limits/Constructions/EpiMono.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.isLimitOfIsLimit\u03c0", "code": "def isLimitOfIsLimit\u03c0 (c : Cone F)\n    (h\u2081 : IsLimit (\u03c0\u2081.mapCone c)) (h\u2082 : IsLimit (\u03c0\u2082.mapCone c))\n    (h\u2083 : IsLimit (\u03c0\u2083.mapCone c)) : IsLimit c where\n  lift s :=\n    { \u03c4\u2081 := h\u2081.lift (\u03c0\u2081.mapCone s)\n      \u03c4\u2082 := h\u2082.lift (\u03c0\u2082.mapCone s)\n      \u03c4\u2083 := h\u2083.lift (\u03c0\u2083.mapCone s)\n      comm\u2081\u2082 := h\u2082.hom_ext (fun j => by\n        have eq\u2081 := h\u2081.fac (\u03c0\u2081.mapCone s)\n        have eq\u2082 := h\u2082.fac (\u03c0\u2082.mapCone s)\n        have eq\u2081\u2082 := fun j => (c.\u03c0.app j).comm\u2081\u2082\n        have eq\u2081\u2082' := fun j => (s.\u03c0.app j).comm\u2081\u2082\n        dsimp at eq\u2081 eq\u2082 eq\u2081\u2082 eq\u2081\u2082' \u22a2\n        rw [assoc, assoc, \u2190 eq\u2081\u2082, reassoc_of% eq\u2081, eq\u2082, eq\u2081\u2082'])\n      comm\u2082\u2083 := h\u2083.hom_ext (fun j => by\n        have eq\u2082 := h\u2082.fac (\u03c0\u2082.mapCone s)\n        have eq\u2083 := h\u2083.fac (\u03c0\u2083.mapCone s)\n        have eq\u2082\u2083 := fun j => (c.\u03c0.app j).comm\u2082\u2083\n        have eq\u2082\u2083' := fun j => (s.\u03c0.app j).comm\u2082\u2083\n        dsimp at eq\u2082 eq\u2083 eq\u2082\u2083 eq\u2082\u2083' \u22a2\n        rw [assoc, assoc, \u2190 eq\u2082\u2083, reassoc_of% eq\u2082, eq\u2083, eq\u2082\u2083']) }\n  fac s j := by ext <;> apply IsLimit.fac\n  uniq s m hm := by\n    ext\n    \u00b7 exact h\u2081.uniq (\u03c0\u2081.mapCone s) _ (fun j => \u03c0\u2081.congr_map (hm j))\n    \u00b7 exact h\u2082.uniq (\u03c0\u2082.mapCone s) _ (fun j => \u03c0\u2082.congr_map (hm j))\n    \u00b7 exact h\u2083.uniq (\u03c0\u2083.mapCone s) _ (fun j => \u03c0\u2083.congr_map (hm j))", "start": [30, 1], "end": [58, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.limitCone", "code": "noncomputable def limitCone : Cone F :=\n  Cone.mk (ShortComplex.mk (limMap (whiskerLeft F \u03c0\u2081To\u03c0\u2082)) (limMap (whiskerLeft F \u03c0\u2082To\u03c0\u2083))\n      (by aesop_cat))\n    { app := fun j => Hom.mk (limit.\u03c0 _ _) (limit.\u03c0 _ _) (limit.\u03c0 _ _)\n        (by aesop_cat) (by aesop_cat)\n      naturality := fun _ _ f => by\n        ext\n        all_goals\n          dsimp\n          erw [id_comp, limit.w] }", "start": [64, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isLimit\u03c0\u2081MapConeLimitCone", "code": "noncomputable def isLimit\u03c0\u2081MapConeLimitCone : IsLimit (\u03c0\u2081.mapCone (limitCone F)) :=\n  (IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext (Iso.refl _) (by aesop_cat)))", "start": [77, 1], "end": [79, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isLimit\u03c0\u2082MapConeLimitCone", "code": "noncomputable def isLimit\u03c0\u2082MapConeLimitCone : IsLimit (\u03c0\u2082.mapCone (limitCone F)) :=\n  (IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext (Iso.refl _) (by aesop_cat)))", "start": [81, 1], "end": [83, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isLimit\u03c0\u2083MapConeLimitCone", "code": "noncomputable def isLimit\u03c0\u2083MapConeLimitCone : IsLimit (\u03c0\u2083.mapCone (limitCone F)) :=\n  (IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext (Iso.refl _) (by aesop_cat)))", "start": [85, 1], "end": [87, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isLimitLimitCone", "code": "noncomputable def isLimitLimitCone : IsLimit (limitCone F) :=\n  isLimitOfIsLimit\u03c0 _ (isLimit\u03c0\u2081MapConeLimitCone F)\n    (isLimit\u03c0\u2082MapConeLimitCone F) (isLimit\u03c0\u2083MapConeLimitCone F)", "start": [89, 1], "end": [92, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasLimit_of_hasLimit\u03c0", "code": "instance hasLimit_of_hasLimit\u03c0 : HasLimit F := \u27e8\u27e8\u27e8_, isLimitLimitCone _\u27e9\u27e9\u27e9", "start": [94, 1], "end": [94, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasLimitsOfShape", "code": "instance hasLimitsOfShape :\n    HasLimitsOfShape J (ShortComplex C) where", "start": [111, 1], "end": [112, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasFiniteLimits", "code": "instance hasFiniteLimits : HasFiniteLimits (ShortComplex C) :=\n  \u27e8fun _ _ _ => inferInstance\u27e9", "start": [126, 1], "end": [127, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesMonomorphisms_\u03c0\u2081", "code": "instance preservesMonomorphisms_\u03c0\u2081 :\n    Functor.PreservesMonomorphisms (\u03c0\u2081 : _ \u2964 C) :=\n  CategoryTheory.preservesMonomorphisms_of_preservesLimitsOfShape _", "start": [144, 1], "end": [146, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesMonomorphisms_\u03c0\u2082", "code": "instance preservesMonomorphisms_\u03c0\u2082 :\n    Functor.PreservesMonomorphisms (\u03c0\u2082 : _ \u2964 C) :=\n  CategoryTheory.preservesMonomorphisms_of_preservesLimitsOfShape _", "start": [148, 1], "end": [150, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesMonomorphisms_\u03c0\u2083", "code": "instance preservesMonomorphisms_\u03c0\u2083 :\n    Functor.PreservesMonomorphisms (\u03c0\u2083 : _ \u2964 C) :=\n  CategoryTheory.preservesMonomorphisms_of_preservesLimitsOfShape _", "start": [152, 1], "end": [154, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isColimitOfIsColimit\u03c0", "code": "def isColimitOfIsColimit\u03c0 (c : Cocone F)\n    (h\u2081 : IsColimit (\u03c0\u2081.mapCocone c)) (h\u2082 : IsColimit (\u03c0\u2082.mapCocone c))\n    (h\u2083 : IsColimit (\u03c0\u2083.mapCocone c)) : IsColimit c where\n  desc s :=\n    { \u03c4\u2081 := h\u2081.desc (\u03c0\u2081.mapCocone s)\n      \u03c4\u2082 := h\u2082.desc (\u03c0\u2082.mapCocone s)\n      \u03c4\u2083 := h\u2083.desc (\u03c0\u2083.mapCocone s)\n      comm\u2081\u2082 := h\u2081.hom_ext (fun j => by\n        have eq\u2081 := h\u2081.fac (\u03c0\u2081.mapCocone s)\n        have eq\u2082 := h\u2082.fac (\u03c0\u2082.mapCocone s)\n        have eq\u2081\u2082 := fun j => (c.\u03b9.app j).comm\u2081\u2082\n        have eq\u2081\u2082' := fun j => (s.\u03b9.app j).comm\u2081\u2082\n        dsimp at eq\u2081 eq\u2082 eq\u2081\u2082 eq\u2081\u2082' \u22a2\n        rw [reassoc_of% (eq\u2081 j), eq\u2081\u2082', reassoc_of% eq\u2081\u2082, eq\u2082])\n      comm\u2082\u2083 := h\u2082.hom_ext (fun j => by\n        have eq\u2082 := h\u2082.fac (\u03c0\u2082.mapCocone s)\n        have eq\u2083 := h\u2083.fac (\u03c0\u2083.mapCocone s)\n        have eq\u2082\u2083 := fun j => (c.\u03b9.app j).comm\u2082\u2083\n        have eq\u2082\u2083' := fun j => (s.\u03b9.app j).comm\u2082\u2083\n        dsimp at eq\u2082 eq\u2083 eq\u2082\u2083 eq\u2082\u2083' \u22a2\n        rw [reassoc_of% (eq\u2082 j), eq\u2082\u2083', reassoc_of% eq\u2082\u2083, eq\u2083]) }\n  fac s j := by\n    ext\n    \u00b7 apply IsColimit.fac h\u2081\n    \u00b7 apply IsColimit.fac h\u2082\n    \u00b7 apply IsColimit.fac h\u2083\n  uniq s m hm := by\n    ext\n    \u00b7 exact h\u2081.uniq (\u03c0\u2081.mapCocone s) _ (fun j => \u03c0\u2081.congr_map (hm j))\n    \u00b7 exact h\u2082.uniq (\u03c0\u2082.mapCocone s) _ (fun j => \u03c0\u2082.congr_map (hm j))\n    \u00b7 exact h\u2083.uniq (\u03c0\u2083.mapCocone s) _ (fun j => \u03c0\u2083.congr_map (hm j))", "start": [158, 1], "end": [190, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.colimitCocone", "code": "noncomputable def colimitCocone : Cocone F :=\n  Cocone.mk (ShortComplex.mk (colimMap (whiskerLeft F \u03c0\u2081To\u03c0\u2082)) (colimMap (whiskerLeft F \u03c0\u2082To\u03c0\u2083))\n      (by aesop_cat))\n    { app := fun j => Hom.mk (colimit.\u03b9 (F \u22d9 \u03c0\u2081) _) (colimit.\u03b9 (F \u22d9 \u03c0\u2082) _)\n        (colimit.\u03b9 (F \u22d9 \u03c0\u2083) _) (by aesop_cat) (by aesop_cat)\n      naturality := fun _ _ f => by\n        ext\n        \u00b7 dsimp; erw [comp_id, colimit.w (F \u22d9 \u03c0\u2081)]\n        \u00b7 dsimp; erw [comp_id, colimit.w (F \u22d9 \u03c0\u2082)]\n        \u00b7 dsimp; erw [comp_id, colimit.w (F \u22d9 \u03c0\u2083)] }", "start": [196, 1], "end": [207, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isColimit\u03c0\u2081MapCoconeColimitCocone", "code": "noncomputable def isColimit\u03c0\u2081MapCoconeColimitCocone :\n    IsColimit (\u03c0\u2081.mapCocone (colimitCocone F)) :=\n  (IsColimit.ofIsoColimit (colimit.isColimit _) (Cocones.ext (Iso.refl _) (by aesop_cat)))", "start": [209, 1], "end": [212, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isColimit\u03c0\u2082MapCoconeColimitCocone", "code": "noncomputable def isColimit\u03c0\u2082MapCoconeColimitCocone :\n    IsColimit (\u03c0\u2082.mapCocone (colimitCocone F)) :=\n  (IsColimit.ofIsoColimit (colimit.isColimit _) (Cocones.ext (Iso.refl _) (by aesop_cat)))", "start": [214, 1], "end": [217, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isColimit\u03c0\u2083MapCoconeColimitCocone", "code": "noncomputable def isColimit\u03c0\u2083MapCoconeColimitCocone :\n    IsColimit (\u03c0\u2083.mapCocone (colimitCocone F)) :=\n  (IsColimit.ofIsoColimit (colimit.isColimit _) (Cocones.ext (Iso.refl _) (by aesop_cat)))", "start": [219, 1], "end": [222, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isColimitColimitCocone", "code": "noncomputable def isColimitColimitCocone : IsColimit (colimitCocone F) :=\n  isColimitOfIsColimit\u03c0 _ (isColimit\u03c0\u2081MapCoconeColimitCocone F)\n    (isColimit\u03c0\u2082MapCoconeColimitCocone F) (isColimit\u03c0\u2083MapCoconeColimitCocone F)", "start": [224, 1], "end": [227, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasColimit_of_hasColimit\u03c0", "code": "instance hasColimit_of_hasColimit\u03c0 : HasColimit F := \u27e8\u27e8\u27e8_, isColimitColimitCocone _\u27e9\u27e9\u27e9", "start": [229, 1], "end": [229, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasColimitsOfShape", "code": "instance hasColimitsOfShape :\n    HasColimitsOfShape J (ShortComplex C) where", "start": [249, 1], "end": [250, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasFiniteColimits", "code": "instance hasFiniteColimits : HasFiniteColimits (ShortComplex C) :=\n  \u27e8fun _ _ _ => inferInstance\u27e9", "start": [264, 1], "end": [265, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesEpimorphisms_\u03c0\u2081", "code": "instance preservesEpimorphisms_\u03c0\u2081 :\n    Functor.PreservesEpimorphisms (\u03c0\u2081 : _ \u2964 C) :=\n  CategoryTheory.preservesEpimorphisms_of_preservesColimitsOfShape _", "start": [282, 1], "end": [284, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesEpimorphisms_\u03c0\u2082", "code": "instance preservesEpimorphisms_\u03c0\u2082 :\n    Functor.PreservesEpimorphisms (\u03c0\u2082 : _ \u2964 C) :=\n  CategoryTheory.preservesEpimorphisms_of_preservesColimitsOfShape _", "start": [286, 1], "end": [288, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.preservesEpimorphisms_\u03c0\u2083", "code": "instance preservesEpimorphisms_\u03c0\u2083 :\n    Functor.PreservesEpimorphisms (\u03c0\u2083 : _ \u2964 C) :=\n  CategoryTheory.preservesEpimorphisms_of_preservesColimitsOfShape _", "start": [290, 1], "end": [292, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Lagrange.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/LinearAlgebra/Vandermonde.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.eq_zero_of_degree_lt_of_eval_finset_eq_zero", "code": "theorem eq_zero_of_degree_lt_of_eval_finset_eq_zero (degree_f_lt : f.degree < s.card)\n    (eval_f : \u2200 x \u2208 s, f.eval x = 0) : f = 0", "start": [44, 1], "end": [52, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq", "code": "theorem eq_of_degree_sub_lt_of_eval_finset_eq (degree_fg_lt : (f - g).degree < s.card)\n    (eval_fg : \u2200 x \u2208 s, f.eval x = g.eval x) : f = g", "start": [55, 1], "end": [60, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degrees_lt_of_eval_finset_eq", "code": "theorem eq_of_degrees_lt_of_eval_finset_eq (degree_f_lt : f.degree < s.card)\n    (degree_g_lt : g.degree < s.card) (eval_fg : \u2200 x \u2208 s, f.eval x = g.eval x) : f = g", "start": [63, 1], "end": [67, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degree_le_of_eval_finset_eq", "code": "theorem eq_of_degree_le_of_eval_finset_eq\n    (h_deg_le : f.degree \u2264 s.card)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : \u2200 x \u2208 s, f.eval x = g.eval x) :\n    f = g", "start": [70, 1], "end": [83, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_degree_lt_of_eval_index_eq_zero", "code": "theorem eq_zero_of_degree_lt_of_eval_index_eq_zero (hvs : Set.InjOn v s)\n    (degree_f_lt : f.degree < s.card) (eval_f : \u2200 i \u2208 s, f.eval (v i) = 0) : f = 0", "start": [93, 1], "end": [100, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degree_sub_lt_of_eval_index_eq", "code": "theorem eq_of_degree_sub_lt_of_eval_index_eq (hvs : Set.InjOn v s)\n    (degree_fg_lt : (f - g).degree < s.card) (eval_fg : \u2200 i \u2208 s, f.eval (v i) = g.eval (v i)) :\n    f = g", "start": [103, 1], "end": [109, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degrees_lt_of_eval_index_eq", "code": "theorem eq_of_degrees_lt_of_eval_index_eq (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card)\n    (degree_g_lt : g.degree < s.card) (eval_fg : \u2200 i \u2208 s, f.eval (v i) = g.eval (v i)) : f = g", "start": [112, 1], "end": [116, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_degree_le_of_eval_index_eq", "code": "theorem eq_of_degree_le_of_eval_index_eq (hvs : Set.InjOn v s)\n    (h_deg_le : f.degree \u2264 s.card)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : \u2200 i \u2208 s, f.eval (v i) = g.eval (v i)) : f = g", "start": [119, 1], "end": [128, 13], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor", "code": "def basisDivisor (x y : F) : F[X] :=\n  C (x - y)\u207b\u00b9 * (X - C y)", "start": [146, 1], "end": [150, 26], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor_self", "code": "theorem basisDivisor_self : basisDivisor x x = 0", "start": [153, 1], "end": [154, 67], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor_inj", "code": "theorem basisDivisor_inj (hxy : basisDivisor x y = 0) : x = y", "start": [157, 1], "end": [160, 12], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor_eq_zero_iff", "code": "@[simp]\ntheorem basisDivisor_eq_zero_iff : basisDivisor x y = 0 \u2194 x = y", "start": [163, 1], "end": [165, 53], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor_ne_zero_iff", "code": "theorem basisDivisor_ne_zero_iff : basisDivisor x y \u2260 0 \u2194 x \u2260 y", "start": [168, 1], "end": [169, 40], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_basisDivisor_of_ne", "code": "theorem degree_basisDivisor_of_ne (hxy : x \u2260 y) : (basisDivisor x y).degree = 1", "start": [172, 1], "end": [174, 44], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_basisDivisor_self", "code": "@[simp]\ntheorem degree_basisDivisor_self : (basisDivisor x x).degree = \u22a5", "start": [177, 1], "end": [179, 38], "kind": "commanddeclaration"}, {"full_name": "Lagrange.natDegree_basisDivisor_self", "code": "theorem natDegree_basisDivisor_self : (basisDivisor x x).natDegree = 0", "start": [182, 1], "end": [183, 41], "kind": "commanddeclaration"}, {"full_name": "Lagrange.natDegree_basisDivisor_of_ne", "code": "theorem natDegree_basisDivisor_of_ne (hxy : x \u2260 y) : (basisDivisor x y).natDegree = 1", "start": [186, 1], "end": [187, 65], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_basisDivisor_right", "code": "@[simp]\ntheorem eval_basisDivisor_right : eval y (basisDivisor x y) = 0", "start": [190, 1], "end": [192, 83], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_basisDivisor_left_of_ne", "code": "theorem eval_basisDivisor_left_of_ne (hxy : x \u2260 y) : eval x (basisDivisor x y) = 1", "start": [195, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis", "code": "protected def basis (s : Finset \u03b9) (v : \u03b9 \u2192 F) (i : \u03b9) : F[X] :=\n  \u220f j in s.erase i, basisDivisor (v i) (v j)", "start": [209, 1], "end": [213, 45], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_empty", "code": "@[simp]\ntheorem basis_empty : Lagrange.basis \u2205 v i = 1", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_singleton", "code": "@[simp]\ntheorem basis_singleton (i : \u03b9) : Lagrange.basis {i} v i = 1", "start": [221, 1], "end": [223, 51], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_pair_left", "code": "@[simp]\ntheorem basis_pair_left (hij : i \u2260 j) : Lagrange.basis {i, j} v i = basisDivisor (v i) (v j)", "start": [226, 1], "end": [229, 35], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_pair_right", "code": "@[simp]\ntheorem basis_pair_right (hij : i \u2260 j) : Lagrange.basis {i, j} v j = basisDivisor (v j) (v i)", "start": [232, 1], "end": [235, 33], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_ne_zero", "code": "theorem basis_ne_zero (hvs : Set.InjOn v s) (hi : i \u2208 s) : Lagrange.basis s v i \u2260 0", "start": [238, 1], "end": [242, 17], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_basis_self", "code": "@[simp]\ntheorem eval_basis_self (hvs : Set.InjOn v s) (hi : i \u2208 s) :\n    (Lagrange.basis s v i).eval (v i) = 1", "start": [245, 1], "end": [252, 32], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_basis_of_ne", "code": "@[simp]\ntheorem eval_basis_of_ne (hij : i \u2260 j) (hj : j \u2208 s) : (Lagrange.basis s v i).eval (v j) = 0", "start": [255, 1], "end": [258, 69], "kind": "commanddeclaration"}, {"full_name": "Lagrange.natDegree_basis", "code": "@[simp]\ntheorem natDegree_basis (hvs : Set.InjOn v s) (hi : i \u2208 s) :\n    (Lagrange.basis s v i).natDegree = s.card - 1", "start": [261, 1], "end": [271, 15], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_basis", "code": "theorem degree_basis (hvs : Set.InjOn v s) (hi : i \u2208 s) :\n    (Lagrange.basis s v i).degree = \u2191(s.card - 1)", "start": [274, 1], "end": [276, 74], "kind": "commanddeclaration"}, {"full_name": "Lagrange.sum_basis", "code": "theorem sum_basis (hvs : Set.InjOn v s) (hs : s.Nonempty) :\n    \u2211 j in s, Lagrange.basis s v j = 1", "start": [280, 1], "end": [294, 33], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basisDivisor_add_symm", "code": "theorem basisDivisor_add_symm {x y : F} (hxy : x \u2260 y) :\n    basisDivisor x y + basisDivisor y x = 1", "start": [297, 1], "end": [302, 34], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate", "code": "@[simps]\ndef interpolate (s : Finset \u03b9) (v : \u03b9 \u2192 F) : (\u03b9 \u2192 F) \u2192\u2097[F] F[X] where\n  toFun r := \u2211 i in s, C (r i) * Lagrange.basis s v i\n  map_add' f g := by\n    simp_rw [\u2190 Finset.sum_add_distrib]\n    have h : (fun x => C (f x) * Lagrange.basis s v x + C (g x) * Lagrange.basis s v x) =\n    (fun x => C ((f + g) x) * Lagrange.basis s v x) := by\n      simp_rw [\u2190 add_mul, \u2190 C_add, Pi.add_apply]\n    rw [h]\n  map_smul' c f := by\n    simp_rw [Finset.smul_sum, C_mul', smul_smul, Pi.smul_apply, RingHom.id_apply, smul_eq_mul]", "start": [314, 1], "end": [327, 95], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_empty", "code": "theorem interpolate_empty : interpolate \u2205 v r = 0", "start": [332, 1], "end": [332, 90], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_singleton", "code": "theorem interpolate_singleton : interpolate {i} v r = C (r i)", "start": [337, 1], "end": [338, 66], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_one", "code": "theorem interpolate_one (hvs : Set.InjOn v s) (hs : s.Nonempty) : interpolate s v 1 = 1", "start": [341, 1], "end": [343, 25], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_interpolate_at_node", "code": "theorem eval_interpolate_at_node (hvs : Set.InjOn v s) (hi : i \u2208 s) :\n    eval (v i) (interpolate s v r) = r i", "start": [346, 1], "end": [351, 56], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_interpolate_le", "code": "theorem degree_interpolate_le (hvs : Set.InjOn v s) :\n    (interpolate s v r).degree \u2264 \u2191(s.card - 1)", "start": [354, 1], "end": [362, 31], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_interpolate_lt", "code": "theorem degree_interpolate_lt (hvs : Set.InjOn v s) : (interpolate s v r).degree < s.card", "start": [366, 1], "end": [373, 55], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_interpolate_erase_lt", "code": "theorem degree_interpolate_erase_lt (hvs : Set.InjOn v s) (hi : i \u2208 s) :\n    (interpolate (s.erase i) v r).degree < \u2191(s.card - 1)", "start": [376, 1], "end": [379, 89], "kind": "commanddeclaration"}, {"full_name": "Lagrange.values_eq_on_of_interpolate_eq", "code": "theorem values_eq_on_of_interpolate_eq (hvs : Set.InjOn v s)\n    (hrr' : interpolate s v r = interpolate s v r') : \u2200 i \u2208 s, r i = r' i", "start": [382, 1], "end": [384, 85], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_eq_of_values_eq_on", "code": "theorem interpolate_eq_of_values_eq_on (hrr' : \u2200 i \u2208 s, r i = r' i) :\n    interpolate s v r = interpolate s v r'", "start": [387, 1], "end": [389, 46], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_eq_iff_values_eq_on", "code": "theorem interpolate_eq_iff_values_eq_on (hvs : Set.InjOn v s) :\n    interpolate s v r = interpolate s v r' \u2194 \u2200 i \u2208 s, r i = r' i", "start": [392, 1], "end": [394, 79], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eq_interpolate", "code": "theorem eq_interpolate {f : F[X]} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card) :\n    f = interpolate s v fun i => f.eval (v i)", "start": [397, 1], "end": [400, 66], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eq_interpolate_of_eval_eq", "code": "theorem eq_interpolate_of_eval_eq {f : F[X]} (hvs : Set.InjOn v s) (degree_f_lt : f.degree < s.card)\n    (eval_f : \u2200 i \u2208 s, f.eval (v i) = r i) : f = interpolate s v r", "start": [403, 1], "end": [406, 50], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eq_interpolate_iff", "code": "theorem eq_interpolate_iff {f : F[X]} (hvs : Set.InjOn v s) :\n    (f.degree < s.card \u2227 \u2200 i \u2208 s, eval (v i) f = r i) \u2194 f = interpolate s v r", "start": [409, 1], "end": [417, 87], "kind": "commanddeclaration"}, {"full_name": "Lagrange.funEquivDegreeLT", "code": "def funEquivDegreeLT (hvs : Set.InjOn v s) : degreeLT F s.card \u2243\u2097[F] s \u2192 F where\n  toFun f i := f.1.eval (v i)\n  map_add' f g := funext fun v => eval_add\n  map_smul' c f := funext <| by simp\n  invFun r :=\n    \u27e8interpolate s v fun x => if hx : x \u2208 s then r \u27e8x, hx\u27e9 else 0,\n      mem_degreeLT.2 <| degree_interpolate_lt _ hvs\u27e9\n  left_inv := by\n    rintro \u27e8f, hf\u27e9\n    simp only [Subtype.mk_eq_mk, Subtype.coe_mk, dite_eq_ite]\n    rw [mem_degreeLT] at hf\n    conv => rhs; rw [eq_interpolate hvs hf]\n    exact interpolate_eq_of_values_eq_on _ _ fun _ hi => if_pos hi\n  right_inv := by\n    intro f\n    ext \u27e8i, hi\u27e9\n    simp only [Subtype.coe_mk, eval_interpolate_at_node _ hvs hi]\n    exact dif_pos hi", "start": [420, 1], "end": [439, 21], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_eq_sum_interpolate_insert_sdiff", "code": "theorem interpolate_eq_sum_interpolate_insert_sdiff (hvt : Set.InjOn v t) (hs : s.Nonempty)\n    (hst : s \u2286 t) :\n    interpolate t v r = \u2211 i in s, interpolate (insert i (t \\ s)) v r * Lagrange.basis s v i", "start": [443, 1], "end": [477, 62], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_eq_add_interpolate_erase", "code": "theorem interpolate_eq_add_interpolate_erase (hvs : Set.InjOn v s) (hi : i \u2208 s) (hj : j \u2208 s)\n    (hij : i \u2260 j) :\n    interpolate s v r =\n      interpolate (s.erase j) v r * basisDivisor (v i) (v j) +\n        interpolate (s.erase i) v r * basisDivisor (v j) (v i)", "start": [480, 1], "end": [491, 66], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal", "code": "def nodal (s : Finset \u03b9) (v : \u03b9 \u2192 R) : R[X] :=\n  \u220f i in s, (X - C (v i))", "start": [503, 1], "end": [512, 26], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_eq", "code": "theorem nodal_eq (s : Finset \u03b9) (v : \u03b9 \u2192 R) : nodal s v = \u220f i in s, (X - C (v i))", "start": [515, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_empty", "code": "@[simp]\ntheorem nodal_empty : nodal \u2205 v = 1", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "Lagrange.natDegree_nodal", "code": "@[simp]\ntheorem natDegree_nodal [Nontrivial R] : (nodal s v).natDegree = s.card", "start": [524, 1], "end": [527, 56], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_ne_zero", "code": "theorem nodal_ne_zero [Nontrivial R] : nodal s v \u2260 0", "start": [529, 1], "end": [533, 42], "kind": "commanddeclaration"}, {"full_name": "Lagrange.degree_nodal", "code": "@[simp]\ntheorem degree_nodal [Nontrivial R] : (nodal s v).degree = s.card", "start": [535, 1], "end": [537, 65], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_monic", "code": "theorem nodal_monic : (nodal s v).Monic", "start": [540, 1], "end": [541, 76], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_nodal", "code": "theorem eval_nodal {x : R} : (nodal s v).eval x = \u220f i in s, (x - v i)", "start": [543, 1], "end": [544, 55], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_nodal_at_node", "code": "theorem eval_nodal_at_node {i : \u03b9} (hi : i \u2208 s) : eval (v i) (nodal s v) = 0", "start": [547, 1], "end": [549, 43], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_nodal_not_at_node", "code": "theorem eval_nodal_not_at_node [Nontrivial R] [NoZeroDivisors R] {x : R}\n    (hx : \u2200 i \u2208 s, x \u2260 v i) : eval x (nodal s v) \u2260 0", "start": [553, 1], "end": [556, 11], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_eq_mul_nodal_erase", "code": "theorem nodal_eq_mul_nodal_erase [DecidableEq \u03b9] {i : \u03b9} (hi : i \u2208 s) :\n    nodal s v = (X - C (v i)) * nodal (s.erase i) v", "start": [559, 1], "end": [561, 71], "kind": "commanddeclaration"}, {"full_name": "Lagrange.X_sub_C_dvd_nodal", "code": "theorem X_sub_C_dvd_nodal (v : \u03b9 \u2192 R) {i : \u03b9} (hi : i \u2208 s) : X - C (v i) \u2223 nodal s v", "start": [564, 1], "end": [565, 54], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_insert_eq_nodal", "code": "theorem nodal_insert_eq_nodal [DecidableEq \u03b9] {i : \u03b9} (hi : i \u2209 s) :\n    nodal (insert i s) v = (X - C (v i)) * nodal s v", "start": [569, 1], "end": [571, 34], "kind": "commanddeclaration"}, {"full_name": "Lagrange.derivative_nodal", "code": "theorem derivative_nodal [DecidableEq \u03b9] :\n    derivative (nodal s v) = \u2211 i in s, nodal (s.erase i) v", "start": [574, 1], "end": [582, 55], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_nodal_derivative_eval_node_eq", "code": "theorem eval_nodal_derivative_eval_node_eq [DecidableEq \u03b9] {i : \u03b9} (hi : i \u2208 s) :\n    eval (v i) (derivative (nodal s v)) = eval (v i) (nodal (s.erase i) v)", "start": [585, 1], "end": [588, 100], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_subgroup_eq_X_pow_card_sub_one", "code": "@[simp] theorem nodal_subgroup_eq_X_pow_card_sub_one [IsDomain R]\n  (G : Subgroup R\u02e3) [Fintype G] :\n  nodal (G : Set R\u02e3).toFinset ((\u2191) : R\u02e3 \u2192 R) = X ^ (Fintype.card G) - 1", "start": [591, 1], "end": [607, 60], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodalWeight", "code": "def nodalWeight (s : Finset \u03b9) (v : \u03b9 \u2192 F) (i : \u03b9) :=\n  \u220f j in s.erase i, (v i - v j)\u207b\u00b9", "start": [618, 1], "end": [620, 34], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodalWeight_eq_eval_nodal_erase_inv", "code": "theorem nodalWeight_eq_eval_nodal_erase_inv :\n    nodalWeight s v i = (eval (v i) (nodal (s.erase i) v))\u207b\u00b9", "start": [623, 1], "end": [625, 49], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodal_erase_eq_nodal_div", "code": "theorem nodal_erase_eq_nodal_div (hi : i \u2208 s) :\n    nodal (s.erase i) v = nodal s v / (X - C (v i))", "start": [628, 1], "end": [631, 26], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodalWeight_eq_eval_nodal_derative", "code": "theorem nodalWeight_eq_eval_nodal_derative (hi : i \u2208 s) :\n    nodalWeight s v i = (eval (v i) (Polynomial.derivative (nodal s v)))\u207b\u00b9", "start": [634, 1], "end": [636, 82], "kind": "commanddeclaration"}, {"full_name": "Lagrange.nodalWeight_ne_zero", "code": "theorem nodalWeight_ne_zero (hvs : Set.InjOn v s) (hi : i \u2208 s) : nodalWeight s v i \u2260 0", "start": [639, 1], "end": [643, 78], "kind": "commanddeclaration"}, {"full_name": "Lagrange.basis_eq_prod_sub_inv_mul_nodal_div", "code": "theorem basis_eq_prod_sub_inv_mul_nodal_div (hi : i \u2208 s) :\n    Lagrange.basis s v i = C (nodalWeight s v i) * (nodal s v / (X - C (v i)))", "start": [655, 1], "end": [658, 40], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_basis_not_at_node", "code": "theorem eval_basis_not_at_node (hi : i \u2208 s) (hxi : x \u2260 v i) :\n    eval x (Lagrange.basis s v i) = eval x (nodal s v) * (nodalWeight s v i * (x - v i)\u207b\u00b9)", "start": [661, 1], "end": [665, 76], "kind": "commanddeclaration"}, {"full_name": "Lagrange.interpolate_eq_nodalWeight_mul_nodal_div_X_sub_C", "code": "theorem interpolate_eq_nodalWeight_mul_nodal_div_X_sub_C :\n    interpolate s v r = \u2211 i in s, C (nodalWeight s v i) * (nodal s v / (X - C (v i))) * C (r i)", "start": [668, 1], "end": [670, 85], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_interpolate_not_at_node", "code": "theorem eval_interpolate_not_at_node (hx : \u2200 i \u2208 s, x \u2260 v i) :\n    eval x (interpolate s v r) =\n      eval x (nodal s v) * \u2211 i in s, nodalWeight s v i * (x - v i)\u207b\u00b9 * r i", "start": [674, 1], "end": [680, 66], "kind": "commanddeclaration"}, {"full_name": "Lagrange.sum_nodalWeight_mul_inv_sub_ne_zero", "code": "theorem sum_nodalWeight_mul_inv_sub_ne_zero (hvs : Set.InjOn v s) (hx : \u2200 i \u2208 s, x \u2260 v i)\n    (hs : s.Nonempty) : (\u2211 i in s, nodalWeight s v i * (x - v i)\u207b\u00b9) \u2260 0", "start": [683, 1], "end": [687, 47], "kind": "commanddeclaration"}, {"full_name": "Lagrange.eval_interpolate_not_at_node'", "code": "theorem eval_interpolate_not_at_node' (hvs : Set.InjOn v s) (hs : s.Nonempty)\n    (hx : \u2200 i \u2208 s, x \u2260 v i) :\n    eval x (interpolate s v r) =\n      (\u2211 i in s, nodalWeight s v i * (x - v i)\u207b\u00b9 * r i) /\n        \u2211 i in s, nodalWeight s v i * (x - v i)\u207b\u00b9", "start": [690, 1], "end": [698, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/AssociatedPrime.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "Mathlib/RingTheory/Noetherian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Ideal/Operations.lean"], "premises": [{"full_name": "IsAssociatedPrime", "code": "def IsAssociatedPrime : Prop :=\n  I.IsPrime \u2227 \u2203 x : M, I = (R \u2219 x).annihilator", "start": [39, 1], "end": [41, 47], "kind": "commanddeclaration"}, {"full_name": "associatedPrimes", "code": "def associatedPrimes : Set (Ideal R) :=\n  { I | IsAssociatedPrime I M }", "start": [46, 1], "end": [48, 32], "kind": "commanddeclaration"}, {"full_name": "AssociatePrimes.mem_iff", "code": "theorem AssociatePrimes.mem_iff : I \u2208 associatedPrimes R M \u2194 IsAssociatedPrime I M", "start": [55, 1], "end": [55, 94], "kind": "commanddeclaration"}, {"full_name": "IsAssociatedPrime.isPrime", "code": "theorem IsAssociatedPrime.isPrime (h : IsAssociatedPrime I M) : I.IsPrime", "start": [58, 1], "end": [58, 81], "kind": "commanddeclaration"}, {"full_name": "IsAssociatedPrime.map_of_injective", "code": "theorem IsAssociatedPrime.map_of_injective (h : IsAssociatedPrime I M) (hf : Function.Injective f) :\n    IsAssociatedPrime I M'", "start": [60, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.isAssociatedPrime_iff", "code": "theorem LinearEquiv.isAssociatedPrime_iff (l : M \u2243\u2097[R] M') :\n    IsAssociatedPrime I M \u2194 IsAssociatedPrime I M'", "start": [69, 1], "end": [72, 57], "kind": "commanddeclaration"}, {"full_name": "not_isAssociatedPrime_of_subsingleton", "code": "theorem not_isAssociatedPrime_of_subsingleton [Subsingleton M] : \u00acIsAssociatedPrime I M", "start": [75, 1], "end": [79, 10], "kind": "commanddeclaration"}, {"full_name": "exists_le_isAssociatedPrime_of_isNoetherianRing", "code": "theorem exists_le_isAssociatedPrime_of_isNoetherianRing [H : IsNoetherianRing R] (x : M)\n    (hx : x \u2260 0) : \u2203 P : Ideal R, IsAssociatedPrime P M \u2227 (R \u2219 x).annihilator \u2264 P", "start": [84, 1], "end": [104, 68], "kind": "commanddeclaration"}, {"full_name": "associatedPrimes.subset_of_injective", "code": "theorem associatedPrimes.subset_of_injective (hf : Function.Injective f) :\n    associatedPrimes R M \u2286 associatedPrimes R M'", "start": [109, 1], "end": [110, 88], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.AssociatedPrimes.eq", "code": "theorem LinearEquiv.AssociatedPrimes.eq (l : M \u2243\u2097[R] M') :\n    associatedPrimes R M = associatedPrimes R M'", "start": [113, 1], "end": [116, 67], "kind": "commanddeclaration"}, {"full_name": "associatedPrimes.eq_empty_of_subsingleton", "code": "theorem associatedPrimes.eq_empty_of_subsingleton [Subsingleton M] : associatedPrimes R M = \u2205", "start": [119, 1], "end": [121, 46], "kind": "commanddeclaration"}, {"full_name": "associatedPrimes.nonempty", "code": "theorem associatedPrimes.nonempty [IsNoetherianRing R] [Nontrivial M] :\n    (associatedPrimes R M).Nonempty", "start": [126, 1], "end": [130, 16], "kind": "commanddeclaration"}, {"full_name": "IsAssociatedPrime.annihilator_le", "code": "theorem IsAssociatedPrime.annihilator_le (h : IsAssociatedPrime I M) :\n    (\u22a4 : Submodule R M).annihilator \u2264 I", "start": [135, 1], "end": [138, 42], "kind": "commanddeclaration"}, {"full_name": "IsAssociatedPrime.eq_radical", "code": "theorem IsAssociatedPrime.eq_radical (hI : I.IsPrimary) (h : IsAssociatedPrime J (R \u29f8 I)) :\n    J = I.radical", "start": [141, 1], "end": [158, 38], "kind": "commanddeclaration"}, {"full_name": "associatedPrimes.eq_singleton_of_isPrimary", "code": "theorem associatedPrimes.eq_singleton_of_isPrimary [IsNoetherianRing R] (hI : I.IsPrimary) :\n    associatedPrimes R (R \u29f8 I) = {I.radical}", "start": [161, 1], "end": [172, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Connected.lean", "imports": ["Mathlib/Topology/Algebra/Module/Cardinality.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/Analysis/Convex/Topology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Countable.isPathConnected_compl_of_one_lt_rank", "code": "theorem Set.Countable.isPathConnected_compl_of_one_lt_rank\n    (h : 1 < Module.rank \u211d E) {s : Set E} (hs : s.Countable) :\n    IsPathConnected s\u1d9c", "start": [30, 1], "end": [101, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.isConnected_compl_of_one_lt_rank", "code": "theorem Set.Countable.isConnected_compl_of_one_lt_rank (h : 1 < Module.rank \u211d E) {s : Set E}\n    (hs : s.Countable) : IsConnected s\u1d9c", "start": [103, 1], "end": [107, 58], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_compl_singleton_of_one_lt_rank", "code": "theorem isPathConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsPathConnected {x}\u1d9c", "start": [109, 1], "end": [113, 79], "kind": "commanddeclaration"}, {"full_name": "isConnected_compl_singleton_of_one_lt_rank", "code": "theorem isConnected_compl_singleton_of_one_lt_rank (h : 1 < Module.rank \u211d E) (x : E) :\n    IsConnected {x}\u1d9c", "start": [115, 1], "end": [119, 67], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_sphere", "code": "theorem isPathConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsPathConnected (sphere x r)", "start": [127, 1], "end": [156, 18], "kind": "commanddeclaration"}, {"full_name": "isConnected_sphere", "code": "theorem isConnected_sphere (h : 1 < Module.rank \u211d E) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    IsConnected (sphere x r)", "start": [158, 1], "end": [161, 46], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_sphere", "code": "theorem isPreconnected_sphere (h : 1 < Module.rank \u211d E) (x : E) (r : \u211d) :\n    IsPreconnected (sphere x r)", "start": [163, 1], "end": [168, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Angle/Sphere.lean", "imports": ["Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean", "Mathlib/Geometry/Euclidean/Circumcenter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq", "code": "theorem oangle_eq_two_zsmul_oangle_sub_of_norm_eq {x y z : V} (hxyne : x \u2260 y) (hxzne : x \u2260 z)\n    (hxy : \u2016x\u2016 = \u2016y\u2016) (hxz : \u2016x\u2016 = \u2016z\u2016) : o.oangle y z = (2 : \u2124) \u2022 o.oangle (y - x) (z - x)", "start": [31, 1], "end": [49, 89], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real", "code": "theorem oangle_eq_two_zsmul_oangle_sub_of_norm_eq_real {x y z : V} (hxyne : x \u2260 y) (hxzne : x \u2260 z)\n    {r : \u211d} (hx : \u2016x\u2016 = r) (hy : \u2016y\u2016 = r) (hz : \u2016z\u2016 = r) :\n    o.oangle y z = (2 : \u2124) \u2022 o.oangle (y - x) (z - x)", "start": [52, 1], "end": [57, 88], "kind": "commanddeclaration"}, {"full_name": "Orientation.two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq", "code": "theorem two_zsmul_oangle_sub_eq_two_zsmul_oangle_sub_of_norm_eq {x\u2081 x\u2082 y z : V} (hx\u2081yne : x\u2081 \u2260 y)\n    (hx\u2081zne : x\u2081 \u2260 z) (hx\u2082yne : x\u2082 \u2260 y) (hx\u2082zne : x\u2082 \u2260 z) {r : \u211d} (hx\u2081 : \u2016x\u2081\u2016 = r) (hx\u2082 : \u2016x\u2082\u2016 = r)\n    (hy : \u2016y\u2016 = r) (hz : \u2016z\u2016 = r) :\n    (2 : \u2124) \u2022 o.oangle (y - x\u2081) (z - x\u2081) = (2 : \u2124) \u2022 o.oangle (y - x\u2082) (z - x\u2082)", "start": [60, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.oangle_center_eq_two_zsmul_oangle", "code": "theorem oangle_center_eq_two_zsmul_oangle {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) (hp\u2082p\u2081 : p\u2082 \u2260 p\u2081) (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) :\n    \u2221 p\u2081 s.center p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083", "start": [82, 1], "end": [88, 24], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.two_zsmul_oangle_eq", "code": "theorem two_zsmul_oangle_eq {s : Sphere P} {p\u2081 p\u2082 p\u2083 p\u2084 : P} (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s)\n    (hp\u2083 : p\u2083 \u2208 s) (hp\u2084 : p\u2084 \u2208 s) (hp\u2082p\u2081 : p\u2082 \u2260 p\u2081) (hp\u2082p\u2084 : p\u2082 \u2260 p\u2084) (hp\u2083p\u2081 : p\u2083 \u2260 p\u2081)\n    (hp\u2083p\u2084 : p\u2083 \u2260 p\u2084) : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084", "start": [91, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical.two_zsmul_oangle_eq", "code": "theorem Cospherical.two_zsmul_oangle_eq {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : Cospherical ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P)) (hp\u2082p\u2081 : p\u2082 \u2260 p\u2081) (hp\u2082p\u2084 : p\u2082 \u2260 p\u2084)\n    (hp\u2083p\u2081 : p\u2083 \u2260 p\u2081) (hp\u2083p\u2084 : p\u2083 \u2260 p\u2084) : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084", "start": [106, 1], "end": [114, 89], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.oangle_eq_pi_sub_two_zsmul_oangle_center_left", "code": "theorem oangle_eq_pi_sub_two_zsmul_oangle_center_left {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (h : p\u2081 \u2260 p\u2082) : \u2221 p\u2081 s.center p\u2082 = \u03c0 - (2 : \u2124) \u2022 \u2221 s.center p\u2082 p\u2081", "start": [119, 1], "end": [124, 59], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.oangle_eq_pi_sub_two_zsmul_oangle_center_right", "code": "theorem oangle_eq_pi_sub_two_zsmul_oangle_center_right {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (h : p\u2081 \u2260 p\u2082) : \u2221 p\u2081 s.center p\u2082 = \u03c0 - (2 : \u2124) \u2022 \u2221 p\u2082 p\u2081 s.center", "start": [127, 1], "end": [132, 85], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi", "code": "theorem two_zsmul_oangle_center_add_two_zsmul_oangle_eq_pi {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) (hp\u2082p\u2081 : p\u2082 \u2260 p\u2081) (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083)\n    (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : (2 : \u2124) \u2022 \u2221 p\u2083 p\u2081 s.center + (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = \u03c0", "start": [135, 1], "end": [141, 89], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.abs_oangle_center_left_toReal_lt_pi_div_two", "code": "theorem abs_oangle_center_left_toReal_lt_pi_div_two {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) : |(\u2221 s.center p\u2082 p\u2081).toReal| < \u03c0 / 2", "start": [144, 1], "end": [148, 56], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.abs_oangle_center_right_toReal_lt_pi_div_two", "code": "theorem abs_oangle_center_right_toReal_lt_pi_div_two {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) : |(\u2221 p\u2082 p\u2081 s.center).toReal| < \u03c0 / 2", "start": [151, 1], "end": [155, 56], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center", "code": "theorem tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center {s : Sphere P} {p\u2081 p\u2082 : P}\n    (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (h : p\u2081 \u2260 p\u2082) :\n    (Real.Angle.tan (\u2221 p\u2082 p\u2081 s.center) / 2) \u2022 o.rotation (\u03c0 / 2 : \u211d) (p\u2082 -\u1d65 p\u2081) +\u1d65\n      midpoint \u211d p\u2081 p\u2082 = s.center", "start": [158, 1], "end": [172, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center", "code": "theorem inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center {s : Sphere P}\n    {p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083)\n    (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) :\n    ((Real.Angle.tan (\u2221 p\u2081 p\u2082 p\u2083))\u207b\u00b9 / 2) \u2022 o.rotation (\u03c0 / 2 : \u211d) (p\u2083 -\u1d65 p\u2081) +\u1d65 midpoint \u211d p\u2081 p\u2083 =\n      s.center", "start": [175, 1], "end": [186, 91], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.dist_div_cos_oangle_center_div_two_eq_radius", "code": "theorem dist_div_cos_oangle_center_div_two_eq_radius {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (h : p\u2081 \u2260 p\u2082) :\n    dist p\u2081 p\u2082 / Real.Angle.cos (\u2221 p\u2082 p\u2081 s.center) / 2 = s.radius", "start": [189, 1], "end": [213, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.dist_div_cos_oangle_center_eq_two_mul_radius", "code": "theorem dist_div_cos_oangle_center_eq_two_mul_radius {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (h : p\u2081 \u2260 p\u2082) :\n    dist p\u2081 p\u2082 / Real.Angle.cos (\u2221 p\u2082 p\u2081 s.center) = 2 * s.radius", "start": [216, 1], "end": [222, 100], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.dist_div_sin_oangle_div_two_eq_radius", "code": "theorem dist_div_sin_oangle_div_two_eq_radius {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) :\n    dist p\u2081 p\u2083 / |Real.Angle.sin (\u2221 p\u2081 p\u2082 p\u2083)| / 2 = s.radius", "start": [225, 1], "end": [235, 66], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.dist_div_sin_oangle_eq_two_mul_radius", "code": "theorem dist_div_sin_oangle_eq_two_mul_radius {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) :\n    dist p\u2081 p\u2083 / |Real.Angle.sin (\u2221 p\u2081 p\u2082 p\u2083)| = 2 * s.radius", "start": [238, 1], "end": [245, 40], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter", "code": "theorem inv_tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_circumcenter (t : Triangle \u211d P)\n    {i\u2081 i\u2082 i\u2083 : Fin 3} (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083) :\n    ((Real.Angle.tan (\u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083)))\u207b\u00b9 / 2) \u2022\n      o.rotation (\u03c0 / 2 : \u211d) (t.points i\u2083 -\u1d65 t.points i\u2081) +\u1d65\n        midpoint \u211d (t.points i\u2081) (t.points i\u2083) = t.circumcenter", "start": [263, 1], "end": [273, 70], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.dist_div_sin_oangle_div_two_eq_circumradius", "code": "theorem dist_div_sin_oangle_div_two_eq_circumradius (t : Triangle \u211d P) {i\u2081 i\u2082 i\u2083 : Fin 3}\n    (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083) : dist (t.points i\u2081) (t.points i\u2083) /\n      |Real.Angle.sin (\u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083))| / 2 = t.circumradius", "start": [276, 1], "end": [284, 37], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.dist_div_sin_oangle_eq_two_mul_circumradius", "code": "theorem dist_div_sin_oangle_eq_two_mul_circumradius (t : Triangle \u211d P) {i\u2081 i\u2082 i\u2083 : Fin 3}\n    (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083) : dist (t.points i\u2081) (t.points i\u2083) /\n      |Real.Angle.sin (\u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083))| = 2 * t.circumradius", "start": [287, 1], "end": [295, 37], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.circumsphere_eq_of_dist_of_oangle", "code": "theorem circumsphere_eq_of_dist_of_oangle (t : Triangle \u211d P) {i\u2081 i\u2082 i\u2083 : Fin 3} (h\u2081\u2082 : i\u2081 \u2260 i\u2082)\n    (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083) : t.circumsphere =\n    \u27e8((Real.Angle.tan (\u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083)))\u207b\u00b9 / 2) \u2022\n      o.rotation (\u03c0 / 2 : \u211d) (t.points i\u2083 -\u1d65 t.points i\u2081) +\u1d65 midpoint \u211d (t.points i\u2081) (t.points i\u2083),\n      dist (t.points i\u2081) (t.points i\u2083) /\n        |Real.Angle.sin (\u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083))| / 2\u27e9", "start": [298, 1], "end": [308, 69], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.circumsphere_eq_circumsphere_of_eq_of_eq_of_two_zsmul_oangle_eq", "code": "theorem circumsphere_eq_circumsphere_of_eq_of_eq_of_two_zsmul_oangle_eq {t\u2081 t\u2082 : Triangle \u211d P}\n    {i\u2081 i\u2082 i\u2083 : Fin 3} (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083)\n    (h\u2081 : t\u2081.points i\u2081 = t\u2082.points i\u2081) (h\u2083 : t\u2081.points i\u2083 = t\u2082.points i\u2083)\n    (h\u2082 : (2 : \u2124) \u2022 \u2221 (t\u2081.points i\u2081) (t\u2081.points i\u2082) (t\u2081.points i\u2083) =\n      (2 : \u2124) \u2022 \u2221 (t\u2082.points i\u2081) (t\u2082.points i\u2082) (t\u2082.points i\u2083)) :\n    t\u2081.circumsphere = t\u2082.circumsphere", "start": [311, 1], "end": [322, 92], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle.mem_circumsphere_of_two_zsmul_oangle_eq", "code": "theorem mem_circumsphere_of_two_zsmul_oangle_eq {t : Triangle \u211d P} {p : P} {i\u2081 i\u2082 i\u2083 : Fin 3}\n    (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083)\n    (h : (2 : \u2124) \u2022 \u2221 (t.points i\u2081) p (t.points i\u2083) =\n      (2 : \u2124) \u2022 \u2221 (t.points i\u2081) (t.points i\u2082) (t.points i\u2083)) : p \u2208 t.circumsphere", "start": [325, 1], "end": [349, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_of_two_zsmul_oangle_eq_of_not_collinear", "code": "theorem cospherical_of_two_zsmul_oangle_eq_of_not_collinear {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084) (hn : \u00acCollinear \u211d ({p\u2081, p\u2082, p\u2084} : Set P)) :\n    Cospherical ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P)", "start": [363, 1], "end": [379, 30], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.concyclic_of_two_zsmul_oangle_eq_of_not_collinear", "code": "theorem concyclic_of_two_zsmul_oangle_eq_of_not_collinear {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084) (hn : \u00acCollinear \u211d ({p\u2081, p\u2082, p\u2084} : Set P)) :\n    Concyclic ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P)", "start": [382, 1], "end": [387, 96], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_or_collinear_of_two_zsmul_oangle_eq", "code": "theorem cospherical_or_collinear_of_two_zsmul_oangle_eq {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084) :\n    Cospherical ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P) \u2228 Collinear \u211d ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P)", "start": [390, 1], "end": [412, 76], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.concyclic_or_collinear_of_two_zsmul_oangle_eq", "code": "theorem concyclic_or_collinear_of_two_zsmul_oangle_eq {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2084 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2083 p\u2084) :\n    Concyclic ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P) \u2228 Collinear \u211d ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P)", "start": [415, 1], "end": [422, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Analytic/Inverse.lean", "imports": ["Mathlib/Analysis/Analytic/Composition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FormalMultilinearSeries.leftInv", "code": "noncomputable def leftInv (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    FormalMultilinearSeries \ud835\udd5c F E\n  | 0 => 0\n  | 1 => (continuousMultilinearCurryFin1 \ud835\udd5c F E).symm i.symm\n  | n + 2 =>\n    -\u2211 c : { c : Composition (n + 2) // c.length < n + 2 },\n        (leftInv p i (c : Composition (n + 2)).length).compAlongComposition\n          (p.compContinuousLinearMap i.symm) c\n  decreasing_by exact c.2", "start": [44, 1], "end": [65, 26], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_coeff_zero", "code": "@[simp]\ntheorem leftInv_coeff_zero (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.leftInv i 0 = 0", "start": [68, 1], "end": [70, 41], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_coeff_one", "code": "@[simp]\ntheorem leftInv_coeff_one (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.leftInv i 1 = (continuousMultilinearCurryFin1 \ud835\udd5c F E).symm i.symm", "start": [73, 1], "end": [75, 90], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_removeZero", "code": "theorem leftInv_removeZero (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.removeZero.leftInv i = p.leftInv i", "start": [78, 1], "end": [93, 19], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_comp", "code": "theorem leftInv_comp (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F)\n    (h : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i) : (leftInv p i).comp p = id \ud835\udd5c E", "start": [96, 1], "end": [149, 56], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.rightInv", "code": "noncomputable def rightInv (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    FormalMultilinearSeries \ud835\udd5c F E\n  | 0 => 0\n  | 1 => (continuousMultilinearCurryFin1 \ud835\udd5c F E).symm i.symm\n  | n + 2 =>\n    let q : FormalMultilinearSeries \ud835\udd5c F E := fun k => if k < n + 2 then rightInv p i k else 0;\n    -(i.symm : F \u2192L[\ud835\udd5c] E).compContinuousMultilinearMap ((p.comp q) (n + 2))", "start": [155, 1], "end": [174, 76], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.rightInv_coeff_zero", "code": "@[simp]\ntheorem rightInv_coeff_zero (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.rightInv i 0 = 0", "start": [177, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.rightInv_coeff_one", "code": "@[simp]\ntheorem rightInv_coeff_one (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.rightInv i 1 = (continuousMultilinearCurryFin1 \ud835\udd5c F E).symm i.symm", "start": [182, 1], "end": [184, 92], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.rightInv_removeZero", "code": "theorem rightInv_removeZero (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) :\n    p.removeZero.rightInv i = p.rightInv i", "start": [187, 1], "end": [200, 46], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.comp_rightInv_aux1", "code": "theorem comp_rightInv_aux1 {n : \u2115} (hn : 0 < n) (p : FormalMultilinearSeries \ud835\udd5c E F)\n    (q : FormalMultilinearSeries \ud835\udd5c F E) (v : Fin n \u2192 F) :\n    p.comp q n v =\n      \u2211 c : Composition n in {c : Composition n | 1 < c.length}.toFinset,\n          p c.length (q.applyComposition c v) +\n        p 1 fun _ => q n v", "start": [203, 1], "end": [229, 48], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.comp_rightInv_aux2", "code": "theorem comp_rightInv_aux2 (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) (n : \u2115)\n    (v : Fin (n + 2) \u2192 F) :\n    \u2211 c : Composition (n + 2) in {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length (applyComposition (fun k : \u2115 => ite (k < n + 2) (p.rightInv i k) 0) c v) =\n      \u2211 c : Composition (n + 2) in {c : Composition (n + 2) | 1 < c.length}.toFinset,\n        p c.length ((p.rightInv i).applyComposition c v)", "start": [232, 1], "end": [244, 32], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.comp_rightInv", "code": "theorem comp_rightInv (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F)\n    (h : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i) (h0 : p 0 = 0) :\n    p.comp (rightInv p i) = id \ud835\udd5c F", "start": [247, 1], "end": [263, 78], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.rightInv_coeff", "code": "theorem rightInv_coeff (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) (n : \u2115) (hn : 2 \u2264 n) :\n    p.rightInv i n =\n      -(i.symm : F \u2192L[\ud835\udd5c] E).compContinuousMultilinearMap\n          (\u2211 c in ({c | 1 < Composition.length c}.toFinset : Finset (Composition n)),\n            p.compAlongComposition (p.rightInv i) c)", "start": [266, 1], "end": [280, 92], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_eq_rightInv_aux", "code": "private theorem leftInv_eq_rightInv_aux (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F)\n    (h : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i) (h0 : p 0 = 0) :\n    leftInv p i = rightInv p i", "start": [286, 1], "end": [294, 32], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.leftInv_eq_rightInv", "code": "theorem leftInv_eq_rightInv (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F)\n    (h : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i) : leftInv p i = rightInv p i", "start": [296, 1], "end": [304, 52], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.radius_right_inv_pos_of_radius_pos_aux1", "code": "theorem radius_right_inv_pos_of_radius_pos_aux1 (n : \u2115) (p : \u2115 \u2192 \u211d) (hp : \u2200 k, 0 \u2264 p k) {r a : \u211d}\n    (hr : 0 \u2264 r) (ha : 0 \u2264 a) :\n    \u2211 k in Ico 2 (n + 1),\n        a ^ k *\n          \u2211 c in ({c | 1 < Composition.length c}.toFinset : Finset (Composition k)),\n            r ^ c.length * \u220f j, p (c.blocksFun j) \u2264\n      \u2211 j in Ico 2 (n + 1), r ^ j * (\u2211 k in Ico 1 n, a ^ k * p k) ^ j", "start": [377, 1], "end": [437, 44], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos_aux2", "code": "theorem radius_rightInv_pos_of_radius_pos_aux2 {n : \u2115} (hn : 2 \u2264 n + 1)\n    (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F) {r a C : \u211d} (hr : 0 \u2264 r) (ha : 0 \u2264 a)\n    (hC : 0 \u2264 C) (hp : \u2200 n, \u2016p n\u2016 \u2264 C * r ^ n) :\n    \u2211 k in Ico 1 (n + 1), a ^ k * \u2016p.rightInv i k\u2016 \u2264\n      \u2016(i.symm : F \u2192L[\ud835\udd5c] E)\u2016 * a +\n        \u2016(i.symm : F \u2192L[\ud835\udd5c] E)\u2016 * C *\n          \u2211 k in Ico 2 (n + 1), (r * \u2211 j in Ico 1 n, a ^ j * \u2016p.rightInv i j\u2016) ^ k", "start": [440, 1], "end": [500, 41], "kind": "commanddeclaration"}, {"full_name": "FormalMultilinearSeries.radius_rightInv_pos_of_radius_pos", "code": "theorem radius_rightInv_pos_of_radius_pos (p : FormalMultilinearSeries \ud835\udd5c E F) (i : E \u2243L[\ud835\udd5c] F)\n    (hp : 0 < p.radius) : 0 < (p.rightInv i).radius", "start": [503, 1], "end": [579, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/FrobeniusNumber.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Tactic/Zify.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Data/Nat/ModEq.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean"], "premises": [{"full_name": "FrobeniusNumber", "code": "def FrobeniusNumber (n : \u2115) (s : Set \u2115) : Prop :=\n  IsGreatest { k | k \u2209 AddSubmonoid.closure s } n", "start": [45, 1], "end": [49, 50], "kind": "commanddeclaration"}, {"full_name": "frobeniusNumber_pair", "code": "theorem frobeniusNumber_pair (cop : Coprime m n) (hm : 1 < m) (hn : 1 < n) :\n    FrobeniusNumber (m * n - m - n) {m, n}", "start": [54, 1], "end": [83, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Nullstellensatz.lean", "imports": ["Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/FieldTheory/MvPolynomial.lean", "Mathlib/RingTheory/Jacobson.lean"], "premises": [{"full_name": "MvPolynomial.zeroLocus", "code": "def zeroLocus (I : Ideal (MvPolynomial \u03c3 k)) : Set (\u03c3 \u2192 k) :=\n  {x : \u03c3 \u2192 k | \u2200 p \u2208 I, eval x p = 0}", "start": [40, 1], "end": [42, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_zeroLocus_iff", "code": "@[simp]\ntheorem mem_zeroLocus_iff {I : Ideal (MvPolynomial \u03c3 k)} {x : \u03c3 \u2192 k} :\n    x \u2208 zeroLocus I \u2194 \u2200 p \u2208 I, eval x p = 0", "start": [45, 1], "end": [48, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_anti_mono", "code": "theorem zeroLocus_anti_mono {I J : Ideal (MvPolynomial \u03c3 k)} (h : I \u2264 J) :\n    zeroLocus J \u2264 zeroLocus I", "start": [51, 1], "end": [52, 63], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_bot", "code": "@[simp]\ntheorem zeroLocus_bot : zeroLocus (\u22a5 : Ideal (MvPolynomial \u03c3 k)) = \u22a4", "start": [55, 1], "end": [57, 97], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_top", "code": "@[simp]\ntheorem zeroLocus_top : zeroLocus (\u22a4 : Ideal (MvPolynomial \u03c3 k)) = \u22a5", "start": [60, 1], "end": [62, 97], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal", "code": "def vanishingIdeal (V : Set (\u03c3 \u2192 k)) : Ideal (MvPolynomial \u03c3 k) where\n  carrier := {p | \u2200 x \u2208 V, eval x p = 0}\n  zero_mem' x _ := RingHom.map_zero _\n  add_mem' {p q} hp hq x hx := by simp only [hq x hx, hp x hx, add_zero, RingHom.map_add]\n  smul_mem' p q hq x hx := by\n    simp only [hq x hx, Algebra.id.smul_eq_mul, mul_zero, RingHom.map_mul]", "start": [65, 1], "end": [71, 75], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_vanishingIdeal_iff", "code": "@[simp]\ntheorem mem_vanishingIdeal_iff {V : Set (\u03c3 \u2192 k)} {p : MvPolynomial \u03c3 k} :\n    p \u2208 vanishingIdeal V \u2194 \u2200 x \u2208 V, eval x p = 0", "start": [74, 1], "end": [77, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal_anti_mono", "code": "theorem vanishingIdeal_anti_mono {A B : Set (\u03c3 \u2192 k)} (h : A \u2264 B) :\n    vanishingIdeal B \u2264 vanishingIdeal A", "start": [80, 1], "end": [81, 73], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal_empty", "code": "theorem vanishingIdeal_empty : vanishingIdeal (\u2205 : Set (\u03c3 \u2192 k)) = \u22a4", "start": [84, 1], "end": [85, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.le_vanishingIdeal_zeroLocus", "code": "theorem le_vanishingIdeal_zeroLocus (I : Ideal (MvPolynomial \u03c3 k)) :\n    I \u2264 vanishingIdeal (zeroLocus I)", "start": [88, 1], "end": [89, 65], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_vanishingIdeal_le", "code": "theorem zeroLocus_vanishingIdeal_le (V : Set (\u03c3 \u2192 k)) : V \u2264 zeroLocus (vanishingIdeal V)", "start": [92, 1], "end": [93, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_vanishingIdeal_galoisConnection", "code": "theorem zeroLocus_vanishingIdeal_galoisConnection :\n    @GaloisConnection (Ideal (MvPolynomial \u03c3 k)) (Set (\u03c3 \u2192 k))\u1d52\u1d48 _ _ zeroLocus vanishingIdeal", "start": [96, 1], "end": [99, 92], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.le_zeroLocus_iff_le_vanishingIdeal", "code": "theorem le_zeroLocus_iff_le_vanishingIdeal {V : Set (\u03c3 \u2192 k)} {I : Ideal (MvPolynomial \u03c3 k)} :\n    V \u2264 zeroLocus I \u2194 I \u2264 vanishingIdeal V", "start": [102, 1], "end": [104, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.zeroLocus_span", "code": "theorem zeroLocus_span (S : Set (MvPolynomial \u03c3 k)) :\n    zeroLocus (Ideal.span S) = { x | \u2200 p \u2208 S, eval x p = 0 }", "start": [106, 1], "end": [109, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_vanishingIdeal_singleton_iff", "code": "theorem mem_vanishingIdeal_singleton_iff (x : \u03c3 \u2192 k) (p : MvPolynomial \u03c3 k) :\n    p \u2208 (vanishingIdeal {x} : Ideal (MvPolynomial \u03c3 k)) \u2194 eval x p = 0", "start": [111, 1], "end": [113, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal_singleton_isMaximal", "code": "instance vanishingIdeal_singleton_isMaximal {x : \u03c3 \u2192 k} :\n    (vanishingIdeal {x} : Ideal (MvPolynomial \u03c3 k)).IsMaximal := by\n  have : MvPolynomial \u03c3 k \u29f8 vanishingIdeal {x} \u2243+* k :=\n    RingEquiv.ofBijective\n      (Ideal.Quotient.lift _ (eval x) fun p h => (mem_vanishingIdeal_singleton_iff x p).mp h)\n      (by\n        refine'\n          \u27e8(injective_iff_map_eq_zero _).mpr fun p hp => _, fun z =>\n            \u27e8(Ideal.Quotient.mk (vanishingIdeal {x} : Ideal (MvPolynomial \u03c3 k))) (C z), by simp\u27e9\u27e9\n        obtain \u27e8q, rfl\u27e9 := Quotient.mk_surjective p\n        rwa [Ideal.Quotient.lift_mk, \u2190 mem_vanishingIdeal_singleton_iff,\n          \u2190 Quotient.eq_zero_iff_mem] at hp)\n  rw [\u2190 bot_quotient_isMaximal_iff, RingEquiv.bot_maximal_iff this]\n  exact bot_isMaximal", "start": [116, 1], "end": [129, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.radical_le_vanishingIdeal_zeroLocus", "code": "theorem radical_le_vanishingIdeal_zeroLocus (I : Ideal (MvPolynomial \u03c3 k)) :\n    I.radical \u2264 vanishingIdeal (zeroLocus I)", "start": [132, 1], "end": [141, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.pointToPoint", "code": "def pointToPoint (x : \u03c3 \u2192 k) : PrimeSpectrum (MvPolynomial \u03c3 k) :=\n  \u27e8(vanishingIdeal {x} : Ideal (MvPolynomial \u03c3 k)), by infer_instance\u27e9", "start": [144, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal_pointToPoint", "code": "@[simp]\ntheorem vanishingIdeal_pointToPoint (V : Set (\u03c3 \u2192 k)) :\n    PrimeSpectrum.vanishingIdeal (pointToPoint '' V) = MvPolynomial.vanishingIdeal V", "start": [149, 1], "end": [160, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.pointToPoint_zeroLocus_le", "code": "theorem pointToPoint_zeroLocus_le (I : Ideal (MvPolynomial \u03c3 k)) :\n    pointToPoint '' MvPolynomial.zeroLocus I \u2264 PrimeSpectrum.zeroLocus \u2191I", "start": [163, 1], "end": [168, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isMaximal_iff_eq_vanishingIdeal_singleton", "code": "theorem isMaximal_iff_eq_vanishingIdeal_singleton (I : Ideal (MvPolynomial \u03c3 k)) :\n    I.IsMaximal \u2194 \u2203 x : \u03c3 \u2192 k, I = vanishingIdeal {x}", "start": [173, 1], "end": [195, 96], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vanishingIdeal_zeroLocus_eq_radical", "code": "@[simp]\ntheorem vanishingIdeal_zeroLocus_eq_radical (I : Ideal (MvPolynomial \u03c3 k)) :\n    vanishingIdeal (zeroLocus I) = I.radical", "start": [198, 1], "end": [212, 57], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.IsPrime.vanishingIdeal_zeroLocus", "code": "@[simp (high)]\ntheorem IsPrime.vanishingIdeal_zeroLocus (P : Ideal (MvPolynomial \u03c3 k)) [h : P.IsPrime] :\n    vanishingIdeal (zeroLocus P) = P", "start": [216, 1], "end": [219, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/Integral.lean", "imports": ["Mathlib/RingTheory/IntegrallyClosed.lean", "Mathlib/RingTheory/Valuation/Integers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Valuation.Integers.mem_of_integral", "code": "theorem mem_of_integral {x : R} (hx : IsIntegral O x) : x \u2208 v.integer", "start": [34, 1], "end": [45, 87], "kind": "commanddeclaration"}, {"full_name": "Valuation.Integers.integralClosure", "code": "protected theorem integralClosure : integralClosure O R = \u22a5", "start": [48, 1], "end": [51, 30], "kind": "commanddeclaration"}, {"full_name": "Valuation.Integers.integrallyClosed", "code": "theorem integrallyClosed : IsIntegrallyClosed O", "start": [66, 1], "end": [67, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/DualNumber.lean", "imports": ["Mathlib/Analysis/NormedSpace/TrivSqZeroExt.lean", "Mathlib/Algebra/DualNumber.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DualNumber.exp_eps", "code": "@[simp]\ntheorem exp_eps : exp \ud835\udd5c (eps : DualNumber R) = 1 + eps", "start": [33, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "DualNumber.exp_smul_eps", "code": "@[simp]\ntheorem exp_smul_eps (r : R) : exp \ud835\udd5c (r \u2022 eps : DualNumber R) = 1 + r \u2022 eps", "start": [38, 1], "end": [40, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Pi/Leibniz.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/ArctanDeriv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.tendsto_sum_pi_div_four", "code": "theorem tendsto_sum_pi_div_four :\n    Tendsto (fun k => \u2211 i in Finset.range k, (-(1 : \u211d)) ^ i / (2 * i + 1)) atTop (\ud835\udcdd (\u03c0 / 4))", "start": [21, 1], "end": [136, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/PrimeSpectrum/IsOpenComapC.lean", "imports": ["Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "Mathlib/RingTheory/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.Polynomial.imageOfDf", "code": "def imageOfDf (f : R[X]) : Set (PrimeSpectrum R) :=\n  { p : PrimeSpectrum R | \u2203 i : \u2115, coeff f i \u2209 p.asIdeal }", "start": [30, 1], "end": [35, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Polynomial.isOpen_imageOfDf", "code": "theorem isOpen_imageOfDf : IsOpen (imageOfDf f)", "start": [38, 1], "end": [40, 48], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Polynomial.comap_C_mem_imageOfDf", "code": "theorem comap_C_mem_imageOfDf {I : PrimeSpectrum R[X]}\n    (H : I \u2208 (zeroLocus {f} : Set (PrimeSpectrum R[X]))\u1d9c) :\n    PrimeSpectrum.comap (Polynomial.C : R \u2192+* R[X]) I \u2208 imageOfDf f", "start": [43, 1], "end": [49, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Polynomial.imageOfDf_eq_comap_C_compl_zeroLocus", "code": "theorem imageOfDf_eq_comap_C_compl_zeroLocus :\n    imageOfDf f = PrimeSpectrum.comap (C : R \u2192+* R[X]) '' (zeroLocus {f})\u1d9c", "start": [52, 1], "end": [66, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Polynomial.isOpenMap_comap_C", "code": "theorem isOpenMap_comap_C : IsOpenMap (PrimeSpectrum.comap (C : R \u2192+* R[X]))", "start": [69, 1], "end": [79, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/DifferentialObject.lean", "imports": ["Mathlib/Algebra/Homology/HomologicalComplex.lean", "Mathlib/CategoryTheory/DifferentialObject.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.DifferentialObject.objEqToHom", "code": "abbrev objEqToHom {i j : \u03b2} (h : i = j) :\n    X.obj i \u27f6 X.obj j :=\n  eqToHom (congr_arg X.obj h)", "start": [41, 1], "end": [45, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.objEqToHom_refl", "code": "@[simp]\ntheorem objEqToHom_refl (i : \u03b2) : X.objEqToHom (refl i) = \ud835\udfd9 _", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.objEqToHom_d", "code": "@[reassoc (attr := simp)]\ntheorem objEqToHom_d {x y : \u03b2} (h : x = y) :\n    X.objEqToHom h \u226b X.d y = X.d x \u226b X.objEqToHom (by cases h; rfl)", "start": [55, 1], "end": [57, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.d_squared_apply", "code": "@[reassoc (attr := simp)]\ntheorem d_squared_apply : X.d x \u226b X.d _ = 0", "start": [60, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.eqToHom_f'", "code": "@[reassoc (attr := simp)]\ntheorem eqToHom_f' {X Y : DifferentialObject \u2124 (GradedObjectWithShift b V)} (f : X \u27f6 Y) {x y : \u03b2}\n    (h : x = y) : X.objEqToHom h \u226b f.f y = f.f x \u226b Y.objEqToHom h", "start": [63, 1], "end": [65, 86], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.d_eqToHom", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem d_eqToHom (X : HomologicalComplex V (ComplexShape.up' b)) {x y z : \u03b2} (h : y = z) :\n    X.d x y \u226b eqToHom (congr_arg X.X h) = X.d x z", "start": [80, 1], "end": [82, 70], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.dgoToHomologicalComplex", "code": "@[simps]\ndef dgoToHomologicalComplex :\n    DifferentialObject \u2124 (GradedObjectWithShift b V) \u2964\n      HomologicalComplex V (ComplexShape.up' b) where\n  obj X :=\n    { X := fun i => X.obj i\n      d := fun i j =>\n        if h : i + b = j then X.d i \u226b X.objEqToHom (show i + (1 : \u2124) \u2022 b = j by simp [h]) else 0\n      shape := fun i j w => by dsimp at w; convert dif_neg w\n      d_comp_d' := fun i j k hij hjk => by\n        dsimp at hij hjk; substs hij hjk\n        simp }\n  map {X Y} f :=\n    { f := f.f\n      comm' := fun i j h => by\n        dsimp at h \u22a2\n        subst h\n        simp only [dite_true, Category.assoc, eqToHom_f']\n        have : f.f i \u226b Y.d i = X.d i \u226b f.f _ := (congr_fun f.comm i).symm\n        rw [reassoc_of% this] }", "start": [86, 1], "end": [108, 32], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.homologicalComplexToDGO", "code": "@[simps]\ndef homologicalComplexToDGO :\n    HomologicalComplex V (ComplexShape.up' b) \u2964\n      DifferentialObject \u2124 (GradedObjectWithShift b V) where\n  obj X :=\n    { obj := fun i => X.X i\n      d := fun i => X.d i _ }\n  map {X Y} f := { f := f.f }", "start": [111, 1], "end": [120, 30], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.dgoEquivHomologicalComplexUnitIso", "code": "@[simps!]\ndef dgoEquivHomologicalComplexUnitIso :\n    \ud835\udfed (DifferentialObject \u2124 (GradedObjectWithShift b V)) \u2245\n      dgoToHomologicalComplex b V \u22d9 homologicalComplexToDGO b V :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => \ud835\udfd9 (X.obj i) }\n      inv := { f := fun i => \ud835\udfd9 (X.obj i) } })", "start": [123, 1], "end": [131, 46], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.dgoEquivHomologicalComplexCounitIso", "code": "@[simps!]\ndef dgoEquivHomologicalComplexCounitIso :\n    homologicalComplexToDGO b V \u22d9 dgoToHomologicalComplex b V \u2245\n      \ud835\udfed (HomologicalComplex V (ComplexShape.up' b)) :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => \ud835\udfd9 (X.X i) }\n      inv := { f := fun i => \ud835\udfd9 (X.X i) } })", "start": [134, 1], "end": [142, 44], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.dgoEquivHomologicalComplex", "code": "@[simps]\ndef dgoEquivHomologicalComplex :\n    DifferentialObject \u2124 (GradedObjectWithShift b V) \u224c\n      HomologicalComplex V (ComplexShape.up' b) where\n  functor := dgoToHomologicalComplex b V\n  inverse := homologicalComplexToDGO b V\n  unitIso := dgoEquivHomologicalComplexUnitIso b V\n  counitIso := dgoEquivHomologicalComplexCounitIso b V", "start": [145, 1], "end": [155, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/ENatENNReal.lean", "imports": ["Mathlib/Data/Real/ENNReal.lean", "Mathlib/Data/ENat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ENat.toENNReal", "code": "@[coe] def toENNReal : \u2115\u221e \u2192 \u211d\u22650\u221e := WithTop.map Nat.cast", "start": [26, 1], "end": [27, 57], "kind": "commanddeclaration"}, {"full_name": "ENat.hasCoeENNReal", "code": "instance hasCoeENNReal : CoeTC \u2115\u221e \u211d\u22650\u221e := \u27e8toENNReal\u27e9", "start": [29, 1], "end": [29, 54], "kind": "commanddeclaration"}, {"full_name": "ENat.map_coe_nnreal", "code": "@[simp]\ntheorem map_coe_nnreal : WithTop.map ((\u2191) : \u2115 \u2192 \u211d\u22650) = ((\u2191) : \u2115\u221e \u2192 \u211d\u22650\u221e)", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNRealOrderEmbedding", "code": "@[simps! (config := { fullyApplied := false })]\ndef toENNRealOrderEmbedding : \u2115\u221e \u21aao \u211d\u22650\u221e :=\n  Nat.castOrderEmbedding.withTopMap", "start": [37, 1], "end": [40, 36], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNRealRingHom", "code": "@[simps! (config := { fullyApplied := false })]\ndef toENNRealRingHom : \u2115\u221e \u2192+* \u211d\u22650\u221e :=\n  .withTopMap (Nat.castRingHom \u211d\u22650) Nat.cast_injective", "start": [43, 1], "end": [46, 55], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_top", "code": "@[simp, norm_cast]\ntheorem toENNReal_top : ((\u22a4 : \u2115\u221e) : \u211d\u22650\u221e) = \u22a4", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_coe", "code": "@[simp, norm_cast]\ntheorem toENNReal_coe (n : \u2115) : ((n : \u2115\u221e) : \u211d\u22650\u221e) = n", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_ofNat", "code": "@[simp, norm_cast]\ntheorem toENNReal_ofNat (n : \u2115) [n.AtLeastTwo] : ((OfNat.ofNat n : \u2115\u221e) : \u211d\u22650\u221e) = OfNat.ofNat n", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_le", "code": "@[simp, norm_cast]\ntheorem toENNReal_le : (m : \u211d\u22650\u221e) \u2264 n \u2194 m \u2264 n", "start": [63, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_lt", "code": "@[simp, norm_cast]\ntheorem toENNReal_lt : (m : \u211d\u22650\u221e) < n \u2194 m < n", "start": [68, 1], "end": [70, 36], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_mono", "code": "@[mono]\ntheorem toENNReal_mono : Monotone ((\u2191) : \u2115\u221e \u2192 \u211d\u22650\u221e)", "start": [73, 1], "end": [75, 35], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_strictMono", "code": "@[mono]\ntheorem toENNReal_strictMono : StrictMono ((\u2191) : \u2115\u221e \u2192 \u211d\u22650\u221e)", "start": [78, 1], "end": [80, 37], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_zero", "code": "@[simp, norm_cast]\ntheorem toENNReal_zero : ((0 : \u2115\u221e) : \u211d\u22650\u221e) = 0", "start": [83, 1], "end": [85, 28], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_add", "code": "@[simp]\ntheorem toENNReal_add (m n : \u2115\u221e) : \u2191(m + n) = (m + n : \u211d\u22650\u221e)", "start": [88, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_one", "code": "@[simp]\ntheorem toENNReal_one : ((1 : \u2115\u221e) : \u211d\u22650\u221e) = 1", "start": [93, 1], "end": [95, 27], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_mul", "code": "@[simp]\ntheorem toENNReal_mul (m n : \u2115\u221e) : \u2191(m * n) = (m * n : \u211d\u22650\u221e)", "start": [101, 1], "end": [103, 31], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_min", "code": "@[simp]\ntheorem toENNReal_min (m n : \u2115\u221e) : \u2191(min m n) = (min m n : \u211d\u22650\u221e)", "start": [106, 1], "end": [108, 25], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_max", "code": "@[simp]\ntheorem toENNReal_max (m n : \u2115\u221e) : \u2191(max m n) = (max m n : \u211d\u22650\u221e)", "start": [111, 1], "end": [113, 25], "kind": "commanddeclaration"}, {"full_name": "ENat.toENNReal_sub", "code": "@[simp]\ntheorem toENNReal_sub (m n : \u2115\u221e) : \u2191(m - n) = (m - n : \u211d\u22650\u221e)", "start": [116, 1], "end": [118, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Small.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Logic/Small/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "small_of_fintype", "code": "instance (priority := 100) small_of_fintype (\u03b1 : Type v) [Fintype \u03b1] : Small.{w} \u03b1 := by\n  rw [small_congr (Fintype.equivFin \u03b1)]\n  infer_instance", "start": [21, 1], "end": [23, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/ToFinsupp.lean", "imports": ["Mathlib/Data/Finsupp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.toFinsupp", "code": "def toFinsupp : \u2115 \u2192\u2080 M where\n  toFun i := getD l i 0\n  support := (Finset.range l.length).filter fun i => getD l i 0 \u2260 0\n  mem_support_toFun n := by\n    simp only [Ne.def, Finset.mem_filter, Finset.mem_range, and_iff_right_iff_imp]\n    contrapose!\n    exact getD_eq_default _ _", "start": [39, 1], "end": [51, 30], "kind": "commanddeclaration"}, {"full_name": "List.coe_toFinsupp", "code": "@[norm_cast]\ntheorem coe_toFinsupp : (l.toFinsupp : \u2115 \u2192 M) = (l.getD \u00b7 0)", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_apply", "code": "@[simp, norm_cast]\ntheorem toFinsupp_apply (i : \u2115) : (l.toFinsupp : \u2115 \u2192 M) i = l.getD i 0", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_support", "code": "theorem toFinsupp_support :\n    l.toFinsupp.support = (Finset.range l.length).filter (getD l \u00b7 0 \u2260 0)", "start": [64, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_apply_lt", "code": "theorem toFinsupp_apply_lt (hn : n < l.length) : l.toFinsupp n = l.get \u27e8n, hn\u27e9", "start": [69, 1], "end": [70, 20], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_apply_fin", "code": "theorem toFinsupp_apply_fin (n : Fin l.length) : l.toFinsupp n = l.get n", "start": [72, 1], "end": [73, 20], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_apply_lt'", "code": "@[deprecated]\ntheorem toFinsupp_apply_lt' (hn : n < l.length) : l.toFinsupp n = l.nthLe n hn", "start": [76, 1], "end": [78, 20], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_apply_le", "code": "theorem toFinsupp_apply_le (hn : l.length \u2264 n) : l.toFinsupp n = 0", "start": [81, 1], "end": [82, 25], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_nil", "code": "@[simp]\ntheorem toFinsupp_nil [DecidablePred fun i => getD ([] : List M) i 0 \u2260 0] :\n    toFinsupp ([] : List M) = 0", "start": [85, 1], "end": [89, 7], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_singleton", "code": "theorem toFinsupp_singleton (x : M) [DecidablePred (getD [x] \u00b7 0 \u2260 0)] :\n    toFinsupp [x] = Finsupp.single 0 x", "start": [92, 1], "end": [94, 71], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_cons_apply_zero", "code": "@[simp]\ntheorem toFinsupp_cons_apply_zero (x : M) (xs : List M)\n    [DecidablePred (getD (x::xs) \u00b7 0 \u2260 0)] : (x::xs).toFinsupp 0 = x", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_cons_apply_succ", "code": "@[simp]\ntheorem toFinsupp_cons_apply_succ (x : M) (xs : List M) (n : \u2115)\n    [DecidablePred (getD (x::xs) \u00b7 0 \u2260 0)] [DecidablePred (getD xs \u00b7 0 \u2260 0)] :\n    (x::xs).toFinsupp n.succ = xs.toFinsupp n", "start": [103, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_append", "code": "theorem toFinsupp_append {R : Type*} [AddZeroClass R] (l\u2081 l\u2082 : List R)\n    [DecidablePred (getD (l\u2081 ++ l\u2082) \u00b7 0 \u2260 0)] [DecidablePred (getD l\u2081 \u00b7 0 \u2260 0)]\n    [DecidablePred (getD l\u2082 \u00b7 0 \u2260 0)] :\n    toFinsupp (l\u2081 ++ l\u2082) =\n      toFinsupp l\u2081 + (toFinsupp l\u2082).embDomain (addLeftEmbedding l\u2081.length)", "start": [111, 1], "end": [126, 50], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_cons_eq_single_add_embDomain", "code": "theorem toFinsupp_cons_eq_single_add_embDomain {R : Type*} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred (getD (x::xs) \u00b7 0 \u2260 0)] [DecidablePred (getD xs \u00b7 0 \u2260 0)] :\n    toFinsupp (x::xs) =\n      Finsupp.single 0 x + (toFinsupp xs).embDomain \u27e8Nat.succ, Nat.succ_injective\u27e9", "start": [128, 1], "end": [136, 25], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_concat_eq_toFinsupp_add_single", "code": "theorem toFinsupp_concat_eq_toFinsupp_add_single {R : Type*} [AddZeroClass R] (x : R) (xs : List R)\n    [DecidablePred fun i => getD (xs ++ [x]) i 0 \u2260 0] [DecidablePred fun i => getD xs i 0 \u2260 0] :\n    toFinsupp (xs ++ [x]) = toFinsupp xs + Finsupp.single xs.length x", "start": [139, 1], "end": [143, 38], "kind": "commanddeclaration"}, {"full_name": "List.toFinsupp_eq_sum_map_enum_single", "code": "theorem toFinsupp_eq_sum_map_enum_single {R : Type*} [AddMonoid R] (l : List R)\n    [DecidablePred (getD l \u00b7 0 \u2260 0)] :\n    toFinsupp l = (l.enum.map fun nr : \u2115 \u00d7 R => Finsupp.single nr.1 nr.2).sum", "start": [147, 1], "end": [156, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/UniformSpace.lean", "imports": ["Mathlib/Topology/Category/TopCat/Basic.lean", "Mathlib/CategoryTheory/Monad/Limits.lean", "Mathlib/CategoryTheory/Adjunction/Reflective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/UniformSpace/Completion.lean", "Mathlib/CategoryTheory/ConcreteCategory/UnbundledHom.lean"], "premises": [{"full_name": "UniformSpaceCat", "code": "def UniformSpaceCat : Type (u + 1) :=\n  Bundled UniformSpace", "start": [30, 1], "end": [32, 23], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.of", "code": "def of (\u03b1 : Type u) [UniformSpace \u03b1] : UniformSpaceCat :=\n  \u27e8\u03b1, \u2039_\u203a\u27e9", "start": [52, 1], "end": [54, 11], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.coe_of", "code": "@[simp]\ntheorem coe_of (X : Type u) [UniformSpace X] : (of X : Type u) = X", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.coe_comp", "code": "@[simp, nolint simpNF]\ntheorem coe_comp {X Y Z : UniformSpaceCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) : (f \u226b g : X \u2192 Z) = g \u2218 f", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.coe_id", "code": "@[simp, nolint simpNF]\ntheorem coe_id (X : UniformSpaceCat) : (\ud835\udfd9 X : X \u2192 X) = id", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.coe_mk", "code": "theorem coe_mk {X Y : UniformSpaceCat} (f : X \u2192 Y) (hf : UniformContinuous f) :\n    ((\u27e8f, hf\u27e9 : X \u27f6 Y) : X \u2192 Y) = f", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.hom_ext", "code": "theorem hom_ext {X Y : UniformSpaceCat} {f g : X \u27f6 Y} : (f : X \u2192 Y) = g \u2192 f = g", "start": [88, 1], "end": [89, 13], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.hasForgetToTop", "code": "instance hasForgetToTop : HasForget\u2082 UniformSpaceCat.{u} TopCat.{u} where\n  forget\u2082 :=\n    { obj := fun X => TopCat.of X\n      map := fun f =>\n        { toFun := f\n          continuous_toFun := f.property.continuous } }", "start": [92, 1], "end": [98, 56], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace", "code": "structure CpltSepUniformSpace where\n  \n  \u03b1 : Type u\n  [isUniformSpace : UniformSpace \u03b1]\n  [isCompleteSpace : CompleteSpace \u03b1]\n  [isSeparated : SeparatedSpace \u03b1]", "start": [103, 1], "end": [109, 35], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.toUniformSpace", "code": "def toUniformSpace (X : CpltSepUniformSpace) : UniformSpaceCat :=\n  UniformSpaceCat.of X", "start": [119, 1], "end": [121, 23], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.completeSpace", "code": "instance completeSpace (X : CpltSepUniformSpace) : CompleteSpace (toUniformSpace X).\u03b1 :=\n  CpltSepUniformSpace.isCompleteSpace X", "start": [124, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.separatedSpace", "code": "instance separatedSpace (X : CpltSepUniformSpace) : SeparatedSpace (toUniformSpace X).\u03b1 :=\n  CpltSepUniformSpace.isSeparated X", "start": [128, 1], "end": [129, 36], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.of", "code": "def of (X : Type u) [UniformSpace X] [CompleteSpace X] [SeparatedSpace X] : CpltSepUniformSpace :=\n  \u27e8X\u27e9", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.coe_of", "code": "@[simp]\ntheorem coe_of (X : Type u) [UniformSpace X] [CompleteSpace X] [SeparatedSpace X] :\n    (of X : Type u) = X", "start": [137, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.category", "code": "instance category : LargeCategory CpltSepUniformSpace :=\n  InducedCategory.category toUniformSpace", "start": [147, 1], "end": [149, 42], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.concreteCategory", "code": "instance concreteCategory : ConcreteCategory CpltSepUniformSpace :=\n  InducedCategory.concreteCategory toUniformSpace", "start": [152, 1], "end": [154, 50], "kind": "commanddeclaration"}, {"full_name": "CpltSepUniformSpace.hasForgetToUniformSpace", "code": "instance hasForgetToUniformSpace : HasForget\u2082 CpltSepUniformSpace UniformSpaceCat :=\n  InducedCategory.hasForget\u2082 toUniformSpace", "start": [157, 1], "end": [158, 44], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.completionFunctor", "code": "noncomputable def completionFunctor : UniformSpaceCat \u2964 CpltSepUniformSpace where\n  obj X := CpltSepUniformSpace.of (Completion X)\n  map f := \u27e8Completion.map f.1, Completion.uniformContinuous_map\u27e9\n  map_id _ := Subtype.eq Completion.map_id\n  map_comp f g := Subtype.eq (Completion.map_comp g.property f.property).symm", "start": [169, 1], "end": [174, 78], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.completionHom", "code": "def completionHom (X : UniformSpaceCat) :\n    X \u27f6 (forget\u2082 CpltSepUniformSpace UniformSpaceCat).obj (completionFunctor.obj X) where\n  val := ((\u2191) : X \u2192 Completion X)\n  property := Completion.uniformContinuous_coe X", "start": [177, 1], "end": [181, 49], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.completionHom_val", "code": "@[simp]\ntheorem completionHom_val (X : UniformSpaceCat) (x) : (completionHom X) x = (x : Completion X)", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.extensionHom", "code": "noncomputable def extensionHom {X : UniformSpaceCat} {Y : CpltSepUniformSpace}\n    (f : X \u27f6 (forget\u2082 CpltSepUniformSpace UniformSpaceCat).obj Y) :\n    completionFunctor.obj X \u27f6 Y where\n  val := Completion.extension f\n  property := Completion.uniformContinuous_extension", "start": [189, 1], "end": [194, 53], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.extensionHom_val", "code": "@[simp]\ntheorem extensionHom_val {X : UniformSpaceCat} {Y : CpltSepUniformSpace}\n    (f : X \u27f6 (forget\u2082 _ _).obj Y) (x) : (extensionHom f) x = Completion.extension f x", "start": [201, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.extension_comp_coe", "code": "@[simp]\ntheorem extension_comp_coe {X : UniformSpaceCat} {Y : CpltSepUniformSpace}\n    (f : toUniformSpace (CpltSepUniformSpace.of (Completion X)) \u27f6 toUniformSpace Y) :\n    extensionHom (completionHom X \u226b f) = f", "start": [207, 1], "end": [213, 63], "kind": "commanddeclaration"}, {"full_name": "UniformSpaceCat.adj", "code": "noncomputable def adj : completionFunctor \u22a3 forget\u2082 CpltSepUniformSpace UniformSpaceCat :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => completionHom X \u226b f\n          invFun := fun f => extensionHom f\n          left_inv := fun f => by dsimp; erw [extension_comp_coe]\n          right_inv := fun f => by\n            apply Subtype.eq; funext x; cases f\n            exact @Completion.extension_coe _ _ _ _ _ (CpltSepUniformSpace.separatedSpace _)\n              \u2039_\u203a _ }\n      homEquiv_naturality_left_symm := fun {X' X Y} f g => by\n        apply hom_ext; funext x; dsimp\n        erw [coe_comp]\n        have := (Completion.extension_map (\u03b3 := Y) (f := g) g.2 f.2)\n        simp only [forget_map_eq_coe] at this \u22a2\n        erw [this]\n        rfl }", "start": [216, 1], "end": [234, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ByteArray.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/UInt.lean", "Mathlib/Data/Char.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Up", "code": "def Up (ub a i : \u2115) := i < a \u2227 i < ub", "start": [11, 1], "end": [12, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Up.next", "code": "lemma Up.next {ub i} (h : i < ub) : Up ub (i+1) i := \u27e8Nat.lt_succ_self _, h\u27e9", "start": [14, 1], "end": [14, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.Up.WF", "code": "lemma Up.WF (ub) : WellFounded (Up ub) :=\n  Subrelation.wf (h\u2082 := (measure (ub - \u00b7)).wf) fun \u27e8ia, iu\u27e9 \u21a6 Nat.sub_lt_sub_left iu ia", "start": [16, 1], "end": [17, 88], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.upRel", "code": "def upRel (ub : \u2115) : WellFoundedRelation Nat := \u27e8Up ub, Up.WF ub\u27e9", "start": [19, 1], "end": [20, 66], "kind": "commanddeclaration"}, {"full_name": "ByteSliceT", "code": "structure ByteSliceT := (arr : ByteArray) (off : Nat)", "start": [24, 1], "end": [25, 54], "kind": "commanddeclaration"}, {"full_name": "ByteSliceT.size", "code": "@[inline] def size (self : ByteSliceT) : Nat := self.arr.size - self.off", "start": [29, 1], "end": [30, 73], "kind": "commanddeclaration"}, {"full_name": "ByteSliceT.getOp", "code": "@[inline] def getOp (self : ByteSliceT) (idx : Nat) : UInt8 := self.arr.get! (self.off + idx)", "start": [32, 1], "end": [33, 94], "kind": "commanddeclaration"}, {"full_name": "ByteArray.toSliceT", "code": "def ByteArray.toSliceT (arr : ByteArray) : ByteSliceT := \u27e8arr, 0\u27e9", "start": [37, 1], "end": [38, 66], "kind": "commanddeclaration"}, {"full_name": "ByteSlice", "code": "structure ByteSlice := (arr : ByteArray) (off len : Nat)", "start": [40, 1], "end": [41, 57], "kind": "commanddeclaration"}, {"full_name": "ByteSlice.toArray", "code": "def toArray : ByteSlice \u2192 ByteArray\n  | \u27e8arr, off, len\u27e9 => arr.extract off len", "start": [45, 1], "end": [47, 43], "kind": "commanddeclaration"}, {"full_name": "ByteSlice.getOp", "code": "@[inline] def getOp (self : ByteSlice) (idx : Nat) : UInt8 := self.arr.get! (self.off + idx)", "start": [49, 1], "end": [50, 93], "kind": "commanddeclaration"}, {"full_name": "ByteSlice.forIn.loop", "code": "def forIn.loop [Monad m] (f : UInt8 \u2192 \u03b2 \u2192 m (ForInStep \u03b2))\n    (arr : ByteArray) (off _end : Nat) (i : Nat) (b : \u03b2) : m \u03b2 :=\n  if h : i < _end then do\n    match \u2190 f (arr.get! i) b with\n    | ForInStep.done b => pure b\n    | ForInStep.yield b => have := Nat.Up.next h; loop f arr off _end (i+1) b\n  else pure b\ntermination_by _ => _end - i", "start": [53, 1], "end": [61, 29], "kind": "commanddeclaration"}, {"full_name": "ByteSliceT.toSlice", "code": "def ByteSliceT.toSlice : ByteSliceT \u2192 ByteSlice\n  | \u27e8arr, off\u27e9 => \u27e8arr, off, arr.size - off\u27e9", "start": [68, 1], "end": [70, 45], "kind": "commanddeclaration"}, {"full_name": "ByteArray.toSlice", "code": "def ByteArray.toSlice (arr : ByteArray) : ByteSlice := \u27e8arr, 0, arr.size\u27e9", "start": [72, 1], "end": [73, 74], "kind": "commanddeclaration"}, {"full_name": "String.toAsciiByteArray", "code": "def String.toAsciiByteArray (s : String) : ByteArray :=\n  let rec loop (p : Pos) (out : ByteArray) : ByteArray :=\n    if h : s.atEnd p then out else\n    let c := s.get p\n    have : utf8ByteSize s - (next s p).byteIdx < utf8ByteSize s - p.byteIdx :=\n      Nat.sub_lt_sub_left (Nat.lt_of_not_le <| mt decide_eq_true h)\n        (Nat.lt_add_of_pos_right (String.csize_pos _))\n    loop (s.next p) (out.push c.toUInt8)\n  loop 0 ByteArray.empty\ntermination_by _ => utf8ByteSize s - p.byteIdx", "start": [75, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "ByteSlice.toString", "code": "def ByteSlice.toString (bs : ByteSlice) : String := Id.run do\n  let mut s := \"\"\n  for c in bs do s := s.push c.toChar\n  s", "start": [88, 1], "end": [93, 4], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Perfection.lean", "imports": ["Mathlib/FieldTheory/Perfect.lean", "Mathlib/RingTheory/Localization/FractionRing.lean", "Mathlib/Algebra/CharP/Subring.lean", "Mathlib/RingTheory/Valuation/Integers.lean", "Mathlib/Algebra/CharP/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "Mathlib/Algebra/Ring/Pi.lean", "Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Algebra/CharP/Pi.lean"], "premises": [{"full_name": "Monoid.perfection", "code": "def Monoid.perfection (M : Type u\u2081) [CommMonoid M] (p : \u2115) : Submonoid (\u2115 \u2192 M) where\n  carrier := { f | \u2200 n, f (n + 1) ^ p = f n }\n  one_mem' _ := one_pow _\n  mul_mem' hf hg n := (mul_pow _ _ _).trans <| congr_arg\u2082 _ (hf n) (hg n)", "start": [35, 1], "end": [41, 74], "kind": "commanddeclaration"}, {"full_name": "Ring.perfectionSubsemiring", "code": "def Ring.perfectionSubsemiring (R : Type u\u2081) [CommSemiring R] (p : \u2115) [hp : Fact p.Prime]\n    [CharP R p] : Subsemiring (\u2115 \u2192 R) :=\n  { Monoid.perfection R p with\n    zero_mem' := fun _ => zero_pow <| hp.1.pos\n    add_mem' := fun hf hg n => (frobenius_add R p _ _).trans <| congr_arg\u2082 _ (hf n) (hg n) }", "start": [44, 1], "end": [51, 93], "kind": "commanddeclaration"}, {"full_name": "Ring.perfectionSubring", "code": "def Ring.perfectionSubring (R : Type u\u2081) [CommRing R] (p : \u2115) [hp : Fact p.Prime] [CharP R p] :\n    Subring (\u2115 \u2192 R) :=\n  (Ring.perfectionSubsemiring R p).toSubring fun n => by\n    simp_rw [\u2190 frobenius_def, Pi.neg_apply, Pi.one_apply, RingHom.map_neg, RingHom.map_one]", "start": [54, 1], "end": [60, 92], "kind": "commanddeclaration"}, {"full_name": "Ring.Perfection", "code": "def Ring.Perfection (R : Type u\u2081) [CommSemiring R] (p : \u2115) : Type u\u2081 :=\n  { f // \u2200 n : \u2115, (f : \u2115 \u2192 R) (n + 1) ^ p = f n }", "start": [63, 1], "end": [67, 50], "kind": "commanddeclaration"}, {"full_name": "Perfection.commSemiring", "code": "instance commSemiring : CommSemiring (Ring.Perfection R p) :=\n  (Ring.perfectionSubsemiring R p).toCommSemiring", "start": [74, 1], "end": [75, 50], "kind": "commanddeclaration"}, {"full_name": "Perfection.charP", "code": "instance charP : CharP (Ring.Perfection R p) p :=\n  CharP.subsemiring (\u2115 \u2192 R) p (Ring.perfectionSubsemiring R p)", "start": [78, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "Perfection.ring", "code": "instance ring (R : Type u\u2081) [CommRing R] [CharP R p] : Ring (Ring.Perfection R p) :=\n  (Ring.perfectionSubring R p).toRing", "start": [82, 1], "end": [83, 38], "kind": "commanddeclaration"}, {"full_name": "Perfection.commRing", "code": "instance commRing (R : Type u\u2081) [CommRing R] [CharP R p] : CommRing (Ring.Perfection R p) :=\n  (Ring.perfectionSubring R p).toCommRing", "start": [86, 1], "end": [87, 42], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff", "code": "def coeff (n : \u2115) : Ring.Perfection R p \u2192+* R where\n  toFun f := f.1 n\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [92, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Perfection.ext", "code": "@[ext]\ntheorem ext {f g : Ring.Perfection R p} (h : \u2200 n, coeff R p n f = coeff R p n g) : f = g", "start": [103, 1], "end": [105, 25], "kind": "commanddeclaration"}, {"full_name": "Perfection.pthRoot", "code": "def pthRoot : Ring.Perfection R p \u2192+* Ring.Perfection R p where\n  toFun f := \u27e8fun n => coeff R p (n + 1) f, fun _ => f.2 _\u27e9\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl", "start": [110, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_mk", "code": "@[simp]\ntheorem coeff_mk (f : \u2115 \u2192 R) (hf) (n : \u2115) : coeff R p n \u27e8f, hf\u27e9 = f n", "start": [121, 1], "end": [122, 77], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_pthRoot", "code": "theorem coeff_pthRoot (f : Ring.Perfection R p) (n : \u2115) :\n    coeff R p n (pthRoot R p f) = coeff R p (n + 1) f", "start": [125, 1], "end": [126, 61], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_pow_p", "code": "theorem coeff_pow_p (f : Ring.Perfection R p) (n : \u2115) : coeff R p (n + 1) (f ^ p) = coeff R p n f", "start": [129, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_pow_p'", "code": "theorem coeff_pow_p' (f : Ring.Perfection R p) (n : \u2115) : coeff R p (n + 1) f ^ p = coeff R p n f", "start": [133, 1], "end": [134, 8], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_frobenius", "code": "theorem coeff_frobenius (f : Ring.Perfection R p) (n : \u2115) :\n    coeff R p (n + 1) (frobenius _ p f) = coeff R p n f", "start": [137, 1], "end": [138, 84], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_iterate_frobenius", "code": "theorem coeff_iterate_frobenius (f : Ring.Perfection R p) (n m : \u2115) :\n    coeff R p (n + m) ((frobenius _ p)^[m] f) = coeff R p n f", "start": [142, 1], "end": [144, 89], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_iterate_frobenius'", "code": "theorem coeff_iterate_frobenius' (f : Ring.Perfection R p) (n m : \u2115) (hmn : m \u2264 n) :\n    coeff R p n ((frobenius _ p)^[m] f) = coeff R p (n - m) f", "start": [147, 1], "end": [149, 98], "kind": "commanddeclaration"}, {"full_name": "Perfection.pthRoot_frobenius", "code": "theorem pthRoot_frobenius : (pthRoot R p).comp (frobenius _ p) = RingHom.id _", "start": [152, 1], "end": [154, 94], "kind": "commanddeclaration"}, {"full_name": "Perfection.frobenius_pthRoot", "code": "theorem frobenius_pthRoot : (frobenius _ p).comp (pthRoot R p) = RingHom.id _", "start": [157, 1], "end": [161, 77], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_add_ne_zero", "code": "theorem coeff_add_ne_zero {f : Ring.Perfection R p} {n : \u2115} (hfn : coeff R p n f \u2260 0) (k : \u2115) :\n    coeff R p (n + k) f \u2260 0", "start": [164, 1], "end": [166, 100], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_ne_zero_of_le", "code": "theorem coeff_ne_zero_of_le {f : Ring.Perfection R p} {m n : \u2115} (hfm : coeff R p m f \u2260 0)\n    (hmn : m \u2264 n) : coeff R p n f \u2260 0", "start": [169, 1], "end": [172, 36], "kind": "commanddeclaration"}, {"full_name": "Perfection.perfectRing", "code": "instance perfectRing : PerfectRing (Ring.Perfection R p) p where\n  bijective_frobenius := Function.bijective_iff_has_inverse.mpr\n    \u27e8pthRoot R p,\n     FunLike.congr_fun <| @frobenius_pthRoot R _ p _ _,\n     FunLike.congr_fun <| @pthRoot_frobenius R _ p _ _\u27e9", "start": [177, 1], "end": [181, 56], "kind": "commanddeclaration"}, {"full_name": "Perfection.lift", "code": "@[simps]\nnoncomputable def lift (R : Type u\u2081) [CommSemiring R] [CharP R p] [PerfectRing R p]\n    (S : Type u\u2082) [CommSemiring S] [CharP S p] : (R \u2192+* S) \u2243 (R \u2192+* Ring.Perfection S p) where\n  toFun f :=\n    { toFun := fun r => \u27e8fun n => f (((frobeniusEquiv R p).symm : R \u2192+* R)^[n] r),\n        fun n => by erw [\u2190 f.map_pow, Function.iterate_succ_apply', frobeniusEquiv_symm_pow_p]\u27e9\n      map_one' := ext fun n => (congr_arg f <| RingHom.iterate_map_one _ _).trans f.map_one\n      map_mul' := fun x y =>\n        ext fun n => (congr_arg f <| iterate_map_mul _ _ _ _).trans <| f.map_mul _ _\n      map_zero' := ext fun n => (congr_arg f <| RingHom.iterate_map_zero _ _).trans f.map_zero\n      map_add' := fun x y =>\n        ext fun n => (congr_arg f <| iterate_map_add _ _ _ _).trans <| f.map_add _ _ }\n  invFun := RingHom.comp <| coeff S p 0\n  left_inv f := RingHom.ext fun r => rfl\n  right_inv f := RingHom.ext fun r => ext fun n =>\n    show coeff S p 0 (f (((frobeniusEquiv R p).symm)^[n] r)) = coeff S p n (f r) by\n      rw [\u2190 coeff_iterate_frobenius _ 0 n, zero_add, \u2190 RingHom.map_iterate_frobenius,\n        Function.RightInverse.iterate (frobenius_apply_frobeniusEquiv_symm R p) n]", "start": [184, 1], "end": [203, 83], "kind": "commanddeclaration"}, {"full_name": "Perfection.hom_ext", "code": "theorem hom_ext {R : Type u\u2081} [CommSemiring R] [CharP R p] [PerfectRing R p] {S : Type u\u2082}\n    [CommSemiring S] [CharP S p] {f g : R \u2192+* Ring.Perfection S p}\n    (hfg : \u2200 x, coeff S p 0 (f x) = coeff S p 0 (g x)) : f = g", "start": [205, 1], "end": [208, 49], "kind": "commanddeclaration"}, {"full_name": "Perfection.map", "code": "@[simps]\ndef map (\u03c6 : R \u2192+* S) : Ring.Perfection R p \u2192+* Ring.Perfection S p where\n  toFun f := \u27e8fun n => \u03c6 (coeff R p n f), fun n => by rw [\u2190 \u03c6.map_pow, coeff_pow_p']\u27e9\n  map_one' := Subtype.eq <| funext fun _ => \u03c6.map_one\n  map_mul' f g := Subtype.eq <| funext fun n => \u03c6.map_mul _ _\n  map_zero' := Subtype.eq <| funext fun _ => \u03c6.map_zero\n  map_add' f g := Subtype.eq <| funext fun n => \u03c6.map_add _ _", "start": [213, 1], "end": [220, 62], "kind": "commanddeclaration"}, {"full_name": "Perfection.coeff_map", "code": "theorem coeff_map (\u03c6 : R \u2192+* S) (f : Ring.Perfection R p) (n : \u2115) :\n    coeff S p n (map p \u03c6 f) = \u03c6 (coeff R p n f)", "start": [223, 1], "end": [224, 55], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap", "code": "structure PerfectionMap (p : \u2115) [Fact p.Prime] {R : Type u\u2081} [CommSemiring R] [CharP R p]\n    {P : Type u\u2082} [CommSemiring P] [CharP P p] [PerfectRing P p] (\u03c0 : P \u2192+* R) : Prop where\n  injective : \u2200 \u2983x y : P\u2984,\n    (\u2200 n, \u03c0 (((frobeniusEquiv P p).symm)^[n] x) = \u03c0 (((frobeniusEquiv P p).symm)^[n] y)) \u2192 x = y\n  surjective : \u2200 f : \u2115 \u2192 R, (\u2200 n, f (n + 1) ^ p = f n) \u2192 \u2203 x : P, \u2200 n,\n    \u03c0 (((frobeniusEquiv P p).symm)^[n] x) = f n", "start": [229, 1], "end": [237, 48], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.mk'", "code": "@[simps]\ntheorem mk' {f : P \u2192+* R} (g : P \u2243+* Ring.Perfection R p) (hfg : Perfection.lift p P R f = g) :\n    PerfectionMap p f", "start": [248, 1], "end": [260, 28], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.of", "code": "theorem of : PerfectionMap p (Perfection.coeff R p 0)", "start": [265, 1], "end": [267, 71], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.id", "code": "theorem id [PerfectRing R p] : PerfectionMap p (RingHom.id R)", "start": [270, 1], "end": [277, 84], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.equiv", "code": "noncomputable def equiv {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) : P \u2243+* Ring.Perfection R p :=\n  RingEquiv.ofBijective (Perfection.lift p P R \u03c0)\n    \u27e8fun _ _ hxy => m.injective fun n => (congr_arg (Perfection.coeff R p n) hxy : _), fun f =>\n      let \u27e8x, hx\u27e9 := m.surjective f.1 f.2\n      \u27e8x, Perfection.ext <| hx\u27e9\u27e9", "start": [282, 1], "end": [287, 33], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.equiv_apply", "code": "theorem equiv_apply {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) (x : P) :\n    m.equiv x = Perfection.lift p P R \u03c0 x", "start": [290, 1], "end": [291, 49], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.comp_equiv", "code": "theorem comp_equiv {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) (x : P) :\n    Perfection.coeff R p 0 (m.equiv x) = \u03c0 x", "start": [294, 1], "end": [295, 52], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.comp_equiv'", "code": "theorem comp_equiv' {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) :\n    (Perfection.coeff R p 0).comp \u2191m.equiv = \u03c0", "start": [298, 1], "end": [300, 27], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.comp_symm_equiv", "code": "theorem comp_symm_equiv {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) (f : Ring.Perfection R p) :\n    \u03c0 (m.equiv.symm f) = Perfection.coeff R p 0 f", "start": [303, 1], "end": [305, 75], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.comp_symm_equiv'", "code": "theorem comp_symm_equiv' {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) :\n    \u03c0.comp \u2191m.equiv.symm = Perfection.coeff R p 0", "start": [308, 1], "end": [310, 32], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.lift", "code": "@[simps]\nnoncomputable def lift [PerfectRing R p] (S : Type u\u2082) [CommSemiring S] [CharP S p] (P : Type u\u2083)\n    [CommSemiring P] [CharP P p] [PerfectRing P p] (\u03c0 : P \u2192+* S) (m : PerfectionMap p \u03c0) :\n    (R \u2192+* S) \u2243 (R \u2192+* P) where\n  toFun f := RingHom.comp \u2191m.equiv.symm <| Perfection.lift p R S f\n  invFun f := \u03c0.comp f\n  left_inv f := by\n    simp_rw [\u2190 RingHom.comp_assoc, comp_symm_equiv']\n    exact (Perfection.lift p R S).symm_apply_apply f\n  right_inv f := by\n    exact RingHom.ext fun x => m.equiv.injective <| (m.equiv.apply_symm_apply _).trans\n      <| show Perfection.lift p R S (\u03c0.comp f) x = RingHom.comp (\u2191m.equiv) f x from\n        RingHom.ext_iff.1 (by rw [Equiv.apply_eq_iff_eq_symm_apply]; rfl) _", "start": [315, 1], "end": [330, 76], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.hom_ext", "code": "theorem hom_ext [PerfectRing R p] {S : Type u\u2082} [CommSemiring S] [CharP S p] {P : Type u\u2083}\n    [CommSemiring P] [CharP P p] [PerfectRing P p] (\u03c0 : P \u2192+* S) (m : PerfectionMap p \u03c0)\n    {f g : R \u2192+* P} (hfg : \u2200 x, \u03c0 (f x) = \u03c0 (g x)) : f = g", "start": [335, 1], "end": [338, 55], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.map", "code": "@[nolint unusedArguments]\nnoncomputable def map {\u03c0 : P \u2192+* R} (_ : PerfectionMap p \u03c0) {\u03c3 : Q \u2192+* S} (n : PerfectionMap p \u03c3)\n    (\u03c6 : R \u2192+* S) : P \u2192+* Q :=\n  lift p P S Q \u03c3 n <| \u03c6.comp \u03c0", "start": [347, 1], "end": [351, 31], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.comp_map", "code": "theorem comp_map {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) {\u03c3 : Q \u2192+* S} (n : PerfectionMap p \u03c3)\n    (\u03c6 : R \u2192+* S) : \u03c3.comp (map p m n \u03c6) = \u03c6.comp \u03c0", "start": [354, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.map_map", "code": "theorem map_map {\u03c0 : P \u2192+* R} (m : PerfectionMap p \u03c0) {\u03c3 : Q \u2192+* S} (n : PerfectionMap p \u03c3)\n    (\u03c6 : R \u2192+* S) (x : P) : \u03c3 (map p m n \u03c6 x) = \u03c6 (\u03c0 x)", "start": [359, 1], "end": [361, 41], "kind": "commanddeclaration"}, {"full_name": "PerfectionMap.map_eq_map", "code": "theorem map_eq_map (\u03c6 : R \u2192+* S) : map p (of p R) (of p S) \u03c6 = Perfection.map p \u03c6", "start": [364, 1], "end": [365, 68], "kind": "commanddeclaration"}, {"full_name": "ModP", "code": "@[nolint unusedArguments] def ModP (K : Type u\u2081) [Field K] (v : Valuation K \u211d\u22650) (O : Type u\u2082) [CommRing O] [Algebra O K]\n    (_ : v.Integers O) (p : \u2115) :=\n  O \u29f8 (Ideal.span {(p : O)} : Ideal O)", "start": [379, 1], "end": [383, 39], "kind": "commanddeclaration"}, {"full_name": "ModP.commRing", "code": "instance commRing : CommRing (ModP K v O hv p) :=\n  Ideal.Quotient.commRing (Ideal.span {(p : O)} : Ideal O)", "start": [390, 1], "end": [391, 59], "kind": "commanddeclaration"}, {"full_name": "ModP.charP", "code": "instance charP : CharP (ModP K v O hv p) p :=\n  CharP.quotient O p <| mt hv.one_of_isUnit <| (map_natCast (algebraMap O K) p).symm \u25b8 hvp.1", "start": [393, 1], "end": [394, 93], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal", "code": "noncomputable def preVal (x : ModP K v O hv p) : \u211d\u22650 :=\n  if x = 0 then 0 else v (algebraMap O K x.out')", "start": [403, 1], "end": [406, 49], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal_mk", "code": "theorem preVal_mk {x : O} (hx : (Ideal.Quotient.mk _ x : ModP K v O hv p) \u2260 0) :\n    preVal K v O hv p (Ideal.Quotient.mk _ x) = v (algebraMap O K x)", "start": [411, 1], "end": [418, 100], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal_zero", "code": "theorem preVal_zero : preVal K v O hv p 0 = 0", "start": [421, 1], "end": [422, 13], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal_mul", "code": "theorem preVal_mul {x y : ModP K v O hv p} (hxy0 : x * y \u2260 0) :\n    preVal K v O hv p (x * y) = preVal K v O hv p x * preVal K v O hv p y", "start": [425, 1], "end": [432, 80], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal_add", "code": "theorem preVal_add (x y : ModP K v O hv p) :\n    preVal K v O hv p (x + y) \u2264 max (preVal K v O hv p x) (preVal K v O hv p y)", "start": [435, 1], "end": [446, 90], "kind": "commanddeclaration"}, {"full_name": "ModP.v_p_lt_preVal", "code": "theorem v_p_lt_preVal {x : ModP K v O hv p} : v p < preVal K v O hv p x \u2194 x \u2260 0", "start": [449, 1], "end": [454, 74], "kind": "commanddeclaration"}, {"full_name": "ModP.preVal_eq_zero", "code": "theorem preVal_eq_zero {x : ModP K v O hv p} : preVal K v O hv p x = 0 \u2194 x = 0", "start": [457, 1], "end": [462, 37], "kind": "commanddeclaration"}, {"full_name": "ModP.v_p_lt_val", "code": "theorem v_p_lt_val {x : O} :\n    v p < v (algebraMap O K x) \u2194 (Ideal.Quotient.mk _ x : ModP K v O hv p) \u2260 0", "start": [467, 1], "end": [470, 62], "kind": "commanddeclaration"}, {"full_name": "ModP.mul_ne_zero_of_pow_p_ne_zero", "code": "theorem mul_ne_zero_of_pow_p_ne_zero {x y : ModP K v O hv p} (hx : x ^ p \u2260 0) (hy : y ^ p \u2260 0) :\n    x * y \u2260 0", "start": [477, 1], "end": [493, 97], "kind": "commanddeclaration"}, {"full_name": "PreTilt", "code": "def PreTilt :=\n  Ring.Perfection (ModP K v O hv p) p", "start": [500, 1], "end": [503, 38], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux", "code": "noncomputable def valAux (f : PreTilt K v O hv p) : \u211d\u22650 :=\n  if h : \u2203 n, coeff _ _ n f \u2260 0 then\n    ModP.preVal K v O hv p (coeff _ _ (Nat.find h) f) ^ p ^ Nat.find h\n  else 0", "start": [520, 1], "end": [526, 9], "kind": "commanddeclaration"}, {"full_name": "PreTilt.coeff_nat_find_add_ne_zero", "code": "theorem coeff_nat_find_add_ne_zero {f : PreTilt K v O hv p} {h : \u2203 n, coeff _ _ n f \u2260 0} (k : \u2115) :\n    coeff _ _ (Nat.find h + k) f \u2260 0", "start": [531, 1], "end": [533, 40], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux_eq", "code": "theorem valAux_eq {f : PreTilt K v O hv p} {n : \u2115} (hfn : coeff _ _ n f \u2260 0) :\n    valAux K v O hv p f = ModP.preVal K v O hv p (coeff _ _ n f) ^ p ^ n", "start": [536, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux_zero", "code": "theorem valAux_zero : valAux K v O hv p 0 = 0", "start": [554, 1], "end": [555, 32], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux_one", "code": "theorem valAux_one : valAux K v O hv p 1 = 1", "start": [558, 1], "end": [563, 22], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux_mul", "code": "theorem valAux_mul (f g : PreTilt K v O hv p) :\n    valAux K v O hv p (f * g) = valAux K v O hv p f * valAux K v O hv p g", "start": [566, 1], "end": [582, 67], "kind": "commanddeclaration"}, {"full_name": "PreTilt.valAux_add", "code": "theorem valAux_add (f g : PreTilt K v O hv p) :\n    valAux K v O hv p (f + g) \u2264 max (valAux K v O hv p f) (valAux K v O hv p g)", "start": [585, 1], "end": [604, 58], "kind": "commanddeclaration"}, {"full_name": "PreTilt.val", "code": "noncomputable def val : Valuation (PreTilt K v O hv p) \u211d\u22650 where\n  toFun := valAux K v O hv p\n  map_one' := valAux_one\n  map_mul' := valAux_mul\n  map_zero' := valAux_zero\n  map_add_le_max' := valAux_add", "start": [609, 1], "end": [617, 32], "kind": "commanddeclaration"}, {"full_name": "PreTilt.map_eq_zero", "code": "theorem map_eq_zero {f : PreTilt K v O hv p} : val K v O hv p f = 0 \u2194 f = 0", "start": [622, 1], "end": [627, 93], "kind": "commanddeclaration"}, {"full_name": "Tilt", "code": "def Tilt :=\n  FractionRing (PreTilt K v O hv p)", "start": [642, 1], "end": [647, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Inversion/ImageHyperplane.lean", "imports": ["Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "Mathlib/Geometry/Euclidean/PerpBisector.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.inversion_mem_perpBisector_inversion_iff", "code": "theorem inversion_mem_perpBisector_inversion_iff (hR : R \u2260 0) (hx : x \u2260 c) (hy : y \u2260 c) :\n    inversion c R x \u2208 perpBisector c (inversion c R y) \u2194 dist x y = dist y c", "start": [35, 1], "end": [42, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_mem_perpBisector_inversion_iff'", "code": "theorem inversion_mem_perpBisector_inversion_iff' (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R x \u2208 perpBisector c (inversion c R y) \u2194 dist x y = dist y c \u2227 x \u2260 c", "start": [44, 1], "end": [50, 65], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.preimage_inversion_perpBisector_inversion", "code": "theorem preimage_inversion_perpBisector_inversion (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R \u207b\u00b9' perpBisector c (inversion c R y) = sphere y (dist y c) \\ {c}", "start": [52, 1], "end": [54, 66], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.preimage_inversion_perpBisector", "code": "theorem preimage_inversion_perpBisector (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R \u207b\u00b9' perpBisector c y = sphere (inversion c R y) (R ^ 2 / dist y c) \\ {c}", "start": [56, 1], "end": [59, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.image_inversion_perpBisector", "code": "theorem image_inversion_perpBisector (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R '' perpBisector c y = sphere (inversion c R y) (R ^ 2 / dist y c) \\ {c}", "start": [61, 1], "end": [64, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.preimage_inversion_sphere_dist_center", "code": "theorem preimage_inversion_sphere_dist_center (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R \u207b\u00b9' sphere y (dist y c) =\n      insert c (perpBisector c (inversion c R y) : Set P)", "start": [66, 1], "end": [71, 92], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.image_inversion_sphere_dist_center", "code": "theorem image_inversion_sphere_dist_center (hR : R \u2260 0) (hy : y \u2260 c) :\n    inversion c R '' sphere y (dist y c) = insert c (perpBisector c (inversion c R y) : Set P)", "start": [73, 1], "end": [76, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mapsTo_inversion_affineSubspace_of_mem", "code": "theorem mapsTo_inversion_affineSubspace_of_mem {p : AffineSubspace \u211d P} (hp : c \u2208 p) :\n    MapsTo (inversion c R) p p", "start": [78, 1], "end": [80, 69], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.image_inversion_affineSubspace_of_mem", "code": "theorem image_inversion_affineSubspace_of_mem {p : AffineSubspace \u211d P} (hR : R \u2260 0) (hp : c \u2208 p) :\n    inversion c R '' p = p", "start": [82, 1], "end": [86, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/BaseChange.lean", "imports": ["Mathlib/Algebra/Algebra/RestrictScalars.lean", "Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "Mathlib/Algebra/Lie/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieAlgebra.ExtendScalars.bracket'", "code": "private def bracket' : A \u2297[R] L \u2192\u2097[A] A \u2297[R] L \u2192\u2097[A] A \u2297[R] L :=\n  TensorProduct.curry <|\n    TensorProduct.AlgebraTensorModule.map\n        (LinearMap.mul' A A) (LieModule.toModuleHom R L L : L \u2297[R] L \u2192\u2097[R] L) \u2218\u2097\n      (TensorProduct.AlgebraTensorModule.tensorTensorTensorComm R A A L A L).toLinearMap", "start": [41, 1], "end": [46, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.bracket'_tmul", "code": "@[simp]\nprivate theorem bracket'_tmul (s t : A) (x y : L) :\n    bracket' R A L (s \u2297\u209c[R] x) (t \u2297\u209c[R] y) = (s * t) \u2297\u209c \u2045x, y\u2046", "start": [48, 1], "end": [50, 70], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.bracket_def", "code": "private theorem bracket_def (x y : A \u2297[R] L) : \u2045x, y\u2046 = bracket' R A L x y", "start": [54, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.bracket_tmul", "code": "@[simp]\ntheorem bracket_tmul (s t : A) (x y : L) : \u2045s \u2297\u209c[R] x, t \u2297\u209c[R] y\u2046 = (s * t) \u2297\u209c \u2045x, y\u2046", "start": [57, 1], "end": [58, 93], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.bracket_lie_self", "code": "private theorem bracket_lie_self (x : A \u2297[R] L) : \u2045x, x\u2046 = 0", "start": [61, 1], "end": [81, 95], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.bracket_leibniz_lie", "code": "private theorem bracket_leibniz_lie (x y z : A \u2297[R] L) :\n    \u2045x, \u2045y, z\u2046\u2046 = \u2045\u2045x, y\u2046, z\u2046 + \u2045y, \u2045x, z\u2046\u2046", "start": [83, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.ExtendScalars.lieAlgebra", "code": "instance lieAlgebra : LieAlgebra A (A \u2297[R] L) where lie_smul _a _x _y := map_smul _ _ _", "start": [113, 1], "end": [113, 88], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.RestrictScalars.lieAlgebra", "code": "instance lieAlgebra [CommRing R] [Algebra R A] : LieAlgebra R (RestrictScalars R A L) where\n  lie_smul t x y := (lie_smul (algebraMap R A t) (RestrictScalars.addEquiv R A L x)\n    (RestrictScalars.addEquiv R A L y) : _)", "start": [129, 1], "end": [131, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/VonNeumannAlgebra/Basic.lean", "imports": ["Mathlib/Analysis/Complex/Basic.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Star/Subalgebra.lean", "Mathlib/Analysis/NormedSpace/Dual.lean"], "premises": [{"full_name": "WStarAlgebra", "code": "class WStarAlgebra (M : Type u) [NormedRing M] [StarRing M] [CstarRing M] [Module \u2102 M]\n    [NormedAlgebra \u2102 M] [StarModule \u2102 M] : Prop where\n  \n  exists_predual :\n    \u2203 (X : Type u) (_ : NormedAddCommGroup X) (_ : NormedSpace \u2102 X) (_ : CompleteSpace X),\n      Nonempty (NormedSpace.Dual \u2102 X \u2243\u2097\u1d62\u22c6[\u2102] M)", "start": [33, 1], "end": [52, 48], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra", "code": "structure VonNeumannAlgebra (H : Type u) [NormedAddCommGroup H] [InnerProductSpace \u2102 H]\n    [CompleteSpace H] extends StarSubalgebra \u2102 (H \u2192L[\u2102] H) where\n  \n  centralizer_centralizer' : Set.centralizer (Set.centralizer carrier) = carrier", "start": [56, 1], "end": [74, 81], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.instSetLike", "code": "instance instSetLike : SetLike (VonNeumannAlgebra H) (H \u2192L[\u2102] H) where\n  coe S := S.carrier\n  coe_injective' S T h := by obtain \u27e8\u27e8\u27e8\u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9, _\u27e9, _\u27e9, _\u27e9 := S; cases T; congr", "start": [87, 1], "end": [89, 89], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.instStarMemClass", "code": "noncomputable instance instStarMemClass : StarMemClass (VonNeumannAlgebra H) (H \u2192L[\u2102] H) where\n  star_mem {s} := s.star_mem'", "start": [92, 1], "end": [93, 30], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.instSubringClass", "code": "instance instSubringClass : SubringClass (VonNeumannAlgebra H) (H \u2192L[\u2102] H) where\n  add_mem {s} := s.add_mem'\n  mul_mem {s} := s.mul_mem'\n  one_mem {s} := s.one_mem'\n  zero_mem {s} := s.zero_mem'\n  neg_mem {s} a ha := show -a \u2208 s.toStarSubalgebra from neg_mem ha", "start": [95, 1], "end": [100, 67], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.mem_carrier", "code": "@[simp]\ntheorem mem_carrier {S : VonNeumannAlgebra H} {x : H \u2192L[\u2102] H} :\n    x \u2208 S.toStarSubalgebra \u2194 x \u2208 (S : Set (H \u2192L[\u2102] H))", "start": [102, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.coe_toStarSubalgebra", "code": "@[simp]\ntheorem coe_toStarSubalgebra (S : VonNeumannAlgebra H) :\n    (S.toStarSubalgebra : Set (H \u2192L[\u2102] H)) = S", "start": [109, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.coe_mk", "code": "@[simp]\ntheorem coe_mk (S : StarSubalgebra \u2102 (H \u2192L[\u2102] H)) (h) :\n    ((\u27e8S, h\u27e9 : VonNeumannAlgebra H) : Set (H \u2192L[\u2102] H)) = S", "start": [114, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.ext", "code": "@[ext]\ntheorem ext {S T : VonNeumannAlgebra H} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [119, 1], "end": [121, 16], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.centralizer_centralizer", "code": "@[simp]\ntheorem centralizer_centralizer (S : VonNeumannAlgebra H) :\n    Set.centralizer (Set.centralizer (S : Set (H \u2192L[\u2102] H))) = S", "start": [124, 1], "end": [127, 29], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.commutant", "code": "def commutant (S : VonNeumannAlgebra H) : VonNeumannAlgebra H where\n  toStarSubalgebra := StarSubalgebra.centralizer \u2102 (S : Set (H \u2192L[\u2102] H))\n  centralizer_centralizer' := by simp", "start": [130, 1], "end": [133, 38], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.coe_commutant", "code": "@[simp]\ntheorem coe_commutant (S : VonNeumannAlgebra H) :\n    \u2191S.commutant = Set.centralizer (S : Set (H \u2192L[\u2102] H))", "start": [136, 1], "end": [139, 19], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.mem_commutant_iff", "code": "@[simp]\ntheorem mem_commutant_iff {S : VonNeumannAlgebra H} {z : H \u2192L[\u2102] H} :\n    z \u2208 S.commutant \u2194 \u2200 g \u2208 S, g * z = z * g", "start": [143, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "VonNeumannAlgebra.commutant_commutant", "code": "@[simp]\ntheorem commutant_commutant (S : VonNeumannAlgebra H) : S.commutant.commutant = S", "start": [150, 1], "end": [152, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sums/Associator.lean", "imports": ["Mathlib/CategoryTheory/Sums/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.sum.associator", "code": "def associator : Sum (Sum C D) E \u2964 Sum C (Sum D E)\n    where\n  obj X :=\n    match X with\n    | inl (inl X) => inl X\n    | inl (inr X) => inr (inl X)\n    | inr X => inr (inr X)\n  map {X Y} f :=\n    match X, Y, f with\n    | inl (inl _), inl (inl _), f => f\n    | inl (inr _), inl (inr _), f => f\n    | inr _, inr _, f => f\n  map_id := by rintro ((_|_)|_) <;> rfl\n  map_comp := by\n    rintro ((_|_)|_) ((_|_)|_) ((_|_)|_) f g <;> first | cases f | cases g | aesop_cat", "start": [27, 1], "end": [43, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_obj_inl_inl", "code": "@[simp]\ntheorem associator_obj_inl_inl (X) : (associator C D E).obj (inl (inl X)) = inl X", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_obj_inl_inr", "code": "@[simp]\ntheorem associator_obj_inl_inr (X) : (associator C D E).obj (inl (inr X)) = inr (inl X)", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_obj_inr", "code": "@[simp]\ntheorem associator_obj_inr (X) : (associator C D E).obj (inr X) = inr (inr X)", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_map_inl_inl", "code": "@[simp]\ntheorem associator_map_inl_inl {X Y : C} (f : inl (inl X) \u27f6 inl (inl Y)) :\n    (associator C D E).map f = f", "start": [61, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_map_inl_inr", "code": "@[simp]\ntheorem associator_map_inl_inr {X Y : D} (f : inl (inr X) \u27f6 inl (inr Y)) :\n    (associator C D E).map f = f", "start": [67, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associator_map_inr", "code": "@[simp]\ntheorem associator_map_inr {X Y : E} (f : inr X \u27f6 inr Y) : (associator C D E).map f = f", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator", "code": "def inverseAssociator : Sum C (Sum D E) \u2964 Sum (Sum C D) E\n    where\n  obj X :=\n    match X with\n    | inl X => inl (inl X)\n    | inr (inl X) => inl (inr X)\n    | inr (inr X) => inr X\n  map {X Y} f :=\n    match X, Y, f with\n    | inl _, inl _, f => f\n    | inr (inl _), inr (inl _), f => f\n    | inr (inr _), inr (inr _), f => f\n  map_id := by rintro (_|(_|_)) <;> rfl\n  map_comp := by\n    rintro (_|(_|_)) (_|(_|_)) (_|(_|_)) f g <;> first | cases f | cases g | aesop_cat", "start": [78, 1], "end": [94, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_obj_inl", "code": "@[simp]\ntheorem inverseAssociator_obj_inl (X) : (inverseAssociator C D E).obj (inl X) = inl (inl X)", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_obj_inr_inl", "code": "@[simp]\ntheorem inverseAssociator_obj_inr_inl (X) :\n    (inverseAssociator C D E).obj (inr (inl X)) = inl (inr X)", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_obj_inr_inr", "code": "@[simp]\ntheorem inverseAssociator_obj_inr_inr (X) : (inverseAssociator C D E).obj (inr (inr X)) = inr X", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_map_inl", "code": "@[simp]\ntheorem inverseAssociator_map_inl {X Y : C} (f : inl X \u27f6 inl Y) :\n    (inverseAssociator C D E).map f = f", "start": [113, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_map_inr_inl", "code": "@[simp]\ntheorem inverseAssociator_map_inr_inl {X Y : D} (f : inr (inl X) \u27f6 inr (inl Y)) :\n    (inverseAssociator C D E).map f = f", "start": [119, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociator_map_inr_inr", "code": "@[simp]\ntheorem inverseAssociator_map_inr_inr {X Y : E} (f : inr (inr X) \u27f6 inr (inr Y)) :\n    (inverseAssociator C D E).map f = f", "start": [125, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associativity", "code": "def associativity : Sum (Sum C D) E \u224c Sum C (Sum D E) :=\n  Equivalence.mk (associator C D E) (inverseAssociator C D E)\n    (NatIso.ofComponents (fun X => eqToIso\n      (by rcases X with ((_|_)|_) <;> rfl)) (by rintro ((_|_)|_) ((_|_)|_) f <;> first | cases f | aesop_cat))\n    (NatIso.ofComponents (fun X => eqToIso\n      (by rcases X with (_|(_|_)) <;> rfl)) (by rintro (_|(_|_)) (_|(_|_)) f <;> first | cases f | aesop_cat))", "start": [131, 1], "end": [140, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.associatorIsEquivalence", "code": "instance associatorIsEquivalence : IsEquivalence (associator C D E) :=\n  (by infer_instance : IsEquivalence (associativity C D E).functor)", "start": [143, 1], "end": [144, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum.inverseAssociatorIsEquivalence", "code": "instance inverseAssociatorIsEquivalence : IsEquivalence (inverseAssociator C D E) :=\n  (by infer_instance : IsEquivalence (associativity C D E).inverse)", "start": [147, 1], "end": [148, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MLList/BestFirst.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/std/Std/Data/RBMap/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "bestFirstSearchAux", "code": "def bestFirstSearchAux\n    (f : Nat \u2192 \u03b1 \u2192 MLList m \u03b1) (maxQueued : Option Nat := none) :\n    RBMap \u03b1 (Nat \u00d7 MLList m \u03b1) compare \u2192 m (RBMap \u03b1 (Nat \u00d7 MLList m \u03b1) compare \u00d7 List \u03b1) :=\nfun s => do\n  match s.min with\n  | none => failure\n  | some (a, (n, L)) =>\n    match \u2190 uncons L with\n    | none => pure (s.erase a, [])\n    | some (b, L') => do\n      let s' := s.insert a (n, L') |>.insert b (n + 1, f (n+1) b)\n      let s' := match maxQueued with\n      | some q => if s'.size > q then\n          match s'.max with | some x => s'.erase x.1 | none => unreachable!\n        else\n          s'\n      | none => s'\n      pure (s', [b])", "start": [37, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "bestFirstSearch", "code": "def bestFirstSearch (f : \u03b1 \u2192 MLList m \u03b1) (a : \u03b1)\n    (maxDepth : Option Nat := none) (maxQueued : Option Nat := none) (removeDuplicates := true) :\n    MLList m \u03b1 :=\nlet f' : Nat \u2192 \u03b1 \u2192 MLList m \u03b1 := match maxDepth with\n| none => fun _ a => f a\n| some d => fun n a => if d < n then nil else f a\nif removeDuplicates then\n  let f'' : Nat \u2192 \u03b1 \u2192 MLList (StateT.{u} (RBSet \u03b1 compare) m) \u03b1 := fun n a =>\n    (f' n a).liftM >>= fun b => do\n      let s \u2190 get\n      if s.contains b then failure\n      set <| s.insert b\n      pure b\n  cons a (fixl (bestFirstSearchAux f'' maxQueued) (RBMap.single a (0, f'' 0 a)))\n    |>.runState' (RBSet.empty.insert a)\nelse\n  cons a (fixl (bestFirstSearchAux f' maxQueued) (RBMap.single a (0, f' 0 a)))", "start": [64, 1], "end": [96, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Quasiconvex.lean", "imports": ["Mathlib/Analysis/Convex/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuasiconvexOn", "code": "def QuasiconvexOn : Prop :=\n  \u2200 r, Convex \ud835\udd5c ({ x \u2208 s | f x \u2264 r })", "start": [48, 1], "end": [51, 38], "kind": "commanddeclaration"}, {"full_name": "QuasiconcaveOn", "code": "def QuasiconcaveOn : Prop :=\n  \u2200 r, Convex \ud835\udd5c ({ x \u2208 s | r \u2264 f x })", "start": [54, 1], "end": [57, 38], "kind": "commanddeclaration"}, {"full_name": "QuasilinearOn", "code": "def QuasilinearOn : Prop :=\n  QuasiconvexOn \ud835\udd5c s f \u2227 QuasiconcaveOn \ud835\udd5c s f", "start": [60, 1], "end": [64, 45], "kind": "commanddeclaration"}, {"full_name": "QuasiconvexOn.dual", "code": "theorem QuasiconvexOn.dual : QuasiconvexOn \ud835\udd5c s f \u2192 QuasiconcaveOn \ud835\udd5c s (toDual \u2218 f)", "start": [69, 1], "end": [70, 5], "kind": "commanddeclaration"}, {"full_name": "QuasiconcaveOn.dual", "code": "theorem QuasiconcaveOn.dual : QuasiconcaveOn \ud835\udd5c s f \u2192 QuasiconvexOn \ud835\udd5c s (toDual \u2218 f)", "start": [73, 1], "end": [74, 5], "kind": "commanddeclaration"}, {"full_name": "QuasilinearOn.dual", "code": "theorem QuasilinearOn.dual : QuasilinearOn \ud835\udd5c s f \u2192 QuasilinearOn \ud835\udd5c s (toDual \u2218 f)", "start": [77, 1], "end": [78, 11], "kind": "commanddeclaration"}, {"full_name": "Convex.quasiconvexOn_of_convex_le", "code": "theorem Convex.quasiconvexOn_of_convex_le (hs : Convex \ud835\udd5c s) (h : \u2200 r, Convex \ud835\udd5c { x | f x \u2264 r }) :\n    QuasiconvexOn \ud835\udd5c s f", "start": [81, 1], "end": [82, 51], "kind": "commanddeclaration"}, {"full_name": "Convex.quasiconcaveOn_of_convex_ge", "code": "theorem Convex.quasiconcaveOn_of_convex_ge (hs : Convex \ud835\udd5c s) (h : \u2200 r, Convex \ud835\udd5c { x | r \u2264 f x }) :\n    QuasiconcaveOn \ud835\udd5c s f", "start": [85, 1], "end": [87, 62], "kind": "commanddeclaration"}, {"full_name": "QuasiconvexOn.convex", "code": "theorem QuasiconvexOn.convex [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)] (hf : QuasiconvexOn \ud835\udd5c s f) : Convex \ud835\udd5c s", "start": [90, 1], "end": [93, 41], "kind": "commanddeclaration"}, {"full_name": "QuasiconcaveOn.convex", "code": "theorem QuasiconcaveOn.convex [IsDirected \u03b2 (\u00b7 \u2265 \u00b7)] (hf : QuasiconcaveOn \ud835\udd5c s f) : Convex \ud835\udd5c s", "start": [96, 1], "end": [97, 17], "kind": "commanddeclaration"}, {"full_name": "QuasiconvexOn.sup", "code": "theorem QuasiconvexOn.sup [SemilatticeSup \u03b2] (hf : QuasiconvexOn \ud835\udd5c s f)\n    (hg : QuasiconvexOn \ud835\udd5c s g) : QuasiconvexOn \ud835\udd5c s (f \u2294 g)", "start": [106, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "QuasiconcaveOn.inf", "code": "theorem QuasiconcaveOn.inf [SemilatticeInf \u03b2] (hf : QuasiconcaveOn \ud835\udd5c s f)\n    (hg : QuasiconcaveOn \ud835\udd5c s g) : QuasiconcaveOn \ud835\udd5c s (f \u2293 g)", "start": [113, 1], "end": [115, 17], "kind": "commanddeclaration"}, {"full_name": "quasiconvexOn_iff_le_max", "code": "theorem quasiconvexOn_iff_le_max : QuasiconvexOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984,\n    y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2264 max (f x) (f y)", "start": [124, 1], "end": [130, 86], "kind": "commanddeclaration"}, {"full_name": "quasiconcaveOn_iff_min_le", "code": "theorem quasiconcaveOn_iff_min_le : QuasiconcaveOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984,\n    y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 min (f x) (f y) \u2264 f (a \u2022 x + b \u2022 y)", "start": [133, 1], "end": [135, 48], "kind": "commanddeclaration"}, {"full_name": "quasilinearOn_iff_mem_uIcc", "code": "theorem quasilinearOn_iff_mem_uIcc : QuasilinearOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984,\n    y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2208 uIcc (f x) (f y)", "start": [138, 1], "end": [143, 59], "kind": "commanddeclaration"}, {"full_name": "QuasiconvexOn.convex_lt", "code": "theorem QuasiconvexOn.convex_lt (hf : QuasiconvexOn \ud835\udd5c s f) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x < r })", "start": [146, 1], "end": [150, 48], "kind": "commanddeclaration"}, {"full_name": "QuasiconcaveOn.convex_gt", "code": "theorem QuasiconcaveOn.convex_gt (hf : QuasiconcaveOn \ud835\udd5c s f) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r < f x })", "start": [153, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.quasiconvexOn", "code": "theorem ConvexOn.quasiconvexOn (hf : ConvexOn \ud835\udd5c s f) : QuasiconvexOn \ud835\udd5c s f", "start": [165, 1], "end": [166, 15], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.quasiconcaveOn", "code": "theorem ConcaveOn.quasiconcaveOn (hf : ConcaveOn \ud835\udd5c s f) : QuasiconcaveOn \ud835\udd5c s f", "start": [169, 1], "end": [170, 15], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.quasiconvexOn", "code": "theorem MonotoneOn.quasiconvexOn (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) : QuasiconvexOn \ud835\udd5c s f", "start": [182, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.quasiconcaveOn", "code": "theorem MonotoneOn.quasiconcaveOn (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) : QuasiconcaveOn \ud835\udd5c s f", "start": [186, 1], "end": [187, 18], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.quasilinearOn", "code": "theorem MonotoneOn.quasilinearOn (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) : QuasilinearOn \ud835\udd5c s f", "start": [190, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.quasiconvexOn", "code": "theorem AntitoneOn.quasiconvexOn (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) : QuasiconvexOn \ud835\udd5c s f", "start": [194, 1], "end": [195, 18], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.quasiconcaveOn", "code": "theorem AntitoneOn.quasiconcaveOn (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) : QuasiconcaveOn \ud835\udd5c s f", "start": [198, 1], "end": [199, 18], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.quasilinearOn", "code": "theorem AntitoneOn.quasilinearOn (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) : QuasilinearOn \ud835\udd5c s f", "start": [202, 1], "end": [203, 46], "kind": "commanddeclaration"}, {"full_name": "Monotone.quasiconvexOn", "code": "theorem Monotone.quasiconvexOn (hf : Monotone f) : QuasiconvexOn \ud835\udd5c univ f", "start": [206, 1], "end": [207, 46], "kind": "commanddeclaration"}, {"full_name": "Monotone.quasiconcaveOn", "code": "theorem Monotone.quasiconcaveOn (hf : Monotone f) : QuasiconcaveOn \ud835\udd5c univ f", "start": [210, 1], "end": [211, 47], "kind": "commanddeclaration"}, {"full_name": "Monotone.quasilinearOn", "code": "theorem Monotone.quasilinearOn (hf : Monotone f) : QuasilinearOn \ud835\udd5c univ f", "start": [214, 1], "end": [215, 40], "kind": "commanddeclaration"}, {"full_name": "Antitone.quasiconvexOn", "code": "theorem Antitone.quasiconvexOn (hf : Antitone f) : QuasiconvexOn \ud835\udd5c univ f", "start": [218, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "Antitone.quasiconcaveOn", "code": "theorem Antitone.quasiconcaveOn (hf : Antitone f) : QuasiconcaveOn \ud835\udd5c univ f", "start": [222, 1], "end": [223, 47], "kind": "commanddeclaration"}, {"full_name": "Antitone.quasilinearOn", "code": "theorem Antitone.quasilinearOn (hf : Antitone f) : QuasilinearOn \ud835\udd5c univ f", "start": [226, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "QuasilinearOn.monotoneOn_or_antitoneOn", "code": "theorem QuasilinearOn.monotoneOn_or_antitoneOn [LinearOrder \u03b2] (hf : QuasilinearOn \ud835\udd5c s f) :\n    MonotoneOn f s \u2228 AntitoneOn f s", "start": [238, 1], "end": [242, 94], "kind": "commanddeclaration"}, {"full_name": "quasilinearOn_iff_monotoneOn_or_antitoneOn", "code": "theorem quasilinearOn_iff_monotoneOn_or_antitoneOn [LinearOrderedAddCommMonoid \u03b2]\n    (hs : Convex \ud835\udd5c s) : QuasilinearOn \ud835\udd5c s f \u2194 MonotoneOn f s \u2228 AntitoneOn f s", "start": [245, 1], "end": [248, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/RelCat.lean", "imports": ["Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.RelCat", "code": "def RelCat :=\n  Type u", "start": [22, 1], "end": [25, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RelCat.inhabited", "code": "instance RelCat.inhabited : Inhabited RelCat := by unfold RelCat; infer_instance", "start": [28, 1], "end": [28, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rel", "code": "instance rel : LargeCategory RelCat where\n  Hom X Y := X \u2192 Y \u2192 Prop\n  id X x y := x = y\n  comp f g x z := \u2203 y, f x y \u2227 g y z", "start": [31, 1], "end": [35, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/EpsilonNFA.lean", "imports": ["Mathlib/Computability/NFA.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "\u03b5NFA", "code": "structure \u03b5NFA (\u03b1 : Type u) (\u03c3 : Type v) where\n  step : \u03c3 \u2192 Option \u03b1 \u2192 Set \u03c3\n  start : Set \u03c3\n  accept : Set \u03c3", "start": [31, 1], "end": [40, 17], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.\u03b5Closure", "code": "inductive \u03b5Closure (S : Set \u03c3) : Set \u03c3\n  | base : \u2200 s \u2208 S, \u03b5Closure S s\n  | step : \u2200 (s), \u2200 t \u2208 M.step s none, \u03b5Closure S s \u2192 \u03b5Closure S t", "start": [47, 1], "end": [51, 67], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.subset_\u03b5Closure", "code": "@[simp]\ntheorem subset_\u03b5Closure (S : Set \u03c3) : S \u2286 M.\u03b5Closure S", "start": [54, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.\u03b5Closure_empty", "code": "@[simp]\ntheorem \u03b5Closure_empty : M.\u03b5Closure \u2205 = \u2205", "start": [59, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.\u03b5Closure_univ", "code": "@[simp]\ntheorem \u03b5Closure_univ : M.\u03b5Closure univ = univ", "start": [64, 1], "end": [66, 48], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.stepSet", "code": "def stepSet (S : Set \u03c3) (a : \u03b1) : Set \u03c3 :=\n  \u22c3 s \u2208 S, M.\u03b5Closure (M.step s a)", "start": [69, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.mem_stepSet_iff", "code": "@[simp]\ntheorem mem_stepSet_iff : s \u2208 M.stepSet S a \u2194 \u2203 t \u2208 S, s \u2208 M.\u03b5Closure (M.step t a)", "start": [76, 1], "end": [78, 46], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.stepSet_empty", "code": "@[simp]\ntheorem stepSet_empty (a : \u03b1) : M.stepSet \u2205 a = \u2205", "start": [81, 1], "end": [83, 69], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.evalFrom", "code": "def evalFrom (start : Set \u03c3) : List \u03b1 \u2192 Set \u03c3 :=\n  List.foldl M.stepSet (M.\u03b5Closure start)", "start": [88, 1], "end": [91, 42], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.evalFrom_nil", "code": "@[simp]\ntheorem evalFrom_nil (S : Set \u03c3) : M.evalFrom S [] = M.\u03b5Closure S", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.evalFrom_singleton", "code": "@[simp]\ntheorem evalFrom_singleton (S : Set \u03c3) (a : \u03b1) : M.evalFrom S [a] = M.stepSet (M.\u03b5Closure S) a", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.evalFrom_append_singleton", "code": "@[simp]\ntheorem evalFrom_append_singleton (S : Set \u03c3) (x : List \u03b1) (a : \u03b1) :\n    M.evalFrom S (x ++ [a]) = M.stepSet (M.evalFrom S x) a", "start": [104, 1], "end": [107, 68], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.evalFrom_empty", "code": "@[simp]\ntheorem evalFrom_empty (x : List \u03b1) : M.evalFrom \u2205 x = \u2205", "start": [110, 1], "end": [114, 54], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.eval", "code": "def eval :=\n  M.evalFrom M.start", "start": [117, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.eval_nil", "code": "@[simp]\ntheorem eval_nil : M.eval [] = M.\u03b5Closure M.start", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.eval_singleton", "code": "@[simp]\ntheorem eval_singleton (a : \u03b1) : M.eval [a] = M.stepSet (M.\u03b5Closure M.start) a", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.eval_append_singleton", "code": "@[simp]\ntheorem eval_append_singleton (x : List \u03b1) (a : \u03b1) : M.eval (x ++ [a]) = M.stepSet (M.eval x) a", "start": [133, 1], "end": [135, 36], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.accepts", "code": "def accepts : Language \u03b1 :=\n  { x | \u2203 S \u2208 M.accept, S \u2208 M.eval x }", "start": [138, 1], "end": [140, 39], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.toNFA", "code": "def toNFA : NFA \u03b1 \u03c3 where\n  step S a := M.\u03b5Closure (M.step S a)\n  start := M.\u03b5Closure M.start\n  accept := M.accept", "start": [146, 1], "end": [150, 21], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.toNFA_evalFrom_match", "code": "@[simp]\ntheorem toNFA_evalFrom_match (start : Set \u03c3) :\n    M.toNFA.evalFrom (M.\u03b5Closure start) = M.evalFrom start", "start": [153, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.toNFA_correct", "code": "@[simp]\ntheorem toNFA_correct : M.toNFA.accepts = M.accepts", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.pumping_lemma", "code": "theorem pumping_lemma [Fintype \u03c3] {x : List \u03b1} (hx : x \u2208 M.accepts)\n    (hlen : Fintype.card (Set \u03c3) \u2264 List.length x) :\n    \u2203 a b c, x = a ++ b ++ c \u2227\n      a.length + b.length \u2264 Fintype.card (Set \u03c3) \u2227 b \u2260 [] \u2227 {a} * {b}\u2217 * {c} \u2264 M.accepts", "start": [164, 1], "end": [168, 32], "kind": "commanddeclaration"}, {"full_name": "NFA.to\u03b5NFA", "code": "def to\u03b5NFA (M : NFA \u03b1 \u03c3) : \u03b5NFA \u03b1 \u03c3 where\n  step s a := a.casesOn' \u2205 fun a \u21a6 M.step s a\n  start := M.start\n  accept := M.accept", "start": [175, 1], "end": [180, 21], "kind": "commanddeclaration"}, {"full_name": "NFA.to\u03b5NFA_\u03b5Closure", "code": "@[simp]\ntheorem to\u03b5NFA_\u03b5Closure (M : NFA \u03b1 \u03c3) (S : Set \u03c3) : M.to\u03b5NFA.\u03b5Closure S = S", "start": [183, 1], "end": [189, 12], "kind": "commanddeclaration"}, {"full_name": "NFA.to\u03b5NFA_evalFrom_match", "code": "@[simp]\ntheorem to\u03b5NFA_evalFrom_match (M : NFA \u03b1 \u03c3) (start : Set \u03c3) :\n    M.to\u03b5NFA.evalFrom start = M.evalFrom start", "start": [192, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "NFA.to\u03b5NFA_correct", "code": "@[simp]\ntheorem to\u03b5NFA_correct (M : NFA \u03b1 \u03c3) : M.to\u03b5NFA.accepts = M.accepts", "start": [206, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.step_zero", "code": "@[simp]\ntheorem step_zero (s a) : (0 : \u03b5NFA \u03b1 \u03c3).step s a = \u2205", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.step_one", "code": "@[simp]\ntheorem step_one (s a) : (1 : \u03b5NFA \u03b1 \u03c3).step s a = \u2205", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.start_zero", "code": "@[simp]\ntheorem start_zero : (0 : \u03b5NFA \u03b1 \u03c3).start = \u2205", "start": [240, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.start_one", "code": "@[simp]\ntheorem start_one : (1 : \u03b5NFA \u03b1 \u03c3).start = univ", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.accept_zero", "code": "@[simp]\ntheorem accept_zero : (0 : \u03b5NFA \u03b1 \u03c3).accept = \u2205", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "\u03b5NFA.accept_one", "code": "@[simp]\ntheorem accept_one : (1 : \u03b5NFA \u03b1 \u03c3).accept = univ", "start": [255, 1], "end": [257, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Stonean/Adjunctions.lean", "imports": ["Mathlib/Topology/Category/Stonean/Basic.lean", "Mathlib/Topology/StoneCech.lean", "Mathlib/Topology/Category/TopCat/Adjunctions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Stonean.stoneCechObj", "code": "def stoneCechObj (X : Type u) : Stonean :=\n  letI : TopologicalSpace X := \u22a5\n  haveI : DiscreteTopology X := \u27e8rfl\u27e9\n  haveI : ExtremallyDisconnected (StoneCech X) :=\n    CompactT2.Projective.extremallyDisconnected StoneCech.projective\n  of (StoneCech X)", "start": [24, 1], "end": [30, 19], "kind": "commanddeclaration"}, {"full_name": "Stonean.stoneCechEquivalence", "code": "noncomputable def stoneCechEquivalence (X : Type u) (Y : Stonean.{u}) :\n    (stoneCechObj X \u27f6 Y) \u2243 (X \u27f6 (forget Stonean).obj Y) := by\n  letI : TopologicalSpace X := \u22a5\n  haveI : DiscreteTopology X := \u27e8rfl\u27e9\n  refine (equivOfFullyFaithful toCompHaus).trans ?_\n  exact (_root_.stoneCechEquivalence (TopCat.of X) (toCompHaus.obj Y)).trans\n    (TopCat.adj\u2081.homEquiv _ _)", "start": [32, 1], "end": [40, 31], "kind": "commanddeclaration"}, {"full_name": "typeToStonean", "code": "noncomputable def typeToStonean : Type u \u2964 Stonean.{u} :=\n  leftAdjointOfEquiv Stonean.stoneCechEquivalence fun _ _ _ _ _ => rfl", "start": [44, 1], "end": [46, 71], "kind": "commanddeclaration"}, {"full_name": "Stonean.stoneCechAdjunction", "code": "noncomputable def stoneCechAdjunction : typeToStonean \u22a3 (forget Stonean) :=\n  adjunctionOfEquivLeft stoneCechEquivalence fun _ _ _ _ _ => rfl", "start": [50, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "Stonean.forget.preservesLimits", "code": "noncomputable instance forget.preservesLimits : Limits.PreservesLimits (forget Stonean) :=\n  rightAdjointPreservesLimits stoneCechAdjunction", "start": [54, 1], "end": [56, 50], "kind": "commanddeclaration"}, {"full_name": "Stonean.mono_iff_injective", "code": "theorem mono_iff_injective {X Y : Stonean} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f", "start": [58, 1], "end": [59, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Grade.lean", "imports": ["Mathlib/Data/Finset/Basic.lean", "Mathlib/Data/Int/SuccPred.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GradeOrder", "code": "class GradeOrder (\ud835\udd46 \u03b1 : Type*) [Preorder \ud835\udd46] [Preorder \u03b1] where\n  \n  grade : \u03b1 \u2192 \ud835\udd46\n  \n  grade_strictMono : StrictMono grade\n  \n  covby_grade \u2983a b : \u03b1\u2984 : a \u22d6 b \u2192 grade a \u22d6 grade b", "start": [63, 1], "end": [71, 52], "kind": "commanddeclaration"}, {"full_name": "GradeMinOrder", "code": "class GradeMinOrder (\ud835\udd46 \u03b1 : Type*) [Preorder \ud835\udd46] [Preorder \u03b1] extends GradeOrder \ud835\udd46 \u03b1 where\n  \n  isMin_grade \u2983a : \u03b1\u2984 : IsMin a \u2192 IsMin (grade a)", "start": [74, 1], "end": [77, 50], "kind": "commanddeclaration"}, {"full_name": "GradeMaxOrder", "code": "class GradeMaxOrder (\ud835\udd46 \u03b1 : Type*) [Preorder \ud835\udd46] [Preorder \u03b1] extends GradeOrder \ud835\udd46 \u03b1 where\n  \n  isMax_grade \u2983a : \u03b1\u2984 : IsMax a \u2192 IsMax (grade a)", "start": [80, 1], "end": [83, 50], "kind": "commanddeclaration"}, {"full_name": "GradeBoundedOrder", "code": "class GradeBoundedOrder (\ud835\udd46 \u03b1 : Type*) [Preorder \ud835\udd46] [Preorder \u03b1] extends GradeMinOrder \ud835\udd46 \u03b1,\n  GradeMaxOrder \ud835\udd46 \u03b1", "start": [86, 1], "end": [89, 20], "kind": "commanddeclaration"}, {"full_name": "grade", "code": "def grade : \u03b1 \u2192 \ud835\udd46 :=\n  GradeOrder.grade", "start": [102, 1], "end": [105, 19], "kind": "commanddeclaration"}, {"full_name": "Covby.grade", "code": "protected theorem Covby.grade (h : a \u22d6 b) : grade \ud835\udd46 a \u22d6 grade \ud835\udd46 b", "start": [108, 1], "end": [109, 27], "kind": "commanddeclaration"}, {"full_name": "grade_strictMono", "code": "theorem grade_strictMono : StrictMono (grade \ud835\udd46 : \u03b1 \u2192 \ud835\udd46)", "start": [114, 1], "end": [115, 30], "kind": "commanddeclaration"}, {"full_name": "covby_iff_lt_covby_grade", "code": "theorem covby_iff_lt_covby_grade : a \u22d6 b \u2194 a < b \u2227 grade \ud835\udd46 a \u22d6 grade \ud835\udd46 b", "start": [118, 1], "end": [120, 85], "kind": "commanddeclaration"}, {"full_name": "IsMin.grade", "code": "protected theorem IsMin.grade (h : IsMin a) : IsMin (grade \ud835\udd46 a)", "start": [129, 1], "end": [130, 30], "kind": "commanddeclaration"}, {"full_name": "isMin_grade_iff", "code": "@[simp]\ntheorem isMin_grade_iff : IsMin (grade \ud835\udd46 a) \u2194 IsMin a", "start": [135, 1], "end": [137, 51], "kind": "commanddeclaration"}, {"full_name": "IsMax.grade", "code": "protected theorem IsMax.grade (h : IsMax a) : IsMax (grade \ud835\udd46 a)", "start": [146, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "isMax_grade_iff", "code": "@[simp]\ntheorem isMax_grade_iff : IsMax (grade \ud835\udd46 a) \u2194 IsMax a", "start": [152, 1], "end": [154, 51], "kind": "commanddeclaration"}, {"full_name": "grade_mono", "code": "theorem grade_mono [PartialOrder \u03b1] [Preorder \ud835\udd46] [GradeOrder \ud835\udd46 \u03b1] : Monotone (grade \ud835\udd46 : \u03b1 \u2192 \ud835\udd46)", "start": [162, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "grade_injective", "code": "theorem grade_injective : Function.Injective (grade \ud835\udd46 : \u03b1 \u2192 \ud835\udd46)", "start": [171, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "grade_le_grade_iff", "code": "@[simp]\ntheorem grade_le_grade_iff : grade \ud835\udd46 a \u2264 grade \ud835\udd46 b \u2194 a \u2264 b", "start": [175, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "grade_lt_grade_iff", "code": "@[simp]\ntheorem grade_lt_grade_iff : grade \ud835\udd46 a < grade \ud835\udd46 b \u2194 a < b", "start": [180, 1], "end": [182, 29], "kind": "commanddeclaration"}, {"full_name": "grade_eq_grade_iff", "code": "@[simp]\ntheorem grade_eq_grade_iff : grade \ud835\udd46 a = grade \ud835\udd46 b \u2194 a = b", "start": [185, 1], "end": [187, 25], "kind": "commanddeclaration"}, {"full_name": "grade_ne_grade_iff", "code": "theorem grade_ne_grade_iff : grade \ud835\udd46 a \u2260 grade \ud835\udd46 b \u2194 a \u2260 b", "start": [190, 1], "end": [191, 25], "kind": "commanddeclaration"}, {"full_name": "grade_covby_grade_iff", "code": "theorem grade_covby_grade_iff : grade \ud835\udd46 a \u22d6 grade \ud835\udd46 b \u2194 a \u22d6 b", "start": [194, 1], "end": [195, 98], "kind": "commanddeclaration"}, {"full_name": "grade_bot", "code": "@[simp]\ntheorem grade_bot [OrderBot \ud835\udd46] [OrderBot \u03b1] [GradeMinOrder \ud835\udd46 \u03b1] : grade \ud835\udd46 (\u22a5 : \u03b1) = \u22a5", "start": [208, 1], "end": [210, 29], "kind": "commanddeclaration"}, {"full_name": "grade_top", "code": "@[simp]\ntheorem grade_top [OrderTop \ud835\udd46] [OrderTop \u03b1] [GradeMaxOrder \ud835\udd46 \u03b1] : grade \ud835\udd46 (\u22a4 : \u03b1) = \u22a4", "start": [213, 1], "end": [215, 29], "kind": "commanddeclaration"}, {"full_name": "Preorder.toGradeBoundedOrder", "code": "instance Preorder.toGradeBoundedOrder : GradeBoundedOrder \u03b1 \u03b1 where\n  grade := id\n  isMin_grade _ := id\n  isMax_grade _ := id\n  grade_strictMono := strictMono_id\n  covby_grade _ _ := id", "start": [224, 1], "end": [229, 24], "kind": "commanddeclaration"}, {"full_name": "grade_self", "code": "@[simp]\ntheorem grade_self (a : \u03b1) : grade \u03b1 a = a", "start": [232, 1], "end": [234, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.gradeOrder", "code": "instance OrderDual.gradeOrder [GradeOrder \ud835\udd46 \u03b1] : GradeOrder \ud835\udd46\u1d52\u1d48 \u03b1\u1d52\u1d48 where\n  grade := toDual \u2218 grade \ud835\udd46 \u2218 ofDual\n  grade_strictMono := grade_strictMono.dual\n  covby_grade _ _ h := (h.ofDual.grade _).toDual", "start": [239, 1], "end": [242, 49], "kind": "commanddeclaration"}, {"full_name": "OrderDual.gradeMinOrder", "code": "instance OrderDual.gradeMinOrder [GradeMaxOrder \ud835\udd46 \u03b1] : GradeMinOrder \ud835\udd46\u1d52\u1d48 \u03b1\u1d52\u1d48 :=\n  { OrderDual.gradeOrder with isMin_grade := fun _ => IsMax.grade (\u03b1 := \u03b1) \ud835\udd46 }", "start": [244, 1], "end": [245, 79], "kind": "commanddeclaration"}, {"full_name": "OrderDual.gradeMaxOrder", "code": "instance OrderDual.gradeMaxOrder [GradeMinOrder \ud835\udd46 \u03b1] : GradeMaxOrder \ud835\udd46\u1d52\u1d48 \u03b1\u1d52\u1d48 :=\n  { OrderDual.gradeOrder with isMax_grade := fun _ => IsMin.grade (\u03b1 := \u03b1) \ud835\udd46 }", "start": [247, 1], "end": [248, 79], "kind": "commanddeclaration"}, {"full_name": "grade_toDual", "code": "@[simp]\ntheorem grade_toDual [GradeOrder \ud835\udd46 \u03b1] (a : \u03b1) : grade \ud835\udd46\u1d52\u1d48 (toDual a) = toDual (grade \ud835\udd46 a)", "start": [253, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "grade_ofDual", "code": "@[simp]\ntheorem grade_ofDual [GradeOrder \ud835\udd46 \u03b1] (a : \u03b1\u1d52\u1d48) : grade \ud835\udd46 (ofDual a) = ofDual (grade \ud835\udd46\u1d52\u1d48 a)", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "GradeOrder.liftLeft", "code": "@[reducible]\ndef GradeOrder.liftLeft [GradeOrder \ud835\udd46 \u03b1] (f : \ud835\udd46 \u2192 \u2119) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) : GradeOrder \u2119 \u03b1\n    where\n  grade := f \u2218 (@grade \ud835\udd46 _ _ _ _) grade_strictMono := hf.comp grade_strictMono\n  covby_grade _ _ h := hcovby _ _ <| h.grade _", "start": [266, 1], "end": [273, 47], "kind": "commanddeclaration"}, {"full_name": "GradeMinOrder.liftLeft", "code": "@[reducible]\ndef GradeMinOrder.liftLeft [GradeMinOrder \ud835\udd46 \u03b1] (f : \ud835\udd46 \u2192 \u2119) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmin : \u2200 a, IsMin a \u2192 IsMin (f a)) : GradeMinOrder \u2119 \u03b1 :=\n  { GradeOrder.liftLeft f hf hcovby with isMin_grade := fun _ ha => hmin _ <| ha.grade _ }", "start": [277, 1], "end": [281, 91], "kind": "commanddeclaration"}, {"full_name": "GradeMaxOrder.liftLeft", "code": "@[reducible]\ndef GradeMaxOrder.liftLeft [GradeMaxOrder \ud835\udd46 \u03b1] (f : \ud835\udd46 \u2192 \u2119) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmax : \u2200 a, IsMax a \u2192 IsMax (f a)) : GradeMaxOrder \u2119 \u03b1 :=\n  { GradeOrder.liftLeft f hf hcovby with isMax_grade := fun _ ha => hmax _ <| ha.grade _ }", "start": [285, 1], "end": [289, 91], "kind": "commanddeclaration"}, {"full_name": "GradeBoundedOrder.liftLeft", "code": "@[reducible]\ndef GradeBoundedOrder.liftLeft [GradeBoundedOrder \ud835\udd46 \u03b1] (f : \ud835\udd46 \u2192 \u2119) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmin : \u2200 a, IsMin a \u2192 IsMin (f a))\n    (hmax : \u2200 a, IsMax a \u2192 IsMax (f a)) : GradeBoundedOrder \u2119 \u03b1 :=\n  { GradeMinOrder.liftLeft f hf hcovby hmin, GradeMaxOrder.liftLeft f hf hcovby hmax with }", "start": [293, 1], "end": [298, 92], "kind": "commanddeclaration"}, {"full_name": "GradeOrder.liftRight", "code": "@[reducible]\ndef GradeOrder.liftRight [GradeOrder \ud835\udd46 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) : GradeOrder \ud835\udd46 \u03b1\n    where\n  grade := (@grade \ud835\udd46 _ _ _ _) \u2218 f grade_strictMono := grade_strictMono.comp hf\n  covby_grade _ _ h := (hcovby _ _ h).grade _", "start": [302, 1], "end": [309, 46], "kind": "commanddeclaration"}, {"full_name": "GradeMinOrder.liftRight", "code": "@[reducible]\ndef GradeMinOrder.liftRight [GradeMinOrder \ud835\udd46 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmin : \u2200 a, IsMin a \u2192 IsMin (f a)) : GradeMinOrder \ud835\udd46 \u03b1 :=\n  { GradeOrder.liftRight f hf hcovby with isMin_grade := fun _ ha => (hmin _ ha).grade _ }", "start": [313, 1], "end": [317, 91], "kind": "commanddeclaration"}, {"full_name": "GradeMaxOrder.liftRight", "code": "@[reducible]\ndef GradeMaxOrder.liftRight [GradeMaxOrder \ud835\udd46 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmax : \u2200 a, IsMax a \u2192 IsMax (f a)) : GradeMaxOrder \ud835\udd46 \u03b1 :=\n  { GradeOrder.liftRight f hf hcovby with isMax_grade := fun _ ha => (hmax _ ha).grade _ }", "start": [321, 1], "end": [325, 91], "kind": "commanddeclaration"}, {"full_name": "GradeBoundedOrder.liftRight", "code": "@[reducible]\ndef GradeBoundedOrder.liftRight [GradeBoundedOrder \ud835\udd46 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : StrictMono f)\n    (hcovby : \u2200 a b, a \u22d6 b \u2192 f a \u22d6 f b) (hmin : \u2200 a, IsMin a \u2192 IsMin (f a))\n    (hmax : \u2200 a, IsMax a \u2192 IsMax (f a)) : GradeBoundedOrder \ud835\udd46 \u03b1 :=\n  { GradeMinOrder.liftRight f hf hcovby hmin, GradeMaxOrder.liftRight f hf hcovby hmax with }", "start": [329, 1], "end": [334, 94], "kind": "commanddeclaration"}, {"full_name": "GradeOrder.finToNat", "code": "@[reducible]\ndef GradeOrder.finToNat (n : \u2115) [GradeOrder (Fin n) \u03b1] : GradeOrder \u2115 \u03b1 :=\n  (GradeOrder.liftLeft (_ : Fin n \u2192 \u2115) Fin.val_strictMono) fun _ _ => Covby.coe_fin", "start": [341, 1], "end": [345, 84], "kind": "commanddeclaration"}, {"full_name": "GradeMinOrder.finToNat", "code": "@[reducible]\ndef GradeMinOrder.finToNat (n : \u2115) [GradeMinOrder (Fin n) \u03b1] : GradeMinOrder \u2115 \u03b1 :=\n  (GradeMinOrder.liftLeft (_ : Fin n \u2192 \u2115) Fin.val_strictMono fun _ _ => Covby.coe_fin) fun a h => by\n    cases n\n    \u00b7 exact a.elim0\n    rw [h.eq_bot, Fin.bot_eq_zero]\n    exact isMin_bot", "start": [349, 1], "end": [357, 20], "kind": "commanddeclaration"}, {"full_name": "GradeOrder.natToInt", "code": "instance GradeOrder.natToInt [GradeOrder \u2115 \u03b1] : GradeOrder \u2124 \u03b1 :=\n  (GradeOrder.liftLeft _ Int.coe_nat_strictMono) fun _ _ => Covby.cast_int", "start": [360, 1], "end": [361, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/CircleTransform.lean", "imports": ["Mathlib/Data/Complex/Basic.lean", "Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.circleTransform", "code": "def circleTransform (f : \u2102 \u2192 E) (\u03b8 : \u211d) : E :=\n  (2 * \u2191\u03c0 * I)\u207b\u00b9 \u2022 deriv (circleMap z R) \u03b8 \u2022 (circleMap z R \u03b8 - w)\u207b\u00b9 \u2022 f (circleMap z R \u03b8)", "start": [36, 1], "end": [42, 91], "kind": "commanddeclaration"}, {"full_name": "Complex.circleTransformDeriv", "code": "def circleTransformDeriv (f : \u2102 \u2192 E) (\u03b8 : \u211d) : E :=\n  (2 * \u2191\u03c0 * I)\u207b\u00b9 \u2022 deriv (circleMap z R) \u03b8 \u2022 ((circleMap z R \u03b8 - w) ^ 2)\u207b\u00b9 \u2022 f (circleMap z R \u03b8)", "start": [45, 1], "end": [47, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.circleTransformDeriv_periodic", "code": "theorem circleTransformDeriv_periodic (f : \u2102 \u2192 E) :\n    Periodic (circleTransformDeriv R z w f) (2 * \u03c0)", "start": [50, 1], "end": [57, 14], "kind": "commanddeclaration"}, {"full_name": "Complex.circleTransformDeriv_eq", "code": "theorem circleTransformDeriv_eq (f : \u2102 \u2192 E) : circleTransformDeriv R z w f =\n    fun \u03b8 => (circleMap z R \u03b8 - w)\u207b\u00b9 \u2022 circleTransform R z w f \u03b8", "start": [60, 1], "end": [67, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.integral_circleTransform", "code": "theorem integral_circleTransform (f : \u2102 \u2192 E) :\n    (\u222b \u03b8 : \u211d in (0)..2 * \u03c0, circleTransform R z w f \u03b8) =\n      (2 * \u2191\u03c0 * I)\u207b\u00b9 \u2022 \u222e z in C(z, R), (z - w)\u207b\u00b9 \u2022 f z", "start": [70, 1], "end": [74, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_circleTransform", "code": "theorem continuous_circleTransform {R : \u211d} (hR : 0 < R) {f : \u2102 \u2192 E} {z w : \u2102}\n    (hf : ContinuousOn f <| sphere z R) (hw : w \u2208 ball z R) :\n    Continuous (circleTransform R z w f)", "start": [77, 1], "end": [85, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_circleTransformDeriv", "code": "theorem continuous_circleTransformDeriv {R : \u211d} (hR : 0 < R) {f : \u2102 \u2192 E} {z w : \u2102}\n    (hf : ContinuousOn f (sphere z R)) (hw : w \u2208 ball z R) :\n    Continuous (circleTransformDeriv R z w f)", "start": [88, 1], "end": [92, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.circleTransformBoundingFunction", "code": "def circleTransformBoundingFunction (R : \u211d) (z : \u2102) (w : \u2102 \u00d7 \u211d) : \u2102 :=\n  circleTransformDeriv R z w.1 (fun _ => 1) w.2", "start": [95, 1], "end": [97, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousOn_prod_circle_transform_function", "code": "theorem continuousOn_prod_circle_transform_function {R r : \u211d} (hr : r < R) {z : \u2102} :\n    ContinuousOn (fun w : \u2102 \u00d7 \u211d => (circleMap z R w.snd - w.fst)\u207b\u00b9 ^ 2)\n      (closedBall z r \u00d7\u02e2 univ)", "start": [100, 1], "end": [110, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.continuousOn_abs_circleTransformBoundingFunction", "code": "theorem continuousOn_abs_circleTransformBoundingFunction {R r : \u211d} (hr : r < R) (z : \u2102) :\n    ContinuousOn (abs \u2218 fun t => circleTransformBoundingFunction R z t)\n      (closedBall z r \u00d7\u02e2 univ)", "start": [113, 1], "end": [125, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_circleTransformBoundingFunction_le", "code": "theorem abs_circleTransformBoundingFunction_le {R r : \u211d} (hr : r < R) (hr' : 0 \u2264 r) (z : \u2102) :\n    \u2203 x : closedBall z r \u00d7\u02e2 [[0, 2 * \u03c0]], \u2200 y : closedBall z r \u00d7\u02e2 [[0, 2 * \u03c0]],\n    abs (circleTransformBoundingFunction R z y) \u2264 abs (circleTransformBoundingFunction R z x)", "start": [128, 1], "end": [139, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.circleTransformDeriv_bound", "code": "theorem circleTransformDeriv_bound {R : \u211d} (hR : 0 < R) {z x : \u2102} {f : \u2102 \u2192 \u2102} (hx : x \u2208 ball z R)\n    (hf : ContinuousOn f (sphere z R)) : \u2203 B \u03b5 : \u211d, 0 < \u03b5 \u2227\n      ball x \u03b5 \u2286 ball z R \u2227 \u2200 (t : \u211d), \u2200 y \u2208 ball x \u03b5, \u2016circleTransformDeriv R z y f t\u2016 \u2264 B", "start": [142, 1], "end": [174, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/PrimeCounting.lean", "imports": ["Mathlib/Data/Nat/PrimeFin.lean", "Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Data/Nat/Totient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Count.lean", "Mathlib/Data/Nat/Nth.lean"], "premises": [{"full_name": "Nat.primeCounting'", "code": "def primeCounting' : \u2115 \u2192 \u2115 :=\n  Nat.count Prime", "start": [44, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.primeCounting", "code": "def primeCounting (n : \u2115) : \u2115 :=\n  primeCounting' (n + 1)", "start": [51, 1], "end": [53, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.monotone_primeCounting'", "code": "theorem monotone_primeCounting' : Monotone primeCounting'", "start": [60, 1], "end": [61, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.monotone_primeCounting", "code": "theorem monotone_primeCounting : Monotone primeCounting", "start": [64, 1], "end": [65, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.primeCounting'_nth_eq", "code": "@[simp]\ntheorem primeCounting'_nth_eq (n : \u2115) : \u03c0' (nth Prime n) = n", "start": [68, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_nth_prime", "code": "@[simp]\ntheorem prime_nth_prime (n : \u2115) : Prime (nth Prime n)", "start": [73, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.primeCounting'_add_le", "code": "theorem primeCounting'_add_le {a k : \u2115} (h0 : 0 < a) (h1 : a < k) (n : \u2115) :\n    \u03c0' (k + n) \u2264 \u03c0' k + Nat.totient a * (n / a + 1)", "start": [78, 1], "end": [98, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Integral.lean", "imports": ["Mathlib/MeasureTheory/Integral/Average.lean", "Mathlib/Analysis/Convex/StrictConvexSpace.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean", "Mathlib/Analysis/Convex/Function.lean"], "premises": [{"full_name": "Convex.integral_mem", "code": "theorem Convex.integral_mem [IsProbabilityMeasure \u03bc] (hs : Convex \u211d s) (hsc : IsClosed s)\n    (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) : (\u222b x, f x \u2202\u03bc) \u2208 s", "start": [53, 1], "end": [81, 56], "kind": "commanddeclaration"}, {"full_name": "Convex.average_mem", "code": "theorem Convex.average_mem [IsFiniteMeasure \u03bc] [NeZero \u03bc] (hs : Convex \u211d s) (hsc : IsClosed s)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) : (\u2a0d x, f x \u2202\u03bc) \u2208 s", "start": [84, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "Convex.set_average_mem", "code": "theorem Convex.set_average_mem (hs : Convex \u211d s) (hsc : IsClosed s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e)\n    (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s) (hfi : IntegrableOn f t \u03bc) : (\u2a0d x in t, f x \u2202\u03bc) \u2208 s", "start": [93, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "Convex.set_average_mem_closure", "code": "theorem Convex.set_average_mem_closure (hs : Convex \u211d s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e)\n    (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s) (hfi : IntegrableOn f t \u03bc) :\n    (\u2a0d x in t, f x \u2202\u03bc) \u2208 closure s", "start": [103, 1], "end": [109, 97], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.average_mem_epigraph", "code": "theorem ConvexOn.average_mem_epigraph [IsFiniteMeasure \u03bc] [NeZero \u03bc] (hg : ConvexOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s)\n    (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    (\u2a0d x, f x \u2202\u03bc, \u2a0d x, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 g p.1 \u2264 p.2}", "start": [112, 1], "end": [119, 79], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.average_mem_hypograph", "code": "theorem ConcaveOn.average_mem_hypograph [IsFiniteMeasure \u03bc] [NeZero \u03bc] (hg : ConcaveOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s)\n    (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    (\u2a0d x, f x \u2202\u03bc, \u2a0d x, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 p.2 \u2264 g p.1}", "start": [122, 1], "end": [127, 60], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.map_average_le", "code": "theorem ConvexOn.map_average_le [IsFiniteMeasure \u03bc] [NeZero \u03bc]\n    (hg : ConvexOn \u211d s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    g (\u2a0d x, f x \u2202\u03bc) \u2264 \u2a0d x, g (f x) \u2202\u03bc", "start": [130, 1], "end": [139, 50], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.le_map_average", "code": "theorem ConcaveOn.le_map_average [IsFiniteMeasure \u03bc] [NeZero \u03bc]\n    (hg : ConcaveOn \u211d s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    (\u2a0d x, g (f x) \u2202\u03bc) \u2264 g (\u2a0d x, f x \u2202\u03bc)", "start": [142, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.set_average_mem_epigraph", "code": "theorem ConvexOn.set_average_mem_epigraph (hg : ConvexOn \u211d s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e) (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s)\n    (hfi : IntegrableOn f t \u03bc) (hgi : IntegrableOn (g \u2218 f) t \u03bc) :\n    (\u2a0d x in t, f x \u2202\u03bc, \u2a0d x in t, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 g p.1 \u2264 p.2}", "start": [154, 1], "end": [165, 46], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.set_average_mem_hypograph", "code": "theorem ConcaveOn.set_average_mem_hypograph (hg : ConcaveOn \u211d s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e) (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s)\n    (hfi : IntegrableOn f t \u03bc) (hgi : IntegrableOn (g \u2218 f) t \u03bc) :\n    (\u2a0d x in t, f x \u2202\u03bc, \u2a0d x in t, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 p.2 \u2264 g p.1}", "start": [168, 1], "end": [178, 70], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.map_set_average_le", "code": "theorem ConvexOn.map_set_average_le (hg : ConvexOn \u211d s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e) (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s)\n    (hfi : IntegrableOn f t \u03bc) (hgi : IntegrableOn (g \u2218 f) t \u03bc) :\n    g (\u2a0d x in t, f x \u2202\u03bc) \u2264 \u2a0d x in t, g (f x) \u2202\u03bc", "start": [181, 1], "end": [190, 60], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.le_map_set_average", "code": "theorem ConcaveOn.le_map_set_average (hg : ConcaveOn \u211d s g) (hgc : ContinuousOn g s)\n    (hsc : IsClosed s) (h0 : \u03bc t \u2260 0) (ht : \u03bc t \u2260 \u221e) (hfs : \u2200\u1d50 x \u2202\u03bc.restrict t, f x \u2208 s)\n    (hfi : IntegrableOn f t \u03bc) (hgi : IntegrableOn (g \u2218 f) t \u03bc) :\n    (\u2a0d x in t, g (f x) \u2202\u03bc) \u2264 g (\u2a0d x in t, f x \u2202\u03bc)", "start": [193, 1], "end": [202, 61], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.map_integral_le", "code": "theorem ConvexOn.map_integral_le [IsProbabilityMeasure \u03bc] (hg : ConvexOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc)\n    (hgi : Integrable (g \u2218 f) \u03bc) : g (\u222b x, f x \u2202\u03bc) \u2264 \u222b x, g (f x) \u2202\u03bc", "start": [205, 1], "end": [213, 79], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.le_map_integral", "code": "theorem ConcaveOn.le_map_integral [IsProbabilityMeasure \u03bc] (hg : ConcaveOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc)\n    (hgi : Integrable (g \u2218 f) \u03bc) : (\u222b x, g (f x) \u2202\u03bc) \u2264 g (\u222b x, f x \u2202\u03bc)", "start": [216, 1], "end": [223, 79], "kind": "commanddeclaration"}, {"full_name": "ae_eq_const_or_exists_average_ne_compl", "code": "theorem ae_eq_const_or_exists_average_ne_compl [IsFiniteMeasure \u03bc] (hfi : Integrable f \u03bc) :\n    f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228\n      \u2203 t, MeasurableSet t \u2227 \u03bc t \u2260 0 \u2227 \u03bc t\u1d9c \u2260 0 \u2227 (\u2a0d x in t, f x \u2202\u03bc) \u2260 \u2a0d x in t\u1d9c, f x \u2202\u03bc", "start": [231, 1], "end": [247, 60], "kind": "commanddeclaration"}, {"full_name": "Convex.average_mem_interior_of_set", "code": "theorem Convex.average_mem_interior_of_set [IsFiniteMeasure \u03bc] (hs : Convex \u211d s) (h0 : \u03bc t \u2260 0)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) (ht : (\u2a0d x in t, f x \u2202\u03bc) \u2208 interior s) :\n    (\u2a0d x, f x \u2202\u03bc) \u2208 interior s", "start": [250, 1], "end": [265, 17], "kind": "commanddeclaration"}, {"full_name": "StrictConvex.ae_eq_const_or_average_mem_interior", "code": "theorem StrictConvex.ae_eq_const_or_average_mem_interior [IsFiniteMeasure \u03bc] (hs : StrictConvex \u211d s)\n    (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) :\n    f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228 (\u2a0d x, f x \u2202\u03bc) \u2208 interior s", "start": [268, 1], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.ae_eq_const_or_map_average_lt", "code": "theorem StrictConvexOn.ae_eq_const_or_map_average_lt [IsFiniteMeasure \u03bc] (hg : StrictConvexOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc)\n    (hgi : Integrable (g \u2218 f) \u03bc) :\n    f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228 g (\u2a0d x, f x \u2202\u03bc) < \u2a0d x, g (f x) \u2202\u03bc", "start": [283, 1], "end": [309, 55], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.ae_eq_const_or_lt_map_average", "code": "theorem StrictConcaveOn.ae_eq_const_or_lt_map_average [IsFiniteMeasure \u03bc]\n    (hg : StrictConcaveOn \u211d s g) (hgc : ContinuousOn g s) (hsc : IsClosed s)\n    (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s) (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228 (\u2a0d x, g (f x) \u2202\u03bc) < g (\u2a0d x, f x \u2202\u03bc)", "start": [312, 1], "end": [320, 69], "kind": "commanddeclaration"}, {"full_name": "ae_eq_const_or_norm_average_lt_of_norm_le_const", "code": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const [StrictConvexSpace \u211d E]\n    (h_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) : f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228 \u2016\u2a0d x, f x \u2202\u03bc\u2016 < C", "start": [323, 1], "end": [339, 10], "kind": "commanddeclaration"}, {"full_name": "ae_eq_const_or_norm_integral_lt_of_norm_le_const", "code": "theorem ae_eq_const_or_norm_integral_lt_of_norm_le_const [StrictConvexSpace \u211d E] [IsFiniteMeasure \u03bc]\n    (h_le : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 C) :\n    f =\u1d50[\u03bc] const \u03b1 (\u2a0d x, f x \u2202\u03bc) \u2228 \u2016\u222b x, f x \u2202\u03bc\u2016 < (\u03bc univ).toReal * C", "start": [342, 1], "end": [353, 25], "kind": "commanddeclaration"}, {"full_name": "ae_eq_const_or_norm_set_integral_lt_of_norm_le_const", "code": "theorem ae_eq_const_or_norm_set_integral_lt_of_norm_le_const [StrictConvexSpace \u211d E] (ht : \u03bc t \u2260 \u221e)\n    (h_le : \u2200\u1d50 x \u2202\u03bc.restrict t, \u2016f x\u2016 \u2264 C) :\n    f =\u1d50[\u03bc.restrict t] const \u03b1 (\u2a0d x in t, f x \u2202\u03bc) \u2228 \u2016\u222b x in t, f x \u2202\u03bc\u2016 < (\u03bc t).toReal * C", "start": [356, 1], "end": [364, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Fix.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/W.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.recF", "code": "def recF {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : F (\u03b1.append1 \u03b2) \u2192 \u03b2) : q.P.W \u03b1 \u2192 \u03b2 :=\n  q.P.wRec fun a f' _f rec => g (abs \u27e8a, splitFun f' rec\u27e9)", "start": [56, 1], "end": [60, 59], "kind": "commanddeclaration"}, {"full_name": "MvQPF.recF_eq", "code": "theorem recF_eq {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : F (\u03b1.append1 \u03b2) \u2192 \u03b2) (a : q.P.A)\n    (f' : q.P.drop.B a \u27f9 \u03b1) (f : q.P.last.B a \u2192 q.P.W \u03b1) :\n    recF g (q.P.wMk a f' f) = g (abs \u27e8a, splitFun f' (recF g \u2218 f)\u27e9)", "start": [64, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "MvQPF.recF_eq'", "code": "theorem recF_eq' {\u03b1 : TypeVec n} {\u03b2 : Type u} (g : F (\u03b1.append1 \u03b2) \u2192 \u03b2) (x : q.P.W \u03b1) :\n    recF g x = g (abs (appendFun id (recF g) <$$> q.P.wDest' x))", "start": [71, 1], "end": [75, 92], "kind": "commanddeclaration"}, {"full_name": "MvQPF.WEquiv", "code": "inductive WEquiv {\u03b1 : TypeVec n} : q.P.W \u03b1 \u2192 q.P.W \u03b1 \u2192 Prop\n  | ind (a : q.P.A) (f' : q.P.drop.B a \u27f9 \u03b1) (f\u2080 f\u2081 : q.P.last.B a \u2192 q.P.W \u03b1) :\n    (\u2200 x, WEquiv (f\u2080 x) (f\u2081 x)) \u2192 WEquiv (q.P.wMk a f' f\u2080) (q.P.wMk a f' f\u2081)\n  | abs (a\u2080 : q.P.A) (f'\u2080 : q.P.drop.B a\u2080 \u27f9 \u03b1) (f\u2080 : q.P.last.B a\u2080 \u2192 q.P.W \u03b1) (a\u2081 : q.P.A)\n    (f'\u2081 : q.P.drop.B a\u2081 \u27f9 \u03b1) (f\u2081 : q.P.last.B a\u2081 \u2192 q.P.W \u03b1) :\n    abs \u27e8a\u2080, q.P.appendContents f'\u2080 f\u2080\u27e9 = abs \u27e8a\u2081, q.P.appendContents f'\u2081 f\u2081\u27e9 \u2192\n      WEquiv (q.P.wMk a\u2080 f'\u2080 f\u2080) (q.P.wMk a\u2081 f'\u2081 f\u2081)\n  | trans (u v w : q.P.W \u03b1) : WEquiv u v \u2192 WEquiv v w \u2192 WEquiv u w", "start": [79, 1], "end": [88, 67], "kind": "commanddeclaration"}, {"full_name": "MvQPF.recF_eq_of_wEquiv", "code": "theorem recF_eq_of_wEquiv (\u03b1 : TypeVec n) {\u03b2 : Type u} (u : F (\u03b1.append1 \u03b2) \u2192 \u03b2) (x y : q.P.W \u03b1) :\n    WEquiv x y \u2192 recF u x = recF u y", "start": [92, 1], "end": [104, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wEquiv.abs'", "code": "theorem wEquiv.abs' {\u03b1 : TypeVec n} (x y : q.P.W \u03b1)\n    (h : MvQPF.abs (q.P.wDest' x) = MvQPF.abs (q.P.wDest' y)) :\n    WEquiv x y", "start": [108, 1], "end": [116, 19], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wEquiv.refl", "code": "theorem wEquiv.refl {\u03b1 : TypeVec n} (x : q.P.W \u03b1) : WEquiv x x", "start": [120, 1], "end": [121, 74], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wEquiv.symm", "code": "theorem wEquiv.symm {\u03b1 : TypeVec n} (x y : q.P.W \u03b1) : WEquiv x y \u2192 WEquiv y x", "start": [125, 1], "end": [129, 77], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wrepr", "code": "def wrepr {\u03b1 : TypeVec n} : q.P.W \u03b1 \u2192 q.P.W \u03b1 :=\n  recF (q.P.wMk' \u2218 repr)", "start": [133, 1], "end": [135, 25], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wrepr_wMk", "code": "theorem wrepr_wMk {\u03b1 : TypeVec n} (a : q.P.A) (f' : q.P.drop.B a \u27f9 \u03b1)\n    (f : q.P.last.B a \u2192 q.P.W \u03b1) :\n    wrepr (q.P.wMk a f' f) =\n      q.P.wMk' (repr (abs (appendFun id wrepr <$$> \u27e8a, q.P.appendContents f' f\u27e9)))", "start": [139, 1], "end": [143, 47], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wrepr_equiv", "code": "theorem wrepr_equiv {\u03b1 : TypeVec n} (x : q.P.W \u03b1) : WEquiv (wrepr x) x", "start": [147, 1], "end": [153, 29], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wEquiv_map", "code": "theorem wEquiv_map {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (x y : q.P.W \u03b1) :\n    WEquiv x y \u2192 WEquiv (g <$$> x) (g <$$> y)", "start": [157, 1], "end": [168, 81], "kind": "commanddeclaration"}, {"full_name": "MvQPF.wSetoid", "code": "def wSetoid (\u03b1 : TypeVec n) : Setoid (q.P.W \u03b1) :=\n  \u27e8WEquiv, @wEquiv.refl _ _ _ _ _, @wEquiv.symm _ _ _ _ _, @WEquiv.trans _ _ _ _ _\u27e9", "start": [172, 1], "end": [175, 84], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix", "code": "def Fix {n : \u2115} (F : TypeVec (n + 1) \u2192 Type*) [MvFunctor F] [q : MvQPF F] (\u03b1 : TypeVec n) :=\n  Quotient (wSetoid \u03b1 : Setoid (q.P.W \u03b1))", "start": [181, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.map", "code": "def Fix.map {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) : Fix F \u03b1 \u2192 Fix F \u03b2 :=\n  Quotient.lift (fun x : q.P.W \u03b1 => \u27e6q.P.wMap g x\u27e7) fun _a _b h => Quot.sound (wEquiv_map _ _ _ h)", "start": [194, 1], "end": [196, 99], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.mvfunctor", "code": "instance Fix.mvfunctor : MvFunctor (Fix F) where map := @Fix.map _ _ _ _", "start": [199, 1], "end": [199, 73], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.rec", "code": "def Fix.rec {\u03b2 : Type u} (g : F (\u03b1 ::: \u03b2) \u2192 \u03b2) : Fix F \u03b1 \u2192 \u03b2 :=\n  Quot.lift (recF g) (recF_eq_of_wEquiv \u03b1 g)", "start": [204, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "MvQPF.fixToW", "code": "def fixToW : Fix F \u03b1 \u2192 q.P.W \u03b1 :=\n  Quotient.lift wrepr (recF_eq_of_wEquiv \u03b1 fun x => q.P.wMk' (repr x))", "start": [209, 1], "end": [211, 71], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.mk", "code": "def Fix.mk (x : F (append1 \u03b1 (Fix F \u03b1))) : Fix F \u03b1 :=\n  Quot.mk _ (q.P.wMk' (appendFun id fixToW <$$> repr x))", "start": [215, 1], "end": [217, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.dest", "code": "def Fix.dest : Fix F \u03b1 \u2192 F (append1 \u03b1 (Fix F \u03b1)) :=\n  Fix.rec (MvFunctor.map (appendFun id Fix.mk))", "start": [220, 1], "end": [222, 48], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.rec_eq", "code": "theorem Fix.rec_eq {\u03b2 : Type u} (g : F (append1 \u03b1 \u03b2) \u2192 \u03b2) (x : F (append1 \u03b1 (Fix F \u03b1))) :\n    Fix.rec g (Fix.mk x) = g (appendFun id (Fix.rec g) <$$> x)", "start": [225, 1], "end": [239, 86], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.ind_aux", "code": "theorem Fix.ind_aux (a : q.P.A) (f' : q.P.drop.B a \u27f9 \u03b1) (f : q.P.last.B a \u2192 q.P.W \u03b1) :\n    Fix.mk (abs \u27e8a, q.P.appendContents f' fun x => \u27e6f x\u27e7\u27e9) = \u27e6q.P.wMk a f' f\u27e7", "start": [242, 1], "end": [255, 20], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.ind_rec", "code": "theorem Fix.ind_rec {\u03b2 : Type u} (g\u2081 g\u2082 : Fix F \u03b1 \u2192 \u03b2)\n    (h :\n      \u2200 x : F (append1 \u03b1 (Fix F \u03b1)),\n        appendFun id g\u2081 <$$> x = appendFun id g\u2082 <$$> x \u2192 g\u2081 (Fix.mk x) = g\u2082 (Fix.mk x)) :\n    \u2200 x, g\u2081 x = g\u2082 x", "start": [258, 1], "end": [276, 12], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.rec_unique", "code": "theorem Fix.rec_unique {\u03b2 : Type u} (g : F (append1 \u03b1 \u03b2) \u2192 \u03b2) (h : Fix F \u03b1 \u2192 \u03b2)\n    (hyp : \u2200 x, h (Fix.mk x) = g (appendFun id h <$$> x)) : Fix.rec g = h", "start": [279, 1], "end": [284, 31], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.mk_dest", "code": "theorem Fix.mk_dest (x : Fix F \u03b1) : Fix.mk (Fix.dest x) = x", "start": [287, 1], "end": [294, 41], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.dest_mk", "code": "theorem Fix.dest_mk (x : F (append1 \u03b1 (Fix F \u03b1))) : Fix.dest (Fix.mk x) = x", "start": [297, 1], "end": [307, 29], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.ind", "code": "theorem Fix.ind {\u03b1 : TypeVec n} (p : Fix F \u03b1 \u2192 Prop)\n    (h : \u2200 x : F (\u03b1.append1 (Fix F \u03b1)), LiftP (PredLast \u03b1 p) x \u2192 p (Fix.mk x)) : \u2200 x, p x", "start": [310, 1], "end": [323, 12], "kind": "commanddeclaration"}, {"full_name": "MvQPF.mvqpfFix", "code": "instance mvqpfFix : MvQPF (Fix F) where\n  P := q.P.wp\n  abs \u03b1 := Quot.mk WEquiv \u03b1\n  repr \u03b1 := fixToW \u03b1\n  abs_repr := by\n    intro \u03b1\n    apply Quot.ind\n    intro a\n    apply Quot.sound\n    apply wrepr_equiv\n  abs_map := by\n    intro \u03b1 \u03b2 g x;\n    conv =>\n      rhs\n      dsimp [MvFunctor.map]", "start": [326, 1], "end": [340, 28], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Fix.drec", "code": "def Fix.drec {\u03b2 : Fix F \u03b1 \u2192 Type u}\n    (g : \u2200 x : F (\u03b1 ::: Sigma \u03b2), \u03b2 (Fix.mk <| (id ::: Sigma.fst) <$$> x)) (x : Fix F \u03b1) : \u03b2 x :=\n  let y := @Fix.rec _ F _ _ \u03b1 (Sigma \u03b2) (fun i => \u27e8_, g i\u27e9) x\n  have : x = y.1 := by\n    symm\n    dsimp\n    apply Fix.ind_rec _ id _ x\n    intro x' ih\n    rw [Fix.rec_eq]\n    dsimp\n    simp [appendFun_id_id] at ih\n    congr\n    conv =>\n      rhs\n      rw [\u2190 ih]\n    rw [MvFunctor.map_map, \u2190 appendFun_comp, id_comp]\n    simp only [Function.comp]\n  cast (by rw [this]) y.2", "start": [343, 1], "end": [361, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/ZFC/Ordinal.lean", "imports": ["Mathlib/SetTheory/ZFC/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZFSet.IsTransitive", "code": "def IsTransitive (x : ZFSet) : Prop :=\n  \u2200 y \u2208 x, y \u2286 x", "start": [39, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "ZFSet.empty_isTransitive", "code": "@[simp]\ntheorem empty_isTransitive : IsTransitive \u2205", "start": [44, 1], "end": [45, 85], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.subset_of_mem", "code": "theorem IsTransitive.subset_of_mem (h : x.IsTransitive) : y \u2208 x \u2192 y \u2286 x", "start": [48, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "ZFSet.isTransitive_iff_mem_trans", "code": "theorem isTransitive_iff_mem_trans : z.IsTransitive \u2194 \u2200 {x y : ZFSet}, x \u2208 y \u2192 y \u2208 z \u2192 x \u2208 z", "start": [52, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.mem_trans", "code": "alias \u27e8IsTransitive.mem_trans, _\u27e9 := isTransitive_iff_mem_trans", "start": [56, 1], "end": [56, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ZFSet.IsTransitive.inter", "code": "protected theorem IsTransitive.inter (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (x \u2229 y).IsTransitive", "start": [59, 1], "end": [62, 53], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.sUnion", "code": "protected theorem IsTransitive.sUnion (h : x.IsTransitive) :\n    (\u22c3\u2080 x : ZFSet).IsTransitive", "start": [65, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.sUnion'", "code": "theorem IsTransitive.sUnion' (H : \u2200 y \u2208 x, IsTransitive y) :\n    (\u22c3\u2080 x : ZFSet).IsTransitive", "start": [71, 1], "end": [74, 57], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.union", "code": "protected theorem IsTransitive.union (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (x \u222a y).IsTransitive", "start": [77, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.powerset", "code": "protected theorem IsTransitive.powerset (h : x.IsTransitive) : (powerset x).IsTransitive", "start": [87, 1], "end": [90, 32], "kind": "commanddeclaration"}, {"full_name": "ZFSet.isTransitive_iff_sUnion_subset", "code": "theorem isTransitive_iff_sUnion_subset : x.IsTransitive \u2194 (\u22c3\u2080 x : ZFSet) \u2286 x", "start": [93, 1], "end": [96, 79], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.sUnion_subset", "code": "alias \u27e8IsTransitive.sUnion_subset, _\u27e9 := isTransitive_iff_sUnion_subset", "start": [99, 1], "end": [99, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ZFSet.isTransitive_iff_subset_powerset", "code": "theorem isTransitive_iff_subset_powerset : x.IsTransitive \u2194 x \u2286 powerset x", "start": [102, 1], "end": [103, 100], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsTransitive.subset_powerset", "code": "alias \u27e8IsTransitive.subset_powerset, _\u27e9 := isTransitive_iff_subset_powerset", "start": [106, 1], "end": [106, 76], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/NumberTheory/Modular.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean", "Mathlib/LinearAlgebra/GeneralLinearGroup.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean"], "premises": [{"full_name": "ModularGroup.bottom_row_coprime", "code": "theorem bottom_row_coprime {R : Type*} [CommRing R] (g : SL(2, R)) :\n    IsCoprime ((\u2191g : Matrix (Fin 2) (Fin 2) R) 1 0) ((\u2191g : Matrix (Fin 2) (Fin 2) R) 1 1)", "start": [85, 1], "end": [90, 18], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.bottom_row_surj", "code": "theorem bottom_row_surj {R : Type*} [CommRing R] :\n    Set.SurjOn (fun g : SL(2, R) => (\u2191g : Matrix (Fin 2) (Fin 2) R) 1) Set.univ\n      {cd | IsCoprime (cd 0) (cd 1)}", "start": [93, 1], "end": [105, 12], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.tendsto_normSq_coprime_pair", "code": "theorem tendsto_normSq_coprime_pair :\n    Filter.Tendsto (fun p : Fin 2 \u2192 \u2124 => normSq ((p 0 : \u2102) * z + p 1)) cofinite atTop", "start": [116, 1], "end": [161, 76], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.lcRow0", "code": "def lcRow0 (p : Fin 2 \u2192 \u2124) : Matrix (Fin 2) (Fin 2) \u211d \u2192\u2097[\u211d] \u211d :=\n  ((p 0 : \u211d) \u2022 LinearMap.proj (0 : Fin 2) +\n      (p 1 : \u211d) \u2022 LinearMap.proj (1 : Fin 2) : (Fin 2 \u2192 \u211d) \u2192\u2097[\u211d] \u211d).comp\n    (LinearMap.proj 0)", "start": [164, 1], "end": [170, 23], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.lcRow0_apply", "code": "@[simp]\ntheorem lcRow0_apply (p : Fin 2 \u2192 \u2124) (g : Matrix (Fin 2) (Fin 2) \u211d) :\n    lcRow0 p g = p 0 * g 0 0 + p 1 * g 0 1", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.lcRow0Extend", "code": "@[simps!]\ndef lcRow0Extend {cd : Fin 2 \u2192 \u2124} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Matrix (Fin 2) (Fin 2) \u211d \u2243\u2097[\u211d] Matrix (Fin 2) (Fin 2) \u211d :=\n  LinearEquiv.piCongrRight\n    ![by\n      refine'\n        LinearMap.GeneralLinearGroup.generalLinearEquiv \u211d (Fin 2 \u2192 \u211d)\n          (GeneralLinearGroup.toLinear (planeConformalMatrix (cd 0 : \u211d) (-(cd 1 : \u211d)) _))\n      norm_cast\n      rw [neg_sq]\n      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl \u211d (Fin 2 \u2192 \u211d)]", "start": [179, 1], "end": [191, 67], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.tendsto_lcRow0", "code": "theorem tendsto_lcRow0 {cd : Fin 2 \u2192 \u2124} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Tendsto (fun g : { g : SL(2, \u2124) // (\u2191\u2098g) 1 = cd } => lcRow0 cd \u2191(\u2191g : SL(2, \u211d))) cofinite\n      (cocompact \u211d)", "start": [194, 1], "end": [233, 8], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.smul_eq_lcRow0_add", "code": "theorem smul_eq_lcRow0_add {p : Fin 2 \u2192 \u2124} (hp : IsCoprime (p 0) (p 1)) (hg : (\u2191\u2098g) 1 = p) :\n    \u2191(g \u2022 z) =\n      (lcRow0 p \u2191(g : SL(2, \u211d)) : \u2102) / ((p 0 : \u2102) ^ 2 + (p 1 : \u2102) ^ 2) +\n        ((p 1 : \u2102) * z - p 0) / (((p 0 : \u2102) ^ 2 + (p 1 : \u2102) ^ 2) * (p 0 * z + p 1))", "start": [236, 1], "end": [252, 7], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.tendsto_abs_re_smul", "code": "theorem tendsto_abs_re_smul {p : Fin 2 \u2192 \u2124} (hp : IsCoprime (p 0) (p 1)) :\n    Tendsto\n      (fun g : { g : SL(2, \u2124) // (\u2191\u2098g) 1 = p } => |((g : SL(2, \u2124)) \u2022 z).re|) cofinite atTop", "start": [255, 1], "end": [273, 68], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.exists_max_im", "code": "theorem exists_max_im : \u2203 g : SL(2, \u2124), \u2200 g' : SL(2, \u2124), (g' \u2022 z).im \u2264 (g \u2022 z).im", "start": [284, 1], "end": [298, 31], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.exists_row_one_eq_and_min_re", "code": "theorem exists_row_one_eq_and_min_re {cd : Fin 2 \u2192 \u2124} (hcd : IsCoprime (cd 0) (cd 1)) :\n    \u2203 g : SL(2, \u2124), (\u2191\u2098g) 1 = cd \u2227 \u2200 g' : SL(2, \u2124), (\u2191\u2098g) 1 = (\u2191\u2098g') 1 \u2192\n      |(g \u2022 z).re| \u2264 |(g' \u2022 z).re|", "start": [301, 1], "end": [315, 24], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.coe_T_zpow_smul_eq", "code": "theorem coe_T_zpow_smul_eq {n : \u2124} : (\u2191(T ^ n \u2022 z) : \u2102) = z + n", "start": [318, 1], "end": [320, 43], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.re_T_zpow_smul", "code": "theorem re_T_zpow_smul (n : \u2124) : (T ^ n \u2022 z).re = z.re + n", "start": [323, 1], "end": [324, 65], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.im_T_zpow_smul", "code": "theorem im_T_zpow_smul (n : \u2124) : (T ^ n \u2022 z).im = z.im", "start": [327, 1], "end": [328, 75], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.re_T_smul", "code": "theorem re_T_smul : (T \u2022 z).re = z.re + 1", "start": [331, 1], "end": [331, 79], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.im_T_smul", "code": "theorem im_T_smul : (T \u2022 z).im = z.im", "start": [334, 1], "end": [334, 75], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.re_T_inv_smul", "code": "theorem re_T_inv_smul : (T\u207b\u00b9 \u2022 z).re = z.re - 1", "start": [337, 1], "end": [337, 88], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.im_T_inv_smul", "code": "theorem im_T_inv_smul : (T\u207b\u00b9 \u2022 z).im = z.im", "start": [340, 1], "end": [340, 84], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.exists_eq_T_zpow_of_c_eq_zero", "code": "theorem exists_eq_T_zpow_of_c_eq_zero (hc : (\u2191\u2098g) 1 0 = 0) :\n    \u2203 n : \u2124, \u2200 z : \u210d, g \u2022 z = T ^ n \u2022 z", "start": [346, 1], "end": [358, 83], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.g_eq_of_c_eq_one", "code": "theorem g_eq_of_c_eq_one (hc : (\u2191\u2098g) 1 0 = 1) : g = T ^ (\u2191\u2098g) 0 0 * S * T ^ (\u2191\u2098g) 1 1", "start": [362, 1], "end": [369, 37], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.normSq_S_smul_lt_one", "code": "theorem normSq_S_smul_lt_one (h : 1 < normSq z) : normSq \u2191(S \u2022 z) < 1", "start": [372, 1], "end": [374, 78], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.im_lt_im_S_smul", "code": "theorem im_lt_im_S_smul (h : normSq z < 1) : z.im < (S \u2022 z).im", "start": [377, 1], "end": [385, 22], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.fd", "code": "def fd : Set \u210d :=\n  {z | 1 \u2264 normSq (z : \u2102) \u2227 |z.re| \u2264 (1 : \u211d) / 2}", "start": [388, 1], "end": [390, 50], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.fdo", "code": "def fdo : Set \u210d :=\n  {z | 1 < normSq (z : \u2102) \u2227 |z.re| < (1 : \u211d) / 2}", "start": [393, 1], "end": [395, 50], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.abs_two_mul_re_lt_one_of_mem_fdo", "code": "theorem abs_two_mul_re_lt_one_of_mem_fdo (h : z \u2208 \ud835\udc9f\u1d52) : |2 * z.re| < 1", "start": [406, 1], "end": [408, 12], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.three_lt_four_mul_im_sq_of_mem_fdo", "code": "theorem three_lt_four_mul_im_sq_of_mem_fdo (h : z \u2208 \ud835\udc9f\u1d52) : 3 < 4 * z.im ^ 2", "start": [411, 1], "end": [414, 37], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.one_lt_normSq_T_zpow_smul", "code": "theorem one_lt_normSq_T_zpow_smul (hz : z \u2208 \ud835\udc9f\u1d52) (n : \u2124) : 1 < normSq (T ^ n \u2022 z : \u210d)", "start": [417, 1], "end": [422, 52], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.eq_zero_of_mem_fdo_of_T_zpow_mem_fdo", "code": "theorem eq_zero_of_mem_fdo_of_T_zpow_mem_fdo {n : \u2124} (hz : z \u2208 \ud835\udc9f\u1d52) (hg : T ^ n \u2022 z \u2208 \ud835\udc9f\u1d52) :\n    n = 0", "start": [425, 1], "end": [435, 26], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.exists_smul_mem_fd", "code": "theorem exists_smul_mem_fd (z : \u210d) : \u2203 g : SL(2, \u2124), g \u2022 z \u2208 \ud835\udc9f", "start": [438, 1], "end": [468, 83], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.abs_c_le_one", "code": "theorem abs_c_le_one (hz : z \u2208 \ud835\udc9f\u1d52) (hg : g \u2022 z \u2208 \ud835\udc9f\u1d52) : |(\u2191\u2098g) 1 0| \u2264 1", "start": [473, 1], "end": [505, 42], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.c_eq_zero", "code": "theorem c_eq_zero (hz : z \u2208 \ud835\udc9f\u1d52) (hg : g \u2022 z \u2208 \ud835\udc9f\u1d52) : (\u2191\u2098g) 1 0 = 0", "start": [508, 1], "end": [527, 71], "kind": "commanddeclaration"}, {"full_name": "ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo", "code": "theorem eq_smul_self_of_mem_fdo_mem_fdo (hz : z \u2208 \ud835\udc9f\u1d52) (hg : g \u2022 z \u2208 \ud835\udc9f\u1d52) : z = g \u2022 z", "start": [530, 1], "end": [535, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Ring/Seminorm.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingSeminorm", "code": "structure RingSeminorm (R : Type*) [NonUnitalNonAssocRing R] extends AddGroupSeminorm R where\n  \n  mul_le' : \u2200 x y : R, toFun (x * y) \u2264 toFun x * toFun y", "start": [45, 1], "end": [50, 57], "kind": "commanddeclaration"}, {"full_name": "RingNorm", "code": "structure RingNorm (R : Type*) [NonUnitalNonAssocRing R] extends RingSeminorm R, AddGroupNorm R", "start": [53, 1], "end": [55, 96], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminorm", "code": "structure MulRingSeminorm (R : Type*) [NonAssocRing R] extends AddGroupSeminorm R,\n  MonoidWithZeroHom R \u211d", "start": [58, 1], "end": [62, 24], "kind": "commanddeclaration"}, {"full_name": "MulRingNorm", "code": "structure MulRingNorm (R : Type*) [NonAssocRing R] extends MulRingSeminorm R, AddGroupNorm R", "start": [65, 1], "end": [67, 93], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.ringSeminormClass", "code": "instance ringSeminormClass : RingSeminormClass (RingSeminorm R) R \u211d where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    ext x\n    exact congr_fun h x\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_mul_le_mul f := f.mul_le'\n  map_neg_eq_map f := f.neg'", "start": [81, 1], "end": [92, 29], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (p : RingSeminorm R) : (p.toAddGroupSeminorm : R \u2192 \u211d) = p", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.ext", "code": "@[ext]\ntheorem ext {p q : RingSeminorm R} : (\u2200 x, p x = q x) \u2192 p = q", "start": [104, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.eq_zero_iff", "code": "theorem eq_zero_iff {p : RingSeminorm R} : p = 0 \u2194 \u2200 x, p x = 0", "start": [113, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.ne_zero_iff", "code": "theorem ne_zero_iff {p : RingSeminorm R} : p \u2260 0 \u2194 \u2203 x, p x \u2260 0", "start": [117, 1], "end": [117, 89], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.apply_one", "code": "@[simp]\ntheorem apply_one [DecidableEq R] (x : R) : (1 : RingSeminorm R) x = if x = 0 then 0 else 1", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.seminorm_one_eq_one_iff_ne_zero", "code": "theorem seminorm_one_eq_one_iff_ne_zero (hp : p 1 \u2264 1) : p 1 = 1 \u2194 p \u2260 0", "start": [148, 1], "end": [161, 58], "kind": "commanddeclaration"}, {"full_name": "normRingSeminorm", "code": "def normRingSeminorm (R : Type*) [NonUnitalSeminormedRing R] : RingSeminorm R :=\n  { normAddGroupSeminorm R with\n    toFun := norm\n    mul_le' := norm_mul_le }", "start": [168, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "RingNorm.ringNormClass", "code": "instance ringNormClass : RingNormClass (RingNorm R) R \u211d where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    ext x\n    exact congr_fun h x\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_mul_le_mul f := f.mul_le'\n  map_neg_eq_map f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _", "start": [179, 1], "end": [191, 58], "kind": "commanddeclaration"}, {"full_name": "RingNorm.ext", "code": "@[ext]\ntheorem ext {p q : RingNorm R} : (\u2200 x, p x = q x) \u2192 p = q", "start": [203, 1], "end": [205, 18], "kind": "commanddeclaration"}, {"full_name": "RingNorm.apply_one", "code": "@[simp]\ntheorem apply_one [DecidableEq R] (x : R) : (1 : RingNorm R) x = if x = 0 then 0 else 1", "start": [215, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminorm.mulRingSeminormClass", "code": "instance mulRingSeminormClass : MulRingSeminormClass (MulRingSeminorm R) R \u211d where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    ext x\n    exact congr_fun h x\n  map_zero f := f.map_zero'\n  map_one f := f.map_one'\n  map_add_le_add f := f.add_le'\n  map_mul f := f.map_mul'\n  map_neg_eq_map f := f.neg'", "start": [229, 1], "end": [241, 29], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminorm.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (p : MulRingSeminorm R) : (p.toAddGroupSeminorm : R \u2192 \u211d) = p", "start": [248, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminorm.ext", "code": "@[ext]\ntheorem ext {p q : MulRingSeminorm R} : (\u2200 x, p x = q x) \u2192 p = q", "start": [253, 1], "end": [255, 18], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminorm.apply_one", "code": "@[simp]\ntheorem apply_one (x : R) : (1 : MulRingSeminorm R) x = if x = 0 then 0 else 1", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "MulRingNorm.mulRingNormClass", "code": "instance mulRingNormClass : MulRingNormClass (MulRingNorm R) R \u211d where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    ext x\n    exact congr_fun h x\n  map_zero f := f.map_zero'\n  map_one f := f.map_one'\n  map_add_le_add f := f.add_le'\n  map_mul f := f.map_mul'\n  map_neg_eq_map f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _", "start": [286, 1], "end": [299, 58], "kind": "commanddeclaration"}, {"full_name": "MulRingNorm.ext", "code": "@[ext]\ntheorem ext {p q : MulRingNorm R} : (\u2200 x, p x = q x) \u2192 p = q", "start": [311, 1], "end": [313, 18], "kind": "commanddeclaration"}, {"full_name": "MulRingNorm.apply_one", "code": "@[simp]\ntheorem apply_one (x : R) : (1 : MulRingNorm R) x = if x = 0 then 0 else 1", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "RingSeminorm.toRingNorm", "code": "def RingSeminorm.toRingNorm {K : Type*} [Field K] (f : RingSeminorm K) (hnt : f \u2260 0) :\n    RingNorm K :=\n  { f with\n    eq_zero_of_map_eq_zero' := fun x hx => by\n      obtain \u27e8c, hc\u27e9 := RingSeminorm.ne_zero_iff.mp hnt\n      by_contra hn0\n      have hc0 : f c = 0 := by\n        rw [\u2190 mul_one c, \u2190 mul_inv_cancel hn0, \u2190 mul_assoc, mul_comm c, mul_assoc]\n        exact\n          le_antisymm\n            (le_trans (map_mul_le_mul f _ _)\n              (by rw [\u2190 RingSeminorm.toFun_eq_coe, \u2190 AddGroupSeminorm.toFun_eq_coe, hx,\n                zero_mul]))\n            (map_nonneg f _)\n      exact hc hc0 }", "start": [335, 1], "end": [350, 21], "kind": "commanddeclaration"}, {"full_name": "normRingNorm", "code": "@[simps!]\ndef normRingNorm (R : Type*) [NonUnitalNormedRing R] : RingNorm R :=\n  { normAddGroupNorm R, normRingSeminorm R with }", "start": [353, 1], "end": [356, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/HNNExtension.lean", "imports": ["Mathlib/GroupTheory/Complement.lean", "Mathlib/GroupTheory/Coprod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HNNExtension.con", "code": "def HNNExtension.con (G : Type*) [Group G] (A B : Subgroup G) (\u03c6 : A \u2243* B) :\n    Con (G \u2217 Multiplicative \u2124) :=\n  conGen (fun x y => \u2203 (a : A),\n    x = inr (ofAdd 1) * inl (a : G) \u2227\n    y = inl (\u03c6 a : G) * inr (ofAdd 1))", "start": [35, 1], "end": [40, 39], "kind": "commanddeclaration"}, {"full_name": "HNNExtension", "code": "def HNNExtension (G : Type*) [Group G] (A B : Subgroup G) (\u03c6 : A \u2243* B) : Type _ :=\n  (HNNExtension.con G A B \u03c6).Quotient", "start": [42, 1], "end": [47, 38], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.of", "code": "def of : G \u2192* HNNExtension G A B \u03c6 :=\n  (HNNExtension.con G A B \u03c6).mk'.comp inl", "start": [57, 1], "end": [59, 42], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.t", "code": "def t : HNNExtension G A B \u03c6 :=\n  (HNNExtension.con G A B \u03c6).mk'.comp inr (ofAdd 1)", "start": [61, 1], "end": [63, 52], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.t_mul_of", "code": "theorem t_mul_of (a : A) :\n    t * (of (a : G) : HNNExtension G A B \u03c6) = of (\u03c6 a : G) * t", "start": [65, 1], "end": [67, 52], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.of_mul_t", "code": "theorem of_mul_t (b : B) :\n    (of (b : G) : HNNExtension G A B \u03c6) * t = t * of (\u03c6.symm b : G)", "start": [69, 1], "end": [71, 22], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.equiv_eq_conj", "code": "theorem equiv_eq_conj (a : A) :\n    (of (\u03c6 a : G) : HNNExtension G A B \u03c6) = t * of (a : G) * t\u207b\u00b9", "start": [73, 1], "end": [75, 22], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.equiv_symm_eq_conj", "code": "theorem equiv_symm_eq_conj (b : B) :\n    (of (\u03c6.symm b : G) : HNNExtension G A B \u03c6) = t\u207b\u00b9 * of (b : G) * t", "start": [77, 1], "end": [79, 33], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.inv_t_mul_of", "code": "theorem inv_t_mul_of (b : B) :\n    t\u207b\u00b9 * (of (b : G) : HNNExtension G A B \u03c6) = of (\u03c6.symm b : G) * t\u207b\u00b9", "start": [81, 1], "end": [83, 32], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.of_mul_inv_t", "code": "theorem of_mul_inv_t (a : A) :\n    (of (a : G) : HNNExtension G A B \u03c6) * t\u207b\u00b9 = t\u207b\u00b9 * of (\u03c6 a : G)", "start": [85, 1], "end": [87, 39], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.lift", "code": "def lift (f : G \u2192* H) (x : H) (hx : \u2200 a : A, x * f \u2191a = f (\u03c6 a : G) * x) :\n    HNNExtension G A B \u03c6 \u2192* H :=\n  Con.lift _ (Coprod.lift f (zpowersHom H x)) (Con.conGen_le <| by\n    rintro _ _ \u27e8a, rfl, rfl\u27e9\n    simp [hx])", "start": [89, 1], "end": [94, 15], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.lift_t", "code": "@[simp]\ntheorem lift_t (f : G \u2192* H) (x : H) (hx : \u2200 a : A, x * f \u2191a = f (\u03c6 a : G) * x) :\n    lift f x hx t = x", "start": [96, 1], "end": [99, 37], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.lift_of", "code": "@[simp]\ntheorem lift_of (f : G \u2192* H) (x : H) (hx : \u2200 a : A, x * f \u2191a = f (\u03c6 a : G) * x) (g : G) :\n    lift f x hx (of g) = f g", "start": [101, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.hom_ext", "code": "@[ext high]\ntheorem hom_ext {f g : HNNExtension G A B \u03c6 \u2192* M}\n    (hg : f.comp of = g.comp of) (ht : f t = g t) : f = g", "start": [106, 1], "end": [110, 46], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {motive : HNNExtension G A B \u03c6 \u2192 Prop}\n    (x : HNNExtension G A B \u03c6) (of : \u2200 g, motive (of g))\n    (t : motive t) (mul : \u2200 x y, motive x \u2192 motive y \u2192 motive (x * y))\n    (inv : \u2200 x, motive x \u2192 motive x\u207b\u00b9) : motive x", "start": [112, 1], "end": [129, 16], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroup", "code": "def toSubgroup (u : \u2124\u02e3) : Subgroup G :=\n  if u = 1 then A else B", "start": [133, 1], "end": [138, 25], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroup_one", "code": "@[simp]\ntheorem toSubgroup_one : toSubgroup A B 1 = A", "start": [140, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroup_neg_one", "code": "@[simp]\ntheorem toSubgroup_neg_one : toSubgroup A B (-1) = B", "start": [143, 1], "end": [144, 60], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroupEquiv", "code": "def toSubgroupEquiv (u : \u2124\u02e3) : toSubgroup A B u \u2243* toSubgroup A B (-u) :=\n  if hu : u = 1 then hu \u25b8 \u03c6 else by\n    convert \u03c6.symm <;>\n    cases Int.units_eq_one_or u <;> simp_all", "start": [148, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroupEquiv_one", "code": "@[simp]\ntheorem toSubgroupEquiv_one : toSubgroupEquiv \u03c6 1 = \u03c6", "start": [157, 1], "end": [158, 61], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroupEquiv_neg_one", "code": "@[simp]\ntheorem toSubgroupEquiv_neg_one : toSubgroupEquiv \u03c6 (-1) = \u03c6.symm", "start": [160, 1], "end": [161, 73], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.toSubgroupEquiv_neg_apply", "code": "@[simp]\ntheorem toSubgroupEquiv_neg_apply (u : \u2124\u02e3) (a : toSubgroup A B u) :\n    (toSubgroupEquiv \u03c6 (-u) (toSubgroupEquiv \u03c6 u a) : G) = a", "start": [163, 1], "end": [170, 31], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.TransversalPair", "code": "structure TransversalPair : Type _ :=\n  \n  set : \u2124\u02e3 \u2192 Set G\n  \n  compl : \u2200 u, IsComplement (toSubgroup A B u : Subgroup G) (set u)", "start": [175, 1], "end": [181, 68], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.TransversalPair.nonempty", "code": "instance TransversalPair.nonempty : Nonempty (TransversalPair G A B) := by\n  have := fun u => exists_right_transversal (H := toSubgroup A B u) (1 : G)\n  simp only [Classical.skolem] at this\n  rcases this with \u27e8t, ht\u27e9\n  apply Nonempty.intro\n  exact\n    { set := t\n      compl := fun i => (ht i).1 }", "start": [183, 1], "end": [190, 35], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.ReducedWord", "code": "structure ReducedWord : Type _ :=\n  \n  head : G\n  \n  toList : List (\u2124\u02e3 \u00d7 G)\n  \n  chain : toList.Chain' (fun a b => a.2 \u2208 toSubgroup A B a.1 \u2192 a.1 = b.1)", "start": [192, 1], "end": [203, 74], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.ReducedWord.empty", "code": "@[simps]\ndef ReducedWord.empty : ReducedWord G A B :=\n  { head := 1\n    toList := []\n    chain := List.chain'_nil }", "start": [205, 1], "end": [210, 31], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.ReducedWord.prod", "code": "def ReducedWord.prod : ReducedWord G A B \u2192 HNNExtension G A B \u03c6 :=\n  fun w => of w.head * (w.toList.map (fun x => t ^ (x.1 : \u2124) * of x.2)).prod", "start": [213, 1], "end": [215, 77], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord", "code": "structure _root_.HNNExtension.NormalWord (d : TransversalPair G A B)\n    extends ReducedWord G A B : Type _ :=\n  \n  mem_set : \u2200 (u : \u2124\u02e3) (g : G), (u, g) \u2208 toList \u2192 g \u2208 d.set u", "start": [217, 1], "end": [225, 62], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.ext", "code": "@[ext]\ntheorem ext {w w' : NormalWord d}\n    (h1 : w.head = w'.head) (h2 : w.toList = w'.toList): w = w'", "start": [229, 1], "end": [232, 44], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.empty", "code": "@[simps]\ndef empty : NormalWord d :=\n  { head := 1\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }", "start": [234, 1], "end": [240, 31], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.ofGroup", "code": "@[simps]\ndef ofGroup (g : G) : NormalWord d :=\n  { head := g\n    toList := []\n    mem_set := by simp\n    chain := List.chain'_nil }", "start": [242, 1], "end": [249, 31], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.group_smul_def", "code": "theorem group_smul_def (g : G) (w : NormalWord d) :\n    g \u2022 w = { w with head := g * w.head }", "start": [258, 1], "end": [259, 49], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.group_smul_head", "code": "@[simp]\ntheorem group_smul_head (g : G) (w : NormalWord d) : (g \u2022 w).head = g * w.head", "start": [261, 1], "end": [262, 86], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.group_smul_toList", "code": "@[simp]\ntheorem group_smul_toList (g : G) (w : NormalWord d) : (g \u2022 w).toList = w.toList", "start": [264, 1], "end": [265, 88], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.cons", "code": "@[simps]\ndef cons (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n    (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?, w.head \u2208 toSubgroup A B u \u2192 u = u') :\n    NormalWord d :=\n  { head := g,\n    toList := (u, w.head) :: w.toList,\n    mem_set := by\n      intro u' g' h'\n      simp only [List.mem_cons, Prod.mk.injEq] at h'\n      rcases h' with \u27e8rfl, rfl\u27e9 | h'\n      \u00b7 exact h1\n      \u00b7 exact w.mem_set _ _ h'\n    chain := by\n      refine List.chain'_cons'.2 \u27e8?_, w.chain\u27e9\n      rintro \u27e8u', g'\u27e9 hu' hw1\n      exact h2 _ (by simp_all) hw1 }", "start": [269, 1], "end": [287, 37], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.consRecOn", "code": "@[elab_as_elim]\ndef consRecOn {motive : NormalWord d \u2192 Sort*} (w : NormalWord d)\n    (ofGroup : \u2200g, motive (ofGroup g))\n    (cons : \u2200 (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n      (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?,\n        w.head \u2208 toSubgroup A B u \u2192 u = u'),\n      motive w \u2192 motive (cons g u w h1 h2)) : motive w := by\n  rcases w with \u27e8\u27e8g, l, chain\u27e9, mem_set\u27e9\n  induction l generalizing g with\n  | nil => exact ofGroup _\n  | cons a l ih =>\n    exact cons g a.1\n      { head := a.2\n        toList := l\n        mem_set := fun _ _ h => mem_set _ _ (List.mem_cons_of_mem _ h),\n        chain := (List.chain'_cons'.1 chain).2 }\n      (mem_set a.1 a.2 (List.mem_cons_self _ _))\n      (by simpa using (List.chain'_cons'.1 chain).1)\n      (ih _ _ _)", "start": [289, 1], "end": [308, 17], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.consRecOn_ofGroup", "code": "@[simp]\ntheorem consRecOn_ofGroup {motive : NormalWord d \u2192 Sort*}\n    (g : G) (ofGroup : \u2200g, motive (ofGroup g))\n    (cons : \u2200 (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n      (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?, w.head\n        \u2208 toSubgroup A B u \u2192 u = u'),\n      motive w \u2192 motive (cons g u w h1 h2)) :\n    consRecOn (.ofGroup g) ofGroup cons = ofGroup g", "start": [310, 1], "end": [317, 59], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.consRecOn_cons", "code": "@[simp]\ntheorem consRecOn_cons {motive : NormalWord d \u2192 Sort*}\n    (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n    (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?, w.head \u2208 toSubgroup A B u \u2192 u = u')\n    (ofGroup : \u2200g, motive (ofGroup g))\n    (cons : \u2200 (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n      (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?,\n        w.head \u2208 toSubgroup A B u \u2192 u = u'),\n      motive w \u2192 motive (cons g u w h1 h2)) :\n    consRecOn (.cons g u w h1 h2) ofGroup cons = cons g u w h1 h2\n      (consRecOn w ofGroup cons)", "start": [319, 1], "end": [329, 40], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.smul_cons", "code": "@[simp]\ntheorem smul_cons (g\u2081 g\u2082 : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n    (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?, w.head \u2208 toSubgroup A B u \u2192 u = u') :\n    g\u2081 \u2022 cons g\u2082 u w h1 h2 = cons (g\u2081 * g\u2082) u w h1 h2", "start": [331, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.smul_ofGroup", "code": "@[simp]\ntheorem smul_ofGroup (g\u2081 g\u2082 : G) :\n    g\u2081 \u2022 (ofGroup g\u2082 : NormalWord d) = ofGroup (g\u2081 * g\u2082)", "start": [337, 1], "end": [339, 64], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMulGroup", "code": "noncomputable def unitsSMulGroup (u : \u2124\u02e3) (g : G) :\n    (toSubgroup A B (-u)) \u00d7 d.set u :=\n  let g' := (d.compl u).equiv g\n  (toSubgroupEquiv \u03c6 u g'.1, g'.2)", "start": [342, 1], "end": [347, 35], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMulGroup_snd", "code": "theorem unitsSMulGroup_snd (u : \u2124\u02e3) (g : G) :\n    (unitsSMulGroup \u03c6 d u g).2 = ((d.compl u).equiv g).2", "start": [349, 1], "end": [351, 54], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.Cancels", "code": "def Cancels (u : \u2124\u02e3) (w : NormalWord d) : Prop :=\n  (w.head \u2208 (toSubgroup A B u : Subgroup G)) \u2227 w.toList.head?.map Prod.fst = some (-u)", "start": [355, 1], "end": [358, 87], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMulWithCancel", "code": "def unitsSMulWithCancel (u : \u2124\u02e3) (w : NormalWord d) : Cancels u w \u2192 NormalWord d :=\n  consRecOn w\n    (by simp [Cancels, ofGroup]; tauto)\n    (fun g u' w h1 h2 _ can =>\n      (toSubgroupEquiv \u03c6 u \u27e8g, can.1\u27e9 : G) \u2022 w)", "start": [360, 1], "end": [365, 48], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMul", "code": "noncomputable def unitsSMul (u : \u2124\u02e3) (w : NormalWord d) : NormalWord d :=\n  letI := Classical.dec\n  if h : Cancels u w\n  then unitsSMulWithCancel \u03c6 u w h\n  else let g' := unitsSMulGroup \u03c6 d u w.head\n    cons g'.1 u ((g'.2 * w.head\u207b\u00b9 : G) \u2022 w)\n      (by simp)\n      (by\n        simp only [group_smul_toList, Option.mem_def, Option.map_eq_some', Prod.exists,\n          exists_and_right, exists_eq_right, group_smul_head, inv_mul_cancel_right,\n          forall_exists_index, unitsSMulGroup]\n        simp only [Cancels, Option.map_eq_some', Prod.exists, exists_and_right, exists_eq_right,\n          not_and, not_exists] at h\n        intro u' x hx hmem\n        have : w.head \u2208 toSubgroup A B u := by\n          have := (d.compl u).rightCosetEquivalence_equiv_snd w.head\n          rw [RightCosetEquivalence, rightCoset_eq_iff, mul_mem_cancel_left hmem] at this\n          simp_all\n        have := h this x\n        simp_all [Int.units_ne_iff_eq_neg])", "start": [367, 1], "end": [387, 44], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.not_cancels_of_cons_hyp", "code": "theorem not_cancels_of_cons_hyp (u : \u2124\u02e3) (w : NormalWord d)\n    (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?,\n      w.head \u2208 toSubgroup A B u \u2192 u = u') :\n    \u00ac Cancels u w", "start": [389, 1], "end": [398, 29], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMul_cancels_iff", "code": "theorem unitsSMul_cancels_iff (u : \u2124\u02e3) (w : NormalWord d) :\n    Cancels (-u) (unitsSMul \u03c6 u w) \u2194 \u00ac Cancels u w", "start": [400, 1], "end": [415, 28], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMul_neg", "code": "theorem unitsSMul_neg (u : \u2124\u02e3) (w : NormalWord d) :\n    unitsSMul \u03c6 (-u) (unitsSMul \u03c6 u w) = w", "start": [417, 1], "end": [453, 13], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMulEquiv", "code": "@[simps]\nnoncomputable def unitsSMulEquiv : NormalWord d \u2243 NormalWord d :=\n  { toFun := unitsSMul \u03c6 1\n    invFun := unitsSMul \u03c6 (-1),\n    left_inv := fun _ => by rw [unitsSMul_neg]\n    right_inv := fun w => by convert unitsSMul_neg _ _ w; simp }", "start": [455, 1], "end": [461, 65], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.unitsSMul_one_group_smul", "code": "theorem unitsSMul_one_group_smul (g : A) (w : NormalWord d) :\n    unitsSMul \u03c6 1 ((g : G) \u2022 w) = (\u03c6 g : G) \u2022 (unitsSMul \u03c6 1 w)", "start": [463, 1], "end": [482, 50], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_group_smul", "code": "@[simp]\ntheorem prod_group_smul (g : G) (w : NormalWord d) :\n    (g \u2022 w).prod \u03c6 = of g * (w.prod \u03c6)", "start": [491, 1], "end": [494, 47], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.of_smul_eq_smul", "code": "theorem of_smul_eq_smul (g : G) (w : NormalWord d) :\n    (of g : HNNExtension G A B \u03c6) \u2022 w = g \u2022 w", "start": [496, 1], "end": [498, 50], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.t_smul_eq_unitsSMul", "code": "theorem t_smul_eq_unitsSMul (w : NormalWord d) :\n    (t : HNNExtension G A B \u03c6) \u2022 w = unitsSMul \u03c6 1 w", "start": [500, 1], "end": [502, 50], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.t_pow_smul_eq_unitsSMul", "code": "theorem t_pow_smul_eq_unitsSMul (u : \u2124\u02e3) (w : NormalWord d) :\n    (t ^ (u : \u2124) : HNNExtension G A B \u03c6) \u2022 w = unitsSMul \u03c6 u w", "start": [504, 1], "end": [507, 72], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_cons", "code": "@[simp]\ntheorem prod_cons (g : G) (u : \u2124\u02e3) (w : NormalWord d) (h1 : w.head \u2208 d.set u)\n    (h2 : \u2200 u' \u2208 Option.map Prod.fst w.toList.head?,\n      w.head \u2208 toSubgroup A B u \u2192 u = u') :\n    (cons g u w h1 h2).prod \u03c6 = of g * (t ^ (u : \u2124) * w.prod \u03c6)", "start": [509, 1], "end": [514, 53], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_unitsSMul", "code": "theorem prod_unitsSMul (u : \u2124\u02e3) (w : NormalWord d) :\n    (unitsSMul \u03c6 u w).prod \u03c6 = (t^(u : \u2124) * w.prod \u03c6 : HNNExtension G A B \u03c6)", "start": [516, 1], "end": [539, 77], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_empty", "code": "@[simp]\ntheorem prod_empty : (empty : NormalWord d).prod \u03c6 = 1", "start": [541, 1], "end": [543, 26], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_smul", "code": "@[simp]\ntheorem prod_smul (g : HNNExtension G A B \u03c6) (w : NormalWord d) :\n    (g \u2022 w).prod \u03c6 = g * w.prod \u03c6", "start": [545, 1], "end": [554, 9], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_smul_empty", "code": "@[simp]\ntheorem prod_smul_empty (w : NormalWord d) :\n    (w.prod \u03c6) \u2022 empty = w", "start": [556, 1], "end": [574, 11], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.equiv", "code": "noncomputable def equiv : HNNExtension G A B \u03c6 \u2243 NormalWord d :=\n  { toFun := fun g => g \u2022 empty,\n    invFun := fun w => w.prod \u03c6,\n    left_inv := fun g => by simp [prod_smul]\n    right_inv := fun w => by simp }", "start": [577, 1], "end": [582, 36], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.NormalWord.prod_injective", "code": "theorem prod_injective : Injective\n    (fun w => w.prod \u03c6 : NormalWord d \u2192 HNNExtension G A B \u03c6)", "start": [584, 1], "end": [586, 29], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.of_injective", "code": "theorem of_injective : Function.Injective (of : G \u2192 HNNExtension G A B \u03c6)", "start": [595, 1], "end": [601, 56], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.ReducedWord.exists_normalWord_prod_eq", "code": "theorem exists_normalWord_prod_eq\n    (d : TransversalPair G A B) (w : ReducedWord G A B) :\n    \u2203 w' : NormalWord d, w'.prod \u03c6 = w.prod \u03c6 \u2227\n      w'.toList.map Prod.fst = w.toList.map Prod.fst \u2227\n      \u2200 u \u2208 w.toList.head?.map Prod.fst,\n      w'.head\u207b\u00b9 * w.head \u2208 toSubgroup A B (-u)", "start": [605, 1], "end": [655, 81], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.ReducedWord.map_fst_eq_and_of_prod_eq", "code": "theorem map_fst_eq_and_of_prod_eq {w\u2081 w\u2082 : ReducedWord G A B}\n    (hprod : w\u2081.prod \u03c6 = w\u2082.prod \u03c6) :\n    w\u2081.toList.map Prod.fst = w\u2082.toList.map Prod.fst \u2227\n     \u2200 u \u2208 w\u2081.toList.head?.map Prod.fst,\n      w\u2081.head\u207b\u00b9 * w\u2082.head \u2208 toSubgroup A B (-u)", "start": [657, 1], "end": [676, 57], "kind": "commanddeclaration"}, {"full_name": "HNNExtension.ReducedWord.toList_eq_nil_of_mem_of_range", "code": "theorem toList_eq_nil_of_mem_of_range (w : ReducedWord G A B)\n    (hw : w.prod \u03c6 \u2208 (of.range : Subgroup (HNNExtension G A B \u03c6))) :\n    w.toList = []", "start": [678, 1], "end": [686, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SumIntegralComparisons.lean", "imports": ["Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "Mathlib/Analysis/SpecialFunctions/Integrals.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AntitoneOn.integral_le_sum", "code": "theorem AntitoneOn.integral_le_sum (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u222b x in x\u2080..x\u2080 + a, f x) \u2264 \u2211 i in Finset.range a, f (x\u2080 + i)", "start": [50, 1], "end": [73, 53], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.integral_le_sum_Ico", "code": "theorem AntitoneOn.integral_le_sum_Ico (hab : a \u2264 b) (hf : AntitoneOn f (Set.Icc a b)) :\n    (\u222b x in a..b, f x) \u2264 \u2211 x in Finset.Ico a b, f x", "start": [76, 1], "end": [98, 59], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.sum_le_integral", "code": "theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u2211 i in Finset.range a, f (x\u2080 + (i + 1 : \u2115))) \u2264 \u222b x in x\u2080..x\u2080 + a, f x", "start": [101, 1], "end": [126, 42], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.sum_le_integral_Ico", "code": "theorem AntitoneOn.sum_le_integral_Ico (hab : a \u2264 b) (hf : AntitoneOn f (Set.Icc a b)) :\n    (\u2211 i in Finset.Ico a b, f (i + 1 : \u2115)) \u2264 \u222b x in a..b, f x", "start": [129, 1], "end": [150, 59], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.sum_le_integral", "code": "theorem MonotoneOn.sum_le_integral (hf : MonotoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u2211 i in Finset.range a, f (x\u2080 + i)) \u2264 \u222b x in x\u2080..x\u2080 + a, f x", "start": [153, 1], "end": [156, 31], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.sum_le_integral_Ico", "code": "theorem MonotoneOn.sum_le_integral_Ico (hab : a \u2264 b) (hf : MonotoneOn f (Set.Icc a b)) :\n    \u2211 x in Finset.Ico a b, f x \u2264 \u222b x in a..b, f x", "start": [159, 1], "end": [162, 39], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.integral_le_sum", "code": "theorem MonotoneOn.integral_le_sum (hf : MonotoneOn f (Icc x\u2080 (x\u2080 + a))) :\n    (\u222b x in x\u2080..x\u2080 + a, f x) \u2264 \u2211 i in Finset.range a, f (x\u2080 + (i + 1 : \u2115))", "start": [165, 1], "end": [168, 31], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.integral_le_sum_Ico", "code": "theorem MonotoneOn.integral_le_sum_Ico (hab : a \u2264 b) (hf : MonotoneOn f (Set.Icc a b)) :\n    (\u222b x in a..b, f x) \u2264 \u2211 i in Finset.Ico a b, f (i + 1 : \u2115)", "start": [171, 1], "end": [174, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SuccPred/IntervalSucc.lean", "imports": ["Mathlib/Order/SuccPred/Basic.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Monotone.biUnion_Ico_Ioc_map_succ", "code": "theorem biUnion_Ico_Ioc_map_succ [SuccOrder \u03b1] [IsSuccArchimedean \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Monotone f) (m n : \u03b1) : \u22c3 i \u2208 Ico m n, Ioc (f i) (f (succ i)) = Ioc (f m) (f n)", "start": [34, 1], "end": [47, 74], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ioc_succ", "code": "theorem pairwise_disjoint_on_Ioc_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioc (f n) (f (succ n)))", "start": [50, 1], "end": [56, 55], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ico_succ", "code": "theorem pairwise_disjoint_on_Ico_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ico (f n) (f (succ n)))", "start": [59, 1], "end": [65, 54], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ioo_succ", "code": "theorem pairwise_disjoint_on_Ioo_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioo (f n) (f (succ n)))", "start": [68, 1], "end": [72, 100], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ioc_pred", "code": "theorem pairwise_disjoint_on_Ioc_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioc (f (pred n)) (f n))", "start": [75, 1], "end": [79, 77], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ico_pred", "code": "theorem pairwise_disjoint_on_Ico_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ico (f (pred n)) (f n))", "start": [82, 1], "end": [86, 77], "kind": "commanddeclaration"}, {"full_name": "Monotone.pairwise_disjoint_on_Ioo_pred", "code": "theorem pairwise_disjoint_on_Ioo_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Pairwise (Disjoint on fun n => Ioo (f (pred n)) (f n))", "start": [89, 1], "end": [93, 77], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ioc_succ", "code": "theorem pairwise_disjoint_on_Ioc_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioc (f (succ n)) (f n))", "start": [100, 1], "end": [104, 45], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ico_succ", "code": "theorem pairwise_disjoint_on_Ico_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ico (f (succ n)) (f n))", "start": [107, 1], "end": [111, 45], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ioo_succ", "code": "theorem pairwise_disjoint_on_Ioo_succ [SuccOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioo (f (succ n)) (f n))", "start": [114, 1], "end": [118, 45], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ioc_pred", "code": "theorem pairwise_disjoint_on_Ioc_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioc (f n) (f (pred n)))", "start": [121, 1], "end": [125, 45], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ico_pred", "code": "theorem pairwise_disjoint_on_Ico_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ico (f n) (f (pred n)))", "start": [128, 1], "end": [132, 45], "kind": "commanddeclaration"}, {"full_name": "Antitone.pairwise_disjoint_on_Ioo_pred", "code": "theorem pairwise_disjoint_on_Ioo_pred [PredOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Pairwise (Disjoint on fun n => Ioo (f n) (f (pred n)))", "start": [135, 1], "end": [139, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/CofilteredLimit.lean", "imports": ["Mathlib/Topology/Category/TopCat/Limits/Konig.lean", "Mathlib/Topology/LocallyConstant/Basic.lean", "Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/Topology/DiscreteQuotient.lean"], "premises": [{"full_name": "Profinite.exists_clopen_of_cofiltered", "code": "theorem exists_clopen_of_cofiltered {U : Set C.pt} (hC : IsLimit C) (hU : IsClopen U) :\n    \u2203 (j : J) (V : Set (F.obj j)) (_ : IsClopen V), U = C.\u03c0.app j \u207b\u00b9' V", "start": [43, 1], "end": [114, 97], "kind": "commanddeclaration"}, {"full_name": "Profinite.exists_locallyConstant_fin_two", "code": "theorem exists_locallyConstant_fin_two (hC : IsLimit C) (f : LocallyConstant C.pt (Fin 2)) :\n    \u2203 (j : J) (g : LocallyConstant (F.obj j) (Fin 2)), f = g.comap (C.\u03c0.app _)", "start": [118, 1], "end": [129, 52], "kind": "commanddeclaration"}, {"full_name": "Profinite.exists_locallyConstant_finite_aux", "code": "theorem exists_locallyConstant_finite_aux {\u03b1 : Type*} [Finite \u03b1] (hC : IsLimit C)\n    (f : LocallyConstant C.pt \u03b1) : \u2203 (j : J) (g : LocallyConstant (F.obj j) (\u03b1 \u2192 Fin 2)),\n      (f.map fun a b => if a = b then (0 : Fin 2) else 1) = g.comap (C.\u03c0.app _)", "start": [133, 1], "end": [176, 31], "kind": "commanddeclaration"}, {"full_name": "Profinite.exists_locallyConstant_finite_nonempty", "code": "theorem exists_locallyConstant_finite_nonempty {\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]\n    (hC : IsLimit C) (f : LocallyConstant C.pt \u03b1) :\n    \u2203 (j : J) (g : LocallyConstant (F.obj j) \u03b1), f = g.comap (C.\u03c0.app _)", "start": [180, 1], "end": [209, 40], "kind": "commanddeclaration"}, {"full_name": "Profinite.exists_locallyConstant", "code": "theorem exists_locallyConstant {\u03b1 : Type*} (hC : IsLimit C) (f : LocallyConstant C.pt \u03b1) :\n    \u2203 (j : J) (g : LocallyConstant (F.obj j) \u03b1), f = g.comap (C.\u03c0.app _)", "start": [213, 1], "end": [252, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Tactic.lean", "imports": ["Mathlib/Tactic/Measurability.lean", "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Rbmap/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/RingTheory/DedekindDomain/SelmerGroup.lean", "imports": ["Mathlib/RingTheory/Norm.lean", "Mathlib/Algebra/Hom/Equiv/TypeTags.lean", "Mathlib/Data/ZMod/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean"], "premises": [{"full_name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun", "code": "def valuationOfNeZeroToFun (x : K\u02e3) : Multiplicative \u2124 :=\n  let hx := IsLocalization.sec R\u2070 (x : K)\n  Multiplicative.ofAdd <|\n    (-(Associates.mk v.asIdeal).count (Associates.mk <| Ideal.span {hx.fst}).factors : \u2124) -\n      (-(Associates.mk v.asIdeal).count (Associates.mk <| Ideal.span {(hx.snd : R)}).factors : \u2124)", "start": [85, 1], "end": [90, 98], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroToFun_eq", "code": "@[simp]\ntheorem valuationOfNeZeroToFun_eq (x : K\u02e3) :\n    (v.valuationOfNeZeroToFun x : \u2124\u2098\u2080) = v.valuation (x : K)", "start": [93, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZero", "code": "def valuationOfNeZero : K\u02e3 \u2192* Multiplicative \u2124 where\n  toFun := v.valuationOfNeZeroToFun\n  map_one' := by rw [\u2190 WithZero.coe_inj, valuationOfNeZeroToFun_eq]; exact map_one _\n  map_mul' _ _ := by\n    rw [\u2190 WithZero.coe_inj, WithZero.coe_mul]\n    simp only [valuationOfNeZeroToFun_eq]; exact map_mul _ _ _", "start": [105, 1], "end": [111, 63], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZero_eq", "code": "@[simp]\ntheorem valuationOfNeZero_eq (x : K\u02e3) : (v.valuationOfNeZero x : \u2124\u2098\u2080) = v.valuation (x : K)", "start": [114, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_eq", "code": "@[simp]\ntheorem valuation_of_unit_eq (x : R\u02e3) :\n    v.valuationOfNeZero (Units.map (algebraMap R K : R \u2192* K) x) = 1", "start": [119, 1], "end": [131, 35], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuationOfNeZeroMod", "code": "def valuationOfNeZeroMod (n : \u2115) : (K/n) \u2192* Multiplicative (ZMod n) :=\n  (Int.quotientZmultiplesNatEquivZMod n).toMultiplicative.toMonoidHom.comp <|\n    QuotientGroup.map (powMonoidHom n : K\u02e3 \u2192* K\u02e3).range\n      (AddSubgroup.toSubgroup (AddSubgroup.zmultiples (n : \u2124)))\n      v.valuationOfNeZero\n      (by\n        rintro _ \u27e8x, rfl\u27e9\n        exact\n          \u27e8v.valuationOfNeZero x, by simp only [powMonoidHom_apply, map_pow, Int.toAdd_pow]; rfl\u27e9)", "start": [137, 1], "end": [146, 99], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_of_unit_mod_eq", "code": "@[simp]\ntheorem valuation_of_unit_mod_eq (n : \u2115) (x : R\u02e3) :\n    v.valuationOfNeZeroMod n (Units.map (algebraMap R K : R \u2192* K) x : K/n) = 1", "start": [149, 1], "end": [155, 57], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup", "code": "def selmerGroup : Subgroup <| K/n where\n  carrier := {x : K/n | \u2200 (v) (_ : v \u2209 S), (v : HeightOneSpectrum R).valuationOfNeZeroMod n x = 1}\n  one_mem' _ _ := by rw [map_one]\n  mul_mem' hx hy v hv := by rw [map_mul, hx v hv, hy v hv, one_mul]\n  inv_mem' hx v hv := by rw [map_inv, hx v hv, inv_one]", "start": [165, 1], "end": [170, 56], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.monotone", "code": "theorem monotone (hS : S \u2264 S') : K\u27eeS,n\u27ef \u2264 K\u27eeS',n\u27ef", "start": [178, 1], "end": [178, 85], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.valuation", "code": "def valuation : K\u27eeS,n\u27ef \u2192* S \u2192 Multiplicative (ZMod n) where\n  toFun x v := (v : HeightOneSpectrum R).valuationOfNeZeroMod n (x : K/n)\n  map_one' := funext fun v => map_one _\n  map_mul' x y := by simp only [Submonoid.coe_mul, Subgroup.coe_toSubmonoid, map_mul]; rfl", "start": [181, 1], "end": [185, 91], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.valuation_ker_eq", "code": "theorem valuation_ker_eq :\n    valuation.ker = K\u27ee(\u2205 : Set <| HeightOneSpectrum R),n\u27ef.subgroupOf (K\u27eeS,n\u27ef)", "start": [188, 1], "end": [196, 66], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.fromUnit", "code": "def fromUnit {n : \u2115} : R\u02e3 \u2192* K\u27ee(\u2205 : Set <| HeightOneSpectrum R),n\u27ef where\n  toFun x :=\n    \u27e8QuotientGroup.mk <| Units.map (algebraMap R K).toMonoidHom x, fun v _ =>\n      v.valuation_of_unit_mod_eq n x\u27e9\n  map_one' := by simp only [map_one, QuotientGroup.mk_one, Subgroup.mk_eq_one_iff]\n  map_mul' _ _ := by simp only [RingHom.toMonoidHom_eq_coe, map_mul, MonoidHom.mem_range,\n    powMonoidHom_apply, QuotientGroup.mk_mul, Submonoid.mk_mul_mk]", "start": [199, 1], "end": [206, 67], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.fromUnit_ker", "code": "theorem fromUnit_ker [hn : Fact <| 0 < n] :\n    (@fromUnit R _ _ _ K _ _ _ n).ker = (powMonoidHom n : R\u02e3 \u2192* R\u02e3).range", "start": [209, 1], "end": [234, 78], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.fromUnitLift", "code": "def fromUnitLift [Fact <| 0 < n] : (R/n) \u2192* K\u27ee(\u2205 : Set <| HeightOneSpectrum R),n\u27ef :=\n  (QuotientGroup.kerLift _).comp\n    (QuotientGroup.quotientMulEquivOfEq (fromUnit_ker (R := R))).symm.toMonoidHom", "start": [237, 1], "end": [240, 82], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.selmerGroup.fromUnitLift_injective", "code": "theorem fromUnitLift_injective [Fact <| 0 < n] :\n    Function.Injective <| @fromUnitLift R _ _ _ K _ _ _ n _", "start": [243, 1], "end": [246, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/Discriminant.lean", "imports": ["Mathlib/NumberTheory/NumberField/Basic.lean", "Mathlib/RingTheory/Localization/NormTrace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NumberField.discr", "code": "noncomputable abbrev discr : \u2124 := Algebra.discr \u2124 (RingOfIntegers.basis K)", "start": [29, 1], "end": [30, 75], "kind": "commanddeclaration"}, {"full_name": "NumberField.coe_discr", "code": "theorem coe_discr : (discr K : \u211a) = Algebra.discr \u211a (integralBasis K)", "start": [32, 1], "end": [33, 79], "kind": "commanddeclaration"}, {"full_name": "NumberField.discr_ne_zero", "code": "theorem discr_ne_zero : discr K \u2260 0", "start": [35, 1], "end": [37, 60], "kind": "commanddeclaration"}, {"full_name": "NumberField.discr_eq_discr", "code": "theorem discr_eq_discr {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 (\ud835\udcde K)) :\n    Algebra.discr \u2124 b = discr K", "start": [39, 1], "end": [42, 83], "kind": "commanddeclaration"}, {"full_name": "Rat.numberField_discr", "code": "@[simp]\ntheorem numberField_discr : discr \u211a = 1", "start": [50, 1], "end": [64, 63], "kind": "commanddeclaration"}, {"full_name": "NumberField.discr_rat", "code": "alias _root_.NumberField.discr_rat := numberField_discr", "start": [66, 1], "end": [66, 56], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/NumberTheory/Pell.lean", "imports": ["Mathlib/Tactic/Qify.lean", "Mathlib/NumberTheory/Zsqrtd/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/DiophantineApproximation.lean"], "premises": [{"full_name": "Pell.is_pell_solution_iff_mem_unitary", "code": "theorem is_pell_solution_iff_mem_unitary {d : \u2124} {a : \u2124\u221ad} :\n    a.re ^ 2 - d * a.im ^ 2 = 1 \u2194 a \u2208 unitary (\u2124\u221ad)", "start": [79, 1], "end": [85, 68], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081", "code": "def Solution\u2081 (d : \u2124) : Type :=\n  \u21a5(unitary (\u2124\u221ad))", "start": [90, 1], "end": [94, 19], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.instCommGroup", "code": "instance instCommGroup : CommGroup (Solution\u2081 d) :=\n  inferInstanceAs (CommGroup (unitary (\u2124\u221ad)))", "start": [103, 1], "end": [104, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.instHasDistribNeg", "code": "instance instHasDistribNeg : HasDistribNeg (Solution\u2081 d) :=\n  inferInstanceAs (HasDistribNeg (unitary (\u2124\u221ad)))", "start": [107, 1], "end": [108, 50], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.instInhabited", "code": "instance instInhabited : Inhabited (Solution\u2081 d) :=\n  inferInstanceAs (Inhabited (unitary (\u2124\u221ad)))", "start": [111, 1], "end": [112, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x", "code": "protected def x (a : Solution\u2081 d) : \u2124 :=\n  (a : \u2124\u221ad).re", "start": [117, 1], "end": [119, 15], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y", "code": "protected def y (a : Solution\u2081 d) : \u2124 :=\n  (a : \u2124\u221ad).im", "start": [122, 1], "end": [124, 15], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.prop", "code": "theorem prop (a : Solution\u2081 d) : a.x ^ 2 - d * a.y ^ 2 = 1", "start": [127, 1], "end": [129, 50], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.prop_x", "code": "theorem prop_x (a : Solution\u2081 d) : a.x ^ 2 = 1 + d * a.y ^ 2", "start": [132, 1], "end": [133, 87], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.prop_y", "code": "theorem prop_y (a : Solution\u2081 d) : d * a.y ^ 2 = a.x ^ 2 - 1", "start": [136, 1], "end": [137, 87], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.ext", "code": "@[ext]\ntheorem ext {a b : Solution\u2081 d} (hx : a.x = b.x) (hy : a.y = b.y) : a = b", "start": [140, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.mk", "code": "def mk (x y : \u2124) (prop : x ^ 2 - d * y ^ 2 = 1) : Solution\u2081 d where\n  val := \u27e8x, y\u27e9\n  property := is_pell_solution_iff_mem_unitary.mp prop", "start": [146, 1], "end": [149, 55], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_mk", "code": "@[simp]\ntheorem x_mk (x y : \u2124) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).x = x", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_mk", "code": "@[simp]\ntheorem y_mk (x y : \u2124) (prop : x ^ 2 - d * y ^ 2 = 1) : (mk x y prop).y = y", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.coe_mk", "code": "@[simp]\ntheorem coe_mk (x y : \u2124) (prop : x ^ 2 - d * y ^ 2 = 1) : (\u2191(mk x y prop) : \u2124\u221ad) = \u27e8x, y\u27e9", "start": [162, 1], "end": [164, 48], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_one", "code": "@[simp]\ntheorem x_one : (1 : Solution\u2081 d).x = 1", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_one", "code": "@[simp]\ntheorem y_one : (1 : Solution\u2081 d).y = 0", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_mul", "code": "@[simp]\ntheorem x_mul (a b : Solution\u2081 d) : (a * b).x = a.x * b.x + d * (a.y * b.y)", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_mul", "code": "@[simp]\ntheorem y_mul (a b : Solution\u2081 d) : (a * b).y = a.x * b.y + a.y * b.x", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_inv", "code": "@[simp]\ntheorem x_inv (a : Solution\u2081 d) : a\u207b\u00b9.x = a.x", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_inv", "code": "@[simp]\ntheorem y_inv (a : Solution\u2081 d) : a\u207b\u00b9.y = -a.y", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_neg", "code": "@[simp]\ntheorem x_neg (a : Solution\u2081 d) : (-a).x = -a.x", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_neg", "code": "@[simp]\ntheorem y_neg (a : Solution\u2081 d) : (-a).y = -a.y", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.eq_zero_of_d_neg", "code": "theorem eq_zero_of_d_neg (h\u2080 : d < 0) (a : Solution\u2081 d) : a.x = 0 \u2228 a.y = 0", "start": [208, 1], "end": [216, 12], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_ne_zero", "code": "theorem x_ne_zero (h\u2080 : 0 \u2264 d) (a : Solution\u2081 d) : a.x \u2260 0", "start": [219, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_ne_zero_of_one_lt_x", "code": "theorem y_ne_zero_of_one_lt_x {a : Solution\u2081 d} (ha : 1 < a.x) : a.y \u2260 0", "start": [227, 1], "end": [232, 88], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.d_pos_of_one_lt_x", "code": "theorem d_pos_of_one_lt_x {a : Solution\u2081 d} (ha : 1 < a.x) : 0 < d", "start": [235, 1], "end": [239, 34], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.d_nonsquare_of_one_lt_x", "code": "theorem d_nonsquare_of_one_lt_x {a : Solution\u2081 d} (ha : 1 < a.x) : \u00acIsSquare d", "start": [242, 1], "end": [247, 71], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.eq_one_of_x_eq_one", "code": "theorem eq_one_of_x_eq_one (h\u2080 : d \u2260 0) {a : Solution\u2081 d} (ha : a.x = 1) : a = 1", "start": [250, 1], "end": [254, 20], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.eq_one_or_neg_one_iff_y_eq_zero", "code": "theorem eq_one_or_neg_one_iff_y_eq_zero {a : Solution\u2081 d} : a = 1 \u2228 a = -1 \u2194 a.y = 0", "start": [257, 1], "end": [262, 53], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_mul_pos", "code": "theorem x_mul_pos {a b : Solution\u2081 d} (ha : 0 < a.x) (hb : 0 < b.x) : 0 < (a * b).x", "start": [265, 1], "end": [279, 9], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_mul_pos", "code": "theorem y_mul_pos {a b : Solution\u2081 d} (hax : 0 < a.x) (hay : 0 < a.y) (hbx : 0 < b.x)\n    (hby : 0 < b.y) : 0 < (a * b).y", "start": [282, 1], "end": [286, 13], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_pow_pos", "code": "theorem x_pow_pos {a : Solution\u2081 d} (hax : 0 < a.x) (n : \u2115) : 0 < (a ^ n).x", "start": [289, 1], "end": [295, 27], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_pow_succ_pos", "code": "theorem y_pow_succ_pos {a : Solution\u2081 d} (hax : 0 < a.x) (hay : 0 < a.y) (n : \u2115) :\n    0 < (a ^ n.succ).y", "start": [298, 1], "end": [305, 49], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.y_zpow_pos", "code": "theorem y_zpow_pos {a : Solution\u2081 d} (hax : 0 < a.x) (hay : 0 < a.y) {n : \u2124} (hn : 0 < n) :\n    0 < (a ^ n).y", "start": [308, 1], "end": [315, 33], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.x_zpow_pos", "code": "theorem x_zpow_pos {a : Solution\u2081 d} (hax : 0 < a.x) (n : \u2124) : 0 < (a ^ n).x", "start": [318, 1], "end": [326, 32], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.sign_y_zpow_eq_sign_of_x_pos_of_y_pos", "code": "theorem sign_y_zpow_eq_sign_of_x_pos_of_y_pos {a : Solution\u2081 d} (hax : 0 < a.x) (hay : 0 < a.y)\n    (n : \u2124) : (a ^ n).y.sign = n.sign", "start": [329, 1], "end": [338, 81], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.exists_pos_variant", "code": "theorem exists_pos_variant (h\u2080 : 0 < d) (a : Solution\u2081 d) :\n    \u2203 b : Solution\u2081 d, 0 < b.x \u2227 0 \u2264 b.y \u2227 a \u2208 ({b, b\u207b\u00b9, -b, -b\u207b\u00b9} : Set (Solution\u2081 d))", "start": [341, 1], "end": [351, 15], "kind": "commanddeclaration"}, {"full_name": "Pell.exists_of_not_isSquare", "code": "theorem exists_of_not_isSquare (h\u2080 : 0 < d) (hd : \u00acIsSquare d) :\n    \u2203 x y : \u2124, x ^ 2 - d * y ^ 2 = 1 \u2227 y \u2260 0", "start": [367, 1], "end": [436, 72], "kind": "commanddeclaration"}, {"full_name": "Pell.exists_iff_not_isSquare", "code": "theorem exists_iff_not_isSquare (h\u2080 : 0 < d) :\n    (\u2203 x y : \u2124, x ^ 2 - d * y ^ 2 = 1 \u2227 y \u2260 0) \u2194 \u00acIsSquare d", "start": [439, 1], "end": [446, 97], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.exists_nontrivial_of_not_isSquare", "code": "theorem exists_nontrivial_of_not_isSquare (h\u2080 : 0 < d) (hd : \u00acIsSquare d) :\n    \u2203 a : Solution\u2081 d, a \u2260 1 \u2227 a \u2260 -1", "start": [451, 1], "end": [457, 19], "kind": "commanddeclaration"}, {"full_name": "Pell.Solution\u2081.exists_pos_of_not_isSquare", "code": "theorem exists_pos_of_not_isSquare (h\u2080 : 0 < d) (hd : \u00acIsSquare d) :\n    \u2203 a : Solution\u2081 d, 1 < a.x \u2227 0 < a.y", "start": [460, 1], "end": [467, 44], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental", "code": "def IsFundamental (a : Solution\u2081 d) : Prop :=\n  1 < a.x \u2227 0 < a.y \u2227 \u2200 {b : Solution\u2081 d}, 1 < b.x \u2192 a.x \u2264 b.x", "start": [484, 1], "end": [487, 63], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.x_pos", "code": "theorem x_pos {a : Solution\u2081 d} (h : IsFundamental a) : 0 < a.x", "start": [494, 1], "end": [496, 24], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.d_pos", "code": "theorem d_pos {a : Solution\u2081 d} (h : IsFundamental a) : 0 < d", "start": [499, 1], "end": [501, 24], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.d_nonsquare", "code": "theorem d_nonsquare {a : Solution\u2081 d} (h : IsFundamental a) : \u00acIsSquare d", "start": [504, 1], "end": [506, 30], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.subsingleton", "code": "theorem subsingleton {a b : Solution\u2081 d} (ha : IsFundamental a) (hb : IsFundamental b) : a = b", "start": [509, 1], "end": [514, 88], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.exists_of_not_isSquare", "code": "theorem exists_of_not_isSquare (h\u2080 : 0 < d) (hd : \u00acIsSquare d) :\n    \u2203 a : Solution\u2081 d, IsFundamental a", "start": [517, 1], "end": [539, 15], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.y_strictMono", "code": "theorem y_strictMono {a : Solution\u2081 d} (h : IsFundamental a) :\n    StrictMono fun n : \u2124 => (a ^ n).y", "start": [542, 1], "end": [562, 33], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.zpow_y_lt_iff_lt", "code": "theorem zpow_y_lt_iff_lt {a : Solution\u2081 d} (h : IsFundamental a) (m n : \u2124) :\n    (a ^ m).y < (a ^ n).y \u2194 m < n", "start": [565, 1], "end": [570, 34], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.zpow_eq_one_iff", "code": "theorem zpow_eq_one_iff {a : Solution\u2081 d} (h : IsFundamental a) (n : \u2124) : a ^ n = 1 \u2194 n = 0", "start": [573, 1], "end": [576, 88], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.zpow_ne_neg_zpow", "code": "theorem zpow_ne_neg_zpow {a : Solution\u2081 d} (h : IsFundamental a) {n n' : \u2124} : a ^ n \u2260 -a ^ n'", "start": [579, 1], "end": [586, 54], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.x_le_x", "code": "theorem x_le_x {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 1 < a.x) :\n    a\u2081.x \u2264 a.x", "start": [589, 1], "end": [593, 12], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.y_le_y", "code": "theorem y_le_y {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : a\u2081.y \u2264 a.y", "start": [596, 1], "end": [604, 21], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.x_mul_y_le_y_mul_x", "code": "theorem x_mul_y_le_y_mul_x {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d}\n    (hax : 1 < a.x) (hay : 0 < a.y) : a.x * a\u2081.y \u2264 a.y * a\u2081.x", "start": [608, 1], "end": [615, 25], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.mul_inv_y_nonneg", "code": "theorem mul_inv_y_nonneg {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : 0 \u2264 (a * a\u2081\u207b\u00b9).y", "start": [618, 1], "end": [623, 33], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.mul_inv_x_pos", "code": "theorem mul_inv_x_pos {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : 0 < (a * a\u2081\u207b\u00b9).x", "start": [626, 1], "end": [636, 30], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.mul_inv_x_lt_x", "code": "theorem mul_inv_x_lt_x {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 1 < a.x)\n    (hay : 0 < a.y) : (a * a\u2081\u207b\u00b9).x < a.x", "start": [639, 1], "end": [659, 83], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.eq_pow_of_nonneg", "code": "theorem eq_pow_of_nonneg {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) {a : Solution\u2081 d} (hax : 0 < a.x)\n    (hay : 0 \u2264 a.y) : \u2203 n : \u2115, a = a\u2081 ^ n", "start": [662, 1], "end": [689, 90], "kind": "commanddeclaration"}, {"full_name": "Pell.IsFundamental.eq_zpow_or_neg_zpow", "code": "theorem eq_zpow_or_neg_zpow {a\u2081 : Solution\u2081 d} (h : IsFundamental a\u2081) (a : Solution\u2081 d) :\n    \u2203 n : \u2124, a = a\u2081 ^ n \u2228 a = -a\u2081 ^ n", "start": [692, 1], "end": [703, 38], "kind": "commanddeclaration"}, {"full_name": "Pell.existsUnique_pos_generator", "code": "theorem existsUnique_pos_generator (h\u2080 : 0 < d) (hd : \u00acIsSquare d) :\n    \u2203! a\u2081 : Solution\u2081 d,\n      1 < a\u2081.x \u2227 0 < a\u2081.y \u2227 \u2200 a : Solution\u2081 d, \u2203 n : \u2124, a = a\u2081 ^ n \u2228 a = -a\u2081 ^ n", "start": [710, 1], "end": [735, 21], "kind": "commanddeclaration"}, {"full_name": "Pell.pos_generator_iff_fundamental", "code": "theorem pos_generator_iff_fundamental (a : Solution\u2081 d) :\n    (1 < a.x \u2227 0 < a.y \u2227 \u2200 b : Solution\u2081 d, \u2203 n : \u2124, b = a ^ n \u2228 b = -a ^ n) \u2194 IsFundamental a", "start": [738, 1], "end": [747, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/Ideal.lean", "imports": ["Mathlib/CategoryTheory/Subterminal.lean", "Mathlib/CategoryTheory/Monad/Limits.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Adjunction/Reflective.lean", "Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean", "Mathlib/CategoryTheory/Closed/Cartesian.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Adjunction/FullyFaithful.lean"], "premises": [{"full_name": "CategoryTheory.ExponentialIdeal", "code": "class ExponentialIdeal : Prop where\n  exp_closed : \u2200 {B}, B \u2208 i.essImage \u2192 \u2200 A, (A \u27f9 B) \u2208 i.essImage", "start": [45, 1], "end": [49, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ExponentialIdeal.mk'", "code": "theorem ExponentialIdeal.mk' (h : \u2200 (B : D) (A : C), (A \u27f9 i.obj B) \u2208 i.essImage) :\n    ExponentialIdeal i", "start": [53, 1], "end": [60, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exponentialIdealReflective", "code": "def exponentialIdealReflective (A : C) [Reflective i] [ExponentialIdeal i] :\n    i \u22d9 exp A \u22d9 leftAdjoint i \u22d9 i \u2245 i \u22d9 exp A := by\n  symm\n  apply NatIso.ofComponents _ _\n  \u00b7 intro X\n    haveI := Functor.essImage.unit_isIso (ExponentialIdeal.exp_closed (i.obj_mem_essImage X) A)\n    apply asIso ((Adjunction.ofRightAdjoint i).unit.app (A \u27f9 i.obj X))\n  \u00b7 simp [asIso]", "start": [76, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ExponentialIdeal.mk_of_iso", "code": "theorem ExponentialIdeal.mk_of_iso [Reflective i]\n    (h : \u2200 A : C, i \u22d9 exp A \u22d9 leftAdjoint i \u22d9 i \u2245 i \u22d9 exp A) : ExponentialIdeal i", "start": [91, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflective_products", "code": "theorem reflective_products [HasFiniteProducts C] [Reflective i] : HasFiniteProducts D", "start": [112, 1], "end": [113, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exponentialIdeal_of_preservesBinaryProducts", "code": "instance (priority := 10) exponentialIdeal_of_preservesBinaryProducts\n    [PreservesLimitsOfShape (Discrete WalkingPair) (leftAdjoint i)] : ExponentialIdeal i := by\n  let ir := Adjunction.ofRightAdjoint i\n  let L : C \u2964 D := leftAdjoint i\n  let \u03b7 : \ud835\udfed C \u27f6 L \u22d9 i := ir.unit\n  let \u03b5 : i \u22d9 L \u27f6 \ud835\udfed D := ir.counit\n  apply ExponentialIdeal.mk'\n  intro B A\n  let q : i.obj (L.obj (A \u27f9 i.obj B)) \u27f6 A \u27f9 i.obj B\n  apply CartesianClosed.curry (ir.homEquiv _ _ _)\n  apply _ \u226b (ir.homEquiv _ _).symm ((exp.ev A).app (i.obj B))\n  refine' prodComparison L A _ \u226b Limits.prod.map (\ud835\udfd9 _) (\u03b5.app _) \u226b inv (prodComparison _ _ _)\n  have : \u03b7.app (A \u27f9 i.obj B) \u226b q = \ud835\udfd9 (A \u27f9 i.obj B) := by\n    dsimp\n    rw [\u2190 curry_natural_left, curry_eq_iff, uncurry_id_eq_ev, \u2190 ir.homEquiv_naturality_left,\n      ir.homEquiv_apply_eq, assoc, assoc, prodComparison_natural_assoc, L.map_id,\n      \u2190 prod.map_id_comp_assoc, ir.left_triangle_components, prod.map_id_id, id_comp]\n    apply IsIso.hom_inv_id_assoc\n  haveI : IsSplitMono (\u03b7.app (A \u27f9 i.obj B)) := IsSplitMono.mk' \u27e8_, this\u27e9\n  apply mem_essImage_of_unit_isSplitMono", "start": [121, 1], "end": [143, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cartesianClosedOfReflective", "code": "def cartesianClosedOfReflective : CartesianClosed D :=\n  { monoidalOfHasFiniteProducts D with closed := fun B =>\n      { isAdj :=\n          { right := i \u22d9 exp (i.obj B) \u22d9 leftAdjoint i\n            adj := by\n              apply Adjunction.restrictFullyFaithful i i (exp.adjunction (i.obj B))\n              \u00b7 symm\n                refine' NatIso.ofComponents (fun X => _) (fun f => _)\n                \u00b7 haveI :=\n                    Adjunction.rightAdjointPreservesLimits.{0, 0} (Adjunction.ofRightAdjoint i)\n                  apply asIso (prodComparison i B X)\n                \u00b7 dsimp [asIso]\n                  rw [prodComparison_natural, Functor.map_id]\n              \u00b7 apply (exponentialIdealReflective i _).symm } } }", "start": [148, 1], "end": [165, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.bijection", "code": "noncomputable def bijection (A B : C) (X : D) :\n    ((leftAdjoint i).obj (A \u2a2f B) \u27f6 X) \u2243 ((leftAdjoint i).obj A \u2a2f (leftAdjoint i).obj B \u27f6 X) :=\n  calc\n    _ \u2243 (A \u2a2f B \u27f6 i.obj X) := (Adjunction.ofRightAdjoint i).homEquiv _ _\n    _ \u2243 (B \u2a2f A \u27f6 i.obj X) := ((Limits.prod.braiding _ _).homCongr (Iso.refl _))\n    _ \u2243 (A \u27f6 B \u27f9 i.obj X) := ((exp.adjunction _).homEquiv _ _)\n    _ \u2243 (i.obj ((leftAdjoint i).obj A) \u27f6 B \u27f9 i.obj X) :=\n      (unitCompPartialBijective _ (ExponentialIdeal.exp_closed (i.obj_mem_essImage _) _))\n    _ \u2243 (B \u2a2f i.obj ((leftAdjoint i).obj A) \u27f6 i.obj X) := ((exp.adjunction _).homEquiv _ _).symm\n    _ \u2243 (i.obj ((leftAdjoint i).obj A) \u2a2f B \u27f6 i.obj X) :=\n      ((Limits.prod.braiding _ _).homCongr (Iso.refl _))\n    _ \u2243 (B \u27f6 i.obj ((leftAdjoint i).obj A) \u27f9 i.obj X) := ((exp.adjunction _).homEquiv _ _)\n    _ \u2243 (i.obj ((leftAdjoint i).obj B) \u27f6 i.obj ((leftAdjoint i).obj A) \u27f9 i.obj X) :=\n      (unitCompPartialBijective _ (ExponentialIdeal.exp_closed (i.obj_mem_essImage _) _))\n    _ \u2243 (i.obj ((leftAdjoint i).obj A) \u2a2f i.obj ((leftAdjoint i).obj B) \u27f6 i.obj X) :=\n      ((exp.adjunction _).homEquiv _ _).symm\n    _ \u2243 (i.obj ((leftAdjoint i).obj A \u2a2f (leftAdjoint i).obj B) \u27f6 i.obj X) :=\n      haveI : PreservesLimits i := (Adjunction.ofRightAdjoint i).rightAdjointPreservesLimits\n      haveI := preservesSmallestLimitsOfPreservesLimits i\n      Iso.homCongr (PreservesLimitPair.iso _ _ _).symm (Iso.refl (i.obj X))\n    _ \u2243 ((leftAdjoint i).obj A \u2a2f (leftAdjoint i).obj B \u27f6 X) := (equivOfFullyFaithful _).symm", "start": [172, 1], "end": [201, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.bijection_symm_apply_id", "code": "theorem bijection_symm_apply_id (A B : C) :\n    (bijection i A B _).symm (\ud835\udfd9 _) = prodComparison _ _ _", "start": [204, 1], "end": [225, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.bijection_natural", "code": "theorem bijection_natural (A B : C) (X X' : D) (f : (leftAdjoint i).obj (A \u2a2f B) \u27f6 X) (g : X \u27f6 X') :\n    bijection i _ _ _ (f \u226b g) = bijection i _ _ _ f \u226b g", "start": [228, 1], "end": [238, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodComparison_iso", "code": "theorem prodComparison_iso (A B : C) : IsIso (prodComparison (leftAdjoint i) A B)", "start": [241, 1], "end": [249, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesBinaryProductsOfExponentialIdeal", "code": "noncomputable def preservesBinaryProductsOfExponentialIdeal :\n    PreservesLimitsOfShape (Discrete WalkingPair) (leftAdjoint i) where\n  preservesLimit {K} :=\n    letI := PreservesLimitPair.ofIsoProdComparison\n      (leftAdjoint i) (K.obj \u27e8WalkingPair.left\u27e9) (K.obj \u27e8WalkingPair.right\u27e9)\n    Limits.preservesLimitOfIsoDiagram _ (diagramIsoPair K).symm", "start": [254, 1], "end": [263, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesFiniteProductsOfExponentialIdeal", "code": "noncomputable def preservesFiniteProductsOfExponentialIdeal (J : Type) [Fintype J] :\n    PreservesLimitsOfShape (Discrete J) (leftAdjoint i) := by\n  letI := preservesBinaryProductsOfExponentialIdeal i\n  letI := leftAdjointPreservesTerminalOfReflective.{0} i\n  apply preservesFiniteProductsOfPreservesBinaryAndTerminal (leftAdjoint i) J", "start": [266, 1], "end": [273, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Hom/Open.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousOpenMap", "code": "structure ContinuousOpenMap (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] extends\n  ContinuousMap \u03b1 \u03b2 where\n  map_open' : IsOpenMap toFun", "start": [32, 1], "end": [35, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMapClass", "code": "class ContinuousOpenMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1]\n  [TopologicalSpace \u03b2] extends ContinuousMapClass F \u03b1 \u03b2 where\n  map_open (f : F) : IsOpenMap f", "start": [42, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : \u03b1 \u2192CO \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [74, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.coe_toContinuousMap", "code": "@[simp] theorem coe_toContinuousMap (f : \u03b1 \u2192CO \u03b2) : (f.toContinuousMap : \u03b1 \u2192 \u03b2) = f", "start": [78, 1], "end": [79, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192CO \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [81, 1], "end": [83, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.copy", "code": "protected def copy (f : \u03b1 \u2192CO \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192CO \u03b2 :=\n  \u27e8f.toContinuousMap.copy f' <| h, h.symm.subst f.map_open'\u27e9", "start": [86, 1], "end": [89, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192CO \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192CO \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [97, 1], "end": [98, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.id", "code": "protected def id : \u03b1 \u2192CO \u03b1 :=\n  \u27e8ContinuousMap.id _, IsOpenMap.id\u27e9", "start": [103, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(ContinuousOpenMap.id \u03b1) = id", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : ContinuousOpenMap.id \u03b1 a = a", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.comp", "code": "def comp (f : \u03b2 \u2192CO \u03b3) (g : \u03b1 \u2192CO \u03b2) : ContinuousOpenMap \u03b1 \u03b3 :=\n  \u27e8f.toContinuousMap.comp g.toContinuousMap, f.map_open'.comp g.map_open'\u27e9", "start": [123, 1], "end": [125, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : \u03b2 \u2192CO \u03b3) (g : \u03b1 \u2192CO \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : \u03b2 \u2192CO \u03b3) (g : \u03b1 \u2192CO \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : \u03b3 \u2192CO \u03b4) (g : \u03b2 \u2192CO \u03b3) (h : \u03b1 \u2192CO \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [138, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192CO \u03b2) : f.comp (ContinuousOpenMap.id \u03b1) = f", "start": [144, 1], "end": [146, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192CO \u03b2) : (ContinuousOpenMap.id \u03b2).comp f = f", "start": [149, 1], "end": [151, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192CO \u03b3} {f : \u03b1 \u2192CO \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [154, 1], "end": [157, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousOpenMap.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192CO \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192CO \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [160, 1], "end": [163, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Additive/RuzsaCovering.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.exists_subset_mul_div", "code": "@[to_additive \"**Ruzsa's covering lemma**\"]\ntheorem exists_subset_mul_div (ht : t.Nonempty) :\n    \u2203 u : Finset \u03b1, u.card * t.card \u2264 (s * t).card \u2227 s \u2286 u * t / t", "start": [28, 1], "end": [52, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Tor.lean", "imports": ["Mathlib/CategoryTheory/Functor/LeftDerived.lean", "Mathlib/CategoryTheory/Monoidal/Preadditive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Tor", "code": "@[simps]\ndef Tor (n : \u2115) : C \u2964 C \u2964 C where\n  obj X := Functor.leftDerived ((tensoringLeft C).obj X) n\n  map f := NatTrans.leftDerived ((tensoringLeft C).map f) n", "start": [41, 1], "end": [45, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Tor'", "code": "@[simps! obj_obj]\ndef Tor' (n : \u2115) : C \u2964 C \u2964 C :=\n  Functor.flip\n    { obj := fun X => Functor.leftDerived ((tensoringRight C).obj X) n\n      map := fun f => NatTrans.leftDerived ((tensoringRight C).map f) n }", "start": [49, 1], "end": [54, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Tor'_map_app'", "code": "@[simp]\nlemma Tor'_map_app' (n : \u2115) {X Y : C} (f : X \u27f6 Y) (Z : C) :\n    ((Tor' C n).map f).app Z = (Functor.leftDerived ((tensoringRight C).obj Z) n).map f := by\n  rfl", "start": [60, 1], "end": [63, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Tor'_obj_map", "code": "@[simp]\nlemma Tor'_obj_map (n : \u2115) {X Y : C} (Z : C) (f : X \u27f6 Y) :\n    ((Tor' C n).obj Z).map f = (NatTrans.leftDerived ((tensoringRight C).map f) n).app Z := rfl", "start": [67, 1], "end": [69, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.torSuccOfProjective", "code": "def torSuccOfProjective (X Y : C) [Projective Y] (n : \u2115) : ((Tor C (n + 1)).obj X).obj Y \u2245 0 :=\n  ((tensoringLeft C).obj X).leftDerivedObjProjectiveSucc n Y", "start": [73, 1], "end": [75, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.tor'SuccOfProjective", "code": "def tor'SuccOfProjective (X Y : C) [Projective X] (n : \u2115) : ((Tor' C (n + 1)).obj X).obj Y \u2245 0 := by\n  dsimp only [Tor', Functor.flip]\n  exact ((tensoringRight C).obj Y).leftDerivedObjProjectiveSucc n X", "start": [79, 1], "end": [83, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/FunLike/Fintype.lean", "imports": ["Mathlib/Data/Finite/Basic.lean", "Mathlib/Data/FunLike/Basic.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FunLike.fintype", "code": "noncomputable def FunLike.fintype [DecidableEq \u03b1] [Fintype \u03b1] [\u2200 i, Fintype (\u03b2 i)] : Fintype F :=\n  Fintype.ofInjective _ FunLike.coe_injective", "start": [36, 1], "end": [43, 46], "kind": "commanddeclaration"}, {"full_name": "FunLike.fintype'", "code": "noncomputable def FunLike.fintype' [DecidableEq \u03b1] [Fintype \u03b1] [Fintype \u03b3] : Fintype G :=\n  FunLike.fintype G", "start": [46, 1], "end": [52, 20], "kind": "commanddeclaration"}, {"full_name": "FunLike.finite", "code": "theorem FunLike.finite [Finite \u03b1] [\u2200 i, Finite (\u03b2 i)] : Finite F", "start": [62, 1], "end": [67, 46], "kind": "commanddeclaration"}, {"full_name": "FunLike.finite'", "code": "theorem FunLike.finite' [Finite \u03b1] [Finite \u03b3] : Finite G", "start": [70, 1], "end": [76, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Comp.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.Comp", "code": "def Comp (v : TypeVec.{u} m) : Type _ :=\n  F fun i : Fin2 n \u21a6 G i v", "start": [28, 1], "end": [31, 27], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.mk", "code": "protected def mk (x : F fun i \u21a6 G i \u03b1) : Comp F G \u03b1 := x", "start": [42, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.get", "code": "protected def get (x : Comp F G \u03b1) : F fun i \u21a6 G i \u03b1 := x", "start": [46, 1], "end": [47, 58], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.mk_get", "code": "@[simp]\nprotected theorem mk_get (x : Comp F G \u03b1) : Comp.mk (Comp.get x) = x", "start": [50, 1], "end": [51, 76], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.get_mk", "code": "@[simp]\nprotected theorem get_mk (x : F fun i \u21a6 G i \u03b1) : Comp.get (Comp.mk x) = x", "start": [54, 1], "end": [55, 81], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.map'", "code": "protected def map' : (fun i : Fin2 n \u21a6 G i \u03b1) \u27f9 fun i : Fin2 n \u21a6 G i \u03b2 := fun _i \u21a6 map f", "start": [58, 1], "end": [59, 89], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.map", "code": "protected def map : (Comp F G) \u03b1 \u2192 (Comp F G) \u03b2 :=\n  (map fun _i \u21a6 map f : (F fun i \u21a6 G i \u03b1) \u2192 F fun i \u21a6 G i \u03b2)", "start": [62, 1], "end": [64, 61], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.map_mk", "code": "theorem map_mk (x : F fun i \u21a6 G i \u03b1) :\n    f <$$> Comp.mk x = Comp.mk ((fun i (x : G i \u03b1) \u21a6 f <$$> x) <$$> x)", "start": [69, 1], "end": [70, 78], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Comp.get_map", "code": "theorem get_map (x : Comp F G \u03b1) :\n    Comp.get (f <$$> x) = (fun i (x : G i \u03b1) \u21a6 f <$$> x) <$$> Comp.get x", "start": [73, 1], "end": [74, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/GCD.lean", "imports": ["Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Init/Meta/WellFoundedTactics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.gcd_def", "code": "theorem gcd_def (x y : \u2115) : gcd x y = if x = 0 then y else gcd (y % x) x", "start": [34, 1], "end": [35, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/IsKan.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/Extension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bicategory.LeftExtension.IsKan", "code": "abbrev IsKan (t : LeftExtension f g) := t.IsUniversal", "start": [49, 1], "end": [50, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftLift.IsKan", "code": "abbrev IsKan (t : LeftLift f g) := t.IsUniversal", "start": [58, 1], "end": [59, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightExtension.IsKan", "code": "abbrev IsKan (t : RightExtension f g) := t.IsUniversal", "start": [67, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightLift.IsKan", "code": "abbrev IsKan (t : RightLift f g) := t.IsUniversal", "start": [76, 1], "end": [77, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Injective.lean", "imports": ["Mathlib/Topology/Instances/AddCircle.lean", "Mathlib/Algebra/Category/GroupCat/EpiMono.lean", "Mathlib/Algebra/Category/GroupCat/ZModuleEquivalence.lean", "Mathlib/Algebra/Module/Injective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Isomorphisms.lean", "Mathlib/Topology/Instances/Rat.lean"], "premises": [{"full_name": "AddCommGroupCat.injective_as_module_iff", "code": "theorem injective_as_module_iff : Injective (\u27e8A\u27e9 : ModuleCat \u2124) \u2194\n    Injective (\u27e8A,inferInstance\u27e9 : AddCommGroupCat)", "start": [47, 1], "end": [49, 85], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.injective_of_divisible", "code": "instance injective_of_divisible [DivisibleBy A \u2124] :\n    Injective (\u27e8A,inferInstance\u27e9 : AddCommGroupCat) :=\n  (injective_as_module_iff A).mp <|\n    @Module.injective_object_of_injective_module \u2124 _ A _ _ <|\n      Module.Baer.injective fun I g \u21a6 by\n        rcases IsPrincipalIdealRing.principal I with \u27e8m, rfl\u27e9\n        obtain rfl | h0 := eq_or_ne m 0\n        \u00b7 refine \u27e80, fun n hn \u21a6 ?_\u27e9\n          rw [Submodule.span_zero_singleton] at hn\n          subst hn\n          exact (map_zero g).symm\n        let g\u2098 := g \u27e8m, Submodule.subset_span (Set.mem_singleton _)\u27e9\n        refine \u27e8LinearMap.toSpanSingleton \u2124 A (DivisibleBy.div g\u2098 m), fun n hn \u21a6 ?_\u27e9\n        rcases Submodule.mem_span_singleton.mp hn with \u27e8n, rfl\u27e9\n        rw [map_zsmul, LinearMap.toSpanSingleton_apply, DivisibleBy.div_cancel g\u2098 h0, \u2190 map_zsmul g,\n          SetLike.mk_smul_mk]", "start": [53, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.injective_ratCircle", "code": "instance injective_ratCircle : Injective <| of <| ULift.{u} <| AddCircle (1 : \u211a) :=\n  have : Fact ((0 : \u211a) < 1) := \u27e8by norm_num\u27e9\n  injective_of_divisible _", "start": [71, 1], "end": [73, 27], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.next", "code": "def next : AddCommGroupCat.{u} := of <|\n  (A_ \u27f6 of <| ULift.{u} <| AddCircle (1 : \u211a)) \u2192 ULift.{u} (AddCircle (1 : \u211a))", "start": [79, 1], "end": [81, 78], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.toNext", "code": "@[simps] def toNext : A_ \u27f6 next A_ where\n  toFun a i := i a\n  map_zero' := by simp only [map_zero]; rfl\n  map_add' _ _ := by simp only [map_add]; rfl", "start": [87, 1], "end": [91, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSpanSingleton_ker", "code": "lemma _root_.LinearMap.toSpanSingleton_ker :\n    LinearMap.ker (LinearMap.toSpanSingleton \u2124 A_ a) = Ideal.span {(addOrderOf a : \u2124)} := by\n  ext1 x\n  rw [Ideal.mem_span_singleton, addOrderOf_dvd_iff_zsmul_eq_zero]\n  rfl", "start": [95, 1], "end": [99, 6], "kind": "mathlibtacticlemma"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.equivZModSpanAddOrderOf", "code": "@[simps!] noncomputable def equivZModSpanAddOrderOf :\n    (\u2124 \u2219 a) \u2243\u2097[\u2124] \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} :=\n  (LinearEquiv.ofEq _ _ <| LinearMap.span_singleton_eq_range \u2124 A_ a).trans <|\n    (LinearMap.quotKerEquivRange <| LinearMap.toSpanSingleton \u2124 A_ a).symm.trans <|\n      Submodule.quotEquivOfEq _ _ <| LinearMap.toSpanSingleton_ker a", "start": [101, 1], "end": [106, 69], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.equivZModSpanAddOrderOf_apply_self", "code": "lemma equivZModSpanAddOrderOf_apply_self :\n    equivZModSpanAddOrderOf a \u27e8a, Submodule.mem_span_singleton_self a\u27e9 = Submodule.Quotient.mk 1 :=\n  (LinearEquiv.eq_symm_apply _).mp (one_zsmul _).symm", "start": [108, 1], "end": [110, 54], "kind": "mathlibtacticlemma"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.divBy", "code": "abbrev divBy (n : \u2115) : \u2124 \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n  LinearMap.toSpanSingleton \u2124 _ (QuotientAddGroup.mk (n : \u211a)\u207b\u00b9)", "start": [112, 1], "end": [114, 64], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.divBy_self", "code": "lemma divBy_self (n : \u2115) : divBy n n = 0 := by\n  obtain rfl | h0 := eq_or_ne n 0\n  \u00b7 apply map_zero\n  apply (AddCircle.coe_eq_zero_iff _).mpr \u27e81, _\u27e9\n  simp [mul_inv_cancel (Nat.cast_ne_zero (R := \u211a).mpr h0)]", "start": [116, 1], "end": [120, 59], "kind": "mathlibtacticlemma"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.toRatCircle", "code": "@[simps!] noncomputable def toRatCircle : (\u2124 \u2219 a) \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n  let e : \u2124 \u29f8 Ideal.span {(addOrderOf a : \u2124)} \u2192\u2097[\u2124] AddCircle (1 : \u211a) :=\n    Submodule.liftQSpanSingleton _ (divBy <| if addOrderOf a = 0 then 2 else addOrderOf a) <| by\n      split_ifs with h\n      \u00b7 rw [h, Nat.cast_zero, map_zero]\n      \u00b7 apply divBy_self\n  e \u2218\u2097 equivZModSpanAddOrderOf a", "start": [124, 1], "end": [132, 33], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.eq_zero_of_toRatCircle_apply_self", "code": "lemma eq_zero_of_toRatCircle_apply_self\n    (h : toRatCircle \u27e8a, Submodule.mem_span_singleton_self a\u27e9 = 0) : a = 0 := by\n  erw [toRatCircle, LinearMap.comp_apply, LinearEquiv.coe_toLinearMap,\n    equivZModSpanAddOrderOf_apply_self, Submodule.liftQSpanSingleton_apply,\n    LinearMap.toSpanSingleton_one, AddCircle.coe_eq_zero_iff] at h\n  obtain \u27e8n, hn\u27e9 := h\n  apply_fun Rat.den at hn\n  rw [zsmul_one, Rat.coe_int_den, Rat.inv_coe_nat_den_of_pos] at hn\n  \u00b7 split_ifs at hn\n    \u00b7 cases hn\n    \u00b7 rwa [eq_comm, AddMonoid.addOrderOf_eq_one_iff] at hn\n  \u00b7 split_ifs with h\n    \u00b7 norm_num\n    \u00b7 exact Nat.pos_of_ne_zero h", "start": [134, 1], "end": [148, 33], "kind": "mathlibtacticlemma"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.toNext_inj", "code": "lemma toNext_inj : Function.Injective <| toNext A_ :=\n  (injective_iff_map_eq_zero _).mpr fun a h0 \u21a6\n    eq_zero_of_toRatCircle_apply_self <| ULift.up_injective <|\n      let f : of (\u2124 \u2219 a) \u27f6 of (ULift.{u} <| AddCircle (1 : \u211a)) :=\n        AddMonoidHom.comp \u27e8\u27e8ULift.up, rfl\u27e9, fun _ _ \u21a6 rfl\u27e9 toRatCircle.toAddMonoidHom\n      let g : of (\u2124 \u2219 a) \u27f6 A_ := AddSubgroupClass.subtype _\n      have : Mono g := (mono_iff_injective _).mpr Subtype.val_injective\n      (FunLike.congr_fun (Injective.comp_factorThru f g) _).symm.trans (congr_fun h0 _)", "start": [152, 1], "end": [159, 88], "kind": "mathlibtacticlemma"}, {"full_name": "AddCommGroupCat.enough_injectives_aux_proofs.presentation", "code": "@[simps] def presentation : InjectivePresentation A_ where\n  J := next A_\n  injective := inferInstance\n  f := toNext A_\n  mono := (AddCommGroupCat.mono_iff_injective _).mpr <| toNext_inj _", "start": [161, 1], "end": [166, 69], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.enoughInjectives", "code": "instance enoughInjectives : EnoughInjectives (AddCommGroupCat.{u}) where\n  presentation A_ := \u27e8enough_injectives_aux_proofs.presentation A_\u27e9", "start": [170, 1], "end": [171, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/CardEmbedding.lean", "imports": ["Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Logic/Embedding/Set.lean", "Mathlib/Logic/Equiv/Embedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fintype.card_embedding_eq_of_unique", "code": "theorem card_embedding_eq_of_unique {\u03b1 \u03b2 : Type*} [Unique \u03b1] [Fintype \u03b2] [Fintype (\u03b1 \u21aa \u03b2)] :\n    \u2016\u03b1 \u21aa \u03b2\u2016 = \u2016\u03b2\u2016", "start": [29, 1], "end": [31, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_embedding_eq", "code": "@[simp]\ntheorem card_embedding_eq {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] [emb : Fintype (\u03b1 \u21aa \u03b2)] :\n    \u2016\u03b1 \u21aa \u03b2\u2016 = \u2016\u03b2\u2016.descFactorial \u2016\u03b1\u2016", "start": [36, 1], "end": [51, 29], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_embedding_eq_of_infinite", "code": "@[simp]\ntheorem card_embedding_eq_of_infinite {\u03b1 \u03b2 : Type*} [Infinite \u03b1] [Fintype \u03b2] [Fintype (\u03b1 \u21aa \u03b2)] :\n    \u2016\u03b1 \u21aa \u03b2\u2016 = 0", "start": [56, 1], "end": [59, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Mod_.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Mon_.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mod_", "code": "structure Mod_ (A : Mon_ C) where\n  X : C\n  act : A.X \u2297 X \u27f6 X\n  one_act : (A.one \u2297 \ud835\udfd9 X) \u226b act = (\u03bb_ X).hom := by aesop_cat\n  assoc : (A.mul \u2297 \ud835\udfd9 X) \u226b act = (\u03b1_ A.X A.X X).hom \u226b (\ud835\udfd9 A.X \u2297 act) \u226b act := by aesop_cat", "start": [23, 1], "end": [28, 89], "kind": "commanddeclaration"}, {"full_name": "Mod_.assoc_flip", "code": "theorem assoc_flip :\n    (\ud835\udfd9 A.X \u2297 M.act) \u226b M.act = (\u03b1_ A.X A.X M.X).inv \u226b (A.mul \u2297 \ud835\udfd9 M.X) \u226b M.act", "start": [38, 1], "end": [39, 88], "kind": "commanddeclaration"}, {"full_name": "Mod_.Hom", "code": "@[ext]\nstructure Hom (M N : Mod_ A) where\n  hom : M.X \u27f6 N.X\n  act_hom : M.act \u226b hom = (\ud835\udfd9 A.X \u2297 hom) \u226b N.act := by aesop_cat", "start": [44, 1], "end": [48, 64], "kind": "commanddeclaration"}, {"full_name": "Mod_.id", "code": "@[simps]\ndef id (M : Mod_ A) : Hom M M where hom := \ud835\udfd9 M.X", "start": [54, 1], "end": [56, 49], "kind": "commanddeclaration"}, {"full_name": "Mod_.homInhabited", "code": "instance homInhabited (M : Mod_ A) : Inhabited (Hom M M) :=\n  \u27e8id M\u27e9", "start": [60, 1], "end": [61, 9], "kind": "commanddeclaration"}, {"full_name": "Mod_.comp", "code": "@[simps]\ndef comp {M N O : Mod_ A} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom \u226b g.hom", "start": [65, 1], "end": [67, 91], "kind": "commanddeclaration"}, {"full_name": "Mod_.hom_ext", "code": "@[ext]\nlemma hom_ext {M N : Mod_ A} (f\u2081 f\u2082 : M \u27f6 N) (h : f\u2081.hom = f\u2082.hom) : f\u2081 = f\u2082 :=\n  Hom.ext _ _ h", "start": [78, 1], "end": [80, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mod_.id_hom'", "code": "@[simp]\ntheorem id_hom' (M : Mod_ A) : (\ud835\udfd9 M : M \u27f6 M).hom = \ud835\udfd9 M.X", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Mod_.comp_hom'", "code": "@[simp]\ntheorem comp_hom' {M N K : Mod_ A} (f : M \u27f6 N) (g : N \u27f6 K) :\n    (f \u226b g).hom = f.hom \u226b g.hom", "start": [88, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "Mod_.regular", "code": "@[simps]\ndef regular : Mod_ A where\n  X := A.X\n  act := A.mul", "start": [97, 1], "end": [101, 15], "kind": "commanddeclaration"}, {"full_name": "Mod_.forget", "code": "def forget : Mod_ A \u2964 C where\n  obj A := A.X\n  map f := f.hom", "start": [108, 1], "end": [111, 17], "kind": "commanddeclaration"}, {"full_name": "Mod_.comap", "code": "@[simps]\ndef comap {A B : Mon_ C} (f : A \u27f6 B) : Mod_ B \u2964 Mod_ A where\n  obj M :=\n    { X := M.X\n      act := (f.hom \u2297 \ud835\udfd9 M.X) \u226b M.act\n      one_act := by\n        slice_lhs 1 2 => rw [\u2190 comp_tensor_id]\n        rw [f.one_hom, one_act]\n      assoc := by\n        slice_rhs 2 3 => rw [id_tensor_comp_tensor_id, \u2190 tensor_id_comp_id_tensor]\n        rw [id_tensor_comp]\n        slice_rhs 4 5 => rw [Mod_.assoc_flip]\n        slice_rhs 3 4 => rw [associator_inv_naturality]\n        slice_rhs 2 3 => rw [\u2190 tensor_id, associator_inv_naturality]\n        slice_rhs 1 3 => rw [Iso.hom_inv_id_assoc]\n        slice_rhs 1 2 => rw [\u2190 comp_tensor_id, tensor_id_comp_id_tensor]\n        slice_rhs 1 2 => rw [\u2190 comp_tensor_id, \u2190 f.mul_hom]\n        rw [comp_tensor_id, Category.assoc] }\n  map g :=\n    { hom := g.hom\n      act_hom := by\n        dsimp\n        slice_rhs 1 2 => rw [id_tensor_comp_tensor_id, \u2190 tensor_id_comp_id_tensor]\n        slice_rhs 2 3 => rw [\u2190 g.act_hom]\n        rw [Category.assoc] }", "start": [117, 1], "end": [145, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean", "imports": ["Mathlib/MeasureTheory/Function/ContinuousMapDense.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Group/Integral.lean", "Mathlib/MeasureTheory/Integral/SetIntegral.lean", "Mathlib/Topology/EMetricSpace/Paracompact.lean", "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean", "Mathlib/Analysis/InnerProductSpace/EuclideanDist.lean", "Mathlib/Analysis/Fourier/FourierTransform.lean", "Mathlib/Analysis/InnerProductSpace/Dual.lean"], "premises": [{"full_name": "fourier_integrand_integrable", "code": "theorem fourier_integrand_integrable (w : V) :\n    Integrable f \u2194 Integrable fun v : V => e[-\u27eav, w\u27eb] \u2022 f v", "start": [64, 1], "end": [70, 64], "kind": "commanddeclaration"}, {"full_name": "fourier_integral_half_period_translate", "code": "theorem fourier_integral_half_period_translate {w : V} (hw : w \u2260 0) :\n    (\u222b v : V, e[-\u27eav, w\u27eb] \u2022 f (v + i w)) = -\u222b v : V, e[-\u27eav, w\u27eb] \u2022 f v", "start": [79, 1], "end": [103, 37], "kind": "commanddeclaration"}, {"full_name": "fourier_integral_eq_half_sub_half_period_translate", "code": "theorem fourier_integral_eq_half_sub_half_period_translate {w : V} (hw : w \u2260 0)\n    (hf : Integrable f) :\n    \u222b v : V, e[-\u27eav, w\u27eb] \u2022 f v = (1 / (2 : \u2102)) \u2022 \u222b v : V, e[-\u27eav, w\u27eb] \u2022 (f v - f (v + i w))", "start": [106, 1], "end": [115, 63], "kind": "commanddeclaration"}, {"full_name": "tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support", "code": "theorem tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support (hf1 : Continuous f)\n    (hf2 : HasCompactSupport f) :\n    Tendsto (fun w : V => \u222b v : V, e[-\u27eav, w\u27eb] \u2022 f v) (cocompact V) (\ud835\udcdd 0)", "start": [118, 1], "end": [212, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_integral_exp_inner_smul_cocompact", "code": "theorem tendsto_integral_exp_inner_smul_cocompact :\n    Tendsto (fun w : V => \u222b v, e[-\u27eav, w\u27eb] \u2022 f v) (cocompact V) (\ud835\udcdd 0)", "start": [217, 1], "end": [247, 39], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_integral_exp_smul_cocompact", "code": "theorem Real.tendsto_integral_exp_smul_cocompact (f : \u211d \u2192 E) :\n    Tendsto (fun w : \u211d => \u222b v : \u211d, e[-(v * w)] \u2022 f v) (cocompact \u211d) (\ud835\udcdd 0)", "start": [250, 1], "end": [253, 46], "kind": "commanddeclaration"}, {"full_name": "Real.zero_at_infty_fourierIntegral", "code": "theorem Real.zero_at_infty_fourierIntegral (f : \u211d \u2192 E) : Tendsto (\ud835\udcd5 f) (cocompact \u211d) (\ud835\udcdd 0)", "start": [256, 1], "end": [258, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_integral_exp_smul_cocompact_of_inner_product", "code": "theorem tendsto_integral_exp_smul_cocompact_of_inner_product (\u03bc : Measure V) [\u03bc.IsAddHaarMeasure] :\n    Tendsto (fun w : V \u2192L[\u211d] \u211d => \u222b v, e[-w v] \u2022 f v \u2202\u03bc) (cocompact (V \u2192L[\u211d] \u211d)) (\ud835\udcdd 0)", "start": [261, 1], "end": [280, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_integral_exp_smul_cocompact", "code": "theorem tendsto_integral_exp_smul_cocompact (\u03bc : Measure V) [\u03bc.IsAddHaarMeasure] :\n    Tendsto (fun w : V \u2192L[\u211d] \u211d => \u222b v, e[-w v] \u2022 f v \u2202\u03bc) (cocompact (V \u2192L[\u211d] \u211d)) (\ud835\udcdd 0)", "start": [291, 1], "end": [344, 60], "kind": "commanddeclaration"}, {"full_name": "Real.zero_at_infty_vector_fourierIntegral", "code": "theorem Real.zero_at_infty_vector_fourierIntegral (\u03bc : Measure V) [\u03bc.IsAddHaarMeasure] :\n    Tendsto (VectorFourier.fourierIntegral e \u03bc (topDualPairing \u211d V).flip f) (cocompact (V \u2192L[\u211d] \u211d))\n      (\ud835\udcdd 0)", "start": [347, 1], "end": [353, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Classes/Order.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Classes/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/SetTheory/Game/Domineering.lean", "imports": ["Mathlib/SetTheory/Game/State.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.Domineering.shiftUp", "code": "@[simps!]\ndef shiftUp : \u2124 \u00d7 \u2124 \u2243 \u2124 \u00d7 \u2124 :=\n  (Equiv.refl \u2124).prodCongr (Equiv.addRight (1 : \u2124))", "start": [32, 1], "end": [35, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.shiftRight", "code": "@[simps!]\ndef shiftRight : \u2124 \u00d7 \u2124 \u2243 \u2124 \u00d7 \u2124 :=\n  (Equiv.addRight (1 : \u2124)).prodCongr (Equiv.refl \u2124)", "start": [38, 1], "end": [41, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.Board", "code": "@[reducible]\ndef Board :=\n  Finset (\u2124 \u00d7 \u2124)\nderiving Inhabited", "start": [44, 1], "end": [50, 19], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.left", "code": "def left (b : Board) : Finset (\u2124 \u00d7 \u2124) :=\n  b \u2229 b.map shiftUp", "start": [53, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.right", "code": "def right (b : Board) : Finset (\u2124 \u00d7 \u2124) :=\n  b \u2229 b.map shiftRight", "start": [58, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.mem_left", "code": "theorem mem_left {b : Board} (x : \u2124 \u00d7 \u2124) : x \u2208 left b \u2194 x \u2208 b \u2227 (x.1, x.2 - 1) \u2208 b", "start": [63, 1], "end": [64, 66], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.mem_right", "code": "theorem mem_right {b : Board} (x : \u2124 \u00d7 \u2124) : x \u2208 right b \u2194 x \u2208 b \u2227 (x.1 - 1, x.2) \u2208 b", "start": [67, 1], "end": [68, 66], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveLeft", "code": "def moveLeft (b : Board) (m : \u2124 \u00d7 \u2124) : Board :=\n  (b.erase m).erase (m.1, m.2 - 1)", "start": [71, 1], "end": [73, 35], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveRight", "code": "def moveRight (b : Board) (m : \u2124 \u00d7 \u2124) : Board :=\n  (b.erase m).erase (m.1 - 1, m.2)", "start": [76, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.fst_pred_mem_erase_of_mem_right", "code": "theorem fst_pred_mem_erase_of_mem_right {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 right b) :\n    (m.1 - 1, m.2) \u2208 b.erase m", "start": [81, 1], "end": [85, 51], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left", "code": "theorem snd_pred_mem_erase_of_mem_left {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 left b) :\n    (m.1, m.2 - 1) \u2208 b.erase m", "start": [88, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.card_of_mem_left", "code": "theorem card_of_mem_left {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 left b) : 2 \u2264 Finset.card b", "start": [95, 1], "end": [100, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.card_of_mem_right", "code": "theorem card_of_mem_right {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 right b) : 2 \u2264 Finset.card b", "start": [103, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveLeft_card", "code": "theorem moveLeft_card {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 left b) :\n    Finset.card (moveLeft b m) + 2 = Finset.card b", "start": [111, 1], "end": [116, 51], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveRight_card", "code": "theorem moveRight_card {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 right b) :\n    Finset.card (moveRight b m) + 2 = Finset.card b", "start": [119, 1], "end": [124, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveLeft_smaller", "code": "theorem moveLeft_smaller {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 left b) :\n    Finset.card (moveLeft b m) / 2 < Finset.card b / 2", "start": [127, 1], "end": [128, 98], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.moveRight_smaller", "code": "theorem moveRight_smaller {b : Board} {m : \u2124 \u00d7 \u2124} (h : m \u2208 right b) :\n    Finset.card (moveRight b m) / 2 < Finset.card b / 2", "start": [131, 1], "end": [132, 100], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Domineering.state", "code": "instance state : State Board where\n  turnBound s := s.card / 2\n  l s := (left s).image (moveLeft s)\n  r s := (right s).image (moveRight s)\n  left_bound m := by\n    simp only [Finset.mem_image, Prod.exists] at m\n    rcases m with \u27e8_, _, \u27e8h, rfl\u27e9\u27e9\n    exact moveLeft_smaller h\n  right_bound m := by\n    simp only [Finset.mem_image, Prod.exists] at m\n    rcases m with \u27e8_, _, \u27e8h, rfl\u27e9\u27e9\n    exact moveRight_smaller h", "start": [135, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.domineering", "code": "def domineering (b : Domineering.Board) : PGame :=\n  PGame.ofState b", "start": [152, 1], "end": [154, 18], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortDomineering", "code": "instance shortDomineering (b : Domineering.Board) : Short (domineering b) := by\n  dsimp [domineering]\n  infer_instance", "start": [157, 1], "end": [160, 17], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.domineering.one", "code": "def domineering.one :=\n  domineering [(0, 0), (0, 1)].toFinset", "start": [163, 1], "end": [165, 40], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.domineering.L", "code": "def domineering.L :=\n  domineering [(0, 2), (0, 1), (0, 0), (1, 0)].toFinset", "start": [168, 1], "end": [170, 56], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOne", "code": "instance shortOne : Short domineering.one := by dsimp [domineering.one]; infer_instance", "start": [174, 1], "end": [174, 88], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortL", "code": "instance shortL : Short domineering.L := by dsimp [domineering.L]; infer_instance", "start": [177, 1], "end": [177, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/KummerDedekind.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/RingTheory/IsAdjoinRoot.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "conductor", "code": "def conductor (x : S) : Ideal S where\n  carrier := {a | \u2200 b : S, a * b \u2208 R<x>}\n  zero_mem' b := by simpa only [zero_mul] using Subalgebra.zero_mem _\n  add_mem' ha hb c := by simpa only [add_mul] using Subalgebra.add_mem _ (ha c) (hb c)\n  smul_mem' c a ha b := by simpa only [smul_eq_mul, mul_left_comm, mul_assoc] using ha (c * b)", "start": [62, 1], "end": [68, 95], "kind": "commanddeclaration"}, {"full_name": "conductor_eq_of_eq", "code": "theorem conductor_eq_of_eq {y : S} (h : (R<x> : Set S) = R<y>) : conductor R x = conductor R y", "start": [73, 1], "end": [74, 63], "kind": "commanddeclaration"}, {"full_name": "conductor_subset_adjoin", "code": "theorem conductor_subset_adjoin : (conductor R x : Set S) \u2286 R<x>", "start": [77, 1], "end": [78, 34], "kind": "commanddeclaration"}, {"full_name": "mem_conductor_iff", "code": "theorem mem_conductor_iff {y : S} : y \u2208 conductor R x \u2194 \u2200 b : S, y * b \u2208 R<x>", "start": [81, 1], "end": [82, 27], "kind": "commanddeclaration"}, {"full_name": "conductor_eq_top_of_adjoin_eq_top", "code": "theorem conductor_eq_top_of_adjoin_eq_top (h : R<x> = \u22a4) : conductor R x = \u22a4", "start": [85, 1], "end": [86, 80], "kind": "commanddeclaration"}, {"full_name": "conductor_eq_top_of_powerBasis", "code": "theorem conductor_eq_top_of_powerBasis (pb : PowerBasis R S) : conductor R pb.gen = \u22a4", "start": [89, 1], "end": [90, 57], "kind": "commanddeclaration"}, {"full_name": "prod_mem_ideal_map_of_mem_conductor", "code": "theorem prod_mem_ideal_map_of_mem_conductor {p : R} {z : S}\n    (hp : p \u2208 Ideal.comap (algebraMap R S) (conductor R x)) (hz' : z \u2208 I.map (algebraMap R S)) :\n    algebraMap R S p * z \u2208 algebraMap R<x> S '' \u2191(I.map (algebraMap R R<x>))", "start": [95, 1], "end": [126, 52], "kind": "commanddeclaration"}, {"full_name": "comap_map_eq_map_adjoin_of_coprime_conductor", "code": "theorem comap_map_eq_map_adjoin_of_coprime_conductor\n    (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4)\n    (h_alg : Function.Injective (algebraMap R<x> S)) :\n    (I.map (algebraMap R S)).comap (algebraMap R<x> S) = I.map (algebraMap R R<x>)", "start": [129, 1], "end": [164, 29], "kind": "commanddeclaration"}, {"full_name": "quotAdjoinEquivQuotMap", "code": "noncomputable def quotAdjoinEquivQuotMap (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4)\n    (h_alg : Function.Injective (algebraMap R<x> S)) :\n    R<x> \u29f8 I.map (algebraMap R R<x>) \u2243+* S \u29f8 I.map (algebraMap R S) := by\n  let f : R<x> \u29f8 I.map (algebraMap R R<x>) \u2192+* S \u29f8 I.map (algebraMap R S) :=\n    (Ideal.Quotient.lift (I.map (algebraMap R R<x>))\n      ((Ideal.Quotient.mk (I.map (algebraMap R S))).comp (algebraMap R<x> S)) (fun r hr => by\n      have : algebraMap R S = (algebraMap R<x> S).comp (algebraMap R R<x>) := by ext; rfl\n      rw [RingHom.comp_apply, Ideal.Quotient.eq_zero_iff_mem, this, \u2190 Ideal.map_map]\n      exact Ideal.mem_map_of_mem _ hr))\n  refine RingEquiv.ofBijective f \u27e8?_, ?_\u27e9\n  \u00b7 refine RingHom.lift_injective_of_ker_le_ideal _ _ fun u hu => ?_\n    rwa [RingHom.mem_ker, RingHom.comp_apply, Ideal.Quotient.eq_zero_iff_mem, \u2190 Ideal.mem_comap,\n      comap_map_eq_map_adjoin_of_coprime_conductor hx h_alg] at hu\n  \u00b7 refine Ideal.Quotient.lift_surjective_of_surjective _ _ fun y => ?_\n    obtain \u27e8z, hz\u27e9 := Ideal.Quotient.mk_surjective y\n    have : z \u2208 conductor R x \u2294 I.map (algebraMap R S) := by\n      suffices conductor R x \u2294 I.map (algebraMap R S) = \u22a4 by simp only [this, Submodule.mem_top]\n      rw [Ideal.eq_top_iff_one] at hx \u22a2\n      replace hx := Ideal.mem_map_of_mem (algebraMap R S) hx\n      rw [Ideal.map_sup, RingHom.map_one] at hx\n      exact (sup_le_sup\n        (show ((conductor R x).comap (algebraMap R S)).map (algebraMap R S) \u2264 conductor R x\n          from Ideal.map_comap_le)\n          (le_refl (I.map (algebraMap R S)))) hx\n    rw [\u2190 Ideal.mem_quotient_iff_mem_sup, hz, Ideal.mem_map_iff_of_surjective] at this\n    obtain \u27e8u, hu, hu'\u27e9 := this\n    use \u27e8u, conductor_subset_adjoin hu\u27e9\n    simp only [\u2190 hu']\n    rfl\n    \u00b7 exact Ideal.Quotient.mk_surjective", "start": [167, 1], "end": [202, 41], "kind": "commanddeclaration"}, {"full_name": "quotAdjoinEquivQuotMap_apply_mk", "code": "@[simp, nolint simpNF]\ntheorem quotAdjoinEquivQuotMap_apply_mk (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4)\n    (h_alg : Function.Injective (algebraMap R<x> S)) (a : R<x>) :\n    quotAdjoinEquivQuotMap hx h_alg (Ideal.Quotient.mk (I.map (algebraMap R R<x>)) a) =\n      Ideal.Quotient.mk (I.map (algebraMap R S)) \u2191a", "start": [207, 1], "end": [211, 59], "kind": "commanddeclaration"}, {"full_name": "KummerDedekind.normalizedFactorsMapEquivNormalizedFactorsMinPolyMk", "code": "noncomputable def normalizedFactorsMapEquivNormalizedFactorsMinPolyMk (hI : IsMaximal I)\n    (hI' : I \u2260 \u22a5) (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4) (hx' : IsIntegral R x) :\n    {J : Ideal S | J \u2208 normalizedFactors (I.map (algebraMap R S))} \u2243\n      {d : (R \u29f8 I)[X] |\n        d \u2208 normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))} := by\n  have : IsPrincipalIdealRing (R \u29f8 I)[X] := inferInstance\n  let f : S \u29f8 map (algebraMap R S) I \u2243+*\n    (R \u29f8 I)[X] \u29f8 span {Polynomial.map (Ideal.Quotient.mk I) (minpoly R x)} := by\n    refine (quotAdjoinEquivQuotMap hx ?_).symm.trans\n      (((Algebra.adjoin.powerBasis'\n        hx').quotientEquivQuotientMinpolyMap I).toRingEquiv.trans (quotEquivOfEq ?_))\n    \u00b7 exact NoZeroSMulDivisors.algebraMap_injective (Algebra.adjoin R {x}) S\n    \u00b7 rw [Algebra.adjoin.powerBasis'_minpoly_gen hx']\n  refine (normalizedFactorsEquivOfQuotEquiv f ?_ ?_).trans ?_\n  \u00b7 rwa [Ne.def, map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S),\n      \u2190 Ne.def]\n  \u00b7 by_contra h\n    exact (show Polynomial.map (Ideal.Quotient.mk I) (minpoly R x) \u2260 0 from\n      Polynomial.map_monic_ne_zero (minpoly.monic hx')) (span_singleton_eq_bot.mp h)\n  \u00b7 refine (normalizedFactorsEquivSpanNormalizedFactors ?_).symm\n    exact Polynomial.map_monic_ne_zero (minpoly.monic hx')", "start": [226, 1], "end": [250, 59], "kind": "commanddeclaration"}, {"full_name": "KummerDedekind.multiplicity_factors_map_eq_multiplicity", "code": "theorem multiplicity_factors_map_eq_multiplicity (hI : IsMaximal I) (hI' : I \u2260 \u22a5)\n    (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4) (hx' : IsIntegral R x) {J : Ideal S}\n    (hJ : J \u2208 normalizedFactors (I.map (algebraMap R S))) :\n    multiplicity J (I.map (algebraMap R S)) =\n      multiplicity (\u2191(normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx' \u27e8J, hJ\u27e9))\n        (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))", "start": [253, 1], "end": [263, 68], "kind": "commanddeclaration"}, {"full_name": "KummerDedekind.normalizedFactors_ideal_map_eq_normalizedFactors_min_poly_mk_map", "code": "theorem normalizedFactors_ideal_map_eq_normalizedFactors_min_poly_mk_map (hI : IsMaximal I)\n    (hI' : I \u2260 \u22a5) (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4) (hx' : IsIntegral R x) :\n    normalizedFactors (I.map (algebraMap R S)) =\n      Multiset.map\n        (fun f =>\n          ((normalizedFactorsMapEquivNormalizedFactorsMinPolyMk hI hI' hx hx').symm f : Ideal S))\n        (normalizedFactors (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))).attach", "start": [266, 1], "end": [308, 81], "kind": "commanddeclaration"}, {"full_name": "KummerDedekind.Ideal.irreducible_map_of_irreducible_minpoly", "code": "theorem Ideal.irreducible_map_of_irreducible_minpoly (hI : IsMaximal I) (hI' : I \u2260 \u22a5)\n    (hx : (conductor R x).comap (algebraMap R S) \u2294 I = \u22a4) (hx' : IsIntegral R x)\n    (hf : Irreducible (Polynomial.map (Ideal.Quotient.mk I) (minpoly R x))) :\n    Irreducible (I.map (algebraMap R S))", "start": [311, 1], "end": [337, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Inversion/Calculus.lean", "imports": ["Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "Mathlib/Analysis/Calculus/Deriv/Inv.lean", "Mathlib/Analysis/InnerProductSpace/Calculus.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContDiffWithinAt.inversion", "code": "protected theorem ContDiffWithinAt.inversion (hc : ContDiffWithinAt \u211d n c s a)\n    (hR : ContDiffWithinAt \u211d n R s a) (hx : ContDiffWithinAt \u211d n x s a) (hne : x a \u2260 c a) :\n    ContDiffWithinAt \u211d n (fun a \u21a6 inversion (c a) (R a) (x a)) s a", "start": [39, 1], "end": [42, 85], "kind": "commanddeclaration"}, {"full_name": "ContDiffOn.inversion", "code": "protected theorem ContDiffOn.inversion (hc : ContDiffOn \u211d n c s) (hR : ContDiffOn \u211d n R s)\n    (hx : ContDiffOn \u211d n x s) (hne : \u2200 a \u2208 s, x a \u2260 c a) :\n    ContDiffOn \u211d n (fun a \u21a6 inversion (c a) (R a) (x a)) s", "start": [44, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "ContDiffAt.inversion", "code": "protected nonrec theorem ContDiffAt.inversion (hc : ContDiffAt \u211d n c a) (hR : ContDiffAt \u211d n R a)\n    (hx : ContDiffAt \u211d n x a) (hne : x a \u2260 c a) :\n    ContDiffAt \u211d n (fun a \u21a6 inversion (c a) (R a) (x a)) a", "start": [49, 1], "end": [52, 25], "kind": "commanddeclaration"}, {"full_name": "ContDiff.inversion", "code": "protected nonrec theorem ContDiff.inversion (hc : ContDiff \u211d n c) (hR : ContDiff \u211d n R)\n    (hx : ContDiff \u211d n x) (hne : \u2200 a, x a \u2260 c a) :\n    ContDiff \u211d n (fun a \u21a6 inversion (c a) (R a) (x a))", "start": [54, 1], "end": [57, 96], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.inversion", "code": "protected theorem DifferentiableWithinAt.inversion (hc : DifferentiableWithinAt \u211d c s a)\n    (hR : DifferentiableWithinAt \u211d R s a) (hx : DifferentiableWithinAt \u211d x s a) (hne : x a \u2260 c a) :\n    DifferentiableWithinAt \u211d (fun a \u21a6 inversion (c a) (R a) (x a)) s a", "start": [59, 1], "end": [63, 92], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.inversion", "code": "protected theorem DifferentiableOn.inversion (hc : DifferentiableOn \u211d c s)\n    (hR : DifferentiableOn \u211d R s) (hx : DifferentiableOn \u211d x s) (hne : \u2200 a \u2208 s, x a \u2260 c a) :\n    DifferentiableOn \u211d (fun a \u21a6 inversion (c a) (R a) (x a)) s", "start": [65, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.inversion", "code": "protected theorem DifferentiableAt.inversion (hc : DifferentiableAt \u211d c a)\n    (hR : DifferentiableAt \u211d R a) (hx : DifferentiableAt \u211d x a) (hne : x a \u2260 c a) :\n    DifferentiableAt \u211d (fun a \u21a6 inversion (c a) (R a) (x a)) a", "start": [70, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "Differentiable.inversion", "code": "protected theorem Differentiable.inversion (hc : Differentiable \u211d c)\n    (hR : Differentiable \u211d R) (hx : Differentiable \u211d x) (hne : \u2200 a, x a \u2260 c a) :\n    Differentiable \u211d (fun a \u21a6 inversion (c a) (R a) (x a))", "start": [76, 1], "end": [79, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.hasFDerivAt_inversion", "code": "theorem hasFDerivAt_inversion (hx : x \u2260 c) :\n    HasFDerivAt (inversion c R)\n      ((R / dist x c) ^ 2 \u2022 (reflection (\u211d \u2219 (x - c))\u15ee : F \u2192L[\u211d] F)) x", "start": [87, 1], "end": [106, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/CompareReals.lean", "imports": ["Mathlib/Topology/Instances/Real.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/UniformSpace/AbsoluteValue.lean", "Mathlib/Topology/UniformSpace/Completion.lean", "Mathlib/Topology/Instances/Rat.lean"], "premises": [{"full_name": "Rat.uniformSpace_eq", "code": "theorem Rat.uniformSpace_eq :\n    (AbsoluteValue.abs : AbsoluteValue \u211a \u211a).uniformSpace = PseudoMetricSpace.toUniformSpace", "start": [58, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "rationalCauSeqPkg", "code": "def rationalCauSeqPkg : @AbstractCompletion \u211a <| (@AbsoluteValue.abs \u211a _).uniformSpace :=\n  @AbstractCompletion.mk\n    (space := \u211d)\n    (coe := ((\u2191) : \u211a \u2192 \u211d))\n    (uniformStruct := by infer_instance)\n    (complete := by infer_instance)\n    (separation := by infer_instance)\n    (uniformInducing := by\n      rw [Rat.uniformSpace_eq]\n      exact Rat.uniformEmbedding_coe_real.toUniformInducing)\n    (dense := Rat.denseEmbedding_coe_real.dense)", "start": [68, 1], "end": [79, 49], "kind": "commanddeclaration"}, {"full_name": "CompareReals.Q", "code": "def Q :=\n  \u211a deriving CommRing, Inhabited", "start": [84, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "CompareReals.uniformSpace", "code": "instance uniformSpace : UniformSpace Q :=\n  (@AbsoluteValue.abs \u211a _).uniformSpace", "start": [93, 1], "end": [94, 40], "kind": "commanddeclaration"}, {"full_name": "CompareReals.Bourbaki\u211d", "code": "def Bourbaki\u211d : Type :=\n  Completion Q deriving Inhabited", "start": [96, 1], "end": [98, 34], "kind": "commanddeclaration"}, {"full_name": "CompareReals.Bourbaki.uniformSpace", "code": "instance Bourbaki.uniformSpace : UniformSpace Bourbaki\u211d :=\n  Completion.uniformSpace Q", "start": [102, 1], "end": [103, 28], "kind": "commanddeclaration"}, {"full_name": "CompareReals.bourbakiPkg", "code": "def bourbakiPkg : AbstractCompletion Q :=\n  Completion.cPkg", "start": [106, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "CompareReals.compareEquiv", "code": "noncomputable def compareEquiv : Bourbaki\u211d \u2243\u1d64 \u211d :=\n  bourbakiPkg.compareEquiv rationalCauSeqPkg", "start": [112, 1], "end": [114, 45], "kind": "commanddeclaration"}, {"full_name": "CompareReals.compare_uc", "code": "theorem compare_uc : UniformContinuous compareEquiv", "start": [117, 1], "end": [118, 63], "kind": "commanddeclaration"}, {"full_name": "CompareReals.compare_uc_symm", "code": "theorem compare_uc_symm : UniformContinuous compareEquiv.symm", "start": [121, 1], "end": [122, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Extension/Linear.lean", "imports": ["Mathlib/Order/Zorn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "extend_partialOrder", "code": "theorem extend_partialOrder {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsPartialOrder \u03b1 r] :\n    \u2203 (s : \u03b1 \u2192 \u03b1 \u2192 Prop) (_ : IsLinearOrder \u03b1 s), r \u2264 s", "start": [24, 1], "end": [73, 44], "kind": "commanddeclaration"}, {"full_name": "LinearExtension", "code": "def LinearExtension (\u03b1 : Type u) : Type u :=\n  \u03b1", "start": [76, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "toLinearExtension", "code": "def toLinearExtension {\u03b1 : Type u} [PartialOrder \u03b1] :\n    ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2192r ((\u00b7 \u2264 \u00b7) : LinearExtension \u03b1 \u2192 LinearExtension \u03b1 \u2192 Prop)\n    where\n  toFun x := x\n  map_rel' := (extend_partialOrder ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)).choose_spec.choose_spec _ _", "start": [89, 1], "end": [94, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/System/IO.lean", "imports": ["Mathlib/Data/List/Indexes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IO.waitAny'", "code": "def IO.waitAny' (tasks : List (Task \u03b1)) (h : List.length tasks > 0 := by nonempty_list) :\n    BaseIO (\u03b1 \u00d7 List (Task \u03b1)) := do\n  let (i, a) \u2190 IO.waitAny\n    (tasks.mapIdx fun i t => t.map (prio := .max) fun a => (i, a))\n    ((tasks.length_mapIdx _).symm \u25b8 h)\n  return (a, tasks.eraseIdx i)", "start": [22, 1], "end": [31, 31], "kind": "commanddeclaration"}, {"full_name": "List.waitAll", "code": "def List.waitAll (tasks : List (Task \u03b1)) : Task (List \u03b1) :=\n  match tasks with\n  | [] => .pure []\n  | task::tasks => task.bind (prio := .max) fun a =>\n      tasks.waitAll.map (prio := .max) fun as => a::as", "start": [33, 1], "end": [41, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Constructions/Prj.lean", "imports": ["Mathlib/Control/Functor/Multivariate.lean", "Mathlib/Data/QPF/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF.Prj", "code": "def Prj (v : TypeVec.{u} n) : Type u := v i", "start": [25, 1], "end": [26, 44], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.inhabited", "code": "instance Prj.inhabited {v : TypeVec.{u} n} [Inhabited (v i)] : Inhabited (Prj i v) :=\n  \u27e8(default : v i)\u27e9", "start": [29, 1], "end": [30, 20], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.map", "code": "def Prj.map \u2983\u03b1 \u03b2 : TypeVec n\u2984 (f : \u03b1 \u27f9 \u03b2) : Prj i \u03b1 \u2192 Prj i \u03b2 := f _", "start": [33, 1], "end": [34, 69], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.mvfunctor", "code": "instance Prj.mvfunctor : MvFunctor (Prj i) where map := @Prj.map _ i", "start": [37, 1], "end": [37, 69], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.P", "code": "def Prj.P : MvPFunctor.{u} n where\n  A := PUnit\n  B _ j := ULift <| PLift <| i = j", "start": [40, 1], "end": [43, 35], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.abs", "code": "def Prj.abs \u2983\u03b1 : TypeVec n\u2984 : Prj.P i \u03b1 \u2192 Prj i \u03b1\n  | \u27e8_x, f\u27e9 => f _ \u27e8\u27e8rfl\u27e9\u27e9", "start": [47, 1], "end": [49, 27], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.repr", "code": "def Prj.repr \u2983\u03b1 : TypeVec n\u2984 : Prj i \u03b1 \u2192 Prj.P i \u03b1 := fun x : \u03b1 i =>\n  \u27e8\u27e8\u27e9, fun j \u27e8\u27e8h\u27e9\u27e9 => (h.rec x : \u03b1 j)\u27e9", "start": [52, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "MvQPF.Prj.mvqpf", "code": "instance Prj.mvqpf : MvQPF (Prj i) where\n  P := Prj.P i\n  abs := @Prj.abs _ i\n  repr := @Prj.repr _ i\n  abs_repr := by intros; rfl\n  abs_map := by intros \u03b1 \u03b2 f P; cases P; rfl", "start": [57, 1], "end": [62, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Option/Init/Lemmas.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Option/Init/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Probability/Kernel/Invariance.lean", "imports": ["Mathlib/Probability/Kernel/Composition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.kernel.bind_add", "code": "@[simp]\ntheorem bind_add (\u03bc \u03bd : Measure \u03b1) (\u03ba : kernel \u03b1 \u03b2) : (\u03bc + \u03bd).bind \u03ba = \u03bc.bind \u03ba + \u03bd.bind \u03ba", "start": [42, 1], "end": [47, 49], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.bind_smul", "code": "@[simp]\ntheorem bind_smul (\u03ba : kernel \u03b1 \u03b2) (\u03bc : Measure \u03b1) (r : \u211d\u22650\u221e) : (r \u2022 \u03bc).bind \u03ba = r \u2022 \u03bc.bind \u03ba", "start": [50, 1], "end": [54, 77], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.const_bind_eq_comp_const", "code": "theorem const_bind_eq_comp_const (\u03ba : kernel \u03b1 \u03b2) (\u03bc : Measure \u03b1) :\n    const \u03b1 (\u03bc.bind \u03ba) = \u03ba \u2218\u2096 const \u03b1 \u03bc", "start": [57, 1], "end": [60, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.comp_const_apply_eq_bind", "code": "theorem comp_const_apply_eq_bind (\u03ba : kernel \u03b1 \u03b2) (\u03bc : Measure \u03b1) (a : \u03b1) :\n    (\u03ba \u2218\u2096 const \u03b1 \u03bc) a = \u03bc.bind \u03ba", "start": [63, 1], "end": [65, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.Invariant", "code": "def Invariant (\u03ba : kernel \u03b1 \u03b1) (\u03bc : Measure \u03b1) : Prop :=\n  \u03bc.bind \u03ba = \u03bc", "start": [71, 1], "end": [74, 15], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.Invariant.def", "code": "theorem Invariant.def (h\u03ba : Invariant \u03ba \u03bc) : \u03bc.bind \u03ba = \u03bc", "start": [79, 1], "end": [80, 5], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.Invariant.comp_const", "code": "theorem Invariant.comp_const (h\u03ba : Invariant \u03ba \u03bc) : \u03ba \u2218\u2096 const \u03b1 \u03bc = const \u03b1 \u03bc", "start": [83, 1], "end": [84, 46], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.Invariant.comp", "code": "theorem Invariant.comp [IsSFiniteKernel \u03ba] (h\u03ba : Invariant \u03ba \u03bc) (h\u03b7 : Invariant \u03b7 \u03bc) :\n    Invariant (\u03ba \u2218\u2096 \u03b7) \u03bc", "start": [87, 1], "end": [92, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Analysis/Topology.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/Topology/LocallyFinite.lean", "Mathlib/Data/Analysis/Filter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ctop", "code": "structure Ctop (\u03b1 \u03c3 : Type*) where\n  f : \u03c3 \u2192 Set \u03b1\n  top : \u03b1 \u2192 \u03c3\n  top_mem : \u2200 x : \u03b1, x \u2208 f (top x)\n  inter : \u2200 (a b) (x : \u03b1), x \u2208 f a \u2229 f b \u2192 \u03c3\n  inter_mem : \u2200 a b x h, x \u2208 f (inter a b x h)\n  inter_sub : \u2200 a b x h, f (inter a b x h) \u2286 f a \u2229 f b", "start": [32, 1], "end": [41, 55], "kind": "commanddeclaration"}, {"full_name": "Ctop.coe_mk", "code": "theorem coe_mk (f T h\u2081 I h\u2082 h\u2083 a) : (@Ctop.mk \u03b1 \u03c3 f T h\u2081 I h\u2082 h\u2083) a = f a", "start": [64, 1], "end": [64, 81], "kind": "commanddeclaration"}, {"full_name": "Ctop.ofEquiv", "code": "def ofEquiv (E : \u03c3 \u2243 \u03c4) : Ctop \u03b1 \u03c3 \u2192 Ctop \u03b1 \u03c4\n  | \u27e8f, T, h\u2081, I, h\u2082, h\u2083\u27e9 =>\n    { f := fun a \u21a6 f (E.symm a)\n      top := fun x \u21a6 E (T x)\n      top_mem := fun x \u21a6 by simpa using h\u2081 x\n      inter := fun a b x h \u21a6 E (I (E.symm a) (E.symm b) x h)\n      inter_mem := fun a b x h \u21a6 by simpa using h\u2082 (E.symm a) (E.symm b) x h\n      inter_sub := fun a b x h \u21a6 by simpa using h\u2083 (E.symm a) (E.symm b) x h }", "start": [67, 1], "end": [75, 79], "kind": "commanddeclaration"}, {"full_name": "Ctop.ofEquiv_val", "code": "@[simp]\ntheorem ofEquiv_val (E : \u03c3 \u2243 \u03c4) (F : Ctop \u03b1 \u03c3) (a : \u03c4) : F.ofEquiv E a = F (E.symm a)", "start": [78, 1], "end": [80, 15], "kind": "commanddeclaration"}, {"full_name": "Ctop.toTopsp", "code": "def toTopsp (F : Ctop \u03b1 \u03c3) : TopologicalSpace \u03b1 := TopologicalSpace.generateFrom (Set.range F.f)", "start": [85, 1], "end": [86, 97], "kind": "commanddeclaration"}, {"full_name": "Ctop.toTopsp_isTopologicalBasis", "code": "theorem toTopsp_isTopologicalBasis (F : Ctop \u03b1 \u03c3) :\n    @TopologicalSpace.IsTopologicalBasis _ F.toTopsp (Set.range F.f)", "start": [89, 1], "end": [94, 66], "kind": "commanddeclaration"}, {"full_name": "Ctop.mem_nhds_toTopsp", "code": "@[simp]\ntheorem mem_nhds_toTopsp (F : Ctop \u03b1 \u03c3) {s : Set \u03b1} {a : \u03b1} :\n    s \u2208 @nhds _ F.toTopsp a \u2194 \u2203 b, a \u2208 F b \u2227 F b \u2286 s", "start": [97, 1], "end": [102, 67], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer", "code": "structure Ctop.Realizer (\u03b1) [T : TopologicalSpace \u03b1] where\n  \u03c3 : Type*\n  F : Ctop \u03b1 \u03c3\n  eq : F.toTopsp = T", "start": [107, 1], "end": [112, 21], "kind": "commanddeclaration"}, {"full_name": "Ctop.toRealizer", "code": "protected def Ctop.toRealizer (F : Ctop \u03b1 \u03c3) : @Ctop.Realizer _ F.toTopsp :=\n  @Ctop.Realizer.mk _ F.toTopsp \u03c3 F rfl", "start": [117, 1], "end": [119, 40], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.is_basis", "code": "protected theorem is_basis [T : TopologicalSpace \u03b1] (F : Realizer \u03b1) :\n    TopologicalSpace.IsTopologicalBasis (Set.range F.F.f)", "start": [127, 1], "end": [129, 61], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.mem_nhds", "code": "protected theorem mem_nhds [T : TopologicalSpace \u03b1] (F : Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    s \u2208 \ud835\udcdd a \u2194 \u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s", "start": [132, 1], "end": [134, 60], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.isOpen_iff", "code": "theorem isOpen_iff [TopologicalSpace \u03b1] (F : Realizer \u03b1) {s : Set \u03b1} :\n    IsOpen s \u2194 \u2200 a \u2208 s, \u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s", "start": [137, 1], "end": [139, 65], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.isClosed_iff", "code": "theorem isClosed_iff [TopologicalSpace \u03b1] (F : Realizer \u03b1) {s : Set \u03b1} :\n    IsClosed s \u2194 \u2200 a, (\u2200 b, a \u2208 F.F b \u2192 \u2203 z, z \u2208 F.F b \u2229 s) \u2192 a \u2208 s", "start": [142, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.mem_interior_iff", "code": "theorem mem_interior_iff [TopologicalSpace \u03b1] (F : Realizer \u03b1) {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 interior s \u2194 \u2203 b, a \u2208 F.F b \u2227 F.F b \u2286 s", "start": [152, 1], "end": [154, 45], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.isOpen", "code": "protected theorem isOpen [TopologicalSpace \u03b1] (F : Realizer \u03b1) (s : F.\u03c3) : IsOpen (F.F s)", "start": [157, 1], "end": [158, 80], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.ext'", "code": "theorem ext' [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3}\n    (H : \u2200 a s, s \u2208 \ud835\udcdd a \u2194 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) : F.toTopsp = T", "start": [161, 1], "end": [165, 27], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.ext", "code": "theorem ext [T : TopologicalSpace \u03b1] {\u03c3 : Type*} {F : Ctop \u03b1 \u03c3} (H\u2081 : \u2200 a, IsOpen (F a))\n    (H\u2082 : \u2200 a s, s \u2208 \ud835\udcdd a \u2192 \u2203 b, a \u2208 F b \u2227 F b \u2286 s) : F.toTopsp = T", "start": [168, 1], "end": [170, 79], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.id", "code": "protected noncomputable def id : Realizer \u03b1 :=\n  \u27e8{ x : Set \u03b1 // IsOpen x },\n    { f := Subtype.val\n      top := fun _ \u21a6 \u27e8univ, isOpen_univ\u27e9\n      top_mem := mem_univ\n      inter := fun \u27e8_x, h\u2081\u27e9 \u27e8_y, h\u2082\u27e9 _a _h\u2083 \u21a6 \u27e8_, h\u2081.inter h\u2082\u27e9\n      inter_mem := fun \u27e8_x, _h\u2081\u27e9 \u27e8_y, _h\u2082\u27e9 _a \u21a6 id\n      inter_sub := fun \u27e8_x, _h\u2081\u27e9 \u27e8_y, _h\u2082\u27e9 _a _h\u2083 \u21a6 Subset.refl _ },\n    ext Subtype.property fun _x _s h \u21a6\n      let \u27e8t, h, o, m\u27e9 := mem_nhds_iff.1 h\n      \u27e8\u27e8t, o\u27e9, m, h\u27e9\u27e9", "start": [177, 1], "end": [188, 22], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.ofEquiv", "code": "def ofEquiv (F : Realizer \u03b1) (E : F.\u03c3 \u2243 \u03c4) : Realizer \u03b1 :=\n  \u27e8\u03c4, F.F.ofEquiv E,\n    ext' fun a s \u21a6\n      F.mem_nhds.trans <|\n        \u27e8fun \u27e8s, h\u27e9 \u21a6 \u27e8E s, by simpa using h\u27e9, fun \u27e8t, h\u27e9 \u21a6 \u27e8E.symm t, by simpa using h\u27e9\u27e9\u27e9", "start": [191, 1], "end": [196, 91], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.ofEquiv_\u03c3", "code": "@[simp]\ntheorem ofEquiv_\u03c3 (F : Realizer \u03b1) (E : F.\u03c3 \u2243 \u03c4) : (F.ofEquiv E).\u03c3 = \u03c4", "start": [199, 1], "end": [200, 78], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.ofEquiv_F", "code": "@[simp]\ntheorem ofEquiv_F (F : Realizer \u03b1) (E : F.\u03c3 \u2243 \u03c4) (s : \u03c4) : (F.ofEquiv E).F s = F.F (E.symm s)", "start": [203, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.nhds", "code": "protected def nhds (F : Realizer \u03b1) (a : \u03b1) : (\ud835\udcdd a).Realizer :=\n  \u27e8{ s : F.\u03c3 // a \u2208 F.F s },\n    { f := fun s \u21a6 F.F s.1\n      pt := \u27e8_, F.F.top_mem a\u27e9\n      inf := fun \u27e8x, h\u2081\u27e9 \u27e8y, h\u2082\u27e9 \u21a6 \u27e8_, F.F.inter_mem x y a \u27e8h\u2081, h\u2082\u27e9\u27e9\n      inf_le_left := fun \u27e8x, h\u2081\u27e9 \u27e8y, h\u2082\u27e9 _z h \u21a6 (F.F.inter_sub x y a \u27e8h\u2081, h\u2082\u27e9 h).1\n      inf_le_right := fun \u27e8x, h\u2081\u27e9 \u27e8y, h\u2082\u27e9 _z h \u21a6 (F.F.inter_sub x y a \u27e8h\u2081, h\u2082\u27e9 h).2 },\n    filter_eq <|\n      Set.ext fun _x \u21a6\n        \u27e8fun \u27e8\u27e8_s, as\u27e9, h\u27e9 \u21a6 mem_nhds_iff.2 \u27e8_, h, F.isOpen _, as\u27e9, fun h \u21a6\n          let \u27e8s, h, as\u27e9 := F.mem_nhds.1 h\n          \u27e8\u27e8s, h\u27e9, as\u27e9\u27e9\u27e9", "start": [209, 1], "end": [221, 25], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.nhds_\u03c3", "code": "@[simp]\ntheorem nhds_\u03c3 (F : Realizer \u03b1) (a : \u03b1) : (F.nhds a).\u03c3 = { s : F.\u03c3 // a \u2208 F.F s }", "start": [224, 1], "end": [225, 89], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.nhds_F", "code": "@[simp]\ntheorem nhds_F (F : Realizer \u03b1) (a : \u03b1) (s) : (F.nhds a).F s = F.F s.1", "start": [228, 1], "end": [229, 78], "kind": "commanddeclaration"}, {"full_name": "Ctop.Realizer.tendsto_nhds_iff", "code": "theorem tendsto_nhds_iff {m : \u03b2 \u2192 \u03b1} {f : Filter \u03b2} (F : f.Realizer) (R : Realizer \u03b1) {a : \u03b1} :\n    Tendsto m f (\ud835\udcdd a) \u2194 \u2200 t, a \u2208 R.F t \u2192 \u2203 s, \u2200 x \u2208 F.F s, m x \u2208 R.F t", "start": [233, 1], "end": [235, 52], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.Realizer", "code": "structure LocallyFinite.Realizer [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1) (f : \u03b2 \u2192 Set \u03b1) where\n  bas : \u2200 a, { s // a \u2208 F.F s }\n  sets : \u2200 x : \u03b1, Fintype { i | (f i \u2229 F.F (bas x)).Nonempty }", "start": [240, 1], "end": [245, 63], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.Realizer.to_locallyFinite", "code": "theorem LocallyFinite.Realizer.to_locallyFinite [TopologicalSpace \u03b1] {F : Ctop.Realizer \u03b1}\n    {f : \u03b2 \u2192 Set \u03b1} (R : LocallyFinite.Realizer F f) : LocallyFinite f", "start": [248, 1], "end": [250, 74], "kind": "commanddeclaration"}, {"full_name": "locallyFinite_iff_exists_realizer", "code": "theorem locallyFinite_iff_exists_realizer [TopologicalSpace \u03b1] (F : Ctop.Realizer \u03b1)\n    {f : \u03b2 \u2192 Set \u03b1} : LocallyFinite f \u2194 Nonempty (LocallyFinite.Realizer F f)", "start": [253, 1], "end": [266, 34], "kind": "commanddeclaration"}, {"full_name": "Compact.Realizer", "code": "def Compact.Realizer [TopologicalSpace \u03b1] (s : Set \u03b1) :=\n  \u2200 {f : Filter \u03b1} (F : f.Realizer) (x : F.\u03c3), f \u2260 \u22a5 \u2192 F.F x \u2286 s \u2192 { a // a \u2208 s \u2227 \ud835\udcdd a \u2293 f \u2260 \u22a5 }", "start": [273, 1], "end": [276, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/ChevalleyWarning.lean", "imports": ["Mathlib/FieldTheory/Finite/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.sum_eval_eq_zero", "code": "theorem MvPolynomial.sum_eval_eq_zero (f : MvPolynomial \u03c3 K)\n    (h : f.totalDegree < (q - 1) * Fintype.card \u03c3) : \u2211 x, eval x f = 0", "start": [55, 1], "end": [99, 50], "kind": "commanddeclaration"}, {"full_name": "char_dvd_card_solutions_of_sum_lt", "code": "theorem char_dvd_card_solutions_of_sum_lt {s : Finset \u03b9} {f : \u03b9 \u2192 MvPolynomial \u03c3 K}\n    (h : (\u2211 i in s, (f i).totalDegree) < Fintype.card \u03c3) :\n    p \u2223 Fintype.card { x : \u03c3 \u2192 K // \u2200 i \u2208 s, eval x (f i) = 0 }", "start": [104, 1], "end": [162, 59], "kind": "commanddeclaration"}, {"full_name": "char_dvd_card_solutions_of_fintype_sum_lt", "code": "theorem char_dvd_card_solutions_of_fintype_sum_lt [Fintype \u03b9] {f : \u03b9 \u2192 MvPolynomial \u03c3 K}\n    (h : (\u2211 i, (f i).totalDegree) < Fintype.card \u03c3) :\n    p \u2223 Fintype.card { x : \u03c3 \u2192 K // \u2200 i, eval x (f i) = 0 }", "start": [165, 1], "end": [173, 52], "kind": "commanddeclaration"}, {"full_name": "char_dvd_card_solutions", "code": "theorem char_dvd_card_solutions {f : MvPolynomial \u03c3 K} (h : f.totalDegree < Fintype.card \u03c3) :\n    p \u2223 Fintype.card { x : \u03c3 \u2192 K // eval x f = 0 }", "start": [176, 1], "end": [190, 8], "kind": "commanddeclaration"}, {"full_name": "char_dvd_card_solutions_of_add_lt", "code": "theorem char_dvd_card_solutions_of_add_lt {f\u2081 f\u2082 : MvPolynomial \u03c3 K}\n    (h : f\u2081.totalDegree + f\u2082.totalDegree < Fintype.card \u03c3) :\n    p \u2223 Fintype.card { x : \u03c3 \u2192 K // eval x f\u2081 = 0 \u2227 eval x f\u2082 = 0 }", "start": [193, 1], "end": [203, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Graph.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/ModelTheory/Satisfiability.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.graph", "code": "protected def graph : Language :=\n  Language.mk\u2082 Empty Empty Empty Empty Unit", "start": [43, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.adj", "code": "def adj : Language.graph.Relations 2 :=\n  Unit.unit", "start": [48, 1], "end": [50, 12], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.structure", "code": "def _root_.SimpleGraph.structure (G : SimpleGraph V) : Language.graph.Structure V :=\n  Structure.mk\u2082 Empty.elim Empty.elim Empty.elim Empty.elim fun _ => G.Adj", "start": [53, 1], "end": [55, 75], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.graph.instIsRelational", "code": "instance instIsRelational : IsRelational Language.graph :=\n  Language.isRelational_mk\u2082", "start": [60, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.graph.instSubsingleton", "code": "instance instSubsingleton : Subsingleton (Language.graph.Relations n) :=\n  Language.subsingleton_mk\u2082_relations", "start": [64, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.simpleGraph", "code": "protected def Theory.simpleGraph : Language.graph.Theory :=\n  {adj.irreflexive, adj.symmetric}", "start": [70, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.simpleGraph_model_iff", "code": "@[simp]\ntheorem Theory.simpleGraph_model_iff [Language.graph.Structure V] :\n    V \u22a8 Theory.simpleGraph \u2194\n      (Irreflexive fun x y : V => RelMap adj ![x, y]) \u2227\n        Symmetric fun x y : V => RelMap adj ![x, y]", "start": [75, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.simpleGraph_model", "code": "instance simpleGraph_model (G : SimpleGraph V) :\n    @Theory.Model _ V G.structure Theory.simpleGraph := by\n  simp only [@Theory.simpleGraph_model_iff _ G.structure, relMap_apply\u2082]\n  exact \u27e8G.loopless, G.symm\u27e9", "start": [83, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.simpleGraphOfStructure", "code": "@[simps]\ndef simpleGraphOfStructure [Language.graph.Structure V] [V \u22a8 Theory.simpleGraph] :\n    SimpleGraph V where\n  Adj x y := RelMap adj ![x, y]\n  symm :=\n    Relations.realize_symmetric.1\n      (Theory.realize_sentence_of_mem Theory.simpleGraph\n        (Set.mem_insert_of_mem _ (Set.mem_singleton _)))\n  loopless :=\n    Relations.realize_irreflexive.1\n      (Theory.realize_sentence_of_mem Theory.simpleGraph (Set.mem_insert _ _))", "start": [91, 1], "end": [102, 79], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.simpleGraphOfStructure", "code": "@[simp]\ntheorem _root_.SimpleGraph.simpleGraphOfStructure (G : SimpleGraph V) :\n    @simpleGraphOfStructure V G.structure _ = G", "start": [107, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.structure_simpleGraphOfStructure", "code": "@[simp]\ntheorem structure_simpleGraphOfStructure [S : Language.graph.Structure V] [V \u22a8 Theory.simpleGraph] :\n    (simpleGraphOfStructure V).structure = S", "start": [114, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.simpleGraph_isSatisfiable", "code": "theorem Theory.simpleGraph_isSatisfiable : Theory.IsSatisfiable Theory.simpleGraph", "start": [134, 1], "end": [135, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ProbabilityMassFunction/Uniform.lean", "imports": ["Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PMF.uniformOfFinset", "code": "def uniformOfFinset (s : Finset \u03b1) (hs : s.Nonempty) : PMF \u03b1 := by\n  refine' ofFinset (fun a => if a \u2208 s then s.card\u207b\u00b9 else 0) s _ _\n  \u00b7 simp only [Finset.sum_ite_mem, Finset.inter_self, Finset.sum_const, nsmul_eq_mul]\n    have : (s.card : \u211d\u22650\u221e) \u2260 0 := by\n      simpa only [Ne.def, Nat.cast_eq_zero, Finset.card_eq_zero] using\n        Finset.nonempty_iff_ne_empty.1 hs\n    refine' ENNReal.mul_inv_cancel this <| ENNReal.nat_ne_top s.card\n  \u00b7 exact fun x hx => by simp only [hx, if_false]", "start": [37, 1], "end": [45, 50], "kind": "commanddeclaration"}, {"full_name": "PMF.uniformOfFinset_apply", "code": "@[simp]\ntheorem uniformOfFinset_apply (a : \u03b1) :\n    uniformOfFinset s hs a = if a \u2208 s then (s.card : \u211d\u22650\u221e)\u207b\u00b9 else 0", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "PMF.uniformOfFinset_apply_of_mem", "code": "theorem uniformOfFinset_apply_of_mem (ha : a \u2208 s) : uniformOfFinset s hs a = (s.card : \u211d\u22650\u221e)\u207b\u00b9", "start": [56, 1], "end": [57, 12], "kind": "commanddeclaration"}, {"full_name": "PMF.uniformOfFinset_apply_of_not_mem", "code": "theorem uniformOfFinset_apply_of_not_mem (ha : a \u2209 s) : uniformOfFinset s hs a = 0", "start": [60, 1], "end": [60, 99], "kind": "commanddeclaration"}, {"full_name": "PMF.support_uniformOfFinset", "code": "@[simp]\ntheorem support_uniformOfFinset : (uniformOfFinset s hs).support = s", "start": [63, 1], "end": [68, 57], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_uniformOfFinset_iff", "code": "theorem mem_support_uniformOfFinset_iff (a : \u03b1) : a \u2208 (uniformOfFinset s hs).support \u2194 a \u2208 s", "start": [71, 1], "end": [72, 7], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_uniformOfFinset_apply", "code": "@[simp]\ntheorem toOuterMeasure_uniformOfFinset_apply :\n    (uniformOfFinset s hs).toOuterMeasure t = (s.filter (\u00b7 \u2208 t)).card / s.card", "start": [79, 1], "end": [94, 67], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_uniformOfFinset_apply", "code": "@[simp]\ntheorem toMeasure_uniformOfFinset_apply [MeasurableSpace \u03b1] (ht : MeasurableSet t) :\n    (uniformOfFinset s hs).toMeasure t = (s.filter (\u00b7 \u2208 t)).card / s.card", "start": [98, 1], "end": [101, 101], "kind": "commanddeclaration"}, {"full_name": "PMF.uniformOfFintype", "code": "def uniformOfFintype (\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] : PMF \u03b1 :=\n  uniformOfFinset Finset.univ Finset.univ_nonempty", "start": [110, 1], "end": [112, 51], "kind": "commanddeclaration"}, {"full_name": "PMF.uniformOfFintype_apply", "code": "@[simp]\ntheorem uniformOfFintype_apply (a : \u03b1) : uniformOfFintype \u03b1 a = (Fintype.card \u03b1 : \u211d\u22650\u221e)\u207b\u00b9", "start": [117, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "PMF.support_uniformOfFintype", "code": "@[simp]\ntheorem support_uniformOfFintype (\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] :\n    (uniformOfFintype \u03b1).support = \u22a4", "start": [123, 1], "end": [126, 45], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_uniformOfFintype", "code": "theorem mem_support_uniformOfFintype (a : \u03b1) : a \u2208 (uniformOfFintype \u03b1).support", "start": [129, 1], "end": [129, 91], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_uniformOfFintype_apply", "code": "theorem toOuterMeasure_uniformOfFintype_apply :\n    (uniformOfFintype \u03b1).toOuterMeasure s = Fintype.card s / Fintype.card \u03b1", "start": [136, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_uniformOfFintype_apply", "code": "theorem toMeasure_uniformOfFintype_apply [MeasurableSpace \u03b1] (hs : MeasurableSet s) :\n    (uniformOfFintype \u03b1).toMeasure s = Fintype.card s / Fintype.card \u03b1", "start": [142, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "PMF.ofMultiset", "code": "def ofMultiset (s : Multiset \u03b1) (hs : s \u2260 0) : PMF \u03b1 :=\n  \u27e8fun a => s.count a / (Multiset.card s),\n    ENNReal.summable.hasSum_iff.2\n      (calc\n        (\u2211' b : \u03b1, (s.count b : \u211d\u22650\u221e) / (Multiset.card s))\n          = (Multiset.card s : \u211d\u22650\u221e)\u207b\u00b9 * \u2211' b, (s.count b : \u211d\u22650\u221e) := by\n            simp_rw [ENNReal.div_eq_inv_mul, ENNReal.tsum_mul_left]\n        _ = (Multiset.card s : \u211d\u22650\u221e)\u207b\u00b9 * \u2211 b in s.toFinset, (s.count b : \u211d\u22650\u221e) :=\n          (congr_arg (fun x => (Multiset.card s : \u211d\u22650\u221e)\u207b\u00b9 * x)\n            (tsum_eq_sum fun a ha =>\n              Nat.cast_eq_zero.2 <| by rwa [Multiset.count_eq_zero, \u2190 Multiset.mem_toFinset]))\n        _ = 1 := by\n          rw [\u2190 Nat.cast_sum, Multiset.toFinset_sum_count_eq s,\n            ENNReal.inv_mul_cancel (Nat.cast_ne_zero.2 (hs \u2218 Multiset.card_eq_zero.1))\n              (ENNReal.nat_ne_top _)]\n        )\u27e9", "start": [154, 1], "end": [171, 11], "kind": "commanddeclaration"}, {"full_name": "PMF.ofMultiset_apply", "code": "@[simp]\ntheorem ofMultiset_apply (a : \u03b1) : ofMultiset s hs a = s.count a / (Multiset.card s)", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "PMF.support_ofMultiset", "code": "@[simp]\ntheorem support_ofMultiset : (ofMultiset s hs).support = s.toFinset", "start": [181, 1], "end": [183, 42], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_ofMultiset_iff", "code": "theorem mem_support_ofMultiset_iff (a : \u03b1) : a \u2208 (ofMultiset s hs).support \u2194 a \u2208 s.toFinset", "start": [186, 1], "end": [187, 7], "kind": "commanddeclaration"}, {"full_name": "PMF.ofMultiset_apply_of_not_mem", "code": "theorem ofMultiset_apply_of_not_mem {a : \u03b1} (ha : a \u2209 s) : ofMultiset s hs a = 0", "start": [190, 1], "end": [192, 47], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_ofMultiset_apply", "code": "@[simp]\ntheorem toOuterMeasure_ofMultiset_apply :\n    (ofMultiset s hs).toOuterMeasure t =\n      (\u2211' x, (s.filter (\u00b7 \u2208 t)).count x : \u211d\u22650\u221e) / (Multiset.card s)", "start": [199, 1], "end": [205, 67], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_ofMultiset_apply", "code": "@[simp]\ntheorem toMeasure_ofMultiset_apply [MeasurableSpace \u03b1] (ht : MeasurableSet t) :\n    (ofMultiset s hs).toMeasure t = (\u2211' x, (s.filter (\u00b7 \u2208 t)).count x : \u211d\u22650\u221e) / (Multiset.card s)", "start": [208, 1], "end": [211, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Independent.lean", "imports": ["Mathlib/Analysis/Convex/Extreme.lean", "Mathlib/Analysis/Convex/Combination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexIndependent", "code": "def ConvexIndependent (p : \u03b9 \u2192 E) : Prop :=\n  \u2200 (s : Set \u03b9) (x : \u03b9), p x \u2208 convexHull \ud835\udd5c (p '' s) \u2192 x \u2208 s", "start": [55, 1], "end": [58, 61], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.convexIndependent", "code": "theorem Subsingleton.convexIndependent [Subsingleton \u03b9] (p : \u03b9 \u2192 E) : ConvexIndependent \ud835\udd5c p", "start": [63, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.injective", "code": "protected theorem ConvexIndependent.injective {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p) :\n    Function.Injective p", "start": [71, 1], "end": [76, 28], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.comp_embedding", "code": "theorem ConvexIndependent.comp_embedding {\u03b9' : Type*} (f : \u03b9' \u21aa \u03b9) {p : \u03b9 \u2192 E}\n    (hc : ConvexIndependent \ud835\udd5c p) : ConvexIndependent \ud835\udd5c (p \u2218 f)", "start": [79, 1], "end": [85, 42], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.subtype", "code": "protected theorem ConvexIndependent.subtype {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p) (s : Set \u03b9) :\n    ConvexIndependent \ud835\udd5c fun i : s => p i", "start": [88, 1], "end": [92, 42], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.range", "code": "protected theorem ConvexIndependent.range {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p) :\n    ConvexIndependent \ud835\udd5c ((\u2191) : Set.range p \u2192 E)", "start": [95, 1], "end": [103, 42], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.mono", "code": "protected theorem ConvexIndependent.mono {s t : Set E} (hc : ConvexIndependent \ud835\udd5c ((\u2191) : t \u2192 E))\n    (hs : s \u2286 t) : ConvexIndependent \ud835\udd5c ((\u2191) : s \u2192 E)", "start": [106, 1], "end": [109, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.convexIndependent_iff_set", "code": "theorem Function.Injective.convexIndependent_iff_set {p : \u03b9 \u2192 E} (hi : Function.Injective p) :\n    ConvexIndependent \ud835\udd5c ((\u2191) : Set.range p \u2192 E) \u2194 ConvexIndependent \ud835\udd5c p", "start": [112, 1], "end": [119, 29], "kind": "commanddeclaration"}, {"full_name": "ConvexIndependent.mem_convexHull_iff", "code": "@[simp]\nprotected theorem ConvexIndependent.mem_convexHull_iff {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p)\n    (s : Set \u03b9) (i : \u03b9) : p i \u2208 convexHull \ud835\udd5c (p '' s) \u2194 i \u2208 s", "start": [122, 1], "end": [127, 72], "kind": "commanddeclaration"}, {"full_name": "convexIndependent_iff_not_mem_convexHull_diff", "code": "theorem convexIndependent_iff_not_mem_convexHull_diff {p : \u03b9 \u2192 E} :\n    ConvexIndependent \ud835\udd5c p \u2194 \u2200 i s, p i \u2209 convexHull \ud835\udd5c (p '' (s \\ {i}))", "start": [130, 1], "end": [140, 13], "kind": "commanddeclaration"}, {"full_name": "convexIndependent_set_iff_inter_convexHull_subset", "code": "theorem convexIndependent_set_iff_inter_convexHull_subset {s : Set E} :\n    ConvexIndependent \ud835\udd5c ((\u2191) : s \u2192 E) \u2194 \u2200 t, t \u2286 s \u2192 s \u2229 convexHull \ud835\udd5c t \u2286 t", "start": [143, 1], "end": [152, 80], "kind": "commanddeclaration"}, {"full_name": "convexIndependent_set_iff_not_mem_convexHull_diff", "code": "theorem convexIndependent_set_iff_not_mem_convexHull_diff {s : Set E} :\n    ConvexIndependent \ud835\udd5c ((\u2191) : s \u2192 E) \u2194 \u2200 x \u2208 s, x \u2209 convexHull \ud835\udd5c (s \\ {x})", "start": [155, 1], "end": [165, 74], "kind": "commanddeclaration"}, {"full_name": "convexIndependent_iff_finset", "code": "theorem convexIndependent_iff_finset {p : \u03b9 \u2192 E} :\n    ConvexIndependent \ud835\udd5c p \u2194\n      \u2200 (s : Finset \u03b9) (x : \u03b9), p x \u2208 convexHull \ud835\udd5c (s.image p : Set E) \u2192 x \u2208 s", "start": [174, 1], "end": [194, 66], "kind": "commanddeclaration"}, {"full_name": "Convex.convexIndependent_extremePoints", "code": "theorem Convex.convexIndependent_extremePoints (hs : Convex \ud835\udd5c s) :\n    ConvexIndependent \ud835\udd5c ((\u2191) : s.extremePoints \ud835\udd5c \u2192 E)", "start": [200, 1], "end": [206, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Json.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Condensed/Equivalence.lean", "imports": ["Mathlib/CategoryTheory/Sites/Closed.lean", "Mathlib/CategoryTheory/Sites/DenseSubsite.lean", "Mathlib/Condensed/Basic.lean", "Mathlib/Topology/Category/Profinite/EffectiveEpi.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Sites/InducedTopology.lean", "Mathlib/Topology/Category/Stonean/EffectiveEpi.lean"], "premises": [{"full_name": "Condensed.StoneanCompHaus.generate_singleton_mem_coherentTopology", "code": "lemma generate_singleton_mem_coherentTopology (B : CompHaus) :\n    Sieve.generate (Presieve.singleton (presentation.\u03c0 B)) \u2208 coherentTopology CompHaus B := by\n  apply Coverage.saturate.of\n  refine \u27e8Unit, inferInstance, fun _ => (Stonean.toCompHaus.obj B.presentation),\n    fun _ => (presentation.\u03c0 B), ?_ , ?_\u27e9\n  \u00b7 funext X f\n    ext\n    refine \u27e8fun \u27e8\u27e9 \u21a6 \u27e8()\u27e9, ?_\u27e9\n    rintro \u27e8\u27e9\n    simp only [Presieve.singleton_eq_iff_domain]\n  \u00b7 apply ((effectiveEpiFamily_tfae\n      (fun (_ : Unit) => (Stonean.toCompHaus.obj B.presentation))\n      (fun (_ : Unit) => (CompHaus.presentation.\u03c0 B))).out 0 2).mpr\n    intro b\n    exact \u27e8(), (CompHaus.epi_iff_surjective (presentation.\u03c0 B)).mp (presentation.epi_\u03c0 B) b\u27e9", "start": [50, 1], "end": [64, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanCompHaus.coverDense", "code": "lemma coverDense : CoverDense (coherentTopology _) Stonean.toCompHaus := by\n  constructor\n  intro B\n  convert generate_singleton_mem_coherentTopology B\n  ext Y f\n  refine \u27e8fun \u27e8\u27e8obj, lift, map, fact\u27e9\u27e9 \u21a6 ?_, fun \u27e8Z, h, g, hypo1, hf\u27e9 \u21a6 ?_\u27e9\n  \u00b7 have : Projective (Stonean.toCompHaus.obj obj) \u00b7 simp only [Stonean.toCompHaus, inducedFunctor_obj]\n      exact inferInstance\n    obtain \u27e8p, p_factors\u27e9 := Projective.factors map (CompHaus.presentation.\u03c0 B)\n    exact \u27e8(Stonean.toCompHaus.obj (presentation B)), \u27e8lift \u226b p, \u27e8(presentation.\u03c0 B),\n      \u27e8Presieve.singleton.mk, by rw [Category.assoc, p_factors, fact]\u27e9\u27e9\u27e9\u27e9\n  \u00b7 cases hypo1\n    exact \u27e8\u27e8presentation B, h, presentation.\u03c0 B, hf\u27e9\u27e9", "start": [67, 1], "end": [80, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanCompHaus.coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily", "code": "theorem coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily (X : Stonean) (S : Sieve X) :\n    (\u2203 (\u03b1 : Type) (_ : Fintype \u03b1) (Y : \u03b1 \u2192 Stonean) (\u03c0 : (a : \u03b1) \u2192 (Y a \u27f6 X)),\n    EffectiveEpiFamily Y \u03c0 \u2227 (\u2200 a : \u03b1, (S.arrows) (\u03c0 a)) ) \u2194\n    (S \u2208 coverDense.inducedTopology X)", "start": [82, 1], "end": [106, 8], "kind": "commanddeclaration"}, {"full_name": "Condensed.StoneanCompHaus.coherentTopology_is_induced", "code": "lemma coherentTopology_is_induced :\n    coherentTopology Stonean.{u} = coverDense.inducedTopology := by\n  ext X S\n  rw [\u2190 coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily X]\n  rw [\u2190 coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily S]", "start": [108, 1], "end": [112, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanCompHaus.coverPreserving", "code": "lemma coverPreserving :\n    CoverPreserving (coherentTopology _) (coherentTopology _) Stonean.toCompHaus := by\n  rw [coherentTopology_is_induced]\n  exact LocallyCoverDense.inducedTopology_coverPreserving (CoverDense.locallyCoverDense coverDense)", "start": [114, 1], "end": [117, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanCompHaus.coverLifting", "code": "lemma coverLifting : CoverLifting (coherentTopology _) (coherentTopology _) Stonean.toCompHaus := by\n  rw [coherentTopology_is_induced]\n  exact LocallyCoverDense.inducedTopology_coverLifting (CoverDense.locallyCoverDense coverDense)", "start": [119, 1], "end": [121, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanCompHaus.equivalence", "code": "noncomputable\ndef equivalence (A : Type _) [Category.{u+1} A] [HasLimits A] :\n    Sheaf (coherentTopology Stonean) A \u224c Condensed.{u} A :=\n  CoverDense.sheafEquivOfCoverPreservingCoverLifting coverDense coverPreserving coverLifting", "start": [123, 1], "end": [128, 93], "kind": "commanddeclaration"}, {"full_name": "Condensed.StoneanProfinite.generate_singleton_mem_coherentTopology", "code": "lemma generate_singleton_mem_coherentTopology (B : Profinite) :\n    Sieve.generate (Presieve.singleton (presentation.\u03c0 B)) \u2208 coherentTopology Profinite B := by\n  apply Coverage.saturate.of\n  refine \u27e8Unit, inferInstance, fun _ => (Stonean.toProfinite.obj B.presentation),\n    fun _ => (presentation.\u03c0 B), ?_ , ?_\u27e9\n  \u00b7 funext X f\n    ext\n    refine \u27e8fun \u27e8\u27e9 \u21a6 \u27e8()\u27e9, ?_\u27e9\n    rintro \u27e8\u27e9\n    simp only [Presieve.singleton_eq_iff_domain]\n  \u00b7 apply ((effectiveEpiFamily_tfae\n      (fun (_ : Unit) => (Stonean.toProfinite.obj B.presentation))\n      (fun (_ : Unit) => (Profinite.presentation.\u03c0 B))).out 0 2).mpr\n    intro b\n    exact \u27e8(), (Profinite.epi_iff_surjective (presentation.\u03c0 B)).mp (presentation.epi_\u03c0 B) b\u27e9", "start": [141, 1], "end": [155, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanProfinite.coverDense", "code": "lemma coverDense : CoverDense (coherentTopology _) Stonean.toProfinite := by\n  constructor\n  intro B\n  convert generate_singleton_mem_coherentTopology B\n  ext Y f\n  refine \u27e8fun \u27e8\u27e8obj, lift, map, fact\u27e9\u27e9 \u21a6 ?_, fun \u27e8Z, h, g, hypo1, hf\u27e9 \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8p, p_factors\u27e9 := Projective.factors map (Profinite.presentation.\u03c0 B)\n    exact \u27e8(Stonean.toProfinite.obj (presentation B)), \u27e8lift \u226b p, \u27e8(presentation.\u03c0 B),\n      \u27e8Presieve.singleton.mk, by rw [Category.assoc, p_factors, fact]\u27e9\u27e9\u27e9\u27e9\n  \u00b7 cases hypo1\n    exact \u27e8\u27e8presentation B, h, presentation.\u03c0 B, hf\u27e9\u27e9", "start": [158, 1], "end": [168, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanProfinite.coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily", "code": "theorem coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily (X : Stonean) (S : Sieve X) :\n    (\u2203 (\u03b1 : Type) (_ : Fintype \u03b1) (Y : \u03b1 \u2192 Stonean) (\u03c0 : (a : \u03b1) \u2192 (Y a \u27f6 X)),\n    EffectiveEpiFamily Y \u03c0 \u2227 (\u2200 a : \u03b1, (S.arrows) (\u03c0 a)) ) \u2194\n    (S \u2208 coverDense.inducedTopology X)", "start": [170, 1], "end": [194, 8], "kind": "commanddeclaration"}, {"full_name": "Condensed.StoneanProfinite.coherentTopology_is_induced", "code": "lemma coherentTopology_is_induced :\n    coherentTopology Stonean.{u} = coverDense.inducedTopology := by\n  ext X S\n  rw [\u2190 coverDense.inducedTopology_Sieve_iff_EffectiveEpiFamily X,\n    \u2190 coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily S]", "start": [196, 1], "end": [200, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanProfinite.coverPreserving", "code": "lemma coverPreserving :\n    CoverPreserving (coherentTopology _) (coherentTopology _) Stonean.toProfinite := by\n  rw [coherentTopology_is_induced]\n  exact LocallyCoverDense.inducedTopology_coverPreserving (CoverDense.locallyCoverDense coverDense)", "start": [202, 1], "end": [205, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanProfinite.coverLifting", "code": "lemma coverLifting :\n    CoverLifting (coherentTopology _) (coherentTopology _) Stonean.toProfinite := by\n  rw [coherentTopology_is_induced]\n  exact LocallyCoverDense.inducedTopology_coverLifting (CoverDense.locallyCoverDense coverDense)", "start": [207, 1], "end": [210, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Condensed.StoneanProfinite.equivalence", "code": "noncomputable\ndef equivalence (A : Type _) [Category.{u+1} A] [HasLimits A] :\n    Sheaf (coherentTopology Stonean) A \u224c Sheaf (coherentTopology Profinite) A :=\n  CoverDense.sheafEquivOfCoverPreservingCoverLifting coverDense coverPreserving coverLifting", "start": [212, 1], "end": [216, 93], "kind": "commanddeclaration"}, {"full_name": "Condensed.ProfiniteCompHaus.equivalence", "code": "noncomputable\ndef ProfiniteCompHaus.equivalence (A : Type _) [Category.{u+1} A] [HasLimits A] :\n    Sheaf (coherentTopology Profinite) A \u224c Condensed.{u} A :=\n  (StoneanProfinite.equivalence A).symm.trans (StoneanCompHaus.equivalence A)", "start": [220, 1], "end": [225, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/ProperConstSMul.lean", "imports": ["Mathlib/Topology/ProperMap.lean", "Mathlib/Topology/Algebra/ConstMulAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProperConstVAdd", "code": "class ProperConstVAdd (M X : Type*) [VAdd M X] [TopologicalSpace X] : Prop where\n  \n  isProperMap_vadd (c : M) : IsProperMap ((c +\u1d65 \u00b7) : X \u2192 X)", "start": [24, 1], "end": [29, 60], "kind": "commanddeclaration"}, {"full_name": "ProperConstSMul", "code": "@[to_additive]\nclass ProperConstSMul (M X : Type*) [SMul M X] [TopologicalSpace X] : Prop where\n  \n  isProperMap_smul (c : M) : IsProperMap ((c \u2022 \u00b7) : X \u2192 X)", "start": [31, 1], "end": [37, 59], "kind": "commanddeclaration"}, {"full_name": "isProperMap_smul", "code": "@[to_additive \"`(c +\u1d65 \u00b7)` is a proper map.\"]\ntheorem isProperMap_smul {M : Type*} (c : M) (X : Type*) [SMul M X] [TopologicalSpace X]\n    [h : ProperConstSMul M X] : IsProperMap ((c \u2022 \u00b7) : X \u2192 X)", "start": [39, 1], "end": [42, 71], "kind": "commanddeclaration"}, {"full_name": "IsCompact.preimage_smul", "code": "@[to_additive \"The preimage of a compact set under `(c +\u1d65 \u00b7)` is a compact set.\"]\ntheorem IsCompact.preimage_smul {M X : Type*} [SMul M X] [TopologicalSpace X]\n    [ProperConstSMul M X] {s : Set X} (hs : IsCompact s) (c : M) : IsCompact ((c \u2022 \u00b7) \u207b\u00b9' s)", "start": [44, 1], "end": [48, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/CHSH.lean", "imports": ["Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/Data/Real/Sqrt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsCHSHTuple", "code": "structure IsCHSHTuple {R} [Monoid R] [StarMul R] (A\u2080 A\u2081 B\u2080 B\u2081 : R) : Prop where\n  A\u2080_inv : A\u2080 ^ 2 = 1\n  A\u2081_inv : A\u2081 ^ 2 = 1\n  B\u2080_inv : B\u2080 ^ 2 = 1\n  B\u2081_inv : B\u2081 ^ 2 = 1\n  A\u2080_sa : star A\u2080 = A\u2080\n  A\u2081_sa : star A\u2081 = A\u2081\n  B\u2080_sa : star B\u2080 = B\u2080\n  B\u2081_sa : star B\u2081 = B\u2081\n  A\u2080B\u2080_commutes : A\u2080 * B\u2080 = B\u2080 * A\u2080\n  A\u2080B\u2081_commutes : A\u2080 * B\u2081 = B\u2081 * A\u2080\n  A\u2081B\u2080_commutes : A\u2081 * B\u2080 = B\u2080 * A\u2081\n  A\u2081B\u2081_commutes : A\u2081 * B\u2081 = B\u2081 * A\u2081", "start": [78, 1], "end": [97, 36], "kind": "commanddeclaration"}, {"full_name": "CHSH_id", "code": "theorem CHSH_id [CommRing R] {A\u2080 A\u2081 B\u2080 B\u2081 : R} (A\u2080_inv : A\u2080 ^ 2 = 1) (A\u2081_inv : A\u2081 ^ 2 = 1)\n    (B\u2080_inv : B\u2080 ^ 2 = 1) (B\u2081_inv : B\u2081 ^ 2 = 1) :\n    (2 - A\u2080 * B\u2080 - A\u2080 * B\u2081 - A\u2081 * B\u2080 + A\u2081 * B\u2081) * (2 - A\u2080 * B\u2080 - A\u2080 * B\u2081 - A\u2081 * B\u2080 + A\u2081 * B\u2081) =\n      4 * (2 - A\u2080 * B\u2080 - A\u2080 * B\u2081 - A\u2081 * B\u2080 + A\u2081 * B\u2081)", "start": [103, 1], "end": [115, 16], "kind": "commanddeclaration"}, {"full_name": "CHSH_inequality_of_comm", "code": "theorem CHSH_inequality_of_comm [OrderedCommRing R] [StarOrderedRing R] [Algebra \u211d R]\n    [OrderedSMul \u211d R] (A\u2080 A\u2081 B\u2080 B\u2081 : R) (T : IsCHSHTuple A\u2080 A\u2081 B\u2080 B\u2081) :\n    A\u2080 * B\u2080 + A\u2080 * B\u2081 + A\u2081 * B\u2080 - A\u2081 * B\u2081 \u2264 2", "start": [119, 1], "end": [147, 54], "kind": "commanddeclaration"}, {"full_name": "TsirelsonInequality.tsirelson_inequality_aux", "code": "theorem tsirelson_inequality_aux : \u221a2 * \u221a2 ^ 3 = \u221a2 * (2 * \u221a2\u207b\u00b9 + 4 * (\u221a2\u207b\u00b9 * 2\u207b\u00b9))", "start": [170, 1], "end": [174, 45], "kind": "commanddeclaration"}, {"full_name": "TsirelsonInequality.sqrt_two_inv_mul_self", "code": "theorem sqrt_two_inv_mul_self : \u221a2\u207b\u00b9 * \u221a2\u207b\u00b9 = (2\u207b\u00b9 : \u211d)", "start": [177, 1], "end": [179, 11], "kind": "commanddeclaration"}, {"full_name": "tsirelson_inequality", "code": "theorem tsirelson_inequality [OrderedRing R] [StarOrderedRing R] [Algebra \u211d R] [OrderedSMul \u211d R]\n    [StarModule \u211d R] (A\u2080 A\u2081 B\u2080 B\u2081 : R) (T : IsCHSHTuple A\u2080 A\u2081 B\u2080 B\u2081) :\n    A\u2080 * B\u2080 + A\u2080 * B\u2081 + A\u2081 * B\u2080 - A\u2081 * B\u2081 \u2264 \u221a2 ^ 3 \u2022 (1 : R)", "start": [186, 1], "end": [249, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "imports": ["Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean", "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.IsExpCmpFilter", "code": "structure IsExpCmpFilter (l : Filter \u2102) : Prop where\n  tendsto_re : Tendsto re l atTop\n  isBigO_im_pow_re : \u2200 n : \u2115, (fun z : \u2102 => z.im ^ n) =O[l] fun z => Real.exp z.re", "start": [38, 1], "end": [47, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.of_isBigO_im_re_rpow", "code": "theorem of_isBigO_im_re_rpow (hre : Tendsto re l atTop) (r : \u211d) (hr : im =O[l] fun z => z.re ^ r) :\n    IsExpCmpFilter l", "start": [59, 1], "end": [68, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.of_isBigO_im_re_pow", "code": "theorem of_isBigO_im_re_pow (hre : Tendsto re l atTop) (n : \u2115) (hr : im =O[l] fun z => z.re ^ n) :\n    IsExpCmpFilter l", "start": [72, 1], "end": [74, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.of_boundedUnder_abs_im", "code": "theorem of_boundedUnder_abs_im (hre : Tendsto re l atTop)\n    (him : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun z => |z.im|) : IsExpCmpFilter l", "start": [78, 1], "end": [82, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.of_boundedUnder_im", "code": "theorem of_boundedUnder_im (hre : Tendsto re l atTop) (him_le : IsBoundedUnder (\u00b7 \u2264 \u00b7) l im)\n    (him_ge : IsBoundedUnder (\u00b7 \u2265 \u00b7) l im) : IsExpCmpFilter l", "start": [85, 1], "end": [87, 73], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.eventually_ne", "code": "theorem eventually_ne (hl : IsExpCmpFilter l) : \u2200\u1da0 w : \u2102 in l, w \u2260 0", "start": [95, 1], "end": [96, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.tendsto_abs_re", "code": "theorem tendsto_abs_re (hl : IsExpCmpFilter l) : Tendsto (fun z : \u2102 => |z.re|) l atTop", "start": [99, 1], "end": [100, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.tendsto_abs", "code": "theorem tendsto_abs (hl : IsExpCmpFilter l) : Tendsto abs l atTop", "start": [103, 1], "end": [104, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_log_re_re", "code": "theorem isLittleO_log_re_re (hl : IsExpCmpFilter l) : (fun z => Real.log z.re) =o[l] re", "start": [107, 1], "end": [108, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_im_pow_exp_re", "code": "theorem isLittleO_im_pow_exp_re (hl : IsExpCmpFilter l) (n : \u2115) :\n    (fun z : \u2102 => z.im ^ n) =o[l] fun z => Real.exp z.re", "start": [111, 1], "end": [123, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.abs_im_pow_eventuallyLE_exp_re", "code": "theorem abs_im_pow_eventuallyLE_exp_re (hl : IsExpCmpFilter l) (n : \u2115) :\n    (fun z : \u2102 => |z.im| ^ n) \u2264\u1da0[l] fun z => Real.exp z.re", "start": [126, 1], "end": [128, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_log_abs_re", "code": "theorem isLittleO_log_abs_re (hl : IsExpCmpFilter l) : (fun z => Real.log (abs z)) =o[l] re", "start": [131, 1], "end": [160, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_cpow_exp", "code": "theorem isLittleO_cpow_exp (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : 0 < b) :\n    (fun z => z ^ a) =o[l] fun z => exp (b * z)", "start": [168, 1], "end": [183, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_cpow_mul_exp", "code": "theorem isLittleO_cpow_mul_exp {b\u2081 b\u2082 : \u211d} (hl : IsExpCmpFilter l) (hb : b\u2081 < b\u2082) (a\u2081 a\u2082 : \u2102) :\n    (fun z => z ^ a\u2081 * exp (b\u2081 * z)) =o[l] fun z => z ^ a\u2082 * exp (b\u2082 * z)", "start": [186, 1], "end": [200, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_exp_cpow", "code": "theorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : b < 0) :\n    (fun z => exp (b * z)) =o[l] fun z => z ^ a", "start": [203, 1], "end": [206, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_pow_mul_exp", "code": "theorem isLittleO_pow_mul_exp {b\u2081 b\u2082 : \u211d} (hl : IsExpCmpFilter l) (hb : b\u2081 < b\u2082) (m n : \u2115) :\n    (fun z => z ^ m * exp (b\u2081 * z)) =o[l] fun z => z ^ n * exp (b\u2082 * z)", "start": [209, 1], "end": [214, 68], "kind": "commanddeclaration"}, {"full_name": "Complex.IsExpCmpFilter.isLittleO_zpow_mul_exp", "code": "theorem isLittleO_zpow_mul_exp {b\u2081 b\u2082 : \u211d} (hl : IsExpCmpFilter l) (hb : b\u2081 < b\u2082) (m n : \u2124) :\n    (fun z => z ^ m * exp (b\u2081 * z)) =o[l] fun z => z ^ n * exp (b\u2082 * z)", "start": [217, 1], "end": [222, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Cyclotomic/Rat.lean", "imports": ["Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean", "Mathlib/NumberTheory/Cyclotomic/Discriminant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsCyclotomicExtension.Rat.discr_prime_pow_ne_two'", "code": "theorem discr_prime_pow_ne_two' [IsCyclotomicExtension {p ^ (k + 1)} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ (k + 1))) (hk : p ^ (k + 1) \u2260 2) :\n    discr \u211a (h\u03b6.subOnePowerBasis \u211a).basis =\n      (-1) ^ ((p ^ (k + 1) : \u2115).totient / 2) * p ^ ((p : \u2115) ^ k * ((p - 1) * (k + 1) - 1))", "start": [37, 1], "end": [43, 49], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.discr_odd_prime'", "code": "theorem discr_odd_prime' [IsCyclotomicExtension {p} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 p) (hodd : p \u2260 2) :\n    discr \u211a (h\u03b6.subOnePowerBasis \u211a).basis = (-1) ^ (((p : \u2115) - 1) / 2) * p ^ ((p : \u2115) - 2)", "start": [46, 1], "end": [49, 49], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.discr_prime_pow'", "code": "theorem discr_prime_pow' [IsCyclotomicExtension {p ^ k} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) :\n    discr \u211a (h\u03b6.subOnePowerBasis \u211a).basis =\n      (-1) ^ ((p ^ k : \u2115).totient / 2) * p ^ ((p : \u2115) ^ (k - 1) * ((p - 1) * k - 1))", "start": [52, 1], "end": [59, 49], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.discr_prime_pow_eq_unit_mul_pow'", "code": "theorem discr_prime_pow_eq_unit_mul_pow' [IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) :\n    \u2203 (u : \u2124\u02e3) (n : \u2115), discr \u211a (h\u03b6.subOnePowerBasis \u211a).basis = u * p ^ n", "start": [62, 1], "end": [69, 84], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow", "code": "theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) : IsIntegralClosure (adjoin \u2124 ({\u03b6} : Set K)) \u2124 K", "start": [72, 1], "end": [120, 86], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime", "code": "theorem isIntegralClosure_adjoin_singleton_of_prime [hcycl : IsCyclotomicExtension {p} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191p) : IsIntegralClosure (adjoin \u2124 ({\u03b6} : Set K)) \u2124 K", "start": [123, 1], "end": [126, 59], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime_pow", "code": "theorem cyclotomicRing_isIntegralClosure_of_prime_pow :\n    IsIntegralClosure (CyclotomicRing (p ^ k) \u2124 \u211a) \u2124 (CyclotomicField (p ^ k) \u211a)", "start": [129, 1], "end": [143, 81], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime", "code": "theorem cyclotomicRing_isIntegralClosure_of_prime :\n    IsIntegralClosure (CyclotomicRing p \u2124 \u211a) \u2124 (CyclotomicField p \u211a)", "start": [146, 1], "end": [149, 54], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.adjoinEquivRingOfIntegers", "code": "@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers\n    [IsCyclotomicExtension {p ^ k} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) :\n    adjoin \u2124 ({\u03b6} : Set K) \u2243\u2090[\u2124] \ud835\udcde K :=\n  let _ := isIntegralClosure_adjoin_singleton_of_prime_pow h\u03b6\n  IsIntegralClosure.equiv \u2124 (adjoin \u2124 ({\u03b6} : Set K)) K (\ud835\udcde K)", "start": [160, 1], "end": [167, 61], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers", "code": "instance IsCyclotomicExtension.ringOfIntegers [IsCyclotomicExtension {p ^ k} \u211a K] :\n    IsCyclotomicExtension {p ^ k} \u2124 (\ud835\udcde K) :=\n  let _ := (zeta_spec (p ^ k) \u211a K).adjoin_isCyclotomicExtension \u2124\n  IsCyclotomicExtension.equiv _ \u2124 _ (zeta_spec (p ^ k) \u211a K).adjoinEquivRingOfIntegers", "start": [170, 1], "end": [174, 86], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.integralPowerBasis", "code": "noncomputable def integralPowerBasis [IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) : PowerBasis \u2124 (\ud835\udcde K) :=\n  (Algebra.adjoin.powerBasis' (h\u03b6.isIntegral (p ^ k).pos)).map h\u03b6.adjoinEquivRingOfIntegers", "start": [177, 1], "end": [181, 92], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.integralPowerBasis_gen", "code": "@[simp]\ntheorem integralPowerBasis_gen [hcycl : IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) :\n    h\u03b6.integralPowerBasis.gen = \u27e8\u03b6, h\u03b6.isIntegral (p ^ k).pos\u27e9", "start": [185, 1], "end": [192, 8], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.integralPowerBasis_dim", "code": "@[simp]\ntheorem integralPowerBasis_dim [hcycl : IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) : h\u03b6.integralPowerBasis.dim = \u03c6 (p ^ k)", "start": [195, 1], "end": [198, 78], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.adjoinEquivRingOfIntegers'", "code": "@[simps!]\nnoncomputable def _root_.IsPrimitiveRoot.adjoinEquivRingOfIntegers'\n    [hcycl : IsCyclotomicExtension {p} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 p) :\n    adjoin \u2124 ({\u03b6} : Set K) \u2243\u2090[\u2124] \ud835\udcde K :=\n  @adjoinEquivRingOfIntegers p 1 K _ _ _ _ (by convert hcycl; rw [pow_one]) (by rwa [pow_one])", "start": [201, 1], "end": [207, 95], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.ring_of_integers'", "code": "instance _root_.IsCyclotomicExtension.ring_of_integers' [IsCyclotomicExtension {p} \u211a K] :\n    IsCyclotomicExtension {p} \u2124 (\ud835\udcde K) :=\n  let _ := (zeta_spec p \u211a K).adjoin_isCyclotomicExtension \u2124\n  IsCyclotomicExtension.equiv _ \u2124 _ (zeta_spec p \u211a K).adjoinEquivRingOfIntegers'", "start": [210, 1], "end": [214, 81], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.integralPowerBasis'", "code": "noncomputable def integralPowerBasis' [hcycl : IsCyclotomicExtension {p} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 p) : PowerBasis \u2124 (\ud835\udcde K) :=\n  @integralPowerBasis p 1 K _ _ _ _ (by convert hcycl; rw [pow_one]) (by rwa [pow_one])", "start": [217, 1], "end": [221, 88], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.integralPowerBasis'_gen", "code": "@[simp]\ntheorem integralPowerBasis'_gen [hcycl : IsCyclotomicExtension {p} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 p) :\n    h\u03b6.integralPowerBasis'.gen = \u27e8\u03b6, h\u03b6.isIntegral p.pos\u27e9", "start": [224, 1], "end": [227, 92], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.power_basis_int'_dim", "code": "@[simp]\ntheorem power_basis_int'_dim [hcycl : IsCyclotomicExtension {p} \u211a K] (h\u03b6 : IsPrimitiveRoot \u03b6 p) :\n    h\u03b6.integralPowerBasis'.dim = \u03c6 p", "start": [230, 1], "end": [234, 13], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.subOneIntegralPowerBasis", "code": "noncomputable def subOneIntegralPowerBasis [IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) : PowerBasis \u2124 (\ud835\udcde K) :=\n  PowerBasis.ofGenMemAdjoin' h\u03b6.integralPowerBasis\n    (isIntegral_of_mem_ringOfIntegers <|\n      Subalgebra.sub_mem _ (h\u03b6.isIntegral (p ^ k).pos) (Subalgebra.one_mem _))\n    (by\n      simp only [integralPowerBasis_gen]\n      convert Subalgebra.add_mem _ (self_mem_adjoin_singleton \u2124 (\u27e8\u03b6 - 1, _\u27e9 : \ud835\udcde K))\n        (Subalgebra.one_mem _)\nsimp only [Subsemiring.coe_add, Subalgebra.coe_toSubsemiring,\n        OneMemClass.coe_one, sub_add_cancel]\n      exact Subalgebra.sub_mem _ (h\u03b6.isIntegral (by simp)) (Subalgebra.one_mem _))", "start": [237, 1], "end": [251, 83], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.subOneIntegralPowerBasis_gen", "code": "@[simp]\ntheorem subOneIntegralPowerBasis_gen [IsCyclotomicExtension {p ^ k} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) :\n    h\u03b6.subOneIntegralPowerBasis.gen =\n      \u27e8\u03b6 - 1, Subalgebra.sub_mem _ (h\u03b6.isIntegral (p ^ k).pos) (Subalgebra.one_mem _)\u27e9", "start": [254, 1], "end": [259, 37], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.subOneIntegralPowerBasis'", "code": "noncomputable def subOneIntegralPowerBasis' [hcycl : IsCyclotomicExtension {p} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 p) : PowerBasis \u2124 (\ud835\udcde K) :=\n  @subOneIntegralPowerBasis p 1 K _ _ _ _ (by convert hcycl; rw [pow_one]) (by rwa [pow_one])", "start": [262, 1], "end": [266, 94], "kind": "commanddeclaration"}, {"full_name": "IsPrimitiveRoot.subOneIntegralPowerBasis'_gen", "code": "@[simp]\ntheorem subOneIntegralPowerBasis'_gen [hcycl : IsCyclotomicExtension {p} \u211a K]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 p) :\n    h\u03b6.subOneIntegralPowerBasis'.gen =\n      \u27e8\u03b6 - 1, Subalgebra.sub_mem _ (h\u03b6.isIntegral p.pos) (Subalgebra.one_mem _)\u27e9", "start": [269, 1], "end": [274, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Hydra.lean", "imports": ["Mathlib/Data/Finsupp/Multiset.lean", "Mathlib/Data/Finsupp/Lex.lean", "Mathlib/Order/GameAdd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Relation.CutExpand", "code": "def CutExpand (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s' s : Multiset \u03b1) : Prop :=\n  \u2203 (t : Multiset \u03b1) (a : \u03b1), (\u2200 a' \u2208 t, r a' a) \u2227 s' + {a} = s + t", "start": [42, 1], "end": [57, 68], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_le_invImage_lex", "code": "theorem cutExpand_le_invImage_lex [DecidableEq \u03b1] [IsIrrefl \u03b1 r] :\n    CutExpand r \u2264 InvImage (Finsupp.Lex (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) (\u00b7 < \u00b7)) toFinsupp", "start": [62, 1], "end": [74, 34], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_singleton", "code": "theorem cutExpand_singleton {s x} (h : \u2200 x' \u2208 s, r x' x) : CutExpand r s {x}", "start": [77, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_singleton_singleton", "code": "theorem cutExpand_singleton_singleton {x' x} (h : r x' x) : CutExpand r {x'} {x}", "start": [81, 1], "end": [82, 59], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_add_left", "code": "theorem cutExpand_add_left {t u} (s) : CutExpand r (s + t) (s + u) \u2194 CutExpand r t u", "start": [85, 1], "end": [86, 97], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_iff", "code": "theorem cutExpand_iff [DecidableEq \u03b1] [IsIrrefl \u03b1 r] {s' s : Multiset \u03b1} :\n    CutExpand r s' s \u2194\n      \u2203 (t : Multiset \u03b1) (a : \u03b1), (\u2200 a' \u2208 t, r a' a) \u2227 a \u2208 s \u2227 s' = s.erase a + t", "start": [89, 1], "end": [98, 68], "kind": "commanddeclaration"}, {"full_name": "Relation.not_cutExpand_zero", "code": "theorem not_cutExpand_zero [IsIrrefl \u03b1 r] (s) : \u00acCutExpand r s 0", "start": [101, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "Relation.cutExpand_fibration", "code": "theorem cutExpand_fibration (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    Fibration (GameAdd (CutExpand r) (CutExpand r)) (CutExpand r) fun s \u21a6 s.1 + s.2", "start": [107, 1], "end": [124, 46], "kind": "commanddeclaration"}, {"full_name": "Relation.acc_of_singleton", "code": "theorem acc_of_singleton [IsIrrefl \u03b1 r] {s : Multiset \u03b1} (hs : \u2200 a \u2208 s, Acc (CutExpand r) {a}) :\n    Acc (CutExpand r) s", "start": [127, 1], "end": [136, 97], "kind": "commanddeclaration"}, {"full_name": "Acc.cutExpand", "code": "theorem _root_.Acc.cutExpand [IsIrrefl \u03b1 r] {a : \u03b1} (hacc : Acc r a) : Acc (CutExpand r) {a}", "start": [139, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "WellFounded.cutExpand", "code": "theorem _root_.WellFounded.cutExpand (hr : WellFounded r) : WellFounded (CutExpand r)", "start": [152, 1], "end": [154, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/LawfulFix.lean", "imports": ["Mathlib/Order/OmegaCompletePartialOrder.lean", "Mathlib/Control/Fix.lean", "Mathlib/Data/Stream/Init.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyFun.lean"], "premises": [{"full_name": "LawfulFix", "code": "class LawfulFix (\u03b1 : Type*) [OmegaCompletePartialOrder \u03b1] extends Fix \u03b1 where\n  fix_eq : \u2200 {f : \u03b1 \u2192o \u03b1}, Continuous f \u2192 Fix.fix f = f (Fix.fix f)", "start": [34, 1], "end": [41, 68], "kind": "commanddeclaration"}, {"full_name": "LawfulFix.fix_eq'", "code": "theorem LawfulFix.fix_eq' {\u03b1} [OmegaCompletePartialOrder \u03b1] [LawfulFix \u03b1] {f : \u03b1 \u2192 \u03b1}\n    (hf : Continuous' f) : Fix.fix f = f (Fix.fix f)", "start": [44, 1], "end": [46, 37], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approx_mono'", "code": "theorem approx_mono' {i : \u2115} : Fix.approx f i \u2264 Fix.approx f (succ i)", "start": [57, 1], "end": [60, 55], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approx_mono", "code": "theorem approx_mono \u2983i j : \u2115\u2984 (hij : i \u2264 j) : approx f i \u2264 approx f j", "start": [63, 1], "end": [68, 43], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.mem_iff", "code": "theorem mem_iff (a : \u03b1) (b : \u03b2 a) : b \u2208 Part.fix f a \u2194 \u2203 i, b \u2208 approx f i a", "start": [71, 1], "end": [91, 20], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approx_le_fix", "code": "theorem approx_le_fix (i : \u2115) : approx f i \u2264 Part.fix f", "start": [94, 1], "end": [96, 16], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.exists_fix_le_approx", "code": "theorem exists_fix_le_approx (x : \u03b1) : \u2203 i, Part.fix f x \u2264 approx f i x", "start": [99, 1], "end": [112, 20], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approxChain", "code": "def approxChain : Chain ((a : _) \u2192 Part <| \u03b2 a) :=\n  \u27e8approx f, approx_mono f\u27e9", "start": [115, 1], "end": [117, 28], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.le_f_of_mem_approx", "code": "theorem le_f_of_mem_approx {x} : x \u2208 approxChain f \u2192 x \u2264 f x", "start": [120, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approx_mem_approxChain", "code": "theorem approx_mem_approxChain {i} : approx f i \u2208 approxChain f", "start": [126, 1], "end": [127, 28], "kind": "commanddeclaration"}, {"full_name": "Part.fix_eq_\u03c9Sup", "code": "theorem fix_eq_\u03c9Sup : Part.fix f = \u03c9Sup (approxChain f)", "start": [146, 1], "end": [160, 26], "kind": "commanddeclaration"}, {"full_name": "Part.fix_le", "code": "theorem fix_le {X : (a : _) \u2192 Part <| \u03b2 a} (hX : f X \u2264 X) : Part.fix f \u2264 X", "start": [163, 1], "end": [170, 62], "kind": "commanddeclaration"}, {"full_name": "Part.fix_eq", "code": "theorem fix_eq : Part.fix f = f (Part.fix f)", "start": [175, 1], "end": [186, 18], "kind": "commanddeclaration"}, {"full_name": "Part.toUnitMono", "code": "@[simps]\ndef toUnitMono (f : Part \u03b1 \u2192o Part \u03b1) : (Unit \u2192 Part \u03b1) \u2192o Unit \u2192 Part \u03b1 where\n  toFun x u := f (x u)\n  monotone' x y (h : x \u2264 y) u := f.monotone <| h u", "start": [193, 1], "end": [197, 51], "kind": "commanddeclaration"}, {"full_name": "Part.to_unit_cont", "code": "theorem to_unit_cont (f : Part \u03b1 \u2192o Part \u03b1) (hc : Continuous f) : Continuous (toUnitMono f)", "start": [200, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "Part.lawfulFix", "code": "instance lawfulFix : LawfulFix (Part \u03b1) :=\n  \u27e8fun {f : Part \u03b1 \u2192o Part \u03b1} hc \u21a6 show Part.fix (toUnitMono f) () = _ by\n    rw [Part.fix_eq (to_unit_cont f hc)]; rfl\u27e9", "start": [207, 1], "end": [209, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.lawfulFix", "code": "instance lawfulFix {\u03b2} : LawfulFix (\u03b1 \u2192 Part \u03b2) :=\n  \u27e8fun {_f} \u21a6 Part.fix_eq\u27e9", "start": [218, 1], "end": [219, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.monotoneCurry", "code": "@[simps]\ndef monotoneCurry [(x y : _) \u2192 Preorder <| \u03b3 x y] :\n    (\u2200 x : \u03a3a, \u03b2 a, \u03b3 x.1 x.2) \u2192o \u2200 (a) (b : \u03b2 a), \u03b3 a b where\n  toFun := curry\n  monotone' _x _y h a b := h \u27e8a, b\u27e9", "start": [228, 1], "end": [233, 36], "kind": "commanddeclaration"}, {"full_name": "Pi.monotoneUncurry", "code": "@[simps]\ndef monotoneUncurry [(x y : _) \u2192 Preorder <| \u03b3 x y] :\n    (\u2200 (a) (b : \u03b2 a), \u03b3 a b) \u2192o \u2200 x : \u03a3a, \u03b2 a, \u03b3 x.1 x.2 where\n  toFun := uncurry\n  monotone' _x _y h a := h a.1 a.2", "start": [236, 1], "end": [241, 35], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_curry", "code": "theorem continuous_curry : Continuous <| monotoneCurry \u03b1 \u03b2 \u03b3", "start": [248, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_uncurry", "code": "theorem continuous_uncurry : Continuous <| monotoneUncurry \u03b1 \u03b2 \u03b3", "start": [255, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.hasFix", "code": "instance hasFix [Fix <| (x : Sigma \u03b2) \u2192 \u03b3 x.1 x.2] : Fix ((x : _) \u2192 (y : \u03b2 x) \u2192 \u03b3 x y) :=\n  \u27e8fun f \u21a6 curry (fix <| uncurry \u2218 f \u2218 curry)\u27e9", "start": [266, 1], "end": [267, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.uncurry_curry_continuous", "code": "theorem uncurry_curry_continuous :\n    Continuous <| (monotoneUncurry \u03b1 \u03b2 \u03b3).comp <| f.comp <| monotoneCurry \u03b1 \u03b2 \u03b3", "start": [278, 1], "end": [280, 99], "kind": "commanddeclaration"}, {"full_name": "Pi.Pi.lawfulFix'", "code": "instance Pi.lawfulFix' [LawfulFix <| (x : Sigma \u03b2) \u2192 \u03b3 x.1 x.2] :\n    LawfulFix ((x y : _) \u2192 \u03b3 x y) where\n  fix_eq {_f} hc := by\n    dsimp [fix]\n    conv =>\n      lhs\n      erw [LawfulFix.fix_eq (uncurry_curry_continuous hc)]", "start": [285, 1], "end": [291, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/LpSpace/DomAct/Basic.lean", "imports": ["Mathlib/MeasureTheory/Function/AEEqFun/DomAct.lean", "Mathlib/MeasureTheory/Integral/Bochner.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DomMulAct.smul_Lp_val", "code": "@[to_additive (attr := simp)]\ntheorem smul_Lp_val (c : M\u1d48\u1d50\u1d43) (f : Lp E p \u03bc) : (c \u2022 f).1 = c \u2022 f.1", "start": [37, 1], "end": [38, 75], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_ae_eq", "code": "@[to_additive]\ntheorem smul_Lp_ae_eq (c : M\u1d48\u1d50\u1d43) (f : Lp E p \u03bc) : c \u2022 f =\u1d50[\u03bc] (f <| mk.symm c \u2022 \u00b7)", "start": [40, 1], "end": [42, 37], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_toLp", "code": "@[to_additive]\ntheorem mk_smul_toLp (c : M) {f : \u03b1 \u2192 E} (hf : Mem\u2112p f p \u03bc) :\n    mk c \u2022 hf.toLp f =\n      (hf.comp_measurePreserving <| measurePreserving_smul c \u03bc).toLp (f <| c \u2022 \u00b7)", "start": [44, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_const", "code": "@[to_additive (attr := simp)]\ntheorem smul_Lp_const [IsFiniteMeasure \u03bc] (c : M\u1d48\u1d50\u1d43) (a : E) :\n    c \u2022 Lp.const p \u03bc a = Lp.const p \u03bc a", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_add", "code": "@[to_additive]\ntheorem smul_Lp_add (c : M\u1d48\u1d50\u1d43) : \u2200 f g : Lp E p \u03bc, c \u2022 (f + g) = c \u2022 f + c \u2022 g", "start": [69, 1], "end": [71, 30], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_zero", "code": "@[to_additive (attr := simp 1001)]\ntheorem smul_Lp_zero (c : M\u1d48\u1d50\u1d43) : c \u2022 (0 : Lp E p \u03bc) = 0", "start": [74, 1], "end": [75, 64], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_neg", "code": "@[to_additive]\ntheorem smul_Lp_neg (c : M\u1d48\u1d50\u1d43) (f : Lp E p \u03bc) : c \u2022 (-f) = -(c \u2022 f)", "start": [77, 1], "end": [79, 30], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_Lp_sub", "code": "@[to_additive]\ntheorem smul_Lp_sub (c : M\u1d48\u1d50\u1d43) : \u2200 f g : Lp E p \u03bc, c \u2022 (f - g) = c \u2022 f - c \u2022 g", "start": [81, 1], "end": [83, 30], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.norm_smul_Lp", "code": "@[to_additive (attr := simp)]\ntheorem norm_smul_Lp (c : M\u1d48\u1d50\u1d43) (f : Lp E p \u03bc) : \u2016c \u2022 f\u2016 = \u2016f\u2016", "start": [90, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.nnnorm_smul_Lp", "code": "@[to_additive (attr := simp)]\ntheorem nnnorm_smul_Lp (c : M\u1d48\u1d50\u1d43) (f : Lp E p \u03bc) : \u2016c \u2022 f\u2016\u208a = \u2016f\u2016\u208a", "start": [94, 1], "end": [96, 49], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.dist_smul_Lp", "code": "@[to_additive (attr := simp)]\ntheorem dist_smul_Lp (c : M\u1d48\u1d50\u1d43) (f g : Lp E p \u03bc) : dist (c \u2022 f) (c \u2022 g) = dist f g", "start": [98, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.edist_smul_Lp", "code": "@[to_additive (attr := simp)]\ntheorem edist_smul_Lp (c : M\u1d48\u1d50\u1d43) (f g : Lp E p \u03bc) : edist (c \u2022 f) (c \u2022 g) = edist f g", "start": [102, 1], "end": [104, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Height.lean", "imports": ["Mathlib/Data/ENat/Lattice.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Order/OrderIsoNat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.subchain", "code": "def subchain : Set (List \u03b1) :=\n  { l | l.Chain' (\u00b7 < \u00b7) \u2227 \u2200 i \u2208 l, i \u2208 s }", "start": [59, 1], "end": [61, 44], "kind": "commanddeclaration"}, {"full_name": "Set.nil_mem_subchain", "code": "@[simp] theorem nil_mem_subchain : [] \u2208 s.subchain", "start": [64, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "Set.cons_mem_subchain_iff", "code": "theorem cons_mem_subchain_iff :\n    (a::l) \u2208 s.subchain \u2194 a \u2208 s \u2227 l \u2208 s.subchain \u2227 \u2200 b \u2208 l.head?, a < b", "start": [70, 1], "end": [73, 15], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_mem_subchain_iff", "code": "@[simp] theorem singleton_mem_subchain_iff : [a] \u2208 s.subchain \u2194 a \u2208 s", "start": [76, 1], "end": [77, 97], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight", "code": "noncomputable def chainHeight : \u2115\u221e :=\n  \u2a06 l \u2208 s.subchain, length l", "start": [84, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_eq_iSup_subtype", "code": "theorem chainHeight_eq_iSup_subtype : s.chainHeight = \u2a06 l : s.subchain, \u2191l.1.length", "start": [89, 1], "end": [90, 16], "kind": "commanddeclaration"}, {"full_name": "Set.exists_chain_of_le_chainHeight", "code": "theorem exists_chain_of_le_chainHeight {n : \u2115} (hn : \u2191n \u2264 s.chainHeight) :\n    \u2203 l \u2208 s.subchain, length l = n", "start": [93, 1], "end": [106, 98], "kind": "commanddeclaration"}, {"full_name": "Set.le_chainHeight_TFAE", "code": "theorem le_chainHeight_TFAE (n : \u2115) :\n    TFAE [\u2191n \u2264 s.chainHeight, \u2203 l \u2208 s.subchain, length l = n, \u2203 l \u2208 s.subchain, n \u2264 length l]", "start": [109, 1], "end": [114, 14], "kind": "commanddeclaration"}, {"full_name": "Set.le_chainHeight_iff", "code": "theorem le_chainHeight_iff {n : \u2115} : \u2191n \u2264 s.chainHeight \u2194 \u2203 l \u2208 s.subchain, length l = n", "start": [119, 1], "end": [120, 36], "kind": "commanddeclaration"}, {"full_name": "Set.length_le_chainHeight_of_mem_subchain", "code": "theorem length_le_chainHeight_of_mem_subchain (hl : l \u2208 s.subchain) : \u2191l.length \u2264 s.chainHeight", "start": [123, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_eq_top_iff", "code": "theorem chainHeight_eq_top_iff : s.chainHeight = \u22a4 \u2194 \u2200 n, \u2203 l \u2208 s.subchain, length l = n", "start": [127, 1], "end": [131, 69], "kind": "commanddeclaration"}, {"full_name": "Set.one_le_chainHeight_iff", "code": "@[simp]\ntheorem one_le_chainHeight_iff : 1 \u2264 s.chainHeight \u2194 s.Nonempty", "start": [134, 1], "end": [138, 46], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_eq_zero_iff", "code": "@[simp]\ntheorem chainHeight_eq_zero_iff : s.chainHeight = 0 \u2194 s = \u2205", "start": [141, 1], "end": [144, 27], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_empty", "code": "@[simp]\ntheorem chainHeight_empty : (\u2205 : Set \u03b1).chainHeight = 0", "start": [147, 1], "end": [149, 32], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_of_isEmpty", "code": "@[simp]\ntheorem chainHeight_of_isEmpty [IsEmpty \u03b1] : s.chainHeight = 0", "start": [152, 1], "end": [154, 54], "kind": "commanddeclaration"}, {"full_name": "Set.le_chainHeight_add_nat_iff", "code": "theorem le_chainHeight_add_nat_iff {n m : \u2115} :\n    \u2191n \u2264 s.chainHeight + m \u2194 \u2203 l \u2208 s.subchain, n \u2264 length l + m", "start": [157, 1], "end": [159, 89], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_add_le_chainHeight_add", "code": "theorem chainHeight_add_le_chainHeight_add (s : Set \u03b1) (t : Set \u03b2) (n m : \u2115) :\n    s.chainHeight + n \u2264 t.chainHeight + m \u2194\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l + n \u2264 length l' + m", "start": [162, 1], "end": [184, 48], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_le_chainHeight_TFAE", "code": "theorem chainHeight_le_chainHeight_TFAE (s : Set \u03b1) (t : Set \u03b2) :\n    TFAE [s.chainHeight \u2264 t.chainHeight, \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l = length l',\n      \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l \u2264 length l']", "start": [187, 1], "end": [195, 14], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_le_chainHeight_iff", "code": "theorem chainHeight_le_chainHeight_iff {t : Set \u03b2} :\n    s.chainHeight \u2264 t.chainHeight \u2194 \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l = length l'", "start": [198, 1], "end": [200, 48], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_le_chainHeight_iff_le", "code": "theorem chainHeight_le_chainHeight_iff_le {t : Set \u03b2} :\n    s.chainHeight \u2264 t.chainHeight \u2194 \u2200 l \u2208 s.subchain, \u2203 l' \u2208 t.subchain, length l \u2264 length l'", "start": [203, 1], "end": [205, 48], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_mono", "code": "theorem chainHeight_mono (h : s \u2286 t) : s.chainHeight \u2264 t.chainHeight", "start": [208, 1], "end": [209, 90], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_image", "code": "theorem chainHeight_image (f : \u03b1 \u2192 \u03b2) (hf : \u2200 {x y}, x < y \u2194 f x < f y) (s : Set \u03b1) :\n    (f '' s).chainHeight = s.chainHeight", "start": [212, 1], "end": [237, 22], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_dual", "code": "@[simp]\ntheorem chainHeight_dual : (ofDual \u207b\u00b9' s).chainHeight = s.chainHeight", "start": [242, 1], "end": [248, 31], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_eq_iSup_Ici", "code": "theorem chainHeight_eq_iSup_Ici : s.chainHeight = \u2a06 i \u2208 s, (s \u2229 Set.Ici i).chainHeight", "start": [257, 1], "end": [270, 75], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_eq_iSup_Iic", "code": "theorem chainHeight_eq_iSup_Iic : s.chainHeight = \u2a06 i \u2208 s, (s \u2229 Set.Iic i).chainHeight", "start": [273, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_insert_of_forall_gt", "code": "theorem chainHeight_insert_of_forall_gt (a : \u03b1) (hx : \u2200 b \u2208 s, a < b) :\n    (insert a s).chainHeight = s.chainHeight + 1", "start": [281, 1], "end": [306, 65], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_insert_of_forall_lt", "code": "theorem chainHeight_insert_of_forall_lt (a : \u03b1) (ha : \u2200 b \u2208 s, b < a) :\n    (insert a s).chainHeight = s.chainHeight + 1", "start": [309, 1], "end": [312, 45], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_union_le", "code": "theorem chainHeight_union_le : (s \u222a t).chainHeight \u2264 s.chainHeight + t.chainHeight", "start": [315, 1], "end": [329, 39], "kind": "commanddeclaration"}, {"full_name": "Set.chainHeight_union_eq", "code": "theorem chainHeight_union_eq (s t : Set \u03b1) (H : \u2200 a \u2208 s, \u2200 b \u2208 t, a < b) :\n    (s \u222a t).chainHeight = s.chainHeight + t.chainHeight", "start": [332, 1], "end": [348, 53], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedGT_of_chainHeight_ne_top", "code": "theorem wellFoundedGT_of_chainHeight_ne_top (s : Set \u03b1) (hs : s.chainHeight \u2260 \u22a4) :\n    WellFoundedGT s", "start": [351, 1], "end": [369, 17], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedLT_of_chainHeight_ne_top", "code": "theorem wellFoundedLT_of_chainHeight_ne_top (s : Set \u03b1) (hs : s.chainHeight \u2260 \u22a4) :\n    WellFoundedLT s", "start": [372, 1], "end": [374, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/Teichmuller.lean", "imports": ["Mathlib/RingTheory/WittVector/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WittVector.teichmullerFun", "code": "def teichmullerFun (r : R) : \ud835\udd4e R :=\n  \u27e8fun n => if n = 0 then r else 0\u27e9", "start": [39, 1], "end": [43, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.ghostComponent_teichmullerFun", "code": "private theorem ghostComponent_teichmullerFun (r : R) (n : \u2115) :\n    ghostComponent n (teichmullerFun p r) = r ^ p ^ n", "start": [61, 1], "end": [73, 68], "kind": "commanddeclaration"}, {"full_name": "WittVector.map_teichmullerFun", "code": "private theorem map_teichmullerFun (f : R \u2192+* S) (r : R) :\n    map f (teichmullerFun p r) = teichmullerFun p (f r)", "start": [75, 1], "end": [79, 21], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller_mul_aux\u2081", "code": "private theorem teichmuller_mul_aux\u2081 (x y : MvPolynomial R \u211a) :\n    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y", "start": [81, 1], "end": [86, 83], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller_mul_aux\u2082", "code": "private theorem teichmuller_mul_aux\u2082 (x y : MvPolynomial R \u2124) :\n    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y", "start": [88, 1], "end": [92, 72], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller", "code": "def teichmuller : R \u2192* \ud835\udd4e R where\n  toFun := teichmullerFun p\n  map_one' := by\n    ext \u27e8\u27e9\n    \u00b7 rw [one_coeff_zero]; rfl\n    \u00b7 rw [one_coeff_eq_of_pos _ _ _ (Nat.succ_pos _)]; rfl\n  map_mul' := by\n    intro x y\n    rcases counit_surjective R x with \u27e8x, rfl\u27e9\n    rcases counit_surjective R y with \u27e8y, rfl\u27e9\n    simp only [\u2190 map_teichmullerFun, \u2190 RingHom.map_mul, teichmuller_mul_aux\u2082]", "start": [94, 1], "end": [107, 78], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller_coeff_zero", "code": "@[simp]\ntheorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller_coeff_pos", "code": "@[simp]\ntheorem teichmuller_coeff_pos (r : R) : \u2200 (n : \u2115) (_ : 0 < n), (teichmuller p r).coeff n = 0", "start": [115, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "WittVector.teichmuller_zero", "code": "@[simp]\ntheorem teichmuller_zero : teichmuller p (0 : R) = 0", "start": [120, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.map_teichmuller", "code": "@[simp]\ntheorem map_teichmuller (f : R \u2192+* S) (r : R) : map f (teichmuller p r) = teichmuller p (f r)", "start": [125, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "WittVector.ghostComponent_teichmuller", "code": "@[simp]\ntheorem ghostComponent_teichmuller (r : R) (n : \u2115) :\n    ghostComponent n (teichmuller p r) = r ^ p ^ n", "start": [131, 1], "end": [135, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/SpecialFunctions/IsROrC.lean", "imports": ["Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean", "Mathlib/Data/IsROrC/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsROrC.measurable_re", "code": "@[measurability]\ntheorem measurable_re : Measurable (re : \ud835\udd5c \u2192 \u211d)", "start": [25, 1], "end": [27, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.measurable_im", "code": "@[measurability]\ntheorem measurable_im : Measurable (im : \ud835\udd5c \u2192 \u211d)", "start": [30, 1], "end": [32, 27], "kind": "commanddeclaration"}, {"full_name": "Measurable.re", "code": "@[measurability]\ntheorem Measurable.re (hf : Measurable f) : Measurable fun x => IsROrC.re (f x)", "start": [41, 1], "end": [43, 31], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.re", "code": "@[measurability]\ntheorem AEMeasurable.re (hf : AEMeasurable f \u03bc) : AEMeasurable (fun x => IsROrC.re (f x)) \u03bc", "start": [46, 1], "end": [48, 44], "kind": "commanddeclaration"}, {"full_name": "Measurable.im", "code": "@[measurability]\ntheorem Measurable.im (hf : Measurable f) : Measurable fun x => IsROrC.im (f x)", "start": [51, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.im", "code": "@[measurability]\ntheorem AEMeasurable.im (hf : AEMeasurable f \u03bc) : AEMeasurable (fun x => IsROrC.im (f x)) \u03bc", "start": [56, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "IsROrC.measurable_ofReal", "code": "@[measurability]\ntheorem IsROrC.measurable_ofReal : Measurable ((\u2191) : \u211d \u2192 \ud835\udd5c)", "start": [67, 1], "end": [69, 38], "kind": "commanddeclaration"}, {"full_name": "measurable_of_re_im", "code": "theorem measurable_of_re_im (hre : Measurable fun x => IsROrC.re (f x))\n    (him : Measurable fun x => IsROrC.im (f x)) : Measurable f", "start": [72, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_of_re_im", "code": "theorem aemeasurable_of_re_im (hre : AEMeasurable (fun x => IsROrC.re (f x)) \u03bc)\n    (him : AEMeasurable (fun x => IsROrC.im (f x)) \u03bc) : AEMeasurable f \u03bc", "start": [79, 1], "end": [83, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Idempotents/Biproducts.lean", "imports": ["Mathlib/CategoryTheory/Idempotents/Karoubi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Idempotents.Karoubi.Biproducts.bicone", "code": "@[simps]\ndef bicone [HasFiniteBiproducts C] {J : Type} [Finite J] (F : J \u2192 Karoubi C) : Bicone F where\n  pt :=\n    { X := biproduct fun j => (F j).X\n      p := biproduct.map fun j => (F j).p\n      idem := by\n        ext\n        simp only [assoc, biproduct.map_\u03c0, biproduct.map_\u03c0_assoc, idem] }\n  \u03c0 j :=\n    { f := (biproduct.map fun j => (F j).p) \u226b Bicone.\u03c0 _ j\n      comm := by\n        simp only [assoc, biproduct.bicone_\u03c0, biproduct.map_\u03c0, biproduct.map_\u03c0_assoc, (F j).idem] }\n  \u03b9 j :=\n    { f := biproduct.\u03b9 (fun j => (F j).X) j \u226b biproduct.map fun j => (F j).p\n      comm := by simp only [biproduct.\u03b9_map, assoc, idem_assoc] }\n  \u03b9_\u03c0 j j' := by\n    split_ifs with h\n    \u00b7 subst h\n      simp only [biproduct.\u03b9_map, biproduct.bicone_\u03c0, biproduct.map_\u03c0, eqToHom_refl,\n        id_eq, hom_ext_iff, comp_f, assoc, bicone_\u03b9_\u03c0_self_assoc, idem]\n    \u00b7 dsimp\n      simp only [hom_ext_iff, biproduct.\u03b9_map, biproduct.map_\u03c0, comp_f, assoc, ne_eq,\n        biproduct.\u03b9_\u03c0_ne_assoc _ h, comp_zero, zero_comp]", "start": [45, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.Karoubi.karoubi_hasFiniteBiproducts", "code": "theorem karoubi_hasFiniteBiproducts [HasFiniteBiproducts C] : HasFiniteBiproducts (Karoubi C)", "start": [74, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.Karoubi.complement", "code": "@[simps]\ndef complement (P : Karoubi C) : Karoubi C where\n  X := P.X\n  p := \ud835\udfd9 _ - P.p\n  idem := idem_of_id_sub_idem P.p P.idem", "start": [93, 1], "end": [99, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Idempotents.Karoubi.decomposition", "code": "def decomposition (P : Karoubi C) : P \u229e P.complement \u2245 (toKaroubi _).obj P.X where\n  hom := biprod.desc P.decompId_i P.complement.decompId_i\n  inv := biprod.lift P.decompId_p P.complement.decompId_p\n  hom_inv_id := by\n    apply biprod.hom_ext'\n    \u00b7 rw [biprod.inl_desc_assoc, comp_id, biprod.lift_eq, comp_add, \u2190 decompId_assoc,\n        add_right_eq_self, \u2190 assoc]\n      refine' (_ =\u226b _).trans zero_comp\n      ext\n      simp only [comp_f, toKaroubi_obj_X, decompId_i_f, decompId_p_f,\n        complement_p, comp_sub, comp_id, idem, sub_self, instAddCommGroupHom_zero]\n    \u00b7 rw [biprod.inr_desc_assoc, comp_id, biprod.lift_eq, comp_add, \u2190 decompId_assoc,\n        add_left_eq_self, \u2190 assoc]\n      refine' (_ =\u226b _).trans zero_comp\n      ext\n      simp only [complement_X, comp_f, decompId_i_f, complement_p,\n        decompId_p_f, sub_comp, id_comp, idem, sub_self, instAddCommGroupHom_zero]\n  inv_hom_id := by\n    simp only [biprod.lift_desc, instAddCommGroupHom_add, toKaroubi_obj_X, comp_f,\n      decompId_p_f, decompId_i_f, idem, complement_X, complement_p, comp_sub, comp_id,\n      sub_comp, id_comp, sub_self, sub_zero, add_sub_cancel'_right,\n      id_eq, toKaroubi_obj_p]", "start": [124, 1], "end": [148, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/Schwarz.lean", "imports": ["Mathlib/Analysis/Complex/AbsMax.lean", "Mathlib/Analysis/Complex/RemovableSingularity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.schwarz_aux", "code": "theorem schwarz_aux {f : \u2102 \u2192 \u2102} (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (hz : z \u2208 ball c R\u2081) :\n    \u2016dslope f c z\u2016 \u2264 R\u2082 / R\u2081", "start": [64, 1], "end": [88, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_dslope_le_div_of_mapsTo_ball", "code": "theorem norm_dslope_le_div_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (hz : z \u2208 ball c R\u2081) :\n    \u2016dslope f c z\u2016 \u2264 R\u2082 / R\u2081", "start": [91, 1], "end": [108, 91], "kind": "commanddeclaration"}, {"full_name": "Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div", "code": "theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div [CompleteSpace E] [StrictConvexSpace \u211d E]\n    (hd : DifferentiableOn \u2102 f (ball c R\u2081)) (h_maps : Set.MapsTo f (ball c R\u2081) (ball (f c) R\u2082))\n    (h_z\u2080 : z\u2080 \u2208 ball c R\u2081) (h_eq : \u2016dslope f c z\u2080\u2016 = R\u2082 / R\u2081) :\n    Set.EqOn f (fun z => f c + (z - c) \u2022 dslope f c z\u2080) (ball c R\u2081)", "start": [111, 1], "end": [129, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div'", "code": "theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div' [CompleteSpace E]\n    [StrictConvexSpace \u211d E] (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : Set.MapsTo f (ball c R\u2081) (ball (f c) R\u2082))\n    (h_z\u2080 : \u2203 z\u2080 \u2208 ball c R\u2081, \u2016dslope f c z\u2080\u2016 = R\u2082 / R\u2081) :\n    \u2203 C : E, \u2016C\u2016 = R\u2082 / R\u2081 \u2227 Set.EqOn f (fun z => f c + (z - c) \u2022 C) (ball c R\u2081)", "start": [132, 1], "end": [138, 96], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_deriv_le_div_of_mapsTo_ball", "code": "theorem norm_deriv_le_div_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (h\u2080 : 0 < R\u2081) : \u2016deriv f c\u2016 \u2264 R\u2082 / R\u2081", "start": [141, 1], "end": [146, 96], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_le_div_mul_dist_of_mapsTo_ball", "code": "theorem dist_le_div_mul_dist_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (hz : z \u2208 ball c R\u2081) :\n    dist (f z) (f c) \u2264 R\u2082 / R\u2081 * dist z c", "start": [149, 1], "end": [158, 100], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_deriv_le_div_of_mapsTo_ball", "code": "theorem abs_deriv_le_div_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (h\u2080 : 0 < R\u2081) : abs (deriv f c) \u2264 R\u2082 / R\u2081", "start": [165, 1], "end": [170, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_deriv_le_one_of_mapsTo_ball", "code": "theorem abs_deriv_le_one_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (h\u2080 : 0 < R) : abs (deriv f c) \u2264 1", "start": [173, 1], "end": [178, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_le_dist_of_mapsTo_ball_self", "code": "theorem dist_le_dist_of_mapsTo_ball_self (hd : DifferentiableOn \u2102 f (ball c R))\n    (h_maps : MapsTo f (ball c R) (ball c R)) (hc : f c = c) (hz : z \u2208 ball c R) :\n    dist (f z) c \u2264 dist z c", "start": [181, 1], "end": [189, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_le_abs_of_mapsTo_ball_self", "code": "theorem abs_le_abs_of_mapsTo_ball_self (hd : DifferentiableOn \u2102 f (ball 0 R))\n    (h_maps : MapsTo f (ball 0 R) (ball 0 R)) (h\u2080 : f 0 = 0) (hz : abs z < R) :\n    abs (f z) \u2264 abs z", "start": [192, 1], "end": [198, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/PartialFun.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/CategoryTheory/Category/Pointed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PartialFun", "code": "def PartialFun : Type _ :=\n  Type*", "start": [38, 1], "end": [40, 8], "kind": "commanddeclaration"}, {"full_name": "PartialFun.of", "code": "def of : Type* \u2192 PartialFun :=\n  id", "start": [50, 1], "end": [52, 5], "kind": "commanddeclaration"}, {"full_name": "PartialFun.largeCategory", "code": "instance largeCategory : LargeCategory.{u} PartialFun where\n  Hom := PFun\n  id := PFun.id\n  comp f g := g.comp f\n  id_comp := @PFun.comp_id\n  comp_id := @PFun.id_comp\n  assoc _ _ _ := (PFun.comp_assoc _ _ _).symm", "start": [61, 1], "end": [67, 46], "kind": "commanddeclaration"}, {"full_name": "PartialFun.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : PartialFun.{u}} (e : \u03b1 \u2243 \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom x := e x\n  inv x := e.symm x\n  hom_inv_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.symm_comp_self, PFun.coe_id]\n    rfl)\n  inv_hom_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.self_comp_symm, PFun.coe_id]\n    rfl)", "start": [70, 1], "end": [80, 9], "kind": "commanddeclaration"}, {"full_name": "typeToPartialFun", "code": "def typeToPartialFun : Type u \u2964 PartialFun where\n  obj := id\n  map := @PFun.lift\n  map_comp _ _ := PFun.coe_comp _ _", "start": [85, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "pointedToPartialFun", "code": "@[simps map]\ndef pointedToPartialFun : Pointed.{u} \u2964 PartialFun where\n  obj X := { x : X // x \u2260 X.point }\n  map f := PFun.toSubtype _ f.toFun \u2218 Subtype.val\n  map_id X :=\n    PFun.ext fun a b => PFun.mem_toSubtype_iff.trans (Subtype.coe_inj.trans Part.mem_some_iff.symm)\n  map_comp f g := by\n    apply PFun.ext _\n    rintro \u27e8a, ha\u27e9 \u27e8c, hc\u27e9\n    constructor\n    \u00b7 rintro \u27e8h\u2081, h\u2082\u27e9\n      exact \u27e8\u27e8fun h\u2080 => h\u2081 ((congr_arg g.toFun h\u2080).trans g.map_point), h\u2081\u27e9, h\u2082\u27e9\n    \u00b7 rintro \u27e8_, _, _\u27e9\n      exact \u27e8_, rfl\u27e9", "start": [95, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "partialFunToPointed", "code": "@[simps map]\nnoncomputable def partialFunToPointed : PartialFun \u2964 Pointed := by\n  classical\n  exact\n    { obj := fun X => \u27e8Option X, none\u27e9\n      map := fun f => \u27e8Option.elim' none fun a => (f a).toOption, rfl\u27e9\n      map_id := fun X => Pointed.Hom.ext _ _ <| funext fun o => Option.recOn o rfl fun a => (by\n        dsimp [CategoryStruct.id]\n        convert Part.some_toOption a)\n      map_comp := fun f g => Pointed.Hom.ext _ _ <| funext fun o => Option.recOn o rfl fun a => by\n        dsimp [CategoryStruct.comp]\n        rw [Part.bind_toOption g (f a), Option.elim'_eq_elim] }", "start": [114, 1], "end": [128, 64], "kind": "commanddeclaration"}, {"full_name": "partialFunEquivPointed", "code": "@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} \u224c Pointed :=\n  CategoryTheory.Equivalence.mk partialFunToPointed pointedToPartialFun\n    (NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => \u27e8some a, some_ne_none a\u27e9\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun a => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          refine' (Part.mem_bind_iff.trans _).trans PFun.mem_toSubtype_iff.symm\n          obtain \u27e8b | b, hb\u27e9 := b\n          \u00b7 exact (hb rfl).elim\n          \u00b7 dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            \u00b7 rintro \u27e8_, \u27e8h\u2081, h\u2082\u27e9, h\u2083\u27e9\n              rw [h\u2083, \u2190 h\u2082, dif_pos h\u2081]\n            \u00b7 intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              refine' \u27e8b, \u27e8ha, h.symm\u27e9, rfl\u27e9)\n    (NatIso.ofComponents (fun X => Pointed.Iso.mk\n      { toFun := Option.elim' X.point Subtype.val\n        invFun := fun a => by\n          classical\n          exact if h : a = X.point then none else some \u27e8_, h\u27e9\n        left_inv := fun a => Option.recOn a (dif_pos rfl) fun a => by\n          dsimp\n          rw [dif_neg a.2]\n          rfl\n        right_inv := fun a => by\n          dsimp\n          split_ifs with h\n          \u00b7 rw [h]\n            rfl\n          \u00b7 rfl} rfl)\n      fun {X Y} f =>\n      Pointed.Hom.ext _ _ <|\n        funext fun a =>\n          Option.recOn a f.map_point.symm (by\n            rintro \u27e8a, ha\u27e9\n            change Option.elim' _ _ _ = f.toFun a\n            dsimp\n            rw [Option.elim'_eq_elim, @Part.elim_toOption _ _ _ (Classical.propDecidable _)]\n            split_ifs with h\n            \u00b7 rfl\n            \u00b7 exact Eq.symm (of_not_not h)))", "start": [131, 1], "end": [188, 45], "kind": "commanddeclaration"}, {"full_name": "typeToPartialFunIsoPartialFunToPointed", "code": "@[simps!]\nnoncomputable def typeToPartialFunIsoPartialFunToPointed :\n    typeToPartialFun \u22d9 partialFunToPointed \u2245 typeToPointed :=\n  NatIso.ofComponents\n    (fun X =>\n      { hom := \u27e8id, rfl\u27e9\n        inv := \u27e8id, rfl\u27e9\n        hom_inv_id := rfl\n        inv_hom_id := rfl })\n    fun f =>\n    Pointed.Hom.ext _ _ <|\n      funext fun a => Option.recOn a rfl fun a => by\n        classical\n        convert Part.some_toOption _", "start": [191, 1], "end": [206, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Symmetrized.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "Mathlib/Algebra/Jordan/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SymAlg", "code": "def SymAlg (\u03b1 : Type*) : Type _ :=\n  \u03b1", "start": [35, 1], "end": [38, 4], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym", "code": "@[match_pattern]\ndef sym : \u03b1 \u2243 \u03b1\u02e2\u02b8\u1d50 :=\n  Equiv.refl _", "start": [48, 1], "end": [52, 15], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym", "code": "def unsym : \u03b1\u02e2\u02b8\u1d50 \u2243 \u03b1 :=\n  Equiv.refl _", "start": [55, 1], "end": [58, 15], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_sym", "code": "@[simp]\ntheorem unsym_sym (a : \u03b1) : unsym (sym a) = a", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_unsym", "code": "@[simp]\ntheorem sym_unsym (a : \u03b1) : sym (unsym a) = a", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_comp_unsym", "code": "@[simp]\ntheorem sym_comp_unsym : (sym : \u03b1 \u2192 \u03b1\u02e2\u02b8\u1d50) \u2218 unsym = id", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_comp_sym", "code": "@[simp]\ntheorem unsym_comp_sym : (unsym : \u03b1\u02e2\u02b8\u1d50 \u2192 \u03b1) \u2218 sym = id", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_symm", "code": "@[simp]\ntheorem sym_symm : (@sym \u03b1).symm = unsym", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_symm", "code": "@[simp]\ntheorem unsym_symm : (@unsym \u03b1).symm = sym", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_bijective", "code": "theorem sym_bijective : Bijective (sym : \u03b1 \u2192 \u03b1\u02e2\u02b8\u1d50)", "start": [91, 1], "end": [92, 16], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_bijective", "code": "theorem unsym_bijective : Bijective (unsym : \u03b1\u02e2\u02b8\u1d50 \u2192 \u03b1)", "start": [95, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_injective", "code": "theorem sym_injective : Injective (sym : \u03b1 \u2192 \u03b1\u02e2\u02b8\u1d50)", "start": [99, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_surjective", "code": "theorem sym_surjective : Surjective (sym : \u03b1 \u2192 \u03b1\u02e2\u02b8\u1d50)", "start": [103, 1], "end": [104, 17], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_injective", "code": "theorem unsym_injective : Injective (unsym : \u03b1\u02e2\u02b8\u1d50 \u2192 \u03b1)", "start": [107, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_surjective", "code": "theorem unsym_surjective : Surjective (unsym : \u03b1\u02e2\u02b8\u1d50 \u2192 \u03b1)", "start": [111, 1], "end": [112, 19], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_inj", "code": "theorem sym_inj {a b : \u03b1} : sym a = sym b \u2194 a = b", "start": [116, 1], "end": [117, 23], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_inj", "code": "theorem unsym_inj {a b : \u03b1\u02e2\u02b8\u1d50} : unsym a = unsym b \u2194 a = b", "start": [121, 1], "end": [122, 25], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_one", "code": "@[to_additive (attr := simp)]\ntheorem sym_one [One \u03b1] : sym (1 : \u03b1) = 1", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_one", "code": "@[to_additive (attr := simp)]\ntheorem unsym_one [One \u03b1] : unsym (1 : \u03b1\u02e2\u02b8\u1d50) = 1", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_add", "code": "@[simp]\ntheorem sym_add [Add \u03b1] (a b : \u03b1) : sym (a + b) = sym a + sym b", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_add", "code": "@[simp]\ntheorem unsym_add [Add \u03b1] (a b : \u03b1\u02e2\u02b8\u1d50) : unsym (a + b) = unsym a + unsym b", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_sub", "code": "@[simp]\ntheorem sym_sub [Sub \u03b1] (a b : \u03b1) : sym (a - b) = sym a - sym b", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_sub", "code": "@[simp]\ntheorem unsym_sub [Sub \u03b1] (a b : \u03b1\u02e2\u02b8\u1d50) : unsym (a - b) = unsym a - unsym b", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_neg", "code": "@[simp]\ntheorem sym_neg [Neg \u03b1] (a : \u03b1) : sym (-a) = -sym a", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_neg", "code": "@[simp]\ntheorem unsym_neg [Neg \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym (-a) = -unsym a", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.mul_def", "code": "theorem mul_def [Add \u03b1] [Mul \u03b1] [One \u03b1] [OfNat \u03b1 2] [Invertible (2 : \u03b1)] (a b : \u03b1\u02e2\u02b8\u1d50) :\n    a * b = sym (\u215f 2 * (unsym a * unsym b + unsym b * unsym a))", "start": [200, 1], "end": [201, 71], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_mul", "code": "theorem unsym_mul [Mul \u03b1] [Add \u03b1] [One \u03b1] [OfNat \u03b1 2] [Invertible (2 : \u03b1)] (a b : \u03b1\u02e2\u02b8\u1d50) :\n    unsym (a * b) = \u215f 2 * (unsym a * unsym b + unsym b * unsym a)", "start": [204, 1], "end": [205, 73], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_mul_sym", "code": "theorem sym_mul_sym [Mul \u03b1] [Add \u03b1] [One \u03b1] [OfNat \u03b1 2] [Invertible (2 : \u03b1)] (a b : \u03b1) :\n    sym a * sym b = sym (\u215f 2 * (a * b + b * a))", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_inv", "code": "@[simp, to_additive existing]\ntheorem sym_inv [Inv \u03b1] (a : \u03b1) : sym a\u207b\u00b9 = (sym a)\u207b\u00b9", "start": [214, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_inv", "code": "@[simp, to_additive existing]\ntheorem unsym_inv [Inv \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym a\u207b\u00b9 = (unsym a)\u207b\u00b9", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_smul", "code": "@[simp]\ntheorem sym_smul {R : Type*} [SMul R \u03b1] (c : R) (a : \u03b1) : sym (c \u2022 a) = c \u2022 sym a", "start": [225, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_smul", "code": "@[simp]\ntheorem unsym_smul {R : Type*} [SMul R \u03b1] (c : R) (a : \u03b1\u02e2\u02b8\u1d50) : unsym (c \u2022 a) = c \u2022 unsym a", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem unsym_eq_one_iff [One \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym a = 1 \u2194 a = 1", "start": [235, 1], "end": [237, 30], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem sym_eq_one_iff [One \u03b1] (a : \u03b1) : sym a = 1 \u2194 a = 1", "start": [241, 1], "end": [243, 28], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_ne_one_iff", "code": "@[to_additive]\ntheorem unsym_ne_one_iff [One \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym a \u2260 (1 : \u03b1) \u2194 a \u2260 (1 : \u03b1\u02e2\u02b8\u1d50)", "start": [247, 1], "end": [249, 34], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_ne_one_iff", "code": "@[to_additive]\ntheorem sym_ne_one_iff [One \u03b1] (a : \u03b1) : sym a \u2260 (1 : \u03b1\u02e2\u02b8\u1d50) \u2194 a \u2260 (1 : \u03b1)", "start": [253, 1], "end": [255, 32], "kind": "commanddeclaration"}, {"full_name": "SymAlg.addCommSemigroup", "code": "instance addCommSemigroup [AddCommSemigroup \u03b1] : AddCommSemigroup \u03b1\u02e2\u02b8\u1d50 :=\n  unsym_injective.addCommSemigroup _ unsym_add", "start": [259, 1], "end": [260, 47], "kind": "commanddeclaration"}, {"full_name": "SymAlg.addMonoid", "code": "instance addMonoid [AddMonoid \u03b1] : AddMonoid \u03b1\u02e2\u02b8\u1d50 :=\n  unsym_injective.addMonoid _ unsym_zero unsym_add fun _ _ => rfl", "start": [262, 1], "end": [263, 66], "kind": "commanddeclaration"}, {"full_name": "SymAlg.addGroup", "code": "instance addGroup [AddGroup \u03b1] : AddGroup \u03b1\u02e2\u02b8\u1d50 :=\n  unsym_injective.addGroup _ unsym_zero unsym_add unsym_neg unsym_sub (fun _ _ => rfl) fun _ _ =>\n    rfl", "start": [265, 1], "end": [267, 8], "kind": "commanddeclaration"}, {"full_name": "SymAlg.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid \u03b1] : AddCommMonoid \u03b1\u02e2\u02b8\u1d50 :=\n  { SymAlg.addCommSemigroup, SymAlg.addMonoid with }", "start": [269, 1], "end": [270, 53], "kind": "commanddeclaration"}, {"full_name": "SymAlg.addCommGroup", "code": "instance addCommGroup [AddCommGroup \u03b1] : AddCommGroup \u03b1\u02e2\u02b8\u1d50 :=\n  { SymAlg.addCommMonoid, SymAlg.addGroup with }", "start": [272, 1], "end": [273, 49], "kind": "commanddeclaration"}, {"full_name": "SymAlg.invOf_sym", "code": "@[simp]\ntheorem invOf_sym [Mul \u03b1] [AddMonoidWithOne \u03b1] [Invertible (2 : \u03b1)] (a : \u03b1) [Invertible a] :\n    \u215f (sym a) = sym (\u215f a)", "start": [286, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "SymAlg.nonAssocSemiring", "code": "instance nonAssocSemiring [Semiring \u03b1] [Invertible (2 : \u03b1)] : NonAssocSemiring \u03b1\u02e2\u02b8\u1d50 :=\n  { SymAlg.addCommMonoid with\n    one := 1\n    mul := (\u00b7 * \u00b7)\n    zero_mul := fun _ => by\n      rw [mul_def, unsym_zero, zero_mul, mul_zero, add_zero,\n        mul_zero, sym_zero]\n    mul_zero := fun _ => by\n      rw [mul_def, unsym_zero, zero_mul, mul_zero, add_zero,\n        mul_zero, sym_zero]\n    mul_one := fun _ => by\n      rw [mul_def, unsym_one, mul_one, one_mul, \u2190 two_mul, invOf_mul_self_assoc, sym_unsym]\n    one_mul := fun _ => by\n      rw [mul_def, unsym_one, mul_one, one_mul, \u2190 two_mul, invOf_mul_self_assoc, sym_unsym]\n    left_distrib := fun a b c => by\n      rw [mul_def, mul_def, mul_def, \u2190 sym_add, \u2190 mul_add, unsym_add, add_mul]\n      congr 2\n      rw [mul_add]\n      abel\n    right_distrib := fun a b c => by\n      rw [mul_def, mul_def, mul_def, \u2190 sym_add, \u2190 mul_add, unsym_add, add_mul]\n      congr 2\n      rw [mul_add]\n      abel }", "start": [292, 1], "end": [317, 13], "kind": "commanddeclaration"}, {"full_name": "SymAlg.unsym_mul_self", "code": "theorem unsym_mul_self [Semiring \u03b1] [Invertible (2 : \u03b1)] (a : \u03b1\u02e2\u02b8\u1d50) :\n    unsym (a * a) = unsym a * unsym a", "start": [326, 1], "end": [327, 101], "kind": "commanddeclaration"}, {"full_name": "SymAlg.sym_mul_self", "code": "theorem sym_mul_self [Semiring \u03b1] [Invertible (2 : \u03b1)] (a : \u03b1) : sym (a * a) = sym a * sym a", "start": [330, 1], "end": [331, 52], "kind": "commanddeclaration"}, {"full_name": "SymAlg.mul_comm", "code": "theorem mul_comm [Mul \u03b1] [AddCommSemigroup \u03b1] [One \u03b1] [OfNat \u03b1 2] [Invertible (2 : \u03b1)]\n    (a b : \u03b1\u02e2\u02b8\u1d50) :\n    a * b = b * a", "start": [334, 1], "end": [336, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/FullSubcategory.lean", "imports": ["Mathlib/CategoryTheory/Limits/Creates.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.ClosedUnderLimitsOfShape", "code": "def ClosedUnderLimitsOfShape {C : Type u} [Category.{v} C] (J : Type w) [Category.{w'} J]\n    (P : C \u2192 Prop) : Prop :=\n  \u2200 \u2983F : J \u2964 C\u2984 \u2983c : Cone F\u2984 (_hc : IsLimit c), (\u2200 j, P (F.obj j)) \u2192 P c.pt", "start": [28, 1], "end": [32, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ClosedUnderColimitsOfShape", "code": "def ClosedUnderColimitsOfShape {C : Type u} [Category.{v} C] (J : Type w) [Category.{w'} J]\n    (P : C \u2192 Prop) : Prop :=\n  \u2200 \u2983F : J \u2964 C\u2984 \u2983c : Cocone F\u2984 (_hc : IsColimit c), (\u2200 j, P (F.obj j)) \u2192 P c.pt", "start": [35, 1], "end": [39, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ClosedUnderLimitsOfShape.limit", "code": "theorem ClosedUnderLimitsOfShape.limit (h : ClosedUnderLimitsOfShape J P) {F : J \u2964 C} [HasLimit F] :\n    (\u2200 j, P (F.obj j)) \u2192 P (limit F)", "start": [46, 1], "end": [48, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ClosedUnderColimitsOfShape.colimit", "code": "theorem ClosedUnderColimitsOfShape.colimit (h : ClosedUnderColimitsOfShape J P) {F : J \u2964 C}\n    [HasColimit F] : (\u2200 j, P (F.obj j)) \u2192 P (colimit F)", "start": [51, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsLimitFullSubcategoryInclusion'", "code": "def createsLimitFullSubcategoryInclusion' (F : J \u2964 FullSubcategory P)\n    {c : Cone (F \u22d9 fullSubcategoryInclusion P)} (hc : IsLimit c) (h : P c.pt) :\n    CreatesLimit F (fullSubcategoryInclusion P) :=\n  createsLimitOfFullyFaithfulOfIso' hc \u27e8_, h\u27e9 (Iso.refl _)", "start": [62, 1], "end": [67, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsLimitFullSubcategoryInclusion", "code": "def createsLimitFullSubcategoryInclusion (F : J \u2964 FullSubcategory P)\n    [HasLimit (F \u22d9 fullSubcategoryInclusion P)] (h : P (limit (F \u22d9 fullSubcategoryInclusion P))) :\n    CreatesLimit F (fullSubcategoryInclusion P) :=\n  createsLimitFullSubcategoryInclusion' F (limit.isLimit _) h", "start": [70, 1], "end": [75, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsColimitFullSubcategoryInclusion'", "code": "def createsColimitFullSubcategoryInclusion' (F : J \u2964 FullSubcategory P)\n    {c : Cocone (F \u22d9 fullSubcategoryInclusion P)} (hc : IsColimit c) (h : P c.pt) :\n    CreatesColimit F (fullSubcategoryInclusion P) :=\n  createsColimitOfFullyFaithfulOfIso' hc \u27e8_, h\u27e9 (Iso.refl _)", "start": [78, 1], "end": [83, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsColimitFullSubcategoryInclusion", "code": "def createsColimitFullSubcategoryInclusion (F : J \u2964 FullSubcategory P)\n    [HasColimit (F \u22d9 fullSubcategoryInclusion P)]\n    (h : P (colimit (F \u22d9 fullSubcategoryInclusion P))) :\n    CreatesColimit F (fullSubcategoryInclusion P) :=\n  createsColimitFullSubcategoryInclusion' F (colimit.isColimit _) h", "start": [86, 1], "end": [92, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsLimitFullSubcategoryInclusionOfClosed", "code": "def createsLimitFullSubcategoryInclusionOfClosed (h : ClosedUnderLimitsOfShape J P)\n    (F : J \u2964 FullSubcategory P) [HasLimit (F \u22d9 fullSubcategoryInclusion P)] :\n    CreatesLimit F (fullSubcategoryInclusion P) :=\n  createsLimitFullSubcategoryInclusion F (h.limit fun j => (F.obj j).property)", "start": [95, 1], "end": [99, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsLimitsOfShapeFullSubcategoryInclusion", "code": "def createsLimitsOfShapeFullSubcategoryInclusion (h : ClosedUnderLimitsOfShape J P)\n    [HasLimitsOfShape J C] : CreatesLimitsOfShape J (fullSubcategoryInclusion P) where\n  CreatesLimit := @fun F => createsLimitFullSubcategoryInclusionOfClosed h F", "start": [102, 1], "end": [105, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimit_of_closed_under_limits", "code": "theorem hasLimit_of_closed_under_limits (h : ClosedUnderLimitsOfShape J P)\n    (F : J \u2964 FullSubcategory P) [HasLimit (F \u22d9 fullSubcategoryInclusion P)] : HasLimit F", "start": [108, 1], "end": [112, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_closed_under_limits", "code": "theorem hasLimitsOfShape_of_closed_under_limits (h : ClosedUnderLimitsOfShape J P)\n    [HasLimitsOfShape J C] : HasLimitsOfShape J (FullSubcategory P)", "start": [115, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsColimitFullSubcategoryInclusionOfClosed", "code": "def createsColimitFullSubcategoryInclusionOfClosed (h : ClosedUnderColimitsOfShape J P)\n    (F : J \u2964 FullSubcategory P) [HasColimit (F \u22d9 fullSubcategoryInclusion P)] :\n    CreatesColimit F (fullSubcategoryInclusion P) :=\n  createsColimitFullSubcategoryInclusion F (h.colimit fun j => (F.obj j).property)", "start": [120, 1], "end": [124, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.createsColimitsOfShapeFullSubcategoryInclusion", "code": "def createsColimitsOfShapeFullSubcategoryInclusion (h : ClosedUnderColimitsOfShape J P)\n    [HasColimitsOfShape J C] : CreatesColimitsOfShape J (fullSubcategoryInclusion P) where\n  CreatesColimit := @fun F => createsColimitFullSubcategoryInclusionOfClosed h F", "start": [127, 1], "end": [130, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimit_of_closed_under_colimits", "code": "theorem hasColimit_of_closed_under_colimits (h : ClosedUnderColimitsOfShape J P)\n    (F : J \u2964 FullSubcategory P) [HasColimit (F \u22d9 fullSubcategoryInclusion P)] : HasColimit F", "start": [133, 1], "end": [137, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_closed_under_colimits", "code": "theorem hasColimitsOfShape_of_closed_under_colimits (h : ClosedUnderColimitsOfShape J P)\n    [HasColimitsOfShape J C] : HasColimitsOfShape J (FullSubcategory P)", "start": [140, 1], "end": [142, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rbtree/MinMax.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/GroupTheory/Commensurable.lean", "imports": ["Mathlib/GroupTheory/Index.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Commensurable", "code": "def Commensurable (H K : Subgroup G) : Prop :=\n  H.relindex K \u2260 0 \u2227 K.relindex H \u2260 0", "start": [34, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "Commensurable.refl", "code": "@[refl]\nprotected theorem refl (H : Subgroup G) : Commensurable H H", "start": [43, 1], "end": [44, 87], "kind": "commanddeclaration"}, {"full_name": "Commensurable.comm", "code": "theorem comm {H K : Subgroup G} : Commensurable H K \u2194 Commensurable K H", "start": [47, 1], "end": [47, 84], "kind": "commanddeclaration"}, {"full_name": "Commensurable.symm", "code": "@[symm]\ntheorem symm {H K : Subgroup G} : Commensurable H K \u2192 Commensurable K H", "start": [50, 1], "end": [51, 84], "kind": "commanddeclaration"}, {"full_name": "Commensurable.trans", "code": "@[trans]\ntheorem trans {H K L : Subgroup G} (hhk : Commensurable H K) (hkl : Commensurable K L) :\n    Commensurable H L", "start": [54, 1], "end": [57, 93], "kind": "commanddeclaration"}, {"full_name": "Commensurable.equivalence", "code": "theorem equivalence : Equivalence (@Commensurable G _)", "start": [60, 1], "end": [61, 94], "kind": "commanddeclaration"}, {"full_name": "Commensurable.quotConjEquiv", "code": "def quotConjEquiv (H K : Subgroup G) (g : ConjAct G) :\n    K \u29f8 H.subgroupOf K \u2243 (g \u2022 K).1 \u29f8 (g \u2022 H).subgroupOf (g \u2022 K) :=\n  Quotient.congr (K.equivSMul g).toEquiv fun a b => by\n    dsimp\n    rw [\u2190 Quotient.eq'', \u2190 Quotient.eq'', QuotientGroup.eq', QuotientGroup.eq',\n      Subgroup.mem_subgroupOf, Subgroup.mem_subgroupOf, \u2190 MulEquiv.map_inv, \u2190 MulEquiv.map_mul,\n      Subgroup.equivSMul_apply_coe]\n    exact Subgroup.smul_mem_pointwise_smul_iff.symm", "start": [64, 1], "end": [72, 52], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurable_conj", "code": "theorem commensurable_conj {H K : Subgroup G} (g : ConjAct G) :\n    Commensurable H K \u2194 Commensurable (g \u2022 H) (g \u2022 K)", "start": [75, 1], "end": [78, 83], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurable_inv", "code": "theorem commensurable_inv (H : Subgroup G) (g : ConjAct G) :\n    Commensurable (g \u2022 H) H \u2194 Commensurable H (g\u207b\u00b9 \u2022 H)", "start": [81, 1], "end": [82, 101], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurator'", "code": "def commensurator' (H : Subgroup G) : Subgroup (ConjAct G) where\n  carrier := { g : ConjAct G | Commensurable (g \u2022 H) H }\n  one_mem' := by rw [Set.mem_setOf_eq, one_smul]\n  mul_mem' ha hb := by\n    rw [Set.mem_setOf_eq, mul_smul]\n    exact trans ((commensurable_conj _).mp hb) ha\n  inv_mem' _ := by rwa [Set.mem_setOf_eq, comm, \u2190 commensurable_inv]", "start": [85, 1], "end": [93, 69], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurator", "code": "def commensurator (H : Subgroup G) : Subgroup G :=\n  (commensurator' H).comap ConjAct.toConjAct.toMonoidHom", "start": [96, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurator'_mem_iff", "code": "@[simp]\ntheorem commensurator'_mem_iff (H : Subgroup G) (g : ConjAct G) :\n    g \u2208 commensurator' H \u2194 Commensurable (g \u2022 H) H", "start": [102, 1], "end": [104, 62], "kind": "commanddeclaration"}, {"full_name": "Commensurable.commensurator_mem_iff", "code": "@[simp]\ntheorem commensurator_mem_iff (H : Subgroup G) (g : G) :\n    g \u2208 commensurator H \u2194 Commensurable (ConjAct.toConjAct g \u2022 H) H", "start": [107, 1], "end": [109, 79], "kind": "commanddeclaration"}, {"full_name": "Commensurable.eq", "code": "theorem eq {H K : Subgroup G} (hk : Commensurable H K) : commensurator H = commensurator K", "start": [112, 1], "end": [115, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Zero.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/ZeroObjects.lean", "Mathlib/Algebra/Category/GroupCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GroupCat.isZero_of_subsingleton", "code": "@[to_additive]\ntheorem isZero_of_subsingleton (G : GroupCat) [Subsingleton G] : IsZero G", "start": [27, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "CommGroupCat.isZero_of_subsingleton", "code": "@[to_additive]\ntheorem isZero_of_subsingleton (G : CommGroupCat) [Subsingleton G] : IsZero G", "start": [48, 1], "end": [55, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat/Completion.lean", "imports": ["Mathlib/Analysis/Normed/Group/SemiNormedGroupCat.lean", "Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/Analysis/Normed/Group/HomCompletion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiNormedGroupCat.completion", "code": "@[simps]\ndef completion : SemiNormedGroupCat.{u} \u2964 SemiNormedGroupCat.{u} where\n  obj V := SemiNormedGroupCat.of (Completion V)\n  map f := f.completion\n  map_id _ := completion_id\n  map_comp f g := (completion_comp f g).symm", "start": [45, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion_completeSpace", "code": "instance completion_completeSpace {V : SemiNormedGroupCat} : CompleteSpace (completion.obj V) :=\n  Completion.completeSpace _", "start": [54, 1], "end": [55, 29], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.incl", "code": "@[simps]\ndef completion.incl {V : SemiNormedGroupCat} : V \u27f6 completion.obj V where\n  toFun v := (v : Completion V)\n  map_add' := Completion.coe_add\n  bound' := \u27e81, fun v => by simp\u27e9", "start": [58, 1], "end": [63, 34], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.norm_incl_eq", "code": "theorem completion.norm_incl_eq {V : SemiNormedGroupCat} {v : V} : \u2016completion.incl v\u2016 = \u2016v\u2016", "start": [69, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.map_normNoninc", "code": "theorem completion.map_normNoninc {V W : SemiNormedGroupCat} {f : V \u27f6 W} (hf : f.NormNoninc) :\n    (completion.map f).NormNoninc", "start": [73, 1], "end": [77, 67], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.mapHom", "code": "def completion.mapHom (V W : SemiNormedGroupCat.{u}) :\n    have (V W : SemiNormedGroupCat.{u}) : AddGroup (V \u27f6 W) := inferInstanceAs <| AddGroup\n      <| NormedAddGroupHom V W\n    (V \u27f6 W) \u2192+ (completion.obj V \u27f6 completion.obj W) :=\n  @AddMonoidHom.mk' _ _ (_) (_) completion.map fun f g => f.completion_add g", "start": [82, 1], "end": [91, 77], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.map_zero", "code": "theorem completion.map_zero (V W : SemiNormedGroupCat) : completion.map (0 : V \u27f6 W) = 0", "start": [95, 1], "end": [97, 61], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.lift", "code": "def completion.lift {V W : SemiNormedGroupCat} [CompleteSpace W] [SeparatedSpace W] (f : V \u27f6 W) :\n    completion.obj V \u27f6 W where\n  toFun := f.extension\n  map_add' := f.extension.toAddMonoidHom.map_add'\n  bound' := f.extension.bound'", "start": [125, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.lift_comp_incl", "code": "theorem completion.lift_comp_incl {V W : SemiNormedGroupCat} [CompleteSpace W] [SeparatedSpace W]\n    (f : V \u27f6 W) : completion.incl \u226b completion.lift f = f", "start": [135, 1], "end": [137, 43], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.completion.lift_unique", "code": "theorem completion.lift_unique {V W : SemiNormedGroupCat} [CompleteSpace W] [SeparatedSpace W]\n    (f : V \u27f6 W) (g : completion.obj V \u27f6 W) : completion.incl \u226b g = f \u2192 g = completion.lift f", "start": [140, 1], "end": [142, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Comap.lean", "imports": ["Mathlib/Data/MvPolynomial/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.comap", "code": "noncomputable def comap (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R) : (\u03c4 \u2192 R) \u2192 \u03c3 \u2192 R :=\n  fun x i => aeval x (f (X i))", "start": [33, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_apply", "code": "@[simp]\ntheorem comap_apply (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R) (x : \u03c4 \u2192 R) (i : \u03c3) :\n    comap f x i = aeval x (f (X i))", "start": [41, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_id_apply", "code": "@[simp]\ntheorem comap_id_apply (x : \u03c3 \u2192 R) : comap (AlgHom.id R (MvPolynomial \u03c3 R)) x = x", "start": [47, 1], "end": [50, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_id", "code": "theorem comap_id : comap (AlgHom.id R (MvPolynomial \u03c3 R)) = id", "start": [55, 1], "end": [57, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_comp_apply", "code": "theorem comap_comp_apply (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R)\n    (g : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c5 R) (x : \u03c5 \u2192 R) :\n    comap (g.comp f) x = comap f (comap g x)", "start": [62, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_comp", "code": "theorem comap_comp (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R)\n    (g : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c5 R) : comap (g.comp f) = comap f \u2218 comap g", "start": [77, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_eq_id_of_eq_id", "code": "theorem comap_eq_id_of_eq_id (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c3 R) (hf : \u2200 \u03c6, f \u03c6 = \u03c6)\n    (x : \u03c3 \u2192 R) : comap f x = x", "start": [83, 1], "end": [87, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comap_rename", "code": "theorem comap_rename (f : \u03c3 \u2192 \u03c4) (x : \u03c4 \u2192 R) : comap (rename f) x = x \u2218 f", "start": [90, 1], "end": [92, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comapEquiv", "code": "noncomputable def comapEquiv (f : MvPolynomial \u03c3 R \u2243\u2090[R] MvPolynomial \u03c4 R) : (\u03c4 \u2192 R) \u2243 (\u03c3 \u2192 R) where\n  toFun := comap f\n  invFun := comap f.symm\n  left_inv := by\n    intro x\n    rw [\u2190 comap_comp_apply]\n    apply comap_eq_id_of_eq_id\n    intro\n    simp only [AlgHom.id_apply, AlgEquiv.comp_symm]\n  right_inv := by\n    intro x\n    rw [\u2190 comap_comp_apply]\n    apply comap_eq_id_of_eq_id\n    intro\n    simp only [AlgHom.id_apply, AlgEquiv.symm_comp]", "start": [95, 1], "end": [112, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comapEquiv_coe", "code": "@[simp]\ntheorem comapEquiv_coe (f : MvPolynomial \u03c3 R \u2243\u2090[R] MvPolynomial \u03c4 R) :\n    (comapEquiv f : (\u03c4 \u2192 R) \u2192 \u03c3 \u2192 R) = comap f", "start": [115, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comapEquiv_symm_coe", "code": "@[simp]\ntheorem comapEquiv_symm_coe (f : MvPolynomial \u03c3 R \u2243\u2090[R] MvPolynomial \u03c4 R) :\n    ((comapEquiv f).symm : (\u03c3 \u2192 R) \u2192 \u03c4 \u2192 R) = comap f.symm", "start": [121, 1], "end": [124, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/GroupCohomology/Basic.lean", "imports": ["Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "Mathlib/Algebra/Homology/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GroupCohomology.linearYonedaObjResolution", "code": "abbrev linearYonedaObjResolution (A : Rep k G) : CochainComplex (ModuleCat.{u} k) \u2115 :=\n  HomologicalComplex.unop\n    ((((linearYoneda k (Rep k G)).obj A).rightOp.mapHomologicalComplex _).obj (resolution k G))", "start": [80, 1], "end": [84, 96], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.linearYonedaObjResolution_d_apply", "code": "theorem linearYonedaObjResolution_d_apply {A : Rep k G} (i j : \u2115) (x : (resolution k G).X i \u27f6 A) :\n    (linearYonedaObjResolution A).d i j x = (resolution k G).d j i \u226b x", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "InhomogeneousCochains.d", "code": "@[simps]\ndef d [Monoid G] (n : \u2115) (A : Rep k G) : ((Fin n \u2192 G) \u2192 A) \u2192\u2097[k] (Fin (n + 1) \u2192 G) \u2192 A where\n  toFun f g :=\n    A.\u03c1 (g 0) (f fun i => g i.succ) +\n      Finset.univ.sum fun j : Fin (n + 1) =>\n        (-1 : k) ^ ((j : \u2115) + 1) \u2022 f (Fin.contractNth j (\u00b7 * \u00b7) g)\n  map_add' f g := by\n    ext x\n\n    simp_rw [Pi.add_apply, map_add, smul_add, Finset.sum_add_distrib, add_add_add_comm]\n  map_smul' r f := by\n    ext x\n\n    simp_rw [Pi.smul_apply, RingHom.id_apply, map_smul, smul_add, Finset.smul_sum, \u2190 smul_assoc,\n      smul_eq_mul, mul_comm r]", "start": [98, 1], "end": [114, 31], "kind": "commanddeclaration"}, {"full_name": "InhomogeneousCochains.d_eq", "code": "@[nolint checkType] theorem d_eq :\n    d n A =\n      (diagonalHomEquiv n A).toModuleIso.inv \u226b\n        (linearYonedaObjResolution A).d n (n + 1) \u226b\n          (diagonalHomEquiv (n + 1) A).toModuleIso.hom", "start": [120, 1], "end": [166, 73], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.inhomogeneousCochains", "code": "noncomputable abbrev inhomogeneousCochains : CochainComplex (ModuleCat k) \u2115 :=\n  CochainComplex.of (fun n => ModuleCat.of k ((Fin n \u2192 G) \u2192 A))\n    (fun n => InhomogeneousCochains.d n A) fun n => by\n\n    ext x\n    have := LinearMap.ext_iff.1 ((linearYonedaObjResolution A).d_comp_d n (n + 1) (n + 2))\n    simp only [ModuleCat.comp_def, LinearMap.comp_apply] at this\n    dsimp only\n    simp only [d_eq, LinearEquiv.toModuleIso_inv, LinearEquiv.toModuleIso_hom, ModuleCat.coe_comp,\n      Function.comp_apply]\n    \n    erw [LinearEquiv.symm_apply_apply, this]\n    exact map_zero _", "start": [177, 1], "end": [200, 21], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.inhomogeneousCochainsIso", "code": "def inhomogeneousCochainsIso : inhomogeneousCochains A \u2245 linearYonedaObjResolution A := by\n\n  refine' HomologicalComplex.Hom.isoOfComponents (fun i =>\n    (Rep.diagonalHomEquiv i A).toModuleIso.symm) _\n  rintro i j (h : i + 1 = j)\n  subst h\n  simp only [CochainComplex.of_d, d_eq, Category.assoc, Iso.symm_hom, Iso.hom_inv_id,\n    Category.comp_id]", "start": [203, 1], "end": [212, 22], "kind": "commanddeclaration"}, {"full_name": "groupCohomology", "code": "def groupCohomology [Group G] (A : Rep k G) (n : \u2115) : ModuleCat k :=\n  (inhomogeneousCochains A).homology n", "start": [219, 1], "end": [222, 39], "kind": "commanddeclaration"}, {"full_name": "groupCohomologyIsoExt", "code": "def groupCohomologyIsoExt [Group G] (A : Rep k G) (n : \u2115) :\n    groupCohomology A n \u2245 ((Ext k (Rep k G) n).obj (Opposite.op <| Rep.trivial k G k)).obj A :=\n  homologyObjIsoOfHomotopyEquiv (HomotopyEquiv.ofIso (inhomogeneousCochainsIso _)) _ \u226a\u226b\n    HomologicalComplex.homologyUnop _ _ \u226a\u226b (extIso k G A n).symm", "start": [225, 1], "end": [230, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/PresentedGroup.lean", "imports": ["Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/GroupTheory/FreeGroup/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PresentedGroup", "code": "def PresentedGroup (rels : Set (FreeGroup \u03b1)) :=\n  FreeGroup \u03b1 \u29f8 Subgroup.normalClosure rels", "start": [33, 1], "end": [36, 44], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.of", "code": "def of {rels : Set (FreeGroup \u03b1)} (x : \u03b1) : PresentedGroup rels :=\n  QuotientGroup.mk (FreeGroup.of x)", "start": [44, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.closure_rels_subset_ker", "code": "theorem closure_rels_subset_ker : Subgroup.normalClosure rels \u2264 MonoidHom.ker F", "start": [65, 1], "end": [66, 77], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.to_group_eq_one_of_mem_closure", "code": "theorem to_group_eq_one_of_mem_closure : \u2200 x \u2208 Subgroup.normalClosure rels, F x = 1", "start": [69, 1], "end": [70, 67], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.toGroup", "code": "def toGroup : PresentedGroup rels \u2192* G :=\n  QuotientGroup.lift (Subgroup.normalClosure rels) F (to_group_eq_one_of_mem_closure h)", "start": [73, 1], "end": [76, 88], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.toGroup.of", "code": "@[simp]\ntheorem toGroup.of {x : \u03b1} : toGroup h (of x) = f x", "start": [79, 1], "end": [81, 20], "kind": "commanddeclaration"}, {"full_name": "PresentedGroup.toGroup.unique", "code": "theorem toGroup.unique (g : PresentedGroup rels \u2192* G)\n    (hg : \u2200 x : \u03b1, g (PresentedGroup.of x) = f x) : \u2200 {x}, g x = toGroup h x", "start": [84, 1], "end": [88, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Flat.lean", "imports": ["Mathlib/RingTheory/Noetherian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.Flat", "code": "class Flat (R : Type u) (M : Type v) [CommRing R] [AddCommGroup M] [Module R M] : Prop where\n  out : \u2200 \u2983I : Ideal R\u2984 (_ : I.FG), Injective (TensorProduct.lift ((lsmul R M).comp I.subtype))", "start": [59, 1], "end": [62, 96], "kind": "commanddeclaration"}, {"full_name": "Module.Flat.self", "code": "instance self (R : Type u) [CommRing R] : Flat R R :=\n  \u27e8by\n    intro I _\n    rw [\u2190 Equiv.injective_comp (TensorProduct.rid R I).symm.toEquiv]\n    convert Subtype.coe_injective using 1\n    ext x\n    simp only [Function.comp_apply, LinearEquiv.coe_toEquiv, rid_symm_apply, comp_apply, mul_one,\n      lift.tmul, Submodule.subtype_apply, Algebra.id.smul_eq_mul, lsmul_apply]\u27e9", "start": [69, 1], "end": [76, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/Character.lean", "imports": ["Mathlib/LinearAlgebra/Trace.lean", "Mathlib/RepresentationTheory/Invariants.lean", "Mathlib/RepresentationTheory/FdRep.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FdRep.character", "code": "def character (V : FdRep k G) (g : G) :=\n  LinearMap.trace k V (V.\u03c1 g)", "start": [41, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_mul_comm", "code": "theorem char_mul_comm (V : FdRep k G) (g : G) (h : G) : V.character (h * g) = V.character (g * h)", "start": [47, 1], "end": [48, 52], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_one", "code": "@[simp]\ntheorem char_one (V : FdRep k G) : V.character 1 = FiniteDimensional.finrank k V", "start": [51, 1], "end": [53, 44], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_tensor", "code": "theorem char_tensor (V W : FdRep k G) : (V \u2297 W).character = V.character * W.character", "start": [56, 1], "end": [58, 54], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_tensor'", "code": "@[simp]\ntheorem char_tensor' (V W : FdRep k G) :\n    character (Action.FunctorCategoryEquivalence.inverse.obj\n    (Action.FunctorCategoryEquivalence.functor.obj V \u2297\n     Action.FunctorCategoryEquivalence.functor.obj W)) = V.character * W.character", "start": [62, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_iso", "code": "theorem char_iso {V W : FdRep k G} (i : V \u2245 W) : V.character = W.character", "start": [69, 1], "end": [71, 87], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_conj", "code": "@[simp]\ntheorem char_conj (V : FdRep k G) (g : G) (h : G) : V.character (h * g * h\u207b\u00b9) = V.character g", "start": [80, 1], "end": [83, 42], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_dual", "code": "@[simp]\ntheorem char_dual (V : FdRep k G) (g : G) : (of (dual V.\u03c1)).character g = V.character g\u207b\u00b9", "start": [86, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_linHom", "code": "@[simp]\ntheorem char_linHom (V W : FdRep k G) (g : G) :\n    (of (linHom V.\u03c1 W.\u03c1)).character g = V.character g\u207b\u00b9 * W.character g", "start": [91, 1], "end": [94, 82], "kind": "commanddeclaration"}, {"full_name": "FdRep.average_char_eq_finrank_invariants", "code": "theorem average_char_eq_finrank_invariants (V : FdRep k G) :\n    \u215f (Fintype.card G : k) \u2022 \u2211 g : G, V.character g = finrank k (invariants V.\u03c1)", "start": [99, 1], "end": [102, 57], "kind": "commanddeclaration"}, {"full_name": "FdRep.char_orthonormal", "code": "theorem char_orthonormal (V W : FdRep k G) [Simple V] [Simple W] :\n    \u215f (Fintype.card G : k) \u2022 \u2211 g : G, V.character g * W.character g\u207b\u00b9 =\n      if Nonempty (V \u2245 W) then \u21911 else \u21910", "start": [115, 1], "end": [135, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/NoZeroDivisors.lean", "imports": ["Mathlib/Algebra/Group/UniqueProds.lean", "Mathlib/Algebra/MonoidAlgebra/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonoidAlgebra.mul_apply_mul_eq_mul_of_uniqueMul", "code": "theorem mul_apply_mul_eq_mul_of_uniqueMul [Mul A] {f g : MonoidAlgebra R A} {a0 b0 : A}\n    (h : UniqueMul f.support g.support a0 b0) :\n    (f * g) (a0 * b0) = f a0 * g b0", "start": [66, 1], "end": [79, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.instNoZeroDivisorsOfUniqueProds", "code": "instance instNoZeroDivisorsOfUniqueProds [NoZeroDivisors R] [Mul A] [UniqueProds A] :\n    NoZeroDivisors (MonoidAlgebra R A) where\n  eq_zero_or_eq_zero_of_mul_eq_zero {a b} ab := by\n    contrapose! ab\n    obtain \u27e8da, a0, db, b0, h\u27e9 := UniqueProds.uniqueMul_of_nonempty\n      (support_nonempty_iff.mpr ab.1) (support_nonempty_iff.mpr ab.2)\n    refine support_nonempty_iff.mp \u27e8da * db, ?_\u27e9\n    rw [mem_support_iff] at a0 b0 \u22a2\n    exact mul_apply_mul_eq_mul_of_uniqueMul h \u25b8 mul_ne_zero a0 b0", "start": [81, 1], "end": [89, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_apply_add_eq_mul_of_uniqueAdd", "code": "theorem mul_apply_add_eq_mul_of_uniqueAdd [Add A] {f g : R[A]} {a0 b0 : A}\n    (h : UniqueAdd f.support g.support a0 b0) :\n    (f * g) (a0 + b0) = f a0 * g b0", "start": [95, 1], "end": [100, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Enriched/Basic.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Center.lean", "Mathlib/CategoryTheory/Monoidal/Types/Coyoneda.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/CategoryTheory/Monoidal/Types/Symmetric.lean"], "premises": [{"full_name": "CategoryTheory.EnrichedCategory", "code": "class EnrichedCategory (C : Type u\u2081) where\n  Hom : C \u2192 C \u2192 V\n  id (X : C) : \ud835\udfd9_ V \u27f6 Hom X X\n  comp (X Y Z : C) : Hom X Y \u2297 Hom Y Z \u27f6 Hom X Z\n  id_comp (X Y : C) : (\u03bb_ (Hom X Y)).inv \u226b (id X \u2297 \ud835\udfd9 _) \u226b comp X X Y = \ud835\udfd9 _ := by aesop_cat\n  comp_id (X Y : C) : (\u03c1_ (Hom X Y)).inv \u226b (\ud835\udfd9 _ \u2297 id Y) \u226b comp X Y Y = \ud835\udfd9 _ := by aesop_cat\n  assoc (W X Y Z : C) : (\u03b1_ _ _ _).inv \u226b (comp W X Y \u2297 \ud835\udfd9 _) \u226b comp W Y Z =\n    (\ud835\udfd9 _ \u2297 comp X Y Z) \u226b comp W X Z := by aesop_cat", "start": [47, 1], "end": [59, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eId", "code": "def eId (X : C) : \ud835\udfd9_ V \u27f6 X \u27f6[V] X :=\n  EnrichedCategory.id X", "start": [66, 1], "end": [69, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eComp", "code": "def eComp (X Y Z : C) : ((X \u27f6[V] Y) \u2297 Y \u27f6[V] Z) \u27f6 X \u27f6[V] Z :=\n  EnrichedCategory.comp X Y Z", "start": [72, 1], "end": [75, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.e_id_comp", "code": "@[reassoc (attr := simp)]\ntheorem e_id_comp (X Y : C) :\n    (\u03bb_ (X \u27f6[V] Y)).inv \u226b (eId V X \u2297 \ud835\udfd9 _) \u226b eComp V X X Y = \ud835\udfd9 (X \u27f6[V] Y)", "start": [79, 1], "end": [82, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.e_comp_id", "code": "@[reassoc (attr := simp)]\ntheorem e_comp_id (X Y : C) :\n    (\u03c1_ (X \u27f6[V] Y)).inv \u226b (\ud835\udfd9 _ \u2297 eId V Y) \u226b eComp V X Y Y = \ud835\udfd9 (X \u27f6[V] Y)", "start": [85, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.e_assoc", "code": "@[reassoc (attr := simp)]\ntheorem e_assoc (W X Y Z : C) :\n    (\u03b1_ _ _ _).inv \u226b (eComp V W X Y \u2297 \ud835\udfd9 _) \u226b eComp V W Y Z =\n      (\ud835\udfd9 _ \u2297 eComp V X Y Z) \u226b eComp V W X Z", "start": [91, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.TransportEnrichment", "code": "@[nolint unusedArguments]\ndef TransportEnrichment (_ : LaxMonoidalFunctor V W) (C : Type u\u2081) :=\n  C", "start": [103, 1], "end": [109, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.categoryOfEnrichedCategoryType", "code": "def categoryOfEnrichedCategoryType (C : Type u\u2081) [\ud835\udc9e : EnrichedCategory (Type v) C] : Category.{v} C\n    where\n  Hom := \ud835\udc9e.Hom\n  id X := eId (Type v) X PUnit.unit\n  comp f g := eComp (Type v) _ _ _ \u27e8f, g\u27e9\n  id_comp f := congr_fun (e_id_comp (Type v) _ _) f\n  comp_id f := congr_fun (e_comp_id (Type v) _ _) f\n  assoc f g h := (congr_fun (e_assoc (Type v) _ _ _ _) \u27e8f, g, h\u27e9 : _)", "start": [132, 1], "end": [141, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.enrichedCategoryTypeOfCategory", "code": "def enrichedCategoryTypeOfCategory (C : Type u\u2081) [\ud835\udc9e : Category.{v} C] : EnrichedCategory (Type v) C\n    where\n  Hom := \ud835\udc9e.Hom\n  id X _ := \ud835\udfd9 X\n  comp X Y Z p := p.1 \u226b p.2\n  id_comp X Y := by ext; simp\n  comp_id X Y := by ext; simp\n  assoc W X Y Z := by ext \u27e8f, g, h\u27e9; simp", "start": [144, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.enrichedCategoryTypeEquivCategory", "code": "def enrichedCategoryTypeEquivCategory (C : Type u\u2081) : EnrichedCategory (Type v) C \u2243 Category.{v} C\n    where\n  toFun _ := categoryOfEnrichedCategoryType C\n  invFun _ := enrichedCategoryTypeOfCategory C\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [156, 1], "end": [163, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment", "code": "@[nolint unusedArguments]\ndef ForgetEnrichment (W : Type (v + 1)) [Category.{v} W] [MonoidalCategory W] (C : Type u\u2081)\n    [EnrichedCategory W C] :=\n  C", "start": [171, 1], "end": [191, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.of", "code": "def ForgetEnrichment.of (X : C) : ForgetEnrichment W C :=\n  X", "start": [196, 1], "end": [198, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.to", "code": "def ForgetEnrichment.to (X : ForgetEnrichment W C) : C :=\n  X", "start": [201, 1], "end": [203, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.to_of", "code": "@[simp]\ntheorem ForgetEnrichment.to_of (X : C) : ForgetEnrichment.to W (ForgetEnrichment.of W X) = X", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.of_to", "code": "@[simp]\ntheorem ForgetEnrichment.of_to (X : ForgetEnrichment W C) :\n    ForgetEnrichment.of W (ForgetEnrichment.to W X) = X", "start": [211, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.categoryForgetEnrichment", "code": "instance categoryForgetEnrichment : Category (ForgetEnrichment W C) := by\n  let I : EnrichedCategory (Type v) (TransportEnrichment (coyonedaTensorUnit W) C) :=\n    inferInstance\n  exact enrichedCategoryTypeEquivCategory C I", "start": [217, 1], "end": [220, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.homOf", "code": "def ForgetEnrichment.homOf {X Y : C} (f : \ud835\udfd9_ W \u27f6 X \u27f6[W] Y) :\n    ForgetEnrichment.of W X \u27f6 ForgetEnrichment.of W Y :=\n  f", "start": [229, 1], "end": [232, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.homTo", "code": "def ForgetEnrichment.homTo {X Y : ForgetEnrichment W C} (f : X \u27f6 Y) :\n    \ud835\udfd9_ W \u27f6 ForgetEnrichment.to W X \u27f6[W] ForgetEnrichment.to W Y :=\n  f", "start": [235, 1], "end": [238, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.homTo_homOf", "code": "@[simp]\ntheorem ForgetEnrichment.homTo_homOf {X Y : C} (f : \ud835\udfd9_ W \u27f6 X \u27f6[W] Y) :\n    ForgetEnrichment.homTo W (ForgetEnrichment.homOf W f) = f", "start": [241, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ForgetEnrichment.homOf_homTo", "code": "@[simp]\ntheorem ForgetEnrichment.homOf_homTo {X Y : ForgetEnrichment W C} (f : X \u27f6 Y) :\n    ForgetEnrichment.homOf W (ForgetEnrichment.homTo W f) = f", "start": [247, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forgetEnrichment_id", "code": "@[simp]\ntheorem forgetEnrichment_id (X : ForgetEnrichment W C) :\n    ForgetEnrichment.homTo W (\ud835\udfd9 X) = eId W (ForgetEnrichment.to W X : C)", "start": [253, 1], "end": [257, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forgetEnrichment_id'", "code": "@[simp]\ntheorem forgetEnrichment_id' (X : C) :\n    ForgetEnrichment.homOf W (eId W X) = \ud835\udfd9 (ForgetEnrichment.of W X : C)", "start": [260, 1], "end": [263, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.forgetEnrichment_comp", "code": "@[simp]\ntheorem forgetEnrichment_comp {X Y Z : ForgetEnrichment W C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    ForgetEnrichment.homTo W (f \u226b g) =\n      ((\u03bb_ (\ud835\udfd9_ W)).inv \u226b (ForgetEnrichment.homTo W f \u2297 ForgetEnrichment.homTo W g)) \u226b\n        eComp W _ _ _", "start": [266, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EnrichedFunctor", "code": "structure EnrichedFunctor (C : Type u\u2081) [EnrichedCategory V C] (D : Type u\u2082)\n    [EnrichedCategory V D] where\n  obj : C \u2192 D\n  map : \u2200 X Y : C, (X \u27f6[V] Y) \u27f6 obj X \u27f6[V] obj Y\n  map_id : \u2200 X : C, eId V X \u226b map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    \u2200 X Y Z : C,\n      eComp V X Y Z \u226b map X Z = (map X Y \u2297 map Y Z) \u226b eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat", "start": [277, 1], "end": [289, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EnrichedFunctor.id", "code": "@[simps]\ndef EnrichedFunctor.id (C : Type u\u2081) [EnrichedCategory V C] : EnrichedFunctor V C C where\n  obj X := X\n  map X Y := \ud835\udfd9 _", "start": [296, 1], "end": [300, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EnrichedFunctor.comp", "code": "@[simps]\ndef EnrichedFunctor.comp {C : Type u\u2081} {D : Type u\u2082} {E : Type u\u2083} [EnrichedCategory V C]\n    [EnrichedCategory V D] [EnrichedCategory V E] (F : EnrichedFunctor V C D)\n    (G : EnrichedFunctor V D E) : EnrichedFunctor V C E where\n  obj X := G.obj (F.obj X)\n  map X Y := F.map _ _ \u226b G.map _ _", "start": [306, 1], "end": [312, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EnrichedFunctor.forget", "code": "def EnrichedFunctor.forget {C : Type u\u2081} {D : Type u\u2082} [EnrichedCategory W C] [EnrichedCategory W D]\n    (F : EnrichedFunctor W C D) : ForgetEnrichment W C \u2964 ForgetEnrichment W D where\n  obj X := ForgetEnrichment.of W (F.obj (ForgetEnrichment.to W X))\n  map f :=\n    ForgetEnrichment.homOf W\n      (ForgetEnrichment.homTo W f \u226b F.map (ForgetEnrichment.to W _) (ForgetEnrichment.to W _))\n  map_comp f g := by\n    dsimp\n    apply_fun ForgetEnrichment.homTo W\n    \u00b7 simp only [Iso.cancel_iso_inv_left, Category.assoc, tensor_comp,\n        ForgetEnrichment.homTo_homOf, EnrichedFunctor.map_comp, forgetEnrichment_comp]\n      rfl\n    \u00b7 intro f g w; apply_fun ForgetEnrichment.homOf W at w; simpa using w", "start": [319, 1], "end": [334, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GradedNatTrans", "code": "@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : \u2200 X : C, A.1 \u27f6 F.obj X \u27f6[V] G.obj X\n  naturality :\n    \u2200 X Y : C,\n      (A.2.\u03b2 (X \u27f6[V] Y)).hom \u226b (F.map X Y \u2297 app Y) \u226b eComp V _ _ _ =\n        (app X \u2297 G.map X Y) \u226b eComp V _ _ _", "start": [391, 1], "end": [400, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.enrichedNatTransYoneda", "code": "@[simps]\ndef enrichedNatTransYoneda (F G : EnrichedFunctor V C D) : V\u1d52\u1d56 \u2964 Type max u\u2081 w where\n  obj A := GradedNatTrans ((Center.ofBraided V).obj (unop A)) F G\n  map f \u03c3 :=\n    { app := fun X => f.unop \u226b \u03c3.app X\n      naturality := fun X Y => by\n        have p := \u03c3.naturality X Y\n        dsimp at p \u22a2\n        rw [\u2190 id_tensor_comp_tensor_id (f.unop \u226b \u03c3.app Y) _, id_tensor_comp, Category.assoc,\n          Category.assoc, \u2190 braiding_naturality_assoc, id_tensor_comp_tensor_id_assoc, p, \u2190\n          tensor_comp_assoc, Category.id_comp] }", "start": [407, 1], "end": [420, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.enrichedFunctorTypeEquivFunctor", "code": "@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u\u2081} [\ud835\udc9e : EnrichedCategory (Type v) C] {D : Type u\u2082}\n    [\ud835\udc9f : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D \u2243 C \u2964 D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) \u27e8f, g\u27e9 }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun X Y f => F.map f\n      map_id := fun X => by ext \u27e8\u27e9; exact F.map_id X\n      map_comp := fun X Y Z => by ext \u27e8f, g\u27e9; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [431, 1], "end": [448, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.enrichedNatTransYonedaTypeIsoYonedaNatTrans", "code": "def enrichedNatTransYonedaTypeIsoYonedaNatTrans {C : Type v} [EnrichedCategory (Type v) C]\n    {D : Type v} [EnrichedCategory (Type v) D] (F G : EnrichedFunctor (Type v) C D) :\n    enrichedNatTransYoneda F G \u2245\n      yoneda.obj (enrichedFunctorTypeEquivFunctor F \u27f6 enrichedFunctorTypeEquivFunctor G) :=\n  NatIso.ofComponents\n    (fun \u03b1 =>\n      { hom := fun \u03c3 x =>\n          { app := fun X => \u03c3.app X x\n            naturality := fun X Y f => congr_fun (\u03c3.naturality X Y) \u27e8x, f\u27e9 }\n        inv := fun \u03c3 =>\n          { app := fun X x => (\u03c3 x).app X\n            naturality := fun X Y => by ext \u27e8x, f\u27e9; exact (\u03c3 x).naturality f } })\n    (by aesop_cat)", "start": [451, 1], "end": [467, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/LaxMilgram.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Analysis/InnerProductSpace/Projection.lean", "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/InnerProductSpace/Dual.lean", "Mathlib/Analysis/NormedSpace/Banach.lean"], "premises": [{"full_name": "IsCoercive.bounded_below", "code": "theorem bounded_below (coercive : IsCoercive B) : \u2203 C, 0 < C \u2227 \u2200 v, C * \u2016v\u2016 \u2264 \u2016B\u266f v\u2016", "start": [56, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.antilipschitz", "code": "theorem antilipschitz (coercive : IsCoercive B) : \u2203 C : \u211d\u22650, 0 < C \u2227 AntilipschitzWith C B\u266f", "start": [70, 1], "end": [76, 26], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.ker_eq_bot", "code": "theorem ker_eq_bot (coercive : IsCoercive B) : ker B\u266f = \u22a5", "start": [79, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.closed_range", "code": "theorem closed_range (coercive : IsCoercive B) : IsClosed (range B\u266f : Set V)", "start": [85, 1], "end": [87, 58], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.range_eq_top", "code": "theorem range_eq_top (coercive : IsCoercive B) : range B\u266f = \u22a4", "start": [90, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.continuousLinearEquivOfBilin", "code": "def continuousLinearEquivOfBilin (coercive : IsCoercive B) : V \u2243L[\u211d] V :=\n  ContinuousLinearEquiv.ofBijective B\u266f coercive.ker_eq_bot coercive.range_eq_top", "start": [108, 1], "end": [114, 81], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.continuousLinearEquivOfBilin_apply", "code": "@[simp]\ntheorem continuousLinearEquivOfBilin_apply (coercive : IsCoercive B) (v w : V) :\n    \u27eacoercive.continuousLinearEquivOfBilin v, w\u27eb_\u211d = B v w", "start": [117, 1], "end": [120, 41], "kind": "commanddeclaration"}, {"full_name": "IsCoercive.unique_continuousLinearEquivOfBilin", "code": "theorem unique_continuousLinearEquivOfBilin (coercive : IsCoercive B) {v f : V}\n    (is_lax_milgram : \u2200 w, \u27eaf, w\u27eb_\u211d = B v w) : f = coercive.continuousLinearEquivOfBilin v", "start": [123, 1], "end": [125, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Fubini.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/CategoryTheory/Functor/Currying.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.DiagramOfCones", "code": "structure DiagramOfCones where\n  obj : \u2200 j : J, Cone (F.obj j)\n  map : \u2200 {j j' : J} (f : j \u27f6 j'), (Cones.postcompose (F.map f)).obj (obj j) \u27f6 obj j'\n  id : \u2200 j : J, (map (\ud835\udfd9 j)).hom = \ud835\udfd9 _ := by aesop_cat\n  comp : \u2200 {j\u2081 j\u2082 j\u2083 : J} (f : j\u2081 \u27f6 j\u2082) (g : j\u2082 \u27f6 j\u2083),\n    (map (f \u226b g)).hom = (map f).hom \u226b (map g).hom := by aesop_cat", "start": [54, 1], "end": [61, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.DiagramOfCones.conePoints", "code": "@[simps]\ndef DiagramOfCones.conePoints (D : DiagramOfCones F) : J \u2964 C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g", "start": [66, 1], "end": [74, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfConeUncurry", "code": "@[simps]\ndef coneOfConeUncurry {D : DiagramOfCones F} (Q : \u2200 j, IsLimit (D.obj j))\n    (c : Cone (uncurry.obj F)) : Cone D.conePoints where\n  pt := c.pt\n  \u03c0 :=\n    { app := fun j =>\n        (Q j).lift\n          { pt := c.pt\n            \u03c0 :=\n              { app := fun k => c.\u03c0.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.id_comp]\n                  have := @NatTrans.naturality _ _ _ _ _ _ c.\u03c0 (j, k) (j, k') (\ud835\udfd9 j, f)\n                  dsimp at this\n                  simp? at this says\n                    simp only [Category.id_comp, Functor.map_id, NatTrans.id_app] at this\n                  exact this } }\n      naturality := fun j j' f =>\n        (Q j').hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.ConeMorphism.w, Limits.Cones.postcompose_obj_\u03c0,\n              Limits.IsLimit.fac_assoc, Limits.IsLimit.fac, NatTrans.comp_app, Category.id_comp,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.\u03c0 (j, k) (j', k) (f, \ud835\udfd9 k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }", "start": [77, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfConeUncurryIsLimit", "code": "def coneOfConeUncurryIsLimit {D : DiagramOfCones F} (Q : \u2200 j, IsLimit (D.obj j))\n    {c : Cone (uncurry.obj F)} (P : IsLimit c) : IsLimit (coneOfConeUncurry Q c) where\n  lift s :=\n    P.lift\n      { pt := s.pt\n        \u03c0 :=\n          { app := fun p => s.\u03c0.app p.1 \u226b (D.obj p.1).\u03c0.app p.2\n            naturality := fun p p' f => by\n              dsimp; simp only [Category.id_comp, Category.assoc]\n              rcases p with \u27e8j, k\u27e9\n              rcases p' with \u27e8j', k'\u27e9\n              rcases f with \u27e8fj, fk\u27e9\n              dsimp\n              slice_rhs 3 4 => rw [\u2190 NatTrans.naturality]\n              slice_rhs 2 3 => rw [\u2190 (D.obj j).\u03c0.naturality]\n              simp only [Functor.const_obj_map, Category.id_comp, Category.assoc]\n              have w := (D.map fj).w k'\n              dsimp at w\n              rw [\u2190 w]\n              have n := s.\u03c0.naturality fj\n              dsimp at n\n              simp only [Category.id_comp] at n\n              rw [n]\n              simp } }\n  fac s j := by\n    apply (Q j).hom_ext\n    intro k\n    simp\n  uniq s m w := by\n    refine' P.uniq\n      { pt := s.pt\n        \u03c0 := _ } m _\n    rintro \u27e8j, k\u27e9\n    dsimp\n    rw [\u2190 w j]\n    simp", "start": [112, 1], "end": [149, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits", "code": "@[simps]\nnoncomputable def DiagramOfCones.mkOfHasLimits : DiagramOfCones F where\n  obj j := limit.cone (F.obj j)\n  map f := { hom := lim.map (F.map f) }", "start": [158, 1], "end": [165, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramOfConesInhabited", "code": "noncomputable instance diagramOfConesInhabited : Inhabited (DiagramOfCones F) :=\n  \u27e8DiagramOfCones.mkOfHasLimits F\u27e9", "start": [169, 1], "end": [170, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_conePoints", "code": "@[simp]\ntheorem DiagramOfCones.mkOfHasLimits_conePoints :\n    (DiagramOfCones.mkOfHasLimits F).conePoints = F \u22d9 lim", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitUncurryIsoLimitCompLim", "code": "noncomputable def limitUncurryIsoLimitCompLim : limit (uncurry.obj F) \u2245 limit (F \u22d9 lim) := by\n  let c := limit.cone (uncurry.obj F)\n  let P : IsLimit c := limit.isLimit _\n  let G := DiagramOfCones.mkOfHasLimits F\n  let Q : \u2200 j, IsLimit (G.obj j) := fun j => limit.isLimit _\n  have Q' := coneOfConeUncurryIsLimit Q P\n  have Q'' := limit.isLimit (F \u22d9 lim)\n  exact IsLimit.conePointUniqueUpToIso Q' Q''", "start": [183, 1], "end": [194, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitUncurryIsoLimitCompLim_hom_\u03c0_\u03c0", "code": "@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_hom_\u03c0_\u03c0 {j} {k} :\n    (limitUncurryIsoLimitCompLim F).hom \u226b limit.\u03c0 _ j \u226b limit.\u03c0 _ k = limit.\u03c0 _ (j, k)", "start": [197, 1], "end": [201, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitUncurryIsoLimitCompLim_inv_\u03c0", "code": "@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_inv_\u03c0 {j} {k} :\n    (limitUncurryIsoLimitCompLim F).inv \u226b limit.\u03c0 _ (j, k) =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k : limit (_ \u22d9 lim) \u27f6 _)", "start": [205, 1], "end": [210, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim", "code": "noncomputable def limitFlipCompLimIsoLimitCompLim : limit (F.flip \u22d9 lim) \u2245 limit (F \u22d9 lim) :=\n  (limitUncurryIsoLimitCompLim _).symm \u226a\u226b\n    HasLimit.isoOfNatIso (uncurryObjFlip _) \u226a\u226b\n      HasLimit.isoOfEquivalence (Prod.braiding _ _)\n          (NatIso.ofComponents fun _ => by rfl) \u226a\u226b\n        limitUncurryIsoLimitCompLim _", "start": [222, 1], "end": [228, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_hom_\u03c0_\u03c0", "code": "@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_hom_\u03c0_\u03c0 (j) (k) :\n    (limitFlipCompLimIsoLimitCompLim F).hom \u226b limit.\u03c0 _ j \u226b limit.\u03c0 _ k =\n      (limit.\u03c0 _ k \u226b limit.\u03c0 _ j : limit (_ \u22d9 lim) \u27f6 _)", "start": [232, 1], "end": [237, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_inv_\u03c0_\u03c0", "code": "@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_inv_\u03c0_\u03c0 (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv \u226b limit.\u03c0 _ k \u226b limit.\u03c0 _ j =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k : limit (_ \u22d9 lim) \u27f6 _)", "start": [242, 1], "end": [247, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitIsoLimitCurryCompLim", "code": "noncomputable def limitIsoLimitCurryCompLim : limit G \u2245 limit (curry.obj G \u22d9 lim) := by\n  have i : G \u2245 uncurry.obj ((@curry J _ K _ C _).obj G) := currying.symm.unitIso.app G\n  haveI : Limits.HasLimit (uncurry.obj ((@curry J _ K _ C _).obj G)) := hasLimitOfIso i\n  trans limit (uncurry.obj ((@curry J _ K _ C _).obj G))\n  apply HasLimit.isoOfNatIso i\n  exact limitUncurryIsoLimitCompLim ((@curry J _ K _ C _).obj G)", "start": [264, 1], "end": [273, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitIsoLimitCurryCompLim_hom_\u03c0_\u03c0", "code": "@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_hom_\u03c0_\u03c0 {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom \u226b limit.\u03c0 _ j \u226b limit.\u03c0 _ k = limit.\u03c0 _ (j, k)", "start": [276, 1], "end": [279, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitIsoLimitCurryCompLim_inv_\u03c0", "code": "@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_inv_\u03c0 {j} {k} :\n    (limitIsoLimitCurryCompLim G).inv \u226b limit.\u03c0 _ (j, k) =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k : limit (_ \u22d9 lim) \u27f6 _)", "start": [283, 1], "end": [288, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim", "code": "noncomputable def limitCurrySwapCompLimIsoLimitCurryCompLim :\n    limit (curry.obj (Prod.swap K J \u22d9 G) \u22d9 lim) \u2245 limit (curry.obj G \u22d9 lim) :=\n  calc\n    limit (curry.obj (Prod.swap K J \u22d9 G) \u22d9 lim) \u2245 limit (Prod.swap K J \u22d9 G) :=\n      (limitIsoLimitCurryCompLim _).symm\n    _ \u2245 limit G := (HasLimit.isoOfEquivalence (Prod.braiding K J) (Iso.refl _))\n    _ \u2245 limit (curry.obj G \u22d9 lim) := limitIsoLimitCurryCompLim _", "start": [300, 1], "end": [309, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_\u03c0_\u03c0", "code": "@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_hom_\u03c0_\u03c0 {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom \u226b limit.\u03c0 _ j \u226b limit.\u03c0 _ k =\n      (limit.\u03c0 _ k \u226b limit.\u03c0 _ j : limit (_ \u22d9 lim) \u27f6 _)", "start": [313, 1], "end": [326, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_inv_\u03c0_\u03c0", "code": "@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_inv_\u03c0_\u03c0 {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).inv \u226b limit.\u03c0 _ k \u226b limit.\u03c0 _ j =\n      (limit.\u03c0 _ j \u226b limit.\u03c0 _ k : limit (_ \u22d9 lim) \u27f6 _)", "start": [331, 1], "end": [340, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/PiInduction.lean", "imports": ["Mathlib/Data/Finset/Sigma.lean", "Mathlib/Data/Fintype/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.induction_on_pi_of_choice", "code": "theorem induction_on_pi_of_choice (r : \u2200 i, \u03b1 i \u2192 Finset (\u03b1 i) \u2192 Prop)\n    (H_ex : \u2200 (i) (s : Finset (\u03b1 i)) (_ : s.Nonempty), \u2203 x \u2208 s, r i x (s.erase x))\n    {p : (\u2200 i, Finset (\u03b1 i)) \u2192 Prop} (f : \u2200 i, Finset (\u03b1 i)) (h0 : p fun _ \u21a6 \u2205)\n    (step :\n      \u2200 (g : \u2200 i, Finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i),\n        r i x (g i) \u2192 p g \u2192 p (update g i (insert x (g i)))) :\n    p f", "start": [36, 1], "end": [64, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_pi", "code": "theorem induction_on_pi {p : (\u2200 i, Finset (\u03b1 i)) \u2192 Prop} (f : \u2200 i, Finset (\u03b1 i)) (h0 : p fun _ \u21a6 \u2205)\n    (step :\n      \u2200 (g : \u2200 i, Finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i) (_ : x \u2209 g i),\n        p g \u2192 p (update g i (insert x (g i)))) :\n    p f", "start": [67, 1], "end": [79, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_pi_max", "code": "theorem induction_on_pi_max [\u2200 i, LinearOrder (\u03b1 i)] {p : (\u2200 i, Finset (\u03b1 i)) \u2192 Prop}\n    (f : \u2200 i, Finset (\u03b1 i)) (h0 : p fun _ \u21a6 \u2205)\n    (step :\n      \u2200 (g : \u2200 i, Finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i),\n        (\u2200 y \u2208 g i, y < x) \u2192 p g \u2192 p (update g i (insert x (g i)))) :\n    p f", "start": [84, 1], "end": [98, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_pi_min", "code": "theorem induction_on_pi_min [\u2200 i, LinearOrder (\u03b1 i)] {p : (\u2200 i, Finset (\u03b1 i)) \u2192 Prop}\n    (f : \u2200 i, Finset (\u03b1 i)) (h0 : p fun _ \u21a6 \u2205)\n    (step :\n      \u2200 (g : \u2200 i, Finset (\u03b1 i)) (i : \u03b9) (x : \u03b1 i),\n        (\u2200 y \u2208 g i, x < y) \u2192 p g \u2192 p (update g i (insert x (g i)))) :\n    p f", "start": [101, 1], "end": [114, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Partial.lean", "imports": ["Mathlib/Order/Filter/Partial.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "rtendsto_nhds", "code": "theorem rtendsto_nhds {r : Rel \u03b2 \u03b1} {l : Filter \u03b2} {a : \u03b1} :\n    RTendsto r l (\ud835\udcdd a) \u2194 \u2200 s, IsOpen s \u2192 a \u2208 s \u2192 r.core s \u2208 l", "start": [25, 1], "end": [27, 46], "kind": "commanddeclaration"}, {"full_name": "rtendsto'_nhds", "code": "theorem rtendsto'_nhds {r : Rel \u03b2 \u03b1} {l : Filter \u03b2} {a : \u03b1} :\n    RTendsto' r l (\ud835\udcdd a) \u2194 \u2200 s, IsOpen s \u2192 a \u2208 s \u2192 r.preimage s \u2208 l", "start": [30, 1], "end": [34, 26], "kind": "commanddeclaration"}, {"full_name": "ptendsto_nhds", "code": "theorem ptendsto_nhds {f : \u03b2 \u2192. \u03b1} {l : Filter \u03b2} {a : \u03b1} :\n    PTendsto f l (\ud835\udcdd a) \u2194 \u2200 s, IsOpen s \u2192 a \u2208 s \u2192 f.core s \u2208 l", "start": [37, 1], "end": [39, 16], "kind": "commanddeclaration"}, {"full_name": "ptendsto'_nhds", "code": "theorem ptendsto'_nhds {f : \u03b2 \u2192. \u03b1} {l : Filter \u03b2} {a : \u03b1} :\n    PTendsto' f l (\ud835\udcdd a) \u2194 \u2200 s, IsOpen s \u2192 a \u2208 s \u2192 f.preimage s \u2208 l", "start": [42, 1], "end": [44, 17], "kind": "commanddeclaration"}, {"full_name": "PContinuous", "code": "def PContinuous (f : \u03b1 \u2192. \u03b2) :=\n  \u2200 s, IsOpen s \u2192 IsOpen (f.preimage s)", "start": [52, 1], "end": [54, 40], "kind": "commanddeclaration"}, {"full_name": "open_dom_of_pcontinuous", "code": "theorem open_dom_of_pcontinuous {f : \u03b1 \u2192. \u03b2} (h : PContinuous f) : IsOpen f.Dom", "start": [57, 1], "end": [58, 51], "kind": "commanddeclaration"}, {"full_name": "pcontinuous_iff'", "code": "theorem pcontinuous_iff' {f : \u03b1 \u2192. \u03b2} :\n    PContinuous f \u2194 \u2200 {x y} (h : y \u2208 f x), PTendsto' f (\ud835\udcdd x) (\ud835\udcdd y)", "start": [61, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_iff_ptendsto_res", "code": "theorem continuousWithinAt_iff_ptendsto_res (f : \u03b1 \u2192 \u03b2) {x : \u03b1} {s : Set \u03b1} :\n    ContinuousWithinAt f s x \u2194 PTendsto (PFun.res f s) (\ud835\udcdd x) (\ud835\udcdd (f x))", "start": [86, 1], "end": [88, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "imports": ["Mathlib/Order/SemiconjSup.lean", "Mathlib/Tactic/Monotonicity.lean", "Mathlib/Order/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean", "Mathlib/Algebra/Hom/Iterate.lean"], "premises": [{"full_name": "CircleDeg1Lift", "code": "structure CircleDeg1Lift extends \u211d \u2192o \u211d : Type where\n  map_add_one' : \u2200 x, toFun (x + 1) = toFun x + 1", "start": [129, 1], "end": [131, 50], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_mk", "code": "@[simp] theorem coe_mk (f h) : \u21d1(mk f h) = f", "start": [141, 1], "end": [141, 52], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_toOrderHom", "code": "@[simp] theorem coe_toOrderHom : \u21d1f.toOrderHom = f", "start": [146, 1], "end": [146, 58], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.monotone", "code": "protected theorem monotone : Monotone f", "start": [148, 1], "end": [148, 55], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.mono", "code": "@[mono] theorem mono {x y} (h : x \u2264 y) : f x \u2264 f y", "start": [151, 1], "end": [151, 67], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.strictMono_iff_injective", "code": "theorem strictMono_iff_injective : StrictMono f \u2194 Injective f", "start": [154, 1], "end": [155, 38], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_add_one", "code": "@[simp]\ntheorem map_add_one : \u2200 x, f (x + 1) = f x + 1", "start": [158, 1], "end": [160, 17], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_one_add", "code": "@[simp]\ntheorem map_one_add (x : \u211d) : f (1 + x) = 1 + f x", "start": [163, 1], "end": [164, 95], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.ext", "code": "@[ext]\ntheorem ext \u2983f g : CircleDeg1Lift\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [169, 1], "end": [171, 20], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.ext_iff", "code": "theorem ext_iff {f g : CircleDeg1Lift} : f = g \u2194 \u2200 x, f x = g x", "start": [174, 1], "end": [175, 18], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_mul", "code": "@[simp]\ntheorem coe_mul : \u21d1(f * g) = f \u2218 g", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.mul_apply", "code": "theorem mul_apply (x) : (f * g) x = f (g x)", "start": [194, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : CircleDeg1Lift) = id", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.unitsHasCoeToFun", "code": "instance unitsHasCoeToFun : CoeFun CircleDeg1Lift\u02e3 fun _ => \u211d \u2192 \u211d :=\n  \u27e8fun f => \u21d1(f : CircleDeg1Lift)\u27e9", "start": [203, 1], "end": [204, 35], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.units_inv_apply_apply", "code": "@[simp]\ntheorem units_inv_apply_apply (f : CircleDeg1Lift\u02e3) (x : \u211d) : (f\u207b\u00b9 : CircleDeg1Lift\u02e3) (f x) = x", "start": [209, 1], "end": [211, 53], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.units_apply_inv_apply", "code": "@[simp]\ntheorem units_apply_inv_apply (f : CircleDeg1Lift\u02e3) (x : \u211d) : f ((f\u207b\u00b9 : CircleDeg1Lift\u02e3) x) = x", "start": [214, 1], "end": [216, 53], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.toOrderIso", "code": "def toOrderIso : CircleDeg1Lift\u02e3 \u2192* \u211d \u2243o \u211d where\n  toFun f :=\n    { toFun := f\n      invFun := \u21d1f\u207b\u00b9\n      left_inv := units_inv_apply_apply f\n      right_inv := units_apply_inv_apply f\n      map_rel_iff' := \u27e8fun h => by simpa using mono (\u2191f\u207b\u00b9) h, mono f\u27e9 }\n  map_one' := rfl\n  map_mul' f g := rfl", "start": [219, 1], "end": [228, 22], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_toOrderIso", "code": "@[simp]\ntheorem coe_toOrderIso (f : CircleDeg1Lift\u02e3) : \u21d1(toOrderIso f) = f", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_toOrderIso_symm", "code": "@[simp]\ntheorem coe_toOrderIso_symm (f : CircleDeg1Lift\u02e3) :\n    \u21d1(toOrderIso f).symm = (f\u207b\u00b9 : CircleDeg1Lift\u02e3)", "start": [236, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_toOrderIso_inv", "code": "@[simp]\ntheorem coe_toOrderIso_inv (f : CircleDeg1Lift\u02e3) : \u21d1(toOrderIso f)\u207b\u00b9 = (f\u207b\u00b9 : CircleDeg1Lift\u02e3)", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.isUnit_iff_bijective", "code": "theorem isUnit_iff_bijective {f : CircleDeg1Lift} : IsUnit f \u2194 Bijective f", "start": [247, 1], "end": [259, 68], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.coe_pow", "code": "theorem coe_pow : \u2200 n : \u2115, \u21d1(f ^ n) = f^[n]", "start": [262, 1], "end": [266, 32], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.semiconjBy_iff_semiconj", "code": "theorem semiconjBy_iff_semiconj {f g\u2081 g\u2082 : CircleDeg1Lift} :\n    SemiconjBy f g\u2081 g\u2082 \u2194 Semiconj f g\u2081 g\u2082", "start": [269, 1], "end": [271, 10], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_iff_commute", "code": "theorem commute_iff_commute {f g : CircleDeg1Lift} : Commute f g \u2194 Function.Commute f g", "start": [274, 1], "end": [275, 10], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate", "code": "def translate : Multiplicative \u211d \u2192* CircleDeg1Lift\u02e3 := MonoidHom.toHomUnits <|\n  { toFun := fun x =>\n      \u27e8\u27e8fun y => Multiplicative.toAdd x + y, fun _ _ h => add_le_add_left h _\u27e9, fun _ =>\n        (add_assoc _ _ _).symm\u27e9\n    map_one' := ext <| zero_add\n    map_mul' := fun _ _ => ext <| add_assoc _ _ }", "start": [283, 1], "end": [291, 50], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate_apply", "code": "@[simp]\ntheorem translate_apply (x y : \u211d) : translate (Multiplicative.ofAdd x) y = x + y", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate_inv_apply", "code": "@[simp]\ntheorem translate_inv_apply (x y : \u211d) : (translate <| Multiplicative.ofAdd x)\u207b\u00b9 y = -x + y", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate_zpow", "code": "@[simp]\ntheorem translate_zpow (x : \u211d) (n : \u2124) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| \u2191n * x)", "start": [304, 1], "end": [307, 62], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate_pow", "code": "@[simp]\ntheorem translate_pow (x : \u211d) (n : \u2115) :\n    translate (Multiplicative.ofAdd x) ^ n = translate (Multiplicative.ofAdd <| \u2191n * x)", "start": [310, 1], "end": [313, 21], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translate_iterate", "code": "@[simp]\ntheorem translate_iterate (x : \u211d) (n : \u2115) :\n    (translate (Multiplicative.ofAdd x))^[n] = translate (Multiplicative.ofAdd <| \u2191n * x)", "start": [316, 1], "end": [319, 60], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_nat_add", "code": "theorem commute_nat_add (n : \u2115) : Function.Commute f (n + \u00b7)", "start": [331, 1], "end": [332, 96], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_add_nat", "code": "theorem commute_add_nat (n : \u2115) : Function.Commute f (\u00b7 + n)", "start": [335, 1], "end": [336, 54], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_sub_nat", "code": "theorem commute_sub_nat (n : \u2115) : Function.Commute f (\u00b7 - n)", "start": [339, 1], "end": [341, 98], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_add_int", "code": "theorem commute_add_int : \u2200 n : \u2124, Function.Commute f (\u00b7 + n)", "start": [344, 1], "end": [346, 72], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_int_add", "code": "theorem commute_int_add (n : \u2124) : Function.Commute f (n + \u00b7)", "start": [349, 1], "end": [350, 60], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.commute_sub_int", "code": "theorem commute_sub_int (n : \u2124) : Function.Commute f (\u00b7 - n)", "start": [353, 1], "end": [355, 98], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_int_add", "code": "@[simp]\ntheorem map_int_add (m : \u2124) (x : \u211d) : f (m + x) = m + f x", "start": [358, 1], "end": [360, 24], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_add_int", "code": "@[simp]\ntheorem map_add_int (x : \u211d) (m : \u2124) : f (x + m) = f x + m", "start": [363, 1], "end": [365, 24], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_sub_int", "code": "@[simp]\ntheorem map_sub_int (x : \u211d) (n : \u2124) : f (x - n) = f x - n", "start": [368, 1], "end": [370, 24], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_add_nat", "code": "@[simp]\ntheorem map_add_nat (x : \u211d) (n : \u2115) : f (x + n) = f x + n", "start": [373, 1], "end": [375, 20], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_nat_add", "code": "@[simp]\ntheorem map_nat_add (n : \u2115) (x : \u211d) : f (n + x) = n + f x", "start": [378, 1], "end": [380, 20], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_sub_nat", "code": "@[simp]\ntheorem map_sub_nat (x : \u211d) (n : \u2115) : f (x - n) = f x - n", "start": [383, 1], "end": [385, 20], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_int_of_map_zero", "code": "theorem map_int_of_map_zero (n : \u2124) : f n = f 0 + n", "start": [388, 1], "end": [388, 89], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_fract_sub_fract_eq", "code": "@[simp]\ntheorem map_fract_sub_fract_eq (x : \u211d) : f (fract x) - fract x = f x - x", "start": [391, 1], "end": [393, 58], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.sup_apply", "code": "@[simp]\ntheorem sup_apply (x : \u211d) : (f \u2294 g) x = max (f x) (g x)", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.inf_apply", "code": "@[simp]\ntheorem inf_apply (x : \u211d) : (f \u2293 g) x = min (f x) (g x)", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_monotone", "code": "theorem iterate_monotone (n : \u2115) : Monotone fun f : CircleDeg1Lift => f^[n]", "start": [433, 1], "end": [434, 34], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_mono", "code": "theorem iterate_mono {f g : CircleDeg1Lift} (h : f \u2264 g) (n : \u2115) : f^[n] \u2264 g^[n]", "start": [437, 1], "end": [438, 23], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.pow_mono", "code": "theorem pow_mono {f g : CircleDeg1Lift} (h : f \u2264 g) (n : \u2115) : f ^ n \u2264 g ^ n", "start": [441, 1], "end": [442, 42], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.pow_monotone", "code": "theorem pow_monotone (n : \u2115) : Monotone fun f : CircleDeg1Lift => f ^ n", "start": [445, 1], "end": [445, 101], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_le_of_map_zero", "code": "theorem map_le_of_map_zero (x : \u211d) : f x \u2264 f 0 + \u2308x\u2309", "start": [458, 1], "end": [461, 45], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_map_zero_le", "code": "theorem map_map_zero_le : f (g 0) \u2264 f 0 + \u2308g 0\u2309", "start": [464, 1], "end": [465, 29], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.floor_map_map_zero_le", "code": "theorem floor_map_map_zero_le : \u230af (g 0)\u230b \u2264 \u230af 0\u230b + \u2308g 0\u2309", "start": [468, 1], "end": [471, 43], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.ceil_map_map_zero_le", "code": "theorem ceil_map_map_zero_le : \u2308f (g 0)\u2309 \u2264 \u2308f 0\u2309 + \u2308g 0\u2309", "start": [474, 1], "end": [477, 42], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_map_zero_lt", "code": "theorem map_map_zero_lt : f (g 0) < f 0 + g 0 + 1", "start": [480, 1], "end": [484, 48], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_map_of_map_zero", "code": "theorem le_map_of_map_zero (x : \u211d) : f 0 + \u230ax\u230b \u2264 f x", "start": [487, 1], "end": [490, 40], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_map_map_zero", "code": "theorem le_map_map_zero : f 0 + \u230ag 0\u230b \u2264 f (g 0)", "start": [493, 1], "end": [494, 29], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_floor_map_map_zero", "code": "theorem le_floor_map_map_zero : \u230af 0\u230b + \u230ag 0\u230b \u2264 \u230af (g 0)\u230b", "start": [497, 1], "end": [500, 55], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_ceil_map_map_zero", "code": "theorem le_ceil_map_map_zero : \u2308f 0\u2309 + \u230ag 0\u230b \u2264 \u2308(f * g) 0\u2309", "start": [503, 1], "end": [506, 54], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.lt_map_map_zero", "code": "theorem lt_map_map_zero : f 0 + g 0 - 1 < f (g 0)", "start": [509, 1], "end": [513, 39], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.dist_map_map_zero_lt", "code": "theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1", "start": [516, 1], "end": [518, 51], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.dist_map_zero_lt_of_semiconj", "code": "theorem dist_map_zero_lt_of_semiconj {f g\u2081 g\u2082 : CircleDeg1Lift} (h : Function.Semiconj f g\u2081 g\u2082) :\n    dist (g\u2081 0) (g\u2082 0) < 2", "start": [521, 1], "end": [529, 32], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.dist_map_zero_lt_of_semiconjBy", "code": "theorem dist_map_zero_lt_of_semiconjBy {f g\u2081 g\u2082 : CircleDeg1Lift} (h : SemiconjBy f g\u2081 g\u2082) :\n    dist (g\u2081 0) (g\u2082 0) < 2", "start": [532, 1], "end": [534, 62], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_atBot", "code": "protected theorem tendsto_atBot : Tendsto f atBot atBot", "start": [541, 1], "end": [544, 51], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_atTop", "code": "protected theorem tendsto_atTop : Tendsto f atTop atTop", "start": [547, 1], "end": [550, 80], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.continuous_iff_surjective", "code": "theorem continuous_iff_surjective : Continuous f \u2194 Function.Surjective f", "start": [553, 1], "end": [554, 95], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_le_of_map_le_add_int", "code": "theorem iterate_le_of_map_le_add_int {x : \u211d} {m : \u2124} (h : f x \u2264 x + m) (n : \u2115) :\n    f^[n] x \u2264 x + n * m", "start": [568, 1], "end": [571, 94], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_iterate_of_add_int_le_map", "code": "theorem le_iterate_of_add_int_le_map {x : \u211d} {m : \u2124} (h : x + m \u2264 f x) (n : \u2115) :\n    x + n * m \u2264 f^[n] x", "start": [574, 1], "end": [577, 99], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_eq_of_map_eq_add_int", "code": "theorem iterate_eq_of_map_eq_add_int {x : \u211d} {m : \u2124} (h : f x = x + m) (n : \u2115) :\n    f^[n] x = x + n * m", "start": [580, 1], "end": [582, 100], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_pos_le_iff", "code": "theorem iterate_pos_le_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x \u2264 x + n * m \u2194 f x \u2264 x + m", "start": [585, 1], "end": [588, 100], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_pos_lt_iff", "code": "theorem iterate_pos_lt_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x < x + n * m \u2194 f x < x + m", "start": [591, 1], "end": [594, 100], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.iterate_pos_eq_iff", "code": "theorem iterate_pos_eq_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x = x + n * m \u2194 f x = x + m", "start": [597, 1], "end": [600, 100], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_iterate_pos_iff", "code": "theorem le_iterate_pos_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    x + n * m \u2264 f^[n] x \u2194 x + m \u2264 f x", "start": [603, 1], "end": [605, 64], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.lt_iterate_pos_iff", "code": "theorem lt_iterate_pos_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    x + n * m < f^[n] x \u2194 x + m < f x", "start": [608, 1], "end": [610, 64], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.mul_floor_map_zero_le_floor_iterate_zero", "code": "theorem mul_floor_map_zero_le_floor_iterate_zero (n : \u2115) : \u2191n * \u230af 0\u230b \u2264 \u230af^[n] 0\u230b", "start": [613, 1], "end": [616, 18], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.transnumAuxSeq", "code": "def transnumAuxSeq (n : \u2115) : \u211d :=\n  (f ^ (2 ^ n : \u2115)) 0 / 2 ^ n", "start": [625, 1], "end": [627, 30], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber", "code": "def translationNumber : \u211d :=\n  limUnder atTop f.transnumAuxSeq", "start": [630, 1], "end": [634, 34], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.transnumAuxSeq_def", "code": "theorem transnumAuxSeq_def : f.transnumAuxSeq = fun n : \u2115 => (f ^ (2 ^ n : \u2115)) 0 / 2 ^ n", "start": [644, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_tendsto_aux", "code": "theorem translationNumber_eq_of_tendsto_aux {\u03c4' : \u211d} (h : Tendsto f.transnumAuxSeq atTop (\ud835\udcdd \u03c4')) :\n    \u03c4 f = \u03c4'", "start": [648, 1], "end": [650, 16], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_tendsto\u2080", "code": "theorem translationNumber_eq_of_tendsto\u2080 {\u03c4' : \u211d}\n    (h : Tendsto (fun n : \u2115 => f^[n] 0 / n) atTop (\ud835\udcdd \u03c4')) : \u03c4 f = \u03c4'", "start": [653, 1], "end": [657, 64], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_tendsto\u2080'", "code": "theorem translationNumber_eq_of_tendsto\u2080' {\u03c4' : \u211d}\n    (h : Tendsto (fun n : \u2115 => f^[n + 1] 0 / (n + 1)) atTop (\ud835\udcdd \u03c4')) : \u03c4 f = \u03c4'", "start": [660, 1], "end": [662, 94], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.transnumAuxSeq_zero", "code": "theorem transnumAuxSeq_zero : f.transnumAuxSeq 0 = f 0", "start": [665, 1], "end": [665, 83], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.transnumAuxSeq_dist_lt", "code": "theorem transnumAuxSeq_dist_lt (n : \u2115) :\n    dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n", "start": [668, 1], "end": [676, 28], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translationNumber_aux", "code": "theorem tendsto_translationNumber_aux : Tendsto f.transnumAuxSeq atTop (\ud835\udcdd <| \u03c4 f)", "start": [679, 1], "end": [680, 101], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.dist_map_zero_translationNumber_le", "code": "theorem dist_map_zero_translationNumber_le : dist (f 0) (\u03c4 f) \u2264 1", "start": [683, 1], "end": [686, 38], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translationNumber_of_dist_bounded_aux", "code": "theorem tendsto_translationNumber_of_dist_bounded_aux (x : \u2115 \u2192 \u211d) (C : \u211d)\n    (H : \u2200 n : \u2115, dist ((f ^ n) 0) (x n) \u2264 C) :\n    Tendsto (fun n : \u2115 => x (2 ^ n) / 2 ^ n) atTop (\ud835\udcdd <| \u03c4 f)", "start": [689, 1], "end": [699, 51], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_dist_bounded", "code": "theorem translationNumber_eq_of_dist_bounded {f g : CircleDeg1Lift} (C : \u211d)\n    (H : \u2200 n : \u2115, dist ((f ^ n) 0) ((g ^ n) 0) \u2264 C) : \u03c4 f = \u03c4 g", "start": [702, 1], "end": [705, 58], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_one", "code": "@[simp]\ntheorem translationNumber_one : \u03c4 1 = 0", "start": [708, 1], "end": [710, 69], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_semiconjBy", "code": "theorem translationNumber_eq_of_semiconjBy {f g\u2081 g\u2082 : CircleDeg1Lift} (H : SemiconjBy f g\u2081 g\u2082) :\n    \u03c4 g\u2081 = \u03c4 g\u2082", "start": [713, 1], "end": [716, 64], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_of_semiconj", "code": "theorem translationNumber_eq_of_semiconj {f g\u2081 g\u2082 : CircleDeg1Lift}\n    (H : Function.Semiconj f g\u2081 g\u2082) : \u03c4 g\u2081 = \u03c4 g\u2082", "start": [719, 1], "end": [721, 68], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_mul_of_commute", "code": "theorem translationNumber_mul_of_commute {f g : CircleDeg1Lift} (h : Commute f g) :\n    \u03c4 (f * g) = \u03c4 f + \u03c4 g", "start": [724, 1], "end": [732, 56], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_units_inv", "code": "@[simp]\ntheorem translationNumber_units_inv (f : CircleDeg1Lift\u02e3) : \u03c4 \u2191f\u207b\u00b9 = -\u03c4 f", "start": [735, 1], "end": [738, 78], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_pow", "code": "@[simp]\ntheorem translationNumber_pow : \u2200 n : \u2115, \u03c4 (f ^ n) = n * \u03c4 f", "start": [741, 1], "end": [746, 67], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_zpow", "code": "@[simp]\ntheorem translationNumber_zpow (f : CircleDeg1Lift\u02e3) : \u2200 n : \u2124, \u03c4 (f ^ n : Units _) = n * \u03c4 f", "start": [749, 1], "end": [752, 28], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_conj_eq", "code": "@[simp]\ntheorem translationNumber_conj_eq (f : CircleDeg1Lift\u02e3) (g : CircleDeg1Lift) :\n    \u03c4 (\u2191f * g * \u2191f\u207b\u00b9) = \u03c4 g", "start": [755, 1], "end": [758, 64], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_conj_eq'", "code": "@[simp]\ntheorem translationNumber_conj_eq' (f : CircleDeg1Lift\u02e3) (g : CircleDeg1Lift) :\n    \u03c4 (\u2191f\u207b\u00b9 * g * f) = \u03c4 g", "start": [761, 1], "end": [764, 34], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.dist_pow_map_zero_mul_translationNumber_le", "code": "theorem dist_pow_map_zero_mul_translationNumber_le (n : \u2115) :\n    dist ((f ^ n) 0) (n * f.translationNumber) \u2264 1", "start": [767, 1], "end": [769, 73], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translation_number\u2080'", "code": "theorem tendsto_translation_number\u2080' :\n    Tendsto (fun n : \u2115 => (f ^ (n + 1) : CircleDeg1Lift) 0 / ((n : \u211d) + 1)) atTop (\ud835\udcdd <| \u03c4 f)", "start": [772, 1], "end": [782, 51], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translation_number\u2080", "code": "theorem tendsto_translation_number\u2080 : Tendsto (fun n : \u2115 => (f ^ n) 0 / n) atTop (\ud835\udcdd <| \u03c4 f)", "start": [785, 1], "end": [786, 85], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translationNumber", "code": "theorem tendsto_translationNumber (x : \u211d) :\n    Tendsto (fun n : \u2115 => ((f ^ n) x - x) / n) atTop (\ud835\udcdd <| \u03c4 f)", "start": [789, 1], "end": [795, 41], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.tendsto_translation_number'", "code": "theorem tendsto_translation_number' (x : \u211d) :\n    Tendsto (fun n : \u2115 => ((f ^ (n + 1) : CircleDeg1Lift) x - x) / (n + 1)) atTop (\ud835\udcdd <| \u03c4 f)", "start": [798, 1], "end": [800, 81], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_mono", "code": "theorem translationNumber_mono : Monotone \u03c4", "start": [803, 1], "end": [805, 62], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_translate", "code": "theorem translationNumber_translate (x : \u211d) : \u03c4 (translate <| Multiplicative.ofAdd x) = x", "start": [808, 1], "end": [811, 88], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_le_of_le_add", "code": "theorem translationNumber_le_of_le_add {z : \u211d} (hz : \u2200 x, f x \u2264 x + z) : \u03c4 f \u2264 z", "start": [814, 1], "end": [815, 97], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_translationNumber_of_add_le", "code": "theorem le_translationNumber_of_add_le {z : \u211d} (hz : \u2200 x, x + z \u2264 f x) : z \u2264 \u03c4 f", "start": [818, 1], "end": [819, 97], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_le_of_le_add_int", "code": "theorem translationNumber_le_of_le_add_int {x : \u211d} {m : \u2124} (h : f x \u2264 x + m) : \u03c4 f \u2264 m", "start": [822, 1], "end": [825, 100], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_le_of_le_add_nat", "code": "theorem translationNumber_le_of_le_add_nat {x : \u211d} {m : \u2115} (h : f x \u2264 x + m) : \u03c4 f \u2264 m", "start": [828, 1], "end": [829, 46], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_translationNumber_of_add_int_le", "code": "theorem le_translationNumber_of_add_int_le {x : \u211d} {m : \u2124} (h : x + m \u2264 f x) : \u2191m \u2264 \u03c4 f", "start": [832, 1], "end": [835, 98], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.le_translationNumber_of_add_nat_le", "code": "theorem le_translationNumber_of_add_nat_le {x : \u211d} {m : \u2115} (h : x + m \u2264 f x) : \u2191m \u2264 \u03c4 f", "start": [838, 1], "end": [839, 46], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_of_eq_add_int", "code": "theorem translationNumber_of_eq_add_int {x : \u211d} {m : \u2124} (h : f x = x + m) : \u03c4 f = m", "start": [842, 1], "end": [846, 62], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.floor_sub_le_translationNumber", "code": "theorem floor_sub_le_translationNumber (x : \u211d) : \u2191\u230af x - x\u230b \u2264 \u03c4 f", "start": [849, 1], "end": [850, 85], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_le_ceil_sub", "code": "theorem translationNumber_le_ceil_sub (x : \u211d) : \u03c4 f \u2264 \u2308f x - x\u2309", "start": [853, 1], "end": [854, 84], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_lt_of_translationNumber_lt_int", "code": "theorem map_lt_of_translationNumber_lt_int {n : \u2124} (h : \u03c4 f < n) (x : \u211d) : f x < x + n", "start": [857, 1], "end": [858, 68], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_lt_of_translationNumber_lt_nat", "code": "theorem map_lt_of_translationNumber_lt_nat {n : \u2115} (h : \u03c4 f < n) (x : \u211d) : f x < x + n", "start": [861, 1], "end": [862, 46], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_lt_add_floor_translationNumber_add_one", "code": "theorem map_lt_add_floor_translationNumber_add_one (x : \u211d) : f x < x + \u230a\u03c4 f\u230b + 1", "start": [865, 1], "end": [870, 27], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.map_lt_add_translationNumber_add_one", "code": "theorem map_lt_add_translationNumber_add_one (x : \u211d) : f x < x + \u03c4 f + 1", "start": [873, 1], "end": [876, 49], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.lt_map_of_int_lt_translationNumber", "code": "theorem lt_map_of_int_lt_translationNumber {n : \u2124} (h : \u2191n < \u03c4 f) (x : \u211d) : x + n < f x", "start": [879, 1], "end": [880, 68], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.lt_map_of_nat_lt_translationNumber", "code": "theorem lt_map_of_nat_lt_translationNumber {n : \u2115} (h : \u2191n < \u03c4 f) (x : \u211d) : x + n < f x", "start": [883, 1], "end": [884, 46], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_of_map_pow_eq_add_int", "code": "theorem translationNumber_of_map_pow_eq_add_int {x : \u211d} {n : \u2115} {m : \u2124} (h : (f ^ n) x = x + m)\n    (hn : 0 < n) : \u03c4 f = m / n", "start": [887, 1], "end": [894, 41], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.forall_map_sub_of_Icc", "code": "theorem forall_map_sub_of_Icc (P : \u211d \u2192 Prop) (h : \u2200 x \u2208 Icc (0 : \u211d) 1, P (f x - x)) (x : \u211d) :\n    P (f x - x)", "start": [897, 1], "end": [901, 79], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_lt_of_forall_lt_add", "code": "theorem translationNumber_lt_of_forall_lt_add (hf : Continuous f) {z : \u211d} (hz : \u2200 x, f x < x + z) :\n    \u03c4 f < z", "start": [904, 1], "end": [912, 58], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.lt_translationNumber_of_forall_add_lt", "code": "theorem lt_translationNumber_of_forall_add_lt (hf : Continuous f) {z : \u211d} (hz : \u2200 x, x + z < f x) :\n    z < \u03c4 f", "start": [915, 1], "end": [923, 37], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.exists_eq_add_translationNumber", "code": "theorem exists_eq_add_translationNumber (hf : Continuous f) : \u2203 x, f x = x + \u03c4 f", "start": [926, 1], "end": [935, 79], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_int_iff", "code": "theorem translationNumber_eq_int_iff (hf : Continuous f) {m : \u2124} :\n    \u03c4 f = m \u2194 \u2203 x : \u211d, f x = x + m", "start": [938, 1], "end": [945, 47], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.continuous_pow", "code": "theorem continuous_pow (hf : Continuous f) (n : \u2115) : Continuous (f ^ n : CircleDeg1Lift)", "start": [948, 1], "end": [950, 21], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.translationNumber_eq_rat_iff", "code": "theorem translationNumber_eq_rat_iff (hf : Continuous f) {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    \u03c4 f = m / n \u2194 \u2203 x, (f ^ n) x = x + m", "start": [953, 1], "end": [956, 69], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.semiconj_of_group_action_of_forall_translationNumber_eq", "code": "theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type*} [Group G]\n    (f\u2081 f\u2082 : G \u2192* CircleDeg1Lift) (h : \u2200 g, \u03c4 (f\u2081 g) = \u03c4 (f\u2082 g)) :\n    \u2203 F : CircleDeg1Lift, \u2200 g, Semiconj F (f\u2081 g) (f\u2082 g)", "start": [959, 1], "end": [997, 17], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.units_semiconj_of_translationNumber_eq", "code": "theorem units_semiconj_of_translationNumber_eq {f\u2081 f\u2082 : CircleDeg1Lift\u02e3} (h : \u03c4 f\u2081 = \u03c4 f\u2082) :\n    \u2203 F : CircleDeg1Lift, Semiconj F f\u2081 f\u2082", "start": [1000, 1], "end": [1010, 44], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.semiconj_of_isUnit_of_translationNumber_eq", "code": "theorem semiconj_of_isUnit_of_translationNumber_eq {f\u2081 f\u2082 : CircleDeg1Lift} (h\u2081 : IsUnit f\u2081)\n    (h\u2082 : IsUnit f\u2082) (h : \u03c4 f\u2081 = \u03c4 f\u2082) : \u2203 F : CircleDeg1Lift, Semiconj F f\u2081 f\u2082", "start": [1013, 1], "end": [1019, 49], "kind": "commanddeclaration"}, {"full_name": "CircleDeg1Lift.semiconj_of_bijective_of_translationNumber_eq", "code": "theorem semiconj_of_bijective_of_translationNumber_eq {f\u2081 f\u2082 : CircleDeg1Lift} (h\u2081 : Bijective f\u2081)\n    (h\u2082 : Bijective f\u2082) (h : \u03c4 f\u2081 = \u03c4 f\u2082) : \u2203 F : CircleDeg1Lift, Semiconj F f\u2081 f\u2082", "start": [1022, 1], "end": [1028, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finmap.lean", "imports": ["Mathlib/Data/Part.lean", "Mathlib/Data/Finset/Sigma.lean", "Mathlib/Data/List/AList.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.keys", "code": "def keys (s : Multiset (Sigma \u03b2)) : Multiset \u03b1 :=\n  s.map Sigma.fst", "start": [26, 1], "end": [28, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_keys", "code": "@[simp]\ntheorem coe_keys {l : List (Sigma \u03b2)} : keys (l : Multiset (Sigma \u03b2)) = (l.keys : Multiset \u03b1)", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.NodupKeys", "code": "def NodupKeys (s : Multiset (Sigma \u03b2)) : Prop :=\n  Quot.liftOn s List.NodupKeys fun _ _ p => propext <| perm_nodupKeys p", "start": [37, 1], "end": [39, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_nodupKeys", "code": "@[simp]\ntheorem coe_nodupKeys {l : List (Sigma \u03b2)} : @NodupKeys \u03b1 \u03b2 l \u2194 l.NodupKeys", "start": [42, 1], "end": [44, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_keys", "code": "lemma nodup_keys {m : Multiset (\u03a3 a, \u03b2 a)} : m.keys.Nodup \u2194 m.NodupKeys := by\n  rcases m with \u27e8l\u27e9; rfl", "start": [47, 1], "end": [48, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Multiset.NodupKeys.nodup_keys", "code": "alias \u27e8_, NodupKeys.nodup_keys\u27e9 := nodup_keys", "start": [50, 1], "end": [50, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.NodupKeys.nodup", "code": "protected lemma NodupKeys.nodup {m : Multiset (\u03a3 a, \u03b2 a)} (h : m.NodupKeys) : m.Nodup :=\n  h.nodup_keys.of_map _", "start": [52, 1], "end": [53, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap", "code": "structure Finmap (\u03b2 : \u03b1 \u2192 Type v) : Type max u v where\n  \n  entries : Multiset (Sigma \u03b2)\n  \n  nodupKeys : entries.NodupKeys", "start": [59, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "AList.toFinmap", "code": "def AList.toFinmap (s : AList \u03b2) : Finmap \u03b2 :=\n  \u27e8s.entries, s.nodupKeys\u27e9", "start": [68, 1], "end": [70, 27], "kind": "commanddeclaration"}, {"full_name": "AList.toFinmap_eq", "code": "theorem AList.toFinmap_eq {s\u2081 s\u2082 : AList \u03b2} :\n    toFinmap s\u2081 = toFinmap s\u2082 \u2194 s\u2081.entries ~ s\u2082.entries", "start": [75, 1], "end": [79, 24], "kind": "commanddeclaration"}, {"full_name": "AList.toFinmap_entries", "code": "@[simp]\ntheorem AList.toFinmap_entries (s : AList \u03b2) : \u27e6s\u27e7.entries = s.entries", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinmap", "code": "def List.toFinmap [DecidableEq \u03b1] (s : List (Sigma \u03b2)) : Finmap \u03b2 :=\n  s.toAList.toFinmap", "start": [87, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "Finmap.nodup_entries", "code": "lemma nodup_entries (f : Finmap \u03b2) : f.entries.Nodup := f.nodupKeys.nodup", "start": [97, 1], "end": [97, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.liftOn", "code": "def liftOn {\u03b3} (s : Finmap \u03b2) (f : AList \u03b2 \u2192 \u03b3)\n    (H : \u2200 a b : AList \u03b2, a.entries ~ b.entries \u2192 f a = f b) : \u03b3 := by\n  refine'\n    (Quotient.liftOn s.entries\n      (fun (l : List (Sigma \u03b2)) => (\u27e8_, fun nd => f \u27e8l, nd\u27e9\u27e9 : Part \u03b3))\n      (fun l\u2081 l\u2082 p => Part.ext' (perm_nodupKeys p) _) : Part \u03b3).get _\n  \u00b7 exact fun h1 h2 => H _ _ p\n  \u00b7 have := s.nodupKeys\n    revert this\n    rcases s.entries with \u27e8l\u27e9\n    exact id", "start": [101, 1], "end": [114, 13], "kind": "commanddeclaration"}, {"full_name": "Finmap.liftOn_toFinmap", "code": "@[simp]\ntheorem liftOn_toFinmap {\u03b3} (s : AList \u03b2) (f : AList \u03b2 \u2192 \u03b3) (H) : liftOn \u27e6s\u27e7 f H = f s", "start": [117, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.liftOn\u2082", "code": "def liftOn\u2082 {\u03b3} (s\u2081 s\u2082 : Finmap \u03b2) (f : AList \u03b2 \u2192 AList \u03b2 \u2192 \u03b3)\n    (H : \u2200 a\u2081 b\u2081 a\u2082 b\u2082 : AList \u03b2,\n      a\u2081.entries ~ a\u2082.entries \u2192 b\u2081.entries ~ b\u2082.entries \u2192 f a\u2081 b\u2081 = f a\u2082 b\u2082) : \u03b3 :=\n  liftOn s\u2081 (fun l\u2081 => liftOn s\u2082 (f l\u2081) fun b\u2081 b\u2082 p => H _ _ _ _ (Perm.refl _) p) fun a\u2081 a\u2082 p => by\n    have H' : f a\u2081 = f a\u2082 := funext fun _ => H _ _ _ _ p (Perm.refl _)\n    simp only [H']", "start": [123, 1], "end": [130, 19], "kind": "commanddeclaration"}, {"full_name": "Finmap.liftOn\u2082_toFinmap", "code": "@[simp]\ntheorem liftOn\u2082_toFinmap {\u03b3} (s\u2081 s\u2082 : AList \u03b2) (f : AList \u03b2 \u2192 AList \u03b2 \u2192 \u03b3) (H) :\n    liftOn\u2082 \u27e6s\u2081\u27e7 \u27e6s\u2082\u27e7 f H = f s\u2081 s\u2082", "start": [133, 1], "end": [136, 33], "kind": "commanddeclaration"}, {"full_name": "Finmap.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {C : Finmap \u03b2 \u2192 Prop} (s : Finmap \u03b2) (H : \u2200 a : AList \u03b2, C \u27e6a\u27e7) : C s", "start": [141, 1], "end": [143, 41], "kind": "commanddeclaration"}, {"full_name": "Finmap.induction_on\u2082", "code": "@[elab_as_elim]\ntheorem induction_on\u2082 {C : Finmap \u03b2 \u2192 Finmap \u03b2 \u2192 Prop} (s\u2081 s\u2082 : Finmap \u03b2)\n    (H : \u2200 a\u2081 a\u2082 : AList \u03b2, C \u27e6a\u2081\u27e7 \u27e6a\u2082\u27e7) : C s\u2081 s\u2082", "start": [146, 1], "end": [149, 62], "kind": "commanddeclaration"}, {"full_name": "Finmap.induction_on\u2083", "code": "@[elab_as_elim]\ntheorem induction_on\u2083 {C : Finmap \u03b2 \u2192 Finmap \u03b2 \u2192 Finmap \u03b2 \u2192 Prop} (s\u2081 s\u2082 s\u2083 : Finmap \u03b2)\n    (H : \u2200 a\u2081 a\u2082 a\u2083 : AList \u03b2, C \u27e6a\u2081\u27e7 \u27e6a\u2082\u27e7 \u27e6a\u2083\u27e7) : C s\u2081 s\u2082 s\u2083", "start": [152, 1], "end": [155, 72], "kind": "commanddeclaration"}, {"full_name": "Finmap.ext", "code": "@[ext]\ntheorem ext : \u2200 {s t : Finmap \u03b2}, s.entries = t.entries \u2192 s = t", "start": [160, 1], "end": [162, 37], "kind": "commanddeclaration"}, {"full_name": "Finmap.ext_iff", "code": "@[simp]\ntheorem ext_iff {s t : Finmap \u03b2} : s.entries = t.entries \u2194 s = t", "start": [165, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_def", "code": "theorem mem_def {a : \u03b1} {s : Finmap \u03b2} : a \u2208 s \u2194 a \u2208 s.entries.keys", "start": [176, 1], "end": [177, 10], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_toFinmap", "code": "@[simp]\ntheorem mem_toFinmap {a : \u03b1} {s : AList \u03b2} : a \u2208 toFinmap s \u2194 a \u2208 s", "start": [180, 1], "end": [182, 10], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys", "code": "def keys (s : Finmap \u03b2) : Finset \u03b1 :=\n  \u27e8s.entries.keys, s.nodupKeys.nodup_keys\u27e9", "start": [187, 1], "end": [189, 43], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_val", "code": "@[simp]\ntheorem keys_val (s : AList \u03b2) : (keys \u27e6s\u27e7).val = s.keys", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_ext", "code": "@[simp]\ntheorem keys_ext {s\u2081 s\u2082 : AList \u03b2} : keys \u27e6s\u2081\u27e7 = keys \u27e6s\u2082\u27e7 \u2194 s\u2081.keys ~ s\u2082.keys", "start": [197, 1], "end": [199, 26], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_keys", "code": "theorem mem_keys {a : \u03b1} {s : Finmap \u03b2} : a \u2208 s.keys \u2194 a \u2208 s", "start": [202, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "Finmap.empty_toFinmap", "code": "@[simp]\ntheorem empty_toFinmap : (\u27e6\u2205\u27e7 : Finmap \u03b2) = \u2205", "start": [215, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.toFinmap_nil", "code": "@[simp]\ntheorem toFinmap_nil [DecidableEq \u03b1] : ([].toFinmap : Finmap \u03b2) = \u2205", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.not_mem_empty", "code": "theorem not_mem_empty {a : \u03b1} : a \u2209 (\u2205 : Finmap \u03b2)", "start": [225, 1], "end": [226, 26], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_empty", "code": "@[simp]\ntheorem keys_empty : (\u2205 : Finmap \u03b2).keys = \u2205", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.singleton", "code": "def singleton (a : \u03b1) (b : \u03b2 a) : Finmap \u03b2 :=\n  \u27e6AList.singleton a b\u27e7", "start": [236, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_singleton", "code": "@[simp]\ntheorem keys_singleton (a : \u03b1) (b : \u03b2 a) : (singleton a b).keys = {a}", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_singleton", "code": "@[simp]\ntheorem mem_singleton (x y : \u03b1) (b : \u03b2 y) : x \u2208 singleton y b \u2194 x = y", "start": [246, 1], "end": [248, 67], "kind": "commanddeclaration"}, {"full_name": "Finmap.decidableEq", "code": "instance decidableEq [\u2200 a, DecidableEq (\u03b2 a)] : DecidableEq (Finmap \u03b2)\n  | _, _ => decidable_of_iff _ ext_iff", "start": [255, 1], "end": [256, 39], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup", "code": "def lookup (a : \u03b1) (s : Finmap \u03b2) : Option (\u03b2 a) :=\n  liftOn s (AList.lookup a) fun _ _ => perm_lookup", "start": [261, 1], "end": [263, 51], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_toFinmap", "code": "@[simp]\ntheorem lookup_toFinmap (a : \u03b1) (s : AList \u03b2) : lookup a \u27e6s\u27e7 = s.lookup a", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.dlookup_list_toFinmap", "code": "@[simp]\ntheorem dlookup_list_toFinmap (a : \u03b1) (s : List (Sigma \u03b2)) : lookup a s.toFinmap = s.dlookup a", "start": [272, 1], "end": [274, 55], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_empty", "code": "@[simp]\ntheorem lookup_empty (a) : lookup a (\u2205 : Finmap \u03b2) = none", "start": [277, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_isSome", "code": "theorem lookup_isSome {a : \u03b1} {s : Finmap \u03b2} : (s.lookup a).isSome \u2194 a \u2208 s", "start": [282, 1], "end": [283, 46], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_eq_none", "code": "theorem lookup_eq_none {a} {s : Finmap \u03b2} : lookup a s = none \u2194 a \u2209 s", "start": [286, 1], "end": [287, 47], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_lookup_iff", "code": "lemma mem_lookup_iff {s : Finmap \u03b2} {a : \u03b1} {b : \u03b2 a} :\n    b \u2208 s.lookup a \u2194 Sigma.mk a b \u2208 s.entries := by\n  rcases s with \u27e8\u27e8l\u27e9, hl\u27e9; exact List.mem_dlookup_iff hl", "start": [290, 1], "end": [292, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.lookup_eq_some_iff", "code": "lemma lookup_eq_some_iff {s : Finmap \u03b2} {a : \u03b1} {b : \u03b2 a} :\n    s.lookup a = b \u2194 Sigma.mk a b \u2208 s.entries := mem_lookup_iff", "start": [294, 1], "end": [295, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.sigma_keys_lookup", "code": "@[simp] lemma sigma_keys_lookup (s : Finmap \u03b2) :\n    s.keys.sigma (fun i => (s.lookup i).toFinset) = \u27e8s.entries, s.nodup_entries\u27e9 := by\n  ext x\n  have : x \u2208 s.entries \u2192 x.1 \u2208 s.keys := Multiset.mem_map_of_mem _\n  simpa [lookup_eq_some_iff]", "start": [297, 1], "end": [301, 29], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.lookup_singleton_eq", "code": "@[simp]\ntheorem lookup_singleton_eq {a : \u03b1} {b : \u03b2 a} : (singleton a b).lookup a = some b", "start": [303, 1], "end": [305, 82], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_iff", "code": "theorem mem_iff {a : \u03b1} {s : Finmap \u03b2} : a \u2208 s \u2194 \u2203 b, s.lookup a = some b", "start": [311, 1], "end": [313, 88], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_of_lookup_eq_some", "code": "theorem mem_of_lookup_eq_some {a : \u03b1} {b : \u03b2 a} {s : Finmap \u03b2} (h : s.lookup a = some b) : a \u2208 s", "start": [316, 1], "end": [317, 21], "kind": "commanddeclaration"}, {"full_name": "Finmap.ext_lookup", "code": "theorem ext_lookup {s\u2081 s\u2082 : Finmap \u03b2} : (\u2200 x, s\u2081.lookup x = s\u2082.lookup x) \u2192 s\u2081 = s\u2082", "start": [320, 1], "end": [326, 11], "kind": "commanddeclaration"}, {"full_name": "Finmap.keysLookupEquiv", "code": "@[simps apply_coe_fst apply_coe_snd]\ndef keysLookupEquiv :\n    Finmap \u03b2 \u2243 { f : Finset \u03b1 \u00d7 (\u2200 a, Option (\u03b2 a)) // \u2200 i, (f.2 i).isSome \u2194 i \u2208 f.1 } where\n  toFun s := \u27e8(s.keys, fun i => s.lookup i), fun _ => lookup_isSome\u27e9\n  invFun f := mk (f.1.1.sigma <| fun i => (f.1.2 i).toFinset).val <| by\n    refine Multiset.nodup_keys.1 ((Finset.nodup _).map_on ?_)\n    simp only [Finset.mem_val, Finset.mem_sigma, Option.mem_toFinset, Option.mem_def]\n    rintro \u27e8i, x\u27e9 \u27e8_, hx\u27e9 \u27e8j, y\u27e9 \u27e8_, hy\u27e9 (rfl : i = j)\n    simpa using hx.symm.trans hy\n  left_inv f := ext <| by simp\n  right_inv := fun \u27e8(s, f), hf\u27e9 => by\n    dsimp only at hf\n    ext\n    \u00b7 simp [keys, Multiset.keys, \u2190 hf, Option.isSome_iff_exists]\n    \u00b7 simp (config := { contextual := true }) [lookup_eq_some_iff, \u2190 hf]", "start": [329, 1], "end": [345, 73], "kind": "commanddeclaration"}, {"full_name": "Finmap.keysLookupEquiv_symm_apply_keys", "code": "@[simp] lemma keysLookupEquiv_symm_apply_keys :\n    \u2200 f : {f : Finset \u03b1 \u00d7 (\u2200 a, Option (\u03b2 a)) // \u2200 i, (f.2 i).isSome \u2194 i \u2208 f.1},\n      (keysLookupEquiv.symm f).keys = f.1.1 :=\n  keysLookupEquiv.surjective.forall.2 $ fun _ => by\n    simp only [Equiv.symm_apply_apply, keysLookupEquiv_apply_coe_fst]", "start": [347, 1], "end": [351, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.keysLookupEquiv_symm_apply_lookup", "code": "@[simp] lemma keysLookupEquiv_symm_apply_lookup :\n    \u2200 (f : {f : Finset \u03b1 \u00d7 (\u2200 a, Option (\u03b2 a)) // \u2200 i, (f.2 i).isSome \u2194 i \u2208 f.1}) a,\n      (keysLookupEquiv.symm f).lookup a = f.1.2 a :=\n  keysLookupEquiv.surjective.forall.2 $ fun _ _ => by\n    simp only [Equiv.symm_apply_apply, keysLookupEquiv_apply_coe_snd]", "start": [353, 1], "end": [357, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Finmap.replace", "code": "def replace (a : \u03b1) (b : \u03b2 a) (s : Finmap \u03b2) : Finmap \u03b2 :=\n  (liftOn s fun t => AList.toFinmap (AList.replace a b t))\n    fun _ _ p => toFinmap_eq.2 <| perm_replace p", "start": [361, 1], "end": [365, 49], "kind": "commanddeclaration"}, {"full_name": "Finmap.replace_toFinmap", "code": "@[simp]\ntheorem replace_toFinmap (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) :\n    replace a b \u27e6s\u27e7 = (\u27e6s.replace a b\u27e7 : Finmap \u03b2)", "start": [369, 1], "end": [372, 17], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_replace", "code": "@[simp]\ntheorem keys_replace (a : \u03b1) (b : \u03b2 a) (s : Finmap \u03b2) : (replace a b s).keys = s.keys", "start": [375, 1], "end": [377, 34], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_replace", "code": "@[simp]\ntheorem mem_replace {a a' : \u03b1} {b : \u03b2 a} {s : Finmap \u03b2} : a' \u2208 replace a b s \u2194 a' \u2208 s", "start": [380, 1], "end": [382, 34], "kind": "commanddeclaration"}, {"full_name": "Finmap.foldl", "code": "def foldl {\u03b4 : Type w} (f : \u03b4 \u2192 \u2200 a, \u03b2 a \u2192 \u03b4)\n    (H : \u2200 d a\u2081 b\u2081 a\u2082 b\u2082, f (f d a\u2081 b\u2081) a\u2082 b\u2082 = f (f d a\u2082 b\u2082) a\u2081 b\u2081) (d : \u03b4) (m : Finmap \u03b2) : \u03b4 :=\n  m.entries.foldl (fun d s => f d s.1 s.2) (fun _ _ _ => H _ _ _ _ _) d", "start": [389, 1], "end": [392, 72], "kind": "commanddeclaration"}, {"full_name": "Finmap.any", "code": "def any (f : \u2200 x, \u03b2 x \u2192 Bool) (s : Finmap \u03b2) : Bool :=\n  s.foldl (fun x y z => x || f y z)\n    (fun _ _ _ _ => by simp_rw [Bool.or_assoc, Bool.or_comm, imp_true_iff]) false", "start": [395, 1], "end": [398, 82], "kind": "commanddeclaration"}, {"full_name": "Finmap.all", "code": "def all (f : \u2200 x, \u03b2 x \u2192 Bool) (s : Finmap \u03b2) : Bool :=\n  s.foldl (fun x y z => x && f y z)\n    (fun _ _ _ _ => by simp_rw [Bool.and_assoc, Bool.and_comm, imp_true_iff]) true", "start": [402, 1], "end": [405, 83], "kind": "commanddeclaration"}, {"full_name": "Finmap.erase", "code": "def erase (a : \u03b1) (s : Finmap \u03b2) : Finmap \u03b2 :=\n  (liftOn s fun t => AList.toFinmap (AList.erase a t)) fun _ _ p => toFinmap_eq.2 <| perm_erase p", "start": [414, 1], "end": [416, 98], "kind": "commanddeclaration"}, {"full_name": "Finmap.erase_toFinmap", "code": "@[simp]\ntheorem erase_toFinmap (a : \u03b1) (s : AList \u03b2) : erase a \u27e6s\u27e7 = AList.toFinmap (s.erase a)", "start": [419, 1], "end": [421, 15], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_erase_toFinset", "code": "@[simp]\ntheorem keys_erase_toFinset (a : \u03b1) (s : AList \u03b2) : keys \u27e6s.erase a\u27e7 = (keys \u27e6s\u27e7).erase a", "start": [424, 1], "end": [426, 54], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_erase", "code": "@[simp]\ntheorem keys_erase (a : \u03b1) (s : Finmap \u03b2) : (erase a s).keys = s.keys.erase a", "start": [429, 1], "end": [431, 34], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_erase", "code": "@[simp]\ntheorem mem_erase {a a' : \u03b1} {s : Finmap \u03b2} : a' \u2208 erase a s \u2194 a' \u2260 a \u2227 a' \u2208 s", "start": [434, 1], "end": [436, 34], "kind": "commanddeclaration"}, {"full_name": "Finmap.not_mem_erase_self", "code": "theorem not_mem_erase_self {a : \u03b1} {s : Finmap \u03b2} : \u00aca \u2208 erase a s", "start": [439, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_erase", "code": "@[simp]\ntheorem lookup_erase (a) (s : Finmap \u03b2) : lookup a (erase a s) = none", "start": [445, 1], "end": [447, 41], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_erase_ne", "code": "@[simp]\ntheorem lookup_erase_ne {a a'} {s : Finmap \u03b2} (h : a \u2260 a') : lookup a (erase a' s) = lookup a s", "start": [450, 1], "end": [452, 50], "kind": "commanddeclaration"}, {"full_name": "Finmap.erase_erase", "code": "theorem erase_erase {a a' : \u03b1} {s : Finmap \u03b2} : erase a (erase a' s) = erase a' (erase a s)", "start": [455, 1], "end": [456, 81], "kind": "commanddeclaration"}, {"full_name": "Finmap.sdiff", "code": "def sdiff (s s' : Finmap \u03b2) : Finmap \u03b2 :=\n  s'.foldl (fun s x _ => s.erase x) (fun _ _ _ _ _ => erase_erase) s", "start": [461, 1], "end": [464, 69], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert", "code": "def insert (a : \u03b1) (b : \u03b2 a) (s : Finmap \u03b2) : Finmap \u03b2 :=\n  (liftOn s fun t => AList.toFinmap (AList.insert a b t)) fun _ _ p =>\n    toFinmap_eq.2 <| perm_insert p", "start": [472, 1], "end": [476, 35], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_toFinmap", "code": "@[simp]\ntheorem insert_toFinmap (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) :\n    insert a b (AList.toFinmap s) = AList.toFinmap (s.insert a b)", "start": [479, 1], "end": [482, 16], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_entries_of_neg", "code": "theorem insert_entries_of_neg {a : \u03b1} {b : \u03b2 a} {s : Finmap \u03b2} :\n    a \u2209 s \u2192 (insert a b s).entries = \u27e8a, b\u27e9 ::\u2098 s.entries", "start": [485, 1], "end": [489, 78], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_insert", "code": "@[simp]\ntheorem mem_insert {a a' : \u03b1} {b' : \u03b2 a'} {s : Finmap \u03b2} : a \u2208 insert a' b' s \u2194 a = a' \u2228 a \u2208 s", "start": [492, 1], "end": [494, 34], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_insert", "code": "@[simp]\ntheorem lookup_insert {a} {b : \u03b2 a} (s : Finmap \u03b2) : lookup a (insert a b s) = some b", "start": [497, 1], "end": [499, 95], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_insert_of_ne", "code": "@[simp]\ntheorem lookup_insert_of_ne {a a'} {b : \u03b2 a} (s : Finmap \u03b2) (h : a' \u2260 a) :\n    lookup a' (insert a b s) = lookup a' s", "start": [502, 1], "end": [505, 94], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_insert", "code": "@[simp]\ntheorem insert_insert {a} {b b' : \u03b2 a} (s : Finmap \u03b2) :\n    (s.insert a b).insert a b' = s.insert a b'", "start": [508, 1], "end": [511, 78], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_insert_of_ne", "code": "theorem insert_insert_of_ne {a a'} {b : \u03b2 a} {b' : \u03b2 a'} (s : Finmap \u03b2) (h : a \u2260 a') :\n    (s.insert a b).insert a' b' = (s.insert a' b').insert a b", "start": [514, 1], "end": [517, 82], "kind": "commanddeclaration"}, {"full_name": "Finmap.toFinmap_cons", "code": "theorem toFinmap_cons (a : \u03b1) (b : \u03b2 a) (xs : List (Sigma \u03b2)) :\n    List.toFinmap (\u27e8a, b\u27e9 :: xs) = insert a b xs.toFinmap", "start": [520, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_list_toFinmap", "code": "theorem mem_list_toFinmap (a : \u03b1) (xs : List (Sigma \u03b2)) :\n    a \u2208 xs.toFinmap \u2194 \u2203 b : \u03b2 a, Sigma.mk a b \u2208 xs", "start": [525, 1], "end": [535, 36], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_singleton_eq", "code": "@[simp]\ntheorem insert_singleton_eq {a : \u03b1} {b b' : \u03b2 a} : insert a b (singleton a b') = singleton a b", "start": [538, 1], "end": [540, 75], "kind": "commanddeclaration"}, {"full_name": "Finmap.extract", "code": "def extract (a : \u03b1) (s : Finmap \u03b2) : Option (\u03b2 a) \u00d7 Finmap \u03b2 :=\n  (liftOn s fun t => Prod.map id AList.toFinmap (AList.extract a t)) fun s\u2081 s\u2082 p => by\n    simp [perm_lookup p, toFinmap_eq, perm_erase p]", "start": [545, 1], "end": [548, 52], "kind": "commanddeclaration"}, {"full_name": "Finmap.extract_eq_lookup_erase", "code": "@[simp]\ntheorem extract_eq_lookup_erase (a : \u03b1) (s : Finmap \u03b2) : extract a s = (lookup a s, erase a s)", "start": [551, 1], "end": [553, 44], "kind": "commanddeclaration"}, {"full_name": "Finmap.union", "code": "def union (s\u2081 s\u2082 : Finmap \u03b2) : Finmap \u03b2 :=\n  (liftOn\u2082 s\u2081 s\u2082 fun s\u2081 s\u2082 => (AList.toFinmap (s\u2081 \u222a s\u2082))) fun _ _ _ _ p\u2081\u2083 p\u2082\u2084 =>\n    toFinmap_eq.mpr <| perm_union p\u2081\u2083 p\u2082\u2084", "start": [558, 1], "end": [562, 42], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_union", "code": "@[simp]\ntheorem mem_union {a} {s\u2081 s\u2082 : Finmap \u03b2} : a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 \u2228 a \u2208 s\u2082", "start": [568, 1], "end": [570, 49], "kind": "commanddeclaration"}, {"full_name": "Finmap.union_toFinmap", "code": "@[simp]\ntheorem union_toFinmap (s\u2081 s\u2082 : AList \u03b2) : (toFinmap s\u2081) \u222a (toFinmap s\u2082) = toFinmap (s\u2081 \u222a s\u2082)", "start": [573, 1], "end": [575, 24], "kind": "commanddeclaration"}, {"full_name": "Finmap.keys_union", "code": "theorem keys_union {s\u2081 s\u2082 : Finmap \u03b2} : (s\u2081 \u222a s\u2082).keys = s\u2081.keys \u222a s\u2082.keys", "start": [578, 1], "end": [579, 64], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_union_left", "code": "@[simp]\ntheorem lookup_union_left {a} {s\u2081 s\u2082 : Finmap \u03b2} : a \u2208 s\u2081 \u2192 lookup a (s\u2081 \u222a s\u2082) = lookup a s\u2081", "start": [582, 1], "end": [584, 57], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_union_right", "code": "@[simp]\ntheorem lookup_union_right {a} {s\u2081 s\u2082 : Finmap \u03b2} : a \u2209 s\u2081 \u2192 lookup a (s\u2081 \u222a s\u2082) = lookup a s\u2082", "start": [587, 1], "end": [589, 58], "kind": "commanddeclaration"}, {"full_name": "Finmap.lookup_union_left_of_not_in", "code": "theorem lookup_union_left_of_not_in {a} {s\u2081 s\u2082 : Finmap \u03b2} (h : a \u2209 s\u2082) :\n    lookup a (s\u2081 \u222a s\u2082) = lookup a s\u2081", "start": [592, 1], "end": [596, 76], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_lookup_union", "code": "theorem mem_lookup_union {a} {b : \u03b2 a} {s\u2081 s\u2082 : Finmap \u03b2} :\n    b \u2208 lookup a (s\u2081 \u222a s\u2082) \u2194 b \u2208 lookup a s\u2081 \u2228 a \u2209 s\u2081 \u2227 b \u2208 lookup a s\u2082", "start": [600, 1], "end": [602, 56], "kind": "commanddeclaration"}, {"full_name": "Finmap.mem_lookup_union_middle", "code": "theorem mem_lookup_union_middle {a} {b : \u03b2 a} {s\u2081 s\u2082 s\u2083 : Finmap \u03b2} :\n    b \u2208 lookup a (s\u2081 \u222a s\u2083) \u2192 a \u2209 s\u2082 \u2192 b \u2208 lookup a (s\u2081 \u222a s\u2082 \u222a s\u2083)", "start": [605, 1], "end": [607, 68], "kind": "commanddeclaration"}, {"full_name": "Finmap.insert_union", "code": "theorem insert_union {a} {b : \u03b2 a} {s\u2081 s\u2082 : Finmap \u03b2} : insert a b (s\u2081 \u222a s\u2082) = insert a b s\u2081 \u222a s\u2082", "start": [610, 1], "end": [611, 64], "kind": "commanddeclaration"}, {"full_name": "Finmap.union_assoc", "code": "theorem union_assoc {s\u2081 s\u2082 s\u2083 : Finmap \u03b2} : s\u2081 \u222a s\u2082 \u222a s\u2083 = s\u2081 \u222a (s\u2082 \u222a s\u2083)", "start": [614, 1], "end": [616, 69], "kind": "commanddeclaration"}, {"full_name": "Finmap.empty_union", "code": "@[simp]\ntheorem empty_union {s\u2081 : Finmap \u03b2} : \u2205 \u222a s\u2081 = s\u2081", "start": [619, 1], "end": [623, 81], "kind": "commanddeclaration"}, {"full_name": "Finmap.union_empty", "code": "@[simp]\ntheorem union_empty {s\u2081 : Finmap \u03b2} : s\u2081 \u222a \u2205 = s\u2081", "start": [626, 1], "end": [630, 81], "kind": "commanddeclaration"}, {"full_name": "Finmap.erase_union_singleton", "code": "theorem erase_union_singleton (a : \u03b1) (b : \u03b2 a) (s : Finmap \u03b2) (h : s.lookup a = some b) :\n    s.erase a \u222a singleton a b = s", "start": [633, 1], "end": [640, 64], "kind": "commanddeclaration"}, {"full_name": "Finmap.Disjoint", "code": "def Disjoint (s\u2081 s\u2082 : Finmap \u03b2) : Prop :=\n  \u2200 x \u2208 s\u2081, \u00acx \u2208 s\u2082", "start": [647, 1], "end": [649, 20], "kind": "commanddeclaration"}, {"full_name": "Finmap.disjoint_empty", "code": "theorem disjoint_empty (x : Finmap \u03b2) : Disjoint \u2205 x", "start": [652, 1], "end": [653, 7], "kind": "commanddeclaration"}, {"full_name": "Finmap.Disjoint.symm", "code": "@[symm]\ntheorem Disjoint.symm (x y : Finmap \u03b2) (h : Disjoint x y) : Disjoint y x", "start": [656, 1], "end": [657, 101], "kind": "commanddeclaration"}, {"full_name": "Finmap.Disjoint.symm_iff", "code": "theorem Disjoint.symm_iff (x y : Finmap \u03b2) : Disjoint x y \u2194 Disjoint y x", "start": [660, 1], "end": [661, 41], "kind": "commanddeclaration"}, {"full_name": "Finmap.disjoint_union_left", "code": "theorem disjoint_union_left (x y z : Finmap \u03b2) : Disjoint (x \u222a y) z \u2194 Disjoint x z \u2227 Disjoint y z", "start": [670, 1], "end": [671, 59], "kind": "commanddeclaration"}, {"full_name": "Finmap.disjoint_union_right", "code": "theorem disjoint_union_right (x y z : Finmap \u03b2) :\n    Disjoint x (y \u222a z) \u2194 Disjoint x y \u2227 Disjoint x z", "start": [674, 1], "end": [676, 92], "kind": "commanddeclaration"}, {"full_name": "Finmap.union_comm_of_disjoint", "code": "theorem union_comm_of_disjoint {s\u2081 s\u2082 : Finmap \u03b2} : Disjoint s\u2081 s\u2082 \u2192 s\u2081 \u222a s\u2082 = s\u2082 \u222a s\u2081", "start": [679, 1], "end": [682, 82], "kind": "commanddeclaration"}, {"full_name": "Finmap.union_cancel", "code": "theorem union_cancel {s\u2081 s\u2082 s\u2083 : Finmap \u03b2} (h : Disjoint s\u2081 s\u2083) (h' : Disjoint s\u2082 s\u2083) :\n    s\u2081 \u222a s\u2083 = s\u2082 \u222a s\u2083 \u2194 s\u2081 = s\u2082", "start": [685, 1], "end": [695, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Compactum.lean", "imports": ["Mathlib/CategoryTheory/Monad/Types.lean", "Mathlib/CategoryTheory/Equivalence.lean", "Mathlib/Topology/Category/CompHaus/Basic.lean", "Mathlib/CategoryTheory/Monad/Limits.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/Data/Set/Constructions.lean"], "premises": [{"full_name": "Compactum", "code": "def Compactum :=\n  Monad.Algebra \u03b2 deriving Category, Inhabited", "start": [84, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "Compactum.forget", "code": "def forget : Compactum \u2964 Type* :=\n  Monad.forget _", "start": [91, 1], "end": [93, 17], "kind": "commanddeclaration"}, {"full_name": "Compactum.free", "code": "def free : Type* \u2964 Compactum :=\n  Monad.free _", "start": [103, 1], "end": [105, 15], "kind": "commanddeclaration"}, {"full_name": "Compactum.adj", "code": "def adj : free \u22a3 forget :=\n  Monad.adj _", "start": [108, 1], "end": [110, 14], "kind": "commanddeclaration"}, {"full_name": "Compactum.str", "code": "def str (X : Compactum) : Ultrafilter X \u2192 X :=\n  X.a", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "Compactum.join", "code": "def join (X : Compactum) : Ultrafilter (Ultrafilter X) \u2192 Ultrafilter X :=\n  (\u03b2 ).\u03bc.app _", "start": [131, 1], "end": [133, 15], "kind": "commanddeclaration"}, {"full_name": "Compactum.incl", "code": "def incl (X : Compactum) : X \u2192 Ultrafilter X :=\n  (\u03b2 ).\u03b7.app _", "start": [136, 1], "end": [138, 15], "kind": "commanddeclaration"}, {"full_name": "Compactum.str_incl", "code": "@[simp]\ntheorem str_incl (X : Compactum) (x : X) : X.str (X.incl x) = x", "start": [141, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Compactum.str_hom_commute", "code": "@[simp]\ntheorem str_hom_commute (X Y : Compactum) (f : X \u27f6 Y) (xs : Ultrafilter X) :\n    f (X.str xs) = Y.str (map f xs)", "start": [148, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Compactum.join_distrib", "code": "@[simp]\ntheorem join_distrib (X : Compactum) (uux : Ultrafilter (Ultrafilter X)) :\n    X.str (X.join uux) = X.str (map X.str uux)", "start": [156, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "Compactum.isClosed_iff", "code": "theorem isClosed_iff {X : Compactum} (S : Set X) :\n    IsClosed S \u2194 \u2200 F : Ultrafilter X, S \u2208 F \u2192 X.str F \u2208 S", "start": [172, 1], "end": [184, 33], "kind": "commanddeclaration"}, {"full_name": "Compactum.basic", "code": "private def basic {X : Compactum} (A : Set X) : Set (Ultrafilter X) :=\n  { F | A \u2208 F }", "start": [196, 1], "end": [198, 16], "kind": "commanddeclaration"}, {"full_name": "Compactum.cl", "code": "private def cl {X : Compactum} (A : Set X) : Set X :=\n  X.str '' basic A", "start": [200, 1], "end": [202, 19], "kind": "commanddeclaration"}, {"full_name": "Compactum.basic_inter", "code": "private theorem basic_inter {X : Compactum} (A B : Set X) : basic (A \u2229 B) = basic A \u2229 basic B", "start": [204, 1], "end": [211, 26], "kind": "commanddeclaration"}, {"full_name": "Compactum.subset_cl", "code": "private theorem subset_cl {X : Compactum} (A : Set X) : A \u2286 cl A", "start": [213, 1], "end": [214, 26], "kind": "commanddeclaration"}, {"full_name": "Compactum.cl_cl", "code": "private theorem cl_cl {X : Compactum} (A : Set X) : cl (cl A) \u2286 cl A", "start": [216, 1], "end": [273, 46], "kind": "commanddeclaration"}, {"full_name": "Compactum.isClosed_cl", "code": "theorem isClosed_cl {X : Compactum} (A : Set X) : IsClosed (cl A)", "start": [275, 1], "end": [278, 29], "kind": "commanddeclaration"}, {"full_name": "Compactum.str_eq_of_le_nhds", "code": "theorem str_eq_of_le_nhds {X : Compactum} (F : Ultrafilter X) (x : X) : \u2191F \u2264 \ud835\udcdd x \u2192 X.str F = x", "start": [281, 1], "end": [349, 44], "kind": "commanddeclaration"}, {"full_name": "Compactum.le_nhds_of_str_eq", "code": "theorem le_nhds_of_str_eq {X : Compactum} (F : Ultrafilter X) (x : X) : X.str F = x \u2192 \u2191F \u2264 \ud835\udcdd x", "start": [352, 1], "end": [353, 61], "kind": "commanddeclaration"}, {"full_name": "Compactum.lim_eq_str", "code": "theorem lim_eq_str {X : Compactum} (F : Ultrafilter X) : F.lim = X.str F", "start": [362, 1], "end": [365, 8], "kind": "commanddeclaration"}, {"full_name": "Compactum.cl_eq_closure", "code": "theorem cl_eq_closure {X : Compactum} (A : Set X) : cl A = closure A", "start": [368, 1], "end": [375, 44], "kind": "commanddeclaration"}, {"full_name": "Compactum.continuous_of_hom", "code": "theorem continuous_of_hom {X Y : Compactum} (f : X \u27f6 Y) : Continuous f", "start": [378, 1], "end": [385, 10], "kind": "commanddeclaration"}, {"full_name": "Compactum.ofTopologicalSpace", "code": "noncomputable def ofTopologicalSpace (X : Type*) [TopologicalSpace X] [CompactSpace X]\n    [T2Space X] : Compactum where\n  A := X\n  a := Ultrafilter.lim\n  unit := by\n    ext x\n    exact lim_eq (pure_le_nhds _)\n  assoc := by\n    ext FF\n    change Ultrafilter (Ultrafilter X) at FF\n    set x := (Ultrafilter.map Ultrafilter.lim FF).lim with c1\n    have c2 : \u2200 (U : Set X) (F : Ultrafilter X), F.lim \u2208 U \u2192 IsOpen U \u2192 U \u2208 F := by\n      intro U F h1 hU\n      exact isOpen_iff_ultrafilter.mp hU _ h1 _ (Ultrafilter.le_nhds_lim _)\n    have c3 : \u2191(Ultrafilter.map Ultrafilter.lim FF) \u2264 \ud835\udcdd x := by\n      rw [le_nhds_iff]\n      intro U hx hU\n      exact mem_coe.2 (c2 _ _ (by rwa [\u2190 c1]) hU)\n    have c4 : \u2200 U : Set X, x \u2208 U \u2192 IsOpen U \u2192 { G : Ultrafilter X | U \u2208 G } \u2208 FF := by\n      intro U hx hU\n      suffices Ultrafilter.lim \u207b\u00b9' U \u2208 FF by\n        apply mem_of_superset this\n        intro P hP\n        exact c2 U P hP hU\n      exact @c3 U (IsOpen.mem_nhds hU hx)\n    apply lim_eq\n    rw [le_nhds_iff]\n    exact c4", "start": [388, 1], "end": [416, 13], "kind": "commanddeclaration"}, {"full_name": "Compactum.homOfContinuous", "code": "def homOfContinuous {X Y : Compactum} (f : X \u2192 Y) (cont : Continuous f) : X \u27f6 Y :=\n  { f\n    h := by\n      rw [continuous_iff_ultrafilter] at cont\n      ext (F : Ultrafilter X)\n      specialize cont (X.str F) F (le_nhds_of_str_eq F (X.str F) rfl)\n      simp only [types_comp_apply, ofTypeFunctor_map]\n      exact str_eq_of_le_nhds (Ultrafilter.map f F) _ cont }", "start": [419, 1], "end": [427, 61], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus", "code": "def compactumToCompHaus : Compactum \u2964 CompHaus where\n  obj X := { toTop := { \u03b1 := X } }\n  map := @fun X Y f =>\n    { toFun := f\n      continuous_toFun := Compactum.continuous_of_hom _ }", "start": [432, 1], "end": [437, 58], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus.full", "code": "def full : Full compactumToCompHaus.{u} where preimage X Y {f} := Compactum.homOfContinuous f.1 f.2", "start": [442, 1], "end": [443, 100], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus.faithful", "code": "theorem faithful : Faithful compactumToCompHaus where", "start": [446, 1], "end": [453, 40], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus.isoOfTopologicalSpace", "code": "def isoOfTopologicalSpace {D : CompHaus} :\n    compactumToCompHaus.obj (Compactum.ofTopologicalSpace D) \u2245 D where\n  hom :=\n    { toFun := id\n      continuous_toFun :=\n        continuous_def.2 fun _ h => by\n          rw [isOpen_iff_ultrafilter'] at h\n          exact h }\n  inv :=\n    { toFun := id\n      continuous_toFun :=\n        continuous_def.2 fun _ h1 => by\n          rw [isOpen_iff_ultrafilter']\n          intro _ h2\n          exact h1 _ h2 }", "start": [456, 1], "end": [471, 26], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus.essSurj", "code": "theorem essSurj : EssSurj compactumToCompHaus", "start": [474, 1], "end": [476, 89], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHaus.isEquivalence", "code": "noncomputable instance isEquivalence : IsEquivalence compactumToCompHaus := by\n  have := compactumToCompHaus.full\n  have := compactumToCompHaus.faithful\n  have := compactumToCompHaus.essSurj\n  apply Equivalence.ofFullyFaithfullyEssSurj _", "start": [479, 1], "end": [484, 47], "kind": "commanddeclaration"}, {"full_name": "compactumToCompHausCompForget", "code": "def compactumToCompHausCompForget :\n    compactumToCompHaus \u22d9 CategoryTheory.forget CompHaus \u2245 Compactum.forget :=\n  NatIso.ofComponents fun X => eqToIso rfl", "start": [489, 1], "end": [493, 43], "kind": "commanddeclaration"}, {"full_name": "CompHaus.forgetCreatesLimits", "code": "noncomputable instance CompHaus.forgetCreatesLimits : CreatesLimits (forget CompHaus) := by\n  let e : forget CompHaus \u2245 compactumToCompHaus.inv \u22d9 Compactum.forget :=\n    (((forget CompHaus).leftUnitor.symm \u226a\u226b\n    isoWhiskerRight compactumToCompHaus.asEquivalence.symm.unitIso (forget CompHaus)) \u226a\u226b\n    compactumToCompHaus.inv.associator compactumToCompHaus (forget CompHaus)) \u226a\u226b\n    isoWhiskerLeft _ compactumToCompHausCompForget\n  exact createsLimitsOfNatIso e.symm", "start": [503, 1], "end": [509, 37], "kind": "commanddeclaration"}, {"full_name": "Profinite.forgetCreatesLimits", "code": "noncomputable instance Profinite.forgetCreatesLimits : CreatesLimits (forget Profinite) := by\n  change CreatesLimits (profiniteToCompHaus \u22d9 forget _)\n  infer_instance", "start": [513, 1], "end": [515, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/RingHom/Finite.lean", "imports": ["Mathlib/RingTheory/RingHomProperties.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.finite_stableUnderComposition", "code": "theorem finite_stableUnderComposition : StableUnderComposition @Finite", "start": [23, 1], "end": [25, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.finite_respectsIso", "code": "theorem finite_respectsIso : RespectsIso @Finite", "start": [28, 1], "end": [31, 64], "kind": "commanddeclaration"}, {"full_name": "RingHom.finite_stableUnderBaseChange", "code": "theorem finite_stableUnderBaseChange : StableUnderBaseChange @Finite", "start": [34, 1], "end": [42, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorAlgebra/Basis.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/LinearAlgebra/FreeModule/Rank.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/FreeModule/StrongRankCondition.lean", "Mathlib/LinearAlgebra/FreeAlgebra.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean"], "premises": [{"full_name": "TensorAlgebra.equivFreeAlgebra", "code": "noncomputable def equivFreeAlgebra (b : Basis \u03ba R M) :\n    TensorAlgebra R M \u2243\u2090[R] FreeAlgebra R \u03ba :=\n  AlgEquiv.ofAlgHom\n    (TensorAlgebra.lift _ (Finsupp.total _ _ _ (FreeAlgebra.\u03b9 _) \u2218\u2097 b.repr.toLinearMap))\n    (FreeAlgebra.lift _ (\u03b9 R \u2218 b))\n    (by ext; simp)\n    (hom_ext <| b.ext <| fun i => by simp)", "start": [38, 1], "end": [46, 43], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.equivFreeAlgebra_\u03b9_apply", "code": "@[simp]\nlemma equivFreeAlgebra_\u03b9_apply (b : Basis \u03ba R M) (i : \u03ba) :\n    equivFreeAlgebra b (\u03b9 R (b i)) = FreeAlgebra.\u03b9 R i :=\n  (TensorAlgebra.lift_\u03b9_apply _ _).trans <| by simp", "start": [48, 1], "end": [51, 52], "kind": "mathlibtacticlemma"}, {"full_name": "TensorAlgebra.equivFreeAlgebra_symm_\u03b9", "code": "@[simp]\nlemma equivFreeAlgebra_symm_\u03b9 (b : Basis \u03ba R M) (i : \u03ba) :\n    (equivFreeAlgebra b).symm (FreeAlgebra.\u03b9 R i) = \u03b9 R (b i) :=\n  (equivFreeAlgebra b).toEquiv.symm_apply_eq.mpr <| equivFreeAlgebra_\u03b9_apply b i |>.symm", "start": [53, 1], "end": [56, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Basis.tensorAlgebra", "code": "@[simps! repr_apply]\nnoncomputable def _root_.Basis.tensorAlgebra (b : Basis \u03ba R M) :\n    Basis (FreeMonoid \u03ba) R (TensorAlgebra R M) :=\n  (FreeAlgebra.basisFreeMonoid R \u03ba).map <| (equivFreeAlgebra b).symm.toLinearEquiv", "start": [58, 1], "end": [62, 83], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.instModuleFree", "code": "instance instModuleFree [Module.Free R M] : Module.Free R (TensorAlgebra R M) :=\n  let \u27e8\u27e8_\u03ba, b\u27e9\u27e9 := Module.Free.exists_basis (R := R) (M := M)\n  .of_basis b.tensorAlgebra", "start": [64, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.rank_eq", "code": "lemma rank_eq [Nontrivial R] [Module.Free R M] :\n    Module.rank R (TensorAlgebra R M) = Cardinal.lift.{uR} (sum fun n \u21a6 Module.rank R M ^\u2115 n) := by\n  let \u27e8\u27e8\u03ba, b\u27e9\u27e9 := Module.Free.exists_basis (R := R) (M := M)\n  rw [(equivFreeAlgebra b).toLinearEquiv.rank_eq, FreeAlgebra.rank_eq, mk_list_eq_sum_pow,\n    Basis.mk_eq_rank'' b]", "start": [79, 1], "end": [83, 26], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Deprecated/Subfield.lean", "imports": ["Mathlib/Deprecated/Subring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSubfield", "code": "structure IsSubfield extends IsSubring S : Prop where\n  inv_mem : \u2200 {x : F}, x \u2208 S \u2192 x\u207b\u00b9 \u2208 S", "start": [32, 1], "end": [36, 39], "kind": "commanddeclaration"}, {"full_name": "IsSubfield.div_mem", "code": "theorem IsSubfield.div_mem {S : Set F} (hS : IsSubfield S) {x y : F} (hx : x \u2208 S) (hy : y \u2208 S) :\n    x / y \u2208 S", "start": [39, 1], "end": [42, 64], "kind": "commanddeclaration"}, {"full_name": "IsSubfield.pow_mem", "code": "theorem IsSubfield.pow_mem {a : F} {n : \u2124} {s : Set F} (hs : IsSubfield s) (h : a \u2208 s) :\n    a ^ n \u2208 s", "start": [45, 1], "end": [52, 62], "kind": "commanddeclaration"}, {"full_name": "Univ.isSubfield", "code": "theorem Univ.isSubfield : IsSubfield (@Set.univ F)", "start": [55, 1], "end": [57, 33], "kind": "commanddeclaration"}, {"full_name": "Preimage.isSubfield", "code": "theorem Preimage.isSubfield {K : Type*} [Field K] (f : F \u2192+* K) {s : Set K} (hs : IsSubfield s) :\n    IsSubfield (f \u207b\u00b9' s)", "start": [60, 1], "end": [65, 28], "kind": "commanddeclaration"}, {"full_name": "Image.isSubfield", "code": "theorem Image.isSubfield {K : Type*} [Field K] (f : F \u2192+* K) {s : Set F} (hs : IsSubfield s) :\n    IsSubfield (f '' s)", "start": [68, 1], "end": [71, 79], "kind": "commanddeclaration"}, {"full_name": "Range.isSubfield", "code": "theorem Range.isSubfield {K : Type*} [Field K] (f : F \u2192+* K) : IsSubfield (Set.range f)", "start": [74, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "Field.closure", "code": "def closure : Set F :=\n  { x | \u2203 y \u2208 Ring.closure S, \u2203 z \u2208 Ring.closure S, y / z = x }", "start": [81, 1], "end": [83, 64], "kind": "commanddeclaration"}, {"full_name": "Field.ring_closure_subset", "code": "theorem ring_closure_subset : Ring.closure S \u2286 closure S", "start": [88, 1], "end": [89, 81], "kind": "commanddeclaration"}, {"full_name": "Field.closure.isSubmonoid", "code": "theorem closure.isSubmonoid : IsSubmonoid (closure S)", "start": [92, 1], "end": [98, 97], "kind": "commanddeclaration"}, {"full_name": "Field.closure.isSubfield", "code": "theorem closure.isSubfield : IsSubfield (closure S)", "start": [101, 1], "end": [122, 49], "kind": "commanddeclaration"}, {"full_name": "Field.mem_closure", "code": "theorem mem_closure {a : F} (ha : a \u2208 S) : a \u2208 closure S", "start": [125, 1], "end": [126, 45], "kind": "commanddeclaration"}, {"full_name": "Field.subset_closure", "code": "theorem subset_closure : S \u2286 closure S", "start": [129, 1], "end": [130, 22], "kind": "commanddeclaration"}, {"full_name": "Field.closure_subset", "code": "theorem closure_subset {T : Set F} (hT : IsSubfield T) (H : S \u2286 T) : closure S \u2286 T", "start": [133, 1], "end": [136, 46], "kind": "commanddeclaration"}, {"full_name": "Field.closure_subset_iff", "code": "theorem closure_subset_iff {s t : Set F} (ht : IsSubfield t) : closure s \u2286 t \u2194 s \u2286 t", "start": [139, 1], "end": [140, 55], "kind": "commanddeclaration"}, {"full_name": "Field.closure_mono", "code": "theorem closure_mono {s t : Set F} (H : s \u2286 t) : closure s \u2286 closure t", "start": [143, 1], "end": [144, 73], "kind": "commanddeclaration"}, {"full_name": "isSubfield_iUnion_of_directed", "code": "theorem isSubfield_iUnion_of_directed {\u03b9 : Type*} [Nonempty \u03b9] {s : \u03b9 \u2192 Set F}\n    (hs : \u2200 i, IsSubfield (s i)) (directed : \u2200 i j, \u2203 k, s i \u2286 s k \u2227 s j \u2286 s k) :\n    IsSubfield (\u22c3 i, s i)", "start": [149, 1], "end": [155, 88], "kind": "commanddeclaration"}, {"full_name": "IsSubfield.inter", "code": "theorem IsSubfield.inter {S\u2081 S\u2082 : Set F} (hS\u2081 : IsSubfield S\u2081) (hS\u2082 : IsSubfield S\u2082) :\n    IsSubfield (S\u2081 \u2229 S\u2082)", "start": [158, 1], "end": [161, 63], "kind": "commanddeclaration"}, {"full_name": "IsSubfield.iInter", "code": "theorem IsSubfield.iInter {\u03b9 : Sort*} {S : \u03b9 \u2192 Set F} (h : \u2200 y : \u03b9, IsSubfield (S y)) :\n    IsSubfield (Set.iInter S)", "start": [164, 1], "end": [167, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Charpoly/FiniteField.lean", "imports": ["Mathlib/FieldTheory/Finite/Basic.lean", "Mathlib/Data/Matrix/CharP.lean", "Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FiniteField.Matrix.charpoly_pow_card", "code": "@[simp]\ntheorem FiniteField.Matrix.charpoly_pow_card {K : Type*} [Field K] [Fintype K] (M : Matrix n n K) :\n    (M ^ Fintype.card K).charpoly = M.charpoly", "start": [25, 1], "end": [43, 46], "kind": "commanddeclaration"}, {"full_name": "ZMod.charpoly_pow_card", "code": "@[simp]\ntheorem ZMod.charpoly_pow_card {p : \u2115} [Fact p.Prime] (M : Matrix n n (ZMod p)) :\n    (M ^ p).charpoly = M.charpoly", "start": [46, 1], "end": [50, 23], "kind": "commanddeclaration"}, {"full_name": "FiniteField.trace_pow_card", "code": "theorem FiniteField.trace_pow_card {K : Type*} [Field K] [Fintype K] (M : Matrix n n K) :\n    trace (M ^ Fintype.card K) = trace M ^ Fintype.card K", "start": [53, 1], "end": [58, 64], "kind": "commanddeclaration"}, {"full_name": "ZMod.trace_pow_card", "code": "theorem ZMod.trace_pow_card {p : \u2115} [Fact p.Prime] (M : Matrix n n (ZMod p)) :\n    trace (M ^ p) = trace M ^ p", "start": [61, 1], "end": [62, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/SchurZassenhaus.lean", "imports": ["Mathlib/GroupTheory/Transfer.lean", "Mathlib/GroupTheory/Sylow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.QuotientDiff", "code": "def QuotientDiff :=\n  Quotient\n    (Setoid.mk (fun \u03b1 \u03b2 => diff (MonoidHom.id H) \u03b1 \u03b2 = 1)\n      \u27e8fun \u03b1 => diff_self (MonoidHom.id H) \u03b1, fun h => by rw [\u2190 diff_inv, h, inv_one],\n        fun h h' => by rw [\u2190 diff_mul_diff, h, h', one_mul]\u27e9)", "start": [38, 1], "end": [43, 62], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_diff_smul'", "code": "theorem smul_diff_smul' [hH : Normal H] (g : G\u1d50\u1d52\u1d56) :\n    diff (MonoidHom.id H) (g \u2022 \u03b1) (g \u2022 \u03b2) =\n      \u27e8g.unop\u207b\u00b9 * (diff (MonoidHom.id H) \u03b1 \u03b2 : H) * g.unop,\n        hH.mem_comm ((congr_arg (\u00b7 \u2208 H) (mul_inv_cancel_left _ _)).mpr (SetLike.coe_mem _))\u27e9", "start": [50, 1], "end": [69, 81], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_diff'", "code": "theorem smul_diff' (h : H) :\n    diff (MonoidHom.id H) \u03b1 (op (h : G) \u2022 \u03b2) = diff (MonoidHom.id H) \u03b1 \u03b2 * h ^ H.index", "start": [88, 1], "end": [96, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_one_of_smul_eq_one", "code": "theorem eq_one_of_smul_eq_one (hH : Nat.Coprime (Nat.card H) H.index) (\u03b1 : H.QuotientDiff)\n    (h : H) : h \u2022 \u03b1 = \u03b1 \u2192 h = 1", "start": [99, 1], "end": [106, 77], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_smul_eq", "code": "theorem exists_smul_eq (hH : Nat.Coprime (Nat.card H) H.index) (\u03b1 \u03b2 : H.QuotientDiff) :\n    \u2203 h : H, h \u2022 \u03b1 = \u03b2", "start": [110, 1], "end": [119, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_stabilizer_of_coprime", "code": "theorem isComplement'_stabilizer_of_coprime {\u03b1 : H.QuotientDiff}\n    (hH : Nat.Coprime (Nat.card H) H.index) : IsComplement' H (stabilizer G \u03b1)", "start": [122, 1], "end": [124, 95], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_right_complement'_of_coprime_aux", "code": "private theorem exists_right_complement'_of_coprime_aux (hH : Nat.Coprime (Nat.card H) H.index) :\n    \u2203 K : Subgroup G, IsComplement' H K", "start": [127, 1], "end": [130, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step0", "code": "private theorem step0 : N \u2260 \u22a5", "start": [167, 1], "end": [170, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step1", "code": "private theorem step1 (K : Subgroup G) (hK : K \u2294 N = \u22a4) : K = \u22a4", "start": [172, 1], "end": [193, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step2", "code": "private theorem step2 (K : Subgroup G) [K.Normal] (hK : K \u2264 N) : K = \u22a5 \u2228 K = N", "start": [195, 1], "end": [223, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step3", "code": "private theorem step3 (K : Subgroup N) [(K.map N.subtype).Normal] : K = \u22a5 \u2228 K = \u22a4", "start": [225, 1], "end": [234, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step4", "code": "private theorem step4 : (Fintype.card N).minFac.Prime", "start": [236, 1], "end": [238, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step5", "code": "private theorem step5 {P : Sylow (Fintype.card N).minFac N} : P.1 \u2260 \u22a5", "start": [240, 1], "end": [243, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step6", "code": "private theorem step6 : IsPGroup (Fintype.card N).minFac N", "start": [245, 1], "end": [252, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SchurZassenhausInduction.step7", "code": "theorem step7 : IsCommutative N", "start": [254, 1], "end": [261, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_right_complement'_of_coprime_aux'", "code": "private theorem exists_right_complement'_of_coprime_aux' [Fintype G] (hG : Fintype.card G = n)\n    {N : Subgroup G} [N.Normal] (hN : Nat.Coprime (Fintype.card N) N.index) :\n    \u2203 H : Subgroup G, IsComplement' N H", "start": [268, 1], "end": [278, 81], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_right_complement'_of_coprime_of_fintype", "code": "theorem exists_right_complement'_of_coprime_of_fintype [Fintype G] {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Fintype.card N) N.index) : \u2203 H : Subgroup G, IsComplement' N H", "start": [280, 1], "end": [285, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_right_complement'_of_coprime", "code": "theorem exists_right_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Nat.card N) N.index) : \u2203 H : Subgroup G, IsComplement' N H", "start": [288, 1], "end": [308, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_left_complement'_of_coprime_of_fintype", "code": "theorem exists_left_complement'_of_coprime_of_fintype [Fintype G] {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Fintype.card N) N.index) : \u2203 H : Subgroup G, IsComplement' H N", "start": [311, 1], "end": [316, 95], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_left_complement'_of_coprime", "code": "theorem exists_left_complement'_of_coprime {N : Subgroup G} [N.Normal]\n    (hN : Nat.Coprime (Nat.card N) N.index) : \u2203 H : Subgroup G, IsComplement' H N", "start": [319, 1], "end": [324, 84], "kind": "commanddeclaration"}]}
