{"path": "Mathlib/Order/LiminfLimsup.lean", "imports": ["Mathlib/Order/Hom/CompleteLattice.lean", "Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.IsBounded", "code": "def IsBounded (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : Filter \u03b1) :=\n  \u2203 b, \u2200\u1da0 x in f, r x b", "start": [50, 1], "end": [54, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder", "code": "def IsBoundedUnder (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) :=\n  (map u f).IsBounded r", "start": [57, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_iff", "code": "theorem isBounded_iff : f.IsBounded r \u2194 \u2203 s \u2208 f.sets, \u2203 b, s \u2286 { x | r x b }", "start": [65, 1], "end": [69, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_of", "code": "theorem isBoundedUnder_of {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : (\u2203 b, \u2200 x, r (u x) b) \u2192 f.IsBoundedUnder r u", "start": [72, 1], "end": [74, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_bot", "code": "theorem isBounded_bot : IsBounded r \u22a5 \u2194 Nonempty \u03b1", "start": [77, 1], "end": [77, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_top", "code": "theorem isBounded_top : IsBounded r \u22a4 \u2194 \u2203 t, \u2200 x, r x t", "start": [80, 1], "end": [80, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_principal", "code": "theorem isBounded_principal (s : Set \u03b1) : IsBounded r (\ud835\udcdf s) \u2194 \u2203 t, \u2200 x \u2208 s, r x t", "start": [83, 1], "end": [84, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_sup", "code": "theorem isBounded_sup [IsTrans \u03b1 r] [IsDirected \u03b1 r] :\n    IsBounded r f \u2192 IsBounded r g \u2192 IsBounded r (f \u2294 g)", "start": [87, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBounded.mono", "code": "theorem IsBounded.mono (h : f \u2264 g) : IsBounded r g \u2192 IsBounded r f", "start": [95, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.mono", "code": "theorem IsBoundedUnder.mono {f g : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} (h : f \u2264 g) :\n    g.IsBoundedUnder r u \u2192 f.IsBoundedUnder r u", "start": [99, 1], "end": [100, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.mono_le", "code": "theorem IsBoundedUnder.mono_le [Preorder \u03b2] {l : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (hu : IsBoundedUnder (\u00b7 \u2264 \u00b7) l u) (hv : v \u2264\u1da0[l] u) : IsBoundedUnder (\u00b7 \u2264 \u00b7) l v", "start": [103, 1], "end": [106, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.mono_ge", "code": "theorem IsBoundedUnder.mono_ge [Preorder \u03b2] {l : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (hu : IsBoundedUnder (\u00b7 \u2265 \u00b7) l u) (hv : u \u2264\u1da0[l] v) : IsBoundedUnder (\u00b7 \u2265 \u00b7) l v", "start": [109, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_const", "code": "theorem isBoundedUnder_const [IsRefl \u03b1 r] {l : Filter \u03b2} {a : \u03b1} : IsBoundedUnder r l fun _ => a", "start": [114, 1], "end": [115, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBounded.isBoundedUnder", "code": "theorem IsBounded.isBoundedUnder {q : \u03b2 \u2192 \u03b2 \u2192 Prop} {u : \u03b1 \u2192 \u03b2}\n    (hu : \u2200 a\u2080 a\u2081, r a\u2080 a\u2081 \u2192 q (u a\u2080) (u a\u2081)) : f.IsBounded r \u2192 f.IsBoundedUnder q u", "start": [118, 1], "end": [120, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.comp", "code": "theorem IsBoundedUnder.comp {l : Filter \u03b3} {q : \u03b2 \u2192 \u03b2 \u2192 Prop} {u : \u03b3 \u2192 \u03b1} {v : \u03b1 \u2192 \u03b2}\n    (hv : \u2200 a\u2080 a\u2081, r a\u2080 a\u2081 \u2192 q (v a\u2080) (v a\u2081)) : l.IsBoundedUnder r u \u2192 l.IsBoundedUnder q (v \u2218 u)", "start": [123, 1], "end": [125, 85], "kind": "commanddeclaration"}, {"full_name": "Monotone.isBoundedUnder_le_comp", "code": "theorem _root_.Monotone.isBoundedUnder_le_comp [Preorder \u03b1] [Preorder \u03b2] {l : Filter \u03b3} {u : \u03b3 \u2192 \u03b1}\n    {v : \u03b1 \u2192 \u03b2} (hv : Monotone v) (hl : l.IsBoundedUnder (\u00b7 \u2264 \u00b7) u) :\n    l.IsBoundedUnder (\u00b7 \u2264 \u00b7) (v \u2218 u)", "start": [127, 1], "end": [130, 13], "kind": "commanddeclaration"}, {"full_name": "Monotone.isBoundedUnder_ge_comp", "code": "theorem _root_.Monotone.isBoundedUnder_ge_comp [Preorder \u03b1] [Preorder \u03b2] {l : Filter \u03b3} {u : \u03b3 \u2192 \u03b1}\n    {v : \u03b1 \u2192 \u03b2} (hv : Monotone v) (hl : l.IsBoundedUnder (\u00b7 \u2265 \u00b7) u) :\n    l.IsBoundedUnder (\u00b7 \u2265 \u00b7) (v \u2218 u)", "start": [132, 1], "end": [135, 20], "kind": "commanddeclaration"}, {"full_name": "Antitone.isBoundedUnder_le_comp", "code": "theorem _root_.Antitone.isBoundedUnder_le_comp [Preorder \u03b1] [Preorder \u03b2] {l : Filter \u03b3} {u : \u03b3 \u2192 \u03b1}\n    {v : \u03b1 \u2192 \u03b2} (hv : Antitone v) (hl : l.IsBoundedUnder (\u00b7 \u2265 \u00b7) u) :\n    l.IsBoundedUnder (\u00b7 \u2264 \u00b7) (v \u2218 u)", "start": [137, 1], "end": [140, 20], "kind": "commanddeclaration"}, {"full_name": "Antitone.isBoundedUnder_ge_comp", "code": "theorem _root_.Antitone.isBoundedUnder_ge_comp [Preorder \u03b1] [Preorder \u03b2] {l : Filter \u03b3} {u : \u03b3 \u2192 \u03b1}\n    {v : \u03b1 \u2192 \u03b2} (hv : Antitone v) (hl : l.IsBoundedUnder (\u00b7 \u2264 \u00b7) u) :\n    l.IsBoundedUnder (\u00b7 \u2265 \u00b7) (v \u2218 u)", "start": [142, 1], "end": [145, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.not_isBoundedUnder_of_tendsto_atTop", "code": "theorem not_isBoundedUnder_of_tendsto_atTop [Preorder \u03b2] [NoMaxOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    [l.NeBot] (hf : Tendsto f l atTop) : \u00acIsBoundedUnder (\u00b7 \u2264 \u00b7) l f", "start": [147, 1], "end": [155, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.not_isBoundedUnder_of_tendsto_atBot", "code": "theorem not_isBoundedUnder_of_tendsto_atBot [Preorder \u03b2] [NoMinOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    [l.NeBot] (hf : Tendsto f l atBot) : \u00acIsBoundedUnder (\u00b7 \u2265 \u00b7) l f", "start": [158, 1], "end": [160, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.bddAbove_range_of_cofinite", "code": "theorem IsBoundedUnder.bddAbove_range_of_cofinite [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)] {f : \u03b1 \u2192 \u03b2}\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) cofinite f) : BddAbove (range f)", "start": [163, 1], "end": [168, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.bddBelow_range_of_cofinite", "code": "theorem IsBoundedUnder.bddBelow_range_of_cofinite [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2265 \u00b7)] {f : \u03b1 \u2192 \u03b2}\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) cofinite f) : BddBelow (range f)", "start": [171, 1], "end": [173, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.bddAbove_range", "code": "theorem IsBoundedUnder.bddAbove_range [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)] {f : \u2115 \u2192 \u03b2}\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) atTop f) : BddAbove (range f)", "start": [176, 1], "end": [179, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.bddBelow_range", "code": "theorem IsBoundedUnder.bddBelow_range [Preorder \u03b2] [IsDirected \u03b2 (\u00b7 \u2265 \u00b7)] {f : \u2115 \u2192 \u03b2}\n    (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) atTop f) : BddBelow (range f)", "start": [182, 1], "end": [184, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCobounded", "code": "def IsCobounded (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : Filter \u03b1) :=\n  \u2203 b, \u2200 a, (\u2200\u1da0 x in f, r x a) \u2192 r b a", "start": [187, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCoboundedUnder", "code": "def IsCoboundedUnder (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) :=\n  (map u f).IsCobounded r", "start": [201, 1], "end": [205, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCobounded.mk", "code": "theorem IsCobounded.mk [IsTrans \u03b1 r] (a : \u03b1) (h : \u2200 s \u2208 f, \u2203 x \u2208 s, r a x) : f.IsCobounded r", "start": [208, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBounded.isCobounded_flip", "code": "theorem IsBounded.isCobounded_flip [IsTrans \u03b1 r] [NeBot f] : f.IsBounded r \u2192 f.IsCobounded (flip r)", "start": [218, 1], "end": [224, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBounded.isCobounded_ge", "code": "theorem IsBounded.isCobounded_ge [Preorder \u03b1] [NeBot f] (h : f.IsBounded (\u00b7 \u2264 \u00b7)) :\n    f.IsCobounded (\u00b7 \u2265 \u00b7)", "start": [227, 1], "end": [229, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBounded.isCobounded_le", "code": "theorem IsBounded.isCobounded_le [Preorder \u03b1] [NeBot f] (h : f.IsBounded (\u00b7 \u2265 \u00b7)) :\n    f.IsCobounded (\u00b7 \u2264 \u00b7)", "start": [232, 1], "end": [234, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.isCoboundedUnder_flip", "code": "theorem IsBoundedUnder.isCoboundedUnder_flip {l : Filter \u03b3} [IsTrans \u03b1 r] [NeBot l]\n    (h : l.IsBoundedUnder r u) : l.IsCoboundedUnder (flip r) u", "start": [237, 1], "end": [239, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.isCoboundedUnder_le", "code": "theorem IsBoundedUnder.isCoboundedUnder_le {u : \u03b3 \u2192 \u03b1} {l : Filter \u03b3} [Preorder \u03b1] [NeBot l]\n    (h : l.IsBoundedUnder (\u00b7 \u2265 \u00b7) u) : l.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u", "start": [241, 1], "end": [243, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.isCoboundedUnder_ge", "code": "theorem IsBoundedUnder.isCoboundedUnder_ge {u : \u03b3 \u2192 \u03b1} {l : Filter \u03b3} [Preorder \u03b1] [NeBot l]\n    (h : l.IsBoundedUnder (\u00b7 \u2264 \u00b7) u) : l.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u", "start": [245, 1], "end": [247, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.isCobounded_bot", "code": "theorem isCobounded_bot : IsCobounded r \u22a5 \u2194 \u2203 b, \u2200 x, r b x", "start": [249, 1], "end": [249, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.isCobounded_top", "code": "theorem isCobounded_top : IsCobounded r \u22a4 \u2194 Nonempty \u03b1", "start": [252, 1], "end": [254, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.isCobounded_principal", "code": "theorem isCobounded_principal (s : Set \u03b1) :\n    (\ud835\udcdf s).IsCobounded r \u2194 \u2203 b, \u2200 a, (\u2200 x \u2208 s, r x a) \u2192 r b a", "start": [257, 1], "end": [258, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCobounded.mono", "code": "theorem IsCobounded.mono (h : f \u2264 g) : f.IsCobounded r \u2192 g.IsCobounded r", "start": [261, 1], "end": [262, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_le_atBot", "code": "theorem isBounded_le_atBot : (atBot : Filter \u03b1).IsBounded (\u00b7 \u2264 \u00b7)", "start": [270, 1], "end": [271, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_ge_atTop", "code": "theorem isBounded_ge_atTop : (atTop : Filter \u03b1).IsBounded (\u00b7 \u2265 \u00b7)", "start": [274, 1], "end": [275, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isBoundedUnder_le_atBot", "code": "theorem Tendsto.isBoundedUnder_le_atBot (h : Tendsto u f atBot) : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u", "start": [278, 1], "end": [279, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isBoundedUnder_ge_atTop", "code": "theorem Tendsto.isBoundedUnder_ge_atTop (h : Tendsto u f atTop) : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u", "start": [282, 1], "end": [283, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.bddAbove_range_of_tendsto_atTop_atBot", "code": "theorem bddAbove_range_of_tendsto_atTop_atBot [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {u : \u2115 \u2192 \u03b1}\n    (hx : Tendsto u atTop atBot) : BddAbove (Set.range u)", "start": [286, 1], "end": [288, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.bddBelow_range_of_tendsto_atTop_atTop", "code": "theorem bddBelow_range_of_tendsto_atTop_atTop [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {u : \u2115 \u2192 \u03b1}\n    (hx : Tendsto u atTop atTop) : BddBelow (Set.range u)", "start": [291, 1], "end": [293, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.isCobounded_le_of_bot", "code": "theorem isCobounded_le_of_bot [Preorder \u03b1] [OrderBot \u03b1] {f : Filter \u03b1} : f.IsCobounded (\u00b7 \u2264 \u00b7)", "start": [298, 1], "end": [299, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.isCobounded_ge_of_top", "code": "theorem isCobounded_ge_of_top [Preorder \u03b1] [OrderTop \u03b1] {f : Filter \u03b1} : f.IsCobounded (\u00b7 \u2265 \u00b7)", "start": [302, 1], "end": [303, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_le_of_top", "code": "theorem isBounded_le_of_top [Preorder \u03b1] [OrderTop \u03b1] {f : Filter \u03b1} : f.IsBounded (\u00b7 \u2264 \u00b7)", "start": [306, 1], "end": [307, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.isBounded_ge_of_bot", "code": "theorem isBounded_ge_of_bot [Preorder \u03b1] [OrderBot \u03b1] {f : Filter \u03b1} : f.IsBounded (\u00b7 \u2265 \u00b7)", "start": [310, 1], "end": [311, 44], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isBoundedUnder_le_comp", "code": "@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder \u03b1] [Preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {l : Filter \u03b3}\n    {u : \u03b3 \u2192 \u03b1} : (IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => e (u x)) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l u", "start": [314, 1], "end": [318, 69], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isBoundedUnder_ge_comp", "code": "@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_ge_comp [Preorder \u03b1] [Preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {l : Filter \u03b3}\n    {u : \u03b3 \u2192 \u03b1} : (IsBoundedUnder (\u00b7 \u2265 \u00b7) l fun x => e (u x)) \u2194 IsBoundedUnder (\u00b7 \u2265 \u00b7) l u", "start": [321, 1], "end": [324, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_le_inv", "code": "@[to_additive (attr := simp)]\ntheorem isBoundedUnder_le_inv [OrderedCommGroup \u03b1] {l : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} :\n    (IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => (u x)\u207b\u00b9) \u2194 IsBoundedUnder (\u00b7 \u2265 \u00b7) l u", "start": [327, 1], "end": [330, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_ge_inv", "code": "@[to_additive (attr := simp)]\ntheorem isBoundedUnder_ge_inv [OrderedCommGroup \u03b1] {l : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} :\n    (IsBoundedUnder (\u00b7 \u2265 \u00b7) l fun x => (u x)\u207b\u00b9) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l u", "start": [334, 1], "end": [337, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.sup", "code": "theorem IsBoundedUnder.sup [SemilatticeSup \u03b1] {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} :\n    f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u \u2192\n      f.IsBoundedUnder (\u00b7 \u2264 \u00b7) v \u2192 f.IsBoundedUnder (\u00b7 \u2264 \u00b7) fun a => u a \u2294 v a", "start": [341, 1], "end": [346, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_le_sup", "code": "@[simp]\ntheorem isBoundedUnder_le_sup [SemilatticeSup \u03b1] {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} :\n    (f.IsBoundedUnder (\u00b7 \u2264 \u00b7) fun a => u a \u2294 v a) \u2194\n      f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u \u2227 f.IsBoundedUnder (\u00b7 \u2264 \u00b7) v", "start": [349, 1], "end": [356, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.inf", "code": "theorem IsBoundedUnder.inf [SemilatticeInf \u03b1] {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} :\n    f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u \u2192\n      f.IsBoundedUnder (\u00b7 \u2265 \u00b7) v \u2192 f.IsBoundedUnder (\u00b7 \u2265 \u00b7) fun a => u a \u2293 v a", "start": [359, 1], "end": [362, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_ge_inf", "code": "@[simp]\ntheorem isBoundedUnder_ge_inf [SemilatticeInf \u03b1] {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} :\n    (f.IsBoundedUnder (\u00b7 \u2265 \u00b7) fun a => u a \u2293 v a) \u2194\n      f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u \u2227 f.IsBoundedUnder (\u00b7 \u2265 \u00b7) v", "start": [365, 1], "end": [369, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_le_abs", "code": "theorem isBoundedUnder_le_abs [LinearOrderedAddCommGroup \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} :\n    (f.IsBoundedUnder (\u00b7 \u2264 \u00b7) fun a => |u a|) \u2194\n      f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u \u2227 f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u", "start": [372, 1], "end": [375, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup", "code": "def limsSup (f : Filter \u03b1) : \u03b1 :=\n  sInf { a | \u2200\u1da0 n in f, n \u2264 a }", "start": [403, 1], "end": [406, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf", "code": "def limsInf (f : Filter \u03b1) : \u03b1 :=\n  sSup { a | \u2200\u1da0 n in f, a \u2264 n }", "start": [411, 1], "end": [414, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup", "code": "def limsup (u : \u03b2 \u2192 \u03b1) (f : Filter \u03b2) : \u03b1 :=\n  limsSup (map u f)", "start": [418, 1], "end": [421, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf", "code": "def liminf (u : \u03b2 \u2192 \u03b1) (f : Filter \u03b2) : \u03b1 :=\n  limsInf (map u f)", "start": [424, 1], "end": [427, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup", "code": "def blimsup (u : \u03b2 \u2192 \u03b1) (f : Filter \u03b2) (p : \u03b2 \u2192 Prop) :=\n  sInf { a | \u2200\u1da0 x in f, p x \u2192 u x \u2264 a }", "start": [430, 1], "end": [433, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf", "code": "def bliminf (u : \u03b2 \u2192 \u03b1) (f : Filter \u03b2) (p : \u03b2 \u2192 Prop) :=\n  sSup { a | \u2200\u1da0 x in f, p x \u2192 a \u2264 u x }", "start": [436, 1], "end": [439, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_eq", "code": "theorem limsup_eq : limsup u f = sInf { a | \u2200\u1da0 n in f, u n \u2264 a }", "start": [446, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_eq", "code": "theorem liminf_eq : liminf u f = sSup { a | \u2200\u1da0 n in f, a \u2264 u n }", "start": [450, 1], "end": [451, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_eq", "code": "theorem blimsup_eq : blimsup u f p = sInf { a | \u2200\u1da0 x in f, p x \u2192 u x \u2264 a }", "start": [454, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_eq", "code": "theorem bliminf_eq : bliminf u f p = sSup { a | \u2200\u1da0 x in f, p x \u2192 a \u2264 u x }", "start": [458, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_true", "code": "@[simp]\ntheorem blimsup_true (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) : (blimsup u f fun _ => True) = limsup u f", "start": [464, 1], "end": [466, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_true", "code": "@[simp]\ntheorem bliminf_true (f : Filter \u03b2) (u : \u03b2 \u2192 \u03b1) : (bliminf u f fun _ => True) = liminf u f", "start": [469, 1], "end": [471, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_eq_limsup_subtype", "code": "theorem blimsup_eq_limsup_subtype {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} :\n    blimsup u f p = limsup (u \u2218 ((\u2191) : { x | p x } \u2192 \u03b2)) (comap (\u2191) f)", "start": [474, 1], "end": [483, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_eq_liminf_subtype", "code": "theorem bliminf_eq_liminf_subtype {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} :\n    bliminf u f p = liminf (u \u2218 ((\u2191) : { x | p x } \u2192 \u03b2)) (comap (\u2191) f)", "start": [486, 1], "end": [488, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_le_of_le", "code": "theorem limsSup_le_of_le {f : Filter \u03b1} {a}\n    (hf : f.IsCobounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (h : \u2200\u1da0 n in f, n \u2264 a) : limsSup f \u2264 a", "start": [491, 1], "end": [494, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.le_limsInf_of_le", "code": "theorem le_limsInf_of_le {f : Filter \u03b1} {a}\n    (hf : f.IsCobounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (h : \u2200\u1da0 n in f, a \u2264 n) : a \u2264 limsInf f", "start": [498, 1], "end": [501, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_le_of_le", "code": "theorem limsup_le_of_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a}\n    (hf : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h : \u2200\u1da0 n in f, u n \u2264 a) : limsup u f \u2264 a", "start": [505, 1], "end": [508, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.le_liminf_of_le", "code": "theorem le_liminf_of_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a}\n    (hf : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (h : \u2200\u1da0 n in f, a \u2264 u n) : a \u2264 liminf u f", "start": [511, 1], "end": [514, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.le_limsSup_of_le", "code": "theorem le_limsSup_of_le {f : Filter \u03b1} {a}\n    (hf : f.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (h : \u2200 b, (\u2200\u1da0 n in f, n \u2264 b) \u2192 a \u2264 b) : a \u2264 limsSup f", "start": [517, 1], "end": [520, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_le_of_le", "code": "theorem limsInf_le_of_le {f : Filter \u03b1} {a}\n    (hf : f.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (h : \u2200 b, (\u2200\u1da0 n in f, b \u2264 n) \u2192 b \u2264 a) : limsInf f \u2264 a", "start": [524, 1], "end": [527, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.le_limsup_of_le", "code": "theorem le_limsup_of_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a}\n    (hf : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h : \u2200 b, (\u2200\u1da0 n in f, u n \u2264 b) \u2192 a \u2264 b) : a \u2264 limsup u f", "start": [531, 1], "end": [534, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_of_le", "code": "theorem liminf_le_of_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a}\n    (hf : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (h : \u2200 b, (\u2200\u1da0 n in f, b \u2264 u n) \u2192 b \u2264 a) : liminf u f \u2264 a", "start": [537, 1], "end": [540, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_le_limsSup", "code": "theorem limsInf_le_limsSup {f : Filter \u03b1} [NeBot f]\n    (h\u2081 : f.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (h\u2082 : f.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault):\n    limsInf f \u2264 limsSup f", "start": [543, 1], "end": [551, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_limsup", "code": "theorem liminf_le_limsup {f : Filter \u03b2} [NeBot f] {u : \u03b2 \u2192 \u03b1}\n    (h : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault):\n    liminf u f \u2264 limsup u f", "start": [555, 1], "end": [559, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_le_limsSup", "code": "theorem limsSup_le_limsSup {f g : Filter \u03b1}\n    (hf : f.IsCobounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (hg : g.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (h : \u2200 a, (\u2200\u1da0 n in g, n \u2264 a) \u2192 \u2200\u1da0 n in f, n \u2264 a) : limsSup f \u2264 limsSup g", "start": [562, 1], "end": [566, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_le_limsInf", "code": "theorem limsInf_le_limsInf {f g : Filter \u03b1}\n    (hf : f.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (hg : g.IsCobounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (h : \u2200 a, (\u2200\u1da0 n in f, a \u2264 n) \u2192 \u2200\u1da0 n in g, a \u2264 n) : limsInf f \u2264 limsInf g", "start": [570, 1], "end": [574, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_le_limsup", "code": "theorem limsup_le_limsup {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (h : u \u2264\u1da0[f] v)\n    (hu : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (hv : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) v := by isBoundedDefault) :\n    limsup u f \u2264 limsup v f", "start": [578, 1], "end": [583, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_liminf", "code": "theorem liminf_le_liminf {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 a in f, u a \u2264 v a)\n    (hu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hv : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) v := by isBoundedDefault) :\n    liminf u f \u2264 liminf v f", "start": [586, 1], "end": [591, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_le_limsSup_of_le", "code": "theorem limsSup_le_limsSup_of_le {f g : Filter \u03b1} (h : f \u2264 g)\n    (hf : f.IsCobounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (hg : g.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault) :\n    limsSup f \u2264 limsSup g", "start": [594, 1], "end": [598, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_le_limsInf_of_le", "code": "theorem limsInf_le_limsInf_of_le {f g : Filter \u03b1} (h : g \u2264 f)\n    (hf : f.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (hg : g.IsCobounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault) :\n    limsInf f \u2264 limsInf g", "start": [602, 1], "end": [606, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_le_limsup_of_le", "code": "theorem limsup_le_limsup_of_le {\u03b1 \u03b2} [ConditionallyCompleteLattice \u03b2] {f g : Filter \u03b1} (h : f \u2264 g)\n    {u : \u03b1 \u2192 \u03b2}\n    (hf : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (hg : g.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault) :\n    limsup u f \u2264 limsup u g", "start": [610, 1], "end": [615, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_liminf_of_le", "code": "theorem liminf_le_liminf_of_le {\u03b1 \u03b2} [ConditionallyCompleteLattice \u03b2] {f g : Filter \u03b1} (h : g \u2264 f)\n    {u : \u03b1 \u2192 \u03b2}\n    (hf : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hg : g.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) :\n    liminf u f \u2264 liminf u g", "start": [618, 1], "end": [623, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_principal", "code": "theorem limsSup_principal {s : Set \u03b1} (h : BddAbove s) (hs : s.Nonempty) : limsSup (\ud835\udcdf s) = sSup s", "start": [626, 1], "end": [627, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_principal", "code": "theorem limsInf_principal {s : Set \u03b1} (h : BddBelow s) (hs : s.Nonempty) : limsInf (\ud835\udcdf s) = sInf s", "start": [631, 1], "end": [632, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_congr", "code": "theorem limsup_congr {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 a in f, u a = v a) : limsup u f = limsup v f", "start": [636, 1], "end": [640, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_congr", "code": "theorem blimsup_congr {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} (h : \u2200\u1da0 a in f, p a \u2192 u a = v a) :\n    blimsup u f p = blimsup v f p", "start": [643, 1], "end": [651, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_congr", "code": "theorem bliminf_congr {f : Filter \u03b2} {u v : \u03b2 \u2192 \u03b1} {p : \u03b2 \u2192 Prop} (h : \u2200\u1da0 a in f, p a \u2192 u a = v a) :\n    bliminf u f p = bliminf v f p", "start": [654, 1], "end": [656, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_congr", "code": "theorem liminf_congr {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} {u v : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 a in f, u a = v a) : liminf u f = liminf v f", "start": [659, 1], "end": [661, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_const", "code": "theorem limsup_const {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} [NeBot f]\n    (b : \u03b2) : limsup (fun _ => b) f = b", "start": [664, 1], "end": [666, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_const", "code": "theorem liminf_const {\u03b1 : Type*} [ConditionallyCompleteLattice \u03b2] {f : Filter \u03b1} [NeBot f]\n    (b : \u03b2) : liminf (fun _ => b) f = b", "start": [669, 1], "end": [671, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.liminf_eq_sSup_iUnion_iInter", "code": "theorem HasBasis.liminf_eq_sSup_iUnion_iInter {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) :\n    liminf f v = sSup (\u22c3 (j : Subtype p), \u22c2 (i : s j), Iic (f i))", "start": [674, 1], "end": [681, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.liminf_eq_sSup_univ_of_empty", "code": "theorem HasBasis.liminf_eq_sSup_univ_of_empty {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) (i : \u03b9') (hi : p i) (h'i : s i = \u2205) :\n    liminf f v = sSup univ", "start": [683, 1], "end": [690, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsup_eq_sInf_iUnion_iInter", "code": "theorem HasBasis.limsup_eq_sInf_iUnion_iInter {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) :\n    limsup f v = sInf (\u22c3 (j : Subtype p), \u22c2 (i : s j), Ici (f i))", "start": [692, 1], "end": [695, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsup_eq_sInf_univ_of_empty", "code": "theorem HasBasis.limsup_eq_sInf_univ_of_empty {f : \u03b9 \u2192 \u03b1} {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} (hv : v.HasBasis p s) (i : \u03b9') (hi : p i) (h'i : s i = \u2205) :\n    limsup f v = sInf univ", "start": [697, 1], "end": [700, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_bot", "code": "@[simp]\ntheorem limsSup_bot : limsSup (\u22a5 : Filter \u03b1) = \u22a5", "start": [708, 1], "end": [710, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_bot", "code": "@[simp] theorem limsup_bot (f : \u03b2 \u2192 \u03b1) : limsup f \u22a5 = \u22a5", "start": [714, 1], "end": [714, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_bot", "code": "@[simp]\ntheorem limsInf_bot : limsInf (\u22a5 : Filter \u03b1) = \u22a4", "start": [716, 1], "end": [718, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_bot", "code": "@[simp] theorem liminf_bot (f : \u03b2 \u2192 \u03b1) : liminf f \u22a5 = \u22a4", "start": [722, 1], "end": [722, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_top", "code": "@[simp]\ntheorem limsSup_top : limsSup (\u22a4 : Filter \u03b1) = \u22a4", "start": [724, 1], "end": [726, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_top", "code": "@[simp]\ntheorem limsInf_top : limsInf (\u22a4 : Filter \u03b1) = \u22a5", "start": [730, 1], "end": [732, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_false", "code": "@[simp]\ntheorem blimsup_false {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : (blimsup u f fun _ => False) = \u22a5", "start": [736, 1], "end": [738, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_false", "code": "@[simp]\ntheorem bliminf_false {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : (bliminf u f fun _ => False) = \u22a4", "start": [741, 1], "end": [743, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_const_bot", "code": "theorem limsup_const_bot {f : Filter \u03b2} : limsup (fun _ : \u03b2 => (\u22a5 : \u03b1)) f = (\u22a5 : \u03b1)", "start": [746, 1], "end": [749, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_const_top", "code": "theorem liminf_const_top {f : Filter \u03b2} : liminf (fun _ : \u03b2 => (\u22a4 : \u03b1)) f = (\u22a4 : \u03b1)", "start": [752, 1], "end": [754, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsSup_eq_iInf_sSup", "code": "theorem HasBasis.limsSup_eq_iInf_sSup {\u03b9} {p : \u03b9 \u2192 Prop} {s} {f : Filter \u03b1} (h : f.HasBasis p s) :\n    limsSup f = \u2a05 (i) (_ : p i), sSup (s i)", "start": [757, 1], "end": [762, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsInf_eq_iSup_sInf", "code": "theorem HasBasis.limsInf_eq_iSup_sInf {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {f : Filter \u03b1}\n    (h : f.HasBasis p s) : limsInf f = \u2a06 (i) (_ : p i), sInf (s i)", "start": [766, 1], "end": [768, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.limsSup_eq_iInf_sSup", "code": "theorem limsSup_eq_iInf_sSup {f : Filter \u03b1} : limsSup f = \u2a05 s \u2208 f, sSup s", "start": [772, 1], "end": [773, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.limsInf_eq_iSup_sInf", "code": "theorem limsInf_eq_iSup_sInf {f : Filter \u03b1} : limsInf f = \u2a06 s \u2208 f, sInf s", "start": [777, 1], "end": [778, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_le_iSup", "code": "theorem limsup_le_iSup {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : limsup u f \u2264 \u2a06 n, u n", "start": [782, 1], "end": [783, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_le_liminf", "code": "theorem iInf_le_liminf {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : \u2a05 n, u n \u2264 liminf u f", "start": [786, 1], "end": [787, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_eq_iInf_iSup", "code": "theorem limsup_eq_iInf_iSup {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : limsup u f = \u2a05 s \u2208 f, \u2a06 a \u2208 s, u a", "start": [790, 1], "end": [793, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_eq_iInf_iSup_of_nat", "code": "theorem limsup_eq_iInf_iSup_of_nat {u : \u2115 \u2192 \u03b1} : limsup u atTop = \u2a05 n : \u2115, \u2a06 i \u2265 n, u i", "start": [796, 1], "end": [797, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_eq_iInf_iSup_of_nat'", "code": "theorem limsup_eq_iInf_iSup_of_nat' {u : \u2115 \u2192 \u03b1} : limsup u atTop = \u2a05 n : \u2115, \u2a06 i : \u2115, u (i + n)", "start": [800, 1], "end": [801, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsup_eq_iInf_iSup", "code": "theorem HasBasis.limsup_eq_iInf_iSup {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b2} {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (h : f.HasBasis p s) : limsup u f = \u2a05 (i) (_ : p i), \u2a06 a \u2208 s i, u a", "start": [804, 1], "end": [806, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_congr'", "code": "theorem blimsup_congr' {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}\n    (h : \u2200\u1da0 x in f, u x \u2260 \u22a5 \u2192 (p x \u2194 q x)) : blimsup u f p = blimsup u f q", "start": [809, 1], "end": [816, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_congr'", "code": "theorem bliminf_congr' {f : Filter \u03b2} {p q : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1}\n    (h : \u2200\u1da0 x in f, u x \u2260 \u22a4 \u2192 (p x \u2194 q x)) : bliminf u f p = bliminf u f q", "start": [819, 1], "end": [821, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_eq_iInf_biSup", "code": "theorem blimsup_eq_iInf_biSup {f : Filter \u03b2} {p : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1} :\n    blimsup u f p = \u2a05 s \u2208 f, \u2a06 (b) (_ : p b \u2227 b \u2208 s), u b", "start": [824, 1], "end": [838, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_eq_iInf_biSup_of_nat", "code": "theorem blimsup_eq_iInf_biSup_of_nat {p : \u2115 \u2192 Prop} {u : \u2115 \u2192 \u03b1} :\n    blimsup u atTop p = \u2a05 i, \u2a06 (j) (_ : p j \u2227 i \u2264 j), u j", "start": [841, 1], "end": [846, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_eq_iSup_iInf", "code": "theorem liminf_eq_iSup_iInf {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} : liminf u f = \u2a06 s \u2208 f, \u2a05 a \u2208 s, u a", "start": [849, 1], "end": [852, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_eq_iSup_iInf_of_nat", "code": "theorem liminf_eq_iSup_iInf_of_nat {u : \u2115 \u2192 \u03b1} : liminf u atTop = \u2a06 n : \u2115, \u2a05 i \u2265 n, u i", "start": [855, 1], "end": [856, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_eq_iSup_iInf_of_nat'", "code": "theorem liminf_eq_iSup_iInf_of_nat' {u : \u2115 \u2192 \u03b1} : liminf u atTop = \u2a06 n : \u2115, \u2a05 i : \u2115, u (i + n)", "start": [859, 1], "end": [860, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.liminf_eq_iSup_iInf", "code": "theorem HasBasis.liminf_eq_iSup_iInf {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b2} {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (h : f.HasBasis p s) : liminf u f = \u2a06 (i) (_ : p i), \u2a05 a \u2208 s i, u a", "start": [863, 1], "end": [865, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_eq_iSup_biInf", "code": "theorem bliminf_eq_iSup_biInf {f : Filter \u03b2} {p : \u03b2 \u2192 Prop} {u : \u03b2 \u2192 \u03b1} :\n    bliminf u f p = \u2a06 s \u2208 f, \u2a05 (b) (_ : p b \u2227 b \u2208 s), u b", "start": [868, 1], "end": [870, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_eq_iSup_biInf_of_nat", "code": "theorem bliminf_eq_iSup_biInf_of_nat {p : \u2115 \u2192 Prop} {u : \u2115 \u2192 \u03b1} :\n    bliminf u atTop p = \u2a06 i, \u2a05 (j) (_ : p j \u2227 i \u2264 j), u j", "start": [873, 1], "end": [875, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_eq_sInf_sSup", "code": "theorem limsup_eq_sInf_sSup {\u03b9 R : Type*} (F : Filter \u03b9) [CompleteLattice R] (a : \u03b9 \u2192 R) :\n    limsup a F = sInf ((fun I => sSup (a '' I)) '' F.sets)", "start": [878, 1], "end": [890, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_eq_sSup_sInf", "code": "theorem liminf_eq_sSup_sInf {\u03b9 R : Type*} (F : Filter \u03b9) [CompleteLattice R] (a : \u03b9 \u2192 R) :\n    liminf a F = sSup ((fun I => sInf (a '' I)) '' F.sets)", "start": [894, 1], "end": [896, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_nat_add", "code": "@[simp, nolint simpNF]\ntheorem liminf_nat_add (f : \u2115 \u2192 \u03b1) (k : \u2115) :\n    liminf (fun i => f (i + k)) atTop = liminf f atTop", "start": [901, 1], "end": [905, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_nat_add", "code": "@[simp, nolint simpNF]\ntheorem limsup_nat_add (f : \u2115 \u2192 \u03b1) (k : \u2115) : limsup (fun i => f (i + k)) atTop = limsup f atTop", "start": [909, 1], "end": [911, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_of_frequently_le'", "code": "theorem liminf_le_of_frequently_le' {\u03b1 \u03b2} [CompleteLattice \u03b2] {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} {x : \u03b2}\n    (h : \u2203\u1da0 a in f, u a \u2264 x) : liminf u f \u2264 x", "start": [914, 1], "end": [922, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.le_limsup_of_frequently_le'", "code": "theorem le_limsup_of_frequently_le' {\u03b1 \u03b2} [CompleteLattice \u03b2] {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} {x : \u03b2}\n    (h : \u2203\u1da0 a in f, x \u2264 u a) : x \u2264 limsup u f", "start": [925, 1], "end": [927, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.CompleteLatticeHom.apply_limsup_iterate", "code": "@[simp]\ntheorem CompleteLatticeHom.apply_limsup_iterate (f : CompleteLatticeHom \u03b1 \u03b1) (a : \u03b1) :\n    f (limsup (fun n => f^[n] a) atTop) = limsup (fun n => f^[n] a) atTop", "start": [930, 1], "end": [942, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.CompleteLatticeHom.apply_liminf_iterate", "code": "theorem CompleteLatticeHom.apply_liminf_iterate (f : CompleteLatticeHom \u03b1 \u03b1) (a : \u03b1) :\n    f (liminf (fun n => f^[n] a) atTop) = liminf (fun n => f^[n] a) atTop", "start": [945, 1], "end": [949, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_mono", "code": "theorem blimsup_mono (h : \u2200 x, p x \u2192 q x) : blimsup u f p \u2264 blimsup u f q", "start": [954, 1], "end": [955, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_antitone", "code": "theorem bliminf_antitone (h : \u2200 x, p x \u2192 q x) : bliminf u f q \u2264 bliminf u f p", "start": [958, 1], "end": [959, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.mono_blimsup'", "code": "theorem mono_blimsup' (h : \u2200\u1da0 x in f, p x \u2192 u x \u2264 v x) : blimsup u f p \u2264 blimsup v f p", "start": [962, 1], "end": [963, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.mono_blimsup", "code": "theorem mono_blimsup (h : \u2200 x, p x \u2192 u x \u2264 v x) : blimsup u f p \u2264 blimsup v f p", "start": [966, 1], "end": [967, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.mono_bliminf'", "code": "theorem mono_bliminf' (h : \u2200\u1da0 x in f, p x \u2192 u x \u2264 v x) : bliminf u f p \u2264 bliminf v f p", "start": [970, 1], "end": [971, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.mono_bliminf", "code": "theorem mono_bliminf (h : \u2200 x, p x \u2192 u x \u2264 v x) : bliminf u f p \u2264 bliminf v f p", "start": [974, 1], "end": [975, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_antitone_filter", "code": "theorem bliminf_antitone_filter (h : f \u2264 g) : bliminf u g p \u2264 bliminf u f p", "start": [978, 1], "end": [979, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_monotone_filter", "code": "theorem blimsup_monotone_filter (h : f \u2264 g) : blimsup u f p \u2264 blimsup u g p", "start": [982, 1], "end": [983, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_and_le_inf", "code": "theorem blimsup_and_le_inf : (blimsup u f fun x => p x \u2227 q x) \u2264 blimsup u f p \u2293 blimsup u f q", "start": [988, 1], "end": [989, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_inf_aux_left", "code": "@[simp]\ntheorem bliminf_sup_le_inf_aux_left :\n    (blimsup u f fun x => p x \u2227 q x) \u2264 blimsup u f p", "start": [992, 1], "end": [995, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_inf_aux_right", "code": "@[simp]\ntheorem bliminf_sup_le_inf_aux_right :\n    (blimsup u f fun x => p x \u2227 q x) \u2264 blimsup u f q", "start": [997, 1], "end": [1000, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_and", "code": "theorem bliminf_sup_le_and : bliminf u f p \u2294 bliminf u f q \u2264 bliminf u f fun x => p x \u2227 q x", "start": [1003, 1], "end": [1004, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_and_aux_left", "code": "@[simp]\ntheorem bliminf_sup_le_and_aux_left : bliminf u f p \u2264 bliminf u f fun x => p x \u2227 q x", "start": [1007, 1], "end": [1009, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_and_aux_right", "code": "@[simp]\ntheorem bliminf_sup_le_and_aux_right : bliminf u f q \u2264 bliminf u f fun x => p x \u2227 q x", "start": [1011, 1], "end": [1013, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_sup_le_or", "code": "theorem blimsup_sup_le_or : blimsup u f p \u2294 blimsup u f q \u2264 blimsup u f fun x => p x \u2228 q x", "start": [1015, 1], "end": [1018, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_or_aux_left", "code": "@[simp]\ntheorem bliminf_sup_le_or_aux_left : blimsup u f p \u2264 blimsup u f fun x => p x \u2228 q x", "start": [1021, 1], "end": [1023, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_sup_le_or_aux_right", "code": "@[simp]\ntheorem bliminf_sup_le_or_aux_right : blimsup u f q \u2264 blimsup u f fun x => p x \u2228 q x", "start": [1025, 1], "end": [1027, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_or_le_inf", "code": "theorem bliminf_or_le_inf : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f p \u2293 bliminf u f q", "start": [1029, 1], "end": [1032, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_or_le_inf_aux_left", "code": "@[simp]\ntheorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f p", "start": [1035, 1], "end": [1037, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_or_le_inf_aux_right", "code": "@[simp]\ntheorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f q", "start": [1039, 1], "end": [1041, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.OrderIso.apply_blimsup", "code": "theorem OrderIso.apply_blimsup [CompleteLattice \u03b3] (e : \u03b1 \u2243o \u03b3) :\n    FunLike.coe e (blimsup u f p) = blimsup ((FunLike.coe e) \u2218 u) f p", "start": [1045, 1], "end": [1051, 7], "kind": "commanddeclaration"}, {"full_name": "Filter.OrderIso.apply_bliminf", "code": "theorem OrderIso.apply_bliminf [CompleteLattice \u03b3] (e : \u03b1 \u2243o \u03b3) :\n    e (bliminf u f p) = bliminf (e \u2218 u) f p", "start": [1054, 1], "end": [1056, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.SupHom.apply_blimsup_le", "code": "theorem SupHom.apply_blimsup_le [CompleteLattice \u03b3] (g : sSupHom \u03b1 \u03b3) :\n    g (blimsup u f p) \u2264 blimsup (g \u2218 u) f p", "start": [1059, 1], "end": [1063, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.InfHom.le_apply_bliminf", "code": "theorem InfHom.le_apply_bliminf [CompleteLattice \u03b3] (g : sInfHom \u03b1 \u03b3) :\n    bliminf (g \u2218 u) f p \u2264 g (bliminf u f p)", "start": [1066, 1], "end": [1068, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.blimsup_or_eq_sup", "code": "@[simp]\ntheorem blimsup_or_eq_sup : (blimsup u f fun x => p x \u2228 q x) = blimsup u f p \u2294 blimsup u f q", "start": [1077, 1], "end": [1082, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.bliminf_or_eq_inf", "code": "@[simp]\ntheorem bliminf_or_eq_inf : (bliminf u f fun x => p x \u2228 q x) = bliminf u f p \u2293 bliminf u f q", "start": [1085, 1], "end": [1087, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_limsup", "code": "theorem sup_limsup [NeBot f] (a : \u03b1) : a \u2294 limsup u f = limsup (fun x => a \u2294 u x) f", "start": [1090, 1], "end": [1093, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_liminf", "code": "theorem inf_liminf [NeBot f] (a : \u03b1) : a \u2293 liminf u f = liminf (fun x => a \u2293 u x) f", "start": [1096, 1], "end": [1097, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_liminf", "code": "theorem sup_liminf (a : \u03b1) : a \u2294 liminf u f = liminf (fun x => a \u2294 u x) f", "start": [1100, 1], "end": [1103, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_limsup", "code": "theorem inf_limsup (a : \u03b1) : a \u2293 limsup u f = limsup (fun x => a \u2293 u x) f", "start": [1106, 1], "end": [1107, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_compl", "code": "theorem limsup_compl : (limsup u f)\u1d9c = liminf (compl \u2218 u) f", "start": [1116, 1], "end": [1117, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_compl", "code": "theorem liminf_compl : (liminf u f)\u1d9c = limsup (compl \u2218 u) f", "start": [1120, 1], "end": [1121, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_sdiff", "code": "theorem limsup_sdiff (a : \u03b1) : limsup u f \\ a = limsup (fun b => u b \\ a) f", "start": [1124, 1], "end": [1127, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_sdiff", "code": "theorem liminf_sdiff [NeBot f] (a : \u03b1) : liminf u f \\ a = liminf (fun b => u b \\ a) f", "start": [1130, 1], "end": [1131, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.sdiff_limsup", "code": "theorem sdiff_limsup [NeBot f] (a : \u03b1) : a \\ limsup u f = liminf (fun b => a \\ u b) f", "start": [1134, 1], "end": [1136, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.sdiff_liminf", "code": "theorem sdiff_liminf (a : \u03b1) : a \\ liminf u f = limsup (fun b => a \\ u b) f", "start": [1139, 1], "end": [1141, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite.blimsup_set_eq", "code": "theorem cofinite.blimsup_set_eq :\n    blimsup s cofinite p = { x | { n | p n \u2227 x \u2208 s n }.Infinite }", "start": [1150, 1], "end": [1157, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite.bliminf_set_eq", "code": "theorem cofinite.bliminf_set_eq : bliminf s cofinite p = { x | { n | p n \u2227 x \u2209 s n }.Finite }", "start": [1160, 1], "end": [1164, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite.limsup_set_eq", "code": "theorem cofinite.limsup_set_eq : limsup s cofinite = { x | { n | x \u2208 s n }.Infinite }", "start": [1167, 1], "end": [1170, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite.liminf_set_eq", "code": "theorem cofinite.liminf_set_eq : liminf s cofinite = { x | { n | x \u2209 s n }.Finite }", "start": [1173, 1], "end": [1176, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_forall_mem_of_hasBasis_mem_blimsup", "code": "theorem exists_forall_mem_of_hasBasis_mem_blimsup {l : Filter \u03b2} {b : \u03b9 \u2192 Set \u03b2} {q : \u03b9 \u2192 Prop}\n    (hl : l.HasBasis q b) {u : \u03b2 \u2192 Set \u03b1} {p : \u03b2 \u2192 Prop} {x : \u03b1} (hx : x \u2208 blimsup u l p) :\n    \u2203 f : { i | q i } \u2192 \u03b2, \u2200 i, x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i", "start": [1179, 1], "end": [1187, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_forall_mem_of_hasBasis_mem_blimsup'", "code": "theorem exists_forall_mem_of_hasBasis_mem_blimsup' {l : Filter \u03b2} {b : \u03b9 \u2192 Set \u03b2}\n    (hl : l.HasBasis (fun _ => True) b) {u : \u03b2 \u2192 Set \u03b1} {p : \u03b2 \u2192 Prop} {x : \u03b1}\n    (hx : x \u2208 blimsup u l p) : \u2203 f : \u03b9 \u2192 \u03b2, \u2200 i, x \u2208 u (f i) \u2227 p (f i) \u2227 f i \u2208 b i", "start": [1190, 1], "end": [1194, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_lt_of_lt_limsSup", "code": "theorem frequently_lt_of_lt_limsSup {f : Filter \u03b1} [ConditionallyCompleteLinearOrder \u03b1] {a : \u03b1}\n    (hf : f.IsCobounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (h : a < limsSup f) : \u2203\u1da0 n in f, a < n", "start": [1201, 1], "end": [1206, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_lt_of_limsInf_lt", "code": "theorem frequently_lt_of_limsInf_lt {f : Filter \u03b1} [ConditionallyCompleteLinearOrder \u03b1] {a : \u03b1}\n    (hf : f.IsCobounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault)\n    (h : limsInf f < a) : \u2203\u1da0 n in f, n < a", "start": [1210, 1], "end": [1213, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_lt_of_lt_liminf", "code": "theorem eventually_lt_of_lt_liminf {f : Filter \u03b1} [ConditionallyCompleteLinearOrder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    {b : \u03b2} (h : b < liminf u f)\n    (hu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) :\n    \u2200\u1da0 a in f, b < u a", "start": [1217, 1], "end": [1224, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_lt_of_limsup_lt", "code": "theorem eventually_lt_of_limsup_lt {f : Filter \u03b1} [ConditionallyCompleteLinearOrder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    {b : \u03b2} (h : limsup u f < b)\n    (hu : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault) :\n    \u2200\u1da0 a in f, u a < b", "start": [1227, 1], "end": [1231, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.le_limsup_of_frequently_le", "code": "theorem le_limsup_of_frequently_le {\u03b1 \u03b2} [ConditionallyCompleteLinearOrder \u03b2] {f : Filter \u03b1}\n    {u : \u03b1 \u2192 \u03b2} {b : \u03b2} (hu_le : \u2203\u1da0 x in f, b \u2264 u x)\n    (hu : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault) :\n    b \u2264 limsup u f", "start": [1234, 1], "end": [1241, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_le_of_frequently_le", "code": "theorem liminf_le_of_frequently_le {\u03b1 \u03b2} [ConditionallyCompleteLinearOrder \u03b2] {f : Filter \u03b1}\n    {u : \u03b1 \u2192 \u03b2} {b : \u03b2} (hu_le : \u2203\u1da0 x in f, u x \u2264 b)\n    (hu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) :\n    liminf u f \u2264 b", "start": [1244, 1], "end": [1248, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_lt_of_lt_limsup", "code": "theorem frequently_lt_of_lt_limsup {\u03b1 \u03b2} [ConditionallyCompleteLinearOrder \u03b2] {f : Filter \u03b1}\n    {u : \u03b1 \u2192 \u03b2} {b : \u03b2}\n    (hu : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h : b < limsup u f) : \u2203\u1da0 x in f, b < u x", "start": [1251, 1], "end": [1257, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_lt_of_liminf_lt", "code": "theorem frequently_lt_of_liminf_lt {\u03b1 \u03b2} [ConditionallyCompleteLinearOrder \u03b2] {f : Filter \u03b1}\n    {u : \u03b1 \u2192 \u03b2} {b : \u03b2}\n    (hu : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (h : liminf u f < b) : \u2203\u1da0 x in f, u x < b", "start": [1260, 1], "end": [1264, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.lt_mem_sets_of_limsSup_lt", "code": "theorem lt_mem_sets_of_limsSup_lt (h : f.IsBounded (\u00b7 \u2264 \u00b7)) (l : f.limsSup < b) :\n    \u2200\u1da0 a in f, a < b", "start": [1271, 1], "end": [1274, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.gt_mem_sets_of_limsInf_gt", "code": "theorem gt_mem_sets_of_limsInf_gt : f.IsBounded (\u00b7 \u2265 \u00b7) \u2192 b < f.limsInf \u2192 \u2200\u1da0 a in f, b < a", "start": [1278, 1], "end": [1279, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.liminf_reparam", "code": "noncomputable def liminf_reparam\n    (f : \u03b9 \u2192 \u03b1) (s : \u03b9' \u2192 Set \u03b9) (p : \u03b9' \u2192 Prop) [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (j : Subtype p) : Subtype p :=\n  let m : Set (Subtype p) := {j | BddBelow (range (fun (i : s j) \u21a6 f i))}\n  let g : \u2115 \u2192 Subtype p := choose (exists_surjective_nat _)\n  have Z : \u2203 n, g n \u2208 m \u2228 \u2200 j, j \u2209 m := by\n    by_cases H : \u2203 j, j \u2208 m\n    \u00b7 rcases H with \u27e8j, hj\u27e9\n      rcases choose_spec (exists_surjective_nat (Subtype p)) j with \u27e8n, rfl\u27e9\n      exact \u27e8n, Or.inl hj\u27e9\n    \u00b7 push_neg at H\n      exact \u27e80, Or.inr H\u27e9\n  if j \u2208 m then j else g (Nat.find Z)", "start": [1287, 1], "end": [1305, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.liminf_eq_ciSup_ciInf", "code": "theorem HasBasis.liminf_eq_ciSup_ciInf {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : \u03b9 \u2192 \u03b1} (hs : \u2200 (j : Subtype p), (s j).Nonempty)\n    (H : \u2203 (j : Subtype p), BddBelow (range (fun (i : s j) \u21a6 f i))) :\n    liminf f v = \u2a06 (j : Subtype p), \u2a05 (i : s (liminf_reparam f s p j)), f i", "start": [1307, 1], "end": [1344, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.liminf_eq_ite", "code": "theorem HasBasis.liminf_eq_ite {v : Filter \u03b9} {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : \u03b9 \u2192 \u03b1):\n    liminf f v = if \u2203 (j : Subtype p), s j = \u2205 then sSup univ else\n      if \u2200 (j : Subtype p), \u00acBddBelow (range (fun (i : s j) \u21a6 f i)) then sSup \u2205\n      else \u2a06 (j : Subtype p), \u2a05 (i : s (liminf_reparam f s p j)), f i", "start": [1346, 1], "end": [1369, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.limsup_reparam", "code": "noncomputable def limsup_reparam\n    (f : \u03b9 \u2192 \u03b1) (s : \u03b9' \u2192 Set \u03b9) (p : \u03b9' \u2192 Prop) [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (j : Subtype p) : Subtype p :=\n  liminf_reparam (\u03b1 := \u03b1\u1d52\u1d48) f s p j", "start": [1371, 1], "end": [1379, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsup_eq_ciInf_ciSup", "code": "theorem HasBasis.limsup_eq_ciInf_ciSup {v : Filter \u03b9}\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : \u03b9 \u2192 \u03b1} (hs : \u2200 (j : Subtype p), (s j).Nonempty)\n    (H : \u2203 (j : Subtype p), BddAbove (range (fun (i : s j) \u21a6 f i))) :\n    limsup f v = \u2a05 (j : Subtype p), \u2a06 (i : s (limsup_reparam f s p j)), f i", "start": [1381, 1], "end": [1389, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.limsup_eq_ite", "code": "theorem HasBasis.limsup_eq_ite {v : Filter \u03b9} {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b9}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : \u03b9 \u2192 \u03b1) :\n    limsup f v = if \u2203 (j : Subtype p), s j = \u2205 then sInf univ else\n      if \u2200 (j : Subtype p), \u00acBddAbove (range (fun (i : s j) \u21a6 f i)) then sInf \u2205\n      else \u2a05 (j : Subtype p), \u2a06 (i : s (limsup_reparam f s p j)), f i", "start": [1391, 1], "end": [1399, 41], "kind": "commanddeclaration"}, {"full_name": "Monotone.isBoundedUnder_le_comp_iff", "code": "theorem Monotone.isBoundedUnder_le_comp_iff [Nonempty \u03b2] [LinearOrder \u03b2] [Preorder \u03b3] [NoMaxOrder \u03b3]\n    {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (hg : Monotone g) (hg' : Tendsto g atTop atTop) :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l (g \u2218 f) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l f", "start": [1411, 1], "end": [1417, 73], "kind": "commanddeclaration"}, {"full_name": "Monotone.isBoundedUnder_ge_comp_iff", "code": "theorem Monotone.isBoundedUnder_ge_comp_iff [Nonempty \u03b2] [LinearOrder \u03b2] [Preorder \u03b3] [NoMinOrder \u03b3]\n    {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (hg : Monotone g) (hg' : Tendsto g atBot atBot) :\n    IsBoundedUnder (\u00b7 \u2265 \u00b7) l (g \u2218 f) \u2194 IsBoundedUnder (\u00b7 \u2265 \u00b7) l f", "start": [1420, 1], "end": [1423, 41], "kind": "commanddeclaration"}, {"full_name": "Antitone.isBoundedUnder_le_comp_iff", "code": "theorem Antitone.isBoundedUnder_le_comp_iff [Nonempty \u03b2] [LinearOrder \u03b2] [Preorder \u03b3] [NoMaxOrder \u03b3]\n    {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (hg : Antitone g) (hg' : Tendsto g atBot atTop) :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l (g \u2218 f) \u2194 IsBoundedUnder (\u00b7 \u2265 \u00b7) l f", "start": [1426, 1], "end": [1429, 47], "kind": "commanddeclaration"}, {"full_name": "Antitone.isBoundedUnder_ge_comp_iff", "code": "theorem Antitone.isBoundedUnder_ge_comp_iff [Nonempty \u03b2] [LinearOrder \u03b2] [Preorder \u03b3] [NoMinOrder \u03b3]\n    {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (hg : Antitone g) (hg' : Tendsto g atTop atBot) :\n    IsBoundedUnder (\u00b7 \u2265 \u00b7) l (g \u2218 f) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l f", "start": [1432, 1], "end": [1435, 47], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_limsup_le", "code": "theorem GaloisConnection.l_limsup_le [ConditionallyCompleteLattice \u03b2]\n    [ConditionallyCompleteLattice \u03b3] {f : Filter \u03b1} {v : \u03b1 \u2192 \u03b2} {l : \u03b2 \u2192 \u03b3} {u : \u03b3 \u2192 \u03b2}\n    (gc : GaloisConnection l u)\n    (hlv : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) fun x => l (v x) := by isBoundedDefault)\n    (hv_co : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) v := by isBoundedDefault) :\n    l (limsup v f) \u2264 limsup (fun x => l (v x)) f", "start": [1438, 1], "end": [1447, 34], "kind": "commanddeclaration"}, {"full_name": "OrderIso.limsup_apply", "code": "theorem OrderIso.limsup_apply {\u03b3} [ConditionallyCompleteLattice \u03b2] [ConditionallyCompleteLattice \u03b3]\n    {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} (g : \u03b2 \u2243o \u03b3)\n    (hu : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) fun x => g (u x) := by isBoundedDefault) :\n    g (limsup u f) = limsup (fun x => g (u x)) f", "start": [1450, 1], "end": [1465, 11], "kind": "commanddeclaration"}, {"full_name": "OrderIso.liminf_apply", "code": "theorem OrderIso.liminf_apply {\u03b3} [ConditionallyCompleteLattice \u03b2] [ConditionallyCompleteLattice \u03b3]\n    {f : Filter \u03b1} {u : \u03b1 \u2192 \u03b2} (g : \u03b2 \u2243o \u03b3)\n    (hu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) fun x => g (u x) := by isBoundedDefault) :\n    g (liminf u f) = liminf (fun x => g (u x)) f", "start": [1468, 1], "end": [1475, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/CountableInter.lean", "imports": ["Mathlib/Data/Set/Countable.lean", "Mathlib/Order/Filter/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CountableInterFilter", "code": "class CountableInterFilter (l : Filter \u03b1) : Prop where\n  \n  countable_sInter_mem : \u2200 S : Set (Set \u03b1), S.Countable \u2192 (\u2200 s \u2208 S, s \u2208 l) \u2192 \u22c2\u2080 S \u2208 l", "start": [36, 1], "end": [40, 86], "kind": "commanddeclaration"}, {"full_name": "countable_sInter_mem", "code": "theorem countable_sInter_mem {S : Set (Set \u03b1)} (hSc : S.Countable) : \u22c2\u2080 S \u2208 l \u2194 \u2200 s \u2208 S, s \u2208 l", "start": [45, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "countable_iInter_mem", "code": "theorem countable_iInter_mem [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} : (\u22c2 i, s i) \u2208 l \u2194 \u2200 i, s i \u2208 l", "start": [50, 1], "end": [51, 85], "kind": "commanddeclaration"}, {"full_name": "countable_bInter_mem", "code": "theorem countable_bInter_mem {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable) {s : \u2200 i \u2208 S, Set \u03b1} :\n    (\u22c2 i, \u22c2 hi : i \u2208 S, s i \u2039_\u203a) \u2208 l \u2194 \u2200 i, \u2200 hi : i \u2208 S, s i \u2039_\u203a \u2208 l", "start": [54, 1], "end": [58, 50], "kind": "commanddeclaration"}, {"full_name": "eventually_countable_forall", "code": "theorem eventually_countable_forall [Countable \u03b9] {p : \u03b1 \u2192 \u03b9 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i, p x i) \u2194 \u2200 i, \u2200\u1da0 x in l, p x i", "start": [61, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "eventually_countable_ball", "code": "theorem eventually_countable_ball {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {p : \u03b1 \u2192 \u2200 i \u2208 S, Prop} :\n    (\u2200\u1da0 x in l, \u2200 i hi, p x i hi) \u2194 \u2200 i hi, \u2200\u1da0 x in l, p x i hi", "start": [67, 1], "end": [71, 68], "kind": "commanddeclaration"}, {"full_name": "EventuallyLE.countable_iUnion", "code": "theorem EventuallyLE.countable_iUnion [Countable \u03b9] {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2264\u1da0[l] t i) :\n    \u22c3 i, s i \u2264\u1da0[l] \u22c3 i, t i", "start": [74, 1], "end": [76, 99], "kind": "commanddeclaration"}, {"full_name": "EventuallyEq.countable_iUnion", "code": "theorem EventuallyEq.countable_iUnion [Countable \u03b9] {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i =\u1da0[l] t i) :\n    \u22c3 i, s i =\u1da0[l] \u22c3 i, t i", "start": [79, 1], "end": [82, 59], "kind": "commanddeclaration"}, {"full_name": "EventuallyLE.countable_bUnion", "code": "theorem EventuallyLE.countable_bUnion {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c3 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c3 i \u2208 S, t i \u2039_\u203a", "start": [85, 1], "end": [90, 55], "kind": "commanddeclaration"}, {"full_name": "EventuallyEq.countable_bUnion", "code": "theorem EventuallyEq.countable_bUnion {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi =\u1da0[l] t i hi) :\n    \u22c3 i \u2208 S, s i \u2039_\u203a =\u1da0[l] \u22c3 i \u2208 S, t i \u2039_\u203a", "start": [93, 1], "end": [97, 68], "kind": "commanddeclaration"}, {"full_name": "EventuallyLE.countable_iInter", "code": "theorem EventuallyLE.countable_iInter [Countable \u03b9] {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2264\u1da0[l] t i) :\n    \u22c2 i, s i \u2264\u1da0[l] \u22c2 i, t i", "start": [100, 1], "end": [103, 52], "kind": "commanddeclaration"}, {"full_name": "EventuallyEq.countable_iInter", "code": "theorem EventuallyEq.countable_iInter [Countable \u03b9] {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i =\u1da0[l] t i) :\n    \u22c2 i, s i =\u1da0[l] \u22c2 i, t i", "start": [106, 1], "end": [109, 59], "kind": "commanddeclaration"}, {"full_name": "EventuallyLE.countable_bInter", "code": "theorem EventuallyLE.countable_bInter {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi \u2264\u1da0[l] t i hi) :\n    \u22c2 i \u2208 S, s i \u2039_\u203a \u2264\u1da0[l] \u22c2 i \u2208 S, t i \u2039_\u203a", "start": [112, 1], "end": [117, 55], "kind": "commanddeclaration"}, {"full_name": "EventuallyEq.countable_bInter", "code": "theorem EventuallyEq.countable_bInter {\u03b9 : Type*} {S : Set \u03b9} (hS : S.Countable)\n    {s t : \u2200 i \u2208 S, Set \u03b1} (h : \u2200 i hi, s i hi =\u1da0[l] t i hi) :\n    \u22c2 i \u2208 S, s i \u2039_\u203a =\u1da0[l] \u22c2 i \u2208 S, t i \u2039_\u203a", "start": [120, 1], "end": [124, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.ofCountableInter", "code": "def Filter.ofCountableInter (l : Set (Set \u03b1))\n    (hp : \u2200 S : Set (Set \u03b1), S.Countable \u2192 S \u2286 l \u2192 \u22c2\u2080 S \u2208 l)\n    (h_mono : \u2200 s t, s \u2208 l \u2192 s \u2286 t \u2192 t \u2208 l) : Filter \u03b1 where\n  sets := l\n  univ_sets := @sInter_empty \u03b1 \u25b8 hp _ countable_empty (empty_subset _)\n  sets_of_superset := h_mono _ _\n  inter_sets {s t} hs ht := sInter_pair s t \u25b8\n    hp _ ((countable_singleton _).insert _) (insert_subset_iff.2 \u27e8hs, singleton_subset_iff.2 ht\u27e9)", "start": [127, 1], "end": [136, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.countableInter_ofCountableInter", "code": "instance Filter.countableInter_ofCountableInter (l : Set (Set \u03b1))\n    (hp : \u2200 S : Set (Set \u03b1), S.Countable \u2192 S \u2286 l \u2192 \u22c2\u2080 S \u2208 l)\n    (h_mono : \u2200 s t, s \u2208 l \u2192 s \u2286 t \u2192 t \u2208 l) :\n    CountableInterFilter (Filter.ofCountableInter l hp h_mono) :=\n  \u27e8hp\u27e9", "start": [139, 1], "end": [143, 7], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_ofCountableInter", "code": "@[simp]\ntheorem Filter.mem_ofCountableInter {l : Set (Set \u03b1)}\n    (hp : \u2200 S : Set (Set \u03b1), S.Countable \u2192 S \u2286 l \u2192 \u22c2\u2080 S \u2208 l) (h_mono : \u2200 s t, s \u2208 l \u2192 s \u2286 t \u2192 t \u2208 l)\n    {s : Set \u03b1} : s \u2208 Filter.ofCountableInter l hp h_mono \u2194 s \u2208 l", "start": [146, 1], "end": [150, 10], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_principal", "code": "instance countableInterFilter_principal (s : Set \u03b1) : CountableInterFilter (\ud835\udcdf s) :=\n  \u27e8fun _ _ hS => subset_sInter hS\u27e9", "start": [153, 1], "end": [154, 35], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_bot", "code": "instance countableInterFilter_bot : CountableInterFilter (\u22a5 : Filter \u03b1) := by\n  rw [\u2190 principal_empty]\n  apply countableInterFilter_principal", "start": [157, 1], "end": [159, 39], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_top", "code": "instance countableInterFilter_top : CountableInterFilter (\u22a4 : Filter \u03b1) := by\n  rw [\u2190 principal_univ]\n  apply countableInterFilter_principal", "start": [162, 1], "end": [164, 39], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_inf", "code": "instance countableInterFilter_inf (l\u2081 l\u2082 : Filter \u03b1) [CountableInterFilter l\u2081]\n    [CountableInterFilter l\u2082] : CountableInterFilter (l\u2081 \u2293 l\u2082) := by\n  refine' \u27e8fun S hSc hS => _\u27e9\n  choose s hs t ht hst using hS\n  replace hs : (\u22c2 i \u2208 S, s i \u2039_\u203a) \u2208 l\u2081 := (countable_bInter_mem hSc).2 hs\n  replace ht : (\u22c2 i \u2208 S, t i \u2039_\u203a) \u2208 l\u2082 := (countable_bInter_mem hSc).2 ht\n  refine' mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => _)\n  rw [hst i hi]\n  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)", "start": [180, 1], "end": [190, 83], "kind": "commanddeclaration"}, {"full_name": "countableInterFilter_sup", "code": "instance countableInterFilter_sup (l\u2081 l\u2082 : Filter \u03b1) [CountableInterFilter l\u2081]\n    [CountableInterFilter l\u2082] : CountableInterFilter (l\u2081 \u2294 l\u2082) := by\n  refine' \u27e8fun S hSc hS => \u27e8_, _\u27e9\u27e9 <;> refine' (countable_sInter_mem hSc).2 fun s hs => _\n  exacts [(hS s hs).1, (hS s hs).2]", "start": [193, 1], "end": [197, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.CountableGenerateSets", "code": "inductive CountableGenerateSets : Set \u03b1 \u2192 Prop\n  | basic {s : Set \u03b1} : s \u2208 g \u2192 CountableGenerateSets s\n  | univ : CountableGenerateSets univ\n  | superset {s t : Set \u03b1} : CountableGenerateSets s \u2192 s \u2286 t \u2192 CountableGenerateSets t\n  | sInter {S : Set (Set \u03b1)} :\n    S.Countable \u2192 (\u2200 s \u2208 S, CountableGenerateSets s) \u2192 CountableGenerateSets (\u22c2\u2080 S)", "start": [204, 1], "end": [211, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.countableGenerate", "code": "def countableGenerate : Filter \u03b1 :=\n  ofCountableInter (CountableGenerateSets g) (fun _ => CountableGenerateSets.sInter) fun _ _ =>\n    CountableGenerateSets.superset", "start": [214, 1], "end": [217, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_countableGenerate_iff", "code": "theorem mem_countableGenerate_iff {s : Set \u03b1} :\n    s \u2208 countableGenerate g \u2194 \u2203 S : Set (Set \u03b1), S \u2286 g \u2227 S.Countable \u2227 \u22c2\u2080 S \u2286 s", "start": [227, 1], "end": [245, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.le_countableGenerate_iff_of_countableInterFilter", "code": "theorem le_countableGenerate_iff_of_countableInterFilter {f : Filter \u03b1} [CountableInterFilter f] :\n    f \u2264 countableGenerate g \u2194 g \u2286 f.sets", "start": [248, 1], "end": [257, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.countableGenerate_isGreatest", "code": "theorem countableGenerate_isGreatest :\n    IsGreatest { f : Filter \u03b1 | CountableInterFilter f \u2227 g \u2286 f.sets } (countableGenerate g)", "start": [262, 1], "end": [267, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "imports": ["Mathlib/Topology/Algebra/Order/Field.lean", "Mathlib/Topology/Algebra/Order/MonotoneConvergence.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Archimedean.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean"], "premises": [{"full_name": "tsum_le_of_sum_range_le", "code": "theorem tsum_le_of_sum_range_le (hf : Summable f) (h : \u2200 n, \u2211 i in range n, f i \u2264 c) :\n    \u2211' n, f n \u2264 c", "start": [30, 1], "end": [33, 56], "kind": "commanddeclaration"}, {"full_name": "hasSum_le", "code": "theorem hasSum_le (h : \u2200 i, f i \u2264 g i) (hf : HasSum f a\u2081) (hg : HasSum g a\u2082) : a\u2081 \u2264 a\u2082", "start": [43, 1], "end": [44, 69], "kind": "commanddeclaration"}, {"full_name": "hasSum_mono", "code": "@[mono]\ntheorem hasSum_mono (hf : HasSum f a\u2081) (hg : HasSum g a\u2082) (h : f \u2264 g) : a\u2081 \u2264 a\u2082", "start": [47, 1], "end": [49, 20], "kind": "commanddeclaration"}, {"full_name": "hasSum_le_of_sum_le", "code": "theorem hasSum_le_of_sum_le (hf : HasSum f a) (h : \u2200 s, \u2211 i in s, f i \u2264 a\u2082) : a \u2264 a\u2082", "start": [52, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "le_hasSum_of_le_sum", "code": "theorem le_hasSum_of_le_sum (hf : HasSum f a) (h : \u2200 s, a\u2082 \u2264 \u2211 i in s, f i) : a\u2082 \u2264 a", "start": [56, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "hasSum_le_inj", "code": "theorem hasSum_le_inj {g : \u03ba \u2192 \u03b1} (e : \u03b9 \u2192 \u03ba) (he : Injective e)\n    (hs : \u2200 c, c \u2209 Set.range e \u2192 0 \u2264 g c) (h : \u2200 i, f i \u2264 g (e i)) (hf : HasSum f a\u2081)\n    (hg : HasSum g a\u2082) : a\u2081 \u2264 a\u2082", "start": [60, 1], "end": [69, 17], "kind": "commanddeclaration"}, {"full_name": "tsum_le_tsum_of_inj", "code": "theorem tsum_le_tsum_of_inj {g : \u03ba \u2192 \u03b1} (e : \u03b9 \u2192 \u03ba) (he : Injective e)\n    (hs : \u2200 c, c \u2209 Set.range e \u2192 0 \u2264 g c) (h : \u2200 i, f i \u2264 g (e i)) (hf : Summable f)\n    (hg : Summable g) : tsum f \u2264 tsum g", "start": [72, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "sum_le_hasSum", "code": "theorem sum_le_hasSum (s : Finset \u03b9) (hs : \u2200 i, i \u2209 s \u2192 0 \u2264 f i) (hf : HasSum f a) :\n    \u2211 i in s, f i \u2264 a", "start": [78, 1], "end": [81, 83], "kind": "commanddeclaration"}, {"full_name": "isLUB_hasSum", "code": "theorem isLUB_hasSum (h : \u2200 i, 0 \u2264 f i) (hf : HasSum f a) :\n    IsLUB (Set.range fun s => \u2211 i in s, f i) a", "start": [84, 1], "end": [86, 62], "kind": "commanddeclaration"}, {"full_name": "le_hasSum", "code": "theorem le_hasSum (hf : HasSum f a) (i : \u03b9) (hb : \u2200 j, j \u2260 i \u2192 0 \u2264 f j) : f i \u2264 a", "start": [89, 1], "end": [92, 43], "kind": "commanddeclaration"}, {"full_name": "sum_le_tsum", "code": "theorem sum_le_tsum {f : \u03b9 \u2192 \u03b1} (s : Finset \u03b9) (hs : \u2200 i, i \u2209 s \u2192 0 \u2264 f i) (hf : Summable f) :\n    \u2211 i in s, f i \u2264 \u2211' i, f i", "start": [95, 1], "end": [97, 31], "kind": "commanddeclaration"}, {"full_name": "le_tsum", "code": "theorem le_tsum (hf : Summable f) (i : \u03b9) (hb : \u2200 j, j \u2260 i \u2192 0 \u2264 f j) : f i \u2264 \u2211' i, f i", "start": [100, 1], "end": [101, 27], "kind": "commanddeclaration"}, {"full_name": "tsum_le_tsum", "code": "theorem tsum_le_tsum (h : \u2200 i, f i \u2264 g i) (hf : Summable f) (hg : Summable g) :\n    \u2211' i, f i \u2264 \u2211' i, g i", "start": [104, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "tsum_mono", "code": "@[mono]\ntheorem tsum_mono (hf : Summable f) (hg : Summable g) (h : f \u2264 g) : \u2211' n, f n \u2264 \u2211' n, g n", "start": [109, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "tsum_le_of_sum_le", "code": "theorem tsum_le_of_sum_le (hf : Summable f) (h : \u2200 s, \u2211 i in s, f i \u2264 a\u2082) : \u2211' i, f i \u2264 a\u2082", "start": [114, 1], "end": [115, 34], "kind": "commanddeclaration"}, {"full_name": "tsum_le_of_sum_le'", "code": "theorem tsum_le_of_sum_le' (ha\u2082 : 0 \u2264 a\u2082) (h : \u2200 s, \u2211 i in s, f i \u2264 a\u2082) : \u2211' i, f i \u2264 a\u2082", "start": [118, 1], "end": [122, 14], "kind": "commanddeclaration"}, {"full_name": "HasSum.nonneg", "code": "theorem HasSum.nonneg (h : \u2200 i, 0 \u2264 g i) (ha : HasSum g a) : 0 \u2264 a", "start": [125, 1], "end": [126, 29], "kind": "commanddeclaration"}, {"full_name": "HasSum.nonpos", "code": "theorem HasSum.nonpos (h : \u2200 i, g i \u2264 0) (ha : HasSum g a) : a \u2264 0", "start": [129, 1], "end": [130, 29], "kind": "commanddeclaration"}, {"full_name": "tsum_nonneg", "code": "theorem tsum_nonneg (h : \u2200 i, 0 \u2264 g i) : 0 \u2264 \u2211' i, g i", "start": [133, 1], "end": [136, 41], "kind": "commanddeclaration"}, {"full_name": "tsum_nonpos", "code": "theorem tsum_nonpos (h : \u2200 i, f i \u2264 0) : \u2211' i, f i \u2264 0", "start": [139, 1], "end": [142, 41], "kind": "commanddeclaration"}, {"full_name": "hasSum_zero_iff_of_nonneg", "code": "theorem hasSum_zero_iff_of_nonneg (hf : \u2200 i, 0 \u2264 f i) : HasSum f 0 \u2194 f = 0", "start": [146, 1], "end": [151, 22], "kind": "commanddeclaration"}, {"full_name": "hasSum_lt", "code": "theorem hasSum_lt (h : f \u2264 g) (hi : f i < g i) (hf : HasSum f a\u2081) (hg : HasSum g a\u2082) : a\u2081 < a\u2082", "start": [161, 1], "end": [164, 82], "kind": "commanddeclaration"}, {"full_name": "hasSum_strict_mono", "code": "@[mono]\ntheorem hasSum_strict_mono (hf : HasSum f a\u2081) (hg : HasSum g a\u2082) (h : f < g) : a\u2081 < a\u2082", "start": [167, 1], "end": [170, 25], "kind": "commanddeclaration"}, {"full_name": "tsum_lt_tsum", "code": "theorem tsum_lt_tsum (h : f \u2264 g) (hi : f i < g i) (hf : Summable f) (hg : Summable g) :\n    \u2211' n, f n < \u2211' n, g n", "start": [173, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "tsum_strict_mono", "code": "@[mono]\ntheorem tsum_strict_mono (hf : Summable f) (hg : Summable g) (h : f < g) :\n    \u2211' n, f n < \u2211' n, g n", "start": [178, 1], "end": [182, 28], "kind": "commanddeclaration"}, {"full_name": "tsum_pos", "code": "theorem tsum_pos (hsum : Summable g) (hg : \u2200 i, 0 \u2264 g i) (i : \u03b9) (hi : 0 < g i) :\n    0 < \u2211' i, g i", "start": [185, 1], "end": [188, 46], "kind": "commanddeclaration"}, {"full_name": "le_hasSum'", "code": "theorem le_hasSum' (hf : HasSum f a) (i : \u03b9) : f i \u2264 a", "start": [198, 1], "end": [199, 38], "kind": "commanddeclaration"}, {"full_name": "le_tsum'", "code": "theorem le_tsum' (hf : Summable f) (i : \u03b9) : f i \u2264 \u2211' i, f i", "start": [202, 1], "end": [203, 36], "kind": "commanddeclaration"}, {"full_name": "hasSum_zero_iff", "code": "theorem hasSum_zero_iff : HasSum f 0 \u2194 \u2200 x, f x = 0", "start": [206, 1], "end": [207, 66], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_zero_iff", "code": "theorem tsum_eq_zero_iff (hf : Summable f) : \u2211' i, f i = 0 \u2194 \u2200 x, f x = 0", "start": [210, 1], "end": [211, 40], "kind": "commanddeclaration"}, {"full_name": "tsum_ne_zero_iff", "code": "theorem tsum_ne_zero_iff (hf : Summable f) : \u2211' i, f i \u2260 0 \u2194 \u2203 x, f x \u2260 0", "start": [214, 1], "end": [215, 47], "kind": "commanddeclaration"}, {"full_name": "isLUB_hasSum'", "code": "theorem isLUB_hasSum' (hf : HasSum f a) : IsLUB (Set.range fun s => \u2211 i in s, f i) a", "start": [218, 1], "end": [219, 52], "kind": "commanddeclaration"}, {"full_name": "hasSum_of_isLUB_of_nonneg", "code": "theorem hasSum_of_isLUB_of_nonneg [LinearOrderedAddCommMonoid \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (i : \u03b1) (h : \u2200 i, 0 \u2264 f i)\n    (hf : IsLUB (Set.range fun s => \u2211 i in s, f i) i) : HasSum f i", "start": [235, 1], "end": [238, 59], "kind": "commanddeclaration"}, {"full_name": "hasSum_of_isLUB", "code": "theorem hasSum_of_isLUB [CanonicallyLinearOrderedAddCommMonoid \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (b : \u03b1) (hf : IsLUB (Set.range fun s => \u2211 i in s, f i) b) :\n    HasSum f b", "start": [241, 1], "end": [244, 49], "kind": "commanddeclaration"}, {"full_name": "summable_abs_iff", "code": "theorem summable_abs_iff [LinearOrderedAddCommGroup \u03b1] [UniformSpace \u03b1] [UniformAddGroup \u03b1]\n    [CompleteSpace \u03b1] {f : \u03b9 \u2192 \u03b1} : (Summable fun x => |f x|) \u2194 Summable f", "start": [247, 1], "end": [256, 80], "kind": "commanddeclaration"}, {"full_name": "Summable.of_abs", "code": "alias \u27e8Summable.of_abs, Summable.abs\u27e9 := summable_abs_iff", "start": [259, 1], "end": [259, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Summable.abs", "code": "alias \u27e8Summable.of_abs, Summable.abs\u27e9 := summable_abs_iff", "start": [259, 1], "end": [259, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finite.of_summable_const", "code": "theorem Finite.of_summable_const [LinearOrderedAddCommGroup \u03b1] [TopologicalSpace \u03b1] [Archimedean \u03b1]\n    [OrderClosedTopology \u03b1] {b : \u03b1} (hb : 0 < b) (hf : Summable fun _ : \u03b9 => b) :\n    Finite \u03b9", "start": [263, 1], "end": [272, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_summable_const", "code": "theorem Set.Finite.of_summable_const [LinearOrderedAddCommGroup \u03b1] [TopologicalSpace \u03b1]\n    [Archimedean \u03b1] [OrderClosedTopology \u03b1] {b : \u03b1} (hb : 0 < b) (hf : Summable fun _ : \u03b9 => b) :\n    (Set.univ : Set \u03b9).Finite", "start": [274, 1], "end": [277, 48], "kind": "commanddeclaration"}, {"full_name": "Summable.tendsto_atTop_of_pos", "code": "theorem Summable.tendsto_atTop_of_pos [LinearOrderedField \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]\n    {f : \u2115 \u2192 \u03b1} (hf : Summable f\u207b\u00b9) (hf' : \u2200 n, 0 < f n) : Tendsto f atTop atTop", "start": [282, 1], "end": [286, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Real.lean", "imports": ["Mathlib/Algebra/Order/Group/Bounds.lean", "Mathlib/Topology/Algebra/Order/Field.lean", "Mathlib/Topology/Algebra/Star.lean", "Mathlib/Topology/Algebra/Order/Archimedean.lean", "Mathlib/Topology/Instances/Int.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/UniformMulAction.lean", "Mathlib/Algebra/Periodic.lean", "Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/GroupTheory/Archimedean.lean"], "premises": [{"full_name": "Real.uniformContinuous_add", "code": "theorem Real.uniformContinuous_add : UniformContinuous fun p : \u211d \u00d7 \u211d => p.1 + p.2", "start": [37, 1], "end": [42, 16], "kind": "commanddeclaration"}, {"full_name": "Real.uniformContinuous_neg", "code": "theorem Real.uniformContinuous_neg : UniformContinuous (@Neg.neg \u211d _)", "start": [45, 1], "end": [47, 93], "kind": "commanddeclaration"}, {"full_name": "Real.isTopologicalBasis_Ioo_rat", "code": "theorem Real.isTopologicalBasis_Ioo_rat :\n    @IsTopologicalBasis \u211d _ (\u22c3 (a : \u211a) (b : \u211a) (_ : a < b), {Ioo (a : \u211d) b})", "start": [67, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "Real.cobounded_eq", "code": "@[simp]\ntheorem Real.cobounded_eq : cobounded \u211d = atBot \u2294 atTop", "start": [80, 1], "end": [82, 88], "kind": "commanddeclaration"}, {"full_name": "Real.cocompact_eq", "code": "@[simp]\ntheorem Real.cocompact_eq : cocompact \u211d = atBot \u2294 atTop", "start": [84, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "Real.mem_closure_iff", "code": "theorem Real.mem_closure_iff {s : Set \u211d} {x : \u211d} : x \u2208 closure s \u2194 \u2200 \u03b5 > 0, \u2203 y \u2208 s, |y - x| < \u03b5", "start": [95, 1], "end": [96, 69], "kind": "commanddeclaration"}, {"full_name": "Real.uniformContinuous_inv", "code": "theorem Real.uniformContinuous_inv (s : Set \u211d) {r : \u211d} (r0 : 0 < r) (H : \u2200 x \u2208 s, r \u2264 |x|) :\n    UniformContinuous fun p : s => p.1\u207b\u00b9", "start": [99, 1], "end": [103, 53], "kind": "commanddeclaration"}, {"full_name": "Real.uniformContinuous_abs", "code": "theorem Real.uniformContinuous_abs : UniformContinuous (abs : \u211d \u2192 \u211d)", "start": [106, 1], "end": [108, 61], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_inv", "code": "@[deprecated continuousAt_inv\u2080]\ntheorem Real.tendsto_inv {r : \u211d} (r0 : r \u2260 0) : Tendsto (fun q => q\u207b\u00b9) (\ud835\udcdd r) (\ud835\udcdd r\u207b\u00b9)", "start": [111, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_inv", "code": "theorem Real.continuous_inv : Continuous fun a : { r : \u211d // r \u2260 0 } => a.val\u207b\u00b9", "start": [116, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Real.Continuous.inv", "code": "@[deprecated Continuous.inv\u2080]\ntheorem Real.Continuous.inv [TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} (h : \u2200 a, f a \u2260 0)\n    (hf : Continuous f) : Continuous fun a => (f a)\u207b\u00b9", "start": [120, 1], "end": [123, 12], "kind": "commanddeclaration"}, {"full_name": "Real.uniformContinuous_const_mul", "code": "theorem Real.uniformContinuous_const_mul {x : \u211d} : UniformContinuous ((\u00b7 * \u00b7) x)", "start": [126, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "Real.uniformContinuous_mul", "code": "theorem Real.uniformContinuous_mul (s : Set (\u211d \u00d7 \u211d)) {r\u2081 r\u2082 : \u211d}\n    (H : \u2200 x \u2208 s, |(x : \u211d \u00d7 \u211d).1| < r\u2081 \u2227 |x.2| < r\u2082) :\n    UniformContinuous fun p : s => p.1.1 * p.1.2", "start": [130, 1], "end": [137, 40], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_mul", "code": "@[deprecated continuous_mul]\nprotected theorem Real.continuous_mul : Continuous fun p : \u211d \u00d7 \u211d => p.1 * p.2", "start": [140, 1], "end": [141, 96], "kind": "commanddeclaration"}, {"full_name": "Real.totallyBounded_ball", "code": "theorem Real.totallyBounded_ball (x \u03b5 : \u211d) : TotallyBounded (ball x \u03b5)", "start": [156, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "closure_of_rat_image_lt", "code": "theorem closure_of_rat_image_lt {q : \u211a} :\n    closure (((\u2191) : \u211a \u2192 \u211d) '' { x | q < x }) = { r | \u2191q \u2264 r }", "start": [162, 1], "end": [171, 73], "kind": "commanddeclaration"}, {"full_name": "Real.isBounded_iff_bddBelow_bddAbove", "code": "theorem Real.isBounded_iff_bddBelow_bddAbove {s : Set \u211d} : IsBounded s \u2194 BddBelow s \u2227 BddAbove s", "start": [182, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "Real.subset_Icc_sInf_sSup_of_isBounded", "code": "theorem Real.subset_Icc_sInf_sSup_of_isBounded {s : Set \u211d} (h : IsBounded s) :\n    s \u2286 Icc (sInf s) (sSup s)", "start": [190, 1], "end": [193, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.compact_of_continuous", "code": "theorem Periodic.compact_of_continuous [TopologicalSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d} (hp : Periodic f c)\n    (hc : c \u2260 0) (hf : Continuous f) : IsCompact (range f)", "start": [202, 1], "end": [206, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.compact_of_continuous'", "code": "@[deprecated Function.Periodic.compact_of_continuous]\ntheorem Periodic.compact_of_continuous' [TopologicalSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d} (hp : Periodic f c)\n    (hc : 0 < c) (hf : Continuous f) : IsCompact (range f)", "start": [209, 1], "end": [212, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.isBounded_of_continuous", "code": "theorem Periodic.isBounded_of_continuous [PseudoMetricSpace \u03b1] {f : \u211d \u2192 \u03b1} {c : \u211d}\n    (hp : Periodic f c) (hc : c \u2260 0) (hf : Continuous f) : IsBounded (range f)", "start": [215, 1], "end": [218, 45], "kind": "commanddeclaration"}, {"full_name": "Int.tendsto_coe_cofinite", "code": "theorem tendsto_coe_cofinite : Tendsto ((\u2191) : \u2124 \u2192 \u211d) cofinite (cocompact \u211d)", "start": [243, 1], "end": [247, 17], "kind": "commanddeclaration"}, {"full_name": "Int.tendsto_zmultiplesHom_cofinite", "code": "theorem tendsto_zmultiplesHom_cofinite {a : \u211d} (ha : a \u2260 0) :\n    Tendsto (zmultiplesHom \u211d a) cofinite (cocompact \u211d)", "start": [250, 1], "end": [256, 17], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.tendsto_zmultiples_subtype_cofinite", "code": "theorem tendsto_zmultiples_subtype_cofinite (a : \u211d) :\n    Tendsto (zmultiples a).subtype cofinite (cocompact \u211d)", "start": [263, 1], "end": [267, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "imports": ["Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasSum.mul_left", "code": "theorem HasSum.mul_left (a\u2082) (h : HasSum f a\u2081) : HasSum (fun i => a\u2082 * f i) (a\u2082 * a\u2081)", "start": [34, 1], "end": [35, 88], "kind": "commanddeclaration"}, {"full_name": "HasSum.mul_right", "code": "theorem HasSum.mul_right (a\u2082) (hf : HasSum f a\u2081) : HasSum (fun i => f i * a\u2082) (a\u2081 * a\u2082)", "start": [38, 1], "end": [39, 90], "kind": "commanddeclaration"}, {"full_name": "Summable.mul_left", "code": "theorem Summable.mul_left (a) (hf : Summable f) : Summable fun i => a * f i", "start": [42, 1], "end": [43, 34], "kind": "commanddeclaration"}, {"full_name": "Summable.mul_right", "code": "theorem Summable.mul_right (a) (hf : Summable f) : Summable fun i => f i * a", "start": [46, 1], "end": [47, 35], "kind": "commanddeclaration"}, {"full_name": "Summable.tsum_mul_left", "code": "theorem Summable.tsum_mul_left (a) (hf : Summable f) : \u2211' i, a * f i = a * \u2211' i, f i", "start": [54, 1], "end": [55, 33], "kind": "commanddeclaration"}, {"full_name": "Summable.tsum_mul_right", "code": "theorem Summable.tsum_mul_right (a) (hf : Summable f) : \u2211' i, f i * a = (\u2211' i, f i) * a", "start": [58, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "Commute.tsum_right", "code": "theorem Commute.tsum_right (a) (h : \u2200 i, Commute a (f i)) : Commute a (\u2211' i, f i)", "start": [62, 1], "end": [65, 69], "kind": "commanddeclaration"}, {"full_name": "Commute.tsum_left", "code": "theorem Commute.tsum_left (a) (h : \u2200 i, Commute (f i) a) : Commute (\u2211' i, f i) a", "start": [68, 1], "end": [69, 50], "kind": "commanddeclaration"}, {"full_name": "HasSum.div_const", "code": "theorem HasSum.div_const (h : HasSum f a) (b : \u03b1) : HasSum (fun i => f i / b) (a / b)", "start": [81, 1], "end": [82, 46], "kind": "commanddeclaration"}, {"full_name": "Summable.div_const", "code": "theorem Summable.div_const (h : Summable f) (b : \u03b1) : Summable fun i => f i / b", "start": [85, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "hasSum_mul_left_iff", "code": "theorem hasSum_mul_left_iff (h : a\u2082 \u2260 0) : HasSum (fun i => a\u2082 * f i) (a\u2082 * a\u2081) \u2194 HasSum f a\u2081", "start": [89, 1], "end": [90, 93], "kind": "commanddeclaration"}, {"full_name": "hasSum_mul_right_iff", "code": "theorem hasSum_mul_right_iff (h : a\u2082 \u2260 0) : HasSum (fun i => f i * a\u2082) (a\u2081 * a\u2082) \u2194 HasSum f a\u2081", "start": [93, 1], "end": [94, 96], "kind": "commanddeclaration"}, {"full_name": "hasSum_div_const_iff", "code": "theorem hasSum_div_const_iff (h : a\u2082 \u2260 0) : HasSum (fun i => f i / a\u2082) (a\u2081 / a\u2082) \u2194 HasSum f a\u2081", "start": [97, 1], "end": [98, 73], "kind": "commanddeclaration"}, {"full_name": "summable_mul_left_iff", "code": "theorem summable_mul_left_iff (h : a \u2260 0) : (Summable fun i => a * f i) \u2194 Summable f", "start": [101, 1], "end": [102, 96], "kind": "commanddeclaration"}, {"full_name": "summable_mul_right_iff", "code": "theorem summable_mul_right_iff (h : a \u2260 0) : (Summable fun i => f i * a) \u2194 Summable f", "start": [105, 1], "end": [106, 99], "kind": "commanddeclaration"}, {"full_name": "summable_div_const_iff", "code": "theorem summable_div_const_iff (h : a \u2260 0) : (Summable fun i => f i / a) \u2194 Summable f", "start": [109, 1], "end": [110, 75], "kind": "commanddeclaration"}, {"full_name": "tsum_mul_left", "code": "theorem tsum_mul_left [T2Space \u03b1] : \u2211' x, a * f x = a * \u2211' x, f x", "start": [113, 1], "end": [117, 92], "kind": "commanddeclaration"}, {"full_name": "tsum_mul_right", "code": "theorem tsum_mul_right [T2Space \u03b1] : \u2211' x, f x * a = (\u2211' x, f x) * a", "start": [120, 1], "end": [124, 93], "kind": "commanddeclaration"}, {"full_name": "tsum_div_const", "code": "theorem tsum_div_const [T2Space \u03b1] : \u2211' x, f x / a = (\u2211' x, f x) / a", "start": [127, 1], "end": [128, 51], "kind": "commanddeclaration"}, {"full_name": "HasSum.mul_eq", "code": "theorem HasSum.mul_eq (hf : HasSum f s) (hg : HasSum g t)\n    (hfg : HasSum (fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) u) : s * t = u", "start": [154, 1], "end": [159, 19], "kind": "commanddeclaration"}, {"full_name": "HasSum.mul", "code": "theorem HasSum.mul (hf : HasSum f s) (hg : HasSum g t)\n    (hfg : Summable fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) :\n    HasSum (fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) (s * t)", "start": [162, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "tsum_mul_tsum", "code": "theorem tsum_mul_tsum (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) :\n    ((\u2211' x, f x) * \u2211' y, g y) = \u2211' z : \u03b9 \u00d7 \u03ba, f z.1 * g z.2", "start": [169, 1], "end": [174, 40], "kind": "commanddeclaration"}, {"full_name": "summable_mul_prod_iff_summable_mul_sigma_antidiagonal", "code": "theorem summable_mul_prod_iff_summable_mul_sigma_antidiagonal :\n    (Summable fun x : \u2115 \u00d7 \u2115 => f x.1 * g x.2) \u2194\n      Summable fun x : \u03a3n : \u2115, Nat.antidiagonal n => f (x.2 : \u2115 \u00d7 \u2115).1 * g (x.2 : \u2115 \u00d7 \u2115).2", "start": [197, 1], "end": [200, 51], "kind": "commanddeclaration"}, {"full_name": "summable_sum_mul_antidiagonal_of_summable_mul", "code": "theorem summable_sum_mul_antidiagonal_of_summable_mul\n    (h : Summable fun x : \u2115 \u00d7 \u2115 => f x.1 * g x.2) :\n    Summable fun n => \u2211 kl in Nat.antidiagonal n, f kl.1 * g kl.2", "start": [205, 1], "end": [210, 54], "kind": "commanddeclaration"}, {"full_name": "tsum_mul_tsum_eq_tsum_sum_antidiagonal", "code": "theorem tsum_mul_tsum_eq_tsum_sum_antidiagonal (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : \u2115 \u00d7 \u2115 => f x.1 * g x.2) :\n    ((\u2211' n, f n) * \u2211' n, g n) = \u2211' n, \u2211 kl in Nat.antidiagonal n, f kl.1 * g kl.2", "start": [213, 1], "end": [225, 69], "kind": "commanddeclaration"}, {"full_name": "summable_sum_mul_range_of_summable_mul", "code": "theorem summable_sum_mul_range_of_summable_mul (h : Summable fun x : \u2115 \u00d7 \u2115 => f x.1 * g x.2) :\n    Summable fun n => \u2211 k in range (n + 1), f k * g (n - k)", "start": [228, 1], "end": [231, 56], "kind": "commanddeclaration"}, {"full_name": "tsum_mul_tsum_eq_tsum_sum_range", "code": "theorem tsum_mul_tsum_eq_tsum_sum_range (hf : Summable f) (hg : Summable g)\n    (hfg : Summable fun x : \u2115 \u00d7 \u2115 => f x.1 * g x.2) :\n    ((\u2211' n, f n) * \u2211' n, g n) = \u2211' n, \u2211 k in range (n + 1), f k * g (n - k)", "start": [234, 1], "end": [243, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "imports": ["Mathlib/Data/Set/Intervals/OrdConnected.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.ordConnectedComponent", "code": "def ordConnectedComponent (s : Set \u03b1) (x : \u03b1) : Set \u03b1 :=\n  { y | [[x, y]] \u2286 s }", "start": [26, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ordConnectedComponent", "code": "theorem mem_ordConnectedComponent : y \u2208 ordConnectedComponent s x \u2194 [[x, y]] \u2286 s", "start": [32, 1], "end": [33, 10], "kind": "commanddeclaration"}, {"full_name": "Set.dual_ordConnectedComponent", "code": "theorem dual_ordConnectedComponent :\n    ordConnectedComponent (ofDual \u207b\u00b9' s) (toDual x) = ofDual \u207b\u00b9' ordConnectedComponent s x", "start": [36, 1], "end": [40, 8], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_subset", "code": "theorem ordConnectedComponent_subset : ordConnectedComponent s x \u2286 s", "start": [43, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "Set.subset_ordConnectedComponent", "code": "theorem subset_ordConnectedComponent {t} [h : OrdConnected s] (hs : x \u2208 s) (ht : s \u2286 t) :\n    s \u2286 ordConnectedComponent t x", "start": [47, 1], "end": [48, 80], "kind": "commanddeclaration"}, {"full_name": "Set.self_mem_ordConnectedComponent", "code": "@[simp]\ntheorem self_mem_ordConnectedComponent : x \u2208 ordConnectedComponent s x \u2194 x \u2208 s", "start": [51, 1], "end": [53, 66], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_ordConnectedComponent", "code": "@[simp]\ntheorem nonempty_ordConnectedComponent : (ordConnectedComponent s x).Nonempty \u2194 x \u2208 s", "start": [56, 1], "end": [58, 89], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_eq_empty", "code": "@[simp]\ntheorem ordConnectedComponent_eq_empty : ordConnectedComponent s x = \u2205 \u2194 x \u2209 s", "start": [61, 1], "end": [63, 67], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_empty", "code": "@[simp]\ntheorem ordConnectedComponent_empty : ordConnectedComponent \u2205 x = \u2205", "start": [66, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_univ", "code": "@[simp]\ntheorem ordConnectedComponent_univ : ordConnectedComponent univ x = univ", "start": [71, 1], "end": [73, 31], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_inter", "code": "theorem ordConnectedComponent_inter (s t : Set \u03b1) (x : \u03b1) :\n    ordConnectedComponent (s \u2229 t) x = ordConnectedComponent s x \u2229 ordConnectedComponent t x", "start": [76, 1], "end": [78, 42], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ordConnectedComponent_comm", "code": "theorem mem_ordConnectedComponent_comm :\n    y \u2208 ordConnectedComponent s x \u2194 x \u2208 ordConnectedComponent s y", "start": [81, 1], "end": [83, 71], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ordConnectedComponent_trans", "code": "theorem mem_ordConnectedComponent_trans (hxy : y \u2208 ordConnectedComponent s x)\n    (hyz : z \u2208 ordConnectedComponent s y) : z \u2208 ordConnectedComponent s x", "start": [86, 1], "end": [90, 34], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_eq", "code": "theorem ordConnectedComponent_eq (h : [[x, y]] \u2286 s) :\n    ordConnectedComponent s x = ordConnectedComponent s y", "start": [93, 1], "end": [97, 41], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedProj", "code": "noncomputable def ordConnectedProj (s : Set \u03b1) : s \u2192 \u03b1 := fun x : s =>\n  (nonempty_ordConnectedComponent.2 x.2).some", "start": [103, 1], "end": [106, 46], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedProj_mem_ordConnectedComponent", "code": "theorem ordConnectedProj_mem_ordConnectedComponent (s : Set \u03b1) (x : s) :\n    ordConnectedProj s x \u2208 ordConnectedComponent s x", "start": [109, 1], "end": [111, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ordConnectedComponent_ordConnectedProj", "code": "theorem mem_ordConnectedComponent_ordConnectedProj (s : Set \u03b1) (x : s) :\n    \u2191x \u2208 ordConnectedComponent s (ordConnectedProj s x)", "start": [114, 1], "end": [116, 85], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedComponent_ordConnectedProj", "code": "@[simp]\ntheorem ordConnectedComponent_ordConnectedProj (s : Set \u03b1) (x : s) :\n    ordConnectedComponent s (ordConnectedProj s x) = ordConnectedComponent s x", "start": [119, 1], "end": [122, 77], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedProj_eq", "code": "@[simp]\ntheorem ordConnectedProj_eq {x y : s} :\n    ordConnectedProj s x = ordConnectedProj s y \u2194 [[(x : \u03b1), y]] \u2286 s", "start": [125, 1], "end": [132, 61], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedSection", "code": "def ordConnectedSection (s : Set \u03b1) : Set \u03b1 :=\n  range <| ordConnectedProj s", "start": [135, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "Set.dual_ordConnectedSection", "code": "theorem dual_ordConnectedSection (s : Set \u03b1) :\n    ordConnectedSection (ofDual \u207b\u00b9' s) = ofDual \u207b\u00b9' ordConnectedSection s", "start": [141, 1], "end": [147, 8], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnectedSection_subset", "code": "theorem ordConnectedSection_subset : ordConnectedSection s \u2286 s", "start": [150, 1], "end": [151, 82], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_mem_ordConnectedSection_of_uIcc_subset", "code": "theorem eq_of_mem_ordConnectedSection_of_uIcc_subset (hx : x \u2208 ordConnectedSection s)\n    (hy : y \u2208 ordConnectedSection s) (h : [[x, y]] \u2286 s) : x = y", "start": [154, 1], "end": [161, 58], "kind": "commanddeclaration"}, {"full_name": "Set.ordSeparatingSet", "code": "def ordSeparatingSet (s t : Set \u03b1) : Set \u03b1 :=\n  (\u22c3 x \u2208 s, ordConnectedComponent t\u1d9c x) \u2229 \u22c3 x \u2208 t, ordConnectedComponent s\u1d9c x", "start": [164, 1], "end": [169, 78], "kind": "commanddeclaration"}, {"full_name": "Set.ordSeparatingSet_comm", "code": "theorem ordSeparatingSet_comm (s t : Set \u03b1) : ordSeparatingSet s t = ordSeparatingSet t s", "start": [172, 1], "end": [173, 17], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_left_ordSeparatingSet", "code": "theorem disjoint_left_ordSeparatingSet : Disjoint s (ordSeparatingSet s t)", "start": [176, 1], "end": [179, 70], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_right_ordSeparatingSet", "code": "theorem disjoint_right_ordSeparatingSet : Disjoint t (ordSeparatingSet s t)", "start": [182, 1], "end": [183, 61], "kind": "commanddeclaration"}, {"full_name": "Set.dual_ordSeparatingSet", "code": "theorem dual_ordSeparatingSet :\n    ordSeparatingSet (ofDual \u207b\u00b9' s) (ofDual \u207b\u00b9' t) = ofDual \u207b\u00b9' ordSeparatingSet s t", "start": [186, 1], "end": [189, 83], "kind": "commanddeclaration"}, {"full_name": "Set.ordT5Nhd", "code": "def ordT5Nhd (s t : Set \u03b1) : Set \u03b1 :=\n  \u22c3 x \u2208 s, ordConnectedComponent (t\u1d9c \u2229 (ordConnectedSection <| ordSeparatingSet s t)\u1d9c) x", "start": [192, 1], "end": [194, 89], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_ordT5Nhd", "code": "theorem disjoint_ordT5Nhd : Disjoint (ordT5Nhd s t) (ordT5Nhd t s)", "start": [197, 1], "end": [235, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Nat.lean", "imports": ["Mathlib/Topology/Instances/Int.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.dist_eq", "code": "theorem dist_eq (x y : \u2115) : dist x y = |(x : \u211d) - y|", "start": [25, 1], "end": [25, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_coe_int", "code": "theorem dist_coe_int (x y : \u2115) : dist (x : \u2124) (y : \u2124) = dist x y", "start": [28, 1], "end": [28, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_cast_real", "code": "@[norm_cast, simp]\ntheorem dist_cast_real (x y : \u2115) : dist (x : \u211d) y = dist x y", "start": [31, 1], "end": [32, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.pairwise_one_le_dist", "code": "theorem pairwise_one_le_dist : Pairwise fun m n : \u2115 => 1 \u2264 dist m n", "start": [35, 1], "end": [36, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.uniformEmbedding_coe_real", "code": "theorem uniformEmbedding_coe_real : UniformEmbedding ((\u2191) : \u2115 \u2192 \u211d)", "start": [39, 1], "end": [40, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.closedEmbedding_coe_real", "code": "theorem closedEmbedding_coe_real : ClosedEmbedding ((\u2191) : \u2115 \u2192 \u211d)", "start": [43, 1], "end": [44, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_ball", "code": "theorem preimage_ball (x : \u2115) (r : \u211d) : (\u2191) \u207b\u00b9' ball (x : \u211d) r = ball x r", "start": [49, 1], "end": [49, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_closedBall", "code": "theorem preimage_closedBall (x : \u2115) (r : \u211d) : (\u2191) \u207b\u00b9' closedBall (x : \u211d) r = closedBall x r", "start": [52, 1], "end": [52, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.closedBall_eq_Icc", "code": "theorem closedBall_eq_Icc (x : \u2115) (r : \u211d) : closedBall x r = Icc \u2308\u2191x - r\u2309\u208a \u230a\u2191x + r\u230b\u208a", "start": [55, 1], "end": [63, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Isometry.lean", "imports": ["Mathlib/Topology/MetricSpace/Antilipschitz.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Isometry", "code": "def Isometry [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 x1 x2 : \u03b1, edist (f x1) (f x2) = edist x1 x2", "start": [33, 1], "end": [36, 49], "kind": "commanddeclaration"}, {"full_name": "isometry_iff_nndist_eq", "code": "theorem isometry_iff_nndist_eq [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Isometry f \u2194 \u2200 x y, nndist (f x) (f y) = nndist x y", "start": [39, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "isometry_iff_dist_eq", "code": "theorem isometry_iff_dist_eq [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Isometry f \u2194 \u2200 x y, dist (f x) (f y) = dist x y", "start": [46, 1], "end": [49, 66], "kind": "commanddeclaration"}, {"full_name": "Isometry.dist_eq", "code": "alias \u27e8Isometry.dist_eq, _\u27e9 := isometry_iff_dist_eq", "start": [52, 1], "end": [53, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Isometry.of_dist_eq", "code": "alias \u27e8_, Isometry.of_dist_eq\u27e9 := isometry_iff_dist_eq", "start": [56, 1], "end": [57, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Isometry.nndist_eq", "code": "alias \u27e8Isometry.nndist_eq, _\u27e9 := isometry_iff_nndist_eq", "start": [60, 1], "end": [61, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Isometry.of_nndist_eq", "code": "alias \u27e8_, Isometry.of_nndist_eq\u27e9 := isometry_iff_nndist_eq", "start": [64, 1], "end": [65, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Isometry.edist_eq", "code": "theorem edist_eq (hf : Isometry f) (x y : \u03b1) : edist (f x) (f y) = edist x y", "start": [76, 1], "end": [78, 9], "kind": "commanddeclaration"}, {"full_name": "Isometry.lipschitz", "code": "theorem lipschitz (h : Isometry f) : LipschitzWith 1 f", "start": [81, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "Isometry.antilipschitz", "code": "theorem antilipschitz (h : Isometry f) : AntilipschitzWith 1 f", "start": [85, 1], "end": [86, 55], "kind": "commanddeclaration"}, {"full_name": "isometry_subsingleton", "code": "@[nontriviality]\ntheorem _root_.isometry_subsingleton [Subsingleton \u03b1] : Isometry f", "start": [89, 1], "end": [92, 35], "kind": "commanddeclaration"}, {"full_name": "isometry_id", "code": "theorem _root_.isometry_id : Isometry (id : \u03b1 \u2192 \u03b1)", "start": [95, 1], "end": [96, 69], "kind": "commanddeclaration"}, {"full_name": "Isometry.prod_map", "code": "theorem prod_map {\u03b4} [PseudoEMetricSpace \u03b4] {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Isometry f)\n    (hg : Isometry g) : Isometry (Prod.map f g)", "start": [99, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "isometry_dcomp", "code": "theorem _root_.isometry_dcomp {\u03b9} [Fintype \u03b9] {\u03b1 \u03b2 : \u03b9 \u2192 Type*} [\u2200 i, PseudoEMetricSpace (\u03b1 i)]\n    [\u2200 i, PseudoEMetricSpace (\u03b2 i)] (f : \u2200 i, \u03b1 i \u2192 \u03b2 i) (hf : \u2200 i, Isometry (f i)) :\n    Isometry (fun g : (i : \u03b9) \u2192 \u03b1 i => fun i => f i (g i))", "start": [104, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "Isometry.comp", "code": "theorem comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Isometry g) (hf : Isometry f) : Isometry (g \u2218 f)", "start": [110, 1], "end": [112, 37], "kind": "commanddeclaration"}, {"full_name": "Isometry.uniformContinuous", "code": "protected theorem uniformContinuous (hf : Isometry f) : UniformContinuous f", "start": [115, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "Isometry.uniformInducing", "code": "protected theorem uniformInducing (hf : Isometry f) : UniformInducing f", "start": [120, 1], "end": [122, 56], "kind": "commanddeclaration"}, {"full_name": "Isometry.tendsto_nhds_iff", "code": "theorem tendsto_nhds_iff {\u03b9 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1} {a : Filter \u03b9} {b : \u03b1}\n    (hf : Isometry f) : Filter.Tendsto g a (\ud835\udcdd b) \u2194 Filter.Tendsto (f \u2218 g) a (\ud835\udcdd (f b))", "start": [125, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "Isometry.continuous", "code": "protected theorem continuous (hf : Isometry f) : Continuous f", "start": [130, 1], "end": [132, 26], "kind": "commanddeclaration"}, {"full_name": "Isometry.right_inv", "code": "theorem right_inv {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : Isometry f) (hg : RightInverse g f) : Isometry g", "start": [135, 1], "end": [137, 37], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_emetric_closedBall", "code": "theorem preimage_emetric_closedBall (h : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    f \u207b\u00b9' EMetric.closedBall (f x) r = EMetric.closedBall x r", "start": [140, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_emetric_ball", "code": "theorem preimage_emetric_ball (h : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    f \u207b\u00b9' EMetric.ball (f x) r = EMetric.ball x r", "start": [146, 1], "end": [149, 20], "kind": "commanddeclaration"}, {"full_name": "Isometry.ediam_image", "code": "theorem ediam_image (hf : Isometry f) (s : Set \u03b1) : EMetric.diam (f '' s) = EMetric.diam s", "start": [152, 1], "end": [154, 95], "kind": "commanddeclaration"}, {"full_name": "Isometry.ediam_range", "code": "theorem ediam_range (hf : Isometry f) : EMetric.diam (range f) = EMetric.diam (univ : Set \u03b1)", "start": [157, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "Isometry.mapsTo_emetric_ball", "code": "theorem mapsTo_emetric_ball (hf : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    MapsTo f (EMetric.ball x r) (EMetric.ball (f x) r)", "start": [162, 1], "end": [164, 36], "kind": "commanddeclaration"}, {"full_name": "Isometry.mapsTo_emetric_closedBall", "code": "theorem mapsTo_emetric_closedBall (hf : Isometry f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    MapsTo f (EMetric.closedBall x r) (EMetric.closedBall (f x) r)", "start": [167, 1], "end": [169, 42], "kind": "commanddeclaration"}, {"full_name": "isometry_subtype_coe", "code": "theorem _root_.isometry_subtype_coe {s : Set \u03b1} : Isometry ((\u2191) : s \u2192 \u03b1)", "start": [172, 1], "end": [173, 91], "kind": "commanddeclaration"}, {"full_name": "Isometry.comp_continuousOn_iff", "code": "theorem comp_continuousOn_iff {\u03b3} [TopologicalSpace \u03b3] (hf : Isometry f) {g : \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    ContinuousOn (f \u2218 g) s \u2194 ContinuousOn g s", "start": [176, 1], "end": [178, 52], "kind": "commanddeclaration"}, {"full_name": "Isometry.comp_continuous_iff", "code": "theorem comp_continuous_iff {\u03b3} [TopologicalSpace \u03b3] (hf : Isometry f) {g : \u03b3 \u2192 \u03b1} :\n    Continuous (f \u2218 g) \u2194 Continuous g", "start": [181, 1], "end": [183, 50], "kind": "commanddeclaration"}, {"full_name": "Isometry.injective", "code": "protected theorem injective (h : Isometry f) : Injective f", "start": [193, 1], "end": [195, 28], "kind": "commanddeclaration"}, {"full_name": "Isometry.uniformEmbedding", "code": "protected theorem uniformEmbedding (hf : Isometry f) : UniformEmbedding f", "start": [198, 1], "end": [200, 67], "kind": "commanddeclaration"}, {"full_name": "Isometry.embedding", "code": "protected theorem embedding (hf : Isometry f) : Embedding f", "start": [203, 1], "end": [205, 32], "kind": "commanddeclaration"}, {"full_name": "Isometry.closedEmbedding", "code": "theorem closedEmbedding [CompleteSpace \u03b1] [EMetricSpace \u03b3] {f : \u03b1 \u2192 \u03b3} (hf : Isometry f) :\n    ClosedEmbedding f", "start": [208, 1], "end": [211, 66], "kind": "commanddeclaration"}, {"full_name": "Isometry.diam_image", "code": "theorem diam_image (hf : Isometry f) (s : Set \u03b1) : Metric.diam (f '' s) = Metric.diam s", "start": [221, 1], "end": [223, 48], "kind": "commanddeclaration"}, {"full_name": "Isometry.diam_range", "code": "theorem diam_range (hf : Isometry f) : Metric.diam (range f) = Metric.diam (univ : Set \u03b1)", "start": [226, 1], "end": [228, 27], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_setOf_dist", "code": "theorem preimage_setOf_dist (hf : Isometry f) (x : \u03b1) (p : \u211d \u2192 Prop) :\n    f \u207b\u00b9' { y | p (dist y (f x)) } = { y | p (dist y x) }", "start": [231, 1], "end": [234, 20], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_closedBall", "code": "theorem preimage_closedBall (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    f \u207b\u00b9' Metric.closedBall (f x) r = Metric.closedBall x r", "start": [237, 1], "end": [239, 35], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_ball", "code": "theorem preimage_ball (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    f \u207b\u00b9' Metric.ball (f x) r = Metric.ball x r", "start": [242, 1], "end": [244, 35], "kind": "commanddeclaration"}, {"full_name": "Isometry.preimage_sphere", "code": "theorem preimage_sphere (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    f \u207b\u00b9' Metric.sphere (f x) r = Metric.sphere x r", "start": [247, 1], "end": [249, 35], "kind": "commanddeclaration"}, {"full_name": "Isometry.mapsTo_ball", "code": "theorem mapsTo_ball (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    MapsTo f (Metric.ball x r) (Metric.ball (f x) r)", "start": [252, 1], "end": [254, 28], "kind": "commanddeclaration"}, {"full_name": "Isometry.mapsTo_sphere", "code": "theorem mapsTo_sphere (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    MapsTo f (Metric.sphere x r) (Metric.sphere (f x) r)", "start": [257, 1], "end": [259, 30], "kind": "commanddeclaration"}, {"full_name": "Isometry.mapsTo_closedBall", "code": "theorem mapsTo_closedBall (hf : Isometry f) (x : \u03b1) (r : \u211d) :\n    MapsTo f (Metric.closedBall x r) (Metric.closedBall (f x) r)", "start": [262, 1], "end": [264, 34], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.to_isometry", "code": "theorem UniformEmbedding.to_isometry {\u03b1 \u03b2} [UniformSpace \u03b1] [MetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : UniformEmbedding f) : (letI := h.comapMetricSpace f; Isometry f)", "start": [273, 1], "end": [278, 37], "kind": "commanddeclaration"}, {"full_name": "Embedding.to_isometry", "code": "theorem Embedding.to_isometry {\u03b1 \u03b2} [TopologicalSpace \u03b1] [MetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Embedding f) : (letI := h.comapMetricSpace f; Isometry f)", "start": [281, 1], "end": [286, 37], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv", "code": "structure IsometryEquiv (\u03b1 : Type u) (\u03b2 : Type v) [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]\n    extends \u03b1 \u2243 \u03b2 where\n  isometry_toFun : Isometry toFun", "start": [290, 1], "end": [294, 34], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Injective (toEquiv : (\u03b1 \u2243\u1d62 \u03b2) \u2192 (\u03b1 \u2243 \u03b2))", "start": [308, 1], "end": [309, 31], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toEquiv_inj", "code": "@[simp] theorem toEquiv_inj {e\u2081 e\u2082 : \u03b1 \u2243\u1d62 \u03b2} : e\u2081.toEquiv = e\u2082.toEquiv \u2194 e\u2081 = e\u2082", "start": [312, 1], "end": [313, 27], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_eq_toEquiv", "code": "theorem coe_eq_toEquiv (h : \u03b1 \u2243\u1d62 \u03b2) (a : \u03b1) : h a = h.toEquiv a", "start": [322, 1], "end": [322, 71], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toEquiv", "code": "@[simp] theorem coe_toEquiv (h : \u03b1 \u2243\u1d62 \u03b2) : \u21d1h.toEquiv = h", "start": [325, 1], "end": [325, 65], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_mk", "code": "@[simp] theorem coe_mk (e : \u03b1 \u2243 \u03b2) (h) : \u21d1(mk e h) = e", "start": [328, 1], "end": [328, 62], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.isometry", "code": "protected theorem isometry (h : \u03b1 \u2243\u1d62 \u03b2) : Isometry h", "start": [330, 1], "end": [331, 19], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.bijective", "code": "protected theorem bijective (h : \u03b1 \u2243\u1d62 \u03b2) : Bijective h", "start": [334, 1], "end": [335, 22], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.injective", "code": "protected theorem injective (h : \u03b1 \u2243\u1d62 \u03b2) : Injective h", "start": [338, 1], "end": [339, 22], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.surjective", "code": "protected theorem surjective (h : \u03b1 \u2243\u1d62 \u03b2) : Surjective h", "start": [342, 1], "end": [343, 23], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.edist_eq", "code": "protected theorem edist_eq (h : \u03b1 \u2243\u1d62 \u03b2) (x y : \u03b1) : edist (h x) (h y) = edist x y", "start": [346, 1], "end": [347, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.dist_eq", "code": "protected theorem dist_eq {\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2)\n    (x y : \u03b1) : dist (h x) (h y) = dist x y", "start": [350, 1], "end": [352, 25], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.nndist_eq", "code": "protected theorem nndist_eq {\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2)\n    (x y : \u03b1) : nndist (h x) (h y) = nndist x y", "start": [355, 1], "end": [357, 27], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.continuous", "code": "protected theorem continuous (h : \u03b1 \u2243\u1d62 \u03b2) : Continuous h", "start": [360, 1], "end": [361, 24], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.ediam_image", "code": "@[simp]\ntheorem ediam_image (h : \u03b1 \u2243\u1d62 \u03b2) (s : Set \u03b1) : EMetric.diam (h '' s) = EMetric.diam s", "start": [364, 1], "end": [366, 27], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.ext", "code": "@[ext]\ntheorem ext \u2983h\u2081 h\u2082 : \u03b1 \u2243\u1d62 \u03b2\u2984 (H : \u2200 x, h\u2081 x = h\u2082 x) : h\u2081 = h\u2082", "start": [369, 1], "end": [371, 20], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mk'", "code": "def mk' {\u03b1 : Type u} [EMetricSpace \u03b1] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) (hfg : \u2200 x, f (g x) = x)\n    (hf : Isometry f) : \u03b1 \u2243\u1d62 \u03b2 where\n  toFun := f\n  invFun := g\n  left_inv _ := hf.injective <| hfg _\n  right_inv := hfg\n  isometry_toFun := hf", "start": [374, 1], "end": [382, 23], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.refl", "code": "protected def refl (\u03b1 : Type*) [PseudoEMetricSpace \u03b1] : \u03b1 \u2243\u1d62 \u03b1 :=\n  { Equiv.refl \u03b1 with isometry_toFun := isometry_id }", "start": [385, 1], "end": [387, 54], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.trans", "code": "protected def trans (h\u2081 : \u03b1 \u2243\u1d62 \u03b2) (h\u2082 : \u03b2 \u2243\u1d62 \u03b3) : \u03b1 \u2243\u1d62 \u03b3 :=\n  { Equiv.trans h\u2081.toEquiv h\u2082.toEquiv with\n    isometry_toFun := h\u2082.isometry_toFun.comp h\u2081.isometry_toFun }", "start": [390, 1], "end": [393, 65], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (h\u2081 : \u03b1 \u2243\u1d62 \u03b2) (h\u2082 : \u03b2 \u2243\u1d62 \u03b3) (x : \u03b1) : h\u2081.trans h\u2082 x = h\u2082 (h\u2081 x)", "start": [396, 1], "end": [398, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm", "code": "protected def symm (h : \u03b1 \u2243\u1d62 \u03b2) : \u03b2 \u2243\u1d62 \u03b1 where\n  isometry_toFun := h.isometry.right_inv h.right_inv\n  toEquiv := h.toEquiv.symm", "start": [401, 1], "end": [404, 28], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.Simps.apply", "code": "def Simps.apply (h : \u03b1 \u2243\u1d62 \u03b2) : \u03b1 \u2192 \u03b2 := h", "start": [407, 1], "end": [409, 42], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (h : \u03b1 \u2243\u1d62 \u03b2) : \u03b2 \u2192 \u03b1 :=\n  h.symm", "start": [412, 1], "end": [414, 9], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (h : \u03b1 \u2243\u1d62 \u03b2) : h.symm.symm = h", "start": [419, 1], "end": [420, 56], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (h : \u03b1 \u2243\u1d62 \u03b2) (y : \u03b2) : h (h.symm y) = y", "start": [423, 1], "end": [425, 31], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) : h.symm (h x) = x", "start": [428, 1], "end": [430, 31], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm_apply_eq", "code": "theorem symm_apply_eq (h : \u03b1 \u2243\u1d62 \u03b2) {x : \u03b1} {y : \u03b2} : h.symm y = x \u2194 y = h x", "start": [433, 1], "end": [434, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.eq_symm_apply", "code": "theorem eq_symm_apply (h : \u03b1 \u2243\u1d62 \u03b2) {x : \u03b1} {y : \u03b2} : x = h.symm y \u2194 h x = y", "start": [437, 1], "end": [438, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm_comp_self", "code": "theorem symm_comp_self (h : \u03b1 \u2243\u1d62 \u03b2) : (h.symm : \u03b2 \u2192 \u03b1) \u2218 h = id", "start": [441, 1], "end": [441, 85], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.self_comp_symm", "code": "theorem self_comp_symm (h : \u03b1 \u2243\u1d62 \u03b2) : (h : \u03b1 \u2192 \u03b2) \u2218 h.symm = id", "start": [444, 1], "end": [444, 86], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.range_eq_univ", "code": "@[simp]\ntheorem range_eq_univ (h : \u03b1 \u2243\u1d62 \u03b2) : range h = univ", "start": [447, 1], "end": [449, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_symm", "code": "theorem image_symm (h : \u03b1 \u2243\u1d62 \u03b2) : image h.symm = preimage h", "start": [452, 1], "end": [453, 80], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_symm", "code": "theorem preimage_symm (h : \u03b1 \u2243\u1d62 \u03b2) : preimage h.symm = image h", "start": [456, 1], "end": [457, 77], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (h\u2081 : \u03b1 \u2243\u1d62 \u03b2) (h\u2082 : \u03b2 \u2243\u1d62 \u03b3) (x : \u03b3) :\n    (h\u2081.trans h\u2082).symm x = h\u2081.symm (h\u2082.symm x)", "start": [460, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.ediam_univ", "code": "theorem ediam_univ (h : \u03b1 \u2243\u1d62 \u03b2) : EMetric.diam (univ : Set \u03b1) = EMetric.diam (univ : Set \u03b2)", "start": [466, 1], "end": [467, 49], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.ediam_preimage", "code": "@[simp]\ntheorem ediam_preimage (h : \u03b1 \u2243\u1d62 \u03b2) (s : Set \u03b2) : EMetric.diam (h \u207b\u00b9' s) = EMetric.diam s", "start": [470, 1], "end": [472, 33], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_emetric_ball", "code": "@[simp]\ntheorem preimage_emetric_ball (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b2) (r : \u211d\u22650\u221e) :\n    h \u207b\u00b9' EMetric.ball x r = EMetric.ball (h.symm x) r", "start": [475, 1], "end": [478, 75], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_emetric_closedBall", "code": "@[simp]\ntheorem preimage_emetric_closedBall (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b2) (r : \u211d\u22650\u221e) :\n    h \u207b\u00b9' EMetric.closedBall x r = EMetric.closedBall (h.symm x) r", "start": [481, 1], "end": [484, 81], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_emetric_ball", "code": "@[simp]\ntheorem image_emetric_ball (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    h '' EMetric.ball x r = EMetric.ball (h x) r", "start": [487, 1], "end": [490, 66], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_emetric_closedBall", "code": "@[simp]\ntheorem image_emetric_closedBall (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    h '' EMetric.closedBall x r = EMetric.closedBall (h x) r", "start": [493, 1], "end": [496, 72], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.toHomeomorph", "code": "@[simps toEquiv]\nprotected def toHomeomorph (h : \u03b1 \u2243\u1d62 \u03b2) : \u03b1 \u2243\u209c \u03b2 where\n  continuous_toFun := h.continuous\n  continuous_invFun := h.symm.continuous\n  toEquiv := h.toEquiv", "start": [499, 1], "end": [504, 23], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph (h : \u03b1 \u2243\u1d62 \u03b2) : \u21d1h.toHomeomorph = h", "start": [508, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_toHomeomorph_symm", "code": "@[simp]\ntheorem coe_toHomeomorph_symm (h : \u03b1 \u2243\u1d62 \u03b2) : \u21d1h.toHomeomorph.symm = h.symm", "start": [513, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.comp_continuousOn_iff", "code": "@[simp]\ntheorem comp_continuousOn_iff {\u03b3} [TopologicalSpace \u03b3] (h : \u03b1 \u2243\u1d62 \u03b2) {f : \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    ContinuousOn (h \u2218 f) s \u2194 ContinuousOn f s", "start": [518, 1], "end": [521, 43], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff {\u03b3} [TopologicalSpace \u03b3] (h : \u03b1 \u2243\u1d62 \u03b2) {f : \u03b3 \u2192 \u03b1} :\n    Continuous (h \u2218 f) \u2194 Continuous f", "start": [524, 1], "end": [527, 37], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.comp_continuous_iff'", "code": "@[simp]\ntheorem comp_continuous_iff' {\u03b3} [TopologicalSpace \u03b3] (h : \u03b1 \u2243\u1d62 \u03b2) {f : \u03b2 \u2192 \u03b3} :\n    Continuous (f \u2218 h) \u2194 Continuous f", "start": [530, 1], "end": [533, 38], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_one", "code": "@[simp] theorem coe_one : \u21d1(1 : \u03b1 \u2243\u1d62 \u03b1) = id", "start": [546, 1], "end": [546, 52], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.coe_mul", "code": "@[simp] theorem coe_mul (e\u2081 e\u2082 : \u03b1 \u2243\u1d62 \u03b1) : \u21d1(e\u2081 * e\u2082) = e\u2081 \u2218 e\u2082", "start": [549, 1], "end": [549, 71], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mul_apply", "code": "theorem mul_apply (e\u2081 e\u2082 : \u03b1 \u2243\u1d62 \u03b1) (x : \u03b1) : (e\u2081 * e\u2082) x = e\u2081 (e\u2082 x)", "start": [552, 1], "end": [552, 76], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.inv_apply_self", "code": "@[simp] theorem inv_apply_self (e : \u03b1 \u2243\u1d62 \u03b1) (x : \u03b1) : e\u207b\u00b9 (e x) = x", "start": [555, 1], "end": [555, 92], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.apply_inv_self", "code": "@[simp] theorem apply_inv_self (e : \u03b1 \u2243\u1d62 \u03b1) (x : \u03b1) : e (e\u207b\u00b9 x) = x", "start": [558, 1], "end": [558, 92], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.completeSpace_iff", "code": "theorem completeSpace_iff (e : \u03b1 \u2243\u1d62 \u03b2) : CompleteSpace \u03b1 \u2194 CompleteSpace \u03b2", "start": [561, 1], "end": [563, 53], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.completeSpace", "code": "protected theorem completeSpace [CompleteSpace \u03b2] (e : \u03b1 \u2243\u1d62 \u03b2) : CompleteSpace \u03b1", "start": [566, 1], "end": [567, 28], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.funUnique", "code": "@[simps!]\ndef funUnique [Unique \u03b9] [Fintype \u03b9] : (\u03b9 \u2192 \u03b1) \u2243\u1d62 \u03b1 where\n  toEquiv := Equiv.funUnique \u03b9 \u03b1\n  isometry_toFun x hx := by simp [edist_pi_def, Finset.univ_unique, Finset.sup_singleton]", "start": [572, 1], "end": [576, 90], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.piFinTwo", "code": "@[simps!]\ndef piFinTwo (\u03b1 : Fin 2 \u2192 Type*) [\u2200 i, PseudoEMetricSpace (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243\u1d62 \u03b1 0 \u00d7 \u03b1 1 where\n  toEquiv := piFinTwoEquiv \u03b1\n  isometry_toFun x hx := by simp [edist_pi_def, Fin.univ_succ, Prod.edist_eq]", "start": [579, 1], "end": [583, 78], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.diam_image", "code": "@[simp]\ntheorem diam_image (s : Set \u03b1) : Metric.diam (h '' s) = Metric.diam s", "start": [592, 1], "end": [594, 26], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.diam_preimage", "code": "@[simp]\ntheorem diam_preimage (s : Set \u03b2) : Metric.diam (h \u207b\u00b9' s) = Metric.diam s", "start": [597, 1], "end": [599, 32], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.diam_univ", "code": "theorem diam_univ : Metric.diam (univ : Set \u03b1) = Metric.diam (univ : Set \u03b2)", "start": [602, 1], "end": [603, 40], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_ball", "code": "@[simp]\ntheorem preimage_ball (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b2) (r : \u211d) :\n    h \u207b\u00b9' Metric.ball x r = Metric.ball (h.symm x) r", "start": [606, 1], "end": [609, 67], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_sphere", "code": "@[simp]\ntheorem preimage_sphere (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b2) (r : \u211d) :\n    h \u207b\u00b9' Metric.sphere x r = Metric.sphere (h.symm x) r", "start": [612, 1], "end": [615, 69], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.preimage_closedBall", "code": "@[simp]\ntheorem preimage_closedBall (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b2) (r : \u211d) :\n    h \u207b\u00b9' Metric.closedBall x r = Metric.closedBall (h.symm x) r", "start": [618, 1], "end": [621, 73], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_ball", "code": "@[simp]\ntheorem image_ball (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d) : h '' Metric.ball x r = Metric.ball (h x) r", "start": [624, 1], "end": [626, 58], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_sphere", "code": "@[simp]\ntheorem image_sphere (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d) :\n    h '' Metric.sphere x r = Metric.sphere (h x) r", "start": [629, 1], "end": [632, 60], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.image_closedBall", "code": "@[simp]\ntheorem image_closedBall (h : \u03b1 \u2243\u1d62 \u03b2) (x : \u03b1) (r : \u211d) :\n    h '' Metric.closedBall x r = Metric.closedBall (h x) r", "start": [635, 1], "end": [638, 64], "kind": "commanddeclaration"}, {"full_name": "Isometry.isometryEquivOnRange", "code": "@[simps! (config := { simpRhs := true }) toEquiv apply]\ndef Isometry.isometryEquivOnRange [EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Isometry f) : \u03b1 \u2243\u1d62 range f where\n  isometry_toFun := h\n  toEquiv := Equiv.ofInjective f h.injective", "start": [645, 1], "end": [651, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Comma.lean", "imports": ["Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/CategoryTheory/EqToHom.lean", "Mathlib/CategoryTheory/Iso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Comma", "code": "structure Comma (L : A \u2964 T) (R : B \u2964 T) : Type max u\u2081 u\u2082 v\u2083 where\n  left : A\n  right : B\n  hom : L.obj left \u27f6 R.obj right", "start": [58, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.inhabited", "code": "instance Comma.inhabited [Inhabited T] : Inhabited (Comma (\ud835\udfed T) (\ud835\udfed T)) where\n  default :=\n    { left := default\n      right := default\n      hom := \ud835\udfd9 default }", "start": [67, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommaMorphism", "code": "@[ext]\nstructure CommaMorphism (X Y : Comma L R) where\n  left : X.left \u27f6 Y.left\n  right : X.right \u27f6 Y.right\n  w : L.map left \u226b Y.hom = X.hom \u226b R.map right := by aesop_cat", "start": [76, 1], "end": [83, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommaMorphism.inhabited", "code": "instance CommaMorphism.inhabited [Inhabited (Comma L R)] :\n    Inhabited (CommaMorphism (default : Comma L R) default) :=\n    \u27e8{ left := \ud835\udfd9 _, right := \ud835\udfd9 _}\u27e9", "start": [87, 1], "end": [89, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.commaCategory", "code": "instance commaCategory : Category (Comma L R) where\n  Hom X Y := CommaMorphism X Y\n  id X :=\n    { left := \ud835\udfd9 X.left\n      right := \ud835\udfd9 X.right }\n  comp f g :=\n    { left := f.left \u226b g.left\n      right := f.right \u226b g.right }", "start": [94, 1], "end": [101, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.hom_ext", "code": "@[ext]\nlemma hom_ext (f g : X \u27f6 Y) (h\u2081 : f.left = g.left) (h\u2082 : f.right = g.right) : f = g :=\n  CommaMorphism.ext _ _ h\u2081 h\u2082", "start": [112, 1], "end": [114, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Comma.id_left", "code": "@[simp]\ntheorem id_left : (\ud835\udfd9 X : CommaMorphism X X).left = \ud835\udfd9 X.left", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.id_right", "code": "@[simp]\ntheorem id_right : (\ud835\udfd9 X : CommaMorphism X X).right = \ud835\udfd9 X.right", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.comp_left", "code": "@[simp]\ntheorem comp_left : (f \u226b g).left = f.left \u226b g.left", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.comp_right", "code": "@[simp]\ntheorem comp_right : (f \u226b g).right = f.right \u226b g.right", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.fst", "code": "@[simps]\ndef fst : Comma L R \u2964 A where\n  obj X := X.left\n  map f := f.left", "start": [140, 1], "end": [144, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.snd", "code": "@[simps]\ndef snd : Comma L R \u2964 B where\n  obj X := X.right\n  map f := f.right", "start": [147, 1], "end": [151, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.natTrans", "code": "@[simps]\ndef natTrans : fst L R \u22d9 L \u27f6 snd L R \u22d9 R where app X := X.hom", "start": [154, 1], "end": [159, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.eqToHom_left", "code": "@[simp]\ntheorem eqToHom_left (X Y : Comma L R) (H : X = Y) :\n    CommaMorphism.left (eqToHom H) = eqToHom (by cases H; rfl)", "start": [162, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.eqToHom_right", "code": "@[simp]\ntheorem eqToHom_right (X Y : Comma L R) (H : X = Y) : CommaMorphism.right (eqToHom H) = eqToHom (by\n    cases H\n    rfl)", "start": [169, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.isoMk", "code": "@[simps]\ndef isoMk {X Y : Comma L\u2081 R\u2081} (l : X.left \u2245 Y.left) (r : X.right \u2245 Y.right)\n    (h : L\u2081.map l.hom \u226b Y.hom = X.hom \u226b R\u2081.map r.hom := by aesop_cat) : X \u2245 Y where\n  hom :=\n    { left := l.hom\n      right := r.hom\n      w := h }\n  inv :=\n    { left := l.inv\n      right := r.inv\n      w := by\n        rw [\u2190 L\u2081.mapIso_inv l, Iso.inv_comp_eq, L\u2081.mapIso_hom, \u2190 Category.assoc, h,\n          Category.assoc, \u2190 R\u2081.map_comp]\n        simp }", "start": [181, 1], "end": [197, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapLeft", "code": "@[simps]\ndef mapLeft (l : L\u2081 \u27f6 L\u2082) : Comma L\u2082 R \u2964 Comma L\u2081 R where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := l.app X.left \u226b X.hom }\n  map f :=\n    { left := f.left\n      right := f.right }", "start": [200, 1], "end": [209, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapLeftId", "code": "@[simps]\ndef mapLeftId : mapLeft R (\ud835\udfd9 L) \u2245 \ud835\udfed _ where\n  hom :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }\n  inv :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }", "start": [212, 1], "end": [223, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapLeftComp", "code": "@[simps]\ndef mapLeftComp (l : L\u2081 \u27f6 L\u2082) (l' : L\u2082 \u27f6 L\u2083) :\n    mapLeft R (l \u226b l') \u2245 mapLeft R l' \u22d9 mapLeft R l where\n  hom :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }\n  inv :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }", "start": [226, 1], "end": [239, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapLeftEq", "code": "@[simps!]\ndef mapLeftEq (l l' : L\u2081 \u27f6 L\u2082) (h : l = l') : mapLeft R l \u2245 mapLeft R l' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _) (by aesop_cat)) (by aesop_cat)", "start": [242, 1], "end": [246, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapLeftIso", "code": "@[simps!]\ndef mapLeftIso (i : L\u2081 \u2245 L\u2082) : Comma L\u2081 R \u224c Comma L\u2082 R :=\n  Equivalence.mk (mapLeft _ i.inv) (mapLeft _ i.hom)\n    ((mapLeftId _ _).symm \u226a\u226b mapLeftEq _ _ _ i.hom_inv_id.symm \u226a\u226b mapLeftComp _ _ _)\n    ((mapLeftComp _ _ _).symm \u226a\u226b mapLeftEq _ _ _ i.inv_hom_id \u226a\u226b mapLeftId _ _)", "start": [248, 1], "end": [254, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapRight", "code": "@[simps]\ndef mapRight (r : R\u2081 \u27f6 R\u2082) : Comma L R\u2081 \u2964 Comma L R\u2082 where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := X.hom \u226b r.app X.right }\n  map f :=\n    { left := f.left\n      right := f.right }", "start": [256, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapRightId", "code": "@[simps]\ndef mapRightId : mapRight L (\ud835\udfd9 R) \u2245 \ud835\udfed _ where\n  hom :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }\n  inv :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }", "start": [268, 1], "end": [279, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapRightComp", "code": "@[simps]\ndef mapRightComp (r : R\u2081 \u27f6 R\u2082) (r' : R\u2082 \u27f6 R\u2083) :\n    mapRight L (r \u226b r') \u2245 mapRight L r \u22d9 mapRight L r' where\n  hom :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }\n  inv :=\n    { app := fun X =>\n        { left := \ud835\udfd9 _\n          right := \ud835\udfd9 _ } }", "start": [282, 1], "end": [295, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapRightEq", "code": "@[simps!]\ndef mapRightEq (r r' : R\u2081 \u27f6 R\u2082) (h : r = r') : mapRight L r \u2245 mapRight L r' :=\n  NatIso.ofComponents (fun X => isoMk (Iso.refl _) (Iso.refl _) (by aesop_cat)) (by aesop_cat)", "start": [298, 1], "end": [302, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.mapRightIso", "code": "@[simps!]\ndef mapRightIso (i : R\u2081 \u2245 R\u2082) : Comma L R\u2081 \u224c Comma L R\u2082 :=\n  Equivalence.mk (mapRight _ i.hom) (mapRight _ i.inv)\n    ((mapRightId _ _).symm \u226a\u226b mapRightEq _ _ _ i.hom_inv_id.symm \u226a\u226b mapRightComp _ _ _)\n    ((mapRightComp _ _ _).symm \u226a\u226b mapRightEq _ _ _ i.inv_hom_id \u226a\u226b mapRightId _ _)", "start": [304, 1], "end": [310, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.preLeft", "code": "@[simps]\ndef preLeft (F : C \u2964 A) (L : A \u2964 T) (R : B \u2964 T) : Comma (F \u22d9 L) R \u2964 Comma L R where\n  obj X :=\n    { left := F.obj X.left\n      right := X.right\n      hom := X.hom }\n  map f :=\n    { left := F.map f.left\n      right := f.right\n      w := by simpa using f.w }", "start": [318, 1], "end": [328, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.isEquivalencePreLeft", "code": "noncomputable def isEquivalencePreLeft (F : C \u2964 A) (L : A \u2964 T) (R : B \u2964 T) [IsEquivalence F] :\n    IsEquivalence (preLeft F L R) :=\n  have := Equivalence.essSurj_of_equivalence F\n  Equivalence.ofFullyFaithfullyEssSurj _", "start": [343, 1], "end": [347, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.preRight", "code": "@[simps]\ndef preRight (L : A \u2964 T) (F : C \u2964 B) (R : B \u2964 T) : Comma L (F \u22d9 R) \u2964 Comma L R where\n  obj X :=\n    { left := X.left\n      right := F.obj X.right\n      hom := X.hom }\n  map f :=\n    { left := f.left\n      right := F.map f.right }", "start": [349, 1], "end": [358, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.isEquivalencePreRight", "code": "noncomputable def isEquivalencePreRight (L : A \u2964 T) (F : C \u2964 B) (R : B \u2964 T) [IsEquivalence F] :\n    IsEquivalence (preRight L F R) :=\n  have := Equivalence.essSurj_of_equivalence F\n  Equivalence.ofFullyFaithfullyEssSurj _", "start": [373, 1], "end": [377, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Comma.post", "code": "@[simps]\ndef post (L : A \u2964 T) (R : B \u2964 T) (F : T \u2964 C) : Comma L R \u2964 Comma (L \u22d9 F) (R \u22d9 F) where\n  obj X :=\n    { left := X.left\n      right := X.right\n      hom := F.map X.hom }\n  map f :=\n    { left := f.left\n      right := f.right\n      w := by simp only [Functor.comp_map, \u2190 F.map_comp, f.w] }", "start": [379, 1], "end": [389, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Pi/Basic.lean", "imports": ["Mathlib/CategoryTheory/NatIso.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/CategoryTheory/EqToHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.pi", "code": "instance pi : Category.{max w\u2080 v\u2081} (\u2200 i, C i) where\n  Hom X Y := \u2200 i, X i \u27f6 Y i\n  id X i := \ud835\udfd9 (X i)\n  comp f g i := f i \u226b g i", "start": [27, 1], "end": [32, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pi'", "code": "abbrev pi' {I : Type v\u2081} (C : I \u2192 Type u\u2081) [\u2200 i, Category.{v\u2081} (C i)] : Category.{v\u2081} (\u2200 i, C i) :=\n  CategoryTheory.pi C", "start": [35, 1], "end": [39, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.id_apply", "code": "@[simp]\ntheorem id_apply (X : \u2200 i, C i) (i) : (\ud835\udfd9 X : \u2200 i, X i \u27f6 X i) i = \ud835\udfd9 (X i)", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.comp_apply", "code": "@[simp]\ntheorem comp_apply {X Y Z : \u2200 i, C i} (f : X \u27f6 Y) (g : Y \u27f6 Z) (i) :\n    (f \u226b g : \u2200 i, X i \u27f6 Z i) i = f i \u226b g i", "start": [51, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.ext", "code": "@[ext]\nlemma ext {X Y : \u2200 i, C i} {f g : X \u27f6 Y} (w : \u2200 i, f i = g i) : f = g :=\n  funext (w \u00b7)", "start": [58, 1], "end": [60, 15], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pi.eval", "code": "@[simps]\ndef eval (i : I) : (\u2200 i, C i) \u2964 C i where\n  obj f := f i\n  map \u03b1 := \u03b1 i", "start": [62, 1], "end": [68, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.comap", "code": "@[simps]\ndef comap (h : J \u2192 I) : (\u2200 i, C i) \u2964 (\u2200 j, C (h j)) where\n  obj f i := f (h i)\n  map \u03b1 i := \u03b1 (h i)", "start": [82, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.comapId", "code": "@[simps]\ndef comapId : comap C (id : I \u2192 I) \u2245 \ud835\udfed (\u2200 i, C i) where\n  hom := { app := fun X => \ud835\udfd9 X }\n  inv := { app := fun X => \ud835\udfd9 X }", "start": [92, 1], "end": [98, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.comapComp", "code": "@[simps!]\ndef comapComp (f : K \u2192 J) (g : J \u2192 I) : comap C g \u22d9 comap (C \u2218 g) f \u2245 comap C (g \u2218 f) where\n  hom :=\n  { app := fun X b => \ud835\udfd9 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }\n  inv :=\n  { app := fun X b => \ud835\udfd9 (X (g (f b)))\n    naturality := fun X Y f' => by simp only [comap, Function.comp]; funext; simp }", "start": [107, 1], "end": [118, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.comapEvalIsoEval", "code": "@[simps!]\ndef comapEvalIsoEval (h : J \u2192 I) (j : J) : comap C h \u22d9 eval (C \u2218 h) j \u2245 eval C (h j) :=\n  NatIso.ofComponents (fun f => Iso.refl _) (by simp only [Iso.refl]; aesop_cat)", "start": [121, 1], "end": [124, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.sumElimCategory", "code": "instance sumElimCategory : \u2200 s : Sum I J, Category.{v\u2081} (Sum.elim C D s)\n  | Sum.inl i => by\n    dsimp\n    infer_instance\n  | Sum.inr j => by\n    dsimp\n    infer_instance", "start": [134, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.sum", "code": "@[simps]\ndef sum : (\u2200 i, C i) \u2964 (\u2200 j, D j) \u2964 \u2200 s : Sum I J, Sum.elim C D s where\n  obj X :=\n    { obj := fun Y s =>\n        match s with\n        | .inl i => X i\n        | .inr j => Y j\n      map := fun {Y} {Y'} f s =>\n        match s with\n        | .inl i => \ud835\udfd9 (X i)\n        | .inr j => f j }\n  map {X} {X'} f :=\n    { app := fun Y s =>\n        match s with\n        | .inl i => f i\n        | .inr j => \ud835\udfd9 (Y j) }", "start": [146, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.isoApp", "code": "@[simps]\ndef isoApp {X Y : \u2200 i, C i} (f : X \u2245 Y) (i : I) : X i \u2245 Y i :=\n  \u27e8f.hom i, f.inv i,\n    by rw [\u2190 comp_apply, Iso.hom_inv_id, id_apply], by rw [\u2190 comp_apply, Iso.inv_hom_id, id_apply]\u27e9", "start": [171, 1], "end": [176, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.isoApp_refl", "code": "@[simp]\ntheorem isoApp_refl (X : \u2200 i, C i) (i : I) : isoApp (Iso.refl X) i = Iso.refl (X i)", "start": [179, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.isoApp_symm", "code": "@[simp]\ntheorem isoApp_symm {X Y : \u2200 i, C i} (f : X \u2245 Y) (i : I) : isoApp f.symm i = (isoApp f i).symm", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pi.isoApp_trans", "code": "@[simp]\ntheorem isoApp_trans {X Y Z : \u2200 i, C i} (f : X \u2245 Y) (g : Y \u2245 Z) (i : I) :\n    isoApp (f \u226a\u226b g) i = isoApp f i \u226a\u226b isoApp g i", "start": [189, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.pi", "code": "@[simps]\ndef pi (F : \u2200 i, C i \u2964 D i) : (\u2200 i, C i) \u2964 \u2200 i, D i where\n  obj f i := (F i).obj (f i)\n  map \u03b1 i := (F i).map (\u03b1 i)", "start": [203, 1], "end": [208, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.pi'", "code": "@[simps]\ndef pi' (f : \u2200 i, A \u2964 C i) : A \u2964 \u2200 i, C i where\n  obj a i := (f i).obj a\n  map h i := (f i).map h", "start": [211, 1], "end": [216, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eqToHom_proj", "code": "@[simp]\ntheorem eqToHom_proj {x x' : \u2200 i, C i} (h : x = x') (i : I) :\n    (eqToHom h : x \u27f6 x') i = eqToHom (Function.funext_iff.mp h i)", "start": [221, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.pi'_eval", "code": "@[simp]\ntheorem pi'_eval (f : \u2200 i, A \u2964 C i) (i : I) : pi' f \u22d9 Pi.eval C i = f i", "start": [232, 1], "end": [238, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.pi_ext", "code": "theorem pi_ext (f f' : A \u2964 \u2200 i, C i) (h : \u2200 i, f \u22d9 (Pi.eval C i) = f' \u22d9 (Pi.eval C i)) :\n    f = f'", "start": [241, 1], "end": [255, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.pi", "code": "@[simps!]\ndef pi (\u03b1 : \u2200 i, F i \u27f6 G i) : Functor.pi F \u27f6 Functor.pi G where\n  app f i := (\u03b1 i).app (f i)", "start": [268, 1], "end": [272, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/Symmetric.lean", "imports": ["Mathlib/Combinatorics/Quiver/Push.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/Combinatorics/Quiver/Path.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver.Symmetrify", "code": "def Symmetrify (V : Type*) := V", "start": [30, 1], "end": [33, 32], "kind": "commanddeclaration"}, {"full_name": "Quiver.symmetrifyQuiver", "code": "instance symmetrifyQuiver (V : Type u) [Quiver V] : Quiver (Symmetrify V) :=\n  \u27e8fun a b : V \u21a6 Sum (a \u27f6 b) (b \u27f6 a)\u27e9", "start": [36, 1], "end": [37, 38], "kind": "commanddeclaration"}, {"full_name": "Quiver.HasReverse", "code": "class HasReverse where\n  \n  reverse' : \u2200 {a b : V}, (a \u27f6 b) \u2192 (b \u27f6 a)", "start": [41, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "Quiver.reverse", "code": "def reverse {V} [Quiver.{v + 1} V] [HasReverse V] {a b : V} : (a \u27f6 b) \u2192 (b \u27f6 a) :=\n  HasReverse.reverse'", "start": [48, 1], "end": [50, 22], "kind": "commanddeclaration"}, {"full_name": "Quiver.HasInvolutiveReverse", "code": "class HasInvolutiveReverse extends HasReverse V where\n  \n  inv' : \u2200 {a b : V} (f : a \u27f6 b), reverse (reverse f) = f", "start": [53, 1], "end": [56, 58], "kind": "commanddeclaration"}, {"full_name": "Quiver.reverse_reverse", "code": "@[simp]\ntheorem reverse_reverse [h : HasInvolutiveReverse V] {a b : V} (f : a \u27f6 b) :\n    reverse (reverse f) = f", "start": [61, 1], "end": [63, 47], "kind": "commanddeclaration"}, {"full_name": "Quiver.reverse_inj", "code": "@[simp]\ntheorem reverse_inj [h : HasInvolutiveReverse V] {a b : V}\n    (f g : a \u27f6 b) : reverse f = reverse g \u2194 f = g", "start": [66, 1], "end": [73, 10], "kind": "commanddeclaration"}, {"full_name": "Quiver.eq_reverse_iff", "code": "theorem eq_reverse_iff [h : HasInvolutiveReverse V] {a b : V} (f : a \u27f6 b)\n    (g : b \u27f6 a) : f = reverse g \u2194 reverse f = g", "start": [76, 1], "end": [78, 37], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.MapReverse", "code": "class _root_.Prefunctor.MapReverse (\u03c6 : U \u2964q V) : Prop where\n  \n  map_reverse' : \u2200 {u v : U} (e : u \u27f6 v), \u03c6.map (reverse e) = reverse (\u03c6.map e)", "start": [85, 1], "end": [88, 80], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.map_reverse", "code": "@[simp]\ntheorem _root_.Prefunctor.map_reverse (\u03c6 : U \u2964q V) [\u03c6.MapReverse]\n    {u v : U} (e : u \u27f6 v) : \u03c6.map (reverse e) = reverse (\u03c6.map e)", "start": [91, 1], "end": [94, 39], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapReverseComp", "code": "instance _root_.Prefunctor.mapReverseComp\n    (\u03c6 : U \u2964q V) (\u03c8 : V \u2964q W) [\u03c6.MapReverse] [\u03c8.MapReverse] :\n    (\u03c6 \u22d9q \u03c8).MapReverse where\n  map_reverse' e := by\n    simp only [Prefunctor.comp_map, Prefunctor.MapReverse.map_reverse']", "start": [97, 1], "end": [101, 72], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapReverseId", "code": "instance _root_.Prefunctor.mapReverseId :\n    (Prefunctor.id U).MapReverse where\n  map_reverse' _ := rfl", "start": [104, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "Quiver.symmetrify_reverse", "code": "@[simp]\ntheorem symmetrify_reverse {a b : Symmetrify V} (e : a \u27f6 b) : reverse e = e.swap", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.toPos", "code": "abbrev Hom.toPos {X Y : V} (f : X \u27f6 Y) : (Quiver.symmetrifyQuiver V).Hom X Y :=\n  Sum.inl f", "start": [127, 1], "end": [129, 12], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.toNeg", "code": "abbrev Hom.toNeg {X Y : V} (f : X \u27f6 Y) : (Quiver.symmetrifyQuiver V).Hom Y X :=\n  Sum.inr f", "start": [132, 1], "end": [134, 12], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.reverse", "code": "@[simp]\ndef Path.reverse [HasReverse V] {a : V} : \u2200 {b}, Path a b \u2192 Path b a\n  | _, Path.nil => Path.nil\n  | _, Path.cons p e => (Quiver.reverse e).toPath.comp p.reverse", "start": [137, 1], "end": [141, 65], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.reverse_toPath", "code": "@[simp]\ntheorem Path.reverse_toPath [HasReverse V] {a b : V} (f : a \u27f6 b) :\n    f.toPath.reverse = (Quiver.reverse f).toPath", "start": [144, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.reverse_comp", "code": "@[simp]\ntheorem Path.reverse_comp [HasReverse V] {a b c : V} (p : Path a b) (q : Path b c) :\n    (p.comp q).reverse = q.reverse.comp p.reverse", "start": [150, 1], "end": [155, 13], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.reverse_reverse", "code": "@[simp]\ntheorem Path.reverse_reverse [h : HasInvolutiveReverse V] {a b : V} (p : Path a b) :\n    p.reverse.reverse = p", "start": [158, 1], "end": [164, 8], "kind": "commanddeclaration"}, {"full_name": "Quiver.Symmetrify.of", "code": "def of : Prefunctor V (Symmetrify V) where\n  obj := id\n  map := Sum.inl", "start": [171, 1], "end": [174, 17], "kind": "commanddeclaration"}, {"full_name": "Quiver.Symmetrify.lift", "code": "def lift [HasReverse V'] (\u03c6 : Prefunctor V V') :\n    Prefunctor (Symmetrify V) V' where\n  obj := \u03c6.obj\n  map f := match f with\n  | Sum.inl g => \u03c6.map g\n  | Sum.inr g => reverse (\u03c6.map g)", "start": [179, 1], "end": [186, 35], "kind": "commanddeclaration"}, {"full_name": "Quiver.Symmetrify.lift_spec", "code": "theorem lift_spec [HasReverse V'] (\u03c6 : Prefunctor V V') :\n    Symmetrify.of.comp (Symmetrify.lift \u03c6) = \u03c6", "start": [189, 1], "end": [195, 8], "kind": "commanddeclaration"}, {"full_name": "Quiver.Symmetrify.lift_reverse", "code": "theorem lift_reverse [h : HasInvolutiveReverse V']\n    (\u03c6 : Prefunctor V V') {X Y : Symmetrify V} (f : X \u27f6 Y) :\n    (Symmetrify.lift \u03c6).map (Quiver.reverse f) = Quiver.reverse ((Symmetrify.lift \u03c6).map f)", "start": [198, 1], "end": [205, 8], "kind": "commanddeclaration"}, {"full_name": "Quiver.Symmetrify.lift_unique", "code": "theorem lift_unique [HasReverse V'] (\u03c6 : V \u2964q V') (\u03a6 : Symmetrify V \u2964q V') (h\u03a6 : (of \u22d9q \u03a6) = \u03c6)\n    (h\u03a6inv : \u2200 {X Y : Symmetrify V} (f : X \u27f6 Y),\n      \u03a6.map (Quiver.reverse f) = Quiver.reverse (\u03a6.map f)) :\n    \u03a6 = Symmetrify.lift \u03c6", "start": [208, 1], "end": [220, 30], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.symmetrify", "code": "@[simps]\ndef _root_.Prefunctor.symmetrify (\u03c6 : U \u2964q V) : Symmetrify U \u2964q Symmetrify V\n    where\n  obj := \u03c6.obj\n  map := Sum.map \u03c6.map \u03c6.map", "start": [223, 1], "end": [228, 29], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.symmetrify_mapReverse", "code": "instance _root_.Prefunctor.symmetrify_mapReverse (\u03c6 : U \u2964q V) :\n    Prefunctor.MapReverse \u03c6.symmetrify :=\n  \u27e8fun e => by cases e <;> rfl\u27e9", "start": [231, 1], "end": [233, 32], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.of_reverse", "code": "theorem of_reverse [HasInvolutiveReverse V] (X Y : V) (f : X \u27f6 Y) :\n    (reverse <| (Push.of \u03c3).map f) = (Push.of \u03c3).map (reverse f)", "start": [253, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.ofMapReverse", "code": "instance ofMapReverse [h : HasInvolutiveReverse V] : (Push.of \u03c3).MapReverse :=\n  \u27e8by simp [of_reverse]\u27e9", "start": [258, 1], "end": [259, 25], "kind": "commanddeclaration"}, {"full_name": "Quiver.IsPreconnected", "code": "def IsPreconnected (V) [Quiver.{u + 1} V] :=\n  \u2200 X Y : V, Nonempty (Path X Y)", "start": [264, 1], "end": [271, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Products/Basic.lean", "imports": ["Mathlib/CategoryTheory/Functor/Const.lean", "Mathlib/Data/Prod/Basic.lean", "Mathlib/CategoryTheory/EqToHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.prod", "code": "@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd]\ninstance prod : Category.{max v\u2081 v\u2082} (C \u00d7 D)\n    where\n  Hom X Y := (X.1 \u27f6 Y.1) \u00d7 (X.2 \u27f6 Y.2)\n  id X := \u27e8\ud835\udfd9 X.1, \ud835\udfd9 X.2\u27e9\n  comp f g := (f.1 \u226b g.1, f.2 \u226b g.2)", "start": [40, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod_id", "code": "@[simp]\ntheorem prod_id (X : C) (Y : D) : \ud835\udfd9 (X, Y) = (\ud835\udfd9 X, \ud835\udfd9 Y)", "start": [52, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod_comp", "code": "@[simp]\ntheorem prod_comp {P Q R : C} {S T U : D} (f : (P, S) \u27f6 (Q, T)) (g : (Q, T) \u27f6 (R, U)) :\n    f \u226b g = (f.1 \u226b g.1, f.2 \u226b g.2)", "start": [58, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_prod_iff", "code": "theorem isIso_prod_iff {P Q : C} {S T : D} {f : (P, S) \u27f6 (Q, T)} :\n    IsIso f \u2194 IsIso f.1 \u2227 IsIso f.2", "start": [64, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod.etaIso", "code": "@[simps]\ndef prod.etaIso (X : C \u00d7 D) : (X.1, X.2) \u2245 X\n    where\n  hom := (\ud835\udfd9 _, \ud835\udfd9 _)\n  inv := (\ud835\udfd9 _, \ud835\udfd9 _)", "start": [82, 1], "end": [87, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.prod", "code": "@[simps]\ndef Iso.prod {P Q : C} {S T : D} (f : P \u2245 Q) (g : S \u2245 T) : (P, S) \u2245 (Q, T)\n    where\n  hom := (f.hom, g.hom)\n  inv := (f.inv, g.inv)", "start": [90, 1], "end": [95, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uniformProd", "code": "instance uniformProd : Category (C \u00d7 D) :=\n  CategoryTheory.prod C D", "start": [106, 1], "end": [110, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.sectl", "code": "@[simps]\ndef sectl (C : Type u\u2081) [Category.{v\u2081} C] {D : Type u\u2082} [Category.{v\u2082} D] (Z : D) : C \u2964 C \u00d7 D\n    where\n  obj X := (X, Z)\n  map f := (f, \ud835\udfd9 Z)", "start": [119, 1], "end": [124, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.sectr", "code": "@[simps]\ndef sectr {C : Type u\u2081} [Category.{v\u2081} C] (Z : C) (D : Type u\u2082) [Category.{v\u2082} D] : D \u2964 C \u00d7 D\n    where\n  obj X := (Z, X)\n  map f := (\ud835\udfd9 Z, f)", "start": [127, 1], "end": [132, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.fst", "code": "@[simps]\ndef fst : C \u00d7 D \u2964 C where\n  obj X := X.1\n  map f := f.1", "start": [137, 1], "end": [141, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.snd", "code": "@[simps]\ndef snd : C \u00d7 D \u2964 D where\n  obj X := X.2\n  map f := f.2", "start": [144, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.swap", "code": "@[simps]\ndef swap : C \u00d7 D \u2964 D \u00d7 C where\n  obj X := (X.2, X.1)\n  map f := (f.2, f.1)", "start": [151, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.symmetry", "code": "@[simps]\ndef symmetry : swap C D \u22d9 swap D C \u2245 \ud835\udfed (C \u00d7 D)\n    where\n  hom := { app := fun X => \ud835\udfd9 X }\n  inv := { app := fun X => \ud835\udfd9 X }", "start": [158, 1], "end": [165, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.braiding", "code": "@[simps!]\ndef braiding : C \u00d7 D \u224c D \u00d7 C :=\n  Equivalence.mk (swap C D) (swap D C)\n    (NatIso.ofComponents fun X => eqToIso (by simp))\n    (NatIso.ofComponents fun X => eqToIso (by simp))", "start": [168, 1], "end": [174, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Prod.swapIsEquivalence", "code": "instance swapIsEquivalence : IsEquivalence (swap C D) :=\n  (by infer_instance : IsEquivalence (braiding C D).functor)", "start": [177, 1], "end": [178, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.evaluation", "code": "@[simps]\ndef evaluation : C \u2964 (C \u2964 D) \u2964 D where\n  obj X :=\n    { obj := fun F => F.obj X\n      map := fun \u03b1 => \u03b1.app X }\n  map {X} {Y} f :=\n    { app := fun F => F.map f\n      naturality := fun {F} {G} \u03b1 => Eq.symm (\u03b1.naturality f) }", "start": [187, 1], "end": [198, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.evaluationUncurried", "code": "@[simps]\ndef evaluationUncurried : C \u00d7 (C \u2964 D) \u2964 D where\n  obj p := p.2.obj p.1\n  map := fun {x} {y} f => x.2.map f.1 \u226b f.2.app y.1\n  map_comp := fun {X} {Y} {Z} f g => by\n    cases g; cases f; cases Z; cases Y; cases X\n    simp only [prod_comp, NatTrans.comp_app, Functor.map_comp, Category.assoc]\n    rw [\u2190 NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app, Category.assoc,\n      NatTrans.naturality]", "start": [201, 1], "end": [212, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.constCompEvaluationObj", "code": "@[simps!]\ndef Functor.constCompEvaluationObj (X : C) : Functor.const C \u22d9 (evaluation C D).obj X \u2245 \ud835\udfed D :=\n  NatIso.ofComponents fun Y => Iso.refl _", "start": [217, 1], "end": [220, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.prod", "code": "@[simps]\ndef prod (F : A \u2964 B) (G : C \u2964 D) : A \u00d7 C \u2964 B \u00d7 D where\n  obj X := (F.obj X.1, G.obj X.2)\n  map f := (F.map f.1, G.map f.2)", "start": [230, 1], "end": [234, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.prod'", "code": "@[simps]\ndef prod' (F : A \u2964 B) (G : A \u2964 C) : A \u2964 B \u00d7 C where\n  obj a := (F.obj a, G.obj a)\n  map f := (F.map f, G.map f)", "start": [239, 1], "end": [243, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.prod'CompFst", "code": "@[simps!]\ndef prod'CompFst (F : A \u2964 B) (G : A \u2964 C) : F.prod' G \u22d9 CategoryTheory.Prod.fst B C \u2245 F :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [246, 1], "end": [249, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.prod'CompSnd", "code": "@[simps!]\ndef prod'CompSnd (F : A \u2964 B) (G : A \u2964 C) : F.prod' G \u22d9 CategoryTheory.Prod.snd B C \u2245 G :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [252, 1], "end": [255, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.diag", "code": "def diag : C \u2964 C \u00d7 C :=\n  (\ud835\udfed C).prod' (\ud835\udfed C)", "start": [262, 1], "end": [264, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.diag_obj", "code": "@[simp]\ntheorem diag_obj (X : C) : (diag C).obj X = (X, X)", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.diag_map", "code": "@[simp]\ntheorem diag_map {X Y : C} (f : X \u27f6 Y) : (diag C).map f = (f, f)", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.prod", "code": "@[simps]\ndef prod {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) : F.prod H \u27f6 G.prod I\n    where\n  app X := (\u03b1.app X.1, \u03b2.app X.2)\n  naturality {X} {Y} f := by\n    cases X; cases Y\n    simp only [Functor.prod_map, prod_comp]\n    rw [Prod.mk.inj_iff]\n    constructor\n    repeat {rw [naturality]}", "start": [283, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.flipCompEvaluation", "code": "@[simps!]\ndef flipCompEvaluation (F : A \u2964 B \u2964 C) (a) : F.flip \u22d9 (evaluation _ _).obj a \u2245 F.obj a :=\n  NatIso.ofComponents fun b => eqToIso rfl", "start": [300, 1], "end": [303, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodFunctorToFunctorProd", "code": "@[simps]\ndef prodFunctorToFunctorProd : (A \u2964 B) \u00d7 (A \u2964 C) \u2964 A \u2964 B \u00d7 C\n    where\n  obj F := F.1.prod' F.2\n  map f := { app := fun X => (f.1.app X, f.2.app X) }", "start": [308, 1], "end": [313, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorProdToProdFunctor", "code": "@[simps]\ndef functorProdToProdFunctor : (A \u2964 B \u00d7 C) \u2964 (A \u2964 B) \u00d7 (A \u2964 C)\n    where\n  obj F := \u27e8F \u22d9 CategoryTheory.Prod.fst B C, F \u22d9 CategoryTheory.Prod.snd B C\u27e9\n  map \u03b1 :=\n    \u27e8{  app := fun X => (\u03b1.app X).1\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.fst_map, \u2190 prod_comp_fst, \u03b1.naturality] },\n      { app := fun X => (\u03b1.app X).2\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.snd_map, \u2190 prod_comp_snd, \u03b1.naturality] }\u27e9", "start": [316, 1], "end": [327, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorProdFunctorEquivUnitIso", "code": "@[simps!]\ndef functorProdFunctorEquivUnitIso :\n    \ud835\udfed _ \u2245 prodFunctorToFunctorProd A B C \u22d9 functorProdToProdFunctor A B C :=\n  NatIso.ofComponents fun F =>\n    (((Functor.prod'CompFst F.fst F.snd).prod (Functor.prod'CompSnd F.fst F.snd)).trans\n      (prod.etaIso F)).symm", "start": [330, 1], "end": [336, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorProdFunctorEquivCounitIso", "code": "@[simps!]\ndef functorProdFunctorEquivCounitIso :\n    functorProdToProdFunctor A B C \u22d9 prodFunctorToFunctorProd A B C \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents fun F => NatIso.ofComponents fun X => prod.etaIso (F.obj X)", "start": [339, 1], "end": [343, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorProdFunctorEquiv", "code": "@[simps]\ndef functorProdFunctorEquiv : (A \u2964 B) \u00d7 (A \u2964 C) \u224c A \u2964 B \u00d7 C :=\n  { functor := prodFunctorToFunctorProd A B C,\n    inverse := functorProdToProdFunctor A B C,\n    unitIso := functorProdFunctorEquivUnitIso A B C,\n    counitIso := functorProdFunctorEquivCounitIso A B C, }", "start": [346, 1], "end": [352, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finite/Card.lean", "imports": ["Mathlib/SetTheory/Cardinal/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finite.equivFin", "code": "def Finite.equivFin (\u03b1 : Type*) [Finite \u03b1] : \u03b1 \u2243 Fin (Nat.card \u03b1) := by\n  have := (Finite.exists_equiv_fin \u03b1).choose_spec.some\n  rwa [Nat.card_eq_of_equiv_fin this]", "start": [37, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "Finite.equivFinOfCardEq", "code": "def Finite.equivFinOfCardEq [Finite \u03b1] {n : \u2115} (h : Nat.card \u03b1 = n) : \u03b1 \u2243 Fin n := by\n  subst h\n  apply Finite.equivFin", "start": [43, 1], "end": [46, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq", "code": "theorem Nat.card_eq (\u03b1 : Type*) :\n    Nat.card \u03b1 = if h : Finite \u03b1 then @Fintype.card \u03b1 (Fintype.ofFinite \u03b1) else 0", "start": [49, 1], "end": [54, 85], "kind": "commanddeclaration"}, {"full_name": "Finite.card_pos_iff", "code": "theorem Finite.card_pos_iff [Finite \u03b1] : 0 < Nat.card \u03b1 \u2194 Nonempty \u03b1", "start": [57, 1], "end": [59, 54], "kind": "commanddeclaration"}, {"full_name": "Finite.card_pos", "code": "theorem Finite.card_pos [Finite \u03b1] [h : Nonempty \u03b1] : 0 < Nat.card \u03b1", "start": [62, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "Finite.cast_card_eq_mk", "code": "theorem cast_card_eq_mk {\u03b1 : Type*} [Finite \u03b1] : \u2191(Nat.card \u03b1) = Cardinal.mk \u03b1", "start": [68, 1], "end": [69, 68], "kind": "commanddeclaration"}, {"full_name": "Finite.card_eq", "code": "theorem card_eq [Finite \u03b1] [Finite \u03b2] : Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "start": [72, 1], "end": [75, 56], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_one_iff_subsingleton", "code": "theorem card_le_one_iff_subsingleton [Finite \u03b1] : Nat.card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "start": [78, 1], "end": [80, 77], "kind": "commanddeclaration"}, {"full_name": "Finite.one_lt_card_iff_nontrivial", "code": "theorem one_lt_card_iff_nontrivial [Finite \u03b1] : 1 < Nat.card \u03b1 \u2194 Nontrivial \u03b1", "start": [83, 1], "end": [85, 75], "kind": "commanddeclaration"}, {"full_name": "Finite.one_lt_card", "code": "theorem one_lt_card [Finite \u03b1] [h : Nontrivial \u03b1] : 1 < Nat.card \u03b1", "start": [88, 1], "end": [89, 35], "kind": "commanddeclaration"}, {"full_name": "Finite.card_option", "code": "@[simp]\ntheorem card_option [Finite \u03b1] : Nat.card (Option \u03b1) = Nat.card \u03b1 + 1", "start": [92, 1], "end": [95, 60], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_injective", "code": "theorem card_le_of_injective [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) :\n    Nat.card \u03b1 \u2264 Nat.card \u03b2", "start": [98, 1], "end": [102, 91], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_embedding", "code": "theorem card_le_of_embedding [Finite \u03b2] (f : \u03b1 \u21aa \u03b2) : Nat.card \u03b1 \u2264 Nat.card \u03b2", "start": [105, 1], "end": [106, 37], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_surjective", "code": "theorem card_le_of_surjective [Finite \u03b1] (f : \u03b1 \u2192 \u03b2) (hf : Function.Surjective f) :\n    Nat.card \u03b2 \u2264 Nat.card \u03b1", "start": [109, 1], "end": [113, 92], "kind": "commanddeclaration"}, {"full_name": "Finite.card_eq_zero_iff", "code": "theorem card_eq_zero_iff [Finite \u03b1] : Nat.card \u03b1 = 0 \u2194 IsEmpty \u03b1", "start": [116, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_injective'", "code": "theorem card_le_of_injective' {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)\n    (h : Nat.card \u03b2 = 0 \u2192 Nat.card \u03b1 = 0) : Nat.card \u03b1 \u2264 Nat.card \u03b2", "start": [121, 1], "end": [126, 66], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_embedding'", "code": "theorem card_le_of_embedding' (f : \u03b1 \u21aa \u03b2) (h : Nat.card \u03b2 = 0 \u2192 Nat.card \u03b1 = 0) :\n    Nat.card \u03b1 \u2264 Nat.card \u03b2", "start": [129, 1], "end": [133, 30], "kind": "commanddeclaration"}, {"full_name": "Finite.card_le_of_surjective'", "code": "theorem card_le_of_surjective' {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f)\n    (h : Nat.card \u03b1 = 0 \u2192 Nat.card \u03b2 = 0) : Nat.card \u03b2 \u2264 Nat.card \u03b1", "start": [136, 1], "end": [141, 67], "kind": "commanddeclaration"}, {"full_name": "Finite.card_eq_zero_of_surjective", "code": "theorem card_eq_zero_of_surjective {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) (h : Nat.card \u03b2 = 0) :\n    Nat.card \u03b1 = 0", "start": [144, 1], "end": [152, 39], "kind": "commanddeclaration"}, {"full_name": "Finite.card_eq_zero_of_injective", "code": "theorem card_eq_zero_of_injective [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)\n    (h : Nat.card \u03b1 = 0) : Nat.card \u03b2 = 0", "start": [155, 1], "end": [158, 63], "kind": "commanddeclaration"}, {"full_name": "Finite.card_eq_zero_of_embedding", "code": "theorem card_eq_zero_of_embedding [Nonempty \u03b1] (f : \u03b1 \u21aa \u03b2) (h : Nat.card \u03b1 = 0) : Nat.card \u03b2 = 0", "start": [161, 1], "end": [163, 34], "kind": "commanddeclaration"}, {"full_name": "Finite.card_sum", "code": "theorem card_sum [Finite \u03b1] [Finite \u03b2] : Nat.card (Sum \u03b1 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2", "start": [166, 1], "end": [169, 57], "kind": "commanddeclaration"}, {"full_name": "Finite.card_image_le", "code": "theorem card_image_le {s : Set \u03b1} [Finite s] (f : \u03b1 \u2192 \u03b2) : Nat.card (f '' s) \u2264 Nat.card s", "start": [172, 1], "end": [173, 52], "kind": "commanddeclaration"}, {"full_name": "Finite.card_range_le", "code": "theorem card_range_le [Finite \u03b1] (f : \u03b1 \u2192 \u03b2) : Nat.card (Set.range f) \u2264 Nat.card \u03b1", "start": [176, 1], "end": [177, 52], "kind": "commanddeclaration"}, {"full_name": "Finite.card_subtype_le", "code": "theorem card_subtype_le [Finite \u03b1] (p : \u03b1 \u2192 Prop) : Nat.card { x // p x } \u2264 Nat.card \u03b1", "start": [180, 1], "end": [182, 83], "kind": "commanddeclaration"}, {"full_name": "Finite.card_subtype_lt", "code": "theorem card_subtype_lt [Finite \u03b1] {p : \u03b1 \u2192 Prop} {x : \u03b1} (hx : \u00acp x) :\n    Nat.card { x // p x } < Nat.card \u03b1", "start": [185, 1], "end": [188, 84], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_eq_coe_nat_card", "code": "theorem card_eq_coe_nat_card (\u03b1 : Type*) [Finite \u03b1] : card \u03b1 = Nat.card \u03b1", "start": [195, 1], "end": [199, 31], "kind": "commanddeclaration"}, {"full_name": "Set.card_union_le", "code": "theorem card_union_le (s t : Set \u03b1) : Nat.card (\u21a5(s \u222a t)) \u2264 Nat.card s + Nat.card t", "start": [206, 1], "end": [213, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Coeff.lean", "imports": ["Mathlib/Data/Finset/NatAntidiagonal.lean", "Mathlib/Algebra/Regular/Pow.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Data/Polynomial/Basic.lean"], "premises": [{"full_name": "Polynomial.coeff_add", "code": "@[simp]\ntheorem coeff_add (p q : R[X]) (n : \u2115) : coeff (p + q) n = coeff p n + coeff q n", "start": [40, 1], "end": [45, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_bit0", "code": "@[simp]\ntheorem coeff_bit0 (p : R[X]) (n : \u2115) : coeff (bit0 p) n = bit0 (coeff p n)", "start": [49, 1], "end": [50, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_smul", "code": "@[simp]\ntheorem coeff_smul [SMulZeroClass S R] (r : S) (p : R[X]) (n : \u2115) :\n    coeff (r \u2022 p) n = r \u2022 coeff p n", "start": [53, 1], "end": [58, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_smul", "code": "theorem support_smul [Monoid S] [DistribMulAction S R] (r : S) (p : R[X]) :\n    support (r \u2022 p) \u2286 support p", "start": [61, 1], "end": [66, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lsum", "code": "@[simps]\ndef lsum {R A M : Type*} [Semiring R] [Semiring A] [AddCommMonoid M] [Module R A] [Module R M]\n    (f : \u2115 \u2192 A \u2192\u2097[R] M) : A[X] \u2192\u2097[R] M\n    where\n  toFun p := p.sum (f \u00b7 \u00b7)\n  map_add' p q := sum_add_index p q _ (fun n => (f n).map_zero) fun n _ _ => (f n).map_add _ _\n  map_smul' c p := by\n    dsimp only []\n    rw [sum_eq_of_subset (f \u00b7 \u00b7) (fun n => (f n).map_zero) (support_smul c p)]\n    simp only [sum_def, Finset.smul_sum, coeff_smul, LinearMap.map_smul, RingHom.id_apply]", "start": [69, 1], "end": [80, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lcoeff", "code": "def lcoeff (n : \u2115) : R[X] \u2192\u2097[R] R where\n  toFun p := coeff p n\n  map_add' p q := coeff_add p q n\n  map_smul' r p := coeff_smul r p n", "start": [86, 1], "end": [90, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lcoeff_apply", "code": "@[simp]\ntheorem lcoeff_apply (n : \u2115) (f : R[X]) : lcoeff R n f = coeff f n", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.finset_sum_coeff", "code": "@[simp]\ntheorem finset_sum_coeff {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) (n : \u2115) :\n    coeff (\u2211 b in s, f b) n = \u2211 b in s, coeff (f b) n", "start": [100, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_sum", "code": "theorem coeff_sum [Semiring S] (n : \u2115) (f : \u2115 \u2192 R \u2192 S[X]) :\n    coeff (p.sum f) n = p.sum fun a b => coeff (f a b) n", "start": [106, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul", "code": "theorem coeff_mul (p q : R[X]) (n : \u2115) :\n    coeff (p * q) n = \u2211 x in Nat.antidiagonal n, coeff p x.1 * coeff q x.2", "start": [113, 1], "end": [120, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_coeff_zero", "code": "@[simp]\ntheorem mul_coeff_zero (p q : R[X]) : coeff (p * q) 0 = coeff p 0 * coeff q 0", "start": [123, 1], "end": [124, 101], "kind": "commanddeclaration"}, {"full_name": "Polynomial.constantCoeff", "code": "@[simps]\ndef constantCoeff : R[X] \u2192+* R where\n  toFun p := coeff p 0\n  map_one' := coeff_one_zero\n  map_mul' := mul_coeff_zero\n  map_zero' := coeff_zero 0\n  map_add' p q := coeff_add p q 0", "start": [127, 1], "end": [135, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_C", "code": "theorem isUnit_C {x : R} : IsUnit (C x) \u2194 IsUnit x", "start": [139, 1], "end": [140, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_X_zero", "code": "theorem coeff_mul_X_zero (p : R[X]) : coeff (p * X) 0 = 0", "start": [143, 1], "end": [143, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_mul_zero", "code": "theorem coeff_X_mul_zero (p : R[X]) : coeff (X * p) 0 = 0", "start": [146, 1], "end": [146, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_mul_X_pow", "code": "theorem coeff_C_mul_X_pow (x : R) (k n : \u2115) :\n    coeff (C x * X ^ k : R[X]) n = if n = k then x else 0", "start": [149, 1], "end": [153, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_mul_X", "code": "theorem coeff_C_mul_X (x : R) (n : \u2115) : coeff (C x * X : R[X]) n = if n = 1 then x else 0", "start": [156, 1], "end": [157, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_mul", "code": "@[simp]\ntheorem coeff_C_mul (p : R[X]) : coeff (C a * p) n = a * coeff p n", "start": [160, 1], "end": [164, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul'", "code": "theorem C_mul' (a : R) (f : R[X]) : C a * f = a \u2022 f", "start": [167, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_C", "code": "@[simp]\ntheorem coeff_mul_C (p : R[X]) (n : \u2115) (a : R) : coeff (p * C a) n = coeff p n * a", "start": [172, 1], "end": [176, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_natCast", "code": "@[simp] lemma coeff_mul_natCast {a k : \u2115} :\n  coeff (p * (a : R[X])) k = coeff p k * (\u2191a : R) := coeff_mul_C _ _ _", "start": [179, 1], "end": [180, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_natCast_mul", "code": "@[simp] lemma coeff_natCast_mul {a k : \u2115} :\n  coeff ((a : R[X]) * p) k = a * coeff p k := coeff_C_mul _", "start": [182, 1], "end": [183, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_mul_ofNat", "code": "@[simp] lemma coeff_mul_ofNat {a k : \u2115} [Nat.AtLeastTwo a] :\n  coeff (p * (no_index (OfNat.ofNat a) : R[X])) k = coeff p k * OfNat.ofNat a := coeff_mul_C _ _ _", "start": [185, 1], "end": [186, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_ofNat_mul", "code": "@[simp] lemma coeff_ofNat_mul {a k : \u2115} [Nat.AtLeastTwo a] :\n  coeff ((no_index (OfNat.ofNat a) : R[X]) * p) k = OfNat.ofNat a * coeff p k := coeff_C_mul _", "start": [188, 1], "end": [189, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_mul_intCast", "code": "@[simp] lemma coeff_mul_intCast [Ring S] {p : S[X]} {a : \u2124} {k : \u2115} :\n  coeff (p * (a : S[X])) k = coeff p k * (\u2191a : S) := coeff_mul_C _ _ _", "start": [191, 1], "end": [192, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_intCast_mul", "code": "@[simp] lemma coeff_intCast_mul [Ring S] {p : S[X]} {a : \u2124} {k : \u2115} :\n  coeff ((a : S[X]) * p) k = a * coeff p k := coeff_C_mul _", "start": [194, 1], "end": [195, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_X_pow", "code": "@[simp]\ntheorem coeff_X_pow (k n : \u2115) : coeff (X ^ k : R[X]) n = if n = k then 1 else 0", "start": [197, 1], "end": [199, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_pow_self", "code": "theorem coeff_X_pow_self (n : \u2115) : coeff (X ^ n : R[X]) n = 1", "start": [202, 1], "end": [202, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_binomial", "code": "theorem support_binomial {k m : \u2115} (hkm : k \u2260 m) {x y : R} (hx : x \u2260 0) (hy : y \u2260 0) :\n    support (C x * X ^ k + C y * X ^ m) = {k, m}", "start": [209, 1], "end": [214, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_trinomial", "code": "theorem support_trinomial {k m n : \u2115} (hkm : k < m) (hmn : m < n) {x y z : R} (hx : x \u2260 0)\n    (hy : y \u2260 0) (hz : z \u2260 0) :\n    support (C x * X ^ k + C y * X ^ m + C z * X ^ n) = {k, m, n}", "start": [217, 1], "end": [224, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_binomial", "code": "theorem card_support_binomial {k m : \u2115} (h : k \u2260 m) {x y : R} (hx : x \u2260 0) (hy : y \u2260 0) :\n    card (support (C x * X ^ k + C y * X ^ m)) = 2", "start": [227, 1], "end": [229, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_trinomial", "code": "theorem card_support_trinomial {k m n : \u2115} (hkm : k < m) (hmn : m < n) {x y z : R} (hx : x \u2260 0)\n    (hy : y \u2260 0) (hz : z \u2260 0) : card (support (C x * X ^ k + C y * X ^ m + C z * X ^ n)) = 3", "start": [232, 1], "end": [237, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_X_pow", "code": "@[simp]\ntheorem coeff_mul_X_pow (p : R[X]) (n d : \u2115) :\n    coeff (p * Polynomial.X ^ n) (d + n) = coeff p d", "start": [242, 1], "end": [253, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_pow_mul", "code": "@[simp]\ntheorem coeff_X_pow_mul (p : R[X]) (n d : \u2115) : coeff (Polynomial.X ^ n * p) (d + n) = coeff p d", "start": [256, 1], "end": [258, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_X_pow'", "code": "theorem coeff_mul_X_pow' (p : R[X]) (n d : \u2115) :\n    (p * X ^ n).coeff d = ite (n \u2264 d) (p.coeff (d - n)) 0", "start": [261, 1], "end": [267, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_pow_mul'", "code": "theorem coeff_X_pow_mul' (p : R[X]) (n d : \u2115) :\n    (X ^ n * p).coeff d = ite (n \u2264 d) (p.coeff (d - n)) 0", "start": [270, 1], "end": [272, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_X", "code": "@[simp]\ntheorem coeff_mul_X (p : R[X]) (n : \u2115) : coeff (p * X) (n + 1) = coeff p n", "start": [275, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_mul", "code": "@[simp]\ntheorem coeff_X_mul (p : R[X]) (n : \u2115) : coeff (X * p) (n + 1) = coeff p n", "start": [280, 1], "end": [282, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_monomial", "code": "theorem coeff_mul_monomial (p : R[X]) (n d : \u2115) (r : R) :\n    coeff (p * monomial n r) (d + n) = coeff p d * r", "start": [285, 1], "end": [287, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_monomial_mul", "code": "theorem coeff_monomial_mul (p : R[X]) (n d : \u2115) (r : R) :\n    coeff (monomial n r * p) (d + n) = r * coeff p d", "start": [290, 1], "end": [292, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_monomial_zero", "code": "theorem coeff_mul_monomial_zero (p : R[X]) (d : \u2115) (r : R) :\n    coeff (p * monomial 0 r) d = coeff p d * r", "start": [296, 1], "end": [298, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_monomial_zero_mul", "code": "theorem coeff_monomial_zero_mul (p : R[X]) (d : \u2115) (r : R) :\n    coeff (monomial 0 r * p) d = r * coeff p d", "start": [302, 1], "end": [304, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_X_pow_eq_zero", "code": "theorem mul_X_pow_eq_zero {p : R[X]} {n : \u2115} (H : p * X ^ n = 0) : p = 0", "start": [307, 1], "end": [308, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRegular_X", "code": "@[simp] theorem isRegular_X : IsRegular (X : R[X])", "start": [311, 1], "end": [316, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRegular_X_pow", "code": "theorem isRegular_X_pow (n : \u2115) : IsRegular (X ^ n : R[X])", "start": [319, 1], "end": [319, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_add_C_pow", "code": "theorem coeff_X_add_C_pow (r : R) (n k : \u2115) :\n    ((X + C r) ^ n).coeff k = r ^ (n - k) * (n.choose k : R)", "start": [321, 1], "end": [330, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_add_one_pow", "code": "theorem coeff_X_add_one_pow (R : Type*) [Semiring R] (n k : \u2115) :\n    ((X + 1) ^ n).coeff k = (n.choose k : R)", "start": [333, 1], "end": [334, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_one_add_X_pow", "code": "theorem coeff_one_add_X_pow (R : Type*) [Semiring R] (n k : \u2115) :\n    ((1 + X) ^ n).coeff k = (n.choose k : R)", "start": [337, 1], "end": [338, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_dvd_iff_dvd_coeff", "code": "theorem C_dvd_iff_dvd_coeff (r : R) (\u03c6 : R[X]) : C r \u2223 \u03c6 \u2194 \u2200 i, r \u2223 \u03c6.coeff i", "start": [341, 1], "end": [358, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_bit0_mul", "code": "theorem coeff_bit0_mul (P Q : R[X]) (n : \u2115) : coeff (bit0 P * Q) n = 2 * coeff (P * Q) n", "start": [362, 1], "end": [364, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_bit1_mul", "code": "theorem coeff_bit1_mul (P Q : R[X]) (n : \u2115) :\n    coeff (bit1 P * Q) n = 2 * coeff (P * Q) n + coeff Q n", "start": [368, 1], "end": [370, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_eq_C_mul", "code": "theorem smul_eq_C_mul (a : R) : a \u2022 p = C a * p", "start": [373, 1], "end": [373, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.update_eq_add_sub_coeff", "code": "theorem update_eq_add_sub_coeff {R : Type*} [Ring R] (p : R[X]) (n : \u2115) (a : R) :\n    p.update n a = p + Polynomial.C (a - p.coeff n) * Polynomial.X ^ n", "start": [376, 1], "end": [380, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nat_cast_coeff_zero", "code": "theorem nat_cast_coeff_zero {n : \u2115} {R : Type*} [Semiring R] : (n : R[X]).coeff 0 = n", "start": [387, 1], "end": [388, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nat_cast_inj", "code": "@[norm_cast] theorem nat_cast_inj {m n : \u2115} {R : Type*} [Semiring R] [CharZero R] :\n    (\u2191m : R[X]) = \u2191n \u2194 m = n", "start": [391, 1], "end": [399, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.int_cast_coeff_zero", "code": "@[simp]\ntheorem int_cast_coeff_zero {i : \u2124} {R : Type*} [Ring R] : (i : R[X]).coeff 0 = i", "start": [402, 1], "end": [404, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.int_cast_inj", "code": "@[norm_cast] theorem int_cast_inj {m n : \u2124} {R : Type*} [Ring R] [CharZero R] : (\u2191m : R[X]) = \u2191n \u2194 m = n", "start": [407, 1], "end": [414, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.charZero", "code": "instance charZero [CharZero R] : CharZero R[X] where cast_injective _x _y := nat_cast_inj.mp", "start": [419, 1], "end": [419, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/WithBot.lean", "imports": ["Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Data/Nat/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.WithBot.add_eq_zero_iff", "code": "theorem add_eq_zero_iff {n m : WithBot \u2115} : n + m = 0 \u2194 n = 0 \u2227 m = 0", "start": [27, 1], "end": [32, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.add_eq_one_iff", "code": "theorem add_eq_one_iff {n m : WithBot \u2115} : n + m = 1 \u2194 n = 0 \u2227 m = 1 \u2228 n = 1 \u2227 m = 0", "start": [35, 1], "end": [39, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.add_eq_two_iff", "code": "theorem add_eq_two_iff {n m : WithBot \u2115} :\n    n + m = 2 \u2194 n = 0 \u2227 m = 2 \u2228 n = 1 \u2227 m = 1 \u2228 n = 2 \u2227 m = 0", "start": [42, 1], "end": [47, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.add_eq_three_iff", "code": "theorem add_eq_three_iff {n m : WithBot \u2115} :\n    n + m = 3 \u2194 n = 0 \u2227 m = 3 \u2228 n = 1 \u2227 m = 2 \u2228 n = 2 \u2227 m = 1 \u2228 n = 3 \u2227 m = 0", "start": [50, 1], "end": [55, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.coe_nonneg", "code": "theorem coe_nonneg {n : \u2115} : 0 \u2264 (n : WithBot \u2115)", "start": [58, 1], "end": [60, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.lt_zero_iff", "code": "@[simp]\ntheorem lt_zero_iff (n : WithBot \u2115) : n < 0 \u2194 n = \u22a5", "start": [63, 1], "end": [73, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.one_le_iff_zero_lt", "code": "theorem one_le_iff_zero_lt {x : WithBot \u2115} : 1 \u2264 x \u2194 0 < x", "start": [76, 1], "end": [80, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.lt_one_iff_le_zero", "code": "theorem lt_one_iff_le_zero {x : WithBot \u2115} : x < 1 \u2194 x \u2264 0", "start": [83, 1], "end": [84, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.WithBot.add_one_le_of_lt", "code": "theorem add_one_le_of_lt {n m : WithBot \u2115} (h : n < m) : n + 1 \u2264 m", "start": [87, 1], "end": [91, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Degree.lean", "imports": ["Mathlib/Algebra/MonoidAlgebra/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddMonoidAlgebra.sup_support_add_le", "code": "theorem sup_support_add_le : (f + g).support.sup degb \u2264 f.support.sup degb \u2294 g.support.sup degb", "start": [87, 1], "end": [88, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_add", "code": "theorem le_inf_support_add : f.support.inf degt \u2293 g.support.inf degt \u2264 (f + g).support.inf degt", "start": [91, 1], "end": [92, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sup_support_mul_le", "code": "theorem sup_support_mul_le {degb : A \u2192 B} (degbm : \u2200 {a b}, degb (a + b) \u2264 degb a + degb b)\n    (f g : R[A]) :\n    (f * g).support.sup degb \u2264 f.support.sup degb + g.support.sup degb", "start": [103, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_mul", "code": "theorem le_inf_support_mul {degt : A \u2192 T} (degtm : \u2200 {a b}, degt a + degt b \u2264 degt (a + b))\n    (f g : R[A]) :\n    f.support.inf degt + g.support.inf degt \u2264 (f * g).support.inf degt", "start": [112, 1], "end": [117, 46], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sup_support_list_prod_le", "code": "theorem sup_support_list_prod_le (degb0 : degb 0 \u2264 0)\n    (degbm : \u2200 a b, degb (a + b) \u2264 degb a + degb b) :\n    \u2200 l : List R[A],\n      l.prod.support.sup degb \u2264 (l.map fun f : R[A] => f.support.sup degb).sum", "start": [129, 1], "end": [139, 70], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_list_prod", "code": "theorem le_inf_support_list_prod (degt0 : 0 \u2264 degt 0)\n    (degtm : \u2200 a b, degt a + degt b \u2264 degt (a + b)) (l : List R[A]) :\n    (l.map fun f : R[A] => f.support.inf degt).sum \u2264 l.prod.support.inf degt", "start": [142, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sup_support_pow_le", "code": "theorem sup_support_pow_le (degb0 : degb 0 \u2264 0) (degbm : \u2200 a b, degb (a + b) \u2264 degb a + degb b)\n    (n : \u2115) (f : R[A]) : (f ^ n).support.sup degb \u2264 n \u2022 f.support.sup degb", "start": [153, 1], "end": [157, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_pow", "code": "theorem le_inf_support_pow (degt0 : 0 \u2264 degt 0) (degtm : \u2200 a b, degt a + degt b \u2264 degt (a + b))\n    (n : \u2115) (f : R[A]) : n \u2022 f.support.inf degt \u2264 (f ^ n).support.inf degt", "start": [160, 1], "end": [165, 18], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sup_support_multiset_prod_le", "code": "theorem sup_support_multiset_prod_le (degb0 : degb 0 \u2264 0)\n    (degbm : \u2200 a b, degb (a + b) \u2264 degb a + degb b) (m : Multiset R[A]) :\n    m.prod.support.sup degb \u2264 (m.map fun f : R[A] => f.support.sup degb).sum", "start": [179, 1], "end": [184, 47], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_multiset_prod", "code": "theorem le_inf_support_multiset_prod (degt0 : 0 \u2264 degt 0)\n    (degtm : \u2200 a b, degt a + degt b \u2264 degt (a + b)) (m : Multiset R[A]) :\n    (m.map fun f : R[A] => f.support.inf degt).sum \u2264 m.prod.support.inf degt", "start": [187, 1], "end": [194, 18], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sup_support_finset_prod_le", "code": "theorem sup_support_finset_prod_le (degb0 : degb 0 \u2264 0)\n    (degbm : \u2200 a b, degb (a + b) \u2264 degb a + degb b) (s : Finset \u03b9) (f : \u03b9 \u2192 R[A]) :\n    (\u220f i in s, f i).support.sup degb \u2264 \u2211 i in s, (f i).support.sup degb", "start": [197, 1], "end": [200, 97], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_inf_support_finset_prod", "code": "theorem le_inf_support_finset_prod (degt0 : 0 \u2264 degt 0)\n    (degtm : \u2200 a b, degt a + degt b \u2264 degt (a + b)) (s : Finset \u03b9) (f : \u03b9 \u2192 R[A]) :\n    (\u2211 i in s, (f i).support.inf degt) \u2264 (\u220f i in s, f i).support.inf degt", "start": [203, 1], "end": [206, 94], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.supDegree", "code": "@[reducible]\ndef supDegree (f : R[A]) : B :=\n  f.support.sup D", "start": [228, 1], "end": [237, 18], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.supDegree_add_le", "code": "theorem supDegree_add_le (f g : R[A]) :\n    (f + g).supDegree D \u2264 (f.supDegree D) \u2294 (g.supDegree D)", "start": [239, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.supDegree_mul_le", "code": "theorem supDegree_mul_le (f g : R[A]) :\n    (f * g).supDegree D \u2264 f.supDegree D + g.supDegree D", "start": [245, 1], "end": [247, 72], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.infDegree", "code": "@[reducible]\ndef infDegree (D : A \u2192 T) (f : R[A]) : T :=\n  f.support.inf D", "start": [255, 1], "end": [264, 18], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_infDegree_add", "code": "theorem le_infDegree_add (D : A \u2192 T) (f g : R[A]) :\n    (f.infDegree D) \u2293 (g.infDegree D) \u2264 (f + g).infDegree D", "start": [266, 1], "end": [268, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.le_infDegree_mul", "code": "theorem le_infDegree_mul (f g : R[A]) :\n    f.infDegree D + g.infDegree D \u2264 (f * g).infDegree D", "start": [272, 1], "end": [275, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/WithTop.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.cast_withTop", "code": "theorem Nat.cast_withTop (n : \u2115) :  Nat.cast n = WithTop.some n", "start": [22, 1], "end": [23, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_withBot", "code": "theorem Nat.cast_withBot (n : \u2115) : Nat.cast n = WithBot.some n", "start": [26, 1], "end": [27, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Monomial.lean", "imports": ["Mathlib/Data/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.monomial_one_eq_iff", "code": "theorem monomial_one_eq_iff [Nontrivial R] {i j : \u2115} :\n    (monomial i 1 : R[X]) = monomial j 1 \u2194 i = j", "start": [29, 1], "end": [33, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.infinite", "code": "instance infinite [Nontrivial R] : Infinite R[X] :=\n  Infinite.of_injective (fun i => monomial i 1) fun m n h => by simpa [monomial_one_eq_iff] using h", "start": [36, 1], "end": [37, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_le_one_iff_monomial", "code": "theorem card_support_le_one_iff_monomial {f : R[X]} :\n    Finset.card f.support \u2264 1 \u2194 \u2203 n a, f = monomial n a", "start": [40, 1], "end": [57, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ringHom_ext", "code": "theorem ringHom_ext {S} [Semiring S] {f g : R[X] \u2192+* S} (h\u2081 : \u2200 a, f (C a) = g (C a))\n    (h\u2082 : f X = g X) : f = g", "start": [60, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ringHom_ext'", "code": "@[ext high]\ntheorem ringHom_ext' {S} [Semiring S] {f g : R[X] \u2192+* S} (h\u2081 : f.comp C = g.comp C)\n    (h\u2082 : f X = g X) : f = g", "start": [84, 1], "end": [87, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Measurability/Init.lean", "imports": ["lake-packages/aesop/Aesop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "imports": ["Mathlib/LinearAlgebra/GeneralLinearGroup.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineEquiv", "code": "structure AffineEquiv (k P\u2081 P\u2082 : Type*) {V\u2081 V\u2082 : Type*} [Ring k] [AddCommGroup V\u2081] [Module k V\u2081]\n  [AddTorsor V\u2081 P\u2081] [AddCommGroup V\u2082] [Module k V\u2082] [AddTorsor V\u2082 P\u2082] extends P\u2081 \u2243 P\u2082 where\n  linear : V\u2081 \u2243\u2097[k] V\u2082\n  map_vadd' : \u2200 (p : P\u2081) (v : V\u2081), toEquiv (v +\u1d65 p) = linear v +\u1d65 toEquiv p", "start": [40, 1], "end": [49, 76], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toAffineMap", "code": "@[coe]\ndef toAffineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2081 \u2192\u1d43[k] P\u2082 :=\n  { e with }", "start": [60, 1], "end": [63, 13], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toAffineMap_mk", "code": "@[simp]\ntheorem toAffineMap_mk (f : P\u2081 \u2243 P\u2082) (f' : V\u2081 \u2243\u2097[k] V\u2082) (h) :\n    toAffineMap (mk f f' h) = \u27e8f, f', h\u27e9", "start": [66, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.linear_toAffineMap", "code": "@[simp]\ntheorem linear_toAffineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.toAffineMap.linear = e.linear", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toAffineMap_injective", "code": "theorem toAffineMap_injective : Injective (toAffineMap : (P\u2081 \u2243\u1d43[k] P\u2082) \u2192 P\u2081 \u2192\u1d43[k] P\u2082)", "start": [77, 1], "end": [83, 20], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toAffineMap_inj", "code": "@[simp]\ntheorem toAffineMap_inj {e e' : P\u2081 \u2243\u1d43[k] P\u2082} : e.toAffineMap = e'.toAffineMap \u2194 e = e'", "start": [86, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.equivLike", "code": "instance equivLike : EquivLike (P\u2081 \u2243\u1d43[k] P\u2082) P\u2081 P\u2082 where\n  coe f := f.toFun\n  inv f := f.invFun\n  left_inv f := f.left_inv\n  right_inv f := f.right_inv\n  coe_injective' _ _ h _ := toAffineMap_injective (FunLike.coe_injective h)", "start": [91, 1], "end": [96, 76], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.map_vadd", "code": "@[simp]\ntheorem map_vadd (e : P\u2081 \u2243\u1d43[k] P\u2082) (p : P\u2081) (v : V\u2081) : e (v +\u1d65 p) = e.linear v +\u1d65 e p", "start": [105, 1], "end": [107, 18], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (e : P\u2081 \u2243\u1d43[k] P\u2082) : \u21d1e.toEquiv = e", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_toAffineMap", "code": "@[simp]\ntheorem coe_toAffineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) : (e.toAffineMap : P\u2081 \u2192 P\u2082) = (e : P\u2081 \u2192 P\u2082)", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_coe", "code": "@[norm_cast, simp]\ntheorem coe_coe (e : P\u2081 \u2243\u1d43[k] P\u2082) : ((e : P\u2081 \u2192\u1d43[k] P\u2082) : P\u2081 \u2192 P\u2082) = e", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_linear", "code": "@[simp]\ntheorem coe_linear (e : P\u2081 \u2243\u1d43[k] P\u2082) : (e : P\u2081 \u2192\u1d43[k] P\u2082).linear = e.linear", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.ext", "code": "@[ext]\ntheorem ext {e e' : P\u2081 \u2243\u1d43[k] P\u2082} (h : \u2200 x, e x = e' x) : e = e'", "start": [133, 1], "end": [135, 20], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coeFn_injective", "code": "theorem coeFn_injective : @Injective (P\u2081 \u2243\u1d43[k] P\u2082) (P\u2081 \u2192 P\u2082) (\u21d1)", "start": [138, 1], "end": [139, 24], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coeFn_inj", "code": "@[norm_cast]\ntheorem coeFn_inj {e e' : P\u2081 \u2243\u1d43[k] P\u2082} : (e : P\u2081 \u2192 P\u2082) = e' \u2194 e = e'", "start": [142, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Injective (toEquiv : (P\u2081 \u2243\u1d43[k] P\u2082) \u2192 P\u2081 \u2243 P\u2082)", "start": [148, 1], "end": [149, 27], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toEquiv_inj", "code": "@[simp]\ntheorem toEquiv_inj {e e' : P\u2081 \u2243\u1d43[k] P\u2082} : e.toEquiv = e'.toEquiv \u2194 e = e'", "start": [152, 1], "end": [154, 27], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (e : P\u2081 \u2243 P\u2082) (e' : V\u2081 \u2243\u2097[k] V\u2082) (h) : ((\u27e8e, e', h\u27e9 : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2081 \u2192 P\u2082) = e", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.mk'", "code": "def mk' (e : P\u2081 \u2192 P\u2082) (e' : V\u2081 \u2243\u2097[k] V\u2082) (p : P\u2081) (h : \u2200 p' : P\u2081, e p' = e' (p' -\u1d65 p) +\u1d65 e p) :\n    P\u2081 \u2243\u1d43[k] P\u2082 where\n  toFun := e\n  invFun := fun q' : P\u2082 => e'.symm (q' -\u1d65 e p) +\u1d65 p\n  left_inv p' := by simp [h p', (vadd_vsub), (vsub_vadd)]\n  right_inv q' := by simp [h (e'.symm (q' -\u1d65 e p) +\u1d65 p), (vadd_vsub), (vsub_vadd)]\n  linear := e'\n  map_vadd' p' v := by simp [h p', h (v +\u1d65 p'), (vadd_vsub_assoc), (vadd_vadd)]", "start": [162, 1], "end": [176, 80], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (e : P\u2081 \u2243 P\u2082) (e' : V\u2081 \u2243\u2097[k] V\u2082) (p h) : \u21d1(mk' e e' p h) = e", "start": [179, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.linear_mk'", "code": "@[simp]\ntheorem linear_mk' (e : P\u2081 \u2243 P\u2082) (e' : V\u2081 \u2243\u2097[k] V\u2082) (p h) : (mk' e e' p h).linear = e'", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm", "code": "@[symm]\ndef symm (e : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2082 \u2243\u1d43[k] P\u2081 where\n  toEquiv := e.toEquiv.symm\n  linear := e.linear.symm\n  map_vadd' p v :=\n    e.toEquiv.symm.apply_eq_iff_eq_symm_apply.2 <| by\n      rw [Equiv.symm_symm, e.map_vadd' ((Equiv.symm e.toEquiv) p) ((LinearEquiv.symm e.linear) v),\n        LinearEquiv.apply_symm_apply, Equiv.apply_symm_apply]", "start": [189, 1], "end": [197, 62], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm_toEquiv", "code": "@[simp]\ntheorem symm_toEquiv (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.toEquiv.symm = e.symm.toEquiv", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm_linear", "code": "@[simp]\ntheorem symm_linear (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.linear.symm = e.symm.linear", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.Simps.apply", "code": "def Simps.apply (e : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2081 \u2192 P\u2082 :=\n  e", "start": [210, 1], "end": [212, 4], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : P\u2081 \u2243\u1d43[k] P\u2082) : P\u2082 \u2192 P\u2081 :=\n  e.symm", "start": [215, 1], "end": [217, 9], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.bijective", "code": "protected theorem bijective (e : P\u2081 \u2243\u1d43[k] P\u2082) : Bijective e", "start": [223, 1], "end": [224, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.surjective", "code": "protected theorem surjective (e : P\u2081 \u2243\u1d43[k] P\u2082) : Surjective e", "start": [227, 1], "end": [228, 23], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.injective", "code": "protected theorem injective (e : P\u2081 \u2243\u1d43[k] P\u2082) : Injective e", "start": [231, 1], "end": [232, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.ofBijective", "code": "@[simps! linear apply]\nnoncomputable def ofBijective {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082} (h\u03c6 : Function.Bijective \u03c6) : P\u2081 \u2243\u1d43[k] P\u2082 :=\n  { Equiv.ofBijective _ h\u03c6 with\n    linear := LinearEquiv.ofBijective \u03c6.linear (\u03c6.linear_bijective_iff.mpr h\u03c6)\n    map_vadd' := \u03c6.map_vadd }", "start": [235, 1], "end": [240, 30], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.ofBijective.symm_eq", "code": "theorem ofBijective.symm_eq {\u03c6 : P\u2081 \u2192\u1d43[k] P\u2082} (h\u03c6 : Function.Bijective \u03c6) :\n    (ofBijective h\u03c6).symm.toEquiv = (Equiv.ofBijective _ h\u03c6).symm", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.range_eq", "code": "@[simp]\ntheorem range_eq (e : P\u2081 \u2243\u1d43[k] P\u2082) : range e = univ", "start": [248, 1], "end": [250, 24], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : P\u2081 \u2243\u1d43[k] P\u2082) (p : P\u2082) : e (e.symm p) = p", "start": [253, 1], "end": [255, 31], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : P\u2081 \u2243\u1d43[k] P\u2082) (p : P\u2081) : e.symm (e p) = p", "start": [258, 1], "end": [260, 31], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.apply_eq_iff_eq_symm_apply", "code": "theorem apply_eq_iff_eq_symm_apply (e : P\u2081 \u2243\u1d43[k] P\u2082) {p\u2081 p\u2082} : e p\u2081 = p\u2082 \u2194 p\u2081 = e.symm p\u2082", "start": [263, 1], "end": [264, 39], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.apply_eq_iff_eq", "code": "theorem apply_eq_iff_eq (e : P\u2081 \u2243\u1d43[k] P\u2082) {p\u2081 p\u2082 : P\u2081} : e p\u2081 = e p\u2082 \u2194 p\u2081 = p\u2082", "start": [268, 1], "end": [269, 28], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.image_symm", "code": "@[simp]\ntheorem image_symm (f : P\u2081 \u2243\u1d43[k] P\u2082) (s : Set P\u2082) : f.symm '' s = f \u207b\u00b9' s", "start": [272, 1], "end": [274, 37], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.preimage_symm", "code": "@[simp]\ntheorem preimage_symm (f : P\u2081 \u2243\u1d43[k] P\u2082) (s : Set P\u2081) : f.symm \u207b\u00b9' s = f '' s", "start": [277, 1], "end": [279, 29], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.refl", "code": "def refl : P\u2081 \u2243\u1d43[k] P\u2081 where\n  toEquiv := Equiv.refl P\u2081\n  linear := LinearEquiv.refl k V\u2081\n  map_vadd' _ _ := rfl", "start": [284, 1], "end": [289, 23], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(refl k P\u2081) = id", "start": [292, 1], "end": [294, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_refl_to_affineMap", "code": "@[simp]\ntheorem coe_refl_to_affineMap : \u2191(refl k P\u2081) = AffineMap.id k P\u2081", "start": [297, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : P\u2081) : refl k P\u2081 x = x", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toEquiv_refl", "code": "@[simp]\ntheorem toEquiv_refl : (refl k P\u2081).toEquiv = Equiv.refl P\u2081", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.linear_refl", "code": "@[simp]\ntheorem linear_refl : (refl k P\u2081).linear = LinearEquiv.refl k V\u2081", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm_refl", "code": "@[simp]\ntheorem symm_refl : (refl k P\u2081).symm = refl k P\u2081", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.trans", "code": "@[trans]\ndef trans (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) : P\u2081 \u2243\u1d43[k] P\u2083 where\n  toEquiv := e.toEquiv.trans e'.toEquiv\n  linear := e.linear.trans e'.linear\n  map_vadd' p v := by\n    simp only [LinearEquiv.trans_apply, (coe_toEquiv), (\u00b7 \u2218 \u00b7), Equiv.coe_trans, (map_vadd)]", "start": [324, 1], "end": [331, 93], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) : \u21d1(e.trans e') = e' \u2218 e", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_trans_to_affineMap", "code": "@[simp]\ntheorem coe_trans_to_affineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) :\n    (e.trans e' : P\u2081 \u2192\u1d43[k] P\u2083) = (e' : P\u2082 \u2192\u1d43[k] P\u2083).comp e", "start": [339, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) (p : P\u2081) : e.trans e' p = e' (e p)", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.trans_assoc", "code": "theorem trans_assoc (e\u2081 : P\u2081 \u2243\u1d43[k] P\u2082) (e\u2082 : P\u2082 \u2243\u1d43[k] P\u2083) (e\u2083 : P\u2083 \u2243\u1d43[k] P\u2084) :\n    (e\u2081.trans e\u2082).trans e\u2083 = e\u2081.trans (e\u2082.trans e\u2083)", "start": [350, 1], "end": [352, 19], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.trans_refl", "code": "@[simp]\ntheorem trans_refl (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.trans (refl k P\u2082) = e", "start": [355, 1], "end": [357, 19], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.refl_trans", "code": "@[simp]\ntheorem refl_trans (e : P\u2081 \u2243\u1d43[k] P\u2082) : (refl k P\u2081).trans e = e", "start": [360, 1], "end": [362, 19], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.trans e.symm = refl k P\u2081", "start": [365, 1], "end": [367, 25], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.symm.trans e = refl k P\u2082", "start": [370, 1], "end": [372, 25], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.apply_lineMap", "code": "@[simp]\ntheorem apply_lineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) (a b : P\u2081) (c : k) :\n    e (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c", "start": [375, 1], "end": [378, 36], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.group", "code": "instance group : Group (P\u2081 \u2243\u1d43[k] P\u2081) where\n  one := refl k P\u2081\n  mul e e' := e'.trans e\n  inv := symm\n  mul_assoc e\u2081 e\u2082 e\u2083 := trans_assoc _ _ _\n  one_mul := trans_refl\n  mul_one := refl_trans\n  mul_left_inv := self_trans_symm", "start": [381, 1], "end": [388, 34], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.one_def", "code": "theorem one_def : (1 : P\u2081 \u2243\u1d43[k] P\u2081) = refl k P\u2081", "start": [391, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : P\u2081 \u2243\u1d43[k] P\u2081) = id", "start": [395, 1], "end": [397, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.mul_def", "code": "theorem mul_def (e e' : P\u2081 \u2243\u1d43[k] P\u2081) : e * e' = e'.trans e", "start": [400, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_mul", "code": "@[simp]\ntheorem coe_mul (e e' : P\u2081 \u2243\u1d43[k] P\u2081) : \u21d1(e * e') = e \u2218 e'", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.inv_def", "code": "theorem inv_def (e : P\u2081 \u2243\u1d43[k] P\u2081) : e\u207b\u00b9 = e.symm", "start": [409, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.linearHom", "code": "@[simps]\ndef linearHom : (P\u2081 \u2243\u1d43[k] P\u2081) \u2192* V\u2081 \u2243\u2097[k] V\u2081 where\n  toFun := linear\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [413, 1], "end": [418, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.equivUnitsAffineMap", "code": "@[simps]\ndef equivUnitsAffineMap : (P\u2081 \u2243\u1d43[k] P\u2081) \u2243* (P\u2081 \u2192\u1d43[k] P\u2081)\u02e3 where\n  toFun e :=\n    { val := e, inv := e.symm,\n      val_inv := congr_arg toAffineMap e.symm_trans_self\n      inv_val := congr_arg toAffineMap e.self_trans_symm }\n  invFun u :=\n    { toFun := (u : P\u2081 \u2192\u1d43[k] P\u2081)\n      invFun := (\u2191u\u207b\u00b9 : P\u2081 \u2192\u1d43[k] P\u2081)\n      left_inv := AffineMap.congr_fun u.inv_mul\n      right_inv := AffineMap.congr_fun u.mul_inv\n      linear :=\n        LinearMap.GeneralLinearGroup.generalLinearEquiv _ _ <| Units.map AffineMap.linearHom u\n      map_vadd' := fun _ _ => (u : P\u2081 \u2192\u1d43[k] P\u2081).map_vadd _ _ }\n  left_inv _ := AffineEquiv.ext fun _ => rfl\n  right_inv _ := Units.ext <| AffineMap.ext fun _ => rfl\n  map_mul' _ _ := rfl", "start": [421, 1], "end": [440, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.vaddConst", "code": "@[simps! linear apply symm_apply]\ndef vaddConst (b : P\u2081) : V\u2081 \u2243\u1d43[k] P\u2081 where\n  toEquiv := Equiv.vaddConst b\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := add_vadd _ _ _", "start": [445, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVSub", "code": "def constVSub (p : P\u2081) : P\u2081 \u2243\u1d43[k] V\u2081 where\n  toEquiv := Equiv.constVSub p\n  linear := LinearEquiv.neg k\n  map_vadd' p' v := by simp [(Equiv.coe_constVSub), (vsub_vadd_eq_vsub_sub), neg_add_eq_sub]", "start": [454, 1], "end": [459, 93], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_constVSub", "code": "@[simp]\ntheorem coe_constVSub (p : P\u2081) : \u21d1(constVSub k p) = (\u00b7 -\u1d65 \u00b7) p", "start": [462, 1], "end": [464, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_constVSub_symm", "code": "@[simp]\ntheorem coe_constVSub_symm (p : P\u2081) : \u21d1(constVSub k p).symm = fun v : V\u2081 => -v +\u1d65 p", "start": [467, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd", "code": "@[simps! apply linear]\ndef constVAdd (v : V\u2081) : P\u2081 \u2243\u1d43[k] P\u2081 where\n  toEquiv := Equiv.constVAdd P\u2081 v\n  linear := LinearEquiv.refl _ _\n  map_vadd' _ _ := vadd_comm _ _ _", "start": [474, 1], "end": [482, 35], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd_zero", "code": "@[simp]\ntheorem constVAdd_zero : constVAdd k P\u2081 0 = AffineEquiv.refl _ _", "start": [485, 1], "end": [487, 21], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd_add", "code": "@[simp]\ntheorem constVAdd_add (v w : V\u2081) :\n    constVAdd k P\u2081 (v + w) = (constVAdd k P\u2081 w).trans (constVAdd k P\u2081 v)", "start": [490, 1], "end": [493, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd_symm", "code": "@[simp]\ntheorem constVAdd_symm (v : V\u2081) : (constVAdd k P\u2081 v).symm = constVAdd k P\u2081 (-v)", "start": [496, 1], "end": [498, 19], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAddHom", "code": "@[simps]\ndef constVAddHom : Multiplicative V\u2081 \u2192* P\u2081 \u2243\u1d43[k] P\u2081 where\n  toFun v := constVAdd k P\u2081 (Multiplicative.toAdd v)\n  map_one' := constVAdd_zero _ _\n  map_mul' := constVAdd_add _ P\u2081", "start": [501, 1], "end": [506, 33], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd_nsmul", "code": "theorem constVAdd_nsmul (n : \u2115) (v : V\u2081) : constVAdd k P\u2081 (n \u2022 v) = constVAdd k P\u2081 v ^ n", "start": [509, 1], "end": [510, 34], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.constVAdd_zsmul", "code": "theorem constVAdd_zsmul (z : \u2124) (v : V\u2081) : constVAdd k P\u2081 (z \u2022 v) = constVAdd k P\u2081 v ^ z", "start": [513, 1], "end": [514, 35], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.homothetyUnitsMulHom", "code": "def homothetyUnitsMulHom (p : P) : R\u02e3 \u2192* P \u2243\u1d43[R] P :=\n  equivUnitsAffineMap.symm.toMonoidHom.comp <| Units.map (AffineMap.homothetyHom p)", "start": [521, 1], "end": [524, 84], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_homothetyUnitsMulHom_apply", "code": "@[simp]\ntheorem coe_homothetyUnitsMulHom_apply (p : P) (t : R\u02e3) :\n    (homothetyUnitsMulHom p t : P \u2192 P) = AffineMap.homothety p (t : R)", "start": [527, 1], "end": [530, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_homothetyUnitsMulHom_apply_symm", "code": "@[simp]\ntheorem coe_homothetyUnitsMulHom_apply_symm (p : P) (t : R\u02e3) :\n    ((homothetyUnitsMulHom p t).symm : P \u2192 P) = AffineMap.homothety p (\u2191t\u207b\u00b9 : R)", "start": [533, 1], "end": [536, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.coe_homothetyUnitsMulHom_eq_homothetyHom_coe", "code": "@[simp]\ntheorem coe_homothetyUnitsMulHom_eq_homothetyHom_coe (p : P) :\n    ((\u2191) : (P \u2243\u1d43[R] P) \u2192 P \u2192\u1d43[R] P) \u2218 homothetyUnitsMulHom p =\n      AffineMap.homothetyHom p \u2218 ((\u2191) : R\u02e3 \u2192 R)", "start": [539, 1], "end": [543, 22], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection", "code": "def pointReflection (x : P\u2081) : P\u2081 \u2243\u1d43[k] P\u2081 :=\n  (constVSub k x).trans (vaddConst k x)", "start": [552, 1], "end": [554, 40], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_apply", "code": "theorem pointReflection_apply (x y : P\u2081) : pointReflection k x y = x -\u1d65 y +\u1d65 x", "start": [557, 1], "end": [558, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_symm", "code": "@[simp]\ntheorem pointReflection_symm (x : P\u2081) : (pointReflection k x).symm = pointReflection k x", "start": [561, 1], "end": [563, 52], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.toEquiv_pointReflection", "code": "@[simp]\ntheorem toEquiv_pointReflection (x : P\u2081) :\n    (pointReflection k x).toEquiv = Equiv.pointReflection x", "start": [566, 1], "end": [569, 6], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_self", "code": "@[simp]\ntheorem pointReflection_self (x : P\u2081) : pointReflection k x x = x", "start": [572, 1], "end": [574, 16], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_involutive", "code": "theorem pointReflection_involutive (x : P\u2081) : Involutive (pointReflection k x : P\u2081 \u2192 P\u2081)", "start": [577, 1], "end": [578, 37], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_fixed_iff_of_injective_bit0", "code": "theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P\u2081} (h : Injective (bit0 : V\u2081 \u2192 V\u2081)) :\n    pointReflection k x y = y \u2194 y = x", "start": [582, 1], "end": [586, 54], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.injective_pointReflection_left_of_injective_bit0", "code": "theorem injective_pointReflection_left_of_injective_bit0 (h : Injective (bit0 : V\u2081 \u2192 V\u2081)) (y : P\u2081) :\n    Injective fun x : P\u2081 => pointReflection k x y", "start": [590, 1], "end": [592, 61], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.injective_pointReflection_left_of_module", "code": "theorem injective_pointReflection_left_of_module [Invertible (2 : k)] :\n    \u2200 y, Injective fun x : P\u2081 => pointReflection k x y", "start": [595, 1], "end": [599, 60], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_fixed_iff_of_module", "code": "theorem pointReflection_fixed_iff_of_module [Invertible (2 : k)] {x y : P\u2081} :\n    pointReflection k x y = y \u2194 y = x", "start": [602, 1], "end": [604, 100], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toAffineEquiv", "code": "def toAffineEquiv (e : V\u2081 \u2243\u2097[k] V\u2082) : V\u2081 \u2243\u1d43[k] V\u2082 where\n  toEquiv := e.toEquiv\n  linear := e\n  map_vadd' p v := e.map_add v p", "start": [611, 1], "end": [615, 33], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toAffineEquiv", "code": "@[simp]\ntheorem coe_toAffineEquiv (e : V\u2081 \u2243\u2097[k] V\u2082) : \u21d1e.toAffineEquiv = e", "start": [618, 1], "end": [620, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vadd", "code": "theorem lineMap_vadd (v v' : V\u2081) (p : P\u2081) (c : k) :\n    lineMap v v' c +\u1d65 p = lineMap (v +\u1d65 p) (v' +\u1d65 p) c", "start": [629, 1], "end": [631, 39], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vsub", "code": "theorem lineMap_vsub (p\u2081 p\u2082 p\u2083 : P\u2081) (c : k) :\n    lineMap p\u2081 p\u2082 c -\u1d65 p\u2083 = lineMap (p\u2081 -\u1d65 p\u2083) (p\u2082 -\u1d65 p\u2083) c", "start": [634, 1], "end": [636, 46], "kind": "commanddeclaration"}, {"full_name": "AffineMap.vsub_lineMap", "code": "theorem vsub_lineMap (p\u2081 p\u2082 p\u2083 : P\u2081) (c : k) :\n    p\u2081 -\u1d65 lineMap p\u2082 p\u2083 c = lineMap (p\u2081 -\u1d65 p\u2082) (p\u2081 -\u1d65 p\u2083) c", "start": [639, 1], "end": [641, 41], "kind": "commanddeclaration"}, {"full_name": "AffineMap.vadd_lineMap", "code": "theorem vadd_lineMap (v : V\u2081) (p\u2081 p\u2082 : P\u2081) (c : k) :\n    v +\u1d65 lineMap p\u2081 p\u2082 c = lineMap (v +\u1d65 p\u2081) (v +\u1d65 p\u2082) c", "start": [644, 1], "end": [646, 43], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_neg_one_apply", "code": "theorem homothety_neg_one_apply (c p : P\u2081) : homothety c (-1 : R') p = pointReflection R' c p", "start": [651, 1], "end": [653, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Dimension.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/SetTheory/Cardinal/Cofinality.lean", "Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "Mathlib/LinearAlgebra/StdBasis.lean", "Mathlib/Algebra/Module/BigOperators.lean", "Mathlib/LinearAlgebra/DFinsupp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Isomorphisms.lean", "Mathlib/LinearAlgebra/Basis/VectorSpace.lean"], "premises": [{"full_name": "Module.rank", "code": "protected irreducible_def Module.rank : Cardinal :=\n  \u2a06 \u03b9 : { s : Set V // LinearIndependent K ((\u2191) : s \u2192 V) }, (#\u03b9.1)", "start": [95, 1], "end": [109, 67], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "LinearMap.lift_rank_le_of_injective", "code": "theorem LinearMap.lift_rank_le_of_injective (f : M \u2192\u2097[R] M') (i : Injective f) :\n    Cardinal.lift.{v'} (Module.rank R M) \u2264 Cardinal.lift.{v} (Module.rank R M')", "start": [124, 1], "end": [132, 56], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_le_of_injective", "code": "theorem LinearMap.rank_le_of_injective (f : M \u2192\u2097[R] M\u2081) (i : Injective f) :\n    Module.rank R M \u2264 Module.rank R M\u2081", "start": [135, 1], "end": [137, 53], "kind": "commanddeclaration"}, {"full_name": "rank_le", "code": "theorem rank_le {n : \u2115}\n    (H : \u2200 s : Finset M, (LinearIndependent R fun i : s => (i : M)) \u2192 s.card \u2264 n) :\n    Module.rank R M \u2264 n", "start": [140, 1], "end": [146, 77], "kind": "commanddeclaration"}, {"full_name": "lift_rank_range_le", "code": "theorem lift_rank_range_le (f : M \u2192\u2097[R] M') : Cardinal.lift.{v}\n    (Module.rank R (LinearMap.range f)) \u2264 Cardinal.lift.{v'} (Module.rank R M)", "start": [150, 1], "end": [165, 81], "kind": "commanddeclaration"}, {"full_name": "rank_range_le", "code": "theorem rank_range_le (f : M \u2192\u2097[R] M\u2081) : Module.rank R (LinearMap.range f) \u2264 Module.rank R M", "start": [168, 1], "end": [169, 35], "kind": "commanddeclaration"}, {"full_name": "lift_rank_map_le", "code": "theorem lift_rank_map_le (f : M \u2192\u2097[R] M') (p : Submodule R M) :\n    Cardinal.lift.{v} (Module.rank R (p.map f)) \u2264 Cardinal.lift.{v'} (Module.rank R p)", "start": [172, 1], "end": [175, 49], "kind": "commanddeclaration"}, {"full_name": "rank_map_le", "code": "theorem rank_map_le (f : M \u2192\u2097[R] M\u2081) (p : Submodule R M) :\n    Module.rank R (p.map f) \u2264 Module.rank R p", "start": [178, 1], "end": [179, 85], "kind": "commanddeclaration"}, {"full_name": "rank_le_of_submodule", "code": "theorem rank_le_of_submodule (s t : Submodule R M) (h : s \u2264 t) :\n    Module.rank R s \u2264 Module.rank R t", "start": [182, 1], "end": [185, 59], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.lift_rank_eq", "code": "theorem LinearEquiv.lift_rank_eq (f : M \u2243\u2097[R] M') :\n    Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M')", "start": [188, 1], "end": [194, 72], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.rank_eq", "code": "theorem LinearEquiv.rank_eq (f : M \u2243\u2097[R] M\u2081) : Module.rank R M = Module.rank R M\u2081", "start": [197, 1], "end": [199, 37], "kind": "commanddeclaration"}, {"full_name": "rank_range_of_injective", "code": "theorem rank_range_of_injective (f : M \u2192\u2097[R] M\u2081) (h : Injective f) :\n    Module.rank R (LinearMap.range f) = Module.rank R M", "start": [202, 1], "end": [204, 45], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.rank_map_eq", "code": "theorem LinearEquiv.rank_map_eq (f : M \u2243\u2097[R] M\u2081) (p : Submodule R M) :\n    Module.rank R (p.map (f : M \u2192\u2097[R] M\u2081)) = Module.rank R p", "start": [207, 1], "end": [210, 34], "kind": "commanddeclaration"}, {"full_name": "rank_top", "code": "@[simp]\ntheorem rank_top : Module.rank R (\u22a4 : Submodule R M) = Module.rank R M", "start": [215, 1], "end": [218, 20], "kind": "commanddeclaration"}, {"full_name": "rank_range_of_surjective", "code": "theorem rank_range_of_surjective (f : M \u2192\u2097[R] M') (h : Surjective f) :\n    Module.rank R (LinearMap.range f) = Module.rank R M'", "start": [223, 1], "end": [225, 47], "kind": "commanddeclaration"}, {"full_name": "rank_submodule_le", "code": "theorem rank_submodule_le (s : Submodule R M) : Module.rank R s \u2264 Module.rank R M", "start": [228, 1], "end": [230, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_le_of_surjective", "code": "theorem LinearMap.rank_le_of_surjective (f : M \u2192\u2097[R] M\u2081) (h : Surjective f) :\n    Module.rank R M\u2081 \u2264 Module.rank R M", "start": [233, 1], "end": [236, 22], "kind": "commanddeclaration"}, {"full_name": "rank_quotient_le", "code": "theorem rank_quotient_le (p : Submodule R M) : Module.rank R (M \u29f8 p) \u2264 Module.rank R M", "start": [239, 1], "end": [240, 55], "kind": "commanddeclaration"}, {"full_name": "cardinal_lift_le_rank_of_linearIndependent", "code": "theorem cardinal_lift_le_rank_of_linearIndependent {\u03b9 : Type w} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) :\n    Cardinal.lift.{v} #\u03b9 \u2264 Cardinal.lift.{w} (Module.rank R M)", "start": [245, 1], "end": [254, 19], "kind": "commanddeclaration"}, {"full_name": "cardinal_lift_le_rank_of_linearIndependent'", "code": "theorem cardinal_lift_le_rank_of_linearIndependent' {\u03b9 : Type w} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) : Cardinal.lift.{v} #\u03b9 \u2264 Cardinal.lift.{w} (Module.rank R M)", "start": [257, 1], "end": [259, 48], "kind": "commanddeclaration"}, {"full_name": "cardinal_le_rank_of_linearIndependent", "code": "theorem cardinal_le_rank_of_linearIndependent {\u03b9 : Type v} {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) : #\u03b9 \u2264 Module.rank R M", "start": [262, 1], "end": [264, 60], "kind": "commanddeclaration"}, {"full_name": "cardinal_le_rank_of_linearIndependent'", "code": "theorem cardinal_le_rank_of_linearIndependent' {s : Set M}\n    (hs : LinearIndependent R (fun x => x : s \u2192 M)) : #s \u2264 Module.rank R M", "start": [267, 1], "end": [269, 43], "kind": "commanddeclaration"}, {"full_name": "rank_punit", "code": "@[simp]\ntheorem rank_punit : Module.rank R PUnit = 0", "start": [274, 1], "end": [282, 57], "kind": "commanddeclaration"}, {"full_name": "rank_bot", "code": "@[simp]\ntheorem rank_bot : Module.rank R (\u22a5 : Submodule R M) = 0", "start": [285, 1], "end": [288, 32], "kind": "commanddeclaration"}, {"full_name": "exists_mem_ne_zero_of_rank_pos", "code": "theorem exists_mem_ne_zero_of_rank_pos {s : Submodule R M} (h : 0 < Module.rank R s) :\n    \u2203 b : M, b \u2208 s \u2227 b \u2260 0", "start": [293, 1], "end": [295, 88], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.finite_of_isNoetherian", "code": "theorem LinearIndependent.finite_of_isNoetherian [IsNoetherian R M] {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) : Finite \u03b9", "start": [298, 1], "end": [307, 42], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.set_finite_of_isNoetherian", "code": "theorem LinearIndependent.set_finite_of_isNoetherian [IsNoetherian R M] {s : Set M}\n    (hi : LinearIndependent R ((\u2191) : s \u2192 M)) : s.Finite", "start": [310, 1], "end": [312, 46], "kind": "commanddeclaration"}, {"full_name": "basis_finite_of_finite_spans", "code": "lemma basis_finite_of_finite_spans (w : Set M) (hw : w.Finite) (s : span R w = \u22a4) {\u03b9 : Type w}\n    (b : Basis \u03b9 R M) : Finite \u03b9 := by\n  classical\n  haveI := hw.to_subtype\n  cases nonempty_fintype w\n  rw [\u2190 not_infinite_iff_finite]\n  intro i\n  let S : Finset \u03b9 := Finset.univ.sup fun x : w => (b.repr x).support\n  let bS : Set M := b '' S\n  have h : \u2200 x \u2208 w, x \u2208 span R bS := by\n    intro x m\n    rw [\u2190 b.total_repr x, Finsupp.span_image_eq_map_total, Submodule.mem_map]\n    use b.repr x\n    simp only [and_true_iff, eq_self_iff_true, Finsupp.mem_supported]\n    change (b.repr x).support \u2264 S\n    convert Finset.le_sup (\u03b1 := Finset \u03b9) (by simp : (\u27e8x, m\u27e9 : w) \u2208 Finset.univ)\n    rfl\n  have k : span R bS = \u22a4 := eq_top_iff.2 (le_trans s.ge (span_le.2 h))\n  obtain \u27e8x, nm\u27e9 := Infinite.exists_not_mem_finset S\n  have k' : b x \u2208 span R bS := by\n    rw [k]\n    exact mem_top\n  refine' b.linearIndependent.not_mem_span_image _ k'\n  exact nm", "start": [319, 1], "end": [352, 11], "kind": "mathlibtacticlemma"}, {"full_name": "union_support_maximal_linearIndependent_eq_range_basis", "code": "theorem union_support_maximal_linearIndependent_eq_range_basis {\u03b9 : Type w} (b : Basis \u03b9 R M)\n    {\u03ba : Type w'} (v : \u03ba \u2192 M) (i : LinearIndependent R v) (m : i.Maximal) :\n    \u22c3 k, ((b.repr (v k)).support : Set \u03b9) = Set.univ", "start": [356, 1], "end": [424, 14], "kind": "commanddeclaration"}, {"full_name": "infinite_basis_le_maximal_linearIndependent'", "code": "theorem infinite_basis_le_maximal_linearIndependent' {\u03b9 : Type w} (b : Basis \u03b9 R M) [Infinite \u03b9]\n    {\u03ba : Type w'} (v : \u03ba \u2192 M) (i : LinearIndependent R v) (m : i.Maximal) :\n    Cardinal.lift.{w'} #\u03b9 \u2264 Cardinal.lift.{w} #\u03ba", "start": [427, 1], "end": [439, 43], "kind": "commanddeclaration"}, {"full_name": "infinite_basis_le_maximal_linearIndependent", "code": "theorem infinite_basis_le_maximal_linearIndependent {\u03b9 : Type w} (b : Basis \u03b9 R M) [Infinite \u03b9]\n    {\u03ba : Type w} (v : \u03ba \u2192 M) (i : LinearIndependent R v) (m : i.Maximal) : #\u03b9 \u2264 #\u03ba", "start": [444, 1], "end": [450, 77], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.subtype_ne_bot_le_rank", "code": "theorem CompleteLattice.Independent.subtype_ne_bot_le_rank [NoZeroSMulDivisors R M]\n    {V : \u03b9 \u2192 Submodule R M} (hV : CompleteLattice.Independent V) :\n    Cardinal.lift.{v} #{ i : \u03b9 // V i \u2260 \u22a5 } \u2264 Cardinal.lift.{w} (Module.rank R M)", "start": [453, 1], "end": [463, 57], "kind": "commanddeclaration"}, {"full_name": "rank_subsingleton", "code": "@[simp]\ntheorem rank_subsingleton [Subsingleton R] : Module.rank R M = 1", "start": [474, 1], "end": [488, 53], "kind": "commanddeclaration"}, {"full_name": "rank_pos", "code": "theorem rank_pos [Nontrivial M] : 0 < Module.rank R M", "start": [493, 1], "end": [499, 39], "kind": "commanddeclaration"}, {"full_name": "rank_zero_iff_forall_zero", "code": "theorem rank_zero_iff_forall_zero : Module.rank R M = 0 \u2194 \u2200 x : M, x = 0", "start": [504, 1], "end": [513, 36], "kind": "commanddeclaration"}, {"full_name": "rank_zero_iff", "code": "theorem rank_zero_iff : Module.rank R M = 0 \u2194 Subsingleton M", "start": [516, 1], "end": [518, 70], "kind": "commanddeclaration"}, {"full_name": "rank_pos_iff_exists_ne_zero", "code": "theorem rank_pos_iff_exists_ne_zero : 0 < Module.rank R M \u2194 \u2203 x : M, x \u2260 0", "start": [521, 1], "end": [523, 40], "kind": "commanddeclaration"}, {"full_name": "rank_pos_iff_nontrivial", "code": "theorem rank_pos_iff_nontrivial : 0 < Module.rank R M \u2194 Nontrivial M", "start": [526, 1], "end": [527, 70], "kind": "commanddeclaration"}, {"full_name": "mk_eq_mk_of_basis", "code": "theorem mk_eq_mk_of_basis (v : Basis \u03b9 R M) (v' : Basis \u03b9' R M) :\n    Cardinal.lift.{w'} #\u03b9 = Cardinal.lift.{w} #\u03b9'", "start": [538, 1], "end": [565, 28], "kind": "commanddeclaration"}, {"full_name": "Basis.indexEquiv", "code": "def Basis.indexEquiv (v : Basis \u03b9 R M) (v' : Basis \u03b9' R M) : \u03b9 \u2243 \u03b9' :=\n  (Cardinal.lift_mk_eq'.1 <| mk_eq_mk_of_basis v v').some", "start": [568, 1], "end": [571, 58], "kind": "commanddeclaration"}, {"full_name": "mk_eq_mk_of_basis'", "code": "theorem mk_eq_mk_of_basis' {\u03b9' : Type w} (v : Basis \u03b9 R M) (v' : Basis \u03b9' R M) : #\u03b9 = #\u03b9'", "start": [574, 1], "end": [575, 48], "kind": "commanddeclaration"}, {"full_name": "Basis.le_span''", "code": "theorem Basis.le_span'' {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 R M) {w : Set M} [Fintype w]\n    (s : span R w = \u22a4) : Fintype.card \u03b9 \u2264 Fintype.card w", "start": [586, 1], "end": [602, 18], "kind": "commanddeclaration"}, {"full_name": "basis_le_span'", "code": "theorem basis_le_span' {\u03b9 : Type*} (b : Basis \u03b9 R M) {w : Set M} [Fintype w] (s : span R w = \u22a4) :\n    #\u03b9 \u2264 Fintype.card w", "start": [605, 1], "end": [616, 28], "kind": "commanddeclaration"}, {"full_name": "Basis.le_span", "code": "theorem Basis.le_span {J : Set M} (v : Basis \u03b9 R M) (hJ : span R J = \u22a4) : #(range v) \u2264 #J", "start": [621, 1], "end": [648, 12], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_span_aux'", "code": "theorem linearIndependent_le_span_aux' {\u03b9 : Type*} [Fintype \u03b9] (v : \u03b9 \u2192 M)\n    (i : LinearIndependent R v) (w : Set M) [Fintype w] (s : range v \u2264 span R w) :\n    Fintype.card \u03b9 \u2264 Fintype.card w", "start": [663, 1], "end": [677, 58], "kind": "commanddeclaration"}, {"full_name": "linearIndependentFintypeOfLeSpanFintype", "code": "def linearIndependentFintypeOfLeSpanFintype {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v)\n    (w : Set M) [Fintype w] (s : range v \u2264 span R w) : Fintype \u03b9 :=\n  fintypeOfFinsetCardLe (Fintype.card w) fun t => by\n    let v' := fun x : (t : Set \u03b9) => v x\n    have i' : LinearIndependent R v' := i.comp _ Subtype.val_injective\n    have s' : range v' \u2264 span R w := (range_comp_subset_range _ _).trans s\n    simpa using linearIndependent_le_span_aux' v' i' w s'", "start": [680, 1], "end": [691, 58], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_span'", "code": "theorem linearIndependent_le_span' {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v \u2264 span R w) : #\u03b9 \u2264 Fintype.card w", "start": [694, 1], "end": [704, 47], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_span", "code": "theorem linearIndependent_le_span {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : span R w = \u22a4) : #\u03b9 \u2264 Fintype.card w", "start": [707, 1], "end": [716, 15], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_span_finset", "code": "theorem linearIndependent_le_span_finset {\u03b9 : Type*} (v : \u03b9 \u2192 M) (i : LinearIndependent R v)\n    (w : Finset M) (s : span R (w : Set M) = \u22a4) : #\u03b9 \u2264 w.card", "start": [719, 1], "end": [722, 93], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_infinite_basis", "code": "theorem linearIndependent_le_infinite_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) [Infinite \u03b9] {\u03ba : Type w}\n    (v : \u03ba \u2192 M) (i : LinearIndependent R v) : #\u03ba \u2264 #\u03b9", "start": [725, 1], "end": [742, 16], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_le_basis", "code": "theorem linearIndependent_le_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) {\u03ba : Type w} (v : \u03ba \u2192 M)\n    (i : LinearIndependent R v) : #\u03ba \u2264 #\u03b9", "start": [745, 1], "end": [760, 52], "kind": "commanddeclaration"}, {"full_name": "Basis.card_le_card_of_linearIndependent_aux", "code": "theorem Basis.card_le_card_of_linearIndependent_aux {R : Type*} [Ring R] [StrongRankCondition R]\n    (n : \u2115) {m : \u2115} (v : Fin m \u2192 Fin n \u2192 R) : LinearIndependent R v \u2192 m \u2264 n", "start": [763, 1], "end": [767, 69], "kind": "commanddeclaration"}, {"full_name": "maximal_linearIndependent_eq_infinite_basis", "code": "theorem maximal_linearIndependent_eq_infinite_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) [Infinite \u03b9]\n    {\u03ba : Type w} (v : \u03ba \u2192 M) (i : LinearIndependent R v) (m : i.Maximal) : #\u03ba = #\u03b9", "start": [771, 1], "end": [783, 62], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_eq_rank''", "code": "theorem Basis.mk_eq_rank'' {\u03b9 : Type v} (v : Basis \u03b9 R M) : #\u03b9 = Module.rank R M", "start": [786, 1], "end": [801, 44], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_range_eq_rank", "code": "theorem Basis.mk_range_eq_rank (v : Basis \u03b9 R M) : #(range v) = Module.rank R M", "start": [804, 1], "end": [805, 30], "kind": "commanddeclaration"}, {"full_name": "rank_eq_card_basis", "code": "theorem rank_eq_card_basis {\u03b9 : Type w} [Fintype \u03b9] (h : Basis \u03b9 R M) :\n    Module.rank R M = Fintype.card \u03b9", "start": [808, 1], "end": [814, 90], "kind": "commanddeclaration"}, {"full_name": "Basis.card_le_card_of_linearIndependent", "code": "theorem Basis.card_le_card_of_linearIndependent {\u03b9 : Type*} [Fintype \u03b9] (b : Basis \u03b9 R M)\n    {\u03b9' : Type*} [Fintype \u03b9'] {v : \u03b9' \u2192 M} (hv : LinearIndependent R v) :\n    Fintype.card \u03b9' \u2264 Fintype.card \u03b9", "start": [817, 1], "end": [822, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.card_le_card_of_submodule", "code": "theorem Basis.card_le_card_of_submodule (N : Submodule R M) [Fintype \u03b9] (b : Basis \u03b9 R M)\n    [Fintype \u03b9'] (b' : Basis \u03b9' R N) : Fintype.card \u03b9' \u2264 Fintype.card \u03b9", "start": [825, 1], "end": [827, 90], "kind": "commanddeclaration"}, {"full_name": "Basis.card_le_card_of_le", "code": "theorem Basis.card_le_card_of_le {N O : Submodule R M} (hNO : N \u2264 O) [Fintype \u03b9] (b : Basis \u03b9 R O)\n    [Fintype \u03b9'] (b' : Basis \u03b9' R N) : Fintype.card \u03b9' \u2264 Fintype.card \u03b9", "start": [830, 1], "end": [833, 70], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_eq_rank", "code": "theorem Basis.mk_eq_rank (v : Basis \u03b9 R M) :\n    Cardinal.lift.{v} #\u03b9 = Cardinal.lift.{w} (Module.rank R M)", "start": [836, 1], "end": [839, 75], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_eq_rank'", "code": "theorem Basis.mk_eq_rank'.{m} (v : Basis \u03b9 R M) :\n    Cardinal.lift.{max v m} #\u03b9 = Cardinal.lift.{max w m} (Module.rank R M)", "start": [842, 1], "end": [844, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.nonempty_fintype_index_of_rank_lt_aleph0", "code": "theorem Basis.nonempty_fintype_index_of_rank_lt_aleph0 {\u03b9 : Type*} (b : Basis \u03b9 R M)\n    (h : Module.rank R M < \u2135\u2080) : Nonempty (Fintype \u03b9)", "start": [847, 1], "end": [851, 41], "kind": "commanddeclaration"}, {"full_name": "Basis.fintypeIndexOfRankLtAleph0", "code": "noncomputable def Basis.fintypeIndexOfRankLtAleph0 {\u03b9 : Type*} (b : Basis \u03b9 R M)\n    (h : Module.rank R M < \u2135\u2080) : Fintype \u03b9 :=\n  Classical.choice (b.nonempty_fintype_index_of_rank_lt_aleph0 h)", "start": [854, 1], "end": [857, 66], "kind": "commanddeclaration"}, {"full_name": "Basis.finite_index_of_rank_lt_aleph0", "code": "theorem Basis.finite_index_of_rank_lt_aleph0 {\u03b9 : Type*} {s : Set \u03b9} (b : Basis s R M)\n    (h : Module.rank R M < \u2135\u2080) : s.Finite", "start": [860, 1], "end": [863, 62], "kind": "commanddeclaration"}, {"full_name": "rank_span", "code": "theorem rank_span {v : \u03b9 \u2192 M} (hv : LinearIndependent R v) :\n    Module.rank R \u2191(span R (range v)) = #(range v)", "start": [866, 1], "end": [870, 89], "kind": "commanddeclaration"}, {"full_name": "rank_span_set", "code": "theorem rank_span_set {s : Set M} (hs : LinearIndependent R (fun x => x : s \u2192 M)) :\n    Module.rank R \u2191(span R s) = #s", "start": [873, 1], "end": [876, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.inductionOnRank", "code": "def Submodule.inductionOnRank [IsDomain R] [Fintype \u03b9] (b : Basis \u03b9 R M)\n    (P : Submodule R M \u2192 Sort*) (ih : \u2200 N : Submodule R M,\n    (\u2200 N' \u2264 N, \u2200 x \u2208 N, (\u2200 (c : R), \u2200 y \u2208 N', c \u2022 x + y = (0 : M) \u2192 c = 0) \u2192 P N') \u2192 P N)\n    (N : Submodule R M) : P N :=\n  Submodule.inductionOnRankAux b P ih (Fintype.card \u03b9) N fun hs hli => by\n    simpa using b.card_le_card_of_linearIndependent hli", "start": [879, 1], "end": [888, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.rank_eq", "code": "theorem Ideal.rank_eq {R S : Type*} [CommRing R] [StrongRankCondition R] [Ring S] [IsDomain S]\n    [Algebra R S] {n m : Type*} [Fintype n] [Fintype m] (b : Basis n R S) {I : Ideal S}\n    (hI : I \u2260 \u22a5) (c : Basis m R I) : Fintype.card m = Fintype.card n", "start": [891, 1], "end": [907, 47], "kind": "commanddeclaration"}, {"full_name": "rank_self", "code": "@[simp]\ntheorem rank_self : Module.rank R R = 1", "start": [912, 1], "end": [914, 86], "kind": "commanddeclaration"}, {"full_name": "Module.Free.rank_eq_card_chooseBasisIndex", "code": "theorem rank_eq_card_chooseBasisIndex : Module.rank K V = #(ChooseBasisIndex K V)", "start": [933, 1], "end": [935, 38], "kind": "commanddeclaration"}, {"full_name": "Module.Free.rank_eq_mk_of_infinite_lt", "code": "lemma rank_eq_mk_of_infinite_lt [Infinite K] (h_lt : lift.{v} #K < lift.{u} #V) :\n    Module.rank K V = #V := by\n  have : Infinite V := infinite_iff.mpr <| lift_le.mp <| le_trans (by simp) h_lt.le\n  have h : lift #V = lift #(ChooseBasisIndex K V \u2192\u2080 K) := lift_mk_eq'.mpr \u27e8(chooseBasis K V).repr\u27e9\n  simp only [mk_finsupp_lift_of_infinite', lift_id', \u2190 rank_eq_card_chooseBasisIndex, lift_max,\n    lift_lift] at h\n  refine lift_inj.mp ((max_eq_iff.mp h.symm).resolve_right <| not_and_of_not_left _ ?_).left\n  exact (lift_umax.{v, u}.symm \u25b8 h_lt).ne", "start": [938, 1], "end": [947, 42], "kind": "mathlibtacticlemma"}, {"full_name": "nonempty_linearEquiv_of_lift_rank_eq", "code": "theorem nonempty_linearEquiv_of_lift_rank_eq\n    (cnd : Cardinal.lift.{v'} (Module.rank K V) = Cardinal.lift.{v} (Module.rank K V')) :\n    Nonempty (V \u2243\u2097[K] V')", "start": [955, 1], "end": [963, 65], "kind": "commanddeclaration"}, {"full_name": "nonempty_linearEquiv_of_rank_eq", "code": "theorem nonempty_linearEquiv_of_rank_eq (cond : Module.rank K V = Module.rank K V\u2081) :\n    Nonempty (V \u2243\u2097[K] V\u2081)", "start": [966, 1], "end": [969, 59], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLiftRankEq", "code": "def LinearEquiv.ofLiftRankEq\n    (cond : Cardinal.lift.{v'} (Module.rank K V) = Cardinal.lift.{v} (Module.rank K V')) :\n    V \u2243\u2097[K] V' :=\n  Classical.choice (nonempty_linearEquiv_of_lift_rank_eq cond)", "start": [976, 1], "end": [980, 63], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofRankEq", "code": "def LinearEquiv.ofRankEq (cond : Module.rank K V = Module.rank K V\u2081) : V \u2243\u2097[K] V\u2081 :=\n  Classical.choice (nonempty_linearEquiv_of_rank_eq cond)", "start": [983, 1], "end": [985, 58], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.nonempty_equiv_iff_lift_rank_eq", "code": "theorem LinearEquiv.nonempty_equiv_iff_lift_rank_eq : Nonempty (V \u2243\u2097[K] V') \u2194\n    Cardinal.lift.{v'} (Module.rank K V) = Cardinal.lift.{v} (Module.rank K V')", "start": [990, 1], "end": [993, 91], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.nonempty_equiv_iff_rank_eq", "code": "theorem LinearEquiv.nonempty_equiv_iff_rank_eq :\n    Nonempty (V \u2243\u2097[K] V\u2081) \u2194 Module.rank K V = Module.rank K V\u2081", "start": [996, 1], "end": [999, 81], "kind": "commanddeclaration"}, {"full_name": "rank_prod", "code": "@[simp]\ntheorem rank_prod : Module.rank K (V \u00d7 V') =\n    Cardinal.lift.{v'} (Module.rank K V) + Cardinal.lift.{v, v'} (Module.rank K V')", "start": [1002, 1], "end": [1008, 82], "kind": "commanddeclaration"}, {"full_name": "rank_prod'", "code": "theorem rank_prod' : Module.rank K (V \u00d7 V\u2081) = Module.rank K V + Module.rank K V\u2081", "start": [1011, 1], "end": [1013, 92], "kind": "commanddeclaration"}, {"full_name": "rank_ulift", "code": "@[simp]\ntheorem rank_ulift : Module.rank K (ULift.{w} V) = Cardinal.lift.{w} (Module.rank K V)", "start": [1016, 1], "end": [1018, 100], "kind": "commanddeclaration"}, {"full_name": "rank_pi", "code": "@[simp]\ntheorem rank_pi [Finite \u03b7] : Module.rank K (\u2200 i, \u03c6 i) =\n    Cardinal.sum fun i => Module.rank K (\u03c6 i)", "start": [1026, 1], "end": [1034, 55], "kind": "commanddeclaration"}, {"full_name": "rank_fun", "code": "theorem rank_fun {V \u03b7 : Type u} [Fintype \u03b7] [AddCommGroup V] [Module K V] [Module.Free K V] :\n    Module.rank K (\u03b7 \u2192 V) = Fintype.card \u03b7 * Module.rank K V", "start": [1039, 1], "end": [1041, 57], "kind": "commanddeclaration"}, {"full_name": "rank_fun_eq_lift_mul", "code": "theorem rank_fun_eq_lift_mul : Module.rank K (\u03b7 \u2192 V) =\n    (Fintype.card \u03b7 : Cardinal.{max u\u2081' v}) * Cardinal.lift.{u\u2081'} (Module.rank K V)", "start": [1044, 1], "end": [1046, 82], "kind": "commanddeclaration"}, {"full_name": "rank_fun'", "code": "theorem rank_fun' : Module.rank K (\u03b7 \u2192 K) = Fintype.card \u03b7", "start": [1049, 1], "end": [1050, 89], "kind": "commanddeclaration"}, {"full_name": "rank_fin_fun", "code": "theorem rank_fin_fun (n : \u2115) : Module.rank K (Fin n \u2192 K) = n", "start": [1053, 1], "end": [1053, 84], "kind": "commanddeclaration"}, {"full_name": "finDimVectorspaceEquiv", "code": "def finDimVectorspaceEquiv (n : \u2115) (hn : Module.rank K V = n) : V \u2243\u2097[K] Fin n \u2192 K := by\n  haveI := nontrivial_of_invariantBasisNumber K\n  have : Cardinal.lift.{u} (n : Cardinal.{v}) = Cardinal.lift.{v} (n : Cardinal.{u}) := by simp\n  have hn := Cardinal.lift_inj.{v, u}.2 hn\n  rw [this] at hn\n  rw [\u2190 @rank_fin_fun K _ _ n] at hn\n  haveI : Module.Free K (Fin n \u2192 K) := Module.Free.pi _ _\n  exact Classical.choice (nonempty_linearEquiv_of_lift_rank_eq hn)", "start": [1059, 1], "end": [1067, 67], "kind": "commanddeclaration"}, {"full_name": "Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0", "code": "theorem Basis.finite_ofVectorSpaceIndex_of_rank_lt_aleph0 (h : Module.rank K V < \u2135\u2080) :\n    (Basis.ofVectorSpaceIndex K V).Finite", "start": [1082, 1], "end": [1085, 87], "kind": "commanddeclaration"}, {"full_name": "rank_span_le", "code": "theorem rank_span_le (s : Set V) : Module.rank K (span K s) \u2264 #s", "start": [1091, 1], "end": [1094, 34], "kind": "commanddeclaration"}, {"full_name": "rank_span_of_finset", "code": "theorem rank_span_of_finset (s : Finset V) : Module.rank K (span K (\u2191s : Set V)) < \u2135\u2080", "start": [1097, 1], "end": [1101, 39], "kind": "commanddeclaration"}, {"full_name": "rank_quotient_add_rank", "code": "theorem rank_quotient_add_rank (p : Submodule K V) :\n    Module.rank K (V \u29f8 p) + Module.rank K p = Module.rank K V", "start": [1104, 1], "end": [1108, 42], "kind": "commanddeclaration"}, {"full_name": "rank_range_add_rank_ker", "code": "theorem rank_range_add_rank_ker (f : V \u2192\u2097[K] V\u2081) :\n    Module.rank K (LinearMap.range f) + Module.rank K (LinearMap.ker f) = Module.rank K V", "start": [1111, 1], "end": [1115, 61], "kind": "commanddeclaration"}, {"full_name": "rank_eq_of_surjective", "code": "theorem rank_eq_of_surjective (f : V \u2192\u2097[K] V\u2081) (h : Surjective f) :\n    Module.rank K V = Module.rank K V\u2081 + Module.rank K (LinearMap.ker f)", "start": [1118, 1], "end": [1120, 67], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_cons_of_lt_rank", "code": "theorem exists_linearIndependent_cons_of_lt_rank {n : \u2115} {v : Fin n \u2192 V}\n    (hv : LinearIndependent K v) (h : n < Module.rank K V) :\n    \u2203 (x : V), LinearIndependent K (Fin.cons x v)", "start": [1123, 1], "end": [1139, 51], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_snoc_of_lt_rank", "code": "theorem exists_linearIndependent_snoc_of_lt_rank {n : \u2115} {v : Fin n \u2192 V}\n    (hv : LinearIndependent K v) (h : n < Module.rank K V) :\n    \u2203 (x : V), LinearIndependent K (Fin.snoc v x)", "start": [1141, 1], "end": [1147, 56], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_pair_of_one_lt_rank", "code": "theorem exists_linearIndependent_pair_of_one_lt_rank\n    (h : 1 < Module.rank K V) {x : V} (hx : x \u2260 0) :\n    \u2203 y, LinearIndependent K ![x, y]", "start": [1149, 1], "end": [1157, 16], "kind": "commanddeclaration"}, {"full_name": "rank_add_rank_split", "code": "theorem rank_add_rank_split (db : V\u2082 \u2192\u2097[K] V) (eb : V\u2083 \u2192\u2097[K] V) (cd : V\u2081 \u2192\u2097[K] V\u2082)\n    (ce : V\u2081 \u2192\u2097[K] V\u2083) (hde : \u22a4 \u2264 LinearMap.range db \u2294 LinearMap.range eb) (hgd : ker cd = \u22a5)\n    (eq : db.comp cd = eb.comp ce) (eq\u2082 : \u2200 d e, db d = eb e \u2192 \u2203 c, cd c = d \u2227 ce c = e) :\n    Module.rank K V + Module.rank K V\u2081 = Module.rank K V\u2082 + Module.rank K V\u2083", "start": [1167, 1], "end": [1195, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.rank_sup_add_rank_inf_eq", "code": "theorem Submodule.rank_sup_add_rank_inf_eq (s t : Submodule K V) :\n    Module.rank K (s \u2294 t : Submodule K V) + Module.rank K (s \u2293 t : Submodule K V) =\n    Module.rank K s + Module.rank K t", "start": [1198, 1], "end": [1210, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.rank_add_le_rank_add_rank", "code": "theorem Submodule.rank_add_le_rank_add_rank (s t : Submodule K V) :\n    Module.rank K (s \u2294 t : Submodule K V) \u2264 Module.rank K s + Module.rank K t", "start": [1213, 1], "end": [1216, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.ofRankEqZero", "code": "def Basis.ofRankEqZero {\u03b9 : Type*} [IsEmpty \u03b9] (hV : Module.rank K V = 0) : Basis \u03b9 K V :=\n  haveI : Subsingleton V := rank_zero_iff.1 hV\n  Basis.empty _", "start": [1229, 1], "end": [1235, 16], "kind": "commanddeclaration"}, {"full_name": "Basis.ofRankEqZero_apply", "code": "@[simp]\ntheorem Basis.ofRankEqZero_apply {\u03b9 : Type*} [IsEmpty \u03b9] (hV : Module.rank K V = 0) (i : \u03b9) :\n    Basis.ofRankEqZero hV i = 0", "start": [1238, 1], "end": [1241, 6], "kind": "commanddeclaration"}, {"full_name": "le_rank_iff_exists_linearIndependent", "code": "theorem le_rank_iff_exists_linearIndependent {c : Cardinal} :\n    c \u2264 Module.rank K V \u2194 \u2203 s : Set V, #s = c \u2227 LinearIndependent K ((\u2191) : s \u2192 V)", "start": [1244, 1], "end": [1253, 51], "kind": "commanddeclaration"}, {"full_name": "le_rank_iff_exists_linearIndependent_finset", "code": "theorem le_rank_iff_exists_linearIndependent_finset {n : \u2115} : \u2191n \u2264 Module.rank K V \u2194\n    \u2203 s : Finset V, s.card = n \u2227 LinearIndependent K ((\u2191) : \u21a5(s : Set V) \u2192 V)", "start": [1256, 1], "end": [1263, 33], "kind": "commanddeclaration"}, {"full_name": "rank_le_one_iff", "code": "theorem rank_le_one_iff : Module.rank K V \u2264 1 \u2194 \u2203 v\u2080 : V, \u2200 v, \u2203 r : K, r \u2022 v\u2080 = v", "start": [1266, 1], "end": [1289, 9], "kind": "commanddeclaration"}, {"full_name": "rank_submodule_le_one_iff", "code": "theorem rank_submodule_le_one_iff (s : Submodule K V) :\n    Module.rank K s \u2264 1 \u2194 \u2203 v\u2080 \u2208 s, s \u2264 K \u2219 v\u2080", "start": [1292, 1], "end": [1312, 13], "kind": "commanddeclaration"}, {"full_name": "rank_submodule_le_one_iff'", "code": "theorem rank_submodule_le_one_iff' (s : Submodule K V) :\n    Module.rank K s \u2264 1 \u2194 \u2203 v\u2080, s \u2264 K \u2219 v\u2080", "start": [1315, 1], "end": [1335, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.rank_le_one_iff_isPrincipal", "code": "theorem Submodule.rank_le_one_iff_isPrincipal (W : Submodule K V) :\n    Module.rank K W \u2264 1 \u2194 W.IsPrincipal", "start": [1338, 1], "end": [1348, 68], "kind": "commanddeclaration"}, {"full_name": "Module.rank_le_one_iff_top_isPrincipal", "code": "theorem Module.rank_le_one_iff_top_isPrincipal :\n    Module.rank K V \u2264 1 \u2194 (\u22a4 : Submodule K V).IsPrincipal", "start": [1351, 1], "end": [1353, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank", "code": "abbrev rank (f : V \u2192\u2097[K] V') : Cardinal :=\n  Module.rank K (LinearMap.range f)", "start": [1371, 1], "end": [1373, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_le_range", "code": "theorem rank_le_range (f : V \u2192\u2097[K] V') : rank f \u2264 Module.rank K V'", "start": [1376, 1], "end": [1377, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_le_domain", "code": "theorem rank_le_domain (f : V \u2192\u2097[K] V\u2081) : rank f \u2264 Module.rank K V", "start": [1380, 1], "end": [1381, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_zero", "code": "@[simp]\ntheorem rank_zero [Nontrivial K] : rank (0 : V \u2192\u2097[K] V') = 0", "start": [1384, 1], "end": [1386, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_comp_le_left", "code": "theorem rank_comp_le_left (g : V \u2192\u2097[K] V') (f : V' \u2192\u2097[K] V'') : rank (f.comp g) \u2264 rank f", "start": [1391, 1], "end": [1394, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lift_rank_comp_le_right", "code": "theorem lift_rank_comp_le_right (g : V \u2192\u2097[K] V') (f : V' \u2192\u2097[K] V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) \u2264 Cardinal.lift.{v''} (rank g)", "start": [1397, 1], "end": [1399, 68], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lift_rank_comp_le", "code": "theorem lift_rank_comp_le (g : V \u2192\u2097[K] V') (f : V' \u2192\u2097[K] V'') :\n    Cardinal.lift.{v'} (rank (f.comp g)) \u2264\n      min (Cardinal.lift.{v'} (rank f)) (Cardinal.lift.{v''} (rank g))", "start": [1402, 1], "end": [1406, 87], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_comp_le_right", "code": "theorem rank_comp_le_right (g : V \u2192\u2097[K] V') (f : V' \u2192\u2097[K] V'\u2081) : rank (f.comp g) \u2264 rank g", "start": [1411, 1], "end": [1412, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_comp_le", "code": "theorem rank_comp_le (g : V \u2192\u2097[K] V') (f : V' \u2192\u2097[K] V'\u2081) :\n    rank (f.comp g) \u2264 min (rank f) (rank g)", "start": [1415, 1], "end": [1420, 60], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_add_le", "code": "theorem rank_add_le (f g : V \u2192\u2097[K] V') : rank (f + g) \u2264 rank f + rank g", "start": [1431, 1], "end": [1438, 67], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rank_finset_sum_le", "code": "theorem rank_finset_sum_le {\u03b7} (s : Finset \u03b7) (f : \u03b7 \u2192 V \u2192\u2097[K] V') :\n    rank (\u2211 d in s, f d) \u2264 \u2211 d in s, rank (f d)", "start": [1441, 1], "end": [1444, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.le_rank_iff_exists_linearIndependent", "code": "theorem le_rank_iff_exists_linearIndependent {c : Cardinal} {f : V \u2192\u2097[K] V'} :\n    c \u2264 rank f \u2194 \u2203 s : Set V, Cardinal.lift.{v'} #s =\n    Cardinal.lift.{v} c \u2227 LinearIndependent K fun x : s => f x", "start": [1447, 1], "end": [1466, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.le_rank_iff_exists_linearIndependent_finset", "code": "theorem le_rank_iff_exists_linearIndependent_finset {n : \u2115} {f : V \u2192\u2097[K] V'} :\n    \u2191n \u2264 rank f \u2194 \u2203 s : Finset V, s.card = n \u2227 LinearIndependent K fun x : (s : Set V) => f x", "start": [1469, 1], "end": [1477, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Palindrome.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Palindrome", "code": "inductive Palindrome : List \u03b1 \u2192 Prop\n  | nil : Palindrome []\n  | singleton : \u2200 x, Palindrome [x]\n  | cons_concat : \u2200 (x) {l}, Palindrome l \u2192 Palindrome (x :: (l ++ [x]))", "start": [34, 1], "end": [43, 73], "kind": "commanddeclaration"}, {"full_name": "List.Palindrome.reverse_eq", "code": "theorem reverse_eq {l : List \u03b1} (p : Palindrome l) : reverse l = l", "start": [50, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "List.Palindrome.of_reverse_eq", "code": "theorem of_reverse_eq {l : List \u03b1} : reverse l = l \u2192 Palindrome l", "start": [55, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "List.Palindrome.iff_reverse_eq", "code": "theorem iff_reverse_eq {l : List \u03b1} : Palindrome l \u2194 reverse l = l", "start": [64, 1], "end": [65, 37], "kind": "commanddeclaration"}, {"full_name": "List.Palindrome.append_reverse", "code": "theorem append_reverse (l : List \u03b1) : Palindrome (l ++ reverse l)", "start": [68, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "List.Palindrome.map", "code": "protected theorem map (f : \u03b1 \u2192 \u03b2) (p : Palindrome l) : Palindrome (map f l)", "start": [73, 1], "end": [74, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/ModEq.lean", "imports": ["Mathlib/Tactic/GCongr/Core.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean", "lake-packages/std/Std/Data/Int/DivMod.lean", "Mathlib/Data/Nat/ModEq.lean"], "premises": [{"full_name": "Int.ModEq", "code": "def ModEq (n a b : \u2124) :=\n  a % n = b % n", "start": [30, 1], "end": [32, 16], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.refl", "code": "@[refl]\nprotected theorem refl (a : \u2124) : a \u2261 a [ZMOD n]", "start": [45, 1], "end": [47, 11], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.rfl", "code": "protected theorem rfl : a \u2261 a [ZMOD n]", "start": [50, 1], "end": [51, 15], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.symm", "code": "@[symm]\nprotected theorem symm : a \u2261 b [ZMOD n] \u2192 b \u2261 a [ZMOD n]", "start": [57, 1], "end": [59, 10], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.trans", "code": "@[trans]\nprotected theorem trans : a \u2261 b [ZMOD n] \u2192 b \u2261 c [ZMOD n] \u2192 a \u2261 c [ZMOD n]", "start": [62, 1], "end": [64, 11], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.eq", "code": "protected theorem eq : a \u2261 b [ZMOD n] \u2192 a % n = b % n", "start": [70, 1], "end": [70, 60], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_comm", "code": "theorem modEq_comm : a \u2261 b [ZMOD n] \u2194 b \u2261 a [ZMOD n]", "start": [75, 1], "end": [75, 81], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_modEq_iff", "code": "theorem coe_nat_modEq_iff {a b n : \u2115} : a \u2261 b [ZMOD n] \u2194 a \u2261 b [MOD n]", "start": [78, 1], "end": [79, 67], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_zero_iff_dvd", "code": "theorem modEq_zero_iff_dvd : a \u2261 0 [ZMOD n] \u2194 n \u2223 a", "start": [82, 1], "end": [83, 46], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.modEq_zero_int", "code": "theorem _root_.Dvd.dvd.modEq_zero_int (h : n \u2223 a) : a \u2261 0 [ZMOD n]", "start": [86, 1], "end": [87, 25], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.zero_modEq_int", "code": "theorem _root_.Dvd.dvd.zero_modEq_int (h : n \u2223 a) : 0 \u2261 a [ZMOD n]", "start": [90, 1], "end": [91, 24], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_iff_dvd", "code": "theorem modEq_iff_dvd : a \u2261 b [ZMOD n] \u2194 n \u2223 b - a", "start": [94, 1], "end": [96, 65], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_iff_add_fac", "code": "theorem modEq_iff_add_fac {a b n : \u2124} : a \u2261 b [ZMOD n] \u2194 \u2203 t, b = a + n * t", "start": [99, 1], "end": [101, 49], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.dvd", "code": "alias \u27e8ModEq.dvd, modEq_of_dvd\u27e9 := modEq_iff_dvd", "start": [104, 1], "end": [104, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.modEq_of_dvd", "code": "alias \u27e8ModEq.dvd, modEq_of_dvd\u27e9 := modEq_iff_dvd", "start": [104, 1], "end": [104, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.mod_modEq", "code": "theorem mod_modEq (a n) : a % n \u2261 a [ZMOD n]", "start": [108, 1], "end": [109, 16], "kind": "commanddeclaration"}, {"full_name": "Int.neg_modEq_neg", "code": "@[simp]\ntheorem neg_modEq_neg : -a \u2261 -b [ZMOD n] \u2194 a \u2261 b [ZMOD n]", "start": [112, 1], "end": [115, 67], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_neg", "code": "@[simp]\ntheorem modEq_neg : a \u2261 b [ZMOD -n] \u2194 a \u2261 b [ZMOD n]", "start": [118, 1], "end": [119, 80], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.of_dvd", "code": "protected theorem of_dvd (d : m \u2223 n) (h : a \u2261 b [ZMOD n]) : a \u2261 b [ZMOD m]", "start": [124, 1], "end": [125, 35], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.mul_left'", "code": "protected theorem mul_left' (h : a \u2261 b [ZMOD n]) : c * a \u2261 c * b [ZMOD c * n]", "start": [128, 1], "end": [133, 56], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.mul_right'", "code": "protected theorem mul_right' (h : a \u2261 b [ZMOD n]) : a * c \u2261 b * c [ZMOD n * c]", "start": [136, 1], "end": [137, 61], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add", "code": "@[gcongr]\nprotected theorem add (h\u2081 : a \u2261 b [ZMOD n]) (h\u2082 : c \u2261 d [ZMOD n]) : a + c \u2261 b + d [ZMOD n]", "start": [140, 1], "end": [144, 9], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_left", "code": "@[gcongr] protected theorem add_left (c : \u2124) (h : a \u2261 b [ZMOD n]) : c + a \u2261 c + b [ZMOD n]", "start": [147, 1], "end": [148, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_right", "code": "@[gcongr] protected theorem add_right (c : \u2124) (h : a \u2261 b [ZMOD n]) : a + c \u2261 b + c [ZMOD n]", "start": [151, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_left_cancel", "code": "protected theorem add_left_cancel (h\u2081 : a \u2261 b [ZMOD n]) (h\u2082 : a + c \u2261 b + d [ZMOD n]) :\n    c \u2261 d [ZMOD n]", "start": [155, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_left_cancel'", "code": "protected theorem add_left_cancel' (c : \u2124) (h : c + a \u2261 c + b [ZMOD n]) : a \u2261 b [ZMOD n]", "start": [163, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_right_cancel", "code": "protected theorem add_right_cancel (h\u2081 : c \u2261 d [ZMOD n]) (h\u2082 : a + c \u2261 b + d [ZMOD n]) :\n    a \u2261 b [ZMOD n]", "start": [167, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.add_right_cancel'", "code": "protected theorem add_right_cancel' (c : \u2124) (h : a + c \u2261 b + c [ZMOD n]) : a \u2261 b [ZMOD n]", "start": [173, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.neg", "code": "@[gcongr] protected theorem neg (h : a \u2261 b [ZMOD n]) : -a \u2261 -b [ZMOD n]", "start": [177, 1], "end": [178, 67], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.sub", "code": "@[gcongr]\nprotected theorem sub (h\u2081 : a \u2261 b [ZMOD n]) (h\u2082 : c \u2261 d [ZMOD n]) : a - c \u2261 b - d [ZMOD n]", "start": [181, 1], "end": [184, 22], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.sub_left", "code": "@[gcongr] protected theorem sub_left (c : \u2124) (h : a \u2261 b [ZMOD n]) : c - a \u2261 c - b [ZMOD n]", "start": [187, 1], "end": [188, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.sub_right", "code": "@[gcongr] protected theorem sub_right (c : \u2124) (h : a \u2261 b [ZMOD n]) : a - c \u2261 b - c [ZMOD n]", "start": [191, 1], "end": [192, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.mul_left", "code": "@[gcongr] protected theorem mul_left (c : \u2124) (h : a \u2261 b [ZMOD n]) : c * a \u2261 c * b [ZMOD n]", "start": [195, 1], "end": [196, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.mul_right", "code": "@[gcongr] protected theorem mul_right (c : \u2124) (h : a \u2261 b [ZMOD n]) : a * c \u2261 b * c [ZMOD n]", "start": [199, 1], "end": [200, 43], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.mul", "code": "@[gcongr]\nprotected theorem mul (h\u2081 : a \u2261 b [ZMOD n]) (h\u2082 : c \u2261 d [ZMOD n]) : a * c \u2261 b * d [ZMOD n]", "start": [203, 1], "end": [205, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.pow", "code": "@[gcongr] protected theorem pow (m : \u2115) (h : a \u2261 b [ZMOD n]) : a ^ m \u2261 b ^ m [ZMOD n]", "start": [208, 1], "end": [211, 17], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.of_mul_left", "code": "lemma of_mul_left (m : \u2124) (h : a \u2261 b [ZMOD m * n]) : a \u2261 b [ZMOD n] := by\n  rw [modEq_iff_dvd] at *; exact (dvd_mul_left n m).trans h", "start": [214, 1], "end": [215, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Int.ModEq.of_mul_right", "code": "lemma of_mul_right (m : \u2124) : a \u2261 b [ZMOD n * m] \u2192 a \u2261 b [ZMOD n] :=\n  mul_comm m n \u25b8 of_mul_left _", "start": [218, 1], "end": [219, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Int.ModEq.cancel_right_div_gcd", "code": "theorem cancel_right_div_gcd (hm : 0 < m) (h : a * c \u2261 b * c [ZMOD m]) :\n    a \u2261 b [ZMOD m / gcd m c]", "start": [222, 1], "end": [233, 88], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.cancel_left_div_gcd", "code": "theorem cancel_left_div_gcd (hm : 0 < m) (h : c * a \u2261 c * b [ZMOD m]) : a \u2261 b [ZMOD m / gcd m c]", "start": [236, 1], "end": [238, 57], "kind": "commanddeclaration"}, {"full_name": "Int.ModEq.of_div", "code": "theorem of_div (h : a / c \u2261 b / c [ZMOD m / c]) (ha : c \u2223 a) (ha : c \u2223 b) (ha : c \u2223 m) :\n    a \u2261 b [ZMOD m]", "start": [241, 1], "end": [242, 76], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_one", "code": "theorem modEq_one : a \u2261 b [ZMOD 1]", "start": [247, 1], "end": [248, 27], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_sub", "code": "theorem modEq_sub (a b : \u2124) : a \u2261 b [ZMOD a - b]", "start": [251, 1], "end": [252, 30], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_zero_iff", "code": "@[simp]\ntheorem modEq_zero_iff : a \u2261 b [ZMOD 0] \u2194 a = b", "start": [255, 1], "end": [256, 87], "kind": "commanddeclaration"}, {"full_name": "Int.add_modEq_left", "code": "@[simp]\ntheorem add_modEq_left : n + a \u2261 a [ZMOD n]", "start": [259, 1], "end": [260, 88], "kind": "commanddeclaration"}, {"full_name": "Int.add_modEq_right", "code": "@[simp]\ntheorem add_modEq_right : a + n \u2261 a [ZMOD n]", "start": [263, 1], "end": [264, 89], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_and_modEq_iff_modEq_mul", "code": "theorem modEq_and_modEq_iff_modEq_mul {a b m n : \u2124} (hmn : m.natAbs.Coprime n.natAbs) :\n    a \u2261 b [ZMOD m] \u2227 a \u2261 b [ZMOD n] \u2194 a \u2261 b [ZMOD m * n]", "start": [267, 1], "end": [274, 50], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_a_modEq", "code": "theorem gcd_a_modEq (a b : \u2115) : (a : \u2124) * Nat.gcdA a b \u2261 Nat.gcd a b [ZMOD b]", "start": [277, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_add_fac", "code": "theorem modEq_add_fac {a b n : \u2124} (c : \u2124) (ha : a \u2261 b [ZMOD n]) : a + n * c \u2261 b [ZMOD n]", "start": [282, 1], "end": [286, 39], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_sub_fac", "code": "theorem modEq_sub_fac {a b n : \u2124} (c : \u2124) (ha : a \u2261 b [ZMOD n]) : a - n * c \u2261 b [ZMOD n]", "start": [289, 1], "end": [291, 7], "kind": "commanddeclaration"}, {"full_name": "Int.modEq_add_fac_self", "code": "theorem modEq_add_fac_self {a t n : \u2124} : a + n * t \u2261 a [ZMOD n]", "start": [293, 1], "end": [294, 28], "kind": "commanddeclaration"}, {"full_name": "Int.mod_coprime", "code": "theorem mod_coprime {a b : \u2115} (hab : Nat.Coprime a b) : \u2203 y : \u2124, a * y \u2261 1 [ZMOD b]", "start": [297, 1], "end": [304, 8], "kind": "commanddeclaration"}, {"full_name": "Int.exists_unique_equiv", "code": "theorem exists_unique_equiv (a : \u2124) {b : \u2124} (hb : 0 < b) :\n    \u2203 z : \u2124, 0 \u2264 z \u2227 z < b \u2227 z \u2261 a [ZMOD b]", "start": [307, 1], "end": [312, 52], "kind": "commanddeclaration"}, {"full_name": "Int.exists_unique_equiv_nat", "code": "theorem exists_unique_equiv_nat (a : \u2124) {b : \u2124} (hb : 0 < b) : \u2203 z : \u2115, \u2191z < b \u2227 \u2191z \u2261 a [ZMOD b]", "start": [315, 1], "end": [318, 73], "kind": "commanddeclaration"}, {"full_name": "Int.mod_mul_right_mod", "code": "theorem mod_mul_right_mod (a b c : \u2124) : a % (b * c) % b = a % b", "start": [321, 1], "end": [322, 33], "kind": "commanddeclaration"}, {"full_name": "Int.mod_mul_left_mod", "code": "theorem mod_mul_left_mod (a b c : \u2124) : a % (b * c) % c = a % c", "start": [325, 1], "end": [326, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/IntervalCases.lean", "imports": ["Mathlib/Tactic/FinCases.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.IntervalCases.IntervalCasesSubgoal", "code": "structure IntervalCasesSubgoal where\n  \n  rhs : Expr\n  \n  value : Int\n  \n  goal : MVarId", "start": [37, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Bound", "code": "inductive Bound\n  \n  | lt (n : \u2124)\n  \n  | le (n : \u2124)", "start": [47, 1], "end": [59, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Bound.asLower", "code": "def Bound.asLower : Bound \u2192 \u2124\n  | .lt n => n + 1\n  | .le n => n", "start": [61, 1], "end": [68, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Bound.asUpper", "code": "def Bound.asUpper : Bound \u2192 \u2124\n  | .lt n => n - 1\n  | .le n => n", "start": [70, 1], "end": [80, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.parseBound", "code": "def parseBound (ty : Expr) : MetaM (Expr \u00d7 Expr \u00d7 Bool \u00d7 Bool) := do\n  let ty \u2190 whnfR ty\n  if ty.isAppOfArity ``Not 1 then\n    let ty \u2190 whnfR ty.appArg!\n    if ty.isAppOfArity ``LT.lt 4 then\n      pure (ty.appArg!, ty.appFn!.appArg!, false, false)\n    else if ty.isAppOfArity ``LE.le 4 then\n      pure (ty.appArg!, ty.appFn!.appArg!, true, false)\n    else failure\n  else if ty.isAppOfArity ``LT.lt 4 then\n    pure (ty.appFn!.appArg!, ty.appArg!, true, true)\n  else if ty.isAppOfArity ``LE.le 4 then\n    pure (ty.appFn!.appArg!, ty.appArg!, false, true)\n  else failure", "start": [82, 1], "end": [101, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Methods", "code": "structure Methods where\n  \n  initLB (e : Expr) : MetaM (Bound \u00d7 Expr \u00d7 Expr) := failure\n  \n  initUB (e : Expr) : MetaM (Bound \u00d7 Expr \u00d7 Expr) := failure\n  \n  proveLE : Expr \u2192 Expr \u2192 MetaM Expr\n  \n  proveLT : Expr \u2192 Expr \u2192 MetaM Expr\n  \n  roundUp : Expr \u2192 Expr \u2192 Expr \u2192 Expr \u2192 MetaM Expr\n  \n  roundDown : Expr \u2192 Expr \u2192 Expr \u2192 Expr \u2192 MetaM Expr\n  \n  eval : Expr \u2192 MetaM (Int \u00d7 Expr \u00d7 Expr)\n  \n  mkNumeral : Int \u2192 MetaM Expr", "start": [103, 1], "end": [125, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_not_lt_left", "code": "theorem of_not_lt_left [LinearOrder \u03b1] (h : \u00ac(a:\u03b1) < b) (eq : a = a') : b \u2264 a'", "start": [127, 1], "end": [127, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_not_lt_right", "code": "theorem of_not_lt_right [LinearOrder \u03b1] (h : \u00ac(a:\u03b1) < b) (eq : b = b') : b' \u2264 a", "start": [128, 1], "end": [128, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_not_le_left", "code": "theorem of_not_le_left [LE \u03b1] (h : \u00ac(a:\u03b1) \u2264 b) (eq : a = a') : \u00aca' \u2264 b", "start": [129, 1], "end": [129, 81], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_not_le_right", "code": "theorem of_not_le_right [LE \u03b1] (h : \u00ac(a:\u03b1) \u2264 b) (eq : b = b') : \u00aca \u2264 b'", "start": [130, 1], "end": [130, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_lt_left", "code": "theorem of_lt_left [LinearOrder \u03b1] (h : (a:\u03b1) < b) (eq : a = a') : \u00acb \u2264 a'", "start": [131, 1], "end": [131, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_lt_right", "code": "theorem of_lt_right [LinearOrder \u03b1] (h : (a:\u03b1) < b) (eq : b = b') : \u00acb' \u2264 a", "start": [132, 1], "end": [132, 95], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_le_left", "code": "theorem of_le_left [LE \u03b1] (h : (a:\u03b1) \u2264 b) (eq : a = a') : a' \u2264 b", "start": [133, 1], "end": [133, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.of_le_right", "code": "theorem of_le_right [LE \u03b1] (h : (a:\u03b1) \u2264 b) (eq : b = b') : a \u2264 b'", "start": [134, 1], "end": [134, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Methods.getBound", "code": "def Methods.getBound (m : Methods) (e : Expr) (pf : Expr) (lb : Bool) :\n    MetaM (Bound \u00d7 Expr \u00d7 Expr) := do\n  let (e', c) \u2190 match \u2190 parseBound (\u2190 inferType pf), lb with\n    | (b, a, false, false), false =>\n      let (z, a', eq) \u2190 m.eval a; pure (b, .le z, a', \u2190 mkAppM ``of_not_lt_left #[pf, eq])\n    | (b, a, false, false), true =>\n      let (z, b', eq) \u2190 m.eval b; pure (a, .le z, b', \u2190 mkAppM ``of_not_lt_right #[pf, eq])\n    | (a, b, false, true), false =>\n      let (z, b', eq) \u2190 m.eval b; pure (a, .le z, b', \u2190 mkAppM ``of_le_right #[pf, eq])\n    | (a, b, false, true), true =>\n      let (z, a', eq) \u2190 m.eval a; pure (b, .le z, a', \u2190 mkAppM ``of_le_left #[pf, eq])\n    | (b, a, true, false), false =>\n      let (z, a', eq) \u2190 m.eval a; pure (b, .lt z, a', \u2190 mkAppM ``of_not_le_left #[pf, eq])\n    | (b, a, true, false), true =>\n      let (z, b', eq) \u2190 m.eval b; pure (a, .lt z, b', \u2190 mkAppM ``of_not_le_right #[pf, eq])\n    | (a, b, true, true), false =>\n      let (z, b', eq) \u2190 m.eval b; pure (a, .lt z, b', \u2190 mkAppM ``of_lt_right #[pf, eq])\n    | (a, b, true, true), true =>\n      let (z, a', eq) \u2190 m.eval a; pure (b, .lt z, a', \u2190 mkAppM ``of_lt_left #[pf, eq])\n  let .true \u2190 withNewMCtxDepth <| withReducible <| isDefEq e e' | failure\n  pure c", "start": [136, 1], "end": [161, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.le_of_not_le_of_le", "code": "theorem le_of_not_le_of_le [LinearOrder \u03b1] (h1 : \u00achi \u2264 n) (h2 : hi \u2264 lo) : (n:\u03b1) \u2264 lo", "start": [163, 1], "end": [164, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Methods.inconsistentBounds", "code": "def Methods.inconsistentBounds (m : Methods)\n    (z1 z2 : Bound) (e1 e2 p1 p2 e : Expr) : MetaM Expr := do\n  match z1, z2 with\n  | .le lo, .lt hi =>\n    if lo == hi then return p2.app p1\n    return p2.app (\u2190 mkAppM ``le_trans #[\u2190 m.proveLE e2 e1, p1])\n  | .lt lo, .le hi =>\n    if lo == hi then return p1.app p2\n    return p1.app (\u2190 mkAppM ``le_trans #[p2, \u2190 m.proveLE e2 e1])\n  | .le _, .le _ => return (\u2190 m.proveLT e2 e1).app (\u2190 mkAppM ``le_trans #[p1, p2])\n  | .lt lo, .lt hi =>\n    if hi \u2264 lo then return p1.app (\u2190 mkAppM ``le_of_not_le_of_le #[p2, \u2190 m.proveLE e2 e1])\n    let e3 \u2190 m.mkNumeral (hi - 1)\n    let p3 \u2190 m.roundDown e e2 e3 p2\n    return p1.app (\u2190 mkAppM ``le_trans #[p3, \u2190 m.proveLE e3 e1])", "start": [166, 1], "end": [184, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.Methods.bisect", "code": "partial def Methods.bisect (m : Methods) (g : MVarId) (cases : Subarray IntervalCasesSubgoal)\n    (z1 z2 : Bound) (e1 e2 p1 p2 e : Expr) : MetaM Unit := g.withContext do\n  if 1 < cases.size then\n    let tgt \u2190 g.getType\n    let mid := cases.size / 2\n    let z3 := z1.asLower + mid\n    let e3 \u2190 m.mkNumeral z3\n    let le \u2190 mkAppM ``LE.le #[e3, e]\n    let g\u2081 \u2190 mkFreshExprMVar (\u2190 mkArrow (mkNot le) tgt) .syntheticOpaque\n    let g\u2082 \u2190 mkFreshExprMVar (\u2190 mkArrow le tgt) .syntheticOpaque\n    g.assign <| \u2190 mkAppM ``dite #[le, g\u2082, g\u2081]\n    let (x\u2081, g\u2081) \u2190 g\u2081.mvarId!.intro1\n    m.bisect g\u2081 cases[:mid] z1 (.lt z3) e1 e3 p1 (.fvar x\u2081) e\n    let (x\u2082, g\u2082) \u2190 g\u2082.mvarId!.intro1\n    m.bisect g\u2082 cases[mid:] (.le z3) z2 e3 e2 (.fvar x\u2082) p2 e\n  else if _x : 0 < cases.size then\n    let { goal, rhs, .. } := cases[0]\n    let pf\u2081 \u2190 match z1 with | .le _ => pure p1 | .lt _ => m.roundUp e1 e rhs p1\n    let pf\u2082 \u2190 match z2 with | .le _ => pure p2 | .lt _ => m.roundDown e e2 rhs p2\n    g.assign (.app (.mvar goal) (\u2190 mkAppM ``le_antisymm #[pf\u2082, pf\u2081]))\n  else panic! \"no goals\"", "start": [186, 1], "end": [213, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.natMethods", "code": "def natMethods : Methods where\n  initLB (e : Q(\u2115)) :=\n    pure (.le 0, q(0), q(Nat.zero_le $e))\n  eval e := do\n    let \u27e8z, e, p\u27e9 := (\u2190 NormNum.derive (\u03b1 := (q(\u2115) : Q(Type))) e).toRawIntEq.get!\n    pure (z, e, p)\n  proveLE (lhs rhs : Q(\u2115)) := mkDecideProof q($lhs \u2264 $rhs)\n  proveLT (lhs rhs : Q(\u2115)) := mkDecideProof q(\u00ac$rhs \u2264 $lhs)\n  roundUp (lhs rhs _ : Q(\u2115)) (p : Q(\u00ac$rhs \u2264 $lhs)) := pure q(Nat.gt_of_not_le $p)\n  roundDown (lhs _ rhs' : Q(\u2115)) (p : Q(\u00acNat.succ $rhs' \u2264 $lhs)) := pure q(Nat.ge_of_not_lt $p)\n  mkNumeral\n    | (i : \u2115) => pure q($i)\n    | _ => failure", "start": [215, 1], "end": [229, 19], "kind": "commanddeclaration"}, {"full_name": "Int.add_one_le_of_not_le", "code": "theorem _root_.Int.add_one_le_of_not_le {a b : \u2124} (h : \u00acb \u2264 a) : a + 1 \u2264 b", "start": [231, 1], "end": [232, 40], "kind": "commanddeclaration"}, {"full_name": "Int.le_sub_one_of_not_le", "code": "theorem _root_.Int.le_sub_one_of_not_le {a b : \u2124} (h : \u00acb \u2264 a) : a \u2264 b - 1", "start": [233, 1], "end": [234, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.intMethods", "code": "def intMethods : Methods where\n  eval e := do\n    let \u27e8z, e, p\u27e9 := (\u2190 NormNum.derive (\u03b1 := (q(\u2124) : Q(Type))) e).toRawIntEq.get!\n    pure (z, e, p)\n  proveLE (lhs rhs : Q(\u2124)) := mkDecideProof q($lhs \u2264 $rhs)\n  proveLT (lhs rhs : Q(\u2124)) := mkDecideProof q(\u00ac$rhs \u2264 $lhs)\n  roundUp (lhs rhs _ : Q(\u2124)) (p : Q(\u00ac$rhs \u2264 $lhs)) := pure q(Int.add_one_le_of_not_le $p)\n  roundDown (lhs rhs _ : Q(\u2124)) (p : Q(\u00ac$rhs \u2264 $lhs)) := pure q(Int.le_sub_one_of_not_le $p)\n  mkNumeral\n    | (i : Nat) => let n : Q(\u2115) := mkRawNatLit i; pure q(OfNat.ofNat $n : \u2124)\n    | .negSucc i => let n : Q(\u2115) := mkRawNatLit (i+1); pure q(-OfNat.ofNat $n : \u2124)", "start": [236, 1], "end": [248, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.IntervalCases.intervalCases", "code": "def intervalCases (g : MVarId) (e e' : Expr) (lbs ubs : Array Expr) (mustUseBounds := false) :\n    MetaM (Array IntervalCasesSubgoal) := g.withContext do\n  let \u03b1 \u2190 whnfR (\u2190 inferType e)\n  let m \u2190\n    if \u03b1.isConstOf ``Nat then pure natMethods else\n    if \u03b1.isConstOf ``Int then pure intMethods else\n    throwError \"interval_cases failed: unsupported type {\u03b1}\"\n  let mut lb \u2190 try? (m.initLB e)\n  for pf in lbs do\n    if let some lb1 \u2190 try? (m.getBound e pf true) then\n      if lb.all (\u00b7.1.asLower < lb1.1.asLower) then\n        lb := some lb1\n    else if mustUseBounds then\n      throwError \"interval_cases failed: provided bound '{\u2190 inferType pf}' cannot be evaluated\"\n  let mut ub \u2190 try? (m.initUB e)\n  for pf in ubs do\n    if let some ub1 \u2190 try? (m.getBound e pf false) then\n      if ub.all (\u00b7.1.asUpper > ub1.1.asUpper) then\n        ub := some ub1\n    else if mustUseBounds then\n      throwError \"interval_cases failed: provided bound '{\u2190 inferType pf}' cannot be evaluated\"\n  match lb, ub with\n  | some (z1, e1, p1), some (z2, e2, p2) =>\n    if z1.asLower > z2.asUpper then\n      (\u2190 g.exfalso).assign (\u2190 m.inconsistentBounds z1 z2 e1 e2 p1 p2 e)\n      pure #[]\n    else\n      let mut goals := #[]\n      let lo := z1.asLower\n      let tgt \u2190 g.getType\n      let tag \u2190 g.getTag\n      for i in [:(z2.asUpper-lo+1).toNat] do\n        let z := lo+i\n        let rhs \u2190 m.mkNumeral z\n        let ty \u2190 mkArrow (\u2190 mkEq e rhs) tgt\n        let goal \u2190 mkFreshExprMVar ty .syntheticOpaque (appendTag tag (toString z))\n        goals := goals.push { rhs, value := z, goal := goal.mvarId! }\n      m.bisect g goals.toSubarray z1 z2 e1 e2 p1 p2 e\n      pure goals\n  | none, some _ => throwError \"interval_cases failed: could not find lower bound on {e'}\"\n  | some _, none => throwError \"interval_cases failed: could not find upper bound on {e'}\"\n  | none, none => throwError \"interval_cases failed: could not find bounds on {e'}\"", "start": [250, 1], "end": [318, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Log.lean", "imports": ["Mathlib/Data/Nat/Pow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.log", "code": "def log (b : \u2115) : \u2115 \u2192 \u2115\n  | n =>\n    if h : b \u2264 n \u2227 1 < b then\n      have : n / b < n := div_lt_self ((zero_lt_one.trans h.2).trans_le h.1) h.2\n      log b (n / b) + 1\n    else 0", "start": [27, 1], "end": [35, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.log_eq_zero_iff", "code": "@[simp]\ntheorem log_eq_zero_iff {b n : \u2115} : log b n = 0 \u2194 n < b \u2228 b \u2264 1", "start": [38, 1], "end": [41, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.log_of_lt", "code": "theorem log_of_lt {b n : \u2115} (hb : n < b) : log b n = 0", "start": [44, 1], "end": [45, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.log_of_left_le_one", "code": "theorem log_of_left_le_one {b : \u2115} (hb : b \u2264 1) (n) : log b n = 0", "start": [48, 1], "end": [49, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.log_pos_iff", "code": "@[simp]\ntheorem log_pos_iff {b n : \u2115} : 0 < log b n \u2194 b \u2264 n \u2227 1 < b", "start": [52, 1], "end": [54, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.log_pos", "code": "theorem log_pos {b n : \u2115} (hb : 1 < b) (hbn : b \u2264 n) : 0 < log b n", "start": [57, 1], "end": [58, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.log_of_one_lt_of_le", "code": "theorem log_of_one_lt_of_le {b n : \u2115} (h : 1 < b) (hn : b \u2264 n) : log b n = log b (n / b) + 1", "start": [61, 1], "end": [63, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.log_zero_left", "code": "@[simp]\ntheorem log_zero_left : \u2200 n, log 0 n = 0", "start": [66, 1], "end": [68, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.log_zero_right", "code": "@[simp]\ntheorem log_zero_right (b : \u2115) : log b 0 = 0", "start": [71, 1], "end": [73, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.log_one_left", "code": "@[simp]\ntheorem log_one_left : \u2200 n, log 1 n = 0", "start": [76, 1], "end": [78, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.log_one_right", "code": "@[simp]\ntheorem log_one_right (b : \u2115) : log b 1 = 0", "start": [81, 1], "end": [83, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_iff_le_log", "code": "theorem pow_le_iff_le_log {b : \u2115} (hb : 1 < b) {x y : \u2115} (hy : y \u2260 0) :\n    b ^ x \u2264 y \u2194 x \u2264 log b y", "start": [86, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_pow_iff_log_lt", "code": "theorem lt_pow_iff_log_lt {b : \u2115} (hb : 1 < b) {x y : \u2115} (hy : y \u2260 0) : y < b ^ x \u2194 log b y < x", "start": [103, 1], "end": [104, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_of_le_log", "code": "theorem pow_le_of_le_log {b x y : \u2115} (hy : y \u2260 0) (h : x \u2264 log b y) : b ^ x \u2264 y", "start": [107, 1], "end": [110, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.le_log_of_pow_le", "code": "theorem le_log_of_pow_le {b x y : \u2115} (hb : 1 < b) (h : b ^ x \u2264 y) : x \u2264 log b y", "start": [113, 1], "end": [115, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_log_le_self", "code": "theorem pow_log_le_self (b : \u2115) {x : \u2115} (hx : x \u2260 0) : b ^ log b x \u2264 x", "start": [118, 1], "end": [119, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.log_lt_of_lt_pow", "code": "theorem log_lt_of_lt_pow {b x y : \u2115} (hy : y \u2260 0) : y < b ^ x \u2192 log b y < x", "start": [122, 1], "end": [123, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_pow_of_log_lt", "code": "theorem lt_pow_of_log_lt {b x y : \u2115} (hb : 1 < b) : log b y < x \u2192 y < b ^ x", "start": [126, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_pow_succ_log_self", "code": "theorem lt_pow_succ_log_self {b : \u2115} (hb : 1 < b) (x : \u2115) : x < b ^ (log b x).succ", "start": [130, 1], "end": [131, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.log_eq_iff", "code": "theorem log_eq_iff {b m n : \u2115} (h : m \u2260 0 \u2228 1 < b \u2227 n \u2260 0) :\n    log b n = m \u2194 b ^ m \u2264 n \u2227 n < b ^ (m + 1)", "start": [134, 1], "end": [145, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.log_eq_of_pow_le_of_lt_pow", "code": "theorem log_eq_of_pow_le_of_lt_pow {b m n : \u2115} (h\u2081 : b ^ m \u2264 n) (h\u2082 : n < b ^ (m + 1)) :\n    log b n = m", "start": [148, 1], "end": [153, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.log_pow", "code": "theorem log_pow {b : \u2115} (hb : 1 < b) (x : \u2115) : log b (b ^ x) = x", "start": [156, 1], "end": [157, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.log_eq_one_iff'", "code": "theorem log_eq_one_iff' {b n : \u2115} : log b n = 1 \u2194 b \u2264 n \u2227 n < b * b", "start": [160, 1], "end": [161, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.log_eq_one_iff", "code": "theorem log_eq_one_iff {b n : \u2115} : log b n = 1 \u2194 n < b * b \u2227 1 < b \u2227 b \u2264 n", "start": [164, 1], "end": [166, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.log_mul_base", "code": "theorem log_mul_base {b n : \u2115} (hb : 1 < b) (hn : n \u2260 0) : log b (n * b) = log b n + 1", "start": [169, 1], "end": [172, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_log_le_add_one", "code": "theorem pow_log_le_add_one (b : \u2115) : \u2200 x, b ^ log b x \u2264 x + 1", "start": [175, 1], "end": [177, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.log_monotone", "code": "theorem log_monotone {b : \u2115} : Monotone (log b)", "start": [180, 1], "end": [185, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.log_mono_right", "code": "@[mono]\ntheorem log_mono_right {b n m : \u2115} (h : n \u2264 m) : log b n \u2264 log b m", "start": [188, 1], "end": [190, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.log_anti_left", "code": "@[mono]\ntheorem log_anti_left {b c n : \u2115} (hc : 1 < c) (hb : c \u2264 b) : log b n \u2264 log c n", "start": [193, 1], "end": [199, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.log_antitone_left", "code": "theorem log_antitone_left {n : \u2115} : AntitoneOn (fun b => log b n) (Set.Ioi 1)", "start": [202, 1], "end": [203, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.log_div_base", "code": "@[simp]\ntheorem log_div_base (b n : \u2115) : log b (n / b) = log b n - 1", "start": [206, 1], "end": [212, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.log_div_mul_self", "code": "@[simp]\ntheorem log_div_mul_self (b n : \u2115) : log b (n / b * b) = log b n", "start": [215, 1], "end": [222, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.add_pred_div_lt", "code": "theorem add_pred_div_lt {b n : \u2115} (hb : 1 < b) (hn : 2 \u2264 n) : (n + b - 1) / b < n", "start": [225, 1], "end": [228, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.clog", "code": "def clog (b : \u2115) : \u2115 \u2192 \u2115\n  | n =>\n    if h : 1 < b \u2227 1 < n then\n      have : (n + b - 1) / b < n := add_pred_div_lt h.1 h.2\n      clog b ((n + b - 1) / b) + 1\n    else 0", "start": [235, 1], "end": [243, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_of_left_le_one", "code": "theorem clog_of_left_le_one {b : \u2115} (hb : b \u2264 1) (n : \u2115) : clog b n = 0", "start": [246, 1], "end": [247, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_of_right_le_one", "code": "theorem clog_of_right_le_one {n : \u2115} (hn : n \u2264 1) (b : \u2115) : clog b n = 0", "start": [250, 1], "end": [251, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_zero_left", "code": "@[simp]\ntheorem clog_zero_left (n : \u2115) : clog 0 n = 0", "start": [254, 1], "end": [256, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_zero_right", "code": "@[simp]\ntheorem clog_zero_right (b : \u2115) : clog b 0 = 0", "start": [259, 1], "end": [261, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_one_left", "code": "@[simp]\ntheorem clog_one_left (n : \u2115) : clog 1 n = 0", "start": [264, 1], "end": [266, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_one_right", "code": "@[simp]\ntheorem clog_one_right (b : \u2115) : clog b 1 = 0", "start": [269, 1], "end": [271, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_of_two_le", "code": "theorem clog_of_two_le {b n : \u2115} (hb : 1 < b) (hn : 2 \u2264 n) :\n    clog b n = clog b ((n + b - 1) / b) + 1", "start": [274, 1], "end": [275, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_pos", "code": "theorem clog_pos {b n : \u2115} (hb : 1 < b) (hn : 2 \u2264 n) : 0 < clog b n", "start": [278, 1], "end": [280, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_eq_one", "code": "theorem clog_eq_one {b n : \u2115} (hn : 2 \u2264 n) (h : n \u2264 b) : clog b n = 1", "start": [283, 1], "end": [288, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_pow_iff_clog_le", "code": "theorem le_pow_iff_clog_le {b : \u2115} (hb : 1 < b) {x y : \u2115} : x \u2264 b ^ y \u2194 clog b x \u2264 y", "start": [291, 1], "end": [306, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_iff_lt_clog", "code": "theorem pow_lt_iff_lt_clog {b : \u2115} (hb : 1 < b) {x y : \u2115} : b ^ y < x \u2194 y < clog b x", "start": [309, 1], "end": [310, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_pow", "code": "theorem clog_pow (b x : \u2115) (hb : 1 < b) : clog b (b ^ x) = x", "start": [313, 1], "end": [316, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_pred_clog_lt_self", "code": "theorem pow_pred_clog_lt_self {b : \u2115} (hb : 1 < b) {x : \u2115} (hx : 1 < x) :\n    b ^ (clog b x).pred < x", "start": [319, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.le_pow_clog", "code": "theorem le_pow_clog {b : \u2115} (hb : 1 < b) (x : \u2115) : x \u2264 b ^ clog b x", "start": [325, 1], "end": [326, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_mono_right", "code": "@[mono]\ntheorem clog_mono_right (b : \u2115) {n m : \u2115} (h : n \u2264 m) : clog b n \u2264 clog b m", "start": [329, 1], "end": [335, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_anti_left", "code": "@[mono]\ntheorem clog_anti_left {b c n : \u2115} (hc : 1 < c) (hb : c \u2264 b) : clog b n \u2264 clog c n", "start": [338, 1], "end": [343, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_monotone", "code": "theorem clog_monotone (b : \u2115) : Monotone (clog b)", "start": [346, 1], "end": [346, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.clog_antitone_left", "code": "theorem clog_antitone_left {n : \u2115} : AntitoneOn (fun b : \u2115 => clog b n) (Set.Ioi 1)", "start": [349, 1], "end": [350, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.log_le_clog", "code": "theorem log_le_clog (b n : \u2115) : log b n \u2264 clog b n", "start": [353, 1], "end": [363, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Indexes.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/List/OfFn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.oldMapIdxCore", "code": "protected def oldMapIdxCore (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) : \u2115 \u2192 List \u03b1 \u2192 List \u03b2\n  | _, []      => []\n  | k, a :: as => f k a :: List.oldMapIdxCore f (k + 1) as", "start": [30, 1], "end": [33, 59], "kind": "commanddeclaration"}, {"full_name": "List.oldMapIdx", "code": "protected def oldMapIdx (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (as : List \u03b1) : List \u03b2 :=\n  List.oldMapIdxCore f 0 as", "start": [35, 1], "end": [38, 28], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_nil", "code": "@[simp]\ntheorem mapIdx_nil {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) : mapIdx f [] = []", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "List.oldMapIdxCore_eq", "code": "protected theorem oldMapIdxCore_eq (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (n : \u2115) :\n    l.oldMapIdxCore f n = l.oldMapIdx fun i a \u21a6 f (i + n) a", "start": [46, 1], "end": [51, 84], "kind": "commanddeclaration"}, {"full_name": "List.list_reverse_induction", "code": "theorem list_reverse_induction (p : List \u03b1 \u2192 Prop) (base : p [])\n    (ind : \u2200 (l : List \u03b1) (e : \u03b1), p l \u2192 p (l ++ [e])) : (\u2200 (l : List \u03b1), p l)", "start": [60, 1], "end": [70, 92], "kind": "commanddeclaration"}, {"full_name": "List.oldMapIdxCore_append", "code": "protected theorem oldMapIdxCore_append : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (n : \u2115) (l\u2081 l\u2082 : List \u03b1),\n    List.oldMapIdxCore f n (l\u2081 ++ l\u2082) =\n    List.oldMapIdxCore f n l\u2081 ++ List.oldMapIdxCore f (n + l\u2081.length) l\u2082", "start": [73, 1], "end": [91, 51], "kind": "commanddeclaration"}, {"full_name": "List.oldMapIdx_append", "code": "protected theorem oldMapIdx_append : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l : List \u03b1) (e : \u03b1),\n    List.oldMapIdx f (l ++ [e]) = List.oldMapIdx f l ++ [f l.length e]", "start": [94, 1], "end": [99, 51], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxGo_append", "code": "theorem mapIdxGo_append : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l\u2081 l\u2082 : List \u03b1) (arr : Array \u03b2),\n    mapIdx.go f (l\u2081 ++ l\u2082) arr = mapIdx.go f l\u2082 (List.toArray (mapIdx.go f l\u2081 arr))", "start": [102, 1], "end": [116, 37], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxGo_length", "code": "theorem mapIdxGo_length : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l : List \u03b1) (arr : Array \u03b2),\n    length (mapIdx.go f l arr) = length l + arr.size", "start": [119, 1], "end": [125, 53], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_append_one", "code": "theorem mapIdx_append_one : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l : List \u03b1) (e : \u03b1),\n    mapIdx f (l ++ [e]) = mapIdx f l ++ [f l.length e]", "start": [128, 1], "end": [134, 41], "kind": "commanddeclaration"}, {"full_name": "List.new_def_eq_old_def", "code": "protected theorem new_def_eq_old_def :\n    \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (l : List \u03b1), l.mapIdx f = List.oldMapIdx f l", "start": [137, 1], "end": [143, 53], "kind": "commanddeclaration"}, {"full_name": "List.map_enumFrom_eq_zipWith", "code": "@[local simp]\ntheorem map_enumFrom_eq_zipWith : \u2200 (l : List \u03b1) (n : \u2115) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2),\n    map (uncurry f) (enumFrom n l) = zipWith (fun i \u21a6 f (i + n)) (range (length l)) l", "start": [145, 1], "end": [163, 60], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_eq_enum_map", "code": "theorem mapIdx_eq_enum_map (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) :\n    l.mapIdx f = l.enum.map (Function.uncurry f)", "start": [165, 1], "end": [171, 62], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_cons", "code": "@[simp]\ntheorem mapIdx_cons {\u03b1 \u03b2} (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    mapIdx f (a :: l) = f 0 a :: mapIdx (fun i \u21a6 f (i + 1)) l", "start": [174, 1], "end": [178, 41], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_append", "code": "theorem mapIdx_append {\u03b1} (K L : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) :\n    (K ++ L).mapIdx f = K.mapIdx f ++ L.mapIdx fun i a \u21a6 f (i + K.length) a", "start": [181, 1], "end": [185, 43], "kind": "commanddeclaration"}, {"full_name": "List.length_mapIdx", "code": "@[simp]\ntheorem length_mapIdx {\u03b1 \u03b2} (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) : (l.mapIdx f).length = l.length", "start": [188, 1], "end": [192, 14], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_mapIdx", "code": "@[simp, deprecated]\ntheorem nthLe_mapIdx {\u03b1 \u03b2} (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) (i : \u2115) (h : i < l.length)\n    (h' : i < (l.mapIdx f).length := h.trans_le (l.length_mapIdx f).ge) :\n    (l.mapIdx f).nthLe i h' = f i (l.nthLe i h)", "start": [195, 1], "end": [199, 47], "kind": "commanddeclaration"}, {"full_name": "List.mapIdx_eq_ofFn", "code": "theorem mapIdx_eq_ofFn {\u03b1 \u03b2} (l : List \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b2) :\n    l.mapIdx f = ofFn fun i : Fin l.length \u21a6 f (i : \u2115) (l.get i)", "start": [203, 1], "end": [207, 14], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdxSpec", "code": "def foldrIdxSpec (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (as : List \u03b1) (start : \u2115) : \u03b2 :=\n  foldr (uncurry f) b <| enumFrom start as", "start": [215, 1], "end": [217, 43], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdxSpec_cons", "code": "theorem foldrIdxSpec_cons (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b a as start) :\n    foldrIdxSpec f b (a :: as) start = f start a (foldrIdxSpec f b as (start + 1))", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdx_eq_foldrIdxSpec", "code": "theorem foldrIdx_eq_foldrIdxSpec (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b as start) :\n    foldrIdx f b as start = foldrIdxSpec f b as start", "start": [225, 1], "end": [229, 47], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdx_eq_foldr_enum", "code": "theorem foldrIdx_eq_foldr_enum (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (as : List \u03b1) :\n    foldrIdx f b as = foldr (uncurry f) b (enum as)", "start": [232, 1], "end": [234, 69], "kind": "commanddeclaration"}, {"full_name": "List.indexesValues_eq_filter_enum", "code": "theorem indexesValues_eq_filter_enum (p : \u03b1 \u2192 Prop) [DecidablePred p] (as : List \u03b1) :\n    indexesValues p as = filter (p \u2218 Prod.snd) (enum as)", "start": [239, 1], "end": [241, 73], "kind": "commanddeclaration"}, {"full_name": "List.findIdxs_eq_map_indexesValues", "code": "theorem findIdxs_eq_map_indexesValues (p : \u03b1 \u2192 Prop) [DecidablePred p] (as : List \u03b1) :\n    findIdxs p as = map Prod.fst (indexesValues p as)", "start": [244, 1], "end": [247, 77], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdxSpec", "code": "def foldlIdxSpec (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) (bs : List \u03b2) (start : \u2115) : \u03b1 :=\n  foldl (fun a p \u21a6 f p.fst a p.snd) a <| enumFrom start bs", "start": [253, 1], "end": [255, 59], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdxSpec_cons", "code": "theorem foldlIdxSpec_cons (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a b bs start) :\n    foldlIdxSpec f a (b :: bs) start = foldlIdxSpec f (f start a b) bs (start + 1)", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdx_eq_foldlIdxSpec", "code": "theorem foldlIdx_eq_foldlIdxSpec (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a bs start) :\n    foldlIdx f a bs start = foldlIdxSpec f a bs start", "start": [263, 1], "end": [267, 27], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdx_eq_foldl_enum", "code": "theorem foldlIdx_eq_foldl_enum (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) (bs : List \u03b2) :\n    foldlIdx f a bs = foldl (fun a p \u21a6 f p.fst a p.snd) a (enum bs)", "start": [270, 1], "end": [272, 69], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdxM_eq_foldrM_enum", "code": "theorem foldrIdxM_eq_foldrM_enum {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b : \u03b2) (as : List \u03b1) [LawfulMonad m] :\n    foldrIdxM f b as = foldrM (uncurry f) b (enum as)", "start": [282, 1], "end": [284, 74], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdxM_eq_foldlM_enum", "code": "theorem foldlIdxM_eq_foldlM_enum [LawfulMonad m] {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b : \u03b2) (as : List \u03b1) :\n    foldlIdxM f b as = List.foldlM (fun b p \u21a6 f p.fst b p.snd) b (enum as)", "start": [287, 1], "end": [289, 58], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxMAuxSpec", "code": "def mapIdxMAuxSpec {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (start : \u2115) (as : List \u03b1) : m (List \u03b2) :=\n  List.traverse (uncurry f) <| enumFrom start as", "start": [299, 1], "end": [301, 49], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxMAuxSpec_cons", "code": "theorem mapIdxMAuxSpec_cons {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (start : \u2115) (a : \u03b1) (as : List \u03b1) :\n    mapIdxMAuxSpec f start (a :: as) = cons <$> f start a <*> mapIdxMAuxSpec f (start + 1) as", "start": [306, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxMGo_eq_mapIdxMAuxSpec", "code": "theorem mapIdxMGo_eq_mapIdxMAuxSpec {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (arr : Array \u03b2) (as : List \u03b1) :\n    mapIdxM.go f as arr = (arr.toList ++ \u00b7) <$> mapIdxMAuxSpec f arr.size as", "start": [311, 1], "end": [328, 26], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxM_eq_mmap_enum", "code": "theorem mapIdxM_eq_mmap_enum {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (as : List \u03b1) :\n    as.mapIdxM f = List.traverse (uncurry f) (enum as)", "start": [331, 1], "end": [334, 79], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxMAux'_eq_mapIdxMGo", "code": "theorem mapIdxMAux'_eq_mapIdxMGo {\u03b1} (f : \u2115 \u2192 \u03b1 \u2192 m PUnit) (as : List \u03b1) (arr : Array PUnit) :\n    mapIdxMAux' f arr.size as = mapIdxM.go f as arr *> pure PUnit.unit", "start": [344, 1], "end": [355, 91], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxM'_eq_mapIdxM", "code": "theorem mapIdxM'_eq_mapIdxM {\u03b1} (f : \u2115 \u2192 \u03b1 \u2192 m PUnit) (as : List \u03b1) :\n    mapIdxM' f as = mapIdxM as f *> pure PUnit.unit", "start": [358, 1], "end": [360, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "imports": ["Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Order/Filter/CountableInter.lean", "Mathlib/Order/Filter/Archimedean.lean", "Mathlib/Order/LiminfLimsup.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Order/Basic.lean"], "premises": [{"full_name": "isBounded_le_nhds", "code": "theorem isBounded_le_nhds (a : \u03b1) : (\ud835\udcdd a).IsBounded (\u00b7 \u2264 \u00b7)", "start": [36, 1], "end": [38, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isBoundedUnder_le", "code": "theorem Filter.Tendsto.isBoundedUnder_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : Tendsto u f (\ud835\udcdd a)) : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u", "start": [41, 1], "end": [43, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.bddAbove_range_of_cofinite", "code": "theorem Filter.Tendsto.bddAbove_range_of_cofinite {u : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : Tendsto u cofinite (\ud835\udcdd a)) : BddAbove (Set.range u)", "start": [46, 1], "end": [48, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.bddAbove_range", "code": "theorem Filter.Tendsto.bddAbove_range {u : \u2115 \u2192 \u03b1} {a : \u03b1} (h : Tendsto u atTop (\ud835\udcdd a)) :\n    BddAbove (Set.range u)", "start": [51, 1], "end": [53, 37], "kind": "commanddeclaration"}, {"full_name": "isCobounded_ge_nhds", "code": "theorem isCobounded_ge_nhds (a : \u03b1) : (\ud835\udcdd a).IsCobounded (\u00b7 \u2265 \u00b7)", "start": [56, 1], "end": [57, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isCoboundedUnder_ge", "code": "theorem Filter.Tendsto.isCoboundedUnder_ge {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} [NeBot f]\n    (h : Tendsto u f (\ud835\udcdd a)) : f.IsCoboundedUnder (\u00b7 \u2265 \u00b7) u", "start": [60, 1], "end": [62, 39], "kind": "commanddeclaration"}, {"full_name": "isBounded_ge_nhds", "code": "theorem isBounded_ge_nhds (a : \u03b1) : (\ud835\udcdd a).IsBounded (\u00b7 \u2265 \u00b7)", "start": [71, 1], "end": [72, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isBoundedUnder_ge", "code": "theorem Filter.Tendsto.isBoundedUnder_ge {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : Tendsto u f (\ud835\udcdd a)) : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u", "start": [75, 1], "end": [77, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.bddBelow_range_of_cofinite", "code": "theorem Filter.Tendsto.bddBelow_range_of_cofinite {u : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : Tendsto u cofinite (\ud835\udcdd a)) : BddBelow (Set.range u)", "start": [80, 1], "end": [82, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.bddBelow_range", "code": "theorem Filter.Tendsto.bddBelow_range {u : \u2115 \u2192 \u03b1} {a : \u03b1} (h : Tendsto u atTop (\ud835\udcdd a)) :\n    BddBelow (Set.range u)", "start": [85, 1], "end": [87, 37], "kind": "commanddeclaration"}, {"full_name": "isCobounded_le_nhds", "code": "theorem isCobounded_le_nhds (a : \u03b1) : (\ud835\udcdd a).IsCobounded (\u00b7 \u2264 \u00b7)", "start": [90, 1], "end": [91, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isCoboundedUnder_le", "code": "theorem Filter.Tendsto.isCoboundedUnder_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} [NeBot f]\n    (h : Tendsto u f (\ud835\udcdd a)) : f.IsCoboundedUnder (\u00b7 \u2264 \u00b7) u", "start": [94, 1], "end": [96, 39], "kind": "commanddeclaration"}, {"full_name": "le_nhds_of_limsSup_eq_limsInf", "code": "theorem le_nhds_of_limsSup_eq_limsInf {f : Filter \u03b1} {a : \u03b1} (hl : f.IsBounded (\u00b7 \u2264 \u00b7))\n    (hg : f.IsBounded (\u00b7 \u2265 \u00b7)) (hs : f.limsSup = a) (hi : f.limsInf = a) : f \u2264 \ud835\udcdd a", "start": [105, 1], "end": [110, 61], "kind": "commanddeclaration"}, {"full_name": "limsSup_nhds", "code": "theorem limsSup_nhds (a : \u03b1) : limsSup (\ud835\udcdd a) = a", "start": [114, 1], "end": [121, 78], "kind": "commanddeclaration"}, {"full_name": "limsInf_nhds", "code": "theorem limsInf_nhds : \u2200 a : \u03b1, limsInf (\ud835\udcdd a) = a", "start": [125, 1], "end": [126, 26], "kind": "commanddeclaration"}, {"full_name": "limsInf_eq_of_le_nhds", "code": "theorem limsInf_eq_of_le_nhds {f : Filter \u03b1} {a : \u03b1} [NeBot f] (h : f \u2264 \ud835\udcdd a) : f.limsInf = a", "start": [130, 1], "end": [141, 96], "kind": "commanddeclaration"}, {"full_name": "limsSup_eq_of_le_nhds", "code": "theorem limsSup_eq_of_le_nhds : \u2200 {f : Filter \u03b1} {a : \u03b1} [NeBot f], f \u2264 \ud835\udcdd a \u2192 f.limsSup = a", "start": [145, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.limsup_eq", "code": "theorem Filter.Tendsto.limsup_eq {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} [NeBot f]\n    (h : Tendsto u f (\ud835\udcdd a)) : limsup u f = a", "start": [151, 1], "end": [154, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.liminf_eq", "code": "theorem Filter.Tendsto.liminf_eq {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} [NeBot f]\n    (h : Tendsto u f (\ud835\udcdd a)) : liminf u f = a", "start": [157, 1], "end": [160, 26], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_liminf_eq_limsup", "code": "theorem tendsto_of_liminf_eq_limsup {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} (hinf : liminf u f = a)\n    (hsup : limsup u f = a) (h : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) : Tendsto u f (\ud835\udcdd a)", "start": [163, 1], "end": [168, 47], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_le_liminf_of_limsup_le", "code": "theorem tendsto_of_le_liminf_of_limsup_le {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} (hinf : a \u2264 liminf u f)\n    (hsup : limsup u f \u2264 a) (h : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) : Tendsto u f (\ud835\udcdd a)", "start": [171, 1], "end": [180, 70], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_no_upcrossings", "code": "theorem tendsto_of_no_upcrossings [DenselyOrdered \u03b1] {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {s : Set \u03b1}\n    (hs : Dense s) (H : \u2200 a \u2208 s, \u2200 b \u2208 s, a < b \u2192 \u00ac((\u2203\u1da0 n in f, u n < a) \u2227 \u2203\u1da0 n in f, b < u n))\n    (h : f.IsBoundedUnder (\u00b7 \u2264 \u00b7) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (\u00b7 \u2265 \u00b7) u := by isBoundedDefault) :\n    \u2203 c : \u03b1, Tendsto u f (\ud835\udcdd c)", "start": [183, 1], "end": [204, 30], "kind": "commanddeclaration"}, {"full_name": "eventually_le_limsup", "code": "theorem eventually_le_limsup (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) f u := by isBoundedDefault) :\n    \u2200\u1da0 b in f, u b \u2264 f.limsup u", "start": [209, 1], "end": [225, 16], "kind": "commanddeclaration"}, {"full_name": "eventually_liminf_le", "code": "theorem eventually_liminf_le (hf : IsBoundedUnder (\u00b7 \u2265 \u00b7) f u := by isBoundedDefault) :\n    \u2200\u1da0 b in f, f.liminf u \u2264 u b", "start": [228, 1], "end": [230, 37], "kind": "commanddeclaration"}, {"full_name": "limsup_eq_bot", "code": "@[simp]\ntheorem limsup_eq_bot : f.limsup u = \u22a5 \u2194 u =\u1da0[f] \u22a5", "start": [240, 1], "end": [247, 28], "kind": "commanddeclaration"}, {"full_name": "liminf_eq_top", "code": "@[simp]\ntheorem liminf_eq_top : f.liminf u = \u22a4 \u2194 u =\u1da0[f] \u22a4", "start": [250, 1], "end": [252, 27], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_limsSup_of_continuousAt", "code": "theorem Antitone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R \u2192 S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault) :\n    f F.limsSup = F.liminf f", "start": [265, 1], "end": [313, 37], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_limsup_of_continuousAt", "code": "theorem Antitone.map_limsup_of_continuousAt {f : R \u2192 S} (f_decr : Antitone f) (a : \u03b9 \u2192 R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) a := by isBoundedDefault) :\n    f (F.limsup a) = F.liminf (f \u2218 a)", "start": [317, 1], "end": [325, 64], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_limsInf_of_continuousAt", "code": "theorem Antitone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R \u2192 S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsInf)\n    (bdd_above : F.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault) : f F.limsInf = F.limsup f", "start": [328, 1], "end": [335, 100], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_liminf_of_continuousAt", "code": "theorem Antitone.map_liminf_of_continuousAt {f : R \u2192 S} (f_decr : Antitone f) (a : \u03b9 \u2192 R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) a := by isBoundedDefault) :\n    f (F.liminf a) = F.limsup (f \u2218 a)", "start": [339, 1], "end": [347, 64], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_limsSup_of_continuousAt", "code": "theorem Monotone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R \u2192 S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault) : f F.limsSup = F.limsup f", "start": [350, 1], "end": [357, 84], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_limsup_of_continuousAt", "code": "theorem Monotone.map_limsup_of_continuousAt {f : R \u2192 S} (f_incr : Monotone f) (a : \u03b9 \u2192 R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) a := by isBoundedDefault) :\n    f (F.limsup a) = F.limsup (f \u2218 a)", "start": [361, 1], "end": [369, 64], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_limsInf_of_continuousAt", "code": "theorem Monotone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R \u2192 S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsInf)\n    (bdd_above : F.IsBounded (\u00b7 \u2264 \u00b7) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (\u00b7 \u2265 \u00b7) := by isBoundedDefault) : f F.limsInf = F.liminf f", "start": [372, 1], "end": [379, 89], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_liminf_of_continuousAt", "code": "theorem Monotone.map_liminf_of_continuousAt {f : R \u2192 S} (f_incr : Monotone f) (a : \u03b9 \u2192 R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) a := by isBoundedDefault) :\n    f (F.liminf a) = F.liminf (f \u2218 a)", "start": [383, 1], "end": [391, 64], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_of_forall_le_of_tendsto", "code": "theorem iInf_eq_of_forall_le_of_tendsto {x : R} {as : \u03b9 \u2192 R} (x_le : \u2200 i, x \u2264 as i) {F : Filter \u03b9}\n    [Filter.NeBot F] (as_lim : Filter.Tendsto as F (\ud835\udcdd x)) : \u2a05 i, as i = x", "start": [404, 1], "end": [407, 100], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_of_forall_le_of_tendsto", "code": "theorem iSup_eq_of_forall_le_of_tendsto {x : R} {as : \u03b9 \u2192 R} (le_x : \u2200 i, as i \u2264 x) {F : Filter \u03b9}\n    [Filter.NeBot F] (as_lim : Filter.Tendsto as F (\ud835\udcdd x)) : \u2a06 i, as i = x", "start": [410, 1], "end": [412, 57], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ici_eq_Ioi_of_lt_of_tendsto", "code": "theorem iUnion_Ici_eq_Ioi_of_lt_of_tendsto {\u03b9 : Type*} (x : R) {as : \u03b9 \u2192 R} (x_lt : \u2200 i, x < as i)\n    {F : Filter \u03b9} [Filter.NeBot F] (as_lim : Filter.Tendsto as F (\ud835\udcdd x)) :\n    \u22c3 i : \u03b9, Ici (as i) = Ioi x", "start": [415, 1], "end": [426, 35], "kind": "commanddeclaration"}, {"full_name": "iUnion_Iic_eq_Iio_of_lt_of_tendsto", "code": "theorem iUnion_Iic_eq_Iio_of_lt_of_tendsto {\u03b9 : Type*} (x : R) {as : \u03b9 \u2192 R} (lt_x : \u2200 i, as i < x)\n    {F : Filter \u03b9} [Filter.NeBot F] (as_lim : Filter.Tendsto as F (\ud835\udcdd x)) :\n    \u22c3 i : \u03b9, Iic (as i) = Iio x", "start": [429, 1], "end": [432, 62], "kind": "commanddeclaration"}, {"full_name": "limsup_eq_tendsto_sum_indicator_nat_atTop", "code": "theorem limsup_eq_tendsto_sum_indicator_nat_atTop (s : \u2115 \u2192 Set \u03b1) :\n    limsup s atTop = { \u03c9 | Tendsto\n      (fun n \u21a6 \u2211 k in Finset.range n, (s (k + 1)).indicator (1 : \u03b1 \u2192 \u2115) \u03c9) atTop atTop }", "start": [441, 1], "end": [496, 70], "kind": "commanddeclaration"}, {"full_name": "limsup_eq_tendsto_sum_indicator_atTop", "code": "theorem limsup_eq_tendsto_sum_indicator_atTop (R : Type*) [StrictOrderedSemiring R] [Archimedean R]\n    (s : \u2115 \u2192 Set \u03b1) : limsup s atTop = { \u03c9 | Tendsto\n      (fun n \u21a6 \u2211 k in Finset.range n, (s (k + 1)).indicator (1 : \u03b1 \u2192 R) \u03c9) atTop atTop }", "start": [499, 1], "end": [509, 75], "kind": "commanddeclaration"}, {"full_name": "limsup_const_add", "code": "lemma limsup_const_add (F : Filter \u03b9) [NeBot F] [Add R] [ContinuousAdd R]\n    [CovariantClass R R (fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.limsup (fun i \u21a6 c + f i) F = c + Filter.limsup f F :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 c + x)\n    (fun _ _ h \u21a6 add_le_add_left h c) (continuous_add_left c).continuousAt bdd_above bdd_below).symm", "start": [520, 1], "end": [526, 101], "kind": "mathlibtacticlemma"}, {"full_name": "limsup_add_const", "code": "lemma limsup_add_const (F : Filter \u03b9) [NeBot F] [Add R] [ContinuousAdd R]\n    [CovariantClass R R (Function.swap fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.limsup (fun i \u21a6 f i + c) F = Filter.limsup f F + c :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 x + c)\n    (fun _ _ h \u21a6 add_le_add_right h c)\n    (continuous_add_right c).continuousAt bdd_above bdd_below).symm", "start": [528, 1], "end": [535, 68], "kind": "mathlibtacticlemma"}, {"full_name": "liminf_const_add", "code": "lemma liminf_const_add (F : Filter \u03b9) [NeBot F] [Add R] [ContinuousAdd R]\n    [CovariantClass R R (fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y]  (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.liminf (fun i \u21a6 c + f i) F = c + Filter.liminf f F :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 c + x)\n    (fun _ _ h \u21a6 add_le_add_left h c) (continuous_add_left c).continuousAt bdd_above bdd_below).symm", "start": [537, 1], "end": [543, 101], "kind": "mathlibtacticlemma"}, {"full_name": "liminf_add_const", "code": "lemma liminf_add_const (F : Filter \u03b9) [NeBot F] [Add R] [ContinuousAdd R]\n    [CovariantClass R R (Function.swap fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.liminf (fun i \u21a6 f i + c) F = Filter.liminf f F + c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 x + c)\n    (fun _ _ h \u21a6 add_le_add_right h c)\n    (continuous_add_right c).continuousAt bdd_above bdd_below).symm", "start": [545, 1], "end": [552, 68], "kind": "mathlibtacticlemma"}, {"full_name": "limsup_const_sub", "code": "lemma limsup_const_sub (F : Filter \u03b9) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] [CovariantClass R R (fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.limsup (fun i \u21a6 c - f i) F = c - Filter.liminf f F :=\n  (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 c - x)\n    (fun _ _ h \u21a6 tsub_le_tsub_left h c)\n    (continuous_sub_left c).continuousAt bdd_above bdd_below).symm", "start": [554, 1], "end": [561, 67], "kind": "mathlibtacticlemma"}, {"full_name": "limsup_sub_const", "code": "lemma limsup_sub_const (F : Filter \u03b9) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.limsup (fun i \u21a6 f i - c) F = Filter.limsup f F - c :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 x - c)\n    (fun _ _ h \u21a6 tsub_le_tsub_right h c)\n    (continuous_sub_right c).continuousAt bdd_above bdd_below).symm", "start": [563, 1], "end": [570, 68], "kind": "mathlibtacticlemma"}, {"full_name": "liminf_const_sub", "code": "lemma liminf_const_sub (F : Filter \u03b9) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] [CovariantClass R R (fun x y \u21a6 x + y) fun x y \u21a6 x \u2264 y] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.liminf (fun i \u21a6 c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 c - x)\n    (fun _ _ h \u21a6 tsub_le_tsub_left h c)\n    (continuous_sub_left c).continuousAt bdd_above bdd_below).symm", "start": [572, 1], "end": [579, 67], "kind": "mathlibtacticlemma"}, {"full_name": "liminf_sub_const", "code": "lemma liminf_sub_const (F : Filter \u03b9) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] (f : \u03b9 \u2192 R) (c : R)\n    (bdd_above : F.IsBoundedUnder (\u00b7 \u2264 \u00b7) f) (bdd_below : F.IsBoundedUnder (\u00b7 \u2265 \u00b7) f) :\n    Filter.liminf (fun i \u21a6 f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) \u21a6 x - c)\n    (fun _ _ h \u21a6 tsub_le_tsub_right h c)\n    (continuous_sub_right c).continuousAt bdd_above bdd_below).symm", "start": [581, 1], "end": [588, 68], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean", "imports": ["Mathlib/Topology/Homeomorph.lean", "Mathlib/Topology/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StrictMonoOn.continuousWithinAt_right_of_exists_between", "code": "theorem StrictMonoOn.continuousWithinAt_right_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioc (f a) b) :\n    ContinuousWithinAt f (Ici a) a", "start": [36, 1], "end": [55, 57], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_right_of_monotoneOn_of_exists_between", "code": "theorem continuousWithinAt_right_of_monotoneOn_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioo (f a) b) :\n    ContinuousWithinAt f (Ici a) a", "start": [58, 1], "end": [76, 46], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_right_of_monotoneOn_of_closure_image_mem_nhdsWithin", "code": "theorem continuousWithinAt_right_of_monotoneOn_of_closure_image_mem_nhdsWithin [DenselyOrdered \u03b2]\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd[\u2265] f a) : ContinuousWithinAt f (Ici a) a", "start": [79, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_right_of_monotoneOn_of_image_mem_nhdsWithin", "code": "theorem continuousWithinAt_right_of_monotoneOn_of_image_mem_nhdsWithin [DenselyOrdered \u03b2]\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a)\n    (hfs : f '' s \u2208 \ud835\udcdd[\u2265] f a) : ContinuousWithinAt f (Ici a) a", "start": [93, 1], "end": [100, 39], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_right_of_closure_image_mem_nhdsWithin", "code": "theorem StrictMonoOn.continuousWithinAt_right_of_closure_image_mem_nhdsWithin [DenselyOrdered \u03b2]\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd[\u2265] f a) : ContinuousWithinAt f (Ici a) a", "start": [103, 1], "end": [110, 57], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_right_of_image_mem_nhdsWithin", "code": "theorem StrictMonoOn.continuousWithinAt_right_of_image_mem_nhdsWithin [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : f '' s \u2208 \ud835\udcdd[\u2265] f a) :\n    ContinuousWithinAt f (Ici a) a", "start": [113, 1], "end": [120, 41], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_right_of_surjOn", "code": "theorem StrictMonoOn.continuousWithinAt_right_of_surjOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : SurjOn f s (Ioi (f a))) :\n    ContinuousWithinAt f (Ici a) a", "start": [123, 1], "end": [130, 36], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_left_of_exists_between", "code": "theorem StrictMonoOn.continuousWithinAt_left_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a) (hfs : \u2200 b < f a, \u2203 c \u2208 s, f c \u2208 Ico b (f a)) :\n    ContinuousWithinAt f (Iic a) a", "start": [133, 1], "end": [145, 23], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_left_of_monotoneOn_of_exists_between", "code": "theorem continuousWithinAt_left_of_monotoneOn_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (hf : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a) (hfs : \u2200 b < f a, \u2203 c \u2208 s, f c \u2208 Ioo b (f a)) :\n    ContinuousWithinAt f (Iic a) a", "start": [148, 1], "end": [160, 23], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_left_of_monotoneOn_of_closure_image_mem_nhdsWithin", "code": "theorem continuousWithinAt_left_of_monotoneOn_of_closure_image_mem_nhdsWithin [DenselyOrdered \u03b2]\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (hf : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd[\u2264] f a) : ContinuousWithinAt f (Iic a) a", "start": [163, 1], "end": [170, 21], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_left_of_monotoneOn_of_image_mem_nhdsWithin", "code": "theorem continuousWithinAt_left_of_monotoneOn_of_image_mem_nhdsWithin [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a) (hfs : f '' s \u2208 \ud835\udcdd[\u2264] f a) :\n    ContinuousWithinAt f (Iic a) a", "start": [173, 1], "end": [180, 41], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_left_of_closure_image_mem_nhdsWithin", "code": "theorem StrictMonoOn.continuousWithinAt_left_of_closure_image_mem_nhdsWithin [DenselyOrdered \u03b2]\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd[\u2264] f a) : ContinuousWithinAt f (Iic a) a", "start": [183, 1], "end": [189, 78], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_left_of_image_mem_nhdsWithin", "code": "theorem StrictMonoOn.continuousWithinAt_left_of_image_mem_nhdsWithin [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a) (hfs : f '' s \u2208 \ud835\udcdd[\u2264] f a) :\n    ContinuousWithinAt f (Iic a) a", "start": [192, 1], "end": [198, 70], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousWithinAt_left_of_surjOn", "code": "theorem StrictMonoOn.continuousWithinAt_left_of_surjOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2264] a) (hfs : SurjOn f s (Iio (f a))) :\n    ContinuousWithinAt f (Iic a) a", "start": [201, 1], "end": [206, 56], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousAt_of_exists_between", "code": "theorem StrictMonoOn.continuousAt_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd a) (hfs_l : \u2200 b < f a, \u2203 c \u2208 s, f c \u2208 Ico b (f a))\n    (hfs_r : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioc (f a) b) : ContinuousAt f a", "start": [209, 1], "end": [217, 95], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousAt_of_closure_image_mem_nhds", "code": "theorem StrictMonoOn.continuousAt_of_closure_image_mem_nhds [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd (f a)) : ContinuousAt f a", "start": [220, 1], "end": [230, 74], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.continuousAt_of_image_mem_nhds", "code": "theorem StrictMonoOn.continuousAt_of_image_mem_nhds [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {a : \u03b1} (h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd a) (hfs : f '' s \u2208 \ud835\udcdd (f a)) :\n    ContinuousAt f a", "start": [233, 1], "end": [238, 88], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_monotoneOn_of_exists_between", "code": "theorem continuousAt_of_monotoneOn_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n    (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd a) (hfs_l : \u2200 b < f a, \u2203 c \u2208 s, f c \u2208 Ioo b (f a))\n    (hfs_r : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioo (f a) b) : ContinuousAt f a", "start": [241, 1], "end": [251, 47], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_monotoneOn_of_closure_image_mem_nhds", "code": "theorem continuousAt_of_monotoneOn_of_closure_image_mem_nhds [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd a)\n    (hfs : closure (f '' s) \u2208 \ud835\udcdd (f a)) : ContinuousAt f a", "start": [254, 1], "end": [264, 74], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_monotoneOn_of_image_mem_nhds", "code": "theorem continuousAt_of_monotoneOn_of_image_mem_nhds [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {a : \u03b1} (h_mono : MonotoneOn f s) (hs : s \u2208 \ud835\udcdd a) (hfs : f '' s \u2208 \ud835\udcdd (f a)) : ContinuousAt f a", "start": [267, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "Monotone.continuous_of_denseRange", "code": "theorem Monotone.continuous_of_denseRange [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2} (h_mono : Monotone f)\n    (h_dense : DenseRange f) : Continuous f", "start": [275, 1], "end": [281, 62], "kind": "commanddeclaration"}, {"full_name": "Monotone.continuous_of_surjective", "code": "theorem Monotone.continuous_of_surjective [DenselyOrdered \u03b2] {f : \u03b1 \u2192 \u03b2} (h_mono : Monotone f)\n    (h_surj : Function.Surjective f) : Continuous f", "start": [284, 1], "end": [287, 52], "kind": "commanddeclaration"}, {"full_name": "OrderIso.continuous", "code": "protected theorem continuous (e : \u03b1 \u2243o \u03b2) : Continuous e", "start": [305, 1], "end": [312, 21], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toHomeomorph", "code": "def toHomeomorph (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2243\u209c \u03b2 :=\n  { e with\n    continuous_toFun := e.continuous\n    continuous_invFun := e.symm.continuous }", "start": [315, 1], "end": [319, 45], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph (e : \u03b1 \u2243o \u03b2) : \u21d1e.toHomeomorph = e", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_toHomeomorph_symm", "code": "@[simp]\ntheorem coe_toHomeomorph_symm (e : \u03b1 \u2243o \u03b2) : \u21d1e.toHomeomorph.symm = e.symm", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/NNReal.lean", "imports": ["Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "Mathlib/Topology/Instances/Real.lean", "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "continuous_real_toNNReal", "code": "theorem _root_.continuous_real_toNNReal : Continuous Real.toNNReal", "start": [83, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.continuous_coe", "code": "theorem continuous_coe : Continuous ((\u2191) : \u211d\u22650 \u2192 \u211d)", "start": [87, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coeNNRealReal", "code": "@[simps (config := { fullyApplied := false })]\ndef _root_.ContinuousMap.coeNNRealReal : C(\u211d\u22650, \u211d) :=\n  \u27e8(\u2191), continuous_coe\u27e9", "start": [91, 1], "end": [94, 24], "kind": "commanddeclaration"}, {"full_name": "NNReal.ContinuousMap.canLift", "code": "instance ContinuousMap.canLift {X : Type*} [TopologicalSpace X] :\n    CanLift C(X, \u211d) C(X, \u211d\u22650) ContinuousMap.coeNNRealReal.comp fun f => \u2200 x, 0 \u2264 f x where\n  prf f hf := \u27e8\u27e8fun x => \u27e8f x, hf x\u27e9, f.2.subtype_mk _\u27e9, FunLike.ext' rfl\u27e9", "start": [98, 1], "end": [100, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_coe", "code": "@[simp, norm_cast]\ntheorem tendsto_coe {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650} {x : \u211d\u22650} :\n    Tendsto (fun a => (m a : \u211d)) f (\ud835\udcdd (x : \u211d)) \u2194 Tendsto m f (\ud835\udcdd x)", "start": [103, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_coe'", "code": "theorem tendsto_coe' {f : Filter \u03b1} [NeBot f] {m : \u03b1 \u2192 \u211d\u22650} {x : \u211d} :\n    Tendsto (fun a => m a : \u03b1 \u2192 \u211d) f (\ud835\udcdd x) \u2194 \u2203 hx : 0 \u2264 x, Tendsto m f (\ud835\udcdd \u27e8x, hx\u27e9)", "start": [109, 1], "end": [111, 99], "kind": "commanddeclaration"}, {"full_name": "NNReal.map_coe_atTop", "code": "@[simp] theorem map_coe_atTop : map toReal atTop = atTop", "start": [114, 1], "end": [114, 80], "kind": "commanddeclaration"}, {"full_name": "NNReal.comap_coe_atTop", "code": "theorem comap_coe_atTop : comap toReal atTop = atTop", "start": [117, 1], "end": [117, 78], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_coe_atTop", "code": "@[simp, norm_cast]\ntheorem tendsto_coe_atTop {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650} :\n    Tendsto (fun a => (m a : \u211d)) f atTop \u2194 Tendsto m f atTop", "start": [120, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "tendsto_real_toNNReal", "code": "theorem _root_.tendsto_real_toNNReal {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d} {x : \u211d} (h : Tendsto m f (\ud835\udcdd x)) :\n    Tendsto (fun a => Real.toNNReal (m a)) f (\ud835\udcdd (Real.toNNReal x))", "start": [126, 1], "end": [128, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_real_toNNReal_atTop", "code": "theorem _root_.tendsto_real_toNNReal_atTop : Tendsto Real.toNNReal atTop atTop", "start": [131, 1], "end": [133, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.nhds_zero", "code": "theorem nhds_zero : \ud835\udcdd (0 : \u211d\u22650) = \u2a05 (a : \u211d\u22650) (_ : a \u2260 0), \ud835\udcdf (Iio a)", "start": [136, 1], "end": [137, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.nhds_zero_basis", "code": "theorem nhds_zero_basis : (\ud835\udcdd (0 : \u211d\u22650)).HasBasis (fun a : \u211d\u22650 => 0 < a) fun a => Iio a", "start": [140, 1], "end": [141, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_coe", "code": "@[norm_cast]\ntheorem hasSum_coe {f : \u03b1 \u2192 \u211d\u22650} {r : \u211d\u22650} : HasSum (fun a => (f a : \u211d)) (r : \u211d) \u2194 HasSum f r", "start": [153, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "HasSum.toNNReal", "code": "protected theorem _root_.HasSum.toNNReal {f : \u03b1 \u2192 \u211d} {y : \u211d} (hf\u2080 : \u2200 n, 0 \u2264 f n)\n    (hy : HasSum f y) : HasSum (fun x => Real.toNNReal (f x)) y.toNNReal", "start": [158, 1], "end": [162, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_real_toNNReal_of_nonneg", "code": "theorem hasSum_real_toNNReal_of_nonneg {f : \u03b1 \u2192 \u211d} (hf_nonneg : \u2200 n, 0 \u2264 f n) (hf : Summable f) :\n    HasSum (fun n => Real.toNNReal (f n)) (Real.toNNReal (\u2211' n, f n))", "start": [164, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_coe", "code": "@[norm_cast]\ntheorem summable_coe {f : \u03b1 \u2192 \u211d\u22650} : (Summable fun a => (f a : \u211d)) \u2194 Summable f", "start": [169, 1], "end": [173, 46], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_mk", "code": "theorem summable_mk {f : \u03b1 \u2192 \u211d} (hf : \u2200 n, 0 \u2264 f n) :\n    (@Summable \u211d\u22650 _ _ _ fun n => \u27e8f n, hf n\u27e9) \u2194 Summable f", "start": [176, 1], "end": [178, 55], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_tsum", "code": "@[norm_cast]\ntheorem coe_tsum {f : \u03b1 \u2192 \u211d\u22650} : \u2191(\u2211' a, f a) = \u2211' a, (f a : \u211d)", "start": [183, 1], "end": [186, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_tsum_of_nonneg", "code": "theorem coe_tsum_of_nonneg {f : \u03b1 \u2192 \u211d} (hf\u2081 : \u2200 n, 0 \u2264 f n) :\n    (\u27e8\u2211' n, f n, tsum_nonneg hf\u2081\u27e9 : \u211d\u22650) = (\u2211' n, \u27e8f n, hf\u2081 n\u27e9 : \u211d\u22650)", "start": [189, 1], "end": [191, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_mul_left", "code": "nonrec theorem tsum_mul_left (a : \u211d\u22650) (f : \u03b1 \u2192 \u211d\u22650) : \u2211' x, a * f x = a * \u2211' x, f x", "start": [194, 1], "end": [195, 70], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_mul_right", "code": "nonrec theorem tsum_mul_right (f : \u03b1 \u2192 \u211d\u22650) (a : \u211d\u22650) : \u2211' x, f x * a = (\u2211' x, f x) * a", "start": [198, 1], "end": [199, 71], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_comp_injective", "code": "theorem summable_comp_injective {\u03b2 : Type*} {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) {i : \u03b2 \u2192 \u03b1}\n    (hi : Function.Injective i) : Summable (f \u2218 i)", "start": [202, 1], "end": [205, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_nat_add", "code": "theorem summable_nat_add (f : \u2115 \u2192 \u211d\u22650) (hf : Summable f) (k : \u2115) : Summable fun i => f (i + k)", "start": [208, 1], "end": [209, 53], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_nat_add_iff", "code": "nonrec theorem summable_nat_add_iff {f : \u2115 \u2192 \u211d\u22650} (k : \u2115) :\n    (Summable fun i => f (i + k)) \u2194 Summable f", "start": [212, 1], "end": [215, 61], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_nat_add_iff", "code": "nonrec theorem hasSum_nat_add_iff {f : \u2115 \u2192 \u211d\u22650} (k : \u2115) {a : \u211d\u22650} :\n    HasSum (fun n => f (n + k)) a \u2194 HasSum f (a + \u2211 i in range k, f i)", "start": [218, 1], "end": [220, 82], "kind": "commanddeclaration"}, {"full_name": "NNReal.sum_add_tsum_nat_add", "code": "theorem sum_add_tsum_nat_add {f : \u2115 \u2192 \u211d\u22650} (k : \u2115) (hf : Summable f) :\n    \u2211' i, f i = (\u2211 i in range k, f i) + \u2211' i, f (i + k)", "start": [223, 1], "end": [225, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.iInf_real_pos_eq_iInf_nnreal_pos", "code": "theorem iInf_real_pos_eq_iInf_nnreal_pos [CompleteLattice \u03b1] {f : \u211d \u2192 \u03b1} :\n    \u2a05 (n : \u211d) (_ : 0 < n), f n = \u2a05 (n : \u211d\u22650) (_ : 0 < n), f n", "start": [228, 1], "end": [230, 99], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_cofinite_zero_of_summable", "code": "theorem tendsto_cofinite_zero_of_summable {\u03b1} {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) :\n    Tendsto f cofinite (\ud835\udcdd 0)", "start": [235, 1], "end": [238, 33], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_atTop_zero_of_summable", "code": "theorem tendsto_atTop_zero_of_summable {f : \u2115 \u2192 \u211d\u22650} (hf : Summable f) : Tendsto f atTop (\ud835\udcdd 0)", "start": [241, 1], "end": [243, 45], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_tsum_compl_atTop_zero", "code": "nonrec theorem tendsto_tsum_compl_atTop_zero {\u03b1 : Type*} (f : \u03b1 \u2192 \u211d\u22650) :\n    Tendsto (fun s : Finset \u03b1 => \u2211' b : { x // x \u2209 s }, f b) atTop (\ud835\udcdd 0)", "start": [246, 1], "end": [251, 61], "kind": "commanddeclaration"}, {"full_name": "NNReal.powOrderIso", "code": "def powOrderIso (n : \u2115) (hn : n \u2260 0) : \u211d\u22650 \u2243o \u211d\u22650 :=\n  StrictMono.orderIsoOfSurjective (fun x \u21a6 x ^ n) (fun x y h =>\n      strictMonoOn_pow hn.bot_lt (zero_le x) (zero_le y) h) <|\n    (continuous_id.pow _).surjective (tendsto_pow_atTop hn) <| by\n      simpa [OrderBot.atBot_eq, pos_iff_ne_zero]", "start": [254, 1], "end": [259, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "imports": ["Mathlib/Topology/Instances/Real.lean", "Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "cauchySeq_of_edist_le_of_summable", "code": "theorem cauchySeq_of_edist_le_of_summable [PseudoEMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) (hd : Summable d) : CauchySeq f", "start": [22, 1], "end": [40, 22], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_dist_le_of_summable", "code": "theorem cauchySeq_of_dist_le_of_summable (d : \u2115 \u2192 \u211d) (hf : \u2200 n, dist (f n) (f n.succ) \u2264 d n)\n    (hd : Summable d) : CauchySeq f", "start": [45, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_summable_dist", "code": "theorem cauchySeq_of_summable_dist (h : Summable fun n => dist (f n) (f n.succ)) : CauchySeq f", "start": [68, 1], "end": [69, 57], "kind": "commanddeclaration"}, {"full_name": "dist_le_tsum_of_dist_le_of_tendsto", "code": "theorem dist_le_tsum_of_dist_le_of_tendsto (d : \u2115 \u2192 \u211d) (hf : \u2200 n, dist (f n) (f n.succ) \u2264 d n)\n    (hd : Summable d) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    dist (f n) a \u2264 \u2211' m, d (n + m)", "start": [72, 1], "end": [79, 50], "kind": "commanddeclaration"}, {"full_name": "dist_le_tsum_of_dist_le_of_tendsto\u2080", "code": "theorem dist_le_tsum_of_dist_le_of_tendsto\u2080 (d : \u2115 \u2192 \u211d) (hf : \u2200 n, dist (f n) (f n.succ) \u2264 d n)\n    (hd : Summable d) (ha : Tendsto f atTop (\ud835\udcdd a)) : dist (f 0) a \u2264 tsum d", "start": [82, 1], "end": [84, 78], "kind": "commanddeclaration"}, {"full_name": "dist_le_tsum_dist_of_tendsto", "code": "theorem dist_le_tsum_dist_of_tendsto (h : Summable fun n => dist (f n) (f n.succ))\n    (ha : Tendsto f atTop (\ud835\udcdd a)) (n) : dist (f n) a \u2264 \u2211' m, dist (f (n + m)) (f (n + m).succ)", "start": [87, 1], "end": [90, 97], "kind": "commanddeclaration"}, {"full_name": "dist_le_tsum_dist_of_tendsto\u2080", "code": "theorem dist_le_tsum_dist_of_tendsto\u2080 (h : Summable fun n => dist (f n) (f n.succ))\n    (ha : Tendsto f atTop (\ud835\udcdd a)) : dist (f 0) a \u2264 \u2211' n, dist (f n) (f n.succ)", "start": [93, 1], "end": [95, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/T5.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Data/Set/Intervals/OrdConnectedComponent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.ordConnectedComponent_mem_nhds", "code": "@[simp]\ntheorem ordConnectedComponent_mem_nhds : ordConnectedComponent s a \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a", "start": [26, 1], "end": [30, 65], "kind": "commanddeclaration"}, {"full_name": "Set.compl_section_ordSeparatingSet_mem_nhdsWithin_Ici", "code": "theorem compl_section_ordSeparatingSet_mem_nhdsWithin_Ici (hd : Disjoint s (closure t))\n    (ha : a \u2208 s) : (ordConnectedSection (ordSeparatingSet s t))\u1d9c \u2208 \ud835\udcdd[\u2265] a", "start": [33, 1], "end": [63, 52], "kind": "commanddeclaration"}, {"full_name": "Set.compl_section_ordSeparatingSet_mem_nhdsWithin_Iic", "code": "theorem compl_section_ordSeparatingSet_mem_nhdsWithin_Iic (hd : Disjoint s (closure t))\n    (ha : a \u2208 s) : (ordConnectedSection <| ordSeparatingSet s t)\u1d9c \u2208 \ud835\udcdd[\u2264] a", "start": [66, 1], "end": [71, 62], "kind": "commanddeclaration"}, {"full_name": "Set.compl_section_ordSeparatingSet_mem_nhds", "code": "theorem compl_section_ordSeparatingSet_mem_nhds (hd : Disjoint s (closure t)) (ha : a \u2208 s) :\n    (ordConnectedSection <| ordSeparatingSet s t)\u1d9c \u2208 \ud835\udcdd a", "start": [74, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "Set.ordT5Nhd_mem_nhdsSet", "code": "theorem ordT5Nhd_mem_nhdsSet (hd : Disjoint s (closure t)) : ordT5Nhd s t \u2208 \ud835\udcdd\u02e2 s", "start": [82, 1], "end": [87, 52], "kind": "commanddeclaration"}, {"full_name": "OrderTopology.t5Space", "code": "instance (priority := 100) OrderTopology.t5Space : T5Space X :=\n  \u27e8fun s t h\u2081 h\u2082 => Filter.disjoint_iff.2\n    \u27e8ordT5Nhd s t, ordT5Nhd_mem_nhdsSet h\u2082, ordT5Nhd t s, ordT5Nhd_mem_nhdsSet h\u2081.symm,\n      disjoint_ordT5Nhd\u27e9\u27e9", "start": [94, 1], "end": [98, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Adjoin/Basic.lean", "imports": ["Mathlib/Algebra/Algebra/Subalgebra/Tower.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Operations.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "Mathlib/LinearAlgebra/Prod.lean"], "premises": [{"full_name": "Algebra.subset_adjoin", "code": "@[aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_adjoin : s \u2286 adjoin R s", "start": [43, 1], "end": [45, 22], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_le", "code": "theorem adjoin_le {S : Subalgebra R A} (H : s \u2286 S) : adjoin R s \u2264 S", "start": [48, 1], "end": [49, 20], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_sInf", "code": "theorem adjoin_eq_sInf : adjoin R s = sInf { p : Subalgebra R A | s \u2286 p }", "start": [52, 1], "end": [53, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_le_iff", "code": "theorem adjoin_le_iff {S : Subalgebra R A} : adjoin R s \u2264 S \u2194 s \u2286 S", "start": [56, 1], "end": [57, 17], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_mono", "code": "theorem adjoin_mono (H : s \u2286 t) : adjoin R s \u2264 adjoin R t", "start": [60, 1], "end": [61, 26], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_of_le", "code": "theorem adjoin_eq_of_le (S : Subalgebra R A) (h\u2081 : s \u2286 S) (h\u2082 : S \u2264 adjoin R s) : adjoin R s = S", "start": [64, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq", "code": "theorem adjoin_eq (S : Subalgebra R A) : adjoin R \u2191S = S", "start": [68, 1], "end": [69, 54], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_iUnion", "code": "theorem adjoin_iUnion {\u03b1 : Type*} (s : \u03b1 \u2192 Set A) :\n    adjoin R (Set.iUnion s) = \u2a06 i : \u03b1, adjoin R (s i)", "start": [72, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_attach_biUnion", "code": "theorem adjoin_attach_biUnion [DecidableEq A] {\u03b1 : Type*} {s : Finset \u03b1} (f : s \u2192 Finset A) :\n    adjoin R (s.attach.biUnion f : Set A) = \u2a06 x, adjoin R (f x)", "start": [77, 1], "end": [78, 91], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_induction", "code": "@[elab_as_elim]\ntheorem adjoin_induction {p : A \u2192 Prop} {x : A} (h : x \u2208 adjoin R s) (Hs : \u2200 x \u2208 s, p x)\n    (Halg : \u2200 r, p (algebraMap R A r)) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [81, 1], "end": [90, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_induction\u2082", "code": "@[elab_as_elim]\ntheorem adjoin_induction\u2082 {p : A \u2192 A \u2192 Prop} {a b : A} (ha : a \u2208 adjoin R s) (hb : b \u2208 adjoin R s)\n    (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (Halg : \u2200 r\u2081 r\u2082, p (algebraMap R A r\u2081) (algebraMap R A r\u2082))\n    (Halg_left : \u2200 (r), \u2200 x \u2208 s, p (algebraMap R A r) x)\n    (Halg_right : \u2200 (r), \u2200 x \u2208 s, p x (algebraMap R A r))\n    (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)) : p a b", "start": [93, 1], "end": [111, 52], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_induction'", "code": "@[elab_as_elim]\ntheorem adjoin_induction' {p : adjoin R s \u2192 Prop} (Hs : \u2200 (x) (h : x \u2208 s), p \u27e8x, subset_adjoin h\u27e9)\n    (Halg : \u2200 r, p (algebraMap R _ r)) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (x : adjoin R s) : p x", "start": [114, 1], "end": [128, 86], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_adjoin_coe_preimage", "code": "@[simp]\ntheorem adjoin_adjoin_coe_preimage {s : Set A} : adjoin R (((\u2191) : adjoin R s \u2192 A) \u207b\u00b9' s) = \u22a4", "start": [131, 1], "end": [141, 31], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_union", "code": "theorem adjoin_union (s t : Set A) : adjoin R (s \u222a t) = adjoin R s \u2294 adjoin R t", "start": [144, 1], "end": [145, 73], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_empty", "code": "@[simp]\ntheorem adjoin_empty : adjoin R (\u2205 : Set A) = \u22a5", "start": [150, 1], "end": [154, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_univ", "code": "@[simp]\ntheorem adjoin_univ : adjoin R (Set.univ : Set A) = \u22a4", "start": [157, 1], "end": [159, 57], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_span", "code": "theorem adjoin_eq_span : Subalgebra.toSubmodule (adjoin R s) = span R (Submonoid.closure s)", "start": [164, 1], "end": [193, 45], "kind": "commanddeclaration"}, {"full_name": "Algebra.span_le_adjoin", "code": "theorem span_le_adjoin (s : Set A) : span R s \u2264 Subalgebra.toSubmodule (adjoin R s)", "start": [196, 1], "end": [197, 28], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_toSubmodule_le", "code": "theorem adjoin_toSubmodule_le {s : Set A} {t : Submodule R A} :\n    Subalgebra.toSubmodule (adjoin R s) \u2264 t \u2194 \u2191(Submonoid.closure s) \u2286 (t : Set A)", "start": [200, 1], "end": [202, 31], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_span_of_subset", "code": "theorem adjoin_eq_span_of_subset {s : Set A} (hs : \u2191(Submonoid.closure s) \u2286 (span R s : Set A)) :\n    Subalgebra.toSubmodule (adjoin R s) = span R s", "start": [205, 1], "end": [207, 70], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_span", "code": "@[simp]\ntheorem adjoin_span {s : Set A} : adjoin R (Submodule.span R s : Set A) = adjoin R s", "start": [210, 1], "end": [212, 83], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_image", "code": "theorem adjoin_image (f : A \u2192\u2090[R] B) (s : Set A) : adjoin R (f '' s) = (adjoin R s).map f", "start": [215, 1], "end": [221, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_insert_adjoin", "code": "@[simp]\ntheorem adjoin_insert_adjoin (x : A) : adjoin R (insert x \u2191(adjoin R s)) = adjoin R (insert x s)", "start": [224, 1], "end": [230, 75], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_prod_le", "code": "theorem adjoin_prod_le (s : Set A) (t : Set B) :\n    adjoin R (s \u00d7\u02e2 t) \u2264 (adjoin R s).prod (adjoin R t)", "start": [233, 1], "end": [235, 57], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_adjoin_of_map_mul", "code": "theorem mem_adjoin_of_map_mul {s} {x : A} {f : A \u2192\u2097[R] B} (hf : \u2200 a\u2081 a\u2082, f (a\u2081 * a\u2082) = f a\u2081 * f a\u2082)\n    (h : x \u2208 adjoin R s) : f x \u2208 adjoin R (f '' (s \u222a {1}))", "start": [238, 1], "end": [249, 23], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_inl_union_inr_eq_prod", "code": "theorem adjoin_inl_union_inr_eq_prod (s) (t) :\n    adjoin R (LinearMap.inl R A B '' (s \u222a {1}) \u222a LinearMap.inr R A B '' (t \u222a {1})) =\n      (adjoin R s).prod (adjoin R t)", "start": [252, 1], "end": [270, 43], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoinCommSemiringOfComm", "code": "def adjoinCommSemiringOfComm {s : Set A} (hcomm : \u2200 a \u2208 s, \u2200 b \u2208 s, a * b = b * a) :\n    CommSemiring (adjoin R s) :=\n  { (adjoin R s).toSemiring with\n    mul_comm := fun x y => by\n      ext\n      simp only [Subalgebra.coe_mul]\n      exact adjoin_induction\u2082 x.prop y.prop hcomm (fun _ _ => by rw [commutes])\n        (fun r x _hx => commutes r x) (fun r x _hx => (commutes r x).symm)\n        (fun _ _ _ h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n        (fun _ _ _ h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n        (fun x\u2081 x\u2082 y\u2081 h\u2081 h\u2082 => by rw [mul_assoc, h\u2082, \u2190 mul_assoc y\u2081, \u2190 h\u2081, mul_assoc x\u2081])\n        fun x\u2081 x\u2082 y\u2081 h\u2081 h\u2082 => by rw [mul_assoc x\u2082, \u2190 h\u2082, \u2190 mul_assoc x\u2082, \u2190 h\u2081, \u2190 mul_assoc] }", "start": [273, 1], "end": [286, 94], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_singleton_one", "code": "theorem adjoin_singleton_one : adjoin R ({1} : Set A) = \u22a5", "start": [289, 1], "end": [290, 92], "kind": "commanddeclaration"}, {"full_name": "Algebra.self_mem_adjoin_singleton", "code": "theorem self_mem_adjoin_singleton (x : A) : x \u2208 adjoin R ({x} : Set A)", "start": [293, 1], "end": [294, 56], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_algebraMap", "code": "theorem adjoin_algebraMap (s : Set S) :\n    adjoin R (algebraMap S A '' s) = (adjoin R s).map (IsScalarTower.toAlgHom R S A)", "start": [298, 1], "end": [300, 50], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_algebraMap_image_union_eq_adjoin_adjoin", "code": "theorem adjoin_algebraMap_image_union_eq_adjoin_adjoin (s : Set S) (t : Set A) :\n    adjoin R (algebraMap S A '' s \u222a t) = (adjoin (adjoin R s) t).restrictScalars R", "start": [303, 1], "end": [313, 71], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_adjoin_of_tower", "code": "theorem adjoin_adjoin_of_tower (s : Set A) : adjoin S (adjoin R s : Set A) = adjoin S s", "start": [315, 1], "end": [323, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_top", "code": "@[simp]\ntheorem adjoin_top :\n    adjoin (\u22a4 : Subalgebra R S) t = (adjoin S t).restrictScalars (\u22a4 : Subalgebra R S)", "start": [326, 1], "end": [338, 78], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_union_eq_adjoin_adjoin", "code": "theorem adjoin_union_eq_adjoin_adjoin :\n    adjoin R (s \u222a t) = (adjoin (adjoin R s) t).restrictScalars R", "start": [350, 1], "end": [352, 67], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_union_coe_submodule", "code": "theorem adjoin_union_coe_submodule :\n    Subalgebra.toSubmodule (adjoin R (s \u222a t)) =\n      Subalgebra.toSubmodule (adjoin R s) * Subalgebra.toSubmodule (adjoin R t)", "start": [355, 1], "end": [359, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin", "code": "theorem pow_smul_mem_of_smul_subset_of_mem_adjoin [CommSemiring B] [Algebra R B] [Algebra A B]\n    [IsScalarTower R A B] (r : A) (s : Set B) (B' : Subalgebra R B) (hs : r \u2022 s \u2286 B') {x : B}\n    (hx : x \u2208 adjoin R s) (hr : algebraMap A B r \u2208 B') : \u2203 n\u2080 : \u2115, \u2200 n \u2265 n\u2080, r ^ n \u2022 x \u2208 B'", "start": [364, 1], "end": [386, 41], "kind": "commanddeclaration"}, {"full_name": "Algebra.pow_smul_mem_adjoin_smul", "code": "theorem pow_smul_mem_adjoin_smul (r : R) (s : Set A) {x : A} (hx : x \u2208 adjoin R s) :\n    \u2203 n\u2080 : \u2115, \u2200 n \u2265 n\u2080, r ^ n \u2022 x \u2208 adjoin R (r \u2022 s)", "start": [389, 1], "end": [391, 99], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_adjoin_iff", "code": "theorem mem_adjoin_iff {s : Set A} {x : A} :\n    x \u2208 adjoin R s \u2194 x \u2208 Subring.closure (Set.range (algebraMap R A) \u222a s)", "start": [402, 1], "end": [411, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_ring_closure", "code": "theorem adjoin_eq_ring_closure (s : Set A) :\n    (adjoin R s).toSubring = Subring.closure (Set.range (algebraMap R A) \u222a s)", "start": [414, 1], "end": [416, 39], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoinCommRingOfComm", "code": "def adjoinCommRingOfComm {s : Set A} (hcomm : \u2200 a \u2208 s, \u2200 b \u2208 s, a * b = b * a) :\n    CommRing (adjoin R s) :=\n  { (adjoin R s).toRing, adjoinCommSemiringOfComm R hcomm with }", "start": [421, 1], "end": [425, 65], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_adjoin", "code": "theorem map_adjoin (\u03c6 : A \u2192\u2090[R] B) (s : Set A) : (adjoin R s).map \u03c6 = adjoin R (\u03c6 '' s)", "start": [438, 1], "end": [439, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.adjoin_le_equalizer", "code": "theorem adjoin_le_equalizer (\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B) {s : Set A} (h : s.EqOn \u03c6\u2081 \u03c6\u2082) :\n    adjoin R s \u2264 \u03c6\u2081.equalizer \u03c6\u2082", "start": [442, 1], "end": [444, 14], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ext_of_adjoin_eq_top", "code": "theorem ext_of_adjoin_eq_top {s : Set A} (h : adjoin R s = \u22a4) \u2983\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B\u2984\n    (hs : s.EqOn \u03c6\u2081 \u03c6\u2082) : \u03c6\u2081 = \u03c6\u2082", "start": [447, 1], "end": [449, 65], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_nat", "code": "theorem Algebra.adjoin_nat {R : Type*} [Semiring R] (s : Set R) :\n    adjoin \u2115 s = subalgebraOfSubsemiring (Subsemiring.closure s)", "start": [456, 1], "end": [459, 98], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_int", "code": "theorem Algebra.adjoin_int {R : Type*} [Ring R] (s : Set R) :\n    adjoin \u2124 s = subalgebraOfSubring (Subring.closure s)", "start": [461, 1], "end": [464, 86], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closureEquivAdjoinNat", "code": "def Subsemiring.closureEquivAdjoinNat {R : Type*} [Semiring R] (s : Set R) :\n    Subsemiring.closure s \u2243\u2090[\u2115] Algebra.adjoin \u2115 s :=\n  Subalgebra.equivOfEq (subalgebraOfSubsemiring <| Subsemiring.closure s) _ (adjoin_nat s).symm", "start": [467, 1], "end": [471, 96], "kind": "commanddeclaration"}, {"full_name": "Subring.closureEquivAdjoinInt", "code": "def Subring.closureEquivAdjoinInt {R : Type*} [Ring R] (s : Set R) :\n    Subring.closure s \u2243\u2090[\u2124] Algebra.adjoin \u2124 s :=\n  Subalgebra.equivOfEq (subalgebraOfSubring <| Subring.closure s) _ (adjoin_int s).symm", "start": [473, 1], "end": [477, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Basic.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/LinearAlgebra/Projection.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Pi.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean", "Mathlib/Topology/Algebra/MulAction.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "ContinuousSMul.of_nhds_zero", "code": "theorem ContinuousSMul.of_nhds_zero [TopologicalRing R] [TopologicalAddGroup M]\n    (hmul : Tendsto (fun p : R \u00d7 M => p.1 \u2022 p.2) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulleft : \u2200 m : M, Tendsto (fun a : R => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmulright : \u2200 a : R, Tendsto (fun m : M => a \u2022 m) (\ud835\udcdd 0) (\ud835\udcdd 0)) : ContinuousSMul R M where", "start": [42, 1], "end": [48, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_top_of_nonempty_interior'", "code": "theorem Submodule.eq_top_of_nonempty_interior' [NeBot (\ud835\udcdd[{ x : R | IsUnit x }] 0)]\n    (s : Submodule R M) (hs : (interior (s : Set M)).Nonempty) : s = \u22a4", "start": [58, 1], "end": [72, 75], "kind": "commanddeclaration"}, {"full_name": "Module.punctured_nhds_neBot", "code": "theorem Module.punctured_nhds_neBot [Nontrivial M] [NeBot (\ud835\udcdd[\u2260] (0 : R))] [NoZeroSMulDivisors R M]\n    (x : M) : NeBot (\ud835\udcdd[\u2260] x)", "start": [77, 1], "end": [94, 24], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_induced", "code": "theorem continuousSMul_induced : @ContinuousSMul R M\u2081 _ u (t.induced f)", "start": [105, 1], "end": [109, 73], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.span", "code": "lemma TopologicalSpace.IsSeparable.span {R M : Type*} [AddCommMonoid M] [Semiring R] [Module R M]\n    [TopologicalSpace M] [TopologicalSpace R] [SeparableSpace R]\n    [ContinuousAdd M] [ContinuousSMul R M] {s : Set M} (hs : IsSeparable s) :\n    IsSeparable (Submodule.span R s : Set M) := by\n  rw [span_eq_iUnion_nat]\n  apply isSeparable_iUnion (fun n \u21a6 ?_)\n  apply IsSeparable.image\n  \u00b7 have : IsSeparable {f : Fin n \u2192 R \u00d7 M | \u2200 (i : Fin n), f i \u2208 Set.univ \u00d7\u02e2 s} := by\n      apply isSeparable_pi (fun i \u21a6 (isSeparable_of_separableSpace Set.univ).prod hs)\n    convert this\n    simp\n  \u00b7 apply continuous_finset_sum _ (fun i _ \u21a6 ?_)\n    exact (continuous_fst.comp (continuous_apply i)).smul (continuous_snd.comp (continuous_apply i))", "start": [114, 1], "end": [127, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Submodule.continuousSMul", "code": "instance continuousSMul [TopologicalSpace \u03b1] [Semiring \u03b1] [AddCommMonoid \u03b2] [Module \u03b1 \u03b2]\n    [ContinuousSMul \u03b1 \u03b2] (S : Submodule \u03b1 \u03b2) : ContinuousSMul \u03b1 S :=\n  continuousSMul_induced S.subtype", "start": [133, 1], "end": [135, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalAddGroup", "code": "instance topologicalAddGroup [Ring \u03b1] [AddCommGroup \u03b2] [Module \u03b1 \u03b2] [TopologicalAddGroup \u03b2]\n    (S : Submodule \u03b1 \u03b2) : TopologicalAddGroup S :=\n  inferInstanceAs (TopologicalAddGroup S.toAddSubgroup)", "start": [138, 1], "end": [140, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapsTo_smul_closure", "code": "theorem Submodule.mapsTo_smul_closure (s : Submodule R M) (c : R) :\n    Set.MapsTo (c \u2022 \u00b7) (closure s : Set M) (closure s)", "start": [151, 1], "end": [154, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_closure_subset", "code": "theorem Submodule.smul_closure_subset (s : Submodule R M) (c : R) :\n    c \u2022 closure (s : Set M) \u2286 closure (s : Set M)", "start": [156, 1], "end": [158, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure", "code": "def Submodule.topologicalClosure (s : Submodule R M) : Submodule R M :=\n  { s.toAddSubmonoid.topologicalClosure with\n    smul_mem' := s.mapsTo_smul_closure }", "start": [162, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure_coe", "code": "@[simp]\ntheorem Submodule.topologicalClosure_coe (s : Submodule R M) :\n    (s.topologicalClosure : Set M) = closure (s : Set M)", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_topologicalClosure", "code": "theorem Submodule.le_topologicalClosure (s : Submodule R M) : s \u2264 s.topologicalClosure", "start": [175, 1], "end": [176, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.closure_subset_topologicalClosure_span", "code": "theorem Submodule.closure_subset_topologicalClosure_span (s : Set M) :\n    closure s \u2286 (span R s).topologicalClosure", "start": [179, 1], "end": [182, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.isClosed_topologicalClosure", "code": "theorem Submodule.isClosed_topologicalClosure (s : Submodule R M) :\n    IsClosed (s.topologicalClosure : Set M)", "start": [184, 1], "end": [185, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure_minimal", "code": "theorem Submodule.topologicalClosure_minimal (s : Submodule R M) {t : Submodule R M} (h : s \u2264 t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure \u2264 t", "start": [188, 1], "end": [190, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure_mono", "code": "theorem Submodule.topologicalClosure_mono {s : Submodule R M} {t : Submodule R M} (h : s \u2264 t) :\n    s.topologicalClosure \u2264 t.topologicalClosure", "start": [193, 1], "end": [195, 17], "kind": "commanddeclaration"}, {"full_name": "IsClosed.submodule_topologicalClosure_eq", "code": "theorem IsClosed.submodule_topologicalClosure_eq {s : Submodule R M} (hs : IsClosed (s : Set M)) :\n    s.topologicalClosure = s", "start": [198, 1], "end": [201, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.dense_iff_topologicalClosure_eq_top", "code": "theorem Submodule.dense_iff_topologicalClosure_eq_top {s : Submodule R M} :\n    Dense (s : Set M) \u2194 s.topologicalClosure = \u22a4", "start": [204, 1], "end": [208, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure.completeSpace", "code": "instance Submodule.topologicalClosure.completeSpace {M' : Type*} [AddCommMonoid M'] [Module R M']\n    [UniformSpace M'] [ContinuousAdd M'] [ContinuousConstSMul R M'] [CompleteSpace M']\n    (U : Submodule R M') : CompleteSpace U.topologicalClosure :=\n  isClosed_closure.completeSpace_coe", "start": [211, 1], "end": [214, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.isClosed_or_dense_of_isCoatom", "code": "theorem Submodule.isClosed_or_dense_of_isCoatom (s : Submodule R M) (hs : IsCoatom s) :\n    IsClosed (s : Set M) \u2228 Dense (s : Set M)", "start": [217, 1], "end": [222, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.continuous_on_pi", "code": "theorem LinearMap.continuous_on_pi {\u03b9 : Type*} {R : Type*} {M : Type*} [Finite \u03b9] [Semiring R]\n    [TopologicalSpace R] [AddCommMonoid M] [Module R M] [TopologicalSpace M] [ContinuousAdd M]\n    [ContinuousSMul R M] (f : (\u03b9 \u2192 R) \u2192\u2097[R] M) : Continuous f", "start": [229, 1], "end": [241, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap", "code": "structure ContinuousLinearMap {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)\n    (M : Type*) [TopologicalSpace M] [AddCommMonoid M] (M\u2082 : Type*) [TopologicalSpace M\u2082]\n    [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082] extends M \u2192\u209b\u2097[\u03c3] M\u2082 where\n  cont : Continuous toFun := by continuity", "start": [246, 1], "end": [252, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousSemilinearMapClass", "code": "class ContinuousSemilinearMapClass (F : Type*) {R S : outParam (Type*)} [Semiring R] [Semiring S]\n    (\u03c3 : outParam <| R \u2192+* S) (M : outParam (Type*)) [TopologicalSpace M] [AddCommMonoid M]\n    (M\u2082 : outParam (Type*)) [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] extends SemilinearMapClass F \u03c3 M M\u2082, ContinuousMapClass F M M\u2082", "start": [266, 1], "end": [274, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMapClass", "code": "abbrev ContinuousLinearMapClass (F : Type*) (R : outParam (Type*)) [Semiring R]\n    (M : outParam (Type*)) [TopologicalSpace M] [AddCommMonoid M] (M\u2082 : outParam (Type*))\n    [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082] :=\n  ContinuousSemilinearMapClass F (RingHom.id R) M M\u2082", "start": [281, 1], "end": [287, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv", "code": "structure ContinuousLinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)\n    {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) [TopologicalSpace M]\n    [AddCommMonoid M] (M\u2082 : Type*) [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] extends M \u2243\u209b\u2097[\u03c3] M\u2082 where\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity", "start": [290, 1], "end": [299, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousSemilinearEquivClass", "code": "class ContinuousSemilinearEquivClass (F : Type*) {R : outParam (Type*)} {S : outParam (Type*)}\n    [Semiring R] [Semiring S] (\u03c3 : outParam <| R \u2192+* S) {\u03c3' : outParam <| S \u2192+* R}\n    [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : outParam (Type*)) [TopologicalSpace M]\n    [AddCommMonoid M] (M\u2082 : outParam (Type*)) [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M]\n    [Module S M\u2082] extends SemilinearEquivClass F \u03c3 M M\u2082 where\n  map_continuous : \u2200 f : F, Continuous f := by continuity\n  inv_continuous : \u2200 f : F, Continuous (inv f) := by continuity", "start": [314, 1], "end": [325, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquivClass", "code": "abbrev ContinuousLinearEquivClass (F : Type*) (R : outParam (Type*)) [Semiring R]\n    (M : outParam (Type*)) [TopologicalSpace M] [AddCommMonoid M] (M\u2082 : outParam (Type*))\n    [TopologicalSpace M\u2082] [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082] :=\n  ContinuousSemilinearEquivClass F (RingHom.id R) M M\u2082", "start": [332, 1], "end": [338, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousSemilinearEquivClass.continuousSemilinearMapClass", "code": "instance (priority := 100) continuousSemilinearMapClass\n    [s : ContinuousSemilinearEquivClass F \u03c3 M M\u2082] : ContinuousSemilinearMapClass F \u03c3 M M\u2082 :=\n  { s with\n    coe := ((\u2191) : F \u2192 M \u2192 M\u2082)\n    coe_injective' := @FunLike.coe_injective F _ _ _ }", "start": [350, 1], "end": [354, 55], "kind": "commanddeclaration"}, {"full_name": "linearMapOfMemClosureRangeCoe", "code": "@[simps (config := .asFn)]\ndef linearMapOfMemClosureRangeCoe (f : M\u2081 \u2192 M\u2082)\n    (hf : f \u2208 closure (Set.range ((\u2191) : (M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082) \u2192 M\u2081 \u2192 M\u2082))) : M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082 :=\n  { @addMonoidHomOfMemClosureRangeCoe M\u2081 M\u2082 _ _ _ _ _ (M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082)\n      (SemilinearMapClass.addMonoidHomClass _) f hf with\n    map_smul' := (isClosed_setOf_map_smul M\u2081 M\u2082 \u03c3).closure_subset_iff.2\n      (Set.range_subset_iff.2 LinearMap.map_smul\u209b\u2097) hf }", "start": [366, 1], "end": [374, 57], "kind": "commanddeclaration"}, {"full_name": "linearMapOfTendsto", "code": "@[simps! (config := .asFn)]\ndef linearMapOfTendsto (f : M\u2081 \u2192 M\u2082) (g : \u03b1 \u2192 M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (\ud835\udcdd f)) : M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082 :=\n  linearMapOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| eventually_of_forall fun _ => Set.mem_range_self _", "start": [378, 1], "end": [383, 83], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isClosed_range_coe", "code": "theorem LinearMap.isClosed_range_coe : IsClosed (Set.range ((\u2191) : (M\u2081 \u2192\u209b\u2097[\u03c3] M\u2082) \u2192 M\u2081 \u2192 M\u2082))", "start": [389, 1], "end": [390, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.LinearMap.coe", "code": "instance LinearMap.coe : Coe (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) := \u27e8toLinearMap\u27e9", "start": [411, 1], "end": [412, 80], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_injective", "code": "theorem coe_injective : Function.Injective ((\u2191) : (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) \u2192 M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [417, 1], "end": [421, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuousSemilinearMapClass", "code": "instance continuousSemilinearMapClass :\n    ContinuousSemilinearMapClass (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) \u03c3\u2081\u2082 M\u2081 M\u2082 where\n  coe f := f.toLinearMap\n  coe_injective' _ _ h := coe_injective (FunLike.coe_injective h)\n  map_add f := map_add f.toLinearMap\n  map_continuous f := f.2\n  map_smul\u209b\u2097 f := f.toLinearMap.map_smul'", "start": [424, 1], "end": [430, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_mk", "code": "theorem coe_mk (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h) : (mk f h : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = f", "start": [434, 1], "end": [439, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h) : (mk f h : M\u2081 \u2192 M\u2082) = f", "start": [442, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuous", "code": "@[continuity]\nprotected theorem continuous (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : Continuous f", "start": [447, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniformContinuous", "code": "protected theorem uniformContinuous {E\u2081 E\u2082 : Type*} [UniformSpace E\u2081] [UniformSpace E\u2082]\n    [AddCommGroup E\u2081] [AddCommGroup E\u2082] [Module R\u2081 E\u2081] [Module R\u2082 E\u2082] [UniformAddGroup E\u2081]\n    [UniformAddGroup E\u2082] (f : E\u2081 \u2192SL[\u03c3\u2081\u2082] E\u2082) : UniformContinuous f", "start": [452, 1], "end": [455, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} : (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = g \u2194 f = g", "start": [458, 1], "end": [460, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeFn_injective", "code": "theorem coeFn_injective : @Function.Injective (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (M\u2081 \u2192 M\u2082) (\u2191)", "start": [463, 1], "end": [464, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.Simps.apply", "code": "def Simps.apply (h : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192 M\u2082 :=\n  h", "start": [467, 1], "end": [470, 4], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.Simps.coe", "code": "def Simps.coe (h : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082 :=\n  h", "start": [473, 1], "end": [475, 4], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ext", "code": "@[ext]\ntheorem ext {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (h : \u2200 x, f x = g x) : f = g", "start": [480, 1], "end": [482, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ext_iff", "code": "theorem ext_iff {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} : f = g \u2194 \u2200 x, f x = g x", "start": [485, 1], "end": [486, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.copy", "code": "protected def copy (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f' : M\u2081 \u2192 M\u2082) (h : f' = \u21d1f) : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082 where\n  toLinearMap := f.toLinearMap.copy f' h\n  cont := show Continuous f' from h.symm \u25b8 f.continuous", "start": [489, 1], "end": [493, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f' : M\u2081 \u2192 M\u2082) (h : f' = \u21d1f) : \u21d1(f.copy f' h) = f'", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.copy_eq", "code": "theorem copy_eq (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f' : M\u2081 \u2192 M\u2082) (h : f' = \u21d1f) : f.copy f' h = f", "start": [501, 1], "end": [502, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_zero", "code": "protected theorem map_zero (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : f (0 : M\u2081) = 0", "start": [506, 1], "end": [507, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_add", "code": "protected theorem map_add (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (x y : M\u2081) : f (x + y) = f x + f y", "start": [510, 1], "end": [511, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_smul\u209b\u2097", "code": "protected theorem map_smul\u209b\u2097 (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (c : R\u2081) (x : M\u2081) : f (c \u2022 x) = \u03c3\u2081\u2082 c \u2022 f x", "start": [515, 1], "end": [516, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_smul", "code": "protected theorem map_smul [Module R\u2081 M\u2082] (f : M\u2081 \u2192L[R\u2081] M\u2082) (c : R\u2081) (x : M\u2081) :\n    f (c \u2022 x) = c \u2022 f x", "start": [520, 1], "end": [521, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_smul_of_tower", "code": "@[simp]\ntheorem map_smul_of_tower {R S : Type*} [Semiring S] [SMul R M\u2081] [Module S M\u2081] [SMul R M\u2082]\n    [Module S M\u2082] [LinearMap.CompatibleSMul M\u2081 M\u2082 R S] (f : M\u2081 \u2192L[S] M\u2082) (c : R) (x : M\u2081) :\n    f (c \u2022 x) = c \u2022 f x", "start": [524, 1], "end": [528, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_sum", "code": "@[deprecated _root_.map_sum]\nprotected theorem map_sum {\u03b9 : Type*} (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (s : Finset \u03b9) (g : \u03b9 \u2192 M\u2081) :\n    f (\u2211 i in s, g i) = \u2211 i in s, f (g i)", "start": [531, 1], "end": [534, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = f", "start": [537, 1], "end": [539, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ext_ring", "code": "@[ext]\ntheorem ext_ring [TopologicalSpace R\u2081] {f g : R\u2081 \u2192L[R\u2081] M\u2081} (h : f 1 = g 1) : f = g", "start": [542, 1], "end": [544, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ext_ring_iff", "code": "theorem ext_ring_iff [TopologicalSpace R\u2081] {f g : R\u2081 \u2192L[R\u2081] M\u2081} : f = g \u2194 f 1 = g 1", "start": [547, 1], "end": [548, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.eqOn_closure_span", "code": "theorem eqOn_closure_span [T2Space M\u2082] {s : Set M\u2081} {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure (Submodule.span R\u2081 s : Set M\u2081))", "start": [551, 1], "end": [555, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ext_on", "code": "theorem ext_on [T2Space M\u2082] {s : Set M\u2081} (hs : Dense (Submodule.span R\u2081 s : Set M\u2081))\n    {f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (h : Set.EqOn f g s) : f = g", "start": [558, 1], "end": [562, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalClosure_map", "code": "theorem _root_.Submodule.topologicalClosure_map [RingHomSurjective \u03c3\u2081\u2082] [TopologicalSpace R\u2081]\n    [TopologicalSpace R\u2082] [ContinuousSMul R\u2081 M\u2081] [ContinuousAdd M\u2081] [ContinuousSMul R\u2082 M\u2082]\n    [ContinuousAdd M\u2082] (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (s : Submodule R\u2081 M\u2081) :\n    s.topologicalClosure.map (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) \u2264\n      (s.map (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)).topologicalClosure", "start": [565, 1], "end": [572, 50], "kind": "commanddeclaration"}, {"full_name": "DenseRange.topologicalClosure_map_submodule", "code": "theorem _root_.DenseRange.topologicalClosure_map_submodule [RingHomSurjective \u03c3\u2081\u2082]\n    [TopologicalSpace R\u2081] [TopologicalSpace R\u2082] [ContinuousSMul R\u2081 M\u2081] [ContinuousAdd M\u2081]\n    [ContinuousSMul R\u2082 M\u2082] [ContinuousAdd M\u2082] {f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (hf' : DenseRange f)\n    {s : Submodule R\u2081 M\u2081} (hs : s.topologicalClosure = \u22a4) :\n    (s.map (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)).topologicalClosure = \u22a4", "start": [575, 1], "end": [585, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mulAction", "code": "instance mulAction : MulAction S\u2082 (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) where\n  smul c f := \u27e8c \u2022 (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082), (f.2.const_smul _ : Continuous fun x => c \u2022 f x)\u27e9\n  one_smul _f := ext fun _x => one_smul _ _\n  mul_smul _a _b _f := ext fun _x => mul_smul _ _ _", "start": [596, 1], "end": [599, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smul_apply", "code": "theorem smul_apply (c : S\u2082) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : (c \u2022 f) x = c \u2022 f x", "start": [602, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (c : S\u2082) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (c \u2022 f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = c \u2022 (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [606, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_smul'", "code": "@[simp, norm_cast]\ntheorem coe_smul' (c : S\u2082) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (c \u2022 f : M\u2081 \u2192 M\u2082) = c \u2022 (f : M\u2081 \u2192 M\u2082)", "start": [612, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isScalarTower", "code": "instance isScalarTower [SMul S\u2082 T\u2082] [IsScalarTower S\u2082 T\u2082 M\u2082] :\n    IsScalarTower S\u2082 T\u2082 (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8fun a b f => ext fun x => smul_assoc a b (f x)\u27e9", "start": [618, 1], "end": [620, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulCommClass", "code": "instance smulCommClass [SMulCommClass S\u2082 T\u2082 M\u2082] : SMulCommClass S\u2082 T\u2082 (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8fun a b f => ext fun x => smul_comm a b (f x)\u27e9", "start": [623, 1], "end": [624, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.zero", "code": "instance zero : Zero (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8\u27e80, continuous_zero\u27e9\u27e9", "start": [629, 1], "end": [631, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inhabited", "code": "instance inhabited : Inhabited (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e80\u27e9", "start": [634, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.default_def", "code": "@[simp]\ntheorem default_def : (default : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = 0", "start": [638, 1], "end": [640, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : M\u2081) : (0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) x = 0", "start": [643, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = 0", "start": [648, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_zero'", "code": "@[norm_cast]\ntheorem coe_zero' : \u21d1(0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = 0", "start": [656, 1], "end": [658, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniqueOfLeft", "code": "instance uniqueOfLeft [Subsingleton M\u2081] : Unique (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  coe_injective.unique", "start": [661, 1], "end": [662, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniqueOfRight", "code": "instance uniqueOfRight [Subsingleton M\u2082] : Unique (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  coe_injective.unique", "start": [665, 1], "end": [666, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.exists_ne_zero", "code": "theorem exists_ne_zero {f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082} (hf : f \u2260 0) : \u2203 x, f x \u2260 0", "start": [669, 1], "end": [671, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.id", "code": "def id : M\u2081 \u2192L[R\u2081] M\u2081 :=\n  \u27e8LinearMap.id, continuous_id\u27e9", "start": [678, 1], "end": [680, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.one", "code": "instance one : One (M\u2081 \u2192L[R\u2081] M\u2081) :=\n  \u27e8id R\u2081 M\u2081\u27e9", "start": [685, 1], "end": [686, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.one_def", "code": "theorem one_def : (1 : M\u2081 \u2192L[R\u2081] M\u2081) = id R\u2081 M\u2081", "start": [689, 1], "end": [690, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.id_apply", "code": "theorem id_apply (x : M\u2081) : id R\u2081 M\u2081 x = x", "start": [693, 1], "end": [694, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_id", "code": "@[simp, norm_cast]\ntheorem coe_id : (id R\u2081 M\u2081 : M\u2081 \u2192\u2097[R\u2081] M\u2081) = LinearMap.id", "start": [697, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_id'", "code": "@[simp, norm_cast]\ntheorem coe_id' : \u21d1(id R\u2081 M\u2081) = _root_.id", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_eq_id", "code": "@[simp, norm_cast]\ntheorem coe_eq_id {f : M\u2081 \u2192L[R\u2081] M\u2081} : (f : M\u2081 \u2192\u2097[R\u2081] M\u2081) = LinearMap.id \u2194 f = id _ _", "start": [707, 1], "end": [709, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.one_apply", "code": "@[simp]\ntheorem one_apply (x : M\u2081) : (1 : M\u2081 \u2192L[R\u2081] M\u2081) x = x", "start": [712, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.add", "code": "instance add : Add (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8fun f g => \u27e8f + g, f.2.add g.2\u27e9\u27e9", "start": [721, 1], "end": [722, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.add_apply", "code": "@[simp]\ntheorem add_apply (f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : (f + g) x = f x + g x", "start": [725, 1], "end": [727, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : (\u2191(f + g) : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = f + g", "start": [730, 1], "end": [732, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_add'", "code": "@[norm_cast]\ntheorem coe_add' (f g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(f + g) = f + g", "start": [735, 1], "end": [737, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) where\n  zero := (0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082)\n  add := (\u00b7 + \u00b7)\n  zero_add := by\n    intros\n    ext\n    apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm]\n  add_zero := by\n    intros\n    ext\n    apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm]\n  add_comm := by\n    intros\n    ext\n    apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm]\n  add_assoc := by\n    intros\n    ext\n    apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm]\n  nsmul := (\u00b7 \u2022 \u00b7)\n  nsmul_zero f := by\n    ext\n    simp\n  nsmul_succ n f := by\n    ext\n    simp [Nat.add_comm n 1, add_smul]", "start": [740, 1], "end": [765, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_sum", "code": "@[simp, norm_cast]\ntheorem coe_sum {\u03b9 : Type*} (t : Finset \u03b9) (f : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    \u2191(\u2211 d in t, f d) = (\u2211 d in t, f d : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [768, 1], "end": [771, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_sum'", "code": "@[simp, norm_cast]\ntheorem coe_sum' {\u03b9 : Type*} (t : Finset \u03b9) (f : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    \u21d1(\u2211 d in t, f d) = \u2211 d in t, \u21d1(f d)", "start": [774, 1], "end": [776, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sum_apply", "code": "theorem sum_apply {\u03b9 : Type*} (t : Finset \u03b9) (f : \u03b9 \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (b : M\u2081) :\n    (\u2211 d in t, f d) b = \u2211 d in t, f d b", "start": [779, 1], "end": [780, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp", "code": "def comp (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192SL[\u03c3\u2081\u2083] M\u2083 :=\n  \u27e8(g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083).comp (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082), g.2.comp f.2\u27e9", "start": [787, 1], "end": [789, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_comp", "code": "@[simp, norm_cast]\ntheorem coe_comp (h : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (h.comp f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = (h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083).comp (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [797, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_comp'", "code": "@[simp, norm_cast]\ntheorem coe_comp' (h : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(h.comp f) = h \u2218 f", "start": [803, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_apply", "code": "theorem comp_apply (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : (g.comp f) x = g (f x)", "start": [808, 1], "end": [809, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : f.comp (id R\u2081 M\u2081) = f", "start": [812, 1], "end": [814, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : (id R\u2082 M\u2082).comp f = f", "start": [817, 1], "end": [819, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_zero", "code": "@[simp]\ntheorem comp_zero (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) : g.comp (0 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = 0", "start": [822, 1], "end": [825, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.zero_comp", "code": "@[simp]\ntheorem zero_comp (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : (0 : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083).comp f = 0", "start": [828, 1], "end": [831, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_add", "code": "@[simp]\ntheorem comp_add [ContinuousAdd M\u2082] [ContinuousAdd M\u2083] (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083)\n    (f\u2081 f\u2082 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : g.comp (f\u2081 + f\u2082) = g.comp f\u2081 + g.comp f\u2082", "start": [834, 1], "end": [838, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.add_comp", "code": "@[simp]\ntheorem add_comp [ContinuousAdd M\u2083] (g\u2081 g\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (g\u2081 + g\u2082).comp f = g\u2081.comp f + g\u2082.comp f", "start": [841, 1], "end": [845, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_assoc", "code": "theorem comp_assoc {R\u2084 : Type*} [Semiring R\u2084] [Module R\u2084 M\u2084] {\u03c3\u2081\u2084 : R\u2081 \u2192+* R\u2084} {\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084}\n    {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084} [RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084] [RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084]\n    [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084] (h : M\u2083 \u2192SL[\u03c3\u2083\u2084] M\u2084) (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [848, 1], "end": [852, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.instMul", "code": "instance instMul : Mul (M\u2081 \u2192L[R\u2081] M\u2081) :=\n  \u27e8comp\u27e9", "start": [855, 1], "end": [856, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mul_def", "code": "theorem mul_def (f g : M\u2081 \u2192L[R\u2081] M\u2081) : f * g = f.comp g", "start": [859, 1], "end": [860, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : M\u2081 \u2192L[R\u2081] M\u2081) : \u21d1(f * g) = f \u2218 g", "start": [863, 1], "end": [865, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mul_apply", "code": "theorem mul_apply (f g : M\u2081 \u2192L[R\u2081] M\u2081) (x : M\u2081) : (f * g) x = f (g x)", "start": [868, 1], "end": [869, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.monoidWithZero", "code": "instance monoidWithZero : MonoidWithZero (M\u2081 \u2192L[R\u2081] M\u2081) where\n  mul := (\u00b7 * \u00b7)\n  one := 1\n  zero := 0\n  mul_zero f := ext fun _ => map_zero f\n  zero_mul _ := ext fun _ => rfl\n  mul_one _ := ext fun _ => rfl\n  one_mul _ := ext fun _ => rfl\n  mul_assoc _ _ _ := ext fun _ => rfl", "start": [872, 1], "end": [880, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_pow", "code": "theorem coe_pow (f : M\u2081 \u2192L[R\u2081] M\u2081) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [883, 1], "end": [884, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.semiring", "code": "instance semiring [ContinuousAdd M\u2081] : Semiring (M\u2081 \u2192L[R\u2081] M\u2081) :=\n  { ContinuousLinearMap.monoidWithZero,\n    ContinuousLinearMap.addCommMonoid with\n    left_distrib := fun f g h => ext fun x => map_add f (g x) (h x)\n    right_distrib := fun _ _ _ => ext fun _ => LinearMap.add_apply _ _ _ }", "start": [886, 1], "end": [890, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toLinearMapRingHom", "code": "@[simps]\ndef toLinearMapRingHom [ContinuousAdd M\u2081] : (M\u2081 \u2192L[R\u2081] M\u2081) \u2192+* M\u2081 \u2192\u2097[R\u2081] M\u2081 where\n  toFun := toLinearMap\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [893, 1], "end": [900, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.applyModule", "code": "instance applyModule : Module (M\u2081 \u2192L[R\u2081] M\u2081) M\u2081 :=\n  Module.compHom _ toLinearMapRingHom", "start": [908, 1], "end": [912, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smul_def", "code": "@[simp]\nprotected theorem smul_def (f : M\u2081 \u2192L[R\u2081] M\u2081) (a : M\u2081) : f \u2022 a = f a", "start": [915, 1], "end": [917, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.applyFaithfulSMul", "code": "instance applyFaithfulSMul : FaithfulSMul (M\u2081 \u2192L[R\u2081] M\u2081) M\u2081 :=\n  \u27e8fun {_ _} => ContinuousLinearMap.ext\u27e9", "start": [920, 1], "end": [922, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.applySMulCommClass", "code": "instance applySMulCommClass : SMulCommClass R\u2081 (M\u2081 \u2192L[R\u2081] M\u2081) M\u2081 where\n  smul_comm r e m := (e.map_smul r m).symm", "start": [925, 1], "end": [926, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.applySMulCommClass'", "code": "instance applySMulCommClass' : SMulCommClass (M\u2081 \u2192L[R\u2081] M\u2081) R\u2081 M\u2081 where\n  smul_comm := ContinuousLinearMap.map_smul", "start": [929, 1], "end": [930, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.continuousConstSMul", "code": "instance continuousConstSMul : ContinuousConstSMul (M\u2081 \u2192L[R\u2081] M\u2081) M\u2081 :=\n  \u27e8ContinuousLinearMap.continuous\u27e9", "start": [933, 1], "end": [934, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod", "code": "protected def prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082) (f\u2082 : M\u2081 \u2192L[R\u2081] M\u2083) :\n    M\u2081 \u2192L[R\u2081] M\u2082 \u00d7 M\u2083 :=\n  \u27e8(f\u2081 : M\u2081 \u2192\u2097[R\u2081] M\u2082).prod f\u2082, f\u2081.2.prod_mk f\u2082.2\u27e9", "start": [939, 1], "end": [942, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_prod", "code": "@[simp, norm_cast]\ntheorem coe_prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082) (f\u2082 : M\u2081 \u2192L[R\u2081] M\u2083) :\n    (f\u2081.prod f\u2082 : M\u2081 \u2192\u2097[R\u2081] M\u2082 \u00d7 M\u2083) = LinearMap.prod f\u2081 f\u2082", "start": [945, 1], "end": [948, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod_apply", "code": "@[simp, norm_cast]\ntheorem prod_apply [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082) (f\u2082 : M\u2081 \u2192L[R\u2081] M\u2083) (x : M\u2081) :\n    f\u2081.prod f\u2082 x = (f\u2081 x, f\u2082 x)", "start": [951, 1], "end": [954, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inl", "code": "def inl [Module R\u2081 M\u2082] : M\u2081 \u2192L[R\u2081] M\u2081 \u00d7 M\u2082 :=\n  (id R\u2081 M\u2081).prod 0", "start": [961, 1], "end": [963, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inr", "code": "def inr [Module R\u2081 M\u2082] : M\u2082 \u2192L[R\u2081] M\u2081 \u00d7 M\u2082 :=\n  (0 : M\u2082 \u2192L[R\u2081] M\u2081).prod (id R\u2081 M\u2082)", "start": [966, 1], "end": [968, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inl_apply", "code": "@[simp]\ntheorem inl_apply [Module R\u2081 M\u2082] (x : M\u2081) : inl R\u2081 M\u2081 M\u2082 x = (x, 0)", "start": [975, 1], "end": [977, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inr_apply", "code": "@[simp]\ntheorem inr_apply [Module R\u2081 M\u2082] (x : M\u2082) : inr R\u2081 M\u2081 M\u2082 x = (0, x)", "start": [980, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_inl", "code": "@[simp, norm_cast]\ntheorem coe_inl [Module R\u2081 M\u2082] : (inl R\u2081 M\u2081 M\u2082 : M\u2081 \u2192\u2097[R\u2081] M\u2081 \u00d7 M\u2082) = LinearMap.inl R\u2081 M\u2081 M\u2082", "start": [985, 1], "end": [987, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_inr", "code": "@[simp, norm_cast]\ntheorem coe_inr [Module R\u2081 M\u2082] : (inr R\u2081 M\u2081 M\u2082 : M\u2082 \u2192\u2097[R\u2081] M\u2081 \u00d7 M\u2082) = LinearMap.inr R\u2081 M\u2081 M\u2082", "start": [990, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isClosed_ker", "code": "theorem isClosed_ker [T1Space M\u2082] [ContinuousSemilinearMapClass F \u03c3\u2081\u2082 M\u2081 M\u2082] (f : F) :\n    IsClosed (ker f : Set M\u2081)", "start": [995, 1], "end": [997, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isComplete_ker", "code": "theorem isComplete_ker {M' : Type*} [UniformSpace M'] [CompleteSpace M'] [AddCommMonoid M']\n    [Module R\u2081 M'] [T1Space M\u2082] [ContinuousSemilinearMapClass F \u03c3\u2081\u2082 M' M\u2082] (f : F) :\n    IsComplete (ker f : Set M')", "start": [1000, 1], "end": [1003, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.completeSpace_ker", "code": "instance completeSpace_ker {M' : Type*} [UniformSpace M'] [CompleteSpace M']\n    [AddCommMonoid M'] [Module R\u2081 M'] [T1Space M\u2082] [ContinuousSemilinearMapClass F \u03c3\u2081\u2082 M' M\u2082]\n    (f : F) : CompleteSpace (ker f) :=\n  (isComplete_ker f).completeSpace_coe", "start": [1006, 1], "end": [1009, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.completeSpace_eqLocus", "code": "instance completeSpace_eqLocus {M' : Type*} [UniformSpace M'] [CompleteSpace M']\n    [AddCommMonoid M'] [Module R\u2081 M'] [T2Space M\u2082] [ContinuousSemilinearMapClass F \u03c3\u2081\u2082 M' M\u2082]\n    (f g : F) : CompleteSpace (LinearMap.eqLocus f g) :=\n  IsClosed.completeSpace_coe <| isClosed_eq (map_continuous f) (map_continuous g)", "start": [1012, 1], "end": [1015, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ker_prod", "code": "@[simp]\ntheorem ker_prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f : M\u2081 \u2192L[R\u2081] M\u2082) (g : M\u2081 \u2192L[R\u2081] M\u2083) :\n    ker (f.prod g) = ker f \u2293 ker g", "start": [1017, 1], "end": [1020, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.codRestrict", "code": "def codRestrict (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (p : Submodule R\u2082 M\u2082) (h : \u2200 x, f x \u2208 p) :\n    M\u2081 \u2192SL[\u03c3\u2081\u2082] p where\n  cont := f.continuous.subtype_mk _\n  toLinearMap := (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082).codRestrict p h", "start": [1023, 1], "end": [1027, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_codRestrict", "code": "@[norm_cast]\ntheorem coe_codRestrict (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (p : Submodule R\u2082 M\u2082) (h : \u2200 x, f x \u2208 p) :\n    (f.codRestrict p h : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] p) = (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082).codRestrict p h", "start": [1030, 1], "end": [1033, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_codRestrict_apply", "code": "@[simp]\ntheorem coe_codRestrict_apply (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (p : Submodule R\u2082 M\u2082) (h : \u2200 x, f x \u2208 p) (x) :\n    (f.codRestrict p h x : M\u2082) = f x", "start": [1036, 1], "end": [1039, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ker_codRestrict", "code": "@[simp]\ntheorem ker_codRestrict (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (p : Submodule R\u2082 M\u2082) (h : \u2200 x, f x \u2208 p) :\n    ker (f.codRestrict p h) = ker f", "start": [1042, 1], "end": [1045, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtypeL", "code": "def _root_.Submodule.subtypeL (p : Submodule R\u2081 M\u2081) : p \u2192L[R\u2081] M\u2081 where\n  cont := continuous_subtype_val\n  toLinearMap := p.subtype", "start": [1048, 1], "end": [1051, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_subtypeL", "code": "@[simp, norm_cast]\ntheorem _root_.Submodule.coe_subtypeL (p : Submodule R\u2081 M\u2081) :\n    (p.subtypeL : p \u2192\u2097[R\u2081] M\u2081) = p.subtype", "start": [1055, 1], "end": [1058, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_subtypeL'", "code": "@[simp]\ntheorem _root_.Submodule.coe_subtypeL' (p : Submodule R\u2081 M\u2081) : \u21d1p.subtypeL = p.subtype", "start": [1062, 1], "end": [1064, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtypeL_apply", "code": "@[simp] theorem _root_.Submodule.subtypeL_apply (p : Submodule R\u2081 M\u2081) (x : p) : p.subtypeL x = x", "start": [1068, 1], "end": [1070, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_subtypeL", "code": "@[simp]\ntheorem _root_.Submodule.range_subtypeL (p : Submodule R\u2081 M\u2081) : range p.subtypeL = p", "start": [1074, 1], "end": [1076, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_subtypeL", "code": "@[simp]\ntheorem _root_.Submodule.ker_subtypeL (p : Submodule R\u2081 M\u2081) : ker p.subtypeL = \u22a5", "start": [1080, 1], "end": [1082, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fst", "code": "def fst [Module R\u2081 M\u2082] : M\u2081 \u00d7 M\u2082 \u2192L[R\u2081] M\u2081 where\n  cont := continuous_fst\n  toLinearMap := LinearMap.fst R\u2081 M\u2081 M\u2082", "start": [1088, 1], "end": [1091, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.snd", "code": "def snd [Module R\u2081 M\u2082] : M\u2081 \u00d7 M\u2082 \u2192L[R\u2081] M\u2082 where\n  cont := continuous_snd\n  toLinearMap := LinearMap.snd R\u2081 M\u2081 M\u2082", "start": [1094, 1], "end": [1097, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_fst", "code": "@[simp, norm_cast]\ntheorem coe_fst [Module R\u2081 M\u2082] : \u2191(fst R\u2081 M\u2081 M\u2082) = LinearMap.fst R\u2081 M\u2081 M\u2082", "start": [1102, 1], "end": [1104, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_fst'", "code": "@[simp, norm_cast]\ntheorem coe_fst' [Module R\u2081 M\u2082] : \u21d1(fst R\u2081 M\u2081 M\u2082) = Prod.fst", "start": [1107, 1], "end": [1109, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_snd", "code": "@[simp, norm_cast]\ntheorem coe_snd [Module R\u2081 M\u2082] : \u2191(snd R\u2081 M\u2081 M\u2082) = LinearMap.snd R\u2081 M\u2081 M\u2082", "start": [1112, 1], "end": [1114, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_snd'", "code": "@[simp, norm_cast]\ntheorem coe_snd' [Module R\u2081 M\u2082] : \u21d1(snd R\u2081 M\u2081 M\u2082) = Prod.snd", "start": [1117, 1], "end": [1119, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fst_prod_snd", "code": "@[simp]\ntheorem fst_prod_snd [Module R\u2081 M\u2082] : (fst R\u2081 M\u2081 M\u2082).prod (snd R\u2081 M\u2081 M\u2082) = id R\u2081 (M\u2081 \u00d7 M\u2082)", "start": [1122, 1], "end": [1124, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.fst_comp_prod", "code": "@[simp]\ntheorem fst_comp_prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f : M\u2081 \u2192L[R\u2081] M\u2082) (g : M\u2081 \u2192L[R\u2081] M\u2083) :\n    (fst R\u2081 M\u2082 M\u2083).comp (f.prod g) = f", "start": [1127, 1], "end": [1130, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.snd_comp_prod", "code": "@[simp]\ntheorem snd_comp_prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] (f : M\u2081 \u2192L[R\u2081] M\u2082) (g : M\u2081 \u2192L[R\u2081] M\u2083) :\n    (snd R\u2081 M\u2082 M\u2083).comp (f.prod g) = g", "start": [1133, 1], "end": [1136, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prodMap", "code": "def prodMap [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082) (f\u2082 : M\u2083 \u2192L[R\u2081] M\u2084) :\n    M\u2081 \u00d7 M\u2083 \u2192L[R\u2081] M\u2082 \u00d7 M\u2084 :=\n  (f\u2081.comp (fst R\u2081 M\u2081 M\u2083)).prod (f\u2082.comp (snd R\u2081 M\u2081 M\u2083))", "start": [1139, 1], "end": [1142, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_prodMap", "code": "@[simp, norm_cast]\ntheorem coe_prodMap [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082)\n    (f\u2082 : M\u2083 \u2192L[R\u2081] M\u2084) : \u2191(f\u2081.prodMap f\u2082) = (f\u2081 : M\u2081 \u2192\u2097[R\u2081] M\u2082).prodMap (f\u2082 : M\u2083 \u2192\u2097[R\u2081] M\u2084)", "start": [1145, 1], "end": [1148, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_prodMap'", "code": "@[simp, norm_cast]\ntheorem coe_prodMap' [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2082)\n    (f\u2082 : M\u2083 \u2192L[R\u2081] M\u2084) : \u21d1(f\u2081.prodMap f\u2082) = Prod.map f\u2081 f\u2082", "start": [1151, 1], "end": [1154, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coprod", "code": "def coprod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [ContinuousAdd M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2083)\n    (f\u2082 : M\u2082 \u2192L[R\u2081] M\u2083) : M\u2081 \u00d7 M\u2082 \u2192L[R\u2081] M\u2083 :=\n  \u27e8LinearMap.coprod f\u2081 f\u2082, (f\u2081.cont.comp continuous_fst).add (f\u2082.cont.comp continuous_snd)\u27e9", "start": [1157, 1], "end": [1160, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_coprod", "code": "@[norm_cast, simp]\ntheorem coe_coprod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [ContinuousAdd M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2083)\n    (f\u2082 : M\u2082 \u2192L[R\u2081] M\u2083) : (f\u2081.coprod f\u2082 : M\u2081 \u00d7 M\u2082 \u2192\u2097[R\u2081] M\u2083) = LinearMap.coprod f\u2081 f\u2082", "start": [1163, 1], "end": [1166, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coprod_apply", "code": "@[simp]\ntheorem coprod_apply [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [ContinuousAdd M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2083)\n    (f\u2082 : M\u2082 \u2192L[R\u2081] M\u2083) (x) : f\u2081.coprod f\u2082 x = f\u2081 x.1 + f\u2082 x.2", "start": [1169, 1], "end": [1172, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.range_coprod", "code": "theorem range_coprod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [ContinuousAdd M\u2083] (f\u2081 : M\u2081 \u2192L[R\u2081] M\u2083)\n    (f\u2082 : M\u2082 \u2192L[R\u2081] M\u2083) : range (f\u2081.coprod f\u2082) = range f\u2081 \u2294 range f\u2082", "start": [1175, 1], "end": [1177, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_fst_add_comp_snd", "code": "theorem comp_fst_add_comp_snd [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [ContinuousAdd M\u2083] (f : M\u2081 \u2192L[R\u2081] M\u2083)\n    (g : M\u2082 \u2192L[R\u2081] M\u2083) :\n    f.comp (ContinuousLinearMap.fst R\u2081 M\u2081 M\u2082) + g.comp (ContinuousLinearMap.snd R\u2081 M\u2081 M\u2082) =\n      f.coprod g", "start": [1180, 1], "end": [1184, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coprod_inl_inr", "code": "theorem coprod_inl_inr [ContinuousAdd M\u2081] [ContinuousAdd M'\u2081] :\n    (ContinuousLinearMap.inl R\u2081 M\u2081 M'\u2081).coprod (ContinuousLinearMap.inr R\u2081 M\u2081 M'\u2081) =\n      ContinuousLinearMap.id R\u2081 (M\u2081 \u00d7 M'\u2081)", "start": [1187, 1], "end": [1190, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight", "code": "def smulRight (c : M\u2081 \u2192L[R] S) (f : M\u2082) : M\u2081 \u2192L[R] M\u2082 :=\n  { c.toLinearMap.smulRight f with cont := c.2.smul continuous_const }", "start": [1198, 1], "end": [1202, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight_apply", "code": "@[simp]\ntheorem smulRight_apply {c : M\u2081 \u2192L[R] S} {f : M\u2082} {x : M\u2081} :\n    (smulRight c f : M\u2081 \u2192 M\u2082) x = c x \u2022 f", "start": [1205, 1], "end": [1208, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight_one_one", "code": "@[simp]\ntheorem smulRight_one_one (c : R\u2081 \u2192L[R\u2081] M\u2082) : smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) (c 1) = c", "start": [1215, 1], "end": [1218, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight_one_eq_iff", "code": "@[simp]\ntheorem smulRight_one_eq_iff {f f' : M\u2082} :\n    smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) f = smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) f' \u2194 f = f'", "start": [1221, 1], "end": [1224, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight_comp", "code": "theorem smulRight_comp [ContinuousMul R\u2081] {x : M\u2082} {c : R\u2081} :\n    (smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) x).comp (smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) c) =\n      smulRight (1 : R\u2081 \u2192L[R\u2081] R\u2081) (c \u2022 x)", "start": [1227, 1], "end": [1231, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton", "code": "def toSpanSingleton (x : M\u2081) : R\u2081 \u2192L[R\u2081] M\u2081\n    where\n  toLinearMap := LinearMap.toSpanSingleton R\u2081 M\u2081 x\n  cont := continuous_id.smul continuous_const", "start": [1240, 1], "end": [1245, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton_apply", "code": "theorem toSpanSingleton_apply (x : M\u2081) (r : R\u2081) : toSpanSingleton R\u2081 x r = r \u2022 x", "start": [1248, 1], "end": [1249, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton_add", "code": "theorem toSpanSingleton_add [ContinuousAdd M\u2081] (x y : M\u2081) :\n    toSpanSingleton R\u2081 (x + y) = toSpanSingleton R\u2081 x + toSpanSingleton R\u2081 y", "start": [1252, 1], "end": [1254, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton_smul'", "code": "theorem toSpanSingleton_smul' {\u03b1} [Monoid \u03b1] [DistribMulAction \u03b1 M\u2081] [ContinuousConstSMul \u03b1 M\u2081]\n    [SMulCommClass R\u2081 \u03b1 M\u2081] (c : \u03b1) (x : M\u2081) :\n    toSpanSingleton R\u2081 (c \u2022 x) = c \u2022 toSpanSingleton R\u2081 x", "start": [1257, 1], "end": [1260, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton_smul", "code": "theorem toSpanSingleton_smul (R) {M\u2081} [CommSemiring R] [AddCommMonoid M\u2081] [Module R M\u2081]\n    [TopologicalSpace R] [TopologicalSpace M\u2081] [ContinuousSMul R M\u2081] (c : R) (x : M\u2081) :\n    toSpanSingleton R (c \u2022 x) = c \u2022 toSpanSingleton R x", "start": [1263, 1], "end": [1267, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.pi", "code": "def pi (f : \u2200 i, M \u2192L[R] \u03c6 i) : M \u2192L[R] \u2200 i, \u03c6 i :=\n  \u27e8LinearMap.pi fun i => f i, continuous_pi fun i => (f i).continuous\u27e9", "start": [1280, 1], "end": [1283, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_pi'", "code": "@[simp]\ntheorem coe_pi' (f : \u2200 i, M \u2192L[R] \u03c6 i) : \u21d1(pi f) = fun c i => f i c", "start": [1286, 1], "end": [1288, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_pi", "code": "@[simp]\ntheorem coe_pi (f : \u2200 i, M \u2192L[R] \u03c6 i) : (pi f : M \u2192\u2097[R] \u2200 i, \u03c6 i) = LinearMap.pi fun i => f i", "start": [1291, 1], "end": [1293, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.pi_apply", "code": "theorem pi_apply (f : \u2200 i, M \u2192L[R] \u03c6 i) (c : M) (i : \u03b9) : pi f c i = f i c", "start": [1296, 1], "end": [1297, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.pi_eq_zero", "code": "theorem pi_eq_zero (f : \u2200 i, M \u2192L[R] \u03c6 i) : pi f = 0 \u2194 \u2200 i, f i = 0", "start": [1300, 1], "end": [1302, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.pi_zero", "code": "theorem pi_zero : pi (fun _ => 0 : \u2200 i, M \u2192L[R] \u03c6 i) = 0", "start": [1305, 1], "end": [1306, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.pi_comp", "code": "theorem pi_comp (f : \u2200 i, M \u2192L[R] \u03c6 i) (g : M\u2082 \u2192L[R] M) :\n    (pi f).comp g = pi fun i => (f i).comp g", "start": [1309, 1], "end": [1311, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.proj", "code": "def proj (i : \u03b9) : (\u2200 i, \u03c6 i) \u2192L[R] \u03c6 i :=\n  \u27e8LinearMap.proj i, continuous_apply _\u27e9", "start": [1314, 1], "end": [1316, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.proj_apply", "code": "@[simp]\ntheorem proj_apply (i : \u03b9) (b : \u2200 i, \u03c6 i) : (proj i : (\u2200 i, \u03c6 i) \u2192L[R] \u03c6 i) b = b i", "start": [1319, 1], "end": [1321, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.proj_pi", "code": "theorem proj_pi (f : \u2200 i, M\u2082 \u2192L[R] \u03c6 i) (i : \u03b9) : (proj i).comp (pi f) = f i", "start": [1324, 1], "end": [1325, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.iInf_ker_proj", "code": "theorem iInf_ker_proj : (\u2a05 i, ker (proj i : (\u2200 i, \u03c6 i) \u2192L[R] \u03c6 i) : Submodule R (\u2200 i, \u03c6 i)) = \u22a5", "start": [1328, 1], "end": [1329, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.iInfKerProjEquiv", "code": "def iInfKerProjEquiv {I J : Set \u03b9} [DecidablePred fun i => i \u2208 I] (hd : Disjoint I J)\n    (hu : Set.univ \u2286 I \u222a J) :\n    (\u2a05 i \u2208 J, ker (proj i : (\u2200 i, \u03c6 i) \u2192L[R] \u03c6 i) : Submodule R (\u2200 i, \u03c6 i)) \u2243L[R] \u2200 i : I, \u03c6 i\n    where\n  toLinearEquiv := LinearMap.iInfKerProjEquiv R \u03c6 hd hu\n  continuous_toFun :=\n    continuous_pi fun i => by\n      have :=\n        @continuous_subtype_val _ _ fun x =>\n          x \u2208 (\u2a05 i \u2208 J, ker (proj i : (\u2200 i, \u03c6 i) \u2192L[R] \u03c6 i) : Submodule R (\u2200 i, \u03c6 i))\n      have := Continuous.comp (continuous_apply (\u03c0 := \u03c6) i) this\n      exact this\n  continuous_invFun :=\n    Continuous.subtype_mk\n      (continuous_pi fun i => by\n        change\n          Continuous (\u21d1(if h : i \u2208 I then LinearMap.proj (R := R) (\u03b9 := \u21a5I)\n            (\u03c6 := fun i : \u21a5I => \u03c6 i) \u27e8i, h\u27e9 else\n            (0 : ((i : I) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i)))\n        split_ifs <;> [apply continuous_apply; exact continuous_zero])\n      _", "start": [1334, 1], "end": [1357, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_neg", "code": "protected theorem map_neg (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) : f (-x) = -f x", "start": [1372, 1], "end": [1373, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.map_sub", "code": "protected theorem map_sub (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x y : M) : f (x - y) = f x - f y", "start": [1376, 1], "end": [1377, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sub_apply'", "code": "@[simp]\ntheorem sub_apply' (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) : ((f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) - g) x = f x - g x", "start": [1380, 1], "end": [1382, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.range_prod_eq", "code": "theorem range_prod_eq {f : M \u2192L[R] M\u2082} {g : M \u2192L[R] M\u2083} (h : ker f \u2294 ker g = \u22a4) :\n    range (f.prod g) = (range f).prod (range g)", "start": [1391, 1], "end": [1393, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ker_prod_ker_le_ker_coprod", "code": "theorem ker_prod_ker_le_ker_coprod [ContinuousAdd M\u2083] (f : M \u2192L[R] M\u2083) (g : M\u2082 \u2192L[R] M\u2083) :\n    (LinearMap.ker f).prod (LinearMap.ker g) \u2264 LinearMap.ker (f.coprod g)", "start": [1396, 1], "end": [1398, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ker_coprod_of_disjoint_range", "code": "theorem ker_coprod_of_disjoint_range [ContinuousAdd M\u2083] (f : M \u2192L[R] M\u2083) (g : M\u2082 \u2192L[R] M\u2083)\n    (hd : Disjoint (range f) (range g)) :\n    LinearMap.ker (f.coprod g) = (LinearMap.ker f).prod (LinearMap.ker g)", "start": [1401, 1], "end": [1404, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.neg", "code": "instance neg : Neg (M \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8fun f => \u27e8-f, f.2.neg\u27e9\u27e9", "start": [1413, 1], "end": [1414, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) : (-f) x = -f x", "start": [1417, 1], "end": [1419, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : (\u2191(-f) : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = -f", "start": [1422, 1], "end": [1424, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_neg'", "code": "@[norm_cast]\ntheorem coe_neg' (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(-f) = -f", "start": [1427, 1], "end": [1429, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sub", "code": "instance sub : Sub (M \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8fun f g => \u27e8f - g, f.2.sub g.2\u27e9\u27e9", "start": [1432, 1], "end": [1433, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.addCommGroup", "code": "instance addCommGroup : AddCommGroup (M \u2192SL[\u03c3\u2081\u2082] M\u2082) := by\n  refine'\n    { ContinuousLinearMap.addCommMonoid with\n      neg := (-\u00b7)\n      sub := (\u00b7 - \u00b7)\n      sub_eq_add_neg := _\n      nsmul := (\u00b7 \u2022 \u00b7)\n      zsmul := (\u00b7 \u2022 \u00b7)\n      zsmul_zero' := fun f => by ext; simp\n      zsmul_succ' := fun n f => by ext; simp [add_smul, add_comm]\n      zsmul_neg' := fun n f => by ext; simp [Nat.succ_eq_add_one, add_smul]\n      .. } <;>\n    { intros\n      ext\n      apply_rules [zero_add, add_assoc, add_zero, add_left_neg, add_comm, sub_eq_add_neg] }", "start": [1436, 1], "end": [1450, 92], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sub_apply", "code": "theorem sub_apply (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (x : M) : (f - g) x = f x - g x", "start": [1453, 1], "end": [1454, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : (\u2191(f - g) : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = f - g", "start": [1457, 1], "end": [1459, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_sub'", "code": "@[simp, norm_cast]\ntheorem coe_sub' (f g : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(f - g) = f - g", "start": [1462, 1], "end": [1464, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_neg", "code": "@[simp]\ntheorem comp_neg [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [TopologicalAddGroup M\u2082] [TopologicalAddGroup M\u2083]\n    (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : g.comp (-f) = -g.comp f", "start": [1469, 1], "end": [1473, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.neg_comp", "code": "@[simp]\ntheorem neg_comp [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [TopologicalAddGroup M\u2083] (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083)\n    (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : (-g).comp f = -g.comp f", "start": [1476, 1], "end": [1480, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_sub", "code": "@[simp]\ntheorem comp_sub [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [TopologicalAddGroup M\u2082] [TopologicalAddGroup M\u2083]\n    (g : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f\u2081 f\u2082 : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : g.comp (f\u2081 - f\u2082) = g.comp f\u2081 - g.comp f\u2082", "start": [1483, 1], "end": [1487, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.sub_comp", "code": "@[simp]\ntheorem sub_comp [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [TopologicalAddGroup M\u2083] (g\u2081 g\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083)\n    (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) : (g\u2081 - g\u2082).comp f = g\u2081.comp f - g\u2082.comp f", "start": [1490, 1], "end": [1494, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ring", "code": "instance ring [TopologicalAddGroup M] : Ring (M \u2192L[R] M) :=\n  { ContinuousLinearMap.semiring,\n    ContinuousLinearMap.addCommGroup with }", "start": [1497, 1], "end": [1499, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight_one_pow", "code": "theorem smulRight_one_pow [TopologicalSpace R] [TopologicalRing R] (c : R) (n : \u2115) :\n    smulRight (1 : R \u2192L[R] R) c ^ n = smulRight (1 : R \u2192L[R] R) (c ^ n)", "start": [1502, 1], "end": [1507, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.projKerOfRightInverse", "code": "def projKerOfRightInverse [TopologicalAddGroup M] (f\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082) (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M)\n    (h : Function.RightInverse f\u2082 f\u2081) : M \u2192L[R] LinearMap.ker f\u2081 :=\n  (id R M - f\u2082.comp f\u2081).codRestrict (LinearMap.ker f\u2081) fun x => by simp [h (f\u2081 x)]", "start": [1515, 1], "end": [1520, 83], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_projKerOfRightInverse_apply", "code": "@[simp]\ntheorem coe_projKerOfRightInverse_apply [TopologicalAddGroup M] (f\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082)\n    (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M) (h : Function.RightInverse f\u2082 f\u2081) (x : M) :\n    (f\u2081.projKerOfRightInverse f\u2082 h x : M) = x - f\u2082 (f\u2081 x)", "start": [1523, 1], "end": [1527, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.projKerOfRightInverse_apply_idem", "code": "@[simp]\ntheorem projKerOfRightInverse_apply_idem [TopologicalAddGroup M] (f\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082)\n    (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M) (h : Function.RightInverse f\u2082 f\u2081) (x : LinearMap.ker f\u2081) :\n    f\u2081.projKerOfRightInverse f\u2082 h x = x", "start": [1530, 1], "end": [1535, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.projKerOfRightInverse_comp_inv", "code": "@[simp]\ntheorem projKerOfRightInverse_comp_inv [TopologicalAddGroup M] (f\u2081 : M \u2192SL[\u03c3\u2081\u2082] M\u2082)\n    (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M) (h : Function.RightInverse f\u2082 f\u2081) (y : M\u2082) :\n    f\u2081.projKerOfRightInverse f\u2082 h (f\u2082 y) = 0", "start": [1538, 1], "end": [1542, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isOpenMap_of_ne_zero", "code": "protected theorem isOpenMap_of_ne_zero [TopologicalSpace R] [DivisionRing R] [ContinuousSub R]\n    [AddCommGroup M] [TopologicalSpace M] [ContinuousAdd M] [Module R M] [ContinuousSMul R M]\n    (f : M \u2192L[R] R) (hf : f \u2260 0) : IsOpenMap f", "start": [1553, 1], "end": [1560, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smul_comp", "code": "@[simp]\ntheorem smul_comp (c : S\u2083) (h : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    (c \u2022 h).comp f = c \u2022 h.comp f", "start": [1577, 1], "end": [1580, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_smul", "code": "@[simp]\ntheorem comp_smul [LinearMap.CompatibleSMul N\u2082 N\u2083 S R] (h\u2097 : N\u2082 \u2192L[R] N\u2083) (c : S)\n    (f\u2097 : M \u2192L[R] N\u2082) : h\u2097.comp (c \u2022 f\u2097) = c \u2022 h\u2097.comp f\u2097", "start": [1587, 1], "end": [1591, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.comp_smul\u209b\u2097", "code": "@[simp]\ntheorem comp_smul\u209b\u2097 [SMulCommClass R\u2082 R\u2082 M\u2082] [SMulCommClass R\u2083 R\u2083 M\u2083] [ContinuousConstSMul R\u2082 M\u2082]\n    [ContinuousConstSMul R\u2083 M\u2083] (h : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) (c : R\u2082) (f : M \u2192SL[\u03c3\u2081\u2082] M\u2082) :\n    h.comp (c \u2022 f) = \u03c3\u2082\u2083 c \u2022 h.comp f", "start": [1594, 1], "end": [1600, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.distribMulAction", "code": "instance distribMulAction [ContinuousAdd M\u2082] : DistribMulAction S\u2083 (M \u2192SL[\u03c3\u2081\u2082] M\u2082) where\n  smul_add a f g := ext fun x => smul_add a (f x) (g x)\n  smul_zero _a := ext fun _x => smul_zero _", "start": [1603, 1], "end": [1605, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prodEquiv", "code": "@[simps apply]\ndef prodEquiv : (M \u2192L[R] N\u2082) \u00d7 (M \u2192L[R] N\u2083) \u2243 (M \u2192L[R] N\u2082 \u00d7 N\u2083) where\n  toFun f := f.1.prod f.2\n  invFun f := \u27e8(fst _ _ _).comp f, (snd _ _ _).comp f\u27e9\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl", "start": [1623, 1], "end": [1629, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod_ext_iff", "code": "theorem prod_ext_iff {f g : M \u00d7 N\u2082 \u2192L[R] N\u2083} :\n    f = g \u2194 f.comp (inl _ _ _) = g.comp (inl _ _ _) \u2227 f.comp (inr _ _ _) = g.comp (inr _ _ _)", "start": [1633, 1], "end": [1636, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod_ext", "code": "@[ext]\ntheorem prod_ext {f g : M \u00d7 N\u2082 \u2192L[R] N\u2083} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))\n    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g", "start": [1639, 1], "end": [1642, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.module", "code": "instance module : Module S\u2083 (M \u2192SL[\u03c3\u2081\u2083] M\u2083) where\n  zero_smul _ := ext fun _ => zero_smul _ _\n  add_smul _ _ _ := ext fun _ => add_smul _ _ _", "start": [1647, 1], "end": [1649, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.isCentralScalar", "code": "instance isCentralScalar [Module S\u2083\u1d50\u1d52\u1d56 M\u2083] [IsCentralScalar S\u2083 M\u2083] :\n    IsCentralScalar S\u2083 (M \u2192SL[\u03c3\u2081\u2083] M\u2083) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _", "start": [1652, 1], "end": [1654, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.prod\u2097", "code": "@[simps apply]\ndef prod\u2097 : ((M \u2192L[R] N\u2082) \u00d7 (M \u2192L[R] N\u2083)) \u2243\u2097[S] M \u2192L[R] N\u2082 \u00d7 N\u2083 :=\n  { prodEquiv with\n    map_add' := fun _f _g => rfl\n    map_smul' := fun _c _f => rfl }", "start": [1659, 1], "end": [1664, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeLM", "code": "@[simps]\ndef coeLM : (M \u2192L[R] N\u2083) \u2192\u2097[S] M \u2192\u2097[R] N\u2083 where\n  toFun := (\u2191)\n  map_add' f g := coe_add f g\n  map_smul' c f := coe_smul c f", "start": [1668, 1], "end": [1673, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coeLM\u209b\u2097", "code": "@[simps]\ndef coeLM\u209b\u2097 : (M \u2192SL[\u03c3\u2081\u2083] M\u2083) \u2192\u2097[S\u2083] M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083 where\n  toFun := (\u2191)\n  map_add' f g := coe_add f g\n  map_smul' c f := coe_smul c f", "start": [1679, 1], "end": [1684, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.smulRight\u2097", "code": "def smulRight\u2097 (c : M \u2192L[R] S) : M\u2082 \u2192\u2097[T] M \u2192L[R] M\u2082 where\n  toFun := c.smulRight\n  map_add' x y := by\n    ext e\n    apply smul_add\n  map_smul' a x := by\n    ext e\n    dsimp\n    apply smul_comm", "start": [1698, 1], "end": [1708, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_smulRight\u2097", "code": "@[simp]\ntheorem coe_smulRight\u2097 (c : M \u2192L[R] S) : \u21d1(smulRight\u2097 c : M\u2082 \u2192\u2097[T] M \u2192L[R] M\u2082) = c.smulRight", "start": [1711, 1], "end": [1713, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.algebra", "code": "instance algebra : Algebra R (M\u2082 \u2192L[R] M\u2082) :=\n  Algebra.ofModule smul_comp fun _ _ _ => comp_smul _ _ _", "start": [1726, 1], "end": [1727, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars", "code": "def restrictScalars (f : M \u2192L[A] M\u2082) : M \u2192L[R] M\u2082 :=\n  \u27e8(f : M \u2192\u2097[A] M\u2082).restrictScalars R, f.continuous\u27e9", "start": [1738, 1], "end": [1742, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrictScalars", "code": "@[simp] theorem coe_restrictScalars (f : M \u2192L[A] M\u2082) :\n    (f.restrictScalars R : M \u2192\u2097[R] M\u2082) = (f : M \u2192\u2097[A] M\u2082).restrictScalars R", "start": [1747, 1], "end": [1750, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrictScalars'", "code": "@[simp]\ntheorem coe_restrictScalars' (f : M \u2192L[A] M\u2082) : \u21d1(f.restrictScalars R) = f", "start": [1753, 1], "end": [1755, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars_zero", "code": "@[simp]\ntheorem restrictScalars_zero : (0 : M \u2192L[A] M\u2082).restrictScalars R = 0", "start": [1758, 1], "end": [1760, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars_add", "code": "@[simp]\ntheorem restrictScalars_add (f g : M \u2192L[A] M\u2082) :\n    (f + g).restrictScalars R = f.restrictScalars R + g.restrictScalars R", "start": [1767, 1], "end": [1770, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars_neg", "code": "@[simp]\ntheorem restrictScalars_neg (f : M \u2192L[A] M\u2082) : (-f).restrictScalars R = -f.restrictScalars R", "start": [1773, 1], "end": [1775, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars_smul", "code": "@[simp]\ntheorem restrictScalars_smul (c : S) (f : M \u2192L[A] M\u2082) :\n    (c \u2022 f).restrictScalars R = c \u2022 f.restrictScalars R", "start": [1784, 1], "end": [1787, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.restrictScalars\u2097", "code": "def restrictScalars\u2097 : (M \u2192L[A] M\u2082) \u2192\u2097[S] M \u2192L[R] M\u2082 where\n  toFun := restrictScalars R\n  map_add' := restrictScalars_add\n  map_smul' := restrictScalars_smul", "start": [1793, 1], "end": [1798, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.coe_restrictScalars\u2097", "code": "@[simp]\ntheorem coe_restrictScalars\u2097 : \u21d1(restrictScalars\u2097 A M M\u2082 R S) = restrictScalars R", "start": [1803, 1], "end": [1805, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toContinuousLinearMap", "code": "@[coe]\ndef toContinuousLinearMap (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082 :=\n  { e.toLinearEquiv.toLinearMap with cont := e.continuous_toFun }", "start": [1826, 1], "end": [1829, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ContinuousLinearMap.coe", "code": "instance ContinuousLinearMap.coe : Coe (M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) :=\n  \u27e8toContinuousLinearMap\u27e9", "start": [1832, 1], "end": [1834, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousSemilinearEquivClass", "code": "instance continuousSemilinearEquivClass :\n    ContinuousSemilinearEquivClass (M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) \u03c3\u2081\u2082 M\u2081 M\u2082 where\n  coe f := f.toFun\n  inv f := f.invFun\n  coe_injective' f g h\u2081 h\u2082 := by\n    cases' f with f' _\n    cases' g with g' _\n    rcases f' with \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9\n    rcases g' with \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9\n    congr\n  left_inv f := f.left_inv\n  right_inv f := f.right_inv\n  map_add f := f.map_add'\n  map_smul\u209b\u2097 f := f.map_smul'\n  map_continuous := continuous_toFun\n  inv_continuous := continuous_invFun", "start": [1837, 1], "end": [1852, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_apply", "code": "theorem coe_apply (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (b : M\u2081) : (e : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) b = e b", "start": [1863, 1], "end": [1864, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_toLinearEquiv", "code": "@[simp]\ntheorem coe_toLinearEquiv (f : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : \u21d1f.toLinearEquiv = f", "start": [1867, 1], "end": [1869, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : \u21d1(e : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = e", "start": [1872, 1], "end": [1874, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toLinearEquiv_injective", "code": "theorem toLinearEquiv_injective :\n    Function.Injective (toLinearEquiv : (M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) \u2192 M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [1877, 1], "end": [1880, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ext", "code": "@[ext]\ntheorem ext {f g : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082} (h : (f : M\u2081 \u2192 M\u2082) = g) : f = g", "start": [1883, 1], "end": [1885, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_injective", "code": "theorem coe_injective : Function.Injective ((\u2191) : (M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) \u2192 M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082)", "start": [1888, 1], "end": [1889, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {e e' : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082} : (e : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = e' \u2194 e = e'", "start": [1892, 1], "end": [1894, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toHomeomorph", "code": "def toHomeomorph (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2243\u209c M\u2082 :=\n  { e with toEquiv := e.toLinearEquiv.toEquiv }", "start": [1897, 1], "end": [1899, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : \u21d1e.toHomeomorph = e", "start": [1902, 1], "end": [1904, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isOpenMap", "code": "theorem isOpenMap (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : IsOpenMap e", "start": [1907, 1], "end": [1908, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.image_closure", "code": "theorem image_closure (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2081) : e '' closure s = closure (e '' s)", "start": [1910, 1], "end": [1911, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.preimage_closure", "code": "theorem preimage_closure (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2082) : e \u207b\u00b9' closure s = closure (e \u207b\u00b9' s)", "start": [1914, 1], "end": [1915, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.isClosed_image", "code": "@[simp]\ntheorem isClosed_image (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {s : Set M\u2081} : IsClosed (e '' s) \u2194 IsClosed s", "start": [1918, 1], "end": [1920, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_nhds_eq", "code": "theorem map_nhds_eq (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : map e (\ud835\udcdd x) = \ud835\udcdd (e x)", "start": [1923, 1], "end": [1924, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_zero", "code": "theorem map_zero (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : e (0 : M\u2081) = 0", "start": [1929, 1], "end": [1930, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_add", "code": "theorem map_add (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x y : M\u2081) : e (x + y) = e x + e y", "start": [1934, 1], "end": [1935, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_smul\u209b\u2097", "code": "theorem map_smul\u209b\u2097 (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (c : R\u2081) (x : M\u2081) : e (c \u2022 x) = \u03c3\u2081\u2082 c \u2022 e x", "start": [1939, 1], "end": [1940, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_smul", "code": "theorem map_smul [Module R\u2081 M\u2082] (e : M\u2081 \u2243L[R\u2081] M\u2082) (c : R\u2081) (x : M\u2081) : e (c \u2022 x) = c \u2022 e x", "start": [1944, 1], "end": [1945, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_eq_zero_iff", "code": "theorem map_eq_zero_iff (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x : M\u2081} : e x = 0 \u2194 x = 0", "start": [1949, 1], "end": [1950, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuous", "code": "@[continuity]\nprotected theorem continuous (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : Continuous (e : M\u2081 \u2192 M\u2082)", "start": [1956, 1], "end": [1958, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousOn", "code": "protected theorem continuousOn (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {s : Set M\u2081} : ContinuousOn (e : M\u2081 \u2192 M\u2082) s", "start": [1961, 1], "end": [1962, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousAt", "code": "protected theorem continuousAt (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x : M\u2081} : ContinuousAt (e : M\u2081 \u2192 M\u2082) x", "start": [1965, 1], "end": [1966, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.continuousWithinAt", "code": "protected theorem continuousWithinAt (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {s : Set M\u2081} {x : M\u2081} :\n    ContinuousWithinAt (e : M\u2081 \u2192 M\u2082) s x", "start": [1969, 1], "end": [1971, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.comp_continuousOn_iff", "code": "theorem comp_continuousOn_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {f : \u03b1 \u2192 M\u2081}\n    {s : Set \u03b1} : ContinuousOn (e \u2218 f) s \u2194 ContinuousOn f s", "start": [1974, 1], "end": [1976, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.comp_continuous_iff", "code": "theorem comp_continuous_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {f : \u03b1 \u2192 M\u2081} :\n    Continuous (e \u2218 f) \u2194 Continuous f", "start": [1979, 1], "end": [1981, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ext\u2081", "code": "theorem ext\u2081 [TopologicalSpace R\u2081] {f g : R\u2081 \u2243L[R\u2081] M\u2081} (h : f 1 = g 1) : f = g", "start": [1984, 1], "end": [1986, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.refl", "code": "@[refl]\nprotected def refl : M\u2081 \u2243L[R\u2081] M\u2081 :=\n  { LinearEquiv.refl R\u2081 M\u2081 with\n    continuous_toFun := continuous_id\n    continuous_invFun := continuous_id }", "start": [1993, 1], "end": [1998, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_refl", "code": "@[simp, norm_cast]\ntheorem coe_refl : \u2191(ContinuousLinearEquiv.refl R\u2081 M\u2081) = ContinuousLinearMap.id R\u2081 M\u2081", "start": [2003, 1], "end": [2005, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_refl'", "code": "@[simp, norm_cast]\ntheorem coe_refl' : \u21d1(ContinuousLinearEquiv.refl R\u2081 M\u2081) = id", "start": [2008, 1], "end": [2010, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm", "code": "@[symm]\nprotected def symm (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : M\u2082 \u2243SL[\u03c3\u2082\u2081] M\u2081 :=\n  { e.toLinearEquiv.symm with\n    continuous_toFun := e.continuous_invFun\n    continuous_invFun := e.continuous_toFun }", "start": [2013, 1], "end": [2018, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_toLinearEquiv", "code": "@[simp]\ntheorem symm_toLinearEquiv (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : e.symm.toLinearEquiv = e.toLinearEquiv.symm", "start": [2021, 1], "end": [2024, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_toHomeomorph", "code": "@[simp]\ntheorem symm_toHomeomorph (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : e.toHomeomorph.symm = e.symm.toHomeomorph", "start": [2027, 1], "end": [2029, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.Simps.apply", "code": "def Simps.apply (h : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : M\u2081 \u2192 M\u2082 :=\n  h", "start": [2032, 1], "end": [2035, 4], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (h : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : M\u2082 \u2192 M\u2081 :=\n  h.symm", "start": [2038, 1], "end": [2040, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_map_nhds_eq", "code": "theorem symm_map_nhds_eq (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : map e.symm (\ud835\udcdd (e x)) = \ud835\udcdd x", "start": [2045, 1], "end": [2046, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.trans", "code": "@[trans]\nprotected def trans (e\u2081 : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (e\u2082 : M\u2082 \u2243SL[\u03c3\u2082\u2083] M\u2083) : M\u2081 \u2243SL[\u03c3\u2081\u2083] M\u2083 :=\n  { e\u2081.toLinearEquiv.trans e\u2082.toLinearEquiv with\n    continuous_toFun := e\u2082.continuous_toFun.comp e\u2081.continuous_toFun\n    continuous_invFun := e\u2081.continuous_invFun.comp e\u2082.continuous_invFun }", "start": [2049, 1], "end": [2054, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.trans_toLinearEquiv", "code": "@[simp]\ntheorem trans_toLinearEquiv (e\u2081 : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (e\u2082 : M\u2082 \u2243SL[\u03c3\u2082\u2083] M\u2083) :\n    (e\u2081.trans e\u2082).toLinearEquiv = e\u2081.toLinearEquiv.trans e\u2082.toLinearEquiv", "start": [2057, 1], "end": [2061, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.prod", "code": "def prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (e : M\u2081 \u2243L[R\u2081] M\u2082) (e' : M\u2083 \u2243L[R\u2081] M\u2084) :\n    (M\u2081 \u00d7 M\u2083) \u2243L[R\u2081] M\u2082 \u00d7 M\u2084 :=\n  { e.toLinearEquiv.prod e'.toLinearEquiv with\n    continuous_toFun := e.continuous_toFun.prod_map e'.continuous_toFun\n    continuous_invFun := e.continuous_invFun.prod_map e'.continuous_invFun }", "start": [2064, 1], "end": [2069, 77], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.prod_apply", "code": "@[simp, norm_cast]\ntheorem prod_apply [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (e : M\u2081 \u2243L[R\u2081] M\u2082)\n    (e' : M\u2083 \u2243L[R\u2081] M\u2084) (x) : e.prod e' x = (e x.1, e' x.2)", "start": [2072, 1], "end": [2075, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_prod", "code": "@[simp, norm_cast]\ntheorem coe_prod [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (e : M\u2081 \u2243L[R\u2081] M\u2082)\n    (e' : M\u2083 \u2243L[R\u2081] M\u2084) :\n    (e.prod e' : M\u2081 \u00d7 M\u2083 \u2192L[R\u2081] M\u2082 \u00d7 M\u2084) = (e : M\u2081 \u2192L[R\u2081] M\u2082).prodMap (e' : M\u2083 \u2192L[R\u2081] M\u2084)", "start": [2078, 1], "end": [2082, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.prod_symm", "code": "theorem prod_symm [Module R\u2081 M\u2082] [Module R\u2081 M\u2083] [Module R\u2081 M\u2084] (e : M\u2081 \u2243L[R\u2081] M\u2082)\n    (e' : M\u2083 \u2243L[R\u2081] M\u2084) : (e.prod e').symm = e.symm.prod e'.symm", "start": [2085, 1], "end": [2087, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.prodComm", "code": "@[simps! apply toLinearEquiv]\ndef prodComm [Module R\u2081 M\u2082] : (M\u2081 \u00d7 M\u2082) \u2243L[R\u2081] M\u2082 \u00d7 M\u2081 :=\n  { LinearEquiv.prodComm R\u2081 M\u2081 M\u2082 with\n    continuous_toFun := continuous_swap\n    continuous_invFun := continuous_swap }", "start": [2092, 1], "end": [2097, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.prodComm_symm", "code": "@[simp] lemma prodComm_symm [Module R\u2081 M\u2082] : (prodComm R\u2081 M\u2081 M\u2082).symm = prodComm R\u2081 M\u2082 M\u2081 := rfl", "start": [2099, 1], "end": [2099, 97], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearEquiv.bijective", "code": "protected theorem bijective (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : Function.Bijective e", "start": [2103, 1], "end": [2104, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.injective", "code": "protected theorem injective (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : Function.Injective e", "start": [2107, 1], "end": [2108, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.surjective", "code": "protected theorem surjective (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : Function.Surjective e", "start": [2111, 1], "end": [2112, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (e\u2082 : M\u2082 \u2243SL[\u03c3\u2082\u2083] M\u2083) (c : M\u2081) :\n    (e\u2081.trans e\u2082) c = e\u2082 (e\u2081 c)", "start": [2115, 1], "end": [2118, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (c : M\u2082) : e (e.symm c) = c", "start": [2121, 1], "end": [2123, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (b : M\u2081) : e.symm (e b) = b", "start": [2126, 1], "end": [2128, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (e\u2081 : M\u2082 \u2243SL[\u03c3\u2082\u2081] M\u2081) (e\u2082 : M\u2083 \u2243SL[\u03c3\u2083\u2082] M\u2082) (c : M\u2081) :\n    (e\u2082.trans e\u2081).symm c = e\u2082.symm (e\u2081.symm c)", "start": [2131, 1], "end": [2134, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_image_image", "code": "@[simp]\ntheorem symm_image_image (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2081) : e.symm '' (e '' s) = s", "start": [2137, 1], "end": [2139, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.image_symm_image", "code": "@[simp]\ntheorem image_symm_image (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2082) : e '' (e.symm '' s) = s", "start": [2142, 1], "end": [2144, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.comp_coe", "code": "@[simp, norm_cast]\ntheorem comp_coe (f : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (f' : M\u2082 \u2243SL[\u03c3\u2082\u2083] M\u2083) :\n    (f' : M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083).comp (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = (f.trans f' : M\u2081 \u2192SL[\u03c3\u2081\u2083] M\u2083)", "start": [2147, 1], "end": [2150, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_comp_coe_symm", "code": "@[simp high]\ntheorem coe_comp_coe_symm (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n    (e : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082).comp (e.symm : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081) = ContinuousLinearMap.id R\u2082 M\u2082", "start": [2154, 1], "end": [2157, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_symm_comp_coe", "code": "@[simp high]\ntheorem coe_symm_comp_coe (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) :\n    (e.symm : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081).comp (e : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) = ContinuousLinearMap.id R\u2081 M\u2081", "start": [2161, 1], "end": [2164, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_comp_self", "code": "@[simp]\ntheorem symm_comp_self (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : (e.symm : M\u2082 \u2192 M\u2081) \u2218 (e : M\u2081 \u2192 M\u2082) = id", "start": [2167, 1], "end": [2170, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.self_comp_symm", "code": "@[simp]\ntheorem self_comp_symm (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : (e : M\u2081 \u2192 M\u2082) \u2218 (e.symm : M\u2082 \u2192 M\u2081) = id", "start": [2173, 1], "end": [2176, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : e.symm.symm = e", "start": [2179, 1], "end": [2182, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm : (ContinuousLinearEquiv.refl R\u2081 M\u2081).symm = ContinuousLinearEquiv.refl R\u2081 M\u2081", "start": [2185, 1], "end": [2187, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_symm_apply", "code": "theorem symm_symm_apply (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M\u2081) : e.symm.symm x = e x", "start": [2190, 1], "end": [2191, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_apply_eq", "code": "theorem symm_apply_eq (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x y} : e.symm x = y \u2194 x = e y", "start": [2194, 1], "end": [2195, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.eq_symm_apply", "code": "theorem eq_symm_apply (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) {x y} : y = e.symm x \u2194 e y = x", "start": [2198, 1], "end": [2199, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.image_eq_preimage", "code": "protected theorem image_eq_preimage (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2081) : e '' s = e.symm \u207b\u00b9' s", "start": [2202, 1], "end": [2203, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.image_symm_eq_preimage", "code": "protected theorem image_symm_eq_preimage (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2082) :\n    e.symm '' s = e \u207b\u00b9' s", "start": [2206, 1], "end": [2207, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_preimage_preimage", "code": "@[simp]\nprotected theorem symm_preimage_preimage (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2082) :\n    e.symm \u207b\u00b9' (e \u207b\u00b9' s) = s", "start": [2210, 1], "end": [2213, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.preimage_symm_preimage", "code": "@[simp]\nprotected theorem preimage_symm_preimage (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (s : Set M\u2081) :\n    e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s", "start": [2216, 1], "end": [2219, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.uniformEmbedding", "code": "protected theorem uniformEmbedding {E\u2081 E\u2082 : Type*} [UniformSpace E\u2081] [UniformSpace E\u2082]\n    [AddCommGroup E\u2081] [AddCommGroup E\u2082] [Module R\u2081 E\u2081] [Module R\u2082 E\u2082] [UniformAddGroup E\u2081]\n    [UniformAddGroup E\u2082] (e : E\u2081 \u2243SL[\u03c3\u2081\u2082] E\u2082) : UniformEmbedding e", "start": [2222, 1], "end": [2226, 51], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.uniformEmbedding", "code": "protected theorem _root_.LinearEquiv.uniformEmbedding {E\u2081 E\u2082 : Type*} [UniformSpace E\u2081]\n    [UniformSpace E\u2082] [AddCommGroup E\u2081] [AddCommGroup E\u2082] [Module R\u2081 E\u2081] [Module R\u2082 E\u2082]\n    [UniformAddGroup E\u2081] [UniformAddGroup E\u2082] (e : E\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] E\u2082)\n    (h\u2081 : Continuous e) (h\u2082 : Continuous e.symm) : UniformEmbedding e", "start": [2229, 1], "end": [2237, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.equivOfInverse", "code": "def equivOfInverse (f\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f\u2082 : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081) (h\u2081 : Function.LeftInverse f\u2082 f\u2081)\n    (h\u2082 : Function.RightInverse f\u2082 f\u2081) : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082 :=\n  { f\u2081 with\n    continuous_toFun := f\u2081.continuous\n    invFun := f\u2082\n    continuous_invFun := f\u2082.continuous\n    left_inv := h\u2081\n    right_inv := h\u2082 }", "start": [2240, 1], "end": [2249, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.equivOfInverse_apply", "code": "@[simp]\ntheorem equivOfInverse_apply (f\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f\u2082 h\u2081 h\u2082 x) :\n    equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082 x = f\u2081 x", "start": [2252, 1], "end": [2255, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.symm_equivOfInverse", "code": "@[simp]\ntheorem symm_equivOfInverse (f\u2081 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (f\u2082 h\u2081 h\u2082) :\n    (equivOfInverse f\u2081 f\u2082 h\u2081 h\u2082).symm = equivOfInverse f\u2082 f\u2081 h\u2082 h\u2081", "start": [2258, 1], "end": [2261, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.automorphismGroup", "code": "instance automorphismGroup : Group (M\u2081 \u2243L[R\u2081] M\u2081) where\n  mul f g := g.trans f\n  one := ContinuousLinearEquiv.refl R\u2081 M\u2081\n  inv f := f.symm\n  mul_assoc f g h := by\n    ext\n    rfl\n  mul_one f := by\n    ext\n    rfl\n  one_mul f := by\n    ext\n    rfl\n  mul_left_inv f := by\n    ext x\n    exact f.left_inv x", "start": [2266, 1], "end": [2282, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ulift", "code": "def ulift : ULift M\u2081 \u2243L[R\u2081] M\u2081 :=\n  { ULift.moduleEquiv with\n    continuous_toFun := continuous_uLift_down\n    continuous_invFun := continuous_uLift_up }", "start": [2289, 1], "end": [2295, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.arrowCongrEquiv", "code": "@[simps]\ndef arrowCongrEquiv (e\u2081\u2082 : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) (e\u2084\u2083 : M\u2084 \u2243SL[\u03c3\u2084\u2083] M\u2083) :\n    (M\u2081 \u2192SL[\u03c3\u2081\u2084] M\u2084) \u2243 (M\u2082 \u2192SL[\u03c3\u2082\u2083] M\u2083) where\n  toFun f := (e\u2084\u2083 : M\u2084 \u2192SL[\u03c3\u2084\u2083] M\u2083).comp (f.comp (e\u2081\u2082.symm : M\u2082 \u2192SL[\u03c3\u2082\u2081] M\u2081))\n  invFun f := (e\u2084\u2083.symm : M\u2083 \u2192SL[\u03c3\u2083\u2084] M\u2084).comp (f.comp (e\u2081\u2082 : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082))\n  left_inv f :=\n    ContinuousLinearMap.ext fun x => by\n      simp only [ContinuousLinearMap.comp_apply, symm_apply_apply, coe_coe]\n  right_inv f :=\n    ContinuousLinearMap.ext fun x => by\n      simp only [ContinuousLinearMap.comp_apply, apply_symm_apply, coe_coe]", "start": [2298, 1], "end": [2310, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.skewProd", "code": "def skewProd (e : M \u2243L[R] M\u2082) (e' : M\u2083 \u2243L[R] M\u2084) (f : M \u2192L[R] M\u2084) : (M \u00d7 M\u2083) \u2243L[R] M\u2082 \u00d7 M\u2084 :=\n  {\n    e.toLinearEquiv.skewProd e'.toLinearEquiv\n      \u2191f with\n    continuous_toFun :=\n      (e.continuous_toFun.comp continuous_fst).prod_mk\n        ((e'.continuous_toFun.comp continuous_snd).add <| f.continuous.comp continuous_fst)\n    continuous_invFun :=\n      (e.continuous_invFun.comp continuous_fst).prod_mk\n        (e'.continuous_invFun.comp <|\n          continuous_snd.sub <| f.continuous.comp <| e.continuous_invFun.comp continuous_fst) }", "start": [2326, 1], "end": [2338, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.skewProd_apply", "code": "@[simp]\ntheorem skewProd_apply (e : M \u2243L[R] M\u2082) (e' : M\u2083 \u2243L[R] M\u2084) (f : M \u2192L[R] M\u2084) (x) :\n    e.skewProd e' f x = (e x.1, e' x.2 + f x.1)", "start": [2341, 1], "end": [2344, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.skewProd_symm_apply", "code": "@[simp]\ntheorem skewProd_symm_apply (e : M \u2243L[R] M\u2082) (e' : M\u2083 \u2243L[R] M\u2084) (f : M \u2192L[R] M\u2084) (x) :\n    (e.skewProd e' f).symm x = (e.symm x.1, e'.symm (x.2 - f (e.symm x.1)))", "start": [2347, 1], "end": [2350, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_sub", "code": "theorem map_sub (e : M \u2243SL[\u03c3\u2081\u2082] M\u2082) (x y : M) : e (x - y) = e x - e y", "start": [2363, 1], "end": [2364, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_neg", "code": "theorem map_neg (e : M \u2243SL[\u03c3\u2081\u2082] M\u2082) (x : M) : e (-x) = -e x", "start": [2368, 1], "end": [2369, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ofUnit", "code": "def ofUnit (f : (M \u2192L[R] M)\u02e3) : M \u2243L[R] M where\n  toLinearEquiv :=\n    { toFun := f.val\n      map_add' := by simp\n      map_smul' := by simp\n      invFun := f.inv\n      left_inv := fun x =>\n        show (f.inv * f.val) x = x by\n          rw [f.inv_val]\n          simp\n      right_inv := fun x =>\n        show (f.val * f.inv) x = x by\n          rw [f.val_inv]\n          simp }\n  continuous_toFun := f.val.continuous\n  continuous_invFun := f.inv.continuous", "start": [2380, 1], "end": [2397, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toUnit", "code": "def toUnit (f : M \u2243L[R] M) : (M \u2192L[R] M)\u02e3 where\n  val := f\n  inv := f.symm\n  val_inv := by\n    ext\n    simp\n  inv_val := by\n    ext\n    simp", "start": [2400, 1], "end": [2409, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquiv", "code": "def unitsEquiv : (M \u2192L[R] M)\u02e3 \u2243* M \u2243L[R] M where\n  toFun := ofUnit\n  invFun := toUnit\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl\n  map_mul' x y := by\n    ext\n    rfl", "start": [2414, 1], "end": [2427, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquiv_apply", "code": "@[simp]\ntheorem unitsEquiv_apply (f : (M \u2192L[R] M)\u02e3) (x : M) : unitsEquiv R M f x = (f : M \u2192L[R] M) x", "start": [2430, 1], "end": [2432, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquivAut", "code": "def unitsEquivAut : R\u02e3 \u2243 R \u2243L[R] R where\n  toFun u :=\n    equivOfInverse (ContinuousLinearMap.smulRight (1 : R \u2192L[R] R) \u2191u)\n      (ContinuousLinearMap.smulRight (1 : R \u2192L[R] R) \u2191u\u207b\u00b9) (fun x => by simp) fun x => by simp\n  invFun e :=\n    \u27e8e 1, e.symm 1, by rw [\u2190 smul_eq_mul, \u2190 map_smul, smul_eq_mul, mul_one, symm_apply_apply], by\n      rw [\u2190 smul_eq_mul, \u2190 map_smul, smul_eq_mul, mul_one, apply_symm_apply]\u27e9\n  left_inv u := Units.ext <| by simp\n  right_inv e := ext\u2081 <| by simp", "start": [2442, 1], "end": [2451, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquivAut_apply", "code": "@[simp]\ntheorem unitsEquivAut_apply (u : R\u02e3) (x : R) : unitsEquivAut R u x = x * u", "start": [2456, 1], "end": [2458, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquivAut_apply_symm", "code": "@[simp]\ntheorem unitsEquivAut_apply_symm (u : R\u02e3) (x : R) : (unitsEquivAut R u).symm x = x * \u2191u\u207b\u00b9", "start": [2461, 1], "end": [2463, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.unitsEquivAut_symm_apply", "code": "@[simp]\ntheorem unitsEquivAut_symm_apply (e : R \u2243L[R] R) : \u2191((unitsEquivAut R).symm e) = e 1", "start": [2466, 1], "end": [2468, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.equivOfRightInverse", "code": "def equivOfRightInverse (f\u2081 : M \u2192L[R] M\u2082) (f\u2082 : M\u2082 \u2192L[R] M) (h : Function.RightInverse f\u2082 f\u2081) :\n    M \u2243L[R] M\u2082 \u00d7 ker f\u2081 :=\n  equivOfInverse (f\u2081.prod (f\u2081.projKerOfRightInverse f\u2082 h)) (f\u2082.coprod (ker f\u2081).subtypeL)\n    (fun x => by simp) fun \u27e8x, y\u27e9 => by\n      rw [ContinuousLinearMap.coprod_apply,\n        Submodule.subtypeL_apply, _root_.map_add, ContinuousLinearMap.prod_apply, h x,\n        ContinuousLinearMap.projKerOfRightInverse_comp_inv,\n        ContinuousLinearMap.prod_apply, LinearMap.map_coe_ker,\n        ContinuousLinearMap.projKerOfRightInverse_apply_idem, Prod.mk_add_mk, add_zero, zero_add]", "start": [2475, 1], "end": [2487, 98], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.fst_equivOfRightInverse", "code": "@[simp]\ntheorem fst_equivOfRightInverse (f\u2081 : M \u2192L[R] M\u2082) (f\u2082 : M\u2082 \u2192L[R] M)\n    (h : Function.RightInverse f\u2082 f\u2081) (x : M) : (equivOfRightInverse f\u2081 f\u2082 h x).1 = f\u2081 x", "start": [2490, 1], "end": [2493, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.snd_equivOfRightInverse", "code": "@[simp]\ntheorem snd_equivOfRightInverse (f\u2081 : M \u2192L[R] M\u2082) (f\u2082 : M\u2082 \u2192L[R] M)\n    (h : Function.RightInverse f\u2082 f\u2081) (x : M) :\n    ((equivOfRightInverse f\u2081 f\u2082 h x).2 : M) = x - f\u2082 (f\u2081 x)", "start": [2496, 1], "end": [2500, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.equivOfRightInverse_symm_apply", "code": "@[simp]\ntheorem equivOfRightInverse_symm_apply (f\u2081 : M \u2192L[R] M\u2082) (f\u2082 : M\u2082 \u2192L[R] M)\n    (h : Function.RightInverse f\u2082 f\u2081) (y : M\u2082 \u00d7 ker f\u2081) :\n    (equivOfRightInverse f\u2081 f\u2082 h).symm y = f\u2082 y.1 + y.2", "start": [2503, 1], "end": [2507, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.funUnique", "code": "def funUnique : (\u03b9 \u2192 M) \u2243L[R] M :=\n  { Homeomorph.funUnique \u03b9 M with toLinearEquiv := LinearEquiv.funUnique \u03b9 R M }", "start": [2517, 1], "end": [2519, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_funUnique", "code": "@[simp]\ntheorem coe_funUnique : \u21d1(funUnique \u03b9 R M) = Function.eval default", "start": [2524, 1], "end": [2526, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_funUnique_symm", "code": "@[simp]\ntheorem coe_funUnique_symm : \u21d1(funUnique \u03b9 R M).symm = Function.const \u03b9", "start": [2529, 1], "end": [2531, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.piFinTwo", "code": "@[simps! (config := { fullyApplied := false }) apply symm_apply]\ndef piFinTwo (M : Fin 2 \u2192 Type*) [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]\n    [\u2200 i, TopologicalSpace (M i)] : ((i : _) \u2192 M i) \u2243L[R] M 0 \u00d7 M 1 :=\n  { Homeomorph.piFinTwo M with toLinearEquiv := LinearEquiv.piFinTwo R M }", "start": [2536, 1], "end": [2541, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.finTwoArrow", "code": "@[simps! (config := { fullyApplied := false }) apply symm_apply]\ndef finTwoArrow : (Fin 2 \u2192 M) \u2243L[R] M \u00d7 M :=\n  { piFinTwo R fun _ => M with toLinearEquiv := LinearEquiv.finTwoArrow R M }", "start": [2546, 1], "end": [2549, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inverse", "code": "noncomputable def inverse : (M \u2192L[R] M\u2082) \u2192 M\u2082 \u2192L[R] M := fun f =>\n  if h : \u2203 e : M \u2243L[R] M\u2082, (e : M \u2192L[R] M\u2082) = f then ((Classical.choose h).symm : M\u2082 \u2192L[R] M) else 0", "start": [2572, 1], "end": [2577, 101], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inverse_equiv", "code": "@[simp]\ntheorem inverse_equiv (e : M \u2243L[R] M\u2082) : inverse (e : M \u2192L[R] M\u2082) = e.symm", "start": [2580, 1], "end": [2586, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.inverse_non_equiv", "code": "@[simp]\ntheorem inverse_non_equiv (f : M \u2192L[R] M\u2082) (h : \u00ac\u2203 e' : M \u2243L[R] M\u2082, \u2191e' = f) : inverse f = 0", "start": [2589, 1], "end": [2592, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ring_inverse_equiv", "code": "@[simp]\ntheorem ring_inverse_equiv (e : M \u2243L[R] M) : Ring.inverse \u2191e = inverse (e : M \u2192L[R] M)", "start": [2605, 1], "end": [2610, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.to_ring_inverse", "code": "theorem to_ring_inverse (e : M \u2243L[R] M\u2082) (f : M \u2192L[R] M\u2082) :\n    inverse f = Ring.inverse ((e.symm : M\u2082 \u2192L[R] M).comp f) \u2218L e.symm", "start": [2613, 1], "end": [2630, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ring_inverse_eq_map_inverse", "code": "theorem ring_inverse_eq_map_inverse : Ring.inverse = @inverse R M M _ _ _ _ _ _ _", "start": [2633, 1], "end": [2635, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.ClosedComplemented", "code": "def ClosedComplemented (p : Submodule R M) : Prop :=\n  \u2203 f : M \u2192L[R] p, \u2200 x : p, f x = x", "start": [2649, 1], "end": [2651, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.ClosedComplemented.has_closed_complement", "code": "theorem ClosedComplemented.has_closed_complement {p : Submodule R M} [T1Space p]\n    (h : ClosedComplemented p) :\n    \u2203 (q : Submodule R M) (_ : IsClosed (q : Set M)), IsCompl p q", "start": [2654, 1], "end": [2657, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.ClosedComplemented.isClosed", "code": "protected theorem ClosedComplemented.isClosed [TopologicalAddGroup M] [T1Space M]\n    {p : Submodule R M} (h : ClosedComplemented p) : IsClosed (p : Set M)", "start": [2660, 1], "end": [2664, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.closedComplemented_bot", "code": "@[simp]\ntheorem closedComplemented_bot : ClosedComplemented (\u22a5 : Submodule R M)", "start": [2667, 1], "end": [2669, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.closedComplemented_top", "code": "@[simp]\ntheorem closedComplemented_top : ClosedComplemented (\u22a4 : Submodule R M)", "start": [2672, 1], "end": [2674, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.closedComplemented_ker_of_rightInverse", "code": "theorem ContinuousLinearMap.closedComplemented_ker_of_rightInverse {R : Type*} [Ring R]\n    {M : Type*} [TopologicalSpace M] [AddCommGroup M] {M\u2082 : Type*} [TopologicalSpace M\u2082]\n    [AddCommGroup M\u2082] [Module R M] [Module R M\u2082] [TopologicalAddGroup M] (f\u2081 : M \u2192L[R] M\u2082)\n    (f\u2082 : M\u2082 \u2192L[R] M) (h : Function.RightInverse f\u2082 f\u2081) : (ker f\u2081).ClosedComplemented", "start": [2679, 1], "end": [2683, 76], "kind": "commanddeclaration"}, {"full_name": "QuotientModule.Quotient.topologicalSpace", "code": "instance _root_.QuotientModule.Quotient.topologicalSpace : TopologicalSpace (M \u29f8 S) :=\n  inferInstanceAs (TopologicalSpace (Quotient S.quotientRel))", "start": [2694, 1], "end": [2695, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.isOpenMap_mkQ", "code": "theorem isOpenMap_mkQ [TopologicalAddGroup M] : IsOpenMap S.mkQ", "start": [2697, 1], "end": [2698, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.topologicalAddGroup_quotient", "code": "instance topologicalAddGroup_quotient [TopologicalAddGroup M] : TopologicalAddGroup (M \u29f8 S) :=\n  _root_.topologicalAddGroup_quotient S.toAddSubgroup", "start": [2701, 1], "end": [2702, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.continuousSMul_quotient", "code": "instance continuousSMul_quotient [TopologicalSpace R] [TopologicalAddGroup M] [ContinuousSMul R M] :\n    ContinuousSMul R (M \u29f8 S) := by\n  constructor\n  have quot : QuotientMap fun au : R \u00d7 M => (au.1, S.mkQ au.2) :=\n    IsOpenMap.to_quotientMap (IsOpenMap.id.prod S.isOpenMap_mkQ)\n      (continuous_id.prod_map continuous_quot_mk)\n      (Function.surjective_id.Prod_map <| surjective_quot_mk _)\n  rw [quot.continuous_iff]\n  exact continuous_quot_mk.comp continuous_smul", "start": [2705, 1], "end": [2713, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.t3_quotient_of_isClosed", "code": "instance t3_quotient_of_isClosed [TopologicalAddGroup M] [IsClosed (S : Set M)] :\n    T3Space (M \u29f8 S) :=\n  letI : IsClosed (S.toAddSubgroup : Set M) := \u2039_\u203a\n  S.toAddSubgroup.t3_quotient_of_isClosed", "start": [2716, 1], "end": [2719, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Algebra.lean", "imports": ["Mathlib/Topology/MetricSpace/Lipschitz.lean", "Mathlib/Tactic/Monotonicity.lean", "Mathlib/Topology/Algebra/MulAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LipschitzAdd", "code": "class LipschitzAdd [AddMonoid \u03b2] : Prop where\n  lipschitz_add : \u2203 C, LipschitzWith C fun p : \u03b2 \u00d7 \u03b2 => p.1 + p.2", "start": [37, 1], "end": [40, 66], "kind": "commanddeclaration"}, {"full_name": "LipschitzMul", "code": "@[to_additive]\nclass LipschitzMul [Monoid \u03b2] : Prop where\n  lipschitz_mul : \u2203 C, LipschitzWith C fun p : \u03b2 \u00d7 \u03b2 => p.1 * p.2", "start": [43, 1], "end": [47, 66], "kind": "commanddeclaration"}, {"full_name": "LipschitzAdd.C", "code": "def LipschitzAdd.C [AddMonoid \u03b2] [_i : LipschitzAdd \u03b2] : \u211d\u22650 := Classical.choose _i.lipschitz_add", "start": [50, 1], "end": [51, 98], "kind": "commanddeclaration"}, {"full_name": "LipschitzMul.C", "code": "@[to_additive existing] def LipschitzMul.C [_i : LipschitzMul \u03b2] : \u211d\u22650 := Classical.choose _i.lipschitz_mul", "start": [57, 1], "end": [59, 84], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_lipschitz_const_mul_edist", "code": "@[to_additive]\ntheorem lipschitzWith_lipschitz_const_mul_edist [_i : LipschitzMul \u03b2] :\n    LipschitzWith (LipschitzMul.C \u03b2) fun p : \u03b2 \u00d7 \u03b2 => p.1 * p.2", "start": [65, 1], "end": [68, 41], "kind": "commanddeclaration"}, {"full_name": "lipschitz_with_lipschitz_const_mul", "code": "@[to_additive]\ntheorem lipschitz_with_lipschitz_const_mul :\n    \u2200 p q : \u03b2 \u00d7 \u03b2, dist (p.1 * p.2) (q.1 * q.2) \u2264 LipschitzMul.C \u03b2 * dist p q", "start": [74, 1], "end": [78, 48], "kind": "commanddeclaration"}, {"full_name": "LipschitzMul.continuousMul", "code": "@[to_additive]\ninstance (priority := 100) LipschitzMul.continuousMul : ContinuousMul \u03b2 :=\n  \u27e8lipschitzWith_lipschitz_const_mul_edist.continuous\u27e9", "start": [83, 1], "end": [85, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.lipschitzMul", "code": "@[to_additive]\ninstance Submonoid.lipschitzMul (s : Submonoid \u03b2) : LipschitzMul s where\n  lipschitz_mul := \u27e8LipschitzMul.C \u03b2, by\n    rintro \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9\n    convert lipschitzWith_lipschitz_const_mul_edist \u27e8(x\u2081 : \u03b2), x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9 using 1\u27e9", "start": [89, 1], "end": [93, 85], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.lipschitzMul", "code": "@[to_additive]\ninstance MulOpposite.lipschitzMul : LipschitzMul \u03b2\u1d50\u1d52\u1d56 where\n  lipschitz_mul := \u27e8LipschitzMul.C \u03b2, fun \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9 =>\n    (lipschitzWith_lipschitz_const_mul_edist \u27e8x\u2082.unop, x\u2081.unop\u27e9 \u27e8y\u2082.unop, y\u2081.unop\u27e9).trans_eq\n      (congr_arg _ <| max_comm _ _)\u27e9", "start": [97, 1], "end": [101, 37], "kind": "commanddeclaration"}, {"full_name": "Real.hasLipschitzAdd", "code": "instance Real.hasLipschitzAdd : LipschitzAdd \u211d where\n  lipschitz_add := \u27e82, LipschitzWith.of_dist_le_mul <| fun p q => by\n    simp only [Real.dist_eq, Prod.dist_eq, Prod.fst_sub, Prod.snd_sub, NNReal.coe_ofNat,\n      add_sub_add_comm, two_mul]\n    refine le_trans (abs_add (p.1 - q.1) (p.2 - q.2)) ?_\n    exact add_le_add (le_max_left _ _) (le_max_right _ _)\u27e9", "start": [107, 1], "end": [112, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasLipschitzAdd", "code": "instance NNReal.hasLipschitzAdd : LipschitzAdd \u211d\u22650 where\n  lipschitz_add := \u27e8LipschitzAdd.C \u211d, by\n    rintro \u27e8x\u2081, x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9\n    exact lipschitzWith_lipschitz_const_add_edist \u27e8(x\u2081 : \u211d), x\u2082\u27e9 \u27e8y\u2081, y\u2082\u27e9\u27e9", "start": [117, 1], "end": [120, 75], "kind": "commanddeclaration"}, {"full_name": "BoundedSMul", "code": "class BoundedSMul : Prop where\n  dist_smul_pair' : \u2200 x : \u03b1, \u2200 y\u2081 y\u2082 : \u03b2, dist (x \u2022 y\u2081) (x \u2022 y\u2082) \u2264 dist x 0 * dist y\u2081 y\u2082\n  dist_pair_smul' : \u2200 x\u2081 x\u2082 : \u03b1, \u2200 y : \u03b2, dist (x\u2081 \u2022 y) (x\u2082 \u2022 y) \u2264 dist x\u2081 x\u2082 * dist y 0", "start": [129, 1], "end": [135, 89], "kind": "commanddeclaration"}, {"full_name": "dist_smul_pair", "code": "theorem dist_smul_pair (x : \u03b1) (y\u2081 y\u2082 : \u03b2) : dist (x \u2022 y\u2081) (x \u2022 y\u2082) \u2264 dist x 0 * dist y\u2081 y\u2082", "start": [141, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "dist_pair_smul", "code": "theorem dist_pair_smul (x\u2081 x\u2082 : \u03b1) (y : \u03b2) : dist (x\u2081 \u2022 y) (x\u2082 \u2022 y) \u2264 dist x\u2081 x\u2082 * dist y 0", "start": [145, 1], "end": [146, 38], "kind": "commanddeclaration"}, {"full_name": "BoundedSMul.continuousSMul", "code": "instance (priority := 100) BoundedSMul.continuousSMul : ContinuousSMul \u03b1 \u03b2 where\n  continuous_smul := by\n    rw [Metric.continuous_iff]\n    rintro \u27e8a, b\u27e9 \u03b5 \u03b50\n    obtain \u27e8\u03b4, \u03b40, h\u03b4\u03b5\u27e9 : \u2203 \u03b4 > 0, \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4 < \u03b5\n    \u00b7 have : Continuous fun \u03b4 \u21a6 \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4 := by continuity\n      refine ((this.tendsto' _ _ ?_).eventually (gt_mem_nhds \u03b50)).exists_gt\n      simp\n    refine \u27e8\u03b4, \u03b40, fun (a', b') hab' => ?_\u27e9\n    obtain \u27e8ha, hb\u27e9 := max_lt_iff.1 hab'\n    calc dist (a' \u2022 b') (a \u2022 b)\n        \u2264 dist (a' \u2022 b') (a \u2022 b') + dist (a \u2022 b') (a \u2022 b) := dist_triangle ..\n      _ \u2264 dist a' a * dist b' 0 + dist a 0 * dist b' b :=\n        add_le_add (dist_pair_smul _ _ _) (dist_smul_pair _ _ _)\n      _ \u2264 \u03b4 * (\u03b4 + dist b 0) + dist a 0 * \u03b4 := by\n          have : dist b' 0 \u2264 \u03b4 + dist b 0 := (dist_triangle _ _ _).trans <| add_le_add_right hb.le _\n          mono* <;> apply_rules [dist_nonneg, le_of_lt]\n      _ < \u03b5 := h\u03b4\u03b5", "start": [150, 1], "end": [168, 19], "kind": "commanddeclaration"}, {"full_name": "Real.boundedSMul", "code": "instance Real.boundedSMul : BoundedSMul \u211d \u211d where\n  dist_smul_pair' x y\u2081 y\u2082 := by simpa [Real.dist_eq, mul_sub] using (abs_mul x (y\u2081 - y\u2082)).le\n  dist_pair_smul' x\u2081 x\u2082 y := by simpa [Real.dist_eq, sub_mul] using (abs_mul (x\u2081 - x\u2082) y).le", "start": [173, 1], "end": [175, 93], "kind": "commanddeclaration"}, {"full_name": "NNReal.boundedSMul", "code": "instance NNReal.boundedSMul : BoundedSMul \u211d\u22650 \u211d\u22650 where\n  dist_smul_pair' x y\u2081 y\u2082 := by convert dist_smul_pair (x : \u211d) (y\u2081 : \u211d) y\u2082 using 1\n  dist_pair_smul' x\u2081 x\u2082 y := by convert dist_pair_smul (x\u2081 : \u211d) x\u2082 (y : \u211d) using 1", "start": [178, 1], "end": [180, 83], "kind": "commanddeclaration"}, {"full_name": "BoundedSMul.op", "code": "instance BoundedSMul.op [SMul \u03b1\u1d50\u1d52\u1d56 \u03b2] [IsCentralScalar \u03b1 \u03b2] : BoundedSMul \u03b1\u1d50\u1d52\u1d56 \u03b2 where\n  dist_smul_pair' :=\n    MulOpposite.rec' fun x y\u2081 y\u2082 => by simpa only [op_smul_eq_smul] using dist_smul_pair x y\u2081 y\u2082\n  dist_pair_smul' :=\n    MulOpposite.rec' fun x\u2081 =>\n      MulOpposite.rec' fun x\u2082 y => by simpa only [op_smul_eq_smul] using dist_pair_smul x\u2081 x\u2082 y", "start": [183, 1], "end": [189, 96], "kind": "commanddeclaration"}, {"full_name": "Pi.instBoundedSMul", "code": "instance Pi.instBoundedSMul {\u03b1 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [PseudoMetricSpace \u03b1]\n    [\u2200 i, PseudoMetricSpace (\u03b2 i)] [Zero \u03b1] [\u2200 i, Zero (\u03b2 i)] [\u2200 i, SMul \u03b1 (\u03b2 i)]\n    [\u2200 i, BoundedSMul \u03b1 (\u03b2 i)] : BoundedSMul \u03b1 (\u2200 i, \u03b2 i) where\n  dist_smul_pair' x y\u2081 y\u2082 :=\n    (dist_pi_le_iff <| by positivity).2 fun i \u21a6\n      (dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (dist_le_pi_dist _ _ _) dist_nonneg\n  dist_pair_smul' x\u2081 x\u2082 y :=\n    (dist_pi_le_iff <| by positivity).2 fun i \u21a6\n      (dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (dist_le_pi_dist _ 0 _) dist_nonneg", "start": [206, 1], "end": [214, 100], "kind": "commanddeclaration"}, {"full_name": "Pi.instBoundedSMul'", "code": "instance Pi.instBoundedSMul' {\u03b1 \u03b2 : \u03b9 \u2192 Type*} [\u2200 i, PseudoMetricSpace (\u03b1 i)]\n    [\u2200 i, PseudoMetricSpace (\u03b2 i)] [\u2200 i, Zero (\u03b1 i)] [\u2200 i, Zero (\u03b2 i)] [\u2200 i, SMul (\u03b1 i) (\u03b2 i)]\n    [\u2200 i, BoundedSMul (\u03b1 i) (\u03b2 i)] : BoundedSMul (\u2200 i, \u03b1 i) (\u2200 i, \u03b2 i) where\n  dist_smul_pair' x y\u2081 y\u2082 :=\n    (dist_pi_le_iff <| by positivity).2 fun i \u21a6\n      (dist_smul_pair _ _ _).trans <|\n        mul_le_mul (dist_le_pi_dist _ 0 _) (dist_le_pi_dist _ _ _) dist_nonneg dist_nonneg\n  dist_pair_smul' x\u2081 x\u2082 y :=\n    (dist_pi_le_iff <| by positivity).2 fun i \u21a6\n      (dist_pair_smul _ _ _).trans <|\n        mul_le_mul (dist_le_pi_dist _ _ _) (dist_le_pi_dist _ 0 _) dist_nonneg dist_nonneg", "start": [216, 1], "end": [226, 91], "kind": "commanddeclaration"}, {"full_name": "Prod.instBoundedSMul", "code": "instance Prod.instBoundedSMul {\u03b1 \u03b2 \u03b3 : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    [PseudoMetricSpace \u03b3] [Zero \u03b1] [Zero \u03b2] [Zero \u03b3] [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [BoundedSMul \u03b1 \u03b2]\n    [BoundedSMul \u03b1 \u03b3] : BoundedSMul \u03b1 (\u03b2 \u00d7 \u03b3) where\n  dist_smul_pair' _x _y\u2081 _y\u2082 :=\n    max_le ((dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_left _ _) dist_nonneg)\n      ((dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_right _ _) dist_nonneg)\n  dist_pair_smul' _x\u2081 _x\u2082 _y :=\n    max_le ((dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_left _ _) dist_nonneg)\n      ((dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_right _ _) dist_nonneg)", "start": [228, 1], "end": [236, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Rat.lean", "imports": ["Mathlib/Topology/Instances/Real.lean", "Mathlib/Topology/Algebra/Order/Archimedean.lean", "Mathlib/Topology/Instances/Int.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Instances/Nat.lean"], "premises": [{"full_name": "Rat.dist_eq", "code": "theorem dist_eq (x y : \u211a) : dist x y = |(x : \u211d) - y|", "start": [28, 1], "end": [28, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.dist_cast", "code": "@[norm_cast, simp]\ntheorem dist_cast (x y : \u211a) : dist (x : \u211d) y = dist x y", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.uniformContinuous_coe_real", "code": "theorem uniformContinuous_coe_real : UniformContinuous ((\u2191) : \u211a \u2192 \u211d)", "start": [36, 1], "end": [37, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.uniformEmbedding_coe_real", "code": "theorem uniformEmbedding_coe_real : UniformEmbedding ((\u2191) : \u211a \u2192 \u211d)", "start": [40, 1], "end": [41, 44], "kind": "commanddeclaration"}, {"full_name": "Rat.denseEmbedding_coe_real", "code": "theorem denseEmbedding_coe_real : DenseEmbedding ((\u2191) : \u211a \u2192 \u211d)", "start": [44, 1], "end": [45, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.embedding_coe_real", "code": "theorem embedding_coe_real : Embedding ((\u2191) : \u211a \u2192 \u211d)", "start": [48, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "Rat.continuous_coe_real", "code": "theorem continuous_coe_real : Continuous ((\u2191) : \u211a \u2192 \u211d)", "start": [52, 1], "end": [53, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_cast_rat", "code": "@[norm_cast, simp]\ntheorem Nat.dist_cast_rat (x y : \u2115) : dist (x : \u211a) y = dist x y", "start": [58, 1], "end": [60, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.uniformEmbedding_coe_rat", "code": "theorem Nat.uniformEmbedding_coe_rat : UniformEmbedding ((\u2191) : \u2115 \u2192 \u211a)", "start": [63, 1], "end": [64, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.closedEmbedding_coe_rat", "code": "theorem Nat.closedEmbedding_coe_rat : ClosedEmbedding ((\u2191) : \u2115 \u2192 \u211a)", "start": [67, 1], "end": [68, 93], "kind": "commanddeclaration"}, {"full_name": "Int.dist_cast_rat", "code": "@[norm_cast, simp]\ntheorem Int.dist_cast_rat (x y : \u2124) : dist (x : \u211a) y = dist x y", "start": [71, 1], "end": [73, 52], "kind": "commanddeclaration"}, {"full_name": "Int.uniformEmbedding_coe_rat", "code": "theorem Int.uniformEmbedding_coe_rat : UniformEmbedding ((\u2191) : \u2124 \u2192 \u211a)", "start": [76, 1], "end": [77, 98], "kind": "commanddeclaration"}, {"full_name": "Int.closedEmbedding_coe_rat", "code": "theorem Int.closedEmbedding_coe_rat : ClosedEmbedding ((\u2191) : \u2124 \u2192 \u211a)", "start": [80, 1], "end": [81, 93], "kind": "commanddeclaration"}, {"full_name": "Rat.uniformContinuous_add", "code": "theorem uniformContinuous_add : UniformContinuous fun p : \u211a \u00d7 \u211a => p.1 + p.2", "start": [88, 1], "end": [92, 79], "kind": "commanddeclaration"}, {"full_name": "Rat.uniformContinuous_neg", "code": "theorem uniformContinuous_neg : UniformContinuous (@Neg.neg \u211a _)", "start": [95, 1], "end": [97, 98], "kind": "commanddeclaration"}, {"full_name": "Rat.uniformContinuous_abs", "code": "theorem uniformContinuous_abs : UniformContinuous (abs : \u211a \u2192 \u211a)", "start": [107, 1], "end": [110, 86], "kind": "commanddeclaration"}, {"full_name": "Rat.continuous_mul", "code": "@[deprecated continuous_mul]\nprotected theorem continuous_mul : Continuous fun p : \u211a \u00d7 \u211a => p.1 * p.2", "start": [115, 1], "end": [116, 91], "kind": "commanddeclaration"}, {"full_name": "Rat.totallyBounded_Icc", "code": "nonrec theorem totallyBounded_Icc (a b : \u211a) : TotallyBounded (Icc a b)", "start": [119, 1], "end": [121, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sequences.lean", "imports": ["Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "seqClosure", "code": "def seqClosure (s : Set X) : Set X :=\n  { a | \u2203 x : \u2115 \u2192 X, (\u2200 n : \u2115, x n \u2208 s) \u2227 Tendsto x atTop (\ud835\udcdd a) }", "start": [74, 1], "end": [78, 66], "kind": "commanddeclaration"}, {"full_name": "subset_seqClosure", "code": "theorem subset_seqClosure {s : Set X} : s \u2286 seqClosure s", "start": [81, 1], "end": [82, 47], "kind": "commanddeclaration"}, {"full_name": "seqClosure_subset_closure", "code": "theorem seqClosure_subset_closure {s : Set X} : seqClosure s \u2286 closure s", "start": [85, 1], "end": [88, 43], "kind": "commanddeclaration"}, {"full_name": "IsSeqClosed", "code": "def IsSeqClosed (s : Set X) : Prop :=\n  \u2200 \u2983x : \u2115 \u2192 X\u2984 \u2983p : X\u2984, (\u2200 n, x n \u2208 s) \u2192 Tendsto x atTop (\ud835\udcdd p) \u2192 p \u2208 s", "start": [91, 1], "end": [95, 72], "kind": "commanddeclaration"}, {"full_name": "IsSeqClosed.seqClosure_eq", "code": "theorem IsSeqClosed.seqClosure_eq {s : Set X} (hs : IsSeqClosed s) : seqClosure s = s", "start": [98, 1], "end": [100, 70], "kind": "commanddeclaration"}, {"full_name": "isSeqClosed_of_seqClosure_eq", "code": "theorem isSeqClosed_of_seqClosure_eq {s : Set X} (hs : seqClosure s = s) : IsSeqClosed s", "start": [103, 1], "end": [105, 41], "kind": "commanddeclaration"}, {"full_name": "isSeqClosed_iff", "code": "theorem isSeqClosed_iff {s : Set X} : IsSeqClosed s \u2194 seqClosure s = s", "start": [108, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isSeqClosed", "code": "protected theorem IsClosed.isSeqClosed {s : Set X} (hc : IsClosed s) : IsSeqClosed s", "start": [113, 1], "end": [115, 68], "kind": "commanddeclaration"}, {"full_name": "FrechetUrysohnSpace", "code": "class FrechetUrysohnSpace (X : Type*) [TopologicalSpace X] : Prop where\n  closure_subset_seqClosure : \u2200 s : Set X, closure s \u2286 seqClosure s", "start": [118, 1], "end": [122, 68], "kind": "commanddeclaration"}, {"full_name": "seqClosure_eq_closure", "code": "theorem seqClosure_eq_closure [FrechetUrysohnSpace X] (s : Set X) : seqClosure s = closure s", "start": [125, 1], "end": [126, 88], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_seq_limit", "code": "theorem mem_closure_iff_seq_limit [FrechetUrysohnSpace X] {s : Set X} {a : X} :\n    a \u2208 closure s \u2194 \u2203 x : \u2115 \u2192 X, (\u2200 n : \u2115, x n \u2208 s) \u2227 Tendsto x atTop (\ud835\udcdd a)", "start": [129, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_iff_seq_tendsto", "code": "theorem tendsto_nhds_iff_seq_tendsto [FrechetUrysohnSpace X] {f : X \u2192 Y} {a : X} {b : Y} :\n    Tendsto f (\ud835\udcdd a) (\ud835\udcdd b) \u2194 \u2200 u : \u2115 \u2192 X, Tendsto u atTop (\ud835\udcdd a) \u2192 Tendsto (f \u2218 u) atTop (\ud835\udcdd b)", "start": [137, 1], "end": [152, 63], "kind": "commanddeclaration"}, {"full_name": "FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto", "code": "theorem FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto\n    (h : \u2200 (f : X \u2192 Prop) (a : X),\n      (\u2200 u : \u2115 \u2192 X, Tendsto u atTop (\ud835\udcdd a) \u2192 Tendsto (f \u2218 u) atTop (\ud835\udcdd (f a))) \u2192 ContinuousAt f a) :\n    FrechetUrysohnSpace X", "start": [155, 1], "end": [168, 53], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.FirstCountableTopology.frechetUrysohnSpace", "code": "instance (priority := 100) TopologicalSpace.FirstCountableTopology.frechetUrysohnSpace\n    [FirstCountableTopology X] : FrechetUrysohnSpace X :=\n  FrechetUrysohnSpace.of_seq_tendsto_imp_tendsto fun _ _ => tendsto_iff_seq_tendsto.2", "start": [172, 1], "end": [175, 86], "kind": "commanddeclaration"}, {"full_name": "SequentialSpace", "code": "class SequentialSpace (X : Type*) [TopologicalSpace X] : Prop where\n  isClosed_of_seq : \u2200 s : Set X, IsSeqClosed s \u2192 IsClosed s", "start": [178, 1], "end": [181, 60], "kind": "commanddeclaration"}, {"full_name": "FrechetUrysohnSpace.to_sequentialSpace", "code": "instance (priority := 100) FrechetUrysohnSpace.to_sequentialSpace [FrechetUrysohnSpace X] :\n    SequentialSpace X :=\n  \u27e8fun s hs => by rw [\u2190 closure_eq_iff_isClosed, \u2190 seqClosure_eq_closure, hs.seqClosure_eq]\u27e9", "start": [185, 1], "end": [188, 93], "kind": "commanddeclaration"}, {"full_name": "IsSeqClosed.isClosed", "code": "protected theorem IsSeqClosed.isClosed [SequentialSpace X] {s : Set X} (hs : IsSeqClosed s) :\n    IsClosed s", "start": [191, 1], "end": [194, 39], "kind": "commanddeclaration"}, {"full_name": "isSeqClosed_iff_isClosed", "code": "theorem isSeqClosed_iff_isClosed [SequentialSpace X] {M : Set X} : IsSeqClosed M \u2194 IsClosed M", "start": [197, 1], "end": [199, 47], "kind": "commanddeclaration"}, {"full_name": "SeqContinuous", "code": "def SeqContinuous (f : X \u2192 Y) : Prop :=\n  \u2200 \u2983x : \u2115 \u2192 X\u2984 \u2983p : X\u2984, Tendsto x atTop (\ud835\udcdd p) \u2192 Tendsto (f \u2218 x) atTop (\ud835\udcdd (f p))", "start": [202, 1], "end": [205, 81], "kind": "commanddeclaration"}, {"full_name": "IsSeqClosed.preimage", "code": "theorem IsSeqClosed.preimage {f : X \u2192 Y} {s : Set Y} (hs : IsSeqClosed s) (hf : SeqContinuous f) :\n    IsSeqClosed (f \u207b\u00b9' s)", "start": [208, 1], "end": [211, 62], "kind": "commanddeclaration"}, {"full_name": "Continuous.seqContinuous", "code": "protected theorem Continuous.seqContinuous {f : X \u2192 Y} (hf : Continuous f) : SeqContinuous f", "start": [215, 1], "end": [216, 40], "kind": "commanddeclaration"}, {"full_name": "SeqContinuous.continuous", "code": "protected theorem SeqContinuous.continuous [SequentialSpace X] {f : X \u2192 Y} (hf : SeqContinuous f) :\n    Continuous f", "start": [219, 1], "end": [222, 81], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_seqContinuous", "code": "theorem continuous_iff_seqContinuous [SequentialSpace X] {f : X \u2192 Y} :\n    Continuous f \u2194 SeqContinuous f", "start": [225, 1], "end": [229, 55], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.sequentialSpace", "code": "theorem QuotientMap.sequentialSpace [SequentialSpace X] {f : X \u2192 Y} (hf : QuotientMap f) :\n    SequentialSpace Y", "start": [232, 1], "end": [234, 98], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact", "code": "def IsSeqCompact (s : Set X) :=\n  \u2200 \u2983x : \u2115 \u2192 X\u2984, (\u2200 n, x n \u2208 s) \u2192 \u2203 a \u2208 s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [249, 1], "end": [252, 99], "kind": "commanddeclaration"}, {"full_name": "SeqCompactSpace", "code": "@[mk_iff seqCompactSpace_iff]\nclass SeqCompactSpace (X : Type*) [TopologicalSpace X] : Prop where\n  seq_compact_univ : IsSeqCompact (univ : Set X)", "start": [255, 1], "end": [259, 49], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.subseq_of_frequently_in", "code": "theorem IsSeqCompact.subseq_of_frequently_in {s : Set X} (hs : IsSeqCompact s) {x : \u2115 \u2192 X}\n    (hx : \u2203\u1da0 n in atTop, x n \u2208 s) :\n    \u2203 a \u2208 s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [265, 1], "end": [270, 34], "kind": "commanddeclaration"}, {"full_name": "SeqCompactSpace.tendsto_subseq", "code": "theorem SeqCompactSpace.tendsto_subseq [SeqCompactSpace X] (x : \u2115 \u2192 X) :\n    \u2203 (a : X) (\u03c6 : \u2115 \u2192 \u2115), StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [273, 1], "end": [276, 18], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isSeqCompact", "code": "protected theorem IsCompact.isSeqCompact {s : Set X} (hs : IsCompact s) : IsSeqCompact s", "start": [285, 1], "end": [288, 31], "kind": "commanddeclaration"}, {"full_name": "IsCompact.tendsto_subseq'", "code": "theorem IsCompact.tendsto_subseq' {s : Set X} {x : \u2115 \u2192 X} (hs : IsCompact s)\n    (hx : \u2203\u1da0 n in atTop, x n \u2208 s) :\n    \u2203 a \u2208 s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [291, 1], "end": [294, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompact.tendsto_subseq", "code": "theorem IsCompact.tendsto_subseq {s : Set X} {x : \u2115 \u2192 X} (hs : IsCompact s) (hx : \u2200 n, x n \u2208 s) :\n    \u2203 a \u2208 s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [297, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "FirstCountableTopology.seq_compact_of_compact", "code": "instance (priority := 100) FirstCountableTopology.seq_compact_of_compact [CompactSpace X] :\n    SeqCompactSpace X :=\n  \u27e8isCompact_univ.isSeqCompact\u27e9", "start": [303, 1], "end": [305, 32], "kind": "commanddeclaration"}, {"full_name": "CompactSpace.tendsto_subseq", "code": "theorem CompactSpace.tendsto_subseq [CompactSpace X] (x : \u2115 \u2192 X) :\n    \u2203 (a : _) (\u03c6 : \u2115 \u2192 \u2115), StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [308, 1], "end": [310, 35], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.exists_tendsto_of_frequently_mem", "code": "theorem IsSeqCompact.exists_tendsto_of_frequently_mem (hs : IsSeqCompact s) {u : \u2115 \u2192 X}\n    (hu : \u2203\u1da0 n in atTop, u n \u2208 s) (huc : CauchySeq u) : \u2203 x \u2208 s, Tendsto u atTop (\ud835\udcdd x)", "start": [325, 1], "end": [328, 76], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.exists_tendsto", "code": "theorem IsSeqCompact.exists_tendsto (hs : IsSeqCompact s) {u : \u2115 \u2192 X} (hu : \u2200 n, u n \u2208 s)\n    (huc : CauchySeq u) : \u2203 x \u2208 s, Tendsto u atTop (\ud835\udcdd x)", "start": [331, 1], "end": [333, 68], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.totallyBounded", "code": "protected theorem IsSeqCompact.totallyBounded (h : IsSeqCompact s) : TotallyBounded s", "start": [336, 1], "end": [347, 83], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.isComplete", "code": "protected theorem IsSeqCompact.isComplete (hs : IsSeqCompact s) : IsComplete s", "start": [352, 1], "end": [381, 45], "kind": "commanddeclaration"}, {"full_name": "IsSeqCompact.isCompact", "code": "protected theorem IsSeqCompact.isCompact (hs : IsSeqCompact s) : IsCompact s", "start": [384, 1], "end": [386, 79], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.isCompact_iff_isSeqCompact", "code": "protected theorem UniformSpace.isCompact_iff_isSeqCompact : IsCompact s \u2194 IsSeqCompact s", "start": [389, 1], "end": [392, 50], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.compactSpace_iff_seqCompactSpace", "code": "theorem UniformSpace.compactSpace_iff_seqCompactSpace : CompactSpace X \u2194 SeqCompactSpace X", "start": [395, 1], "end": [396, 97], "kind": "commanddeclaration"}, {"full_name": "SeqCompact.lebesgue_number_lemma_of_metric", "code": "nonrec theorem SeqCompact.lebesgue_number_lemma_of_metric {\u03b9 : Sort*} {c : \u03b9 \u2192 Set X} {s : Set X}\n    (hs : IsSeqCompact s) (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i, c i) :\n    \u2203 \u03b4 > 0, \u2200 a \u2208 s, \u2203 i, ball a \u03b4 \u2286 c i", "start": [407, 1], "end": [410, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_subseq_of_frequently_bounded", "code": "theorem tendsto_subseq_of_frequently_bounded (hs : IsBounded s) {x : \u2115 \u2192 X}\n    (hx : \u2203\u1da0 n in atTop, x n \u2208 s) :\n    \u2203 a \u2208 closure s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [415, 1], "end": [423, 34], "kind": "commanddeclaration"}, {"full_name": "tendsto_subseq_of_bounded", "code": "theorem tendsto_subseq_of_bounded (hs : IsBounded s) {x : \u2115 \u2192 X} (hx : \u2200 n, x n \u2208 s) :\n    \u2203 a \u2208 closure s, \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 Tendsto (x \u2218 \u03c6) atTop (\ud835\udcdd a)", "start": [426, 1], "end": [430, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "imports": ["Mathlib/Topology/MetricSpace/Isometry.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsometricVAdd", "code": "class IsometricVAdd [PseudoEMetricSpace X] [VAdd M X] : Prop where\n  protected isometry_vadd : \u2200 c : M, Isometry ((c +\u1d65 \u00b7) : X \u2192 X)", "start": [39, 1], "end": [41, 65], "kind": "commanddeclaration"}, {"full_name": "IsometricSMul", "code": "@[to_additive]\nclass IsometricSMul [PseudoEMetricSpace X] [SMul M X] : Prop where\n  protected isometry_smul : \u2200 c : M, Isometry ((c \u2022 \u00b7) : X \u2192 X)", "start": [44, 1], "end": [47, 64], "kind": "commanddeclaration"}, {"full_name": "isometry_smul", "code": "@[to_additive]\ntheorem isometry_smul {M : Type u} (X : Type w) [PseudoEMetricSpace X] [SMul M X]\n    [IsometricSMul M X] (c : M) : Isometry (c \u2022 \u00b7 : X \u2192 X)", "start": [51, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "IsometricSMul.to_continuousConstSMul", "code": "@[to_additive]\ninstance (priority := 100) IsometricSMul.to_continuousConstSMul [PseudoEMetricSpace X] [SMul M X]\n    [IsometricSMul M X] : ContinuousConstSMul M X :=\n  \u27e8fun c => (isometry_smul X c).continuous\u27e9", "start": [56, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "IsometricSMul.opposite_of_comm", "code": "@[to_additive]\ninstance (priority := 100) IsometricSMul.opposite_of_comm [PseudoEMetricSpace X] [SMul M X]\n    [SMul M\u1d50\u1d52\u1d56 X] [IsCentralScalar M X] [IsometricSMul M X] : IsometricSMul M\u1d50\u1d52\u1d56 X :=\n  \u27e8fun c x y => by simpa only [\u2190 op_smul_eq_smul] using isometry_smul X c.unop x y\u27e9", "start": [63, 1], "end": [66, 84], "kind": "commanddeclaration"}, {"full_name": "edist_smul_left", "code": "@[to_additive (attr := simp)]\ntheorem edist_smul_left [SMul M X] [IsometricSMul M X] (c : M) (x y : X) :\n    edist (c \u2022 x) (c \u2022 y) = edist x y", "start": [76, 1], "end": [79, 24], "kind": "commanddeclaration"}, {"full_name": "ediam_smul", "code": "@[to_additive (attr := simp)]\ntheorem ediam_smul [SMul M X] [IsometricSMul M X] (c : M) (s : Set X) :\n    EMetric.diam (c \u2022 s) = EMetric.diam s", "start": [83, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "isometry_mul_left", "code": "@[to_additive]\ntheorem isometry_mul_left [Mul M] [PseudoEMetricSpace M] [IsometricSMul M M] (a : M) :\n    Isometry ((\u00b7 * \u00b7) a)", "start": [90, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "edist_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem edist_mul_left [Mul M] [PseudoEMetricSpace M] [IsometricSMul M M] (a b c : M) :\n    edist (a * b) (a * c) = edist b c", "start": [97, 1], "end": [100, 26], "kind": "commanddeclaration"}, {"full_name": "isometry_mul_right", "code": "@[to_additive]\ntheorem isometry_mul_right [Mul M] [PseudoEMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M] (a : M) :\n    Isometry fun x => x * a", "start": [104, 1], "end": [107, 37], "kind": "commanddeclaration"}, {"full_name": "edist_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem edist_mul_right [Mul M] [PseudoEMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M] (a b c : M) :\n    edist (a * c) (b * c) = edist a b", "start": [111, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "edist_div_right", "code": "@[to_additive (attr := simp)]\ntheorem edist_div_right [DivInvMonoid M] [PseudoEMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M]\n    (a b c : M) : edist (a / c) (b / c) = edist a b", "start": [118, 1], "end": [121, 46], "kind": "commanddeclaration"}, {"full_name": "edist_inv_inv", "code": "@[to_additive (attr := simp)]\ntheorem edist_inv_inv [PseudoEMetricSpace G] [IsometricSMul G G] [IsometricSMul G\u1d50\u1d52\u1d56 G]\n    (a b : G) : edist a\u207b\u00b9 b\u207b\u00b9 = edist a b", "start": [125, 1], "end": [129, 16], "kind": "commanddeclaration"}, {"full_name": "isometry_inv", "code": "@[to_additive]\ntheorem isometry_inv [PseudoEMetricSpace G] [IsometricSMul G G] [IsometricSMul G\u1d50\u1d52\u1d56 G] :\n    Isometry (Inv.inv : G \u2192 G)", "start": [133, 1], "end": [136, 16], "kind": "commanddeclaration"}, {"full_name": "edist_inv", "code": "@[to_additive]\ntheorem edist_inv [PseudoEMetricSpace G] [IsometricSMul G G] [IsometricSMul G\u1d50\u1d52\u1d56 G]\n    (x y : G) : edist x\u207b\u00b9 y = edist x y\u207b\u00b9", "start": [140, 1], "end": [142, 78], "kind": "commanddeclaration"}, {"full_name": "edist_div_left", "code": "@[to_additive (attr := simp)]\ntheorem edist_div_left [PseudoEMetricSpace G] [IsometricSMul G G] [IsometricSMul G\u1d50\u1d52\u1d56 G]\n    (a b c : G) : edist (a / b) (a / c) = edist b c", "start": [146, 1], "end": [149, 69], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.constSMul", "code": "@[to_additive (attr := simps! toEquiv apply) \"If an additive group `G` acts on `X` by isometries,\nthen `IsometryEquiv.constVAdd` is the isometry of `X` given by addition of a constant element of the\ngroup.\"]\ndef constSMul (c : G) : X \u2243\u1d62 X where\n  toEquiv := MulAction.toPerm c\n  isometry_toFun := isometry_smul X c", "start": [155, 1], "end": [162, 38], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.constSMul_symm", "code": "@[to_additive (attr := simp)]\ntheorem constSMul_symm (c : G) : (constSMul c : X \u2243\u1d62 X).symm = constSMul c\u207b\u00b9", "start": [170, 1], "end": [172, 19], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mulLeft", "code": "@[to_additive (attr := simps! apply toEquiv) \"Addition `y \u21a6 x + y` as an `IsometryEquiv`.\"]\ndef mulLeft [IsometricSMul G G] (c : G) : G \u2243\u1d62 G where\n  toEquiv := Equiv.mulLeft c\n  isometry_toFun := edist_mul_left c", "start": [178, 1], "end": [182, 37], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mulLeft_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulLeft_symm [IsometricSMul G G] (x : G) :\n    (mulLeft x).symm = IsometryEquiv.mulLeft x\u207b\u00b9", "start": [190, 1], "end": [193, 19], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mulRight", "code": "@[to_additive (attr := simps! apply toEquiv) \"Addition `y \u21a6 y + x` as an `IsometryEquiv`.\"]\ndef mulRight [IsometricSMul G\u1d50\u1d52\u1d56 G] (c : G) : G \u2243\u1d62 G where\n  toEquiv := Equiv.mulRight c\n  isometry_toFun a b := edist_mul_right a b c", "start": [197, 1], "end": [201, 46], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.mulRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulRight_symm [IsometricSMul G\u1d50\u1d52\u1d56 G] (x : G) : (mulRight x).symm = mulRight x\u207b\u00b9", "start": [209, 1], "end": [211, 19], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.divRight", "code": "@[to_additive (attr := simps! apply toEquiv) \"Subtraction `y \u21a6 y - x` as an `IsometryEquiv`.\"]\ndef divRight [IsometricSMul G\u1d50\u1d52\u1d56 G] (c : G) : G \u2243\u1d62 G where\n  toEquiv := Equiv.divRight c\n  isometry_toFun a b := edist_div_right a b c", "start": [215, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.divRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem divRight_symm [IsometricSMul G\u1d50\u1d52\u1d56 G] (c : G) : (divRight c).symm = mulRight c", "start": [227, 1], "end": [229, 19], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.divLeft", "code": "@[to_additive (attr := simps! apply symm_apply toEquiv)\n  \"Subtraction `y \u21a6 x - y` as an `IsometryEquiv`.\"]\ndef divLeft (c : G) : G \u2243\u1d62 G where\n  toEquiv := Equiv.divLeft c\n  isometry_toFun := edist_div_left c", "start": [235, 1], "end": [240, 37], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.inv", "code": "@[to_additive (attr := simps! apply toEquiv) \"Negation `x \u21a6 -x` as an `IsometryEquiv`.\"]\ndef inv : G \u2243\u1d62 G where\n  toEquiv := Equiv.inv G\n  isometry_toFun := edist_inv_inv", "start": [252, 1], "end": [256, 34], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.inv_symm", "code": "@[to_additive (attr := simp)] theorem inv_symm : (inv G).symm = inv G", "start": [264, 1], "end": [264, 77], "kind": "commanddeclaration"}, {"full_name": "EMetric.smul_ball", "code": "@[to_additive (attr := simp)]\ntheorem smul_ball (c : G) (x : X) (r : \u211d\u22650\u221e) : c \u2022 ball x r = ball (c \u2022 x) r", "start": [272, 1], "end": [274, 53], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_smul_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_smul_ball (c : G) (x : X) (r : \u211d\u22650\u221e) : (\u00b7 \u2022 \u00b7) c \u207b\u00b9' ball x r = ball (c\u207b\u00b9 \u2022 x) r", "start": [278, 1], "end": [280, 35], "kind": "commanddeclaration"}, {"full_name": "EMetric.smul_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem smul_closedBall (c : G) (x : X) (r : \u211d\u22650\u221e) : c \u2022 closedBall x r = closedBall (c \u2022 x) r", "start": [284, 1], "end": [286, 59], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_smul_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_smul_closedBall (c : G) (x : X) (r : \u211d\u22650\u221e) :\n    (\u00b7 \u2022 \u00b7) c \u207b\u00b9' closedBall x r = closedBall (c\u207b\u00b9 \u2022 x) r", "start": [290, 1], "end": [293, 38], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_mul_left_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_ball [IsometricSMul G G] (a b : G) (r : \u211d\u22650\u221e) :\n    (\u00b7 * \u00b7) a \u207b\u00b9' ball b r = ball (a\u207b\u00b9 * b) r", "start": [299, 1], "end": [302, 27], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_mul_right_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_ball [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) (r : \u211d\u22650\u221e) :\n    (fun x => x * a) \u207b\u00b9' ball b r = ball (b / a) r", "start": [306, 1], "end": [310, 50], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_mul_left_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_closedBall [IsometricSMul G G] (a b : G) (r : \u211d\u22650\u221e) :\n    (\u00b7 * \u00b7) a \u207b\u00b9' closedBall b r = closedBall (a\u207b\u00b9 * b) r", "start": [314, 1], "end": [317, 33], "kind": "commanddeclaration"}, {"full_name": "EMetric.preimage_mul_right_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_closedBall [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) (r : \u211d\u22650\u221e) :\n    (fun x => x * a) \u207b\u00b9' closedBall b r = closedBall (b / a) r", "start": [321, 1], "end": [325, 56], "kind": "commanddeclaration"}, {"full_name": "dist_smul", "code": "@[to_additive (attr := simp)]\ntheorem dist_smul [PseudoMetricSpace X] [SMul M X] [IsometricSMul M X] (c : M) (x y : X) :\n    dist (c \u2022 x) (c \u2022 y) = dist x y", "start": [333, 1], "end": [336, 34], "kind": "commanddeclaration"}, {"full_name": "nndist_smul", "code": "@[to_additive (attr := simp)]\ntheorem nndist_smul [PseudoMetricSpace X] [SMul M X] [IsometricSMul M X] (c : M) (x y : X) :\n    nndist (c \u2022 x) (c \u2022 y) = nndist x y", "start": [340, 1], "end": [343, 36], "kind": "commanddeclaration"}, {"full_name": "diam_smul", "code": "@[to_additive (attr := simp)]\ntheorem diam_smul [PseudoMetricSpace X] [SMul M X] [IsometricSMul M X] (c : M) (s : Set X) :\n    Metric.diam (c \u2022 s) = Metric.diam s", "start": [347, 1], "end": [350, 35], "kind": "commanddeclaration"}, {"full_name": "dist_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_mul_left [PseudoMetricSpace M] [Mul M] [IsometricSMul M M] (a b c : M) :\n    dist (a * b) (a * c) = dist b c", "start": [354, 1], "end": [357, 18], "kind": "commanddeclaration"}, {"full_name": "nndist_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem nndist_mul_left [PseudoMetricSpace M] [Mul M] [IsometricSMul M M] (a b c : M) :\n    nndist (a * b) (a * c) = nndist b c", "start": [361, 1], "end": [364, 20], "kind": "commanddeclaration"}, {"full_name": "dist_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_mul_right [Mul M] [PseudoMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M] (a b c : M) :\n    dist (a * c) (b * c) = dist a b", "start": [368, 1], "end": [371, 35], "kind": "commanddeclaration"}, {"full_name": "nndist_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem nndist_mul_right [PseudoMetricSpace M] [Mul M] [IsometricSMul M\u1d50\u1d52\u1d56 M] (a b c : M) :\n    nndist (a * c) (b * c) = nndist a b", "start": [375, 1], "end": [378, 37], "kind": "commanddeclaration"}, {"full_name": "dist_div_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M]\n    (a b c : M) : dist (a / c) (b / c) = dist a b", "start": [382, 1], "end": [384, 99], "kind": "commanddeclaration"}, {"full_name": "nndist_div_right", "code": "@[to_additive (attr := simp)]\ntheorem nndist_div_right [DivInvMonoid M] [PseudoMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M]\n    (a b c : M) : nndist (a / c) (b / c) = nndist a b", "start": [388, 1], "end": [391, 47], "kind": "commanddeclaration"}, {"full_name": "dist_inv_inv", "code": "@[to_additive (attr := simp)]\ntheorem dist_inv_inv [Group G] [PseudoMetricSpace G] [IsometricSMul G G]\n    [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) : dist a\u207b\u00b9 b\u207b\u00b9 = dist a b", "start": [395, 1], "end": [398, 36], "kind": "commanddeclaration"}, {"full_name": "nndist_inv_inv", "code": "@[to_additive (attr := simp)]\ntheorem nndist_inv_inv [Group G] [PseudoMetricSpace G] [IsometricSMul G G]\n    [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) : nndist a\u207b\u00b9 b\u207b\u00b9 = nndist a b", "start": [402, 1], "end": [405, 38], "kind": "commanddeclaration"}, {"full_name": "dist_div_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_div_left [Group G] [PseudoMetricSpace G] [IsometricSMul G G]\n    [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b c : G) : dist (a / b) (a / c) = dist b c", "start": [409, 1], "end": [412, 24], "kind": "commanddeclaration"}, {"full_name": "nndist_div_left", "code": "@[to_additive (attr := simp)]\ntheorem nndist_div_left [Group G] [PseudoMetricSpace G] [IsometricSMul G G]\n    [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b c : G) : nndist (a / b) (a / c) = nndist b c", "start": [416, 1], "end": [419, 24], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.smul", "code": "@[to_additive \"Given an additive isometric action of `G` on `X`, the image of a bounded set in `X`\nunder translation by `c : G` is bounded\"]\ntheorem Bornology.IsBounded.smul [PseudoMetricSpace X] [SMul G X] [IsometricSMul G X] {s : Set X}\n    (hs : IsBounded s) (c : G) : IsBounded (c \u2022 s)", "start": [423, 1], "end": [430, 51], "kind": "commanddeclaration"}, {"full_name": "Metric.smul_ball", "code": "@[to_additive (attr := simp)]\ntheorem smul_ball (c : G) (x : X) (r : \u211d) : c \u2022 ball x r = ball (c \u2022 x) r", "start": [436, 1], "end": [438, 45], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_smul_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_smul_ball (c : G) (x : X) (r : \u211d) : (\u00b7 \u2022 \u00b7) c \u207b\u00b9' ball x r = ball (c\u207b\u00b9 \u2022 x) r", "start": [442, 1], "end": [444, 32], "kind": "commanddeclaration"}, {"full_name": "Metric.smul_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem smul_closedBall (c : G) (x : X) (r : \u211d) : c \u2022 closedBall x r = closedBall (c \u2022 x) r", "start": [448, 1], "end": [450, 51], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_smul_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_smul_closedBall (c : G) (x : X) (r : \u211d) :\n    (\u00b7 \u2022 \u00b7) c \u207b\u00b9' closedBall x r = closedBall (c\u207b\u00b9 \u2022 x) r", "start": [454, 1], "end": [456, 100], "kind": "commanddeclaration"}, {"full_name": "Metric.smul_sphere", "code": "@[to_additive (attr := simp)]\ntheorem smul_sphere (c : G) (x : X) (r : \u211d) : c \u2022 sphere x r = sphere (c \u2022 x) r", "start": [460, 1], "end": [462, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_smul_sphere", "code": "@[to_additive (attr := simp)]\ntheorem preimage_smul_sphere (c : G) (x : X) (r : \u211d) :\n    (\u00b7 \u2022 \u00b7) c \u207b\u00b9' sphere x r = sphere (c\u207b\u00b9 \u2022 x) r", "start": [466, 1], "end": [468, 88], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_mul_left_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_ball [IsometricSMul G G] (a b : G) (r : \u211d) :\n    (\u00b7 * \u00b7) a \u207b\u00b9' ball b r = ball (a\u207b\u00b9 * b) r", "start": [474, 1], "end": [477, 27], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_mul_right_ball", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_ball [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) (r : \u211d) :\n    (fun x => x * a) \u207b\u00b9' ball b r = ball (b / a) r", "start": [481, 1], "end": [485, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_mul_left_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_closedBall [IsometricSMul G G] (a b : G) (r : \u211d) :\n    (\u00b7 * \u00b7) a \u207b\u00b9' closedBall b r = closedBall (a\u207b\u00b9 * b) r", "start": [489, 1], "end": [492, 33], "kind": "commanddeclaration"}, {"full_name": "Metric.preimage_mul_right_closedBall", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_closedBall [IsometricSMul G\u1d50\u1d52\u1d56 G] (a b : G) (r : \u211d) :\n    (fun x => x * a) \u207b\u00b9' closedBall b r = closedBall (b / a) r", "start": [496, 1], "end": [500, 56], "kind": "commanddeclaration"}, {"full_name": "Prod.isometricSMul'", "code": "@[to_additive]\ninstance Prod.isometricSMul' {N} [Mul M] [PseudoEMetricSpace M] [IsometricSMul M M] [Mul N]\n    [PseudoEMetricSpace N] [IsometricSMul N N] : IsometricSMul (M \u00d7 N) (M \u00d7 N) :=\n  \u27e8fun c => (isometry_smul M c.1).prod_map (isometry_smul N c.2)\u27e9", "start": [515, 1], "end": [518, 66], "kind": "commanddeclaration"}, {"full_name": "Prod.isometricSMul''", "code": "@[to_additive]\ninstance Prod.isometricSMul'' {N} [Mul M] [PseudoEMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M]\n    [Mul N] [PseudoEMetricSpace N] [IsometricSMul N\u1d50\u1d52\u1d56 N] :\n    IsometricSMul (M \u00d7 N)\u1d50\u1d52\u1d56 (M \u00d7 N) :=\n  \u27e8fun c => (isometry_mul_right c.unop.1).prod_map (isometry_mul_right c.unop.2)\u27e9", "start": [522, 1], "end": [526, 82], "kind": "commanddeclaration"}, {"full_name": "Units.isometricSMul", "code": "@[to_additive]\ninstance Units.isometricSMul [Monoid M] : IsometricSMul M\u02e3 X :=\n  \u27e8fun c => isometry_smul X (c : M)\u27e9", "start": [530, 1], "end": [532, 37], "kind": "commanddeclaration"}, {"full_name": "ULift.isometricSMul", "code": "@[to_additive]\ninstance ULift.isometricSMul : IsometricSMul (ULift M) X :=\n  \u27e8fun c => by simpa only using isometry_smul X c.down\u27e9", "start": [540, 1], "end": [542, 56], "kind": "commanddeclaration"}, {"full_name": "ULift.isometricSMul'", "code": "@[to_additive]\ninstance ULift.isometricSMul' : IsometricSMul M (ULift X) :=\n  \u27e8fun c x y => by simpa only using edist_smul_left c x.1 y.1\u27e9", "start": [546, 1], "end": [548, 63], "kind": "commanddeclaration"}, {"full_name": "Pi.isometricSMul'", "code": "@[to_additive]\ninstance Pi.isometricSMul' {\u03b9} {M X : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, SMul (M i) (X i)]\n    [\u2200 i, PseudoEMetricSpace (X i)] [\u2200 i, IsometricSMul (M i) (X i)] :\n    IsometricSMul (\u2200 i, M i) (\u2200 i, X i) :=\n  \u27e8fun c => isometry_dcomp (fun i => (c i \u2022 \u00b7)) fun _ => isometry_smul _ _\u27e9", "start": [557, 1], "end": [561, 76], "kind": "commanddeclaration"}, {"full_name": "Pi.isometricSMul''", "code": "@[to_additive]\ninstance Pi.isometricSMul'' {\u03b9} {M : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, Mul (M i)]\n    [\u2200 i, PseudoEMetricSpace (M i)] [\u2200 i, IsometricSMul (M i)\u1d50\u1d52\u1d56 (M i)] :\n    IsometricSMul (\u2200 i, M i)\u1d50\u1d52\u1d56 (\u2200 i, M i) :=\n  \u27e8fun c => isometry_dcomp (fun i (x : M i) => x * c.unop i) fun _ => isometry_mul_right _\u27e9", "start": [565, 1], "end": [569, 92], "kind": "commanddeclaration"}, {"full_name": "Additive.isometricVAdd", "code": "instance Additive.isometricVAdd : IsometricVAdd (Additive M) X :=\n  \u27e8fun c => isometry_smul X (toMul c)\u27e9", "start": [573, 1], "end": [574, 39], "kind": "commanddeclaration"}, {"full_name": "Additive.isometricVAdd'", "code": "instance Additive.isometricVAdd' [Mul M] [PseudoEMetricSpace M] [IsometricSMul M M] :\n    IsometricVAdd (Additive M) (Additive M) :=\n  \u27e8fun c x y => edist_smul_left (toMul c) (toMul x) (toMul y)\u27e9", "start": [577, 1], "end": [579, 63], "kind": "commanddeclaration"}, {"full_name": "Additive.isometricVAdd''", "code": "instance Additive.isometricVAdd'' [Mul M] [PseudoEMetricSpace M] [IsometricSMul M\u1d50\u1d52\u1d56 M] :\n    IsometricVAdd (Additive M)\u1d43\u1d52\u1d56 (Additive M) :=\n  \u27e8fun c x y => edist_smul_left (MulOpposite.op (toMul c.unop)) (toMul x) (toMul y)\u27e9", "start": [582, 1], "end": [584, 85], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isometricSMul", "code": "instance Multiplicative.isometricSMul {M X} [VAdd M X] [PseudoEMetricSpace X]\n    [IsometricVAdd M X] : IsometricSMul (Multiplicative M) X :=\n  \u27e8fun c => isometry_vadd X (toAdd c)\u27e9", "start": [587, 1], "end": [589, 39], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isometricSMul'", "code": "instance Multiplicative.isometricSMul' [Add M] [PseudoEMetricSpace M] [IsometricVAdd M M] :\n    IsometricSMul (Multiplicative M) (Multiplicative M) :=\n  \u27e8fun c x y => edist_vadd_left (toAdd c) (toAdd x) (toAdd y)\u27e9", "start": [592, 1], "end": [594, 63], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isometricVAdd''", "code": "instance Multiplicative.isometricVAdd'' [Add M] [PseudoEMetricSpace M]\n    [IsometricVAdd M\u1d43\u1d52\u1d56 M] : IsometricSMul (Multiplicative M)\u1d50\u1d52\u1d56 (Multiplicative M) :=\n  \u27e8fun c x y => edist_vadd_left (AddOpposite.op (toAdd c.unop)) (toAdd x) (toAdd y)\u27e9", "start": [597, 1], "end": [599, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/Seminorm.lean", "imports": ["Mathlib/Tactic/GCongr.lean", "Mathlib/Tactic/Positivity.lean", "Mathlib/Data/Real/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddGroupSeminorm", "code": "structure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  \n  protected toFun : G \u2192 \u211d\n  \n  protected map_zero' : toFun 0 = 0\n  \n  protected add_le' : \u2200 r s, toFun (r + s) \u2264 toFun r + toFun s\n  \n  protected neg' : \u2200 r, toFun (-r) = toFun r", "start": [56, 1], "end": [68, 45], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm", "code": "@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  \n  protected toFun : G \u2192 \u211d\n  \n  protected map_one' : toFun 1 = 0\n  \n  protected mul_le' : \u2200 x y, toFun (x * y) \u2264 toFun x + toFun y\n  \n  protected inv' : \u2200 x, toFun x\u207b\u00b9 = toFun x", "start": [71, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm", "code": "structure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G \u211d where\n  \n  protected add_le_max' : \u2200 r s, toFun (r + s) \u2264 max (toFun r) (toFun s)\n  \n  protected neg' : \u2200 r, toFun (-r) = toFun r", "start": [86, 1], "end": [93, 45], "kind": "commanddeclaration"}, {"full_name": "AddGroupNorm", "code": "structure AddGroupNorm (G : Type*) [AddGroup G] extends AddGroupSeminorm G where\n  \n  protected eq_zero_of_map_eq_zero' : \u2200 x, toFun x = 0 \u2192 x = 0", "start": [101, 1], "end": [105, 63], "kind": "commanddeclaration"}, {"full_name": "GroupNorm", "code": "@[to_additive]\nstructure GroupNorm (G : Type*) [Group G] extends GroupSeminorm G where\n  \n  protected eq_one_of_map_eq_zero' : \u2200 x, toFun x = 0 \u2192 x = 1", "start": [108, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm", "code": "structure NonarchAddGroupNorm (G : Type*) [AddGroup G] extends NonarchAddGroupSeminorm G where\n  \n  protected eq_zero_of_map_eq_zero' : \u2200 x, toFun x = 0 \u2192 x = 0", "start": [116, 1], "end": [120, 63], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminormClass", "code": "class NonarchAddGroupSeminormClass (F : Type*) (\u03b1 : outParam <| Type*) [AddGroup \u03b1] extends\n  NonarchimedeanHomClass F \u03b1 \u211d where\n  \n  protected map_zero (f : F) : f 0 = 0\n  \n  protected map_neg_eq_map' (f : F) (a : \u03b1) : f (-a) = f a", "start": [123, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNormClass", "code": "class NonarchAddGroupNormClass (F : Type*) (\u03b1 : outParam <| Type*) [AddGroup \u03b1] extends\n  NonarchAddGroupSeminormClass F \u03b1 where\n  \n  protected eq_zero_of_map_eq_zero (f : F) {a : \u03b1} : f a = 0 \u2192 a = 0", "start": [135, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "map_sub_le_max", "code": "theorem map_sub_le_max : f (x - y) \u2264 max (f x) (f y)", "start": [149, 1], "end": [151, 29], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminormClass.toAddGroupSeminormClass", "code": "instance (priority := 100) NonarchAddGroupSeminormClass.toAddGroupSeminormClass [AddGroup E]\n    [NonarchAddGroupSeminormClass F E] : AddGroupSeminormClass F E \u211d :=\n  { \u2039NonarchAddGroupSeminormClass F E\u203a with\n    map_add_le_add := fun f x y =>\n      haveI h_nonneg : \u2200 a, 0 \u2264 f a := by\n        intro a\n        rw [\u2190 NonarchAddGroupSeminormClass.map_zero f, \u2190 sub_self a]\n        exact le_trans (map_sub_le_max _ _ _) (by rw [max_self (f a)])\n      le_trans (map_add_le_max _ _ _)\n        (max_le (le_add_of_nonneg_right (h_nonneg _)) (le_add_of_nonneg_left (h_nonneg _)))\n    map_neg_eq_map := NonarchAddGroupSeminormClass.map_neg_eq_map' }", "start": [157, 1], "end": [167, 69], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNormClass.toAddGroupNormClass", "code": "instance (priority := 100) NonarchAddGroupNormClass.toAddGroupNormClass [AddGroup E]\n    [NonarchAddGroupNormClass F E] : AddGroupNormClass F E \u211d :=\n  { \u2039NonarchAddGroupNormClass F E\u203a with\n    map_add_le_add := map_add_le_add\n    map_neg_eq_map := NonarchAddGroupSeminormClass.map_neg_eq_map' }", "start": [171, 1], "end": [175, 69], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.groupSeminormClass", "code": "@[to_additive]\ninstance groupSeminormClass : GroupSeminormClass (GroupSeminorm E) E \u211d\n    where\n  coe f := f.toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'", "start": [187, 1], "end": [194, 29], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.toFun_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toFun_eq_coe : p.toFun = p", "start": [204, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext : (\u2200 x, p x = q x) \u2192 p = q", "start": [210, 1], "end": [212, 18], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.le_def", "code": "@[to_additive]\ntheorem le_def : p \u2264 q \u2194 (p : E \u2192 \u211d) \u2264 q", "start": [220, 1], "end": [222, 10], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.lt_def", "code": "@[to_additive]\ntheorem lt_def : p < q \u2194 (p : E \u2192 \u211d) < q", "start": [226, 1], "end": [228, 10], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_le_coe", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E \u2192 \u211d) \u2264 q \u2194 p \u2264 q", "start": [232, 1], "end": [234, 10], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_lt_coe", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E \u2192 \u211d) < q \u2194 p < q", "start": [238, 1], "end": [240, 10], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.instZeroGroupSeminorm", "code": "@[to_additive]\ninstance instZeroGroupSeminorm : Zero (GroupSeminorm E) :=\n  \u27e8{  toFun := 0\n      map_one' := Pi.zero_apply _\n      mul_le' := fun _ _ => (zero_add _).ge\n      inv' := fun _ => rfl }\u27e9", "start": [246, 1], "end": [251, 30], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_zero", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zero : \u21d1(0 : GroupSeminorm E) = 0", "start": [253, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.zero_apply", "code": "@[to_additive (attr := simp)]\ntheorem zero_apply (x : E) : (0 : GroupSeminorm E) x = 0", "start": [259, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_add", "code": "@[to_additive (attr := simp)]\ntheorem coe_add : \u21d1(p + q) = p + q", "start": [279, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.add_apply", "code": "@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_sup", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : \u21d1(p \u2294 q) = \u21d1p \u2294 \u21d1q", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.sup_apply", "code": "@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p \u2294 q) x = p x \u2294 q x", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.semilatticeSup", "code": "@[to_additive]\ninstance semilatticeSup : SemilatticeSup (GroupSeminorm E) :=\n  FunLike.coe_injective.semilatticeSup _ coe_sup", "start": [316, 1], "end": [318, 49], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp", "code": "@[to_additive \"Composition of an additive group seminorm with an additive monoid homomorphism as an\nadditive group seminorm.\"]\ndef comp (p : GroupSeminorm E) (f : F \u2192* E) : GroupSeminorm F\n    where\n  toFun x := p (f x)\n  map_one' := by simp_rw [f.map_one, map_one_eq_zero p]\n  mul_le' _ _ := (congr_arg p <| f.map_mul _ _).trans_le <| map_mul_le_add p _ _\n  inv' x := by simp_rw [map_inv, map_inv_eq_map p]", "start": [320, 1], "end": [328, 51], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem coe_comp : \u21d1(p.comp f) = p \u2218 f", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_apply", "code": "@[to_additive (attr := simp)]\ntheorem comp_apply (x : F) : (p.comp f) x = p (f x)", "start": [338, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem comp_id : p.comp (MonoidHom.id _) = p", "start": [344, 1], "end": [346, 19], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_zero", "code": "@[to_additive (attr := simp)]\ntheorem comp_zero : p.comp (1 : F \u2192* E) = 0", "start": [350, 1], "end": [352, 33], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.zero_comp", "code": "@[to_additive (attr := simp)]\ntheorem zero_comp : (0 : GroupSeminorm E).comp f = 0", "start": [356, 1], "end": [358, 19], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_assoc", "code": "@[to_additive]\ntheorem comp_assoc (g : F \u2192* E) (f : G \u2192* F) : p.comp (g.comp f) = (p.comp g).comp f", "start": [362, 1], "end": [364, 19], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.add_comp", "code": "@[to_additive]\ntheorem add_comp (f : F \u2192* E) : (p + q).comp f = p.comp f + q.comp f", "start": [368, 1], "end": [370, 19], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_mono", "code": "@[to_additive]\ntheorem comp_mono (hp : p \u2264 q) : p.comp f \u2264 q.comp f", "start": [376, 1], "end": [377, 70], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.comp_mul_le", "code": "@[to_additive]\ntheorem comp_mul_le (f g : F \u2192* E) : p.comp (f * g) \u2264 p.comp f + p.comp g", "start": [387, 1], "end": [389, 23], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.mul_bddBelow_range_add", "code": "@[to_additive]\ntheorem mul_bddBelow_range_add {p q : GroupSeminorm E} {x : E} :\n    BddBelow (range fun y => p y + q (x / y))", "start": [393, 1], "end": [399, 16], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.inf_apply", "code": "@[to_additive (attr := simp)]\ntheorem inf_apply : (p \u2293 q) x = \u2a05 y, p y + q (x / y)", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.toOne", "code": "instance toOne [DecidableEq E] : One (AddGroupSeminorm E) :=\n  \u27e8{  toFun := fun x => if x = 0 then 0 else 1\n      map_zero' := if_pos rfl\n      add_le' := fun x y => by\n        by_cases hx : x = 0\n        \u00b7 simp only\n          rw [if_pos hx, hx, zero_add, zero_add]\n        \u00b7 simp only\n          rw [if_neg hx]\n          refine' le_add_of_le_of_nonneg _ _ <;> split_ifs <;> norm_num\n      neg' := fun x => by simp_rw [neg_eq_zero] }\u27e9", "start": [449, 1], "end": [459, 51], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.apply_one", "code": "@[simp]\ntheorem apply_one [DecidableEq E] (x : E) : (1 : AddGroupSeminorm E) x = if x = 0 then 0 else 1", "start": [461, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.toSMul", "code": "instance toSMul : SMul R (AddGroupSeminorm E) :=\n  \u27e8fun r p =>\n    { toFun := fun x => r \u2022 p x\n      map_zero' := by\n        simp only [\u2190 smul_one_smul \u211d\u22650 r (_ : \u211d), NNReal.smul_def, smul_eq_mul, map_zero, mul_zero]\n      add_le' := fun _ _ => by\n        simp only [\u2190 smul_one_smul \u211d\u22650 r (_ : \u211d), NNReal.smul_def, smul_eq_mul, \u2190 mul_add]\n        gcongr\n        apply map_add_le_add\n      neg' := fun x => by simp_rw [map_neg_eq_map] }\u27e9", "start": [466, 1], "end": [476, 54], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (r : R) (p : AddGroupSeminorm E) : \u21d1(r \u2022 p) = r \u2022 \u21d1p", "start": [478, 1], "end": [480, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.smul_apply", "code": "@[simp]\ntheorem smul_apply (r : R) (p : AddGroupSeminorm E) (x : E) : (r \u2022 p) x = r \u2022 p x", "start": [483, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.isScalarTower", "code": "instance isScalarTower [SMul R' \u211d] [SMul R' \u211d\u22650] [IsScalarTower R' \u211d\u22650 \u211d] [SMul R R']\n    [IsScalarTower R R' \u211d] : IsScalarTower R R' (AddGroupSeminorm E) :=\n  \u27e8fun r a p => ext fun x => smul_assoc r a (p x)\u27e9", "start": [488, 1], "end": [490, 51], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminorm.smul_sup", "code": "theorem smul_sup (r : R) (p q : AddGroupSeminorm E) : r \u2022 (p \u2294 q) = r \u2022 p \u2294 r \u2022 q", "start": [492, 1], "end": [496, 33], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.nonarchAddGroupSeminormClass", "code": "instance nonarchAddGroupSeminormClass : NonarchAddGroupSeminormClass (NonarchAddGroupSeminorm E) E\n    where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8_, _\u27e9, _, _\u27e9 := f; cases g; congr\n  map_add_le_max f := f.add_le_max'\n  map_zero f := f.map_zero'\n  map_neg_eq_map' f := f.neg'", "start": [507, 1], "end": [513, 30], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.toZeroHom_eq_coe", "code": "@[simp]\ntheorem toZeroHom_eq_coe : \u21d1p.toZeroHom = p", "start": [521, 1], "end": [523, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.ext", "code": "@[ext]\ntheorem ext : (\u2200 x, p x = q x) \u2192 p = q", "start": [526, 1], "end": [528, 18], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.le_def", "code": "theorem le_def : p \u2264 q \u2194 (p : E \u2192 \u211d) \u2264 q", "start": [534, 1], "end": [535, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.lt_def", "code": "theorem lt_def : p < q \u2194 (p : E \u2192 \u211d) < q", "start": [538, 1], "end": [539, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe : (p : E \u2192 \u211d) \u2264 q \u2194 p \u2264 q", "start": [542, 1], "end": [544, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe : (p : E \u2192 \u211d) < q \u2194 p < q", "start": [547, 1], "end": [549, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u21d1(0 : NonarchAddGroupSeminorm E) = 0", "start": [560, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : E) : (0 : NonarchAddGroupSeminorm E) x = 0", "start": [565, 1], "end": [567, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup : \u21d1(p \u2294 q) = \u21d1p \u2294 \u21d1q", "start": [584, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.sup_apply", "code": "@[simp]\ntheorem sup_apply (x : E) : (p \u2294 q) x = p x \u2294 q x", "start": [589, 1], "end": [591, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.add_bddBelow_range_add", "code": "theorem add_bddBelow_range_add {p q : NonarchAddGroupSeminorm E} {x : E} :\n    BddBelow (range fun y => p y + q (x - y))", "start": [603, 1], "end": [608, 16], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.toOne", "code": "@[to_additive existing AddGroupSeminorm.toOne]\ninstance toOne [DecidableEq E] : One (GroupSeminorm E) :=\n  \u27e8{  toFun := fun x => if x = 1 then 0 else 1\n      map_one' := if_pos rfl\n      mul_le' := fun x y => by\n        by_cases hx : x = 1\n        \u00b7 simp only\n          rw [if_pos hx, hx, one_mul, zero_add]\n        \u00b7 simp only\n          rw [if_neg hx]\n          refine' le_add_of_le_of_nonneg _ _ <;> split_ifs <;> norm_num\n      inv' := fun x => by simp_rw [inv_eq_one] }\u27e9", "start": [619, 1], "end": [630, 50], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.apply_one", "code": "@[to_additive (attr := simp) existing AddGroupSeminorm.apply_one]\ntheorem apply_one [DecidableEq E] (x : E) : (1 : GroupSeminorm E) x = if x = 1 then 0 else 1", "start": [632, 1], "end": [634, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.coe_smul", "code": "@[to_additive (attr := simp, norm_cast) existing AddGroupSeminorm.coe_smul]\ntheorem coe_smul (r : R) (p : GroupSeminorm E) : \u21d1(r \u2022 p) = r \u2022 \u21d1p", "start": [656, 1], "end": [658, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.smul_apply", "code": "@[to_additive (attr := simp) existing AddGroupSeminorm.smul_apply]\ntheorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r \u2022 p) x = r \u2022 p x", "start": [661, 1], "end": [663, 6], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.smul_sup", "code": "@[to_additive existing AddGroupSeminorm.smul_sup]\ntheorem smul_sup (r : R) (p q : GroupSeminorm E) : r \u2022 (p \u2294 q) = r \u2022 p \u2294 r \u2022 q", "start": [666, 1], "end": [671, 33], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.apply_one", "code": "@[simp]\ntheorem apply_one [DecidableEq E] (x : E) :\n    (1 : NonarchAddGroupSeminorm E) x = if x = 0 then 0 else 1", "start": [691, 1], "end": [694, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (r : R) (p : NonarchAddGroupSeminorm E) : \u21d1(r \u2022 p) = r \u2022 \u21d1p", "start": [715, 1], "end": [717, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.smul_apply", "code": "@[simp]\ntheorem smul_apply (r : R) (p : NonarchAddGroupSeminorm E) (x : E) : (r \u2022 p) x = r \u2022 p x", "start": [720, 1], "end": [722, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupSeminorm.smul_sup", "code": "theorem smul_sup (r : R) (p q : NonarchAddGroupSeminorm E) : r \u2022 (p \u2294 q) = r \u2022 p \u2294 r \u2022 q", "start": [725, 1], "end": [729, 33], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.groupNormClass", "code": "@[to_additive]\ninstance groupNormClass : GroupNormClass (GroupNorm E) E \u211d\n    where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8_, _, _, _\u27e9, _\u27e9 := f; cases g; congr\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'\n  eq_one_of_map_eq_zero f := f.eq_one_of_map_eq_zero' _", "start": [743, 1], "end": [751, 56], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.toGroupSeminorm_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toGroupSeminorm_eq_coe : \u21d1p.toGroupSeminorm = p", "start": [763, 1], "end": [765, 6], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext : (\u2200 x, p x = q x) \u2192 p = q", "start": [769, 1], "end": [771, 18], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.le_def", "code": "@[to_additive]\ntheorem le_def : p \u2264 q \u2194 (p : E \u2192 \u211d) \u2264 q", "start": [779, 1], "end": [781, 10], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.lt_def", "code": "@[to_additive]\ntheorem lt_def : p < q \u2194 (p : E \u2192 \u211d) < q", "start": [785, 1], "end": [787, 10], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.coe_le_coe", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E \u2192 \u211d) \u2264 q \u2194 p \u2264 q", "start": [791, 1], "end": [793, 10], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.coe_lt_coe", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E \u2192 \u211d) < q \u2194 p < q", "start": [797, 1], "end": [799, 10], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.coe_add", "code": "@[to_additive (attr := simp)]\ntheorem coe_add : \u21d1(p + q) = p + q", "start": [812, 1], "end": [814, 6], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.add_apply", "code": "@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x", "start": [818, 1], "end": [820, 6], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.coe_sup", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : \u21d1(p \u2294 q) = \u21d1p \u2294 \u21d1q", "start": [832, 1], "end": [834, 6], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.sup_apply", "code": "@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p \u2294 q) x = p x \u2294 q x", "start": [838, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupNorm.apply_one", "code": "@[simp]\ntheorem apply_one (x : E) : (1 : AddGroupNorm E) x = if x = 0 then 0 else 1", "start": [860, 1], "end": [862, 6], "kind": "commanddeclaration"}, {"full_name": "AddGroupNorm.toOne", "code": "instance _root_.AddGroupNorm.toOne [AddGroup E] [DecidableEq E] : One (AddGroupNorm E) :=\n  \u27e8{ (1 : AddGroupSeminorm E) with\n    eq_zero_of_map_eq_zero' := fun _ => zero_ne_one.ite_eq_left_iff.1 }\u27e9", "start": [872, 1], "end": [874, 73], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.toOne", "code": "@[to_additive existing AddGroupNorm.toOne]\ninstance toOne : One (GroupNorm E) :=\n  \u27e8{ (1 : GroupSeminorm E) with eq_one_of_map_eq_zero' := fun _ => zero_ne_one.ite_eq_left_iff.1 }\u27e9", "start": [878, 1], "end": [880, 100], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.apply_one", "code": "@[to_additive (attr := simp) existing AddGroupNorm.apply_one]\ntheorem apply_one (x : E) : (1 : GroupNorm E) x = if x = 1 then 0 else 1", "start": [882, 1], "end": [884, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.nonarchAddGroupNormClass", "code": "instance nonarchAddGroupNormClass : NonarchAddGroupNormClass (NonarchAddGroupNorm E) E\n    where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8\u27e8_, _\u27e9, _, _\u27e9, _\u27e9 := f; cases g; congr\n  map_add_le_max f := f.add_le_max'\n  map_zero f := f.map_zero'\n  map_neg_eq_map' f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _", "start": [899, 1], "end": [906, 58], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.toNonarchAddGroupSeminorm_eq_coe", "code": "@[simp]\ntheorem toNonarchAddGroupSeminorm_eq_coe : \u21d1p.toNonarchAddGroupSeminorm = p", "start": [914, 1], "end": [916, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.ext", "code": "@[ext]\ntheorem ext : (\u2200 x, p x = q x) \u2192 p = q", "start": [919, 1], "end": [921, 18], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.le_def", "code": "theorem le_def : p \u2264 q \u2194 (p : E \u2192 \u211d) \u2264 q", "start": [927, 1], "end": [928, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.lt_def", "code": "theorem lt_def : p < q \u2194 (p : E \u2192 \u211d) < q", "start": [931, 1], "end": [932, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe : (p : E \u2192 \u211d) \u2264 q \u2194 p \u2264 q", "start": [935, 1], "end": [937, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe : (p : E \u2192 \u211d) < q \u2194 p < q", "start": [940, 1], "end": [942, 10], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup : \u21d1(p \u2294 q) = \u21d1p \u2294 \u21d1q", "start": [953, 1], "end": [955, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.sup_apply", "code": "@[simp]\ntheorem sup_apply (x : E) : (p \u2294 q) x = p x \u2294 q x", "start": [958, 1], "end": [960, 6], "kind": "commanddeclaration"}, {"full_name": "NonarchAddGroupNorm.apply_one", "code": "@[simp]\ntheorem apply_one [DecidableEq E] (x : E) :\n    (1 : NonarchAddGroupNorm E) x = if x = 0 then 0 else 1", "start": [970, 1], "end": [973, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Arrow.lean", "imports": ["Mathlib/CategoryTheory/Comma.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Arrow", "code": "def Arrow :=\n  Comma.{v, v, v} (\ud835\udfed T) (\ud835\udfed T)", "start": [34, 1], "end": [37, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.inhabited", "code": "instance Arrow.inhabited [Inhabited T] : Inhabited (Arrow T) where\n  default := show Comma (\ud835\udfed T) (\ud835\udfed T) from default", "start": [44, 1], "end": [45, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hom_ext", "code": "@[ext]\nlemma hom_ext {X Y : Arrow T} (f g : X \u27f6 Y) (h\u2081 : f.left = g.left) (h\u2082 : f.right = g.right) :\n    f = g :=\n  CommaMorphism.ext _ _ h\u2081 h\u2082", "start": [52, 1], "end": [55, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Arrow.id_left", "code": "@[simp]\ntheorem id_left (f : Arrow T) : CommaMorphism.left (\ud835\udfd9 f) = \ud835\udfd9 f.left", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.id_right", "code": "@[simp]\ntheorem id_right (f : Arrow T) : CommaMorphism.right (\ud835\udfd9 f) = \ud835\udfd9 f.right", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.comp_left", "code": "@[simp, reassoc]\ntheorem comp_left {X Y Z : Arrow T} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).left = f.left \u226b g.left", "start": [68, 1], "end": [70, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.comp_right", "code": "@[simp, reassoc]\ntheorem comp_right {X Y Z : Arrow T} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).right = f.right \u226b g.right", "start": [73, 1], "end": [75, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mk", "code": "@[simps]\ndef mk {X Y : T} (f : X \u27f6 Y) : Arrow T where\n  left := X\n  right := Y\n  hom := f", "start": [77, 1], "end": [82, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mk_eq", "code": "@[simp]\ntheorem mk_eq (f : Arrow T) : Arrow.mk f.hom = f", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mk_injective", "code": "theorem mk_injective (A B : T) :\n    Function.Injective (Arrow.mk : (A \u27f6 B) \u2192 Arrow T)", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mk_inj", "code": "theorem mk_inj (A B : T) {f g : A \u27f6 B} : Arrow.mk f = Arrow.mk g \u2194 f = g", "start": [97, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.homMk", "code": "@[simps]\ndef homMk {f g : Arrow T} {u : f.left \u27f6 g.left} {v : f.right \u27f6 g.right}\n    (w : u \u226b g.hom = f.hom \u226b v) : f \u27f6 g where\n  left := u\n  right := v\n  w := w", "start": [105, 1], "end": [112, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.homMk'", "code": "@[simps]\ndef homMk' {X Y : T} {f : X \u27f6 Y} {P Q : T} {g : P \u27f6 Q} {u : X \u27f6 P} {v : Y \u27f6 Q} (w : u \u226b g = f \u226b v) :\n    Arrow.mk f \u27f6 Arrow.mk g where\n  left := u\n  right := v\n  w := w", "start": [115, 1], "end": [121, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.w", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem w {f g : Arrow T} (sq : f \u27f6 g) : sq.left \u226b g.hom = f.hom \u226b sq.right", "start": [126, 1], "end": [128, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.w_mk_right", "code": "@[reassoc (attr := simp)]\ntheorem w_mk_right {f : Arrow T} {X Y : T} {g : X \u27f6 Y} (sq : f \u27f6 mk g) :\n    sq.left \u226b g = f.hom \u226b sq.right", "start": [132, 1], "end": [135, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isIso_of_isIso_left_of_isIso_right", "code": "theorem isIso_of_isIso_left_of_isIso_right {f g : Arrow T} (ff : f \u27f6 g) [IsIso ff.left]\n    [IsIso ff.right] : IsIso ff where", "start": [138, 1], "end": [143, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isoMk", "code": "@[simps!]\ndef isoMk {f g : Arrow T} (l : f.left \u2245 g.left) (r : f.right \u2245 g.right)\n    (h : l.hom \u226b g.hom = f.hom \u226b r.hom := by aesop_cat) : f \u2245 g :=\n  Comma.isoMk l r h", "start": [146, 1], "end": [152, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isoMk'", "code": "abbrev isoMk' {W X Y Z : T} (f : W \u27f6 X) (g : Y \u27f6 Z) (e\u2081 : W \u2245 Y) (e\u2082 : X \u2245 Z)\n    (h : e\u2081.hom \u226b g = f \u226b e\u2082.hom := by aesop_cat) : Arrow.mk f \u2245 Arrow.mk g :=\n  Arrow.isoMk e\u2081 e\u2082 h", "start": [155, 1], "end": [159, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hom.congr_left", "code": "theorem hom.congr_left {f g : Arrow T} {\u03c6\u2081 \u03c6\u2082 : f \u27f6 g} (h : \u03c6\u2081 = \u03c6\u2082) : \u03c6\u2081.left = \u03c6\u2082.left", "start": [162, 1], "end": [163, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.hom.congr_right", "code": "@[simp]\ntheorem hom.congr_right {f g : Arrow T} {\u03c6\u2081 \u03c6\u2082 : f \u27f6 g} (h : \u03c6\u2081 = \u03c6\u2082) : \u03c6\u2081.right = \u03c6\u2082.right", "start": [166, 1], "end": [168, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.iso_w", "code": "theorem iso_w {f g : Arrow T} (e : f \u2245 g) : g.hom = e.inv.left \u226b f.hom \u226b e.hom.right", "start": [171, 1], "end": [174, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.iso_w'", "code": "theorem iso_w' {W X Y Z : T} {f : W \u27f6 X} {g : Y \u27f6 Z} (e : Arrow.mk f \u2245 Arrow.mk g) :\n    g = e.inv.left \u226b f \u226b e.hom.right", "start": [177, 1], "end": [179, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isIso_left", "code": "instance isIso_left [IsIso sq] : IsIso sq.left where\n  out := by\n    apply Exists.intro (inv sq).left\n    simp only [\u2190 Comma.comp_left, IsIso.hom_inv_id, IsIso.inv_hom_id, Arrow.id_left,\n      eq_self_iff_true, and_self_iff]\n    simp", "start": [186, 1], "end": [191, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isIso_right", "code": "instance isIso_right [IsIso sq] : IsIso sq.right where\n  out := by\n    apply Exists.intro (inv sq).right\n    simp only [\u2190 Comma.comp_right, IsIso.hom_inv_id, IsIso.inv_hom_id, Arrow.id_right,\n      eq_self_iff_true, and_self_iff]\n    simp", "start": [194, 1], "end": [199, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.inv_left", "code": "@[simp]\ntheorem inv_left [IsIso sq] : (inv sq).left = inv sq.left", "start": [202, 1], "end": [204, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.inv_right", "code": "@[simp]\ntheorem inv_right [IsIso sq] : (inv sq).right = inv sq.right", "start": [207, 1], "end": [209, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.left_hom_inv_right", "code": "theorem left_hom_inv_right [IsIso sq] : sq.left \u226b g.hom \u226b inv sq.right = f.hom", "start": [213, 1], "end": [214, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.inv_left_hom_right", "code": "theorem inv_left_hom_right [IsIso sq] : inv sq.left \u226b f.hom \u226b sq.right = g.hom", "start": [218, 1], "end": [219, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mono_left", "code": "instance mono_left [Mono sq] : Mono sq.left where\n  right_cancellation {Z} \u03c6 \u03c8 h := by\n    let aux : (Z \u27f6 f.left) \u2192 (Arrow.mk (\ud835\udfd9 Z) \u27f6 f) := fun \u03c6 =>\n      { left := \u03c6\n        right := \u03c6 \u226b f.hom }\n    have : \u2200 g, (aux g).right = g \u226b f.hom := fun g => by dsimp\n    show (aux \u03c6).left = (aux \u03c8).left\n    congr 1\n    rw [\u2190 cancel_mono sq]\n    apply CommaMorphism.ext\n    \u00b7 exact h\n    \u00b7 rw [Comma.comp_right, Comma.comp_right, this, this, Category.assoc, Category.assoc]\n      rw [\u2190Arrow.w]\n      simp only [\u2190 Category.assoc, h]", "start": [222, 1], "end": [235, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.epi_right", "code": "instance epi_right [Epi sq] : Epi sq.right where\n  left_cancellation {Z} \u03c6 \u03c8 h := by\n    let aux : (g.right \u27f6 Z) \u2192 (g \u27f6 Arrow.mk (\ud835\udfd9 Z)) := fun \u03c6 =>\n      { right := \u03c6\n        left := g.hom \u226b \u03c6 }\n    show (aux \u03c6).right = (aux \u03c8).right\n    congr 1\n    rw [\u2190 cancel_epi sq]\n    apply CommaMorphism.ext\n    \u00b7 rw [Comma.comp_left, Comma.comp_left, Arrow.w_assoc, Arrow.w_assoc, h]\n    \u00b7 exact h", "start": [238, 1], "end": [248, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.square_to_iso_invert", "code": "@[simp]\ntheorem square_to_iso_invert (i : Arrow T) {X Y : T} (p : X \u2245 Y) (sq : i \u27f6 Arrow.mk p.hom) :\n    i.hom \u226b sq.right \u226b p.inv = sq.left", "start": [253, 1], "end": [258, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.square_from_iso_invert", "code": "theorem square_from_iso_invert {X Y : T} (i : X \u2245 Y) (p : Arrow T) (sq : Arrow.mk i.hom \u27f6 p) :\n    i.inv \u226b sq.left \u226b p.hom = sq.right", "start": [261, 1], "end": [264, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.squareToSnd", "code": "@[simps]\ndef squareToSnd {X Y Z : C} {i : Arrow C} {f : X \u27f6 Y} {g : Y \u27f6 Z} (sq : i \u27f6 Arrow.mk (f \u226b g)) :\n    i \u27f6 Arrow.mk g where\n  left := sq.left \u226b f\n  right := sq.right", "start": [269, 1], "end": [281, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.leftFunc", "code": "@[simps!]\ndef leftFunc : Arrow C \u2964 C :=\n  Comma.fst _ _", "start": [284, 1], "end": [287, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.rightFunc", "code": "@[simps!]\ndef rightFunc : Arrow C \u2964 C :=\n  Comma.snd _ _", "start": [290, 1], "end": [293, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.leftToRight", "code": "@[simps]\ndef leftToRight : (leftFunc : Arrow C \u2964 C) \u27f6 rightFunc where app f := f.hom", "start": [296, 1], "end": [298, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapArrow", "code": "@[simps]\ndef mapArrow (F : C \u2964 D) : Arrow C \u2964 Arrow D where\n  obj a :=\n    { left := F.obj a.left\n      right := F.obj a.right\n      hom := F.map a.hom }\n  map f :=\n    { left := F.map f.left\n      right := F.map f.right\n      w := by\n        let w := f.w\n        simp only [id_map] at w\n        dsimp\n        simp only [\u2190 F.map_comp, w] }", "start": [309, 1], "end": [323, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapArrowFunctor", "code": "@[simps]\ndef mapArrowFunctor : (C \u2964 D) \u2964 (Arrow C \u2964 Arrow D) where\n  obj F := F.mapArrow\n  map \u03c4 :=\n    { app := fun f =>\n        { left := \u03c4.app _\n          right := \u03c4.app _ } }", "start": [328, 1], "end": [336, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapArrowEquivalence", "code": "def mapArrowEquivalence (e : C \u224c D) : Arrow C \u224c Arrow D where\n  functor := e.functor.mapArrow\n  inverse := e.inverse.mapArrow\n  unitIso := Functor.mapIso (mapArrowFunctor C C) e.unitIso\n  counitIso := Functor.mapIso (mapArrowFunctor D D) e.counitIso", "start": [340, 1], "end": [345, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isEquivalenceMapArrow", "code": "instance isEquivalenceMapArrow (F : C \u2964 D) [IsEquivalence F] :\n    IsEquivalence F.mapArrow :=\n  IsEquivalence.ofEquivalence (mapArrowEquivalence (asEquivalence F))", "start": [347, 1], "end": [349, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.isoOfNatIso", "code": "def Arrow.isoOfNatIso {C D : Type*} [Category C] [Category D] {F G : C \u2964 D} (e : F \u2245 G)\n    (f : Arrow C) : F.mapArrow.obj f \u2245 G.mapArrow.obj f :=\n  Arrow.isoMk (e.app f.left) (e.app f.right)", "start": [353, 1], "end": [357, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Groupoid.lean", "imports": ["Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/CategoryTheory/FullSubcategory.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "Mathlib/Combinatorics/Quiver/Symmetric.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Pi/Basic.lean"], "premises": [{"full_name": "CategoryTheory.Groupoid", "code": "class Groupoid (obj : Type u) extends Category.{v} obj : Type max u (v + 1) where\n  \n  inv : \u2200 {X Y : obj}, (X \u27f6 Y) \u2192 (Y \u27f6 X)\n  \n  inv_comp : \u2200 {X Y : obj} (f : X \u27f6 Y), comp (inv f) f = id Y := by aesop_cat\n  \n  comp_inv : \u2200 {X Y : obj} (f : X \u27f6 Y), comp f (inv f) = id X := by aesop_cat", "start": [40, 1], "end": [47, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LargeGroupoid", "code": "abbrev LargeGroupoid (C : Type (u + 1)) : Type (u + 1) :=\n  Groupoid.{u} C", "start": [52, 1], "end": [56, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SmallGroupoid", "code": "abbrev SmallGroupoid (C : Type u) : Type (u + 1) :=\n  Groupoid.{u} C", "start": [59, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_groupoid", "code": "instance (priority := 100) IsIso.of_groupoid (f : X \u27f6 Y) : IsIso f :=\n  \u27e8\u27e8Groupoid.inv f, Groupoid.comp_inv f, Groupoid.inv_comp f\u27e9\u27e9", "start": [71, 1], "end": [72, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.inv_eq_inv", "code": "@[simp]\ntheorem Groupoid.inv_eq_inv (f : X \u27f6 Y) : Groupoid.inv f = CategoryTheory.inv f", "start": [75, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.invEquiv", "code": "@[simps]\ndef Groupoid.invEquiv : (X \u27f6 Y) \u2243 (Y \u27f6 X) :=\n  \u27e8Groupoid.inv, Groupoid.inv, fun f => by simp, fun f => by simp\u27e9", "start": [80, 1], "end": [83, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoidHasInvolutiveReverse", "code": "instance (priority := 100) groupoidHasInvolutiveReverse : Quiver.HasInvolutiveReverse C where\n  reverse' f := Groupoid.inv f\n  inv' f := by\n    dsimp [Quiver.reverse]\n    simp", "start": [86, 1], "end": [90, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.reverse_eq_inv", "code": "@[simp]\ntheorem Groupoid.reverse_eq_inv (f : X \u27f6 Y) : Quiver.reverse f = Groupoid.inv f", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.functorMapReverse", "code": "instance functorMapReverse {D : Type*} [Groupoid D] (F : C \u2964 D) : F.toPrefunctor.MapReverse where\n  map_reverse' f := by\n    simp only [Quiver.reverse, Quiver.HasReverse.reverse', Groupoid.inv_eq_inv,\n      Functor.map_inv]", "start": [98, 1], "end": [101, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.isoEquivHom", "code": "def Groupoid.isoEquivHom : (X \u2245 Y) \u2243 (X \u27f6 Y) where\n  toFun := Iso.hom\n  invFun f := \u27e8f, Groupoid.inv f, (by aesop_cat), (by aesop_cat)\u27e9\n  left_inv i := Iso.ext rfl\n  right_inv f := rfl", "start": [106, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.invFunctor", "code": "@[simps]\nnoncomputable def Groupoid.invFunctor : C \u2964 C\u1d52\u1d56 where\n  obj := Opposite.op\n  map {X Y} f := (inv f).op", "start": [116, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.ofIsIso", "code": "noncomputable def Groupoid.ofIsIso (all_is_iso : \u2200 {X Y : C} (f : X \u27f6 Y), IsIso f) :\n    Groupoid.{v} C where\n  inv := fun f => CategoryTheory.inv f\n  inv_comp := fun f => Classical.choose_spec (all_is_iso f).out|>.right", "start": [129, 1], "end": [133, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.ofHomUnique", "code": "def Groupoid.ofHomUnique (all_unique : \u2200 {X Y : C}, Unique (X \u27f6 Y)) : Groupoid.{v} C where\n  inv _ := all_unique.default", "start": [136, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.groupoid", "code": "instance InducedCategory.groupoid {C : Type u} (D : Type u\u2082) [Groupoid.{v} D] (F : C \u2192 D) :\n    Groupoid.{v} (InducedCategory D F) :=\n  { InducedCategory.category F with\n    inv := fun f => Groupoid.inv f\n    inv_comp := fun f => Groupoid.inv_comp f\n    comp_inv := fun f => Groupoid.comp_inv f }", "start": [143, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoidPi", "code": "instance groupoidPi {I : Type u} {J : I \u2192 Type u\u2082} [\u2200 i, Groupoid.{v} (J i)] :\n    Groupoid.{max u v} (\u2200 i : I, J i) where\n  inv f := fun i : I => Groupoid.inv (f i)\n  comp_inv := fun f => by funext i; apply Groupoid.comp_inv\n  inv_comp := fun f => by funext i; apply Groupoid.inv_comp", "start": [153, 1], "end": [157, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoidProd", "code": "instance groupoidProd {\u03b1 : Type u} {\u03b2 : Type v} [Groupoid.{u\u2082} \u03b1] [Groupoid.{v\u2082} \u03b2] :\n    Groupoid.{max u\u2082 v\u2082} (\u03b1 \u00d7 \u03b2) where\n  inv f := (Groupoid.inv f.1, Groupoid.inv f.2)", "start": [160, 1], "end": [162, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Index.lean", "imports": ["Mathlib/GroupTheory/Finiteness.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean", "Mathlib/Data/Finite/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.index", "code": "@[to_additive \"The index of a subgroup as a natural number,\nand returns 0 if the index is infinite.\"]\nnoncomputable def index : \u2115 :=\n  Nat.card (G \u29f8 H)", "start": [43, 1], "end": [47, 19], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex", "code": "@[to_additive \"The relative index of a subgroup as a natural number,\nand returns 0 if the relative index is infinite.\"]\nnoncomputable def relindex : \u2115 :=\n  (H.subgroupOf K).index", "start": [51, 1], "end": [56, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_comap_of_surjective", "code": "@[to_additive]\ntheorem index_comap_of_surjective {G' : Type*} [Group G'] {f : G' \u2192* G}\n    (hf : Function.Surjective f) : (H.comap f).index = H.index", "start": [60, 1], "end": [75, 77], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_comap", "code": "@[to_additive]\ntheorem index_comap {G' : Type*} [Group G'] (f : G' \u2192* G) :\n    (H.comap f).index = H.relindex f.range", "start": [79, 1], "end": [83, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_comap", "code": "@[to_additive]\ntheorem relindex_comap {G' : Type*} [Group G'] (f : G' \u2192* G) (K : Subgroup G') :\n    relindex (comap f H) K = relindex H (map f K)", "start": [87, 1], "end": [90, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_mul_index", "code": "@[to_additive relindex_mul_index]\ntheorem relindex_mul_index (h : H \u2264 K) : H.relindex K * K.index = H.index", "start": [96, 1], "end": [99, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_dvd_of_le", "code": "@[to_additive]\ntheorem index_dvd_of_le (h : H \u2264 K) : K.index \u2223 H.index", "start": [103, 1], "end": [105, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_dvd_index_of_le", "code": "@[to_additive]\ntheorem relindex_dvd_index_of_le (h : H \u2264 K) : H.relindex K \u2223 H.index", "start": [109, 1], "end": [111, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_subgroupOf", "code": "@[to_additive]\ntheorem relindex_subgroupOf (hKL : K \u2264 L) :\n    (H.subgroupOf L).relindex (K.subgroupOf L) = H.relindex K", "start": [115, 1], "end": [118, 98], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_mul_relindex", "code": "@[to_additive relindex_mul_relindex]\ntheorem relindex_mul_relindex (hHK : H \u2264 K) (hKL : K \u2264 L) :\n    H.relindex K * K.relindex L = H.relindex L", "start": [124, 1], "end": [128, 46], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_relindex_right", "code": "@[to_additive]\ntheorem inf_relindex_right : (H \u2293 K).relindex K = H.relindex K", "start": [132, 1], "end": [134, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_relindex_left", "code": "@[to_additive]\ntheorem inf_relindex_left : (H \u2293 K).relindex H = K.relindex H", "start": [138, 1], "end": [140, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_inf_mul_relindex", "code": "@[to_additive relindex_inf_mul_relindex]\ntheorem relindex_inf_mul_relindex : H.relindex (K \u2293 L) * K.relindex L = (H \u2293 K).relindex L", "start": [144, 1], "end": [147, 88], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_sup_right", "code": "@[to_additive (attr := simp)]\ntheorem relindex_sup_right [K.Normal] : K.relindex (H \u2294 K) = K.relindex H", "start": [151, 1], "end": [153, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_sup_left", "code": "@[to_additive (attr := simp)]\ntheorem relindex_sup_left [K.Normal] : K.relindex (K \u2294 H) = K.relindex H", "start": [157, 1], "end": [159, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_dvd_index_of_normal", "code": "@[to_additive]\ntheorem relindex_dvd_index_of_normal [H.Normal] : H.relindex K \u2223 H.index", "start": [163, 1], "end": [165, 65], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_dvd_of_le_left", "code": "@[to_additive]\ntheorem relindex_dvd_of_le_left (hHK : H \u2264 K) : K.relindex L \u2223 H.relindex L", "start": [171, 1], "end": [173, 78], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_eq_two_iff", "code": "@[to_additive \"An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"]\ntheorem index_eq_two_iff : H.index = 2 \u2194 \u2203 a, \u2200 b, Xor' (b * a \u2208 H) (b \u2208 H)", "start": [177, 1], "end": [191, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_mem_iff_of_index_two", "code": "@[to_additive]\ntheorem mul_mem_iff_of_index_two (h : H.index = 2) {a b : G} : a * b \u2208 H \u2194 (a \u2208 H \u2194 b \u2208 H)", "start": [195, 1], "end": [202, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_self_mem_of_index_two", "code": "@[to_additive]\ntheorem mul_self_mem_of_index_two (h : H.index = 2) (a : G) : a * a \u2208 H", "start": [206, 1], "end": [208, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sq_mem_of_index_two", "code": "@[to_additive two_smul_mem_of_index_two]\ntheorem sq_mem_of_index_two (h : H.index = 2) (a : G) : a ^ 2 \u2208 H", "start": [212, 1], "end": [214, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_top", "code": "@[to_additive (attr := simp)]\ntheorem index_top : (\u22a4 : Subgroup G).index = 1", "start": [221, 1], "end": [223, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_bot", "code": "@[to_additive (attr := simp)]\ntheorem index_bot : (\u22a5 : Subgroup G).index = Nat.card G", "start": [227, 1], "end": [229, 57], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_bot_eq_card", "code": "@[to_additive]\ntheorem index_bot_eq_card [Fintype G] : (\u22a5 : Subgroup G).index = Fintype.card G", "start": [233, 1], "end": [235, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_top_left", "code": "@[to_additive (attr := simp)]\ntheorem relindex_top_left : (\u22a4 : Subgroup G).relindex H = 1", "start": [239, 1], "end": [241, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_top_right", "code": "@[to_additive (attr := simp)]\ntheorem relindex_top_right : H.relindex \u22a4 = H.index", "start": [245, 1], "end": [247, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_bot_left", "code": "@[to_additive (attr := simp)]\ntheorem relindex_bot_left : (\u22a5 : Subgroup G).relindex H = Nat.card H", "start": [251, 1], "end": [253, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_bot_left_eq_card", "code": "@[to_additive]\ntheorem relindex_bot_left_eq_card [Fintype H] : (\u22a5 : Subgroup G).relindex H = Fintype.card H", "start": [257, 1], "end": [259, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_bot_right", "code": "@[to_additive (attr := simp)]\ntheorem relindex_bot_right : H.relindex \u22a5 = 1", "start": [263, 1], "end": [264, 100], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_self", "code": "@[to_additive (attr := simp)]\ntheorem relindex_self : H.relindex H = 1", "start": [268, 1], "end": [269, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_ker", "code": "@[to_additive]\ntheorem index_ker {H} [Group H] (f : G \u2192* H) : f.ker.index = Nat.card (Set.range f)", "start": [273, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_ker", "code": "@[to_additive]\ntheorem relindex_ker {H} [Group H] (f : G \u2192* H) (K : Subgroup G) :\n    f.ker.relindex K = Nat.card (f '' K)", "start": [280, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_mul_index", "code": "@[to_additive (attr := simp) card_mul_index]\ntheorem card_mul_index : Nat.card H * H.index = Nat.card G", "start": [288, 1], "end": [291, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nat_card_dvd_of_injective", "code": "@[to_additive]\ntheorem nat_card_dvd_of_injective {G H : Type*} [Group G] [Group H] (f : G \u2192* H)\n    (hf : Function.Injective f) : Nat.card G \u2223 Nat.card H", "start": [295, 1], "end": [299, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nat_card_dvd_of_le", "code": "@[to_additive]\ntheorem nat_card_dvd_of_le (hHK : H \u2264 K) : Nat.card H \u2223 Nat.card K", "start": [303, 1], "end": [305, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nat_card_dvd_of_surjective", "code": "@[to_additive]\ntheorem nat_card_dvd_of_surjective {G H : Type*} [Group G] [Group H] (f : G \u2192* H)\n    (hf : Function.Surjective f) : Nat.card H \u2223 Nat.card G", "start": [309, 1], "end": [313, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_dvd_of_surjective", "code": "@[to_additive]\ntheorem card_dvd_of_surjective {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H]\n    (f : G \u2192* H) (hf : Function.Surjective f) : Fintype.card H \u2223 Fintype.card G", "start": [317, 1], "end": [320, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_map", "code": "@[to_additive]\ntheorem index_map {G' : Type*} [Group G'] (f : G \u2192* G') :\n    (H.map f).index = (H \u2294 f.ker).index * f.range.index", "start": [324, 1], "end": [327, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_map_dvd", "code": "@[to_additive]\ntheorem index_map_dvd {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : Function.Surjective f) :\n    (H.map f).index \u2223 H.index", "start": [331, 1], "end": [335, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.dvd_index_map", "code": "@[to_additive]\ntheorem dvd_index_map {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : f.ker \u2264 H) :\n    H.index \u2223 (H.map f).index", "start": [339, 1], "end": [343, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_map_eq", "code": "@[to_additive]\ntheorem index_map_eq {G' : Type*} [Group G'] {f : G \u2192* G'} (hf1 : Function.Surjective f)\n    (hf2 : f.ker \u2264 H) : (H.map f).index = H.index", "start": [347, 1], "end": [350, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_eq_card", "code": "@[to_additive]\ntheorem index_eq_card [Fintype (G \u29f8 H)] : H.index = Fintype.card (G \u29f8 H)", "start": [354, 1], "end": [356, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_mul_card", "code": "@[to_additive index_mul_card]\ntheorem index_mul_card [Fintype G] [hH : Fintype H] :\n    H.index * Fintype.card H = Fintype.card G", "start": [360, 1], "end": [364, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_dvd_card", "code": "@[to_additive]\ntheorem index_dvd_card [Fintype G] : H.index \u2223 Fintype.card G", "start": [368, 1], "end": [370, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_eq_zero_of_le_left", "code": "@[to_additive]\ntheorem relindex_eq_zero_of_le_left (hHK : H \u2264 K) (hKL : K.relindex L = 0) : H.relindex L = 0", "start": [376, 1], "end": [378, 60], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_eq_zero_of_le_right", "code": "@[to_additive]\ntheorem relindex_eq_zero_of_le_right (hKL : K \u2264 L) (hHK : H.relindex K = 0) : H.relindex L = 0", "start": [382, 1], "end": [384, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_eq_zero_of_relindex_eq_zero", "code": "@[to_additive]\ntheorem index_eq_zero_of_relindex_eq_zero (h : H.relindex K = 0) : H.index = 0", "start": [388, 1], "end": [390, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_le_of_le_left", "code": "@[to_additive]\ntheorem relindex_le_of_le_left (hHK : H \u2264 K) (hHL : H.relindex L \u2260 0) :\n    K.relindex L \u2264 H.relindex L", "start": [394, 1], "end": [397, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_le_of_le_right", "code": "@[to_additive]\ntheorem relindex_le_of_le_right (hKL : K \u2264 L) (hHL : H.relindex L \u2260 0) :\n    H.relindex K \u2264 H.relindex L", "start": [401, 1], "end": [404, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_ne_zero_trans", "code": "@[to_additive]\ntheorem relindex_ne_zero_trans (hHK : H.relindex K \u2260 0) (hKL : K.relindex L \u2260 0) :\n    H.relindex L \u2260 0", "start": [408, 1], "end": [412, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_inf_ne_zero", "code": "@[to_additive]\ntheorem relindex_inf_ne_zero (hH : H.relindex L \u2260 0) (hK : K.relindex L \u2260 0) :\n    (H \u2293 K).relindex L \u2260 0", "start": [416, 1], "end": [422, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_inf_ne_zero", "code": "@[to_additive]\ntheorem index_inf_ne_zero (hH : H.index \u2260 0) (hK : K.index \u2260 0) : (H \u2293 K).index \u2260 0", "start": [426, 1], "end": [429, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_inf_le", "code": "@[to_additive]\ntheorem relindex_inf_le : (H \u2293 K).relindex L \u2264 H.relindex L * K.relindex L", "start": [433, 1], "end": [439, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_inf_le", "code": "@[to_additive]\ntheorem index_inf_le : (H \u2293 K).index \u2264 H.index * K.index", "start": [443, 1], "end": [445, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_iInf_ne_zero", "code": "@[to_additive]\ntheorem relindex_iInf_ne_zero {\u03b9 : Type*} [_h\u03b9 : Finite \u03b9] {f : \u03b9 \u2192 Subgroup G}\n    (hf : \u2200 i, (f i).relindex L \u2260 0) : (\u2a05 i, f i).relindex L \u2260 0", "start": [449, 1], "end": [455, 77], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_iInf_le", "code": "@[to_additive]\ntheorem relindex_iInf_le {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b9 \u2192 Subgroup G) :\n    (\u2a05 i, f i).relindex L \u2264 \u220f i, (f i).relindex L", "start": [459, 1], "end": [466, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_iInf_ne_zero", "code": "@[to_additive]\ntheorem index_iInf_ne_zero {\u03b9 : Type*} [Finite \u03b9] {f : \u03b9 \u2192 Subgroup G}\n    (hf : \u2200 i, (f i).index \u2260 0) : (\u2a05 i, f i).index \u2260 0", "start": [470, 1], "end": [474, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_iInf_le", "code": "@[to_additive]\ntheorem index_iInf_le {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b9 \u2192 Subgroup G) :\n    (\u2a05 i, f i).index \u2264 \u220f i, (f i).index", "start": [478, 1], "end": [480, 95], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_eq_one", "code": "@[to_additive (attr := simp) index_eq_one]\ntheorem index_eq_one : H.index = 1 \u2194 H = \u22a4", "start": [485, 1], "end": [489, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.relindex_eq_one", "code": "@[to_additive (attr := simp) relindex_eq_one]\ntheorem relindex_eq_one : H.relindex K = 1 \u2194 K \u2264 H", "start": [493, 1], "end": [495, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_eq_one", "code": "@[to_additive (attr := simp) card_eq_one]\ntheorem card_eq_one : Nat.card H = 1 \u2194 H = \u22a5", "start": [499, 1], "end": [501, 57], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_ne_zero_of_finite", "code": "@[to_additive]\ntheorem index_ne_zero_of_finite [hH : Finite (G \u29f8 H)] : H.index \u2260 0", "start": [505, 1], "end": [509, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fintypeOfIndexNeZero", "code": "@[to_additive \"Finite index implies finite quotient.\"]\nnoncomputable def fintypeOfIndexNeZero (hH : H.index \u2260 0) : Fintype (G \u29f8 H) :=\n  @Fintype.ofFinite _ (Nat.finite_of_card_ne_zero hH)", "start": [514, 1], "end": [517, 54], "kind": "commanddeclaration"}, {"full_name": "Subgroup.one_lt_index_of_ne_top", "code": "@[to_additive one_lt_index_of_ne_top]\ntheorem one_lt_index_of_ne_top [Finite (G \u29f8 H)] (hH : H \u2260 \u22a4) : 1 < H.index", "start": [521, 1], "end": [523, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.FiniteIndex", "code": "class FiniteIndex : Prop where\n  \n  finiteIndex : H.index \u2260 0", "start": [531, 1], "end": [534, 28], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.FiniteIndex", "code": "class _root_.AddSubgroup.FiniteIndex {G : Type*} [AddGroup G] (H : AddSubgroup G) : Prop where\n  \n  finiteIndex : H.index \u2260 0", "start": [537, 1], "end": [540, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fintypeQuotientOfFiniteIndex", "code": "@[to_additive \"A finite index subgroup has finite quotient\"]\nnoncomputable def fintypeQuotientOfFiniteIndex [FiniteIndex H] : Fintype (G \u29f8 H) :=\n  fintypeOfIndexNeZero FiniteIndex.finiteIndex", "start": [543, 1], "end": [546, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finite_quotient_of_finiteIndex", "code": "@[to_additive]\ninstance finite_quotient_of_finiteIndex [FiniteIndex H] : Finite (G \u29f8 H) :=\n  H.fintypeQuotientOfFiniteIndex.finite", "start": [550, 1], "end": [552, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_of_finite_quotient", "code": "@[to_additive]\ntheorem finiteIndex_of_finite_quotient [Finite (G \u29f8 H)] : FiniteIndex H", "start": [556, 1], "end": [558, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_of_finite", "code": "@[to_additive]\ninstance (priority := 100) finiteIndex_of_finite [Finite G] : FiniteIndex H :=\n  @finiteIndex_of_finite_quotient _ _ H (Quotient.finite _)", "start": [563, 1], "end": [565, 60], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_of_le", "code": "@[to_additive]\ntheorem finiteIndex_of_le [FiniteIndex H] (h : H \u2264 K) : FiniteIndex K", "start": [579, 1], "end": [581, 71], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_ker", "code": "@[to_additive]\ninstance finiteIndex_ker {G' : Type*} [Group G'] (f : G \u2192* G') [Finite f.range] :\n    f.ker.FiniteIndex :=\n  @finiteIndex_of_finite_quotient G _ f.ker\n    (Finite.of_equiv f.range (QuotientGroup.quotientKerEquivRange f).symm)", "start": [587, 1], "end": [591, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_normalCore", "code": "instance finiteIndex_normalCore [H.FiniteIndex] : H.normalCore.FiniteIndex := by\n  rw [normalCore_eq_ker]\n  infer_instance", "start": [595, 1], "end": [597, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.finiteIndex_center", "code": "instance finiteIndex_center [Finite (commutatorSet G)] [Group.FG G] : FiniteIndex (center G) := by\n  obtain \u27e8S, -, hS\u27e9 := Group.rank_spec G\n  exact \u27e8mt (Finite.card_eq_zero_of_embedding (quotientCenterEmbedding hS)) Finite.card_pos.ne'\u27e9", "start": [602, 1], "end": [604, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.index_center_le_pow", "code": "theorem index_center_le_pow [Finite (commutatorSet G)] [Group.FG G] :\n    (center G).index \u2264 Nat.card (commutatorSet G) ^ Group.rank G", "start": [607, 1], "end": [611, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Infinite.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NoMaxOrder.infinite", "code": "theorem NoMaxOrder.infinite [Nonempty \u03b1] [NoMaxOrder \u03b1] : Infinite \u03b1", "start": [21, 1], "end": [25, 39], "kind": "commanddeclaration"}, {"full_name": "NoMinOrder.infinite", "code": "theorem NoMinOrder.infinite [Nonempty \u03b1] [NoMinOrder \u03b1] : Infinite \u03b1", "start": [28, 1], "end": [31, 33], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.infinite", "code": "theorem Ioo.infinite : Infinite (Ioo a b)", "start": [40, 1], "end": [41, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_infinite", "code": "theorem Ioo_infinite : (Ioo a b).Infinite", "start": [44, 1], "end": [45, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_infinite", "code": "theorem Ico_infinite : (Ico a b).Infinite", "start": [48, 1], "end": [49, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.infinite", "code": "theorem Ico.infinite : Infinite (Ico a b)", "start": [52, 1], "end": [53, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_infinite", "code": "theorem Ioc_infinite : (Ioc a b).Infinite", "start": [56, 1], "end": [57, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.infinite", "code": "theorem Ioc.infinite : Infinite (Ioc a b)", "start": [60, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_infinite", "code": "theorem Icc_infinite : (Icc a b).Infinite", "start": [64, 1], "end": [65, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.infinite", "code": "theorem Icc.infinite : Infinite (Icc a b)", "start": [68, 1], "end": [69, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_infinite", "code": "theorem Iio_infinite [NoMinOrder \u03b1] (a : \u03b1) : (Iio a).Infinite", "start": [77, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_infinite", "code": "theorem Iic_infinite [NoMinOrder \u03b1] (a : \u03b1) : (Iic a).Infinite", "start": [84, 1], "end": [85, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_infinite", "code": "theorem Ioi_infinite [NoMaxOrder \u03b1] (a : \u03b1) : (Ioi a).Infinite", "start": [91, 1], "end": [92, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_infinite", "code": "theorem Ici_infinite [NoMaxOrder \u03b1] (a : \u03b1) : (Ici a).Infinite", "start": [98, 1], "end": [99, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Degree/Definitions.lean", "imports": ["Mathlib/Data/Polynomial/Monomial.lean", "Mathlib/Data/Nat/Cast/WithTop.lean", "Mathlib/Algebra/MonoidAlgebra/Degree.lean", "Mathlib/Data/Fintype/BigOperators.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/WithBot.lean", "Mathlib/Data/Polynomial/Coeff.lean"], "premises": [{"full_name": "Polynomial.degree", "code": "def degree (p : R[X]) : WithBot \u2115 :=\n  p.support.max", "start": [50, 1], "end": [54, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_lt_wf", "code": "theorem degree_lt_wf : WellFounded fun p q : R[X] => degree p < degree q", "start": [57, 1], "end": [58, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree", "code": "def natDegree (p : R[X]) : \u2115 :=\n  (degree p).unbot' 0", "start": [64, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff", "code": "def leadingCoeff (p : R[X]) : R :=\n  coeff p (natDegree p)", "start": [69, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic", "code": "def Monic (p : R[X]) :=\n  leadingCoeff p = (1 : R)", "start": [74, 1], "end": [76, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_subsingleton", "code": "@[nontriviality]\ntheorem monic_of_subsingleton [Subsingleton R] (p : R[X]) : Monic p", "start": [79, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.def", "code": "theorem Monic.def : Monic p \u2194 leadingCoeff p = 1", "start": [84, 1], "end": [85, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.decidable", "code": "instance Monic.decidable [DecidableEq R] : Decidable (Monic p) := by unfold Monic; infer_instance", "start": [88, 1], "end": [88, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.leadingCoeff", "code": "@[simp]\ntheorem Monic.leadingCoeff {p : R[X]} (hp : p.Monic) : leadingCoeff p = 1", "start": [91, 1], "end": [93, 5], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.coeff_natDegree", "code": "theorem Monic.coeff_natDegree {p : R[X]} (hp : p.Monic) : p.coeff p.natDegree = 1", "start": [96, 1], "end": [97, 5], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_zero", "code": "@[simp]\ntheorem degree_zero : degree (0 : R[X]) = \u22a5", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_zero", "code": "@[simp]\ntheorem natDegree_zero : natDegree (0 : R[X]) = 0", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_natDegree", "code": "@[simp]\ntheorem coeff_natDegree : coeff p (natDegree p) = leadingCoeff p", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_bot", "code": "@[simp]\ntheorem degree_eq_bot : degree p = \u22a5 \u2194 p = 0", "start": [115, 1], "end": [117, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_of_subsingleton", "code": "@[nontriviality]\ntheorem degree_of_subsingleton [Subsingleton R] : degree p = \u22a5", "start": [120, 1], "end": [122, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_of_subsingleton", "code": "@[nontriviality]\ntheorem natDegree_of_subsingleton [Subsingleton R] : natDegree p = 0", "start": [125, 1], "end": [127, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_natDegree", "code": "theorem degree_eq_natDegree (hp : p \u2260 0) : degree p = (natDegree p : WithBot \u2115)", "start": [130, 1], "end": [133, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_iff_natDegree_eq", "code": "theorem degree_eq_iff_natDegree_eq {p : R[X]} {n : \u2115} (hp : p \u2260 0) :\n    p.degree = n \u2194 p.natDegree = n", "start": [136, 1], "end": [137, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_iff_natDegree_eq_of_pos", "code": "theorem degree_eq_iff_natDegree_eq_of_pos {p : R[X]} {n : \u2115} (hn : 0 < n) :\n    p.degree = n \u2194 p.natDegree = n", "start": [140, 1], "end": [153, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_of_degree_eq_some", "code": "theorem natDegree_eq_of_degree_eq_some {p : R[X]} {n : \u2115} (h : degree p = n) : natDegree p = n", "start": [156, 1], "end": [158, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_ne_of_natDegree_ne", "code": "theorem degree_ne_of_natDegree_ne {n : \u2115} : p.natDegree \u2260 n \u2192 degree p \u2260 n", "start": [161, 1], "end": [162, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_natDegree", "code": "@[simp]\ntheorem degree_le_natDegree : degree p \u2264 natDegree p", "start": [165, 1], "end": [167, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_of_degree_eq", "code": "theorem natDegree_eq_of_degree_eq [Semiring S] {q : S[X]} (h : degree p = degree q) :\n    natDegree p = natDegree q", "start": [170, 1], "end": [171, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_degree_of_ne_zero", "code": "theorem le_degree_of_ne_zero (h : coeff p n \u2260 0) : (n : WithBot \u2115) \u2264 degree p", "start": [174, 1], "end": [176, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_natDegree_of_ne_zero", "code": "theorem le_natDegree_of_ne_zero (h : coeff p n \u2260 0) : n \u2264 natDegree p", "start": [179, 1], "end": [183, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_natDegree_of_mem_supp", "code": "theorem le_natDegree_of_mem_supp (a : \u2115) : a \u2208 p.support \u2192 a \u2264 natDegree p", "start": [186, 1], "end": [187, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_of_le_of_coeff_ne_zero", "code": "theorem degree_eq_of_le_of_coeff_ne_zero (pn : p.degree \u2264 n) (p1 : p.coeff n \u2260 0) : p.degree = n", "start": [190, 1], "end": [191, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_of_le_of_coeff_ne_zero", "code": "theorem natDegree_eq_of_le_of_coeff_ne_zero (pn : p.natDegree \u2264 n) (p1 : p.coeff n \u2260 0) :\n    p.natDegree = n", "start": [194, 1], "end": [196, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mono", "code": "theorem degree_mono [Semiring S] {f : R[X]} {g : S[X]} (h : f.support \u2286 g.support) :\n    f.degree \u2264 g.degree", "start": [199, 1], "end": [201, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.supp_subset_range", "code": "theorem supp_subset_range (h : natDegree p < m) : p.support \u2286 Finset.range m", "start": [204, 1], "end": [205, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.supp_subset_range_natDegree_succ", "code": "theorem supp_subset_range_natDegree_succ : p.support \u2286 Finset.range (natDegree p + 1)", "start": [208, 1], "end": [209, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_degree", "code": "theorem degree_le_degree (h : coeff q (natDegree p) \u2260 0) : degree p \u2264 degree q", "start": [212, 1], "end": [217, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_le_iff_degree_le", "code": "theorem natDegree_le_iff_degree_le {n : \u2115} : natDegree p \u2264 n \u2194 degree p \u2264 n", "start": [220, 1], "end": [221, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_lt_iff_degree_lt", "code": "theorem natDegree_lt_iff_degree_lt (hp : p \u2260 0) : p.natDegree < n \u2194 p.degree < \u2191n", "start": [224, 1], "end": [225, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_of_natDegree_le", "code": "alias \u27e8degree_le_of_natDegree_le, natDegree_le_of_degree_le\u27e9 := natDegree_le_iff_degree_le", "start": [228, 1], "end": [228, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Polynomial.natDegree_le_of_degree_le", "code": "alias \u27e8degree_le_of_natDegree_le, natDegree_le_of_degree_le\u27e9 := natDegree_le_iff_degree_le", "start": [228, 1], "end": [228, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Polynomial.natDegree_le_natDegree", "code": "theorem natDegree_le_natDegree [Semiring S] {q : S[X]} (hpq : p.degree \u2264 q.degree) :\n    p.natDegree \u2264 q.natDegree", "start": [232, 1], "end": [234, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_lt_natDegree", "code": "theorem natDegree_lt_natDegree {p q : R[X]} (hp : p \u2260 0) (hpq : p.degree < q.degree) :\n    p.natDegree < q.natDegree", "start": [237, 1], "end": [241, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C", "code": "@[simp]\ntheorem degree_C (ha : a \u2260 0) : degree (C a) = (0 : WithBot \u2115)", "start": [244, 1], "end": [247, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_le", "code": "theorem degree_C_le : degree (C a) \u2264 0", "start": [250, 1], "end": [254, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_lt", "code": "theorem degree_C_lt : degree (C a) < 1", "start": [257, 1], "end": [258, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_one_le", "code": "theorem degree_one_le : degree (1 : R[X]) \u2264 (0 : WithBot \u2115)", "start": [261, 1], "end": [261, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C", "code": "@[simp]\ntheorem natDegree_C (a : R) : natDegree (C a) = 0", "start": [264, 1], "end": [271, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_one", "code": "@[simp]\ntheorem natDegree_one : natDegree (1 : R[X]) = 0", "start": [274, 1], "end": [276, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_nat_cast", "code": "@[simp]\ntheorem natDegree_nat_cast (n : \u2115) : natDegree (n : R[X]) = 0", "start": [279, 1], "end": [281, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_nat_cast_le", "code": "theorem degree_nat_cast_le (n : \u2115) : degree (n : R[X]) \u2264 0", "start": [284, 1], "end": [284, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_monomial", "code": "@[simp]\ntheorem degree_monomial (n : \u2115) (ha : a \u2260 0) : degree (monomial n a) = n", "start": [286, 1], "end": [288, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_mul_X_pow", "code": "@[simp]\ntheorem degree_C_mul_X_pow (n : \u2115) (ha : a \u2260 0) : degree (C a * X ^ n) = n", "start": [291, 1], "end": [293, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_mul_X", "code": "theorem degree_C_mul_X (ha : a \u2260 0) : degree (C a * X) = 1", "start": [296, 1], "end": [297, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_monomial_le", "code": "theorem degree_monomial_le (n : \u2115) (a : R) : degree (monomial n a) \u2264 n", "start": [300, 1], "end": [303, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_mul_X_pow_le", "code": "theorem degree_C_mul_X_pow_le (n : \u2115) (a : R) : degree (C a * X ^ n) \u2264 n", "start": [306, 1], "end": [308, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_mul_X_le", "code": "theorem degree_C_mul_X_le (a : R) : degree (C a * X) \u2264 1", "start": [311, 1], "end": [312, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_X_pow", "code": "@[simp]\ntheorem natDegree_C_mul_X_pow (n : \u2115) (a : R) (ha : a \u2260 0) : natDegree (C a * X ^ n) = n", "start": [315, 1], "end": [317, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_X", "code": "@[simp]\ntheorem natDegree_C_mul_X (a : R) (ha : a \u2260 0) : natDegree (C a * X) = 1", "start": [320, 1], "end": [322, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_monomial", "code": "@[simp]\ntheorem natDegree_monomial [DecidableEq R] (i : \u2115) (r : R) :\n    natDegree (monomial i r) = if r = 0 then 0 else i", "start": [325, 1], "end": [330, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_monomial_le", "code": "theorem natDegree_monomial_le (a : R) {m : \u2115} : (monomial m a).natDegree \u2264 m", "start": [333, 1], "end": [337, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_monomial_eq", "code": "theorem natDegree_monomial_eq (i : \u2115) {r : R} (r0 : r \u2260 0) : (monomial i r).natDegree = i", "start": [340, 1], "end": [342, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_eq_zero_of_degree_lt", "code": "theorem coeff_eq_zero_of_degree_lt (h : degree p < n) : coeff p n = 0", "start": [345, 1], "end": [346, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_eq_zero_of_natDegree_lt", "code": "theorem coeff_eq_zero_of_natDegree_lt {p : R[X]} {n : \u2115} (h : p.natDegree < n) :\n    p.coeff n = 0", "start": [349, 1], "end": [355, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ext_iff_natDegree_le", "code": "theorem ext_iff_natDegree_le {p q : R[X]} {n : \u2115} (hp : p.natDegree \u2264 n) (hq : q.natDegree \u2264 n) :\n    p = q \u2194 \u2200 i \u2264 n, p.coeff i = q.coeff i", "start": [358, 1], "end": [365, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ext_iff_degree_le", "code": "theorem ext_iff_degree_le {p q : R[X]} {n : \u2115} (hp : p.degree \u2264 n) (hq : q.degree \u2264 n) :\n    p = q \u2194 \u2200 i \u2264 n, p.coeff i = q.coeff i", "start": [368, 1], "end": [370, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_natDegree_succ_eq_zero", "code": "@[simp]\ntheorem coeff_natDegree_succ_eq_zero {p : R[X]} : p.coeff (p.natDegree + 1) = 0", "start": [373, 1], "end": [375, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ite_le_natDegree_coeff", "code": "theorem ite_le_natDegree_coeff (p : R[X]) (n : \u2115) (I : Decidable (n < 1 + natDegree p)) :\n    @ite _ (n < 1 + natDegree p) I (coeff p n) 0 = coeff p n", "start": [379, 1], "end": [383, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.as_sum_support", "code": "theorem as_sum_support (p : R[X]) : p = \u2211 i in p.support, monomial i (p.coeff i)", "start": [386, 1], "end": [387, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.as_sum_support_C_mul_X_pow", "code": "theorem as_sum_support_C_mul_X_pow (p : R[X]) : p = \u2211 i in p.support, C (p.coeff i) * X ^ i", "start": [390, 1], "end": [391, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_over_range'", "code": "theorem sum_over_range' [AddCommMonoid S] (p : R[X]) {f : \u2115 \u2192 R \u2192 S} (h : \u2200 n, f n 0 = 0) (n : \u2115)\n    (w : p.natDegree < n) : p.sum f = \u2211 a : \u2115 in range n, f a (coeff p a)", "start": [394, 1], "end": [402, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_over_range", "code": "theorem sum_over_range [AddCommMonoid S] (p : R[X]) {f : \u2115 \u2192 R \u2192 S} (h : \u2200 n, f n 0 = 0) :\n    p.sum f = \u2211 a : \u2115 in range (p.natDegree + 1), f a (coeff p a)", "start": [405, 1], "end": [409, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_fin", "code": "theorem sum_fin [AddCommMonoid S] (f : \u2115 \u2192 R \u2192 S) (hf : \u2200 i, f i 0 = 0) {n : \u2115} {p : R[X]}\n    (hn : p.degree < n) : (\u2211 i : Fin n, f i (p.coeff i)) = p.sum f", "start": [413, 1], "end": [420, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.as_sum_range'", "code": "theorem as_sum_range' (p : R[X]) (n : \u2115) (w : p.natDegree < n) :\n    p = \u2211 i in range n, monomial i (coeff p i)", "start": [423, 1], "end": [425, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.as_sum_range", "code": "theorem as_sum_range (p : R[X]) : p = \u2211 i in range (p.natDegree + 1), monomial i (coeff p i)", "start": [428, 1], "end": [429, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.as_sum_range_C_mul_X_pow", "code": "theorem as_sum_range_C_mul_X_pow (p : R[X]) :\n    p = \u2211 i in range (p.natDegree + 1), C (coeff p i) * X ^ i", "start": [432, 1], "end": [434, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_ne_zero_of_eq_degree", "code": "theorem coeff_ne_zero_of_eq_degree (hn : degree p = n) : coeff p n \u2260 0", "start": [437, 1], "end": [438, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_X_add_C_of_degree_le_one", "code": "theorem eq_X_add_C_of_degree_le_one (h : degree p \u2264 1) : p = C (p.coeff 1) * X + C (p.coeff 0)", "start": [441, 1], "end": [449, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_X_add_C_of_degree_eq_one", "code": "theorem eq_X_add_C_of_degree_eq_one (h : degree p = 1) :\n    p = C p.leadingCoeff * X + C (p.coeff 0)", "start": [452, 1], "end": [455, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_X_add_C_of_natDegree_le_one", "code": "theorem eq_X_add_C_of_natDegree_le_one (h : natDegree p \u2264 1) :\n    p = C (p.coeff 1) * X + C (p.coeff 0)", "start": [458, 1], "end": [460, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.eq_X_add_C", "code": "theorem Monic.eq_X_add_C (hm : p.Monic) (hnd : p.natDegree = 1) : p = X + C (p.coeff 0)", "start": [463, 1], "end": [464, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_eq_X_add_C_of_natDegree_le_one", "code": "theorem exists_eq_X_add_C_of_natDegree_le_one (h : natDegree p \u2264 1) : \u2203 a b, p = C a * X + C b", "start": [467, 1], "end": [468, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_pow_le", "code": "theorem degree_X_pow_le (n : \u2115) : degree (X ^ n : R[X]) \u2264 n", "start": [471, 1], "end": [472, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_le", "code": "theorem degree_X_le : degree (X : R[X]) \u2264 1", "start": [475, 1], "end": [476, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_le", "code": "theorem natDegree_X_le : (X : R[X]).natDegree \u2264 1", "start": [479, 1], "end": [480, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_support_C_mul_X_pow", "code": "theorem mem_support_C_mul_X_pow {n a : \u2115} {c : R} (h : a \u2208 support (C c * X ^ n)) : a = n", "start": [483, 1], "end": [484, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_C_mul_X_pow_le_one", "code": "theorem card_support_C_mul_X_pow_le_one {c : R} {n : \u2115} : card (support (C c * X ^ n)) \u2264 1", "start": [487, 1], "end": [489, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_supp_le_succ_natDegree", "code": "theorem card_supp_le_succ_natDegree (p : R[X]) : p.support.card \u2264 p.natDegree + 1", "start": [492, 1], "end": [494, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_degree_of_mem_supp", "code": "theorem le_degree_of_mem_supp (a : \u2115) : a \u2208 p.support \u2192 \u2191a \u2264 degree p", "start": [497, 1], "end": [498, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nonempty_support_iff", "code": "theorem nonempty_support_iff : p.support.Nonempty \u2194 p \u2260 0", "start": [501, 1], "end": [502, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_one", "code": "@[simp]\ntheorem degree_one : degree (1 : R[X]) = (0 : WithBot \u2115)", "start": [511, 1], "end": [513, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X", "code": "@[simp]\ntheorem degree_X : degree (X : R[X]) = 1", "start": [516, 1], "end": [518, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X", "code": "@[simp]\ntheorem natDegree_X : (X : R[X]).natDegree = 1", "start": [521, 1], "end": [523, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_X_sub_C", "code": "theorem coeff_mul_X_sub_C {p : R[X]} {r : R} {a : \u2115} :\n    coeff (p * (X - C r)) (a + 1) = coeff p a - coeff p (a + 1) * r", "start": [532, 1], "end": [533, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_neg", "code": "@[simp]\ntheorem degree_neg (p : R[X]) : degree (-p) = degree p", "start": [536, 1], "end": [537, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_neg_le_of_le", "code": "theorem degree_neg_le_of_le {a : WithBot \u2115} {p : R[X]} (hp : degree p \u2264 a) : degree (-p) \u2264 a", "start": [540, 1], "end": [541, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_neg", "code": "@[simp]\ntheorem natDegree_neg (p : R[X]) : natDegree (-p) = natDegree p", "start": [543, 1], "end": [544, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_neg_le_of_le", "code": "theorem natDegree_neg_le_of_le {p : R[X]} (hp : natDegree p \u2264 m) : natDegree (-p) \u2264 m", "start": [547, 1], "end": [548, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_int_cast", "code": "@[simp]\ntheorem natDegree_int_cast (n : \u2124) : natDegree (n : R[X]) = 0", "start": [550, 1], "end": [552, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_int_cast_le", "code": "theorem degree_int_cast_le (n : \u2124) : degree (n : R[X]) \u2264 0", "start": [555, 1], "end": [555, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_neg", "code": "@[simp]\ntheorem leadingCoeff_neg (p : R[X]) : (-p).leadingCoeff = -p.leadingCoeff", "start": [557, 1], "end": [559, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff", "code": "def nextCoeff (p : R[X]) : R :=\n  if p.natDegree = 0 then 0 else p.coeff (p.natDegree - 1)", "start": [568, 1], "end": [570, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff_C_eq_zero", "code": "@[simp]\ntheorem nextCoeff_C_eq_zero (c : R) : nextCoeff (C c) = 0", "start": [573, 1], "end": [576, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff_of_pos_natDegree", "code": "theorem nextCoeff_of_pos_natDegree (p : R[X]) (hp : 0 < p.natDegree) :\n    nextCoeff p = p.coeff (p.natDegree - 1)", "start": [579, 1], "end": [583, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_natDegree_eq_zero_of_degree_lt", "code": "theorem coeff_natDegree_eq_zero_of_degree_lt (h : degree p < degree q) :\n    coeff p (natDegree q) = 0", "start": [588, 1], "end": [590, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_degree_gt", "code": "theorem ne_zero_of_degree_gt {n : WithBot \u2115} (h : n < degree p) : p \u2260 0", "start": [593, 1], "end": [594, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_degree_ge_degree", "code": "theorem ne_zero_of_degree_ge_degree (hpq : p.degree \u2264 q.degree) (hp : p \u2260 0) : q \u2260 0", "start": [597, 1], "end": [600, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_natDegree_gt", "code": "theorem ne_zero_of_natDegree_gt {n : \u2115} (h : n < natDegree p) : p \u2260 0", "start": [603, 1], "end": [604, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_lt_degree", "code": "theorem degree_lt_degree (h : natDegree p < natDegree q) : degree p < degree q", "start": [607, 1], "end": [613, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_lt_natDegree_iff", "code": "theorem natDegree_lt_natDegree_iff (hp : p \u2260 0) : natDegree p < natDegree q \u2194 degree p < degree q", "start": [616, 1], "end": [619, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_of_degree_le_zero", "code": "theorem eq_C_of_degree_le_zero (h : degree p \u2264 0) : p = C (coeff p 0)", "start": [622, 1], "end": [626, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_of_degree_eq_zero", "code": "theorem eq_C_of_degree_eq_zero (h : degree p = 0) : p = C (coeff p 0)", "start": [629, 1], "end": [630, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_zero_iff", "code": "theorem degree_le_zero_iff : degree p \u2264 0 \u2194 p = C (coeff p 0)", "start": [633, 1], "end": [634, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_le", "code": "theorem degree_add_le (p q : R[X]) : degree (p + q) \u2264 max (degree p) (degree q)", "start": [637, 1], "end": [639, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_le_of_degree_le", "code": "theorem degree_add_le_of_degree_le {p q : R[X]} {n : \u2115} (hp : degree p \u2264 n) (hq : degree q \u2264 n) :\n    degree (p + q) \u2264 n", "start": [642, 1], "end": [644, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_le_of_le", "code": "theorem degree_add_le_of_le {a b : WithBot \u2115} (hp : degree p \u2264 a) (hq : degree q \u2264 b) :\n    degree (p + q) \u2264 max a b", "start": [647, 1], "end": [649, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_le", "code": "theorem natDegree_add_le (p q : R[X]) : natDegree (p + q) \u2264 max (natDegree p) (natDegree q)", "start": [651, 1], "end": [652, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_le_of_degree_le", "code": "theorem natDegree_add_le_of_degree_le {p q : R[X]} {n : \u2115} (hp : natDegree p \u2264 n)\n    (hq : natDegree q \u2264 n) : natDegree (p + q) \u2264 n", "start": [655, 1], "end": [657, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_le_of_le", "code": "theorem natDegree_add_le_of_le (hp : natDegree p \u2264 m) (hq : natDegree q \u2264 n) :\n    natDegree (p + q) \u2264 max m n", "start": [660, 1], "end": [662, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_zero", "code": "@[simp]\ntheorem leadingCoeff_zero : leadingCoeff (0 : R[X]) = 0", "start": [664, 1], "end": [666, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_eq_zero", "code": "@[simp]\ntheorem leadingCoeff_eq_zero : leadingCoeff p = 0 \u2194 p = 0", "start": [669, 1], "end": [674, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_ne_zero", "code": "theorem leadingCoeff_ne_zero : leadingCoeff p \u2260 0 \u2194 p \u2260 0", "start": [677, 1], "end": [677, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_eq_zero_iff_deg_eq_bot", "code": "theorem leadingCoeff_eq_zero_iff_deg_eq_bot : leadingCoeff p = 0 \u2194 degree p = \u22a5", "start": [680, 1], "end": [681, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mem_support_of_nonzero", "code": "theorem natDegree_mem_support_of_nonzero (H : p \u2260 0) : p.natDegree \u2208 p.support", "start": [684, 1], "end": [686, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_support_max'", "code": "theorem natDegree_eq_support_max' (h : p \u2260 0) :\n    p.natDegree = p.support.max' (nonempty_support_iff.mpr h)", "start": [689, 1], "end": [692, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_X_pow_le", "code": "theorem natDegree_C_mul_X_pow_le (a : R) (n : \u2115) : natDegree (C a * X ^ n) \u2264 n", "start": [695, 1], "end": [696, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_eq_left_of_degree_lt", "code": "theorem degree_add_eq_left_of_degree_lt (h : degree q < degree p) : degree (p + q) = degree p", "start": [699, 1], "end": [703, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_eq_right_of_degree_lt", "code": "theorem degree_add_eq_right_of_degree_lt (h : degree p < degree q) : degree (p + q) = degree q", "start": [706, 1], "end": [707, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_eq_left_of_natDegree_lt", "code": "theorem natDegree_add_eq_left_of_natDegree_lt (h : natDegree q < natDegree p) :\n    natDegree (p + q) = natDegree p", "start": [710, 1], "end": [712, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_eq_right_of_natDegree_lt", "code": "theorem natDegree_add_eq_right_of_natDegree_lt (h : natDegree p < natDegree q) :\n    natDegree (p + q) = natDegree q", "start": [715, 1], "end": [717, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_C", "code": "theorem degree_add_C (hp : 0 < degree p) : degree (p + C a) = degree p", "start": [720, 1], "end": [721, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_C", "code": "@[simp] theorem natDegree_add_C {a : R} : (p + C a).natDegree = p.natDegree", "start": [724, 1], "end": [730, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_add", "code": "@[simp] theorem natDegree_C_add {a : R} : (C a + p).natDegree = p.natDegree", "start": [732, 1], "end": [733, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_eq_of_leadingCoeff_add_ne_zero", "code": "theorem degree_add_eq_of_leadingCoeff_add_ne_zero (h : leadingCoeff p + leadingCoeff q \u2260 0) :\n    degree (p + q) = max p.degree q.degree", "start": [735, 1], "end": [749, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_erase_le", "code": "theorem degree_erase_le (p : R[X]) (n : \u2115) : degree (p.erase n) \u2264 degree p", "start": [752, 1], "end": [758, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_erase_lt", "code": "theorem degree_erase_lt (hp : p \u2260 0) : degree (p.erase (natDegree p)) < degree p", "start": [761, 1], "end": [764, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_update_le", "code": "theorem degree_update_le (p : R[X]) (n : \u2115) (a : R) : degree (p.update n a) \u2264 max (degree p) n", "start": [767, 1], "end": [773, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sum_le", "code": "theorem degree_sum_le (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) :\n    degree (\u2211 i in s, f i) \u2264 s.sup fun b => degree (f b)", "start": [776, 1], "end": [783, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_le", "code": "theorem degree_mul_le (p q : R[X]) : degree (p * q) \u2264 degree p + degree q", "start": [786, 1], "end": [788, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_le_of_le", "code": "theorem degree_mul_le_of_le {a b : WithBot \u2115} (hp : degree p \u2264 a) (hq : degree q \u2264 b) :\n    degree (p * q) \u2264 a + b", "start": [791, 1], "end": [793, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pow_le", "code": "theorem degree_pow_le (p : R[X]) : \u2200 n : \u2115, degree (p ^ n) \u2264 n \u2022 degree p", "start": [795, 1], "end": [801, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pow_le_of_le", "code": "theorem degree_pow_le_of_le {a : WithBot \u2115} (b : \u2115) (hp : degree p \u2264 a) :\n    degree (p ^ b) \u2264 b * a", "start": [804, 1], "end": [810, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_monomial", "code": "@[simp]\ntheorem leadingCoeff_monomial (a : R) (n : \u2115) : leadingCoeff (monomial n a) = a", "start": [812, 1], "end": [818, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_C_mul_X_pow", "code": "theorem leadingCoeff_C_mul_X_pow (a : R) (n : \u2115) : leadingCoeff (C a * X ^ n) = a", "start": [821, 1], "end": [822, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_C_mul_X", "code": "theorem leadingCoeff_C_mul_X (a : R) : leadingCoeff (C a * X) = a", "start": [825, 1], "end": [826, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_C", "code": "@[simp]\ntheorem leadingCoeff_C (a : R) : leadingCoeff (C a) = a", "start": [829, 1], "end": [831, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_pow", "code": "theorem leadingCoeff_X_pow (n : \u2115) : leadingCoeff ((X : R[X]) ^ n) = 1", "start": [835, 1], "end": [836, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X", "code": "theorem leadingCoeff_X : leadingCoeff (X : R[X]) = 1", "start": [840, 1], "end": [841, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_pow", "code": "@[simp]\ntheorem monic_X_pow (n : \u2115) : Monic (X ^ n : R[X])", "start": [844, 1], "end": [846, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X", "code": "@[simp]\ntheorem monic_X : Monic (X : R[X])", "start": [849, 1], "end": [851, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_one", "code": "theorem leadingCoeff_one : leadingCoeff (1 : R[X]) = 1", "start": [855, 1], "end": [856, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_one", "code": "@[simp]\ntheorem monic_one : Monic (1 : R[X])", "start": [859, 1], "end": [861, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.ne_zero", "code": "theorem Monic.ne_zero {R : Type*} [Semiring R] [Nontrivial R] {p : R[X]} (hp : p.Monic) :\n    p \u2260 0", "start": [864, 1], "end": [867, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.ne_zero_of_ne", "code": "theorem Monic.ne_zero_of_ne (h : (0 : R) \u2260 1) {p : R[X]} (hp : p.Monic) : p \u2260 0", "start": [870, 1], "end": [872, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_natDegree_le_of_coeff_eq_one", "code": "theorem monic_of_natDegree_le_of_coeff_eq_one (n : \u2115) (pn : p.natDegree \u2264 n) (p1 : p.coeff n = 1) :\n    Monic p", "start": [875, 1], "end": [880, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_degree_le_of_coeff_eq_one", "code": "theorem monic_of_degree_le_of_coeff_eq_one (n : \u2115) (pn : p.degree \u2264 n) (p1 : p.coeff n = 1) :\n    Monic p", "start": [883, 1], "end": [885, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.ne_zero_of_polynomial_ne", "code": "theorem Monic.ne_zero_of_polynomial_ne {r} (hp : Monic p) (hne : q \u2260 r) : p \u2260 0", "start": [888, 1], "end": [890, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_add_of_degree_lt", "code": "theorem leadingCoeff_add_of_degree_lt (h : degree p < degree q) :\n    leadingCoeff (p + q) = leadingCoeff q", "start": [893, 1], "end": [897, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_add_of_degree_lt'", "code": "theorem leadingCoeff_add_of_degree_lt' (h : degree q < degree p) :\n    leadingCoeff (p + q) = leadingCoeff p", "start": [900, 1], "end": [903, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_add_of_degree_eq", "code": "theorem leadingCoeff_add_of_degree_eq (h : degree p = degree q)\n    (hlc : leadingCoeff p + leadingCoeff q \u2260 0) :\n    leadingCoeff (p + q) = leadingCoeff p + leadingCoeff q", "start": [905, 1], "end": [911, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_degree_add_degree", "code": "@[simp]\ntheorem coeff_mul_degree_add_degree (p q : R[X]) :\n    coeff (p * q) (natDegree p + natDegree q) = leadingCoeff p * leadingCoeff q", "start": [914, 1], "end": [947, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul'", "code": "theorem degree_mul' (h : leadingCoeff p * leadingCoeff q \u2260 0) :\n    degree (p * q) = degree p + degree q", "start": [950, 1], "end": [958, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.degree_mul", "code": "theorem Monic.degree_mul (hq : Monic q) : degree (p * q) = degree p + degree q", "start": [961, 1], "end": [964, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul'", "code": "theorem natDegree_mul' (h : leadingCoeff p * leadingCoeff q \u2260 0) :\n    natDegree (p * q) = natDegree p + natDegree q", "start": [967, 1], "end": [972, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_mul'", "code": "theorem leadingCoeff_mul' (h : leadingCoeff p * leadingCoeff q \u2260 0) :\n    leadingCoeff (p * q) = leadingCoeff p * leadingCoeff q", "start": [975, 1], "end": [979, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_natDegree_leadingCoeff_eq_self", "code": "theorem monomial_natDegree_leadingCoeff_eq_self (h : p.support.card \u2264 1) :\n    monomial p.natDegree p.leadingCoeff = p", "start": [982, 1], "end": [986, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_X_pow_eq_self", "code": "theorem C_mul_X_pow_eq_self (h : p.support.card \u2264 1) : C p.leadingCoeff * X ^ p.natDegree = p", "start": [989, 1], "end": [990, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_pow'", "code": "theorem leadingCoeff_pow' : leadingCoeff p ^ n \u2260 0 \u2192 leadingCoeff (p ^ n) = leadingCoeff p ^ n", "start": [993, 1], "end": [997, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pow'", "code": "theorem degree_pow' : \u2200 {n : \u2115}, leadingCoeff p ^ n \u2260 0 \u2192 degree (p ^ n) = n \u2022 degree p", "start": [1000, 1], "end": [1006, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pow'", "code": "theorem natDegree_pow' {n : \u2115} (h : leadingCoeff p ^ n \u2260 0) : natDegree (p ^ n) = n * natDegree p", "start": [1009, 1], "end": [1019, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_monic_mul", "code": "theorem leadingCoeff_monic_mul {p q : R[X]} (hp : Monic p) :\n    leadingCoeff (p * q) = leadingCoeff q", "start": [1022, 1], "end": [1027, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_mul_monic", "code": "theorem leadingCoeff_mul_monic {p q : R[X]} (hq : Monic q) :\n    leadingCoeff (p * q) = leadingCoeff p", "start": [1030, 1], "end": [1038, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_mul_X_pow", "code": "@[simp]\ntheorem leadingCoeff_mul_X_pow {p : R[X]} {n : \u2115} : leadingCoeff (p * X ^ n) = leadingCoeff p", "start": [1041, 1], "end": [1043, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_mul_X", "code": "@[simp]\ntheorem leadingCoeff_mul_X {p : R[X]} : leadingCoeff (p * X) = leadingCoeff p", "start": [1046, 1], "end": [1048, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_le", "code": "theorem natDegree_mul_le {p q : R[X]} : natDegree (p * q) \u2264 natDegree p + natDegree q", "start": [1051, 1], "end": [1055, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_le_of_le", "code": "theorem natDegree_mul_le_of_le (hp : natDegree p \u2264 m) (hg : natDegree q \u2264 n) :\n    natDegree (p * q) \u2264 m + n", "start": [1058, 1], "end": [1060, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pow_le", "code": "theorem natDegree_pow_le {p : R[X]} {n : \u2115} : (p ^ n).natDegree \u2264 n * p.natDegree", "start": [1062, 1], "end": [1067, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pow_le_of_le", "code": "theorem natDegree_pow_le_of_le (n : \u2115) (hp : natDegree p \u2264 m) :\n    natDegree (p ^ n) \u2264 n * m", "start": [1070, 1], "end": [1072, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_pow_mul_natDegree", "code": "@[simp]\ntheorem coeff_pow_mul_natDegree (p : R[X]) (n : \u2115) :\n    (p ^ n).coeff (n * p.natDegree) = p.leadingCoeff ^ n", "start": [1074, 1], "end": [1094, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_add_eq_of_natDegree_le", "code": "theorem coeff_mul_add_eq_of_natDegree_le {df dg : \u2115} {g : R[X]}\n    (hdf : natDegree f \u2264 df) (hdg : natDegree g \u2264 dg) :\n    (f * g).coeff (df + dg) = f.coeff df * g.coeff dg", "start": [1097, 1], "end": [1109, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_le_degree_iff", "code": "theorem zero_le_degree_iff : 0 \u2264 degree p \u2194 p \u2260 0", "start": [1111, 1], "end": [1112, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_zero_iff_degree_le_zero", "code": "theorem natDegree_eq_zero_iff_degree_le_zero : p.natDegree = 0 \u2194 p.degree \u2264 0", "start": [1115, 1], "end": [1116, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_zero_le", "code": "theorem degree_zero_le : degree (0 : R[X]) \u2264 0", "start": [1119, 1], "end": [1119, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_iff_coeff_zero", "code": "theorem degree_le_iff_coeff_zero (f : R[X]) (n : WithBot \u2115) :\n    degree f \u2264 n \u2194 \u2200 m : \u2115, n < m \u2192 coeff f m = 0", "start": [1121, 1], "end": [1125, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_lt_iff_coeff_zero", "code": "theorem degree_lt_iff_coeff_zero (f : R[X]) (n : \u2115) :\n    degree f < n \u2194 \u2200 m : \u2115, n \u2264 m \u2192 coeff f m = 0", "start": [1128, 1], "end": [1131, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_smul_le", "code": "theorem degree_smul_le (a : R) (p : R[X]) : degree (a \u2022 p) \u2264 degree p", "start": [1134, 1], "end": [1137, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_smul_le", "code": "theorem natDegree_smul_le (a : R) (p : R[X]) : natDegree (a \u2022 p) \u2264 natDegree p", "start": [1140, 1], "end": [1141, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_lt_degree_mul_X", "code": "theorem degree_lt_degree_mul_X (hp : p \u2260 0) : p.degree < (p * X).degree", "start": [1144, 1], "end": [1148, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pos_iff_degree_pos", "code": "theorem natDegree_pos_iff_degree_pos : 0 < natDegree p \u2194 0 < degree p", "start": [1151, 1], "end": [1152, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_of_natDegree_le_zero", "code": "theorem eq_C_of_natDegree_le_zero (h : natDegree p \u2264 0) : p = C (coeff p 0)", "start": [1155, 1], "end": [1156, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_of_natDegree_eq_zero", "code": "theorem eq_C_of_natDegree_eq_zero (h : natDegree p = 0) : p = C (coeff p 0)", "start": [1159, 1], "end": [1160, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_coeff_zero_iff_natDegree_eq_zero", "code": "theorem eq_C_coeff_zero_iff_natDegree_eq_zero : p = C (p.coeff 0) \u2194 p.natDegree = 0", "start": [1163, 1], "end": [1164, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_one_of_monic_natDegree_zero", "code": "theorem eq_one_of_monic_natDegree_zero (hf : p.Monic) (hfd : p.natDegree = 0) : p = 1", "start": [1166, 1], "end": [1168, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_coe_le_degree", "code": "theorem ne_zero_of_coe_le_degree (hdeg : \u2191n \u2264 p.degree) : p \u2260 0", "start": [1170, 1], "end": [1171, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_natDegree_of_coe_le_degree", "code": "theorem le_natDegree_of_coe_le_degree (hdeg : \u2191n \u2264 p.degree) : n \u2264 p.natDegree", "start": [1174, 1], "end": [1177, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sum_fin_lt", "code": "theorem degree_sum_fin_lt {n : \u2115} (f : Fin n \u2192 R) :\n    degree (\u2211 i : Fin n, C (f i) * X ^ (i : \u2115)) < n", "start": [1180, 1], "end": [1184, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_linear_le", "code": "theorem degree_linear_le : degree (C a * X + C b) \u2264 1", "start": [1187, 1], "end": [1188, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_linear_lt", "code": "theorem degree_linear_lt : degree (C a * X + C b) < 2", "start": [1191, 1], "end": [1192, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_lt_degree_C_mul_X", "code": "theorem degree_C_lt_degree_C_mul_X (ha : a \u2260 0) : degree (C b) < degree (C a * X)", "start": [1195, 1], "end": [1196, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_linear", "code": "@[simp]\ntheorem degree_linear (ha : a \u2260 0) : degree (C a * X + C b) = 1", "start": [1199, 1], "end": [1201, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_linear_le", "code": "theorem natDegree_linear_le : natDegree (C a * X + C b) \u2264 1", "start": [1204, 1], "end": [1205, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_linear", "code": "theorem natDegree_linear (ha : a \u2260 0) : natDegree (C a * X + C b) = 1", "start": [1208, 1], "end": [1209, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_linear", "code": "@[simp]\ntheorem leadingCoeff_linear (ha : a \u2260 0) : leadingCoeff (C a * X + C b) = a", "start": [1212, 1], "end": [1215, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_quadratic_le", "code": "theorem degree_quadratic_le : degree (C a * X ^ 2 + C b * X + C c) \u2264 2", "start": [1218, 1], "end": [1221, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_quadratic_lt", "code": "theorem degree_quadratic_lt : degree (C a * X ^ 2 + C b * X + C c) < 3", "start": [1224, 1], "end": [1225, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_linear_lt_degree_C_mul_X_sq", "code": "theorem degree_linear_lt_degree_C_mul_X_sq (ha : a \u2260 0) :\n    degree (C b * X + C c) < degree (C a * X ^ 2)", "start": [1228, 1], "end": [1230, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_quadratic", "code": "@[simp]\ntheorem degree_quadratic (ha : a \u2260 0) : degree (C a * X ^ 2 + C b * X + C c) = 2", "start": [1233, 1], "end": [1237, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_quadratic_le", "code": "theorem natDegree_quadratic_le : natDegree (C a * X ^ 2 + C b * X + C c) \u2264 2", "start": [1240, 1], "end": [1241, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_quadratic", "code": "theorem natDegree_quadratic (ha : a \u2260 0) : natDegree (C a * X ^ 2 + C b * X + C c) = 2", "start": [1244, 1], "end": [1245, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_quadratic", "code": "@[simp]\ntheorem leadingCoeff_quadratic (ha : a \u2260 0) : leadingCoeff (C a * X ^ 2 + C b * X + C c) = a", "start": [1248, 1], "end": [1251, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_cubic_le", "code": "theorem degree_cubic_le : degree (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) \u2264 3", "start": [1254, 1], "end": [1257, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_cubic_lt", "code": "theorem degree_cubic_lt : degree (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) < 4", "start": [1260, 1], "end": [1261, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_quadratic_lt_degree_C_mul_X_cb", "code": "theorem degree_quadratic_lt_degree_C_mul_X_cb (ha : a \u2260 0) :\n    degree (C b * X ^ 2 + C c * X + C d) < degree (C a * X ^ 3)", "start": [1264, 1], "end": [1266, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_cubic", "code": "@[simp]\ntheorem degree_cubic (ha : a \u2260 0) : degree (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) = 3", "start": [1269, 1], "end": [1274, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_cubic_le", "code": "theorem natDegree_cubic_le : natDegree (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) \u2264 3", "start": [1277, 1], "end": [1278, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_cubic", "code": "theorem natDegree_cubic (ha : a \u2260 0) : natDegree (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) = 3", "start": [1281, 1], "end": [1282, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_cubic", "code": "@[simp]\ntheorem leadingCoeff_cubic (ha : a \u2260 0) :\n    leadingCoeff (C a * X ^ 3 + C b * X ^ 2 + C c * X + C d) = a", "start": [1285, 1], "end": [1290, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_pow", "code": "@[simp]\ntheorem degree_X_pow : degree ((X : R[X]) ^ n) = n", "start": [1299, 1], "end": [1301, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_pow", "code": "@[simp]\ntheorem natDegree_X_pow : natDegree ((X : R[X]) ^ n) = n", "start": [1304, 1], "end": [1306, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_X", "code": "@[simp] lemma natDegree_mul_X (hp : p \u2260 0) : natDegree (p * X) = natDegree p + 1 := by\n  rw [natDegree_mul' (by simpa), natDegree_X]", "start": [1309, 1], "end": [1310, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.natDegree_X_mul", "code": "@[simp] lemma natDegree_X_mul (hp : p \u2260 0) : natDegree (X * p) = natDegree p + 1 := by\n  rw [commute_X p, natDegree_mul_X hp]", "start": [1312, 1], "end": [1313, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.natDegree_mul_X_pow", "code": "@[simp] lemma natDegree_mul_X_pow (hp : p \u2260 0) : natDegree (p * X ^ n) = natDegree p + n := by\n  rw [natDegree_mul' (by simpa), natDegree_X_pow]", "start": [1315, 1], "end": [1316, 50], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.natDegree_X_pow_mul", "code": "@[simp] lemma natDegree_X_pow_mul (hp : p \u2260 0) : natDegree (X ^ n * p) = natDegree p + n := by\n  rw [commute_X_pow, natDegree_mul_X_pow n hp]", "start": [1318, 1], "end": [1319, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.natDegree_X_pow_le", "code": "theorem natDegree_X_pow_le {R : Type*} [Semiring R] (n : \u2115) : (X ^ n : R[X]).natDegree \u2264 n", "start": [1322, 1], "end": [1324, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_isUnit_X", "code": "theorem not_isUnit_X : \u00acIsUnit (X : R[X])", "start": [1327, 1], "end": [1330, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_X", "code": "@[simp]\ntheorem degree_mul_X : degree (p * X) = degree p + 1", "start": [1333, 1], "end": [1334, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_X_pow", "code": "@[simp]\ntheorem degree_mul_X_pow : degree (p * X ^ n) = degree p + n", "start": [1337, 1], "end": [1338, 101], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_C", "code": "theorem degree_sub_C (hp : 0 < degree p) : degree (p - C a) = degree p", "start": [1347, 1], "end": [1348, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_C", "code": "@[simp]\ntheorem natDegree_sub_C {a : R} : natDegree (p - C a) = natDegree p", "start": [1350, 1], "end": [1352, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_le", "code": "theorem degree_sub_le (p q : R[X]) : degree (p - q) \u2264 max (degree p) (degree q)", "start": [1354, 1], "end": [1355, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_le_of_le", "code": "theorem degree_sub_le_of_le {a b : WithBot \u2115} (hp : degree p \u2264 a) (hq : degree q \u2264 b) :\n    degree (p - q) \u2264 max a b", "start": [1358, 1], "end": [1360, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_sub_of_degree_lt", "code": "theorem leadingCoeff_sub_of_degree_lt (h : Polynomial.degree q < Polynomial.degree p) :\n    (p - q).leadingCoeff = p.leadingCoeff", "start": [1362, 1], "end": [1365, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_sub_of_degree_lt'", "code": "theorem leadingCoeff_sub_of_degree_lt' (h : Polynomial.degree p < Polynomial.degree q) :\n    (p - q).leadingCoeff = -q.leadingCoeff", "start": [1367, 1], "end": [1370, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_sub_of_degree_eq", "code": "theorem leadingCoeff_sub_of_degree_eq (h : degree p = degree q)\n    (hlc : leadingCoeff p \u2260 leadingCoeff q) :\n    leadingCoeff (p - q) = leadingCoeff p - leadingCoeff q", "start": [1372, 1], "end": [1378, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_le", "code": "theorem natDegree_sub_le (p q : R[X]) : natDegree (p - q) \u2264 max (natDegree p) (natDegree q)", "start": [1380, 1], "end": [1381, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_le_of_le", "code": "theorem natDegree_sub_le_of_le (hp : natDegree p \u2264 m) (hq : natDegree q \u2264 n) :\n    natDegree (p - q) \u2264 max m n", "start": [1384, 1], "end": [1386, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_lt", "code": "theorem degree_sub_lt (hd : degree p = degree q) (hp0 : p \u2260 0)\n    (hlc : leadingCoeff p = leadingCoeff q) : degree (p - q) < degree p", "start": [1388, 1], "end": [1403, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_sub_C_le", "code": "theorem degree_X_sub_C_le (r : R) : (X - C r).degree \u2264 1", "start": [1406, 1], "end": [1407, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_sub_C_le", "code": "theorem natDegree_X_sub_C_le (r : R) : (X - C r).natDegree \u2264 1", "start": [1410, 1], "end": [1411, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_eq_left_of_degree_lt", "code": "theorem degree_sub_eq_left_of_degree_lt (h : degree q < degree p) : degree (p - q) = degree p", "start": [1414, 1], "end": [1416, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sub_eq_right_of_degree_lt", "code": "theorem degree_sub_eq_right_of_degree_lt (h : degree p < degree q) : degree (p - q) = degree q", "start": [1419, 1], "end": [1421, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_eq_left_of_natDegree_lt", "code": "theorem natDegree_sub_eq_left_of_natDegree_lt (h : natDegree q < natDegree p) :\n    natDegree (p - q) = natDegree p", "start": [1424, 1], "end": [1426, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_eq_right_of_natDegree_lt", "code": "theorem natDegree_sub_eq_right_of_natDegree_lt (h : natDegree p < natDegree q) :\n    natDegree (p - q) = natDegree q", "start": [1429, 1], "end": [1431, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_add_C", "code": "@[simp]\ntheorem degree_X_add_C (a : R) : degree (X + C a) = 1", "start": [1444, 1], "end": [1451, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_add_C", "code": "theorem natDegree_X_add_C (x : R) : (X + C x).natDegree = 1", "start": [1454, 1], "end": [1455, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff_X_add_C", "code": "@[simp]\ntheorem nextCoeff_X_add_C [Semiring S] (c : S) : nextCoeff (X + C c) = c", "start": [1458, 1], "end": [1461, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_pow_add_C", "code": "theorem degree_X_pow_add_C {n : \u2115} (hn : 0 < n) (a : R) : degree ((X : R[X]) ^ n + C a) = n", "start": [1464, 1], "end": [1467, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_add_C_ne_zero", "code": "theorem X_pow_add_C_ne_zero {n : \u2115} (hn : 0 < n) (a : R) : (X : R[X]) ^ n + C a \u2260 0", "start": [1470, 1], "end": [1473, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_add_C_ne_zero", "code": "theorem X_add_C_ne_zero (r : R) : X + C r \u2260 0", "start": [1476, 1], "end": [1477, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_nmem_multiset_map_X_add_C", "code": "theorem zero_nmem_multiset_map_X_add_C {\u03b1 : Type*} (m : Multiset \u03b1) (f : \u03b1 \u2192 R) :\n    (0 : R[X]) \u2209 m.map fun a => X + C (f a)", "start": [1480, 1], "end": [1483, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_pow_add_C", "code": "theorem natDegree_X_pow_add_C {n : \u2115} {r : R} : (X ^ n + C r).natDegree = n", "start": [1486, 1], "end": [1489, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_add_C_ne_one", "code": "theorem X_pow_add_C_ne_one {n : \u2115} (hn : 0 < n) (a : R) : (X : R[X]) ^ n + C a \u2260 1", "start": [1492, 1], "end": [1493, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_add_C_ne_one", "code": "theorem X_add_C_ne_one (r : R) : X + C r \u2260 1", "start": [1496, 1], "end": [1497, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_pow_add_C", "code": "@[simp]\ntheorem leadingCoeff_X_pow_add_C {n : \u2115} (hn : 0 < n) {r : R} :\n    (X ^ n + C r).leadingCoeff = 1", "start": [1508, 1], "end": [1513, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_add_C", "code": "@[simp]\ntheorem leadingCoeff_X_add_C [Semiring S] (r : S) : (X + C r).leadingCoeff = 1", "start": [1516, 1], "end": [1518, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_pow_add_one", "code": "@[simp]\ntheorem leadingCoeff_X_pow_add_one {n : \u2115} (hn : 0 < n) : (X ^ n + 1 : R[X]).leadingCoeff = 1", "start": [1521, 1], "end": [1523, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_pow_X_add_C", "code": "@[simp]\ntheorem leadingCoeff_pow_X_add_C (r : R) (i : \u2115) : leadingCoeff ((X + C r) ^ i) = 1", "start": [1526, 1], "end": [1529, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_pow_sub_C", "code": "@[simp]\ntheorem leadingCoeff_X_pow_sub_C {n : \u2115} (hn : 0 < n) {r : R} :\n    (X ^ n - C r).leadingCoeff = 1", "start": [1538, 1], "end": [1541, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_pow_sub_one", "code": "@[simp]\ntheorem leadingCoeff_X_pow_sub_one {n : \u2115} (hn : 0 < n) : (X ^ n - 1 : R[X]).leadingCoeff = 1", "start": [1544, 1], "end": [1546, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_sub_C", "code": "@[simp]\ntheorem degree_X_sub_C (a : R) : degree (X - C a) = 1", "start": [1551, 1], "end": [1553, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_sub_C", "code": "theorem natDegree_X_sub_C (x : R) : (X - C x).natDegree = 1", "start": [1556, 1], "end": [1557, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff_X_sub_C", "code": "@[simp]\ntheorem nextCoeff_X_sub_C [Ring S] (c : S) : nextCoeff (X - C c) = -c", "start": [1560, 1], "end": [1562, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_X_pow_sub_C", "code": "theorem degree_X_pow_sub_C {n : \u2115} (hn : 0 < n) (a : R) : degree ((X : R[X]) ^ n - C a) = n", "start": [1565, 1], "end": [1566, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_sub_C_ne_zero", "code": "theorem X_pow_sub_C_ne_zero {n : \u2115} (hn : 0 < n) (a : R) : (X : R[X]) ^ n - C a \u2260 0", "start": [1569, 1], "end": [1571, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_sub_C_ne_zero", "code": "theorem X_sub_C_ne_zero (r : R) : X - C r \u2260 0", "start": [1574, 1], "end": [1575, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_nmem_multiset_map_X_sub_C", "code": "theorem zero_nmem_multiset_map_X_sub_C {\u03b1 : Type*} (m : Multiset \u03b1) (f : \u03b1 \u2192 R) :\n    (0 : R[X]) \u2209 m.map fun a => X - C (f a)", "start": [1578, 1], "end": [1581, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_X_pow_sub_C", "code": "theorem natDegree_X_pow_sub_C {n : \u2115} {r : R} : (X ^ n - C r).natDegree = n", "start": [1584, 1], "end": [1585, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_X_sub_C", "code": "@[simp]\ntheorem leadingCoeff_X_sub_C [Ring S] (r : S) : (X - C r).leadingCoeff = 1", "start": [1588, 1], "end": [1590, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul", "code": "@[simp]\ntheorem degree_mul : degree (p * q) = degree p + degree q", "start": [1599, 1], "end": [1605, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degreeMonoidHom", "code": "def degreeMonoidHom [Nontrivial R] : R[X] \u2192* Multiplicative (WithBot \u2115)\n    where\n  toFun := degree\n  map_one' := degree_one\n  map_mul' _ _ := degree_mul", "start": [1608, 1], "end": [1614, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pow", "code": "@[simp]\ntheorem degree_pow [Nontrivial R] (p : R[X]) (n : \u2115) : degree (p ^ n) = n \u2022 degree p", "start": [1617, 1], "end": [1619, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_mul", "code": "@[simp]\ntheorem leadingCoeff_mul (p q : R[X]) : leadingCoeff (p * q) = leadingCoeff p * leadingCoeff q", "start": [1622, 1], "end": [1629, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeffHom", "code": "def leadingCoeffHom : R[X] \u2192* R where\n  toFun := leadingCoeff\n  map_one' := by simp\n  map_mul' := leadingCoeff_mul", "start": [1632, 1], "end": [1637, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeffHom_apply", "code": "@[simp]\ntheorem leadingCoeffHom_apply (p : R[X]) : leadingCoeffHom p = leadingCoeff p", "start": [1640, 1], "end": [1642, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_pow", "code": "@[simp]\ntheorem leadingCoeff_pow (p : R[X]) (n : \u2115) : leadingCoeff (p ^ n) = leadingCoeff p ^ n", "start": [1645, 1], "end": [1647, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Induction.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/Data/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {M : R[X] \u2192 Prop} (p : R[X]) (h_C : \u2200 a, M (C a))\n    (h_add : \u2200 p q, M p \u2192 M q \u2192 M (p + q))\n    (h_monomial : \u2200 (n : \u2115) (a : R), M (C a * X ^ n) \u2192 M (C a * X ^ (n + 1))) : M p", "start": [38, 1], "end": [55, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.induction_on'", "code": "@[elab_as_elim]\nprotected theorem induction_on' {M : R[X] \u2192 Prop} (p : R[X]) (h_add : \u2200 p q, M p \u2192 M q \u2192 M (p + q))\n    (h_monomial : \u2200 (n : \u2115) (a : R), M (monomial n a)) : M p", "start": [58, 1], "end": [66, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.span_le_of_C_coeff_mem", "code": "theorem span_le_of_C_coeff_mem (cf : \u2200 i : \u2115, C (f.coeff i) \u2208 I) :\n    Ideal.span { g | \u2203 i, g = C (f.coeff i) } \u2264 I", "start": [73, 1], "end": [78, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_span_C_coeff", "code": "theorem mem_span_C_coeff : f \u2208 Ideal.span { g : R[X] | \u2203 i : \u2115, g = C (coeff f i) }", "start": [82, 1], "end": [94, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_C_coeff_not_mem", "code": "theorem exists_C_coeff_not_mem : f \u2209 I \u2192 \u2203 i : \u2115, C (coeff f i) \u2209 I", "start": [98, 1], "end": [99, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Disjointed.lean", "imports": ["Mathlib/Order/PartialSups.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "disjointed", "code": "def disjointed (f : \u2115 \u2192 \u03b1) : \u2115 \u2192 \u03b1\n  | 0 => f 0\n  | n + 1 => f (n + 1) \\ partialSups f n", "start": [46, 1], "end": [51, 41], "kind": "commanddeclaration"}, {"full_name": "disjointed_zero", "code": "@[simp]\ntheorem disjointed_zero (f : \u2115 \u2192 \u03b1) : disjointed f 0 = f 0", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "disjointed_succ", "code": "theorem disjointed_succ (f : \u2115 \u2192 \u03b1) (n : \u2115) : disjointed f (n + 1) = f (n + 1) \\ partialSups f n", "start": [59, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "disjointed_le_id", "code": "theorem disjointed_le_id : disjointed \u2264 (id : (\u2115 \u2192 \u03b1) \u2192 \u2115 \u2192 \u03b1)", "start": [63, 1], "end": [67, 19], "kind": "commanddeclaration"}, {"full_name": "disjointed_le", "code": "theorem disjointed_le (f : \u2115 \u2192 \u03b1) : disjointed f \u2264 f", "start": [70, 1], "end": [71, 21], "kind": "commanddeclaration"}, {"full_name": "disjoint_disjointed", "code": "theorem disjoint_disjointed (f : \u2115 \u2192 \u03b1) : Pairwise (Disjoint on disjointed f)", "start": [74, 1], "end": [80, 84], "kind": "commanddeclaration"}, {"full_name": "disjointedRec", "code": "def disjointedRec {f : \u2115 \u2192 \u03b1} {p : \u03b1 \u2192 Sort*} (hdiff : \u2200 \u2983t i\u2984, p t \u2192 p (t \\ f i)) :\n    \u2200 \u2983n\u2984, p (f n) \u2192 p (disjointed f n)\n  | 0 => id\n  | n + 1 => fun h => by\n    suffices H : \u2200 k, p (f (n + 1) \\ partialSups f k) from H n\n    rintro k\n    induction' k with k ih\n    \u00b7 exact hdiff h\n    rw [partialSups_succ, \u2190 sdiff_sdiff_left]\n    exact hdiff ih", "start": [84, 1], "end": [95, 19], "kind": "commanddeclaration"}, {"full_name": "disjointedRec_zero", "code": "@[simp]\ntheorem disjointedRec_zero {f : \u2115 \u2192 \u03b1} {p : \u03b1 \u2192 Sort*} (hdiff : \u2200 \u2983t i\u2984, p t \u2192 p (t \\ f i))\n    (h\u2080 : p (f 0)) : disjointedRec hdiff h\u2080 = h\u2080", "start": [98, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Monotone.disjointed_eq", "code": "theorem Monotone.disjointed_eq {f : \u2115 \u2192 \u03b1} (hf : Monotone f) (n : \u2115) :\n    disjointed f (n + 1) = f (n + 1) \\ f n", "start": [105, 1], "end": [106, 89], "kind": "commanddeclaration"}, {"full_name": "partialSups_disjointed", "code": "@[simp]\ntheorem partialSups_disjointed (f : \u2115 \u2192 \u03b1) : partialSups (disjointed f) = partialSups f", "start": [109, 1], "end": [114, 87], "kind": "commanddeclaration"}, {"full_name": "disjointed_unique", "code": "theorem disjointed_unique {f d : \u2115 \u2192 \u03b1} (hdisj : Pairwise (Disjoint on d))\n    (hsups : partialSups d = partialSups f) : d = disjointed f", "start": [117, 1], "end": [132, 69], "kind": "commanddeclaration"}, {"full_name": "iSup_disjointed", "code": "theorem iSup_disjointed (f : \u2115 \u2192 \u03b1) : \u2a06 n, disjointed f n = \u2a06 n, f n", "start": [141, 1], "end": [142, 72], "kind": "commanddeclaration"}, {"full_name": "disjointed_eq_inf_compl", "code": "theorem disjointed_eq_inf_compl (f : \u2115 \u2192 \u03b1) (n : \u2115) : disjointed f n = f n \u2293 \u2a05 i < n, (f i)\u1d9c", "start": [145, 1], "end": [153, 23], "kind": "commanddeclaration"}, {"full_name": "disjointed_subset", "code": "theorem disjointed_subset (f : \u2115 \u2192 Set \u03b1) (n : \u2115) : disjointed f n \u2286 f n", "start": [161, 1], "end": [162, 20], "kind": "commanddeclaration"}, {"full_name": "iUnion_disjointed", "code": "theorem iUnion_disjointed {f : \u2115 \u2192 Set \u03b1} : \u22c3 n, disjointed f n = \u22c3 n, f n", "start": [165, 1], "end": [166, 20], "kind": "commanddeclaration"}, {"full_name": "disjointed_eq_inter_compl", "code": "theorem disjointed_eq_inter_compl (f : \u2115 \u2192 Set \u03b1) (n : \u2115) :\n    disjointed f n = f n \u2229 \u22c2 i < n, (f i)\u1d9c", "start": [169, 1], "end": [171, 30], "kind": "commanddeclaration"}, {"full_name": "preimage_find_eq_disjointed", "code": "theorem preimage_find_eq_disjointed (s : \u2115 \u2192 Set \u03b1) (H : \u2200 x, \u2203 n, x \u2208 s n)\n    [\u2200 x n, Decidable (x \u2208 s n)] (n : \u2115) : (fun x => Nat.find (H x)) \u207b\u00b9' {n} = disjointed s n", "start": [174, 1], "end": [177, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Measurability.lean", "imports": ["Mathlib/Tactic/Measurability/Init.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "midpoint", "code": "def midpoint (x y : P) : P :=\n  lineMap x y (\u215f 2 : R)", "start": [42, 1], "end": [44, 24], "kind": "commanddeclaration"}, {"full_name": "AffineMap.map_midpoint", "code": "@[simp]\ntheorem AffineMap.map_midpoint (f : P \u2192\u1d43[R] P') (a b : P) :\n    f (midpoint R a b) = midpoint R (f a) (f b)", "start": [49, 1], "end": [52, 24], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.map_midpoint", "code": "@[simp]\ntheorem AffineEquiv.map_midpoint (f : P \u2243\u1d43[R] P') (a b : P) :\n    f (midpoint R a b) = midpoint R (f a) (f b)", "start": [55, 1], "end": [58, 24], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_midpoint_left", "code": "theorem AffineEquiv.pointReflection_midpoint_left (x y : P) :\n    pointReflection R (midpoint R x y) x = y", "start": [61, 1], "end": [64, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_midpoint_left", "code": "@[simp] theorem Equiv.pointReflection_midpoint_left (x y : P) :\n    (Equiv.pointReflection (midpoint R x y)) x = y", "start": [67, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "midpoint_comm", "code": "theorem midpoint_comm (x y : P) : midpoint R x y = midpoint R y x", "start": [73, 1], "end": [74, 70], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.pointReflection_midpoint_right", "code": "theorem AffineEquiv.pointReflection_midpoint_right (x y : P) :\n    pointReflection R (midpoint R x y) y = x", "start": [77, 1], "end": [79, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_midpoint_right", "code": "@[simp] theorem Equiv.pointReflection_midpoint_right (x y : P) :\n    (Equiv.pointReflection (midpoint R x y)) y = x", "start": [82, 1], "end": [85, 58], "kind": "commanddeclaration"}, {"full_name": "midpoint_vsub_midpoint", "code": "theorem midpoint_vsub_midpoint (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    midpoint R p\u2081 p\u2082 -\u1d65 midpoint R p\u2083 p\u2084 = midpoint R (p\u2081 -\u1d65 p\u2083) (p\u2082 -\u1d65 p\u2084)", "start": [87, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "midpoint_vadd_midpoint", "code": "theorem midpoint_vadd_midpoint (v v' : V) (p p' : P) :\n    midpoint R v v' +\u1d65 midpoint R p p' = midpoint R (v +\u1d65 p) (v' +\u1d65 p')", "start": [92, 1], "end": [94, 33], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_iff", "code": "theorem midpoint_eq_iff {x y z : P} : midpoint R x y = z \u2194 pointReflection R z x = y", "start": [97, 1], "end": [100, 62], "kind": "commanddeclaration"}, {"full_name": "midpoint_pointReflection_left", "code": "@[simp]\ntheorem midpoint_pointReflection_left (x y : P) :\n    midpoint R (Equiv.pointReflection x y) y = x", "start": [103, 1], "end": [106, 60], "kind": "commanddeclaration"}, {"full_name": "midpoint_pointReflection_right", "code": "@[simp]\ntheorem midpoint_pointReflection_right (x y : P) :\n    midpoint R y (Equiv.pointReflection x y) = x", "start": [108, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "midpoint_vsub_left", "code": "@[simp]\ntheorem midpoint_vsub_left (p\u2081 p\u2082 : P) : midpoint R p\u2081 p\u2082 -\u1d65 p\u2081 = (\u215f 2 : R) \u2022 (p\u2082 -\u1d65 p\u2081)", "start": [113, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "midpoint_vsub_right", "code": "@[simp]\ntheorem midpoint_vsub_right (p\u2081 p\u2082 : P) : midpoint R p\u2081 p\u2082 -\u1d65 p\u2082 = (\u215f 2 : R) \u2022 (p\u2081 -\u1d65 p\u2082)", "start": [118, 1], "end": [120, 41], "kind": "commanddeclaration"}, {"full_name": "left_vsub_midpoint", "code": "@[simp]\ntheorem left_vsub_midpoint (p\u2081 p\u2082 : P) : p\u2081 -\u1d65 midpoint R p\u2081 p\u2082 = (\u215f 2 : R) \u2022 (p\u2081 -\u1d65 p\u2082)", "start": [123, 1], "end": [125, 26], "kind": "commanddeclaration"}, {"full_name": "right_vsub_midpoint", "code": "@[simp]\ntheorem right_vsub_midpoint (p\u2081 p\u2082 : P) : p\u2082 -\u1d65 midpoint R p\u2081 p\u2082 = (\u215f 2 : R) \u2022 (p\u2082 -\u1d65 p\u2081)", "start": [128, 1], "end": [130, 41], "kind": "commanddeclaration"}, {"full_name": "midpoint_vsub", "code": "theorem midpoint_vsub (p\u2081 p\u2082 p : P) :\n    midpoint R p\u2081 p\u2082 -\u1d65 p = (\u215f 2 : R) \u2022 (p\u2081 -\u1d65 p) + (\u215f 2 : R) \u2022 (p\u2082 -\u1d65 p)", "start": [133, 1], "end": [137, 44], "kind": "commanddeclaration"}, {"full_name": "vsub_midpoint", "code": "theorem vsub_midpoint (p\u2081 p\u2082 p : P) :\n    p -\u1d65 midpoint R p\u2081 p\u2082 = (\u215f 2 : R) \u2022 (p -\u1d65 p\u2081) + (\u215f 2 : R) \u2022 (p -\u1d65 p\u2082)", "start": [140, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "midpoint_sub_left", "code": "@[simp]\ntheorem midpoint_sub_left (v\u2081 v\u2082 : V) : midpoint R v\u2081 v\u2082 - v\u2081 = (\u215f 2 : R) \u2022 (v\u2082 - v\u2081)", "start": [146, 1], "end": [148, 27], "kind": "commanddeclaration"}, {"full_name": "midpoint_sub_right", "code": "@[simp]\ntheorem midpoint_sub_right (v\u2081 v\u2082 : V) : midpoint R v\u2081 v\u2082 - v\u2082 = (\u215f 2 : R) \u2022 (v\u2081 - v\u2082)", "start": [151, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "left_sub_midpoint", "code": "@[simp]\ntheorem left_sub_midpoint (v\u2081 v\u2082 : V) : v\u2081 - midpoint R v\u2081 v\u2082 = (\u215f 2 : R) \u2022 (v\u2081 - v\u2082)", "start": [156, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "right_sub_midpoint", "code": "@[simp]\ntheorem right_sub_midpoint (v\u2081 v\u2082 : V) : v\u2082 - midpoint R v\u2081 v\u2082 = (\u215f 2 : R) \u2022 (v\u2082 - v\u2081)", "start": [161, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_left_iff", "code": "@[simp]\ntheorem midpoint_eq_left_iff {x y : P} : midpoint R x y = x \u2194 x = y", "start": [168, 1], "end": [170, 45], "kind": "commanddeclaration"}, {"full_name": "left_eq_midpoint_iff", "code": "@[simp]\ntheorem left_eq_midpoint_iff {x y : P} : x = midpoint R x y \u2194 x = y", "start": [173, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_right_iff", "code": "@[simp]\ntheorem midpoint_eq_right_iff {x y : P} : midpoint R x y = y \u2194 x = y", "start": [178, 1], "end": [180, 52], "kind": "commanddeclaration"}, {"full_name": "right_eq_midpoint_iff", "code": "@[simp]\ntheorem right_eq_midpoint_iff {x y : P} : y = midpoint R x y \u2194 x = y", "start": [183, 1], "end": [185, 38], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_midpoint_iff_vsub_eq_vsub", "code": "theorem midpoint_eq_midpoint_iff_vsub_eq_vsub {x x' y y' : P} :\n    midpoint R x y = midpoint R x' y' \u2194 x -\u1d65 x' = y' -\u1d65 y", "start": [188, 1], "end": [191, 91], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_iff'", "code": "theorem midpoint_eq_iff' {x y z : P} : midpoint R x y = z \u2194 Equiv.pointReflection z x = y", "start": [194, 1], "end": [195, 18], "kind": "commanddeclaration"}, {"full_name": "midpoint_unique", "code": "theorem midpoint_unique (R' : Type*) [Ring R'] [Invertible (2 : R')] [Module R' V] (x y : P) :\n    midpoint R x y = midpoint R' x y", "start": [198, 1], "end": [201, 56], "kind": "commanddeclaration"}, {"full_name": "midpoint_self", "code": "@[simp]\ntheorem midpoint_self (x : P) : midpoint R x x = x", "start": [204, 1], "end": [206, 25], "kind": "commanddeclaration"}, {"full_name": "midpoint_add_self", "code": "@[simp]\ntheorem midpoint_add_self (x y : V) : midpoint R x y + midpoint R x y = x + y", "start": [209, 1], "end": [213, 99], "kind": "commanddeclaration"}, {"full_name": "midpoint_zero_add", "code": "theorem midpoint_zero_add (x y : V) : midpoint R 0 (x + y) = midpoint R x y", "start": [216, 1], "end": [217, 83], "kind": "commanddeclaration"}, {"full_name": "midpoint_eq_smul_add", "code": "theorem midpoint_eq_smul_add (x y : V) : midpoint R x y = (\u215f 2 : R) \u2022 (x + y)", "start": [220, 1], "end": [222, 70], "kind": "commanddeclaration"}, {"full_name": "midpoint_self_neg", "code": "@[simp]\ntheorem midpoint_self_neg (x : V) : midpoint R x (-x) = 0", "start": [225, 1], "end": [227, 53], "kind": "commanddeclaration"}, {"full_name": "midpoint_neg_self", "code": "@[simp]\ntheorem midpoint_neg_self (x : V) : midpoint R (-x) x = 0", "start": [230, 1], "end": [231, 101], "kind": "commanddeclaration"}, {"full_name": "midpoint_sub_add", "code": "@[simp]\ntheorem midpoint_sub_add (x y : V) : midpoint R (x - y) (x + y) = x", "start": [234, 1], "end": [236, 84], "kind": "commanddeclaration"}, {"full_name": "midpoint_add_sub", "code": "@[simp]\ntheorem midpoint_add_sub (x y : V) : midpoint R (x + y) (x - y) = x", "start": [239, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.ofMapMidpoint", "code": "def ofMapMidpoint (f : E \u2192 F) (h0 : f 0 = 0)\n    (hm : \u2200 x y, f (midpoint R x y) = midpoint R' (f x) (f y)) : E \u2192+ F\n    where\n  toFun := f\n  map_zero' := h0\n  map_add' x y :=\n    calc\n      f (x + y) = f 0 + f (x + y) := by rw [h0, zero_add]\n      _ = midpoint R' (f 0) (f (x + y)) + midpoint R' (f 0) (f (x + y)) :=\n        (midpoint_add_self _ _ _).symm\n      _ = f (midpoint R x y) + f (midpoint R x y) := by rw [\u2190 hm, midpoint_zero_add]\n      _ = f x + f y := by rw [hm, midpoint_add_self]", "start": [251, 1], "end": [263, 53], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_ofMapMidpoint", "code": "@[simp]\ntheorem coe_ofMapMidpoint (f : E \u2192 F) (h0 : f 0 = 0)\n    (hm : \u2200 x y, f (midpoint R x y) = midpoint R' (f x) (f y)) :\n    \u21d1(ofMapMidpoint R R' f h0 hm) = f", "start": [266, 1], "end": [270, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Ray.lean", "imports": ["Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/GroupTheory/Subgroup/Actions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SameRay", "code": "def SameRay (v\u2081 v\u2082 : M) : Prop :=\n  v\u2081 = 0 \u2228 v\u2082 = 0 \u2228 \u2203 r\u2081 r\u2082 : R, 0 < r\u2081 \u2227 0 < r\u2082 \u2227 r\u2081 \u2022 v\u2081 = r\u2082 \u2022 v\u2082", "start": [40, 1], "end": [44, 69], "kind": "commanddeclaration"}, {"full_name": "SameRay.zero_left", "code": "@[simp]\ntheorem zero_left (y : M) : SameRay R 0 y", "start": [53, 1], "end": [55, 13], "kind": "commanddeclaration"}, {"full_name": "SameRay.zero_right", "code": "@[simp]\ntheorem zero_right (x : M) : SameRay R x 0", "start": [58, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "SameRay.of_subsingleton", "code": "@[nontriviality]\ntheorem of_subsingleton [Subsingleton M] (x y : M) : SameRay R x y", "start": [63, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "SameRay.of_subsingleton'", "code": "@[nontriviality]\ntheorem of_subsingleton' [Subsingleton R] (x y : M) : SameRay R x y", "start": [69, 1], "end": [72, 22], "kind": "commanddeclaration"}, {"full_name": "SameRay.refl", "code": "@[refl]\ntheorem refl (x : M) : SameRay R x x", "start": [75, 1], "end": [79, 65], "kind": "commanddeclaration"}, {"full_name": "SameRay.rfl", "code": "protected theorem rfl : SameRay R x x", "start": [82, 1], "end": [83, 9], "kind": "commanddeclaration"}, {"full_name": "SameRay.symm", "code": "@[symm]\ntheorem symm (h : SameRay R x y) : SameRay R y x", "start": [86, 1], "end": [89, 99], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_pos", "code": "theorem exists_pos (h : SameRay R x y) (hx : x \u2260 0) (hy : y \u2260 0) :\n    \u2203 r\u2081 r\u2082 : R, 0 < r\u2081 \u2227 0 < r\u2082 \u2227 r\u2081 \u2022 x = r\u2082 \u2022 y", "start": [92, 1], "end": [96, 38], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_comm", "code": "theorem sameRay_comm : SameRay R x y \u2194 SameRay R y x", "start": [99, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "SameRay.trans", "code": "theorem trans (hxy : SameRay R x y) (hyz : SameRay R y z) (hy : y = 0 \u2192 x = 0 \u2228 z = 0) :\n    SameRay R x z", "start": [103, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_nonneg_smul_right", "code": "theorem sameRay_nonneg_smul_right (v : M) {r : R} (h : 0 \u2264 r) : SameRay R v (r \u2022 v)", "start": [117, 1], "end": [123, 48], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_pos_smul_right", "code": "theorem sameRay_pos_smul_right (v : M) {r : R} (h : 0 < r) : SameRay R v (r \u2022 v)", "start": [126, 1], "end": [128, 35], "kind": "commanddeclaration"}, {"full_name": "SameRay.nonneg_smul_right", "code": "theorem nonneg_smul_right {r : R} (h : SameRay R x y) (hr : 0 \u2264 r) : SameRay R x (r \u2022 y)", "start": [131, 1], "end": [133, 85], "kind": "commanddeclaration"}, {"full_name": "SameRay.pos_smul_right", "code": "theorem pos_smul_right {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R x (r \u2022 y)", "start": [136, 1], "end": [138, 28], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_nonneg_smul_left", "code": "theorem sameRay_nonneg_smul_left (v : M) {r : R} (h : 0 \u2264 r) : SameRay R (r \u2022 v) v", "start": [141, 1], "end": [143, 39], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_pos_smul_left", "code": "theorem sameRay_pos_smul_left (v : M) {r : R} (h : 0 < r) : SameRay R (r \u2022 v) v", "start": [146, 1], "end": [148, 34], "kind": "commanddeclaration"}, {"full_name": "SameRay.nonneg_smul_left", "code": "theorem nonneg_smul_left {r : R} (h : SameRay R x y) (hr : 0 \u2264 r) : SameRay R (r \u2022 x) y", "start": [151, 1], "end": [153, 37], "kind": "commanddeclaration"}, {"full_name": "SameRay.pos_smul_left", "code": "theorem pos_smul_left {r : R} (h : SameRay R x y) (hr : 0 < r) : SameRay R (r \u2022 x) y", "start": [156, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "SameRay.map", "code": "theorem map (f : M \u2192\u2097[R] N) (h : SameRay R x y) : SameRay R (f x) (f y)", "start": [161, 1], "end": [165, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.sameRay_map_iff", "code": "theorem _root_.Function.Injective.sameRay_map_iff {F : Type*} [LinearMapClass F R M N] {f : F}\n    (hf : Function.Injective f) : SameRay R (f x) (f y) \u2194 SameRay R x y", "start": [168, 1], "end": [172, 55], "kind": "commanddeclaration"}, {"full_name": "SameRay.sameRay_map_iff", "code": "@[simp]\ntheorem sameRay_map_iff (e : M \u2243\u2097[R] N) : SameRay R (e x) (e y) \u2194 SameRay R x y", "start": [175, 1], "end": [179, 61], "kind": "commanddeclaration"}, {"full_name": "SameRay.smul", "code": "theorem smul {S : Type*} [Monoid S] [DistribMulAction S M] [SMulCommClass R S M]\n    (h : SameRay R x y) (s : S) : SameRay R (s \u2022 x) (s \u2022 y)", "start": [182, 1], "end": [186, 41], "kind": "commanddeclaration"}, {"full_name": "SameRay.add_left", "code": "theorem add_left (hx : SameRay R x z) (hy : SameRay R y z) : SameRay R (x + y) z", "start": [189, 1], "end": [199, 19], "kind": "commanddeclaration"}, {"full_name": "SameRay.add_right", "code": "theorem add_right (hy : SameRay R x y) (hz : SameRay R x z) : SameRay R x (y + z)", "start": [202, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "RayVector", "code": "@[nolint unusedArguments]\ndef RayVector (R M : Type*) [Zero M] :=\n  { v : M // v \u2260 0 }", "start": [211, 1], "end": [215, 21], "kind": "commanddeclaration"}, {"full_name": "RayVector.coe", "code": "instance RayVector.coe [Zero M] : CoeOut (RayVector R M) M where\n  coe := Subtype.val", "start": [219, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "RayVector.Setoid", "code": "instance RayVector.Setoid : Setoid (RayVector R M)\n    where\n  r x y := SameRay R (x : M) y\n  iseqv :=\n    \u27e8fun x => SameRay.refl _, fun h => h.symm, by\n      intros x y z hxy hyz\n      exact hxy.trans hyz fun hy => (y.2 hy).elim\u27e9", "start": [227, 1], "end": [234, 51], "kind": "commanddeclaration"}, {"full_name": "Module.Ray", "code": "def Module.Ray :=\n  Quotient (RayVector.Setoid R M)", "start": [236, 1], "end": [239, 34], "kind": "commanddeclaration"}, {"full_name": "equiv_iff_sameRay", "code": "theorem equiv_iff_sameRay {v\u2081 v\u2082 : RayVector R M} : v\u2081 \u2248 v\u2082 \u2194 SameRay R (v\u2081 : M) v\u2082", "start": [244, 1], "end": [246, 10], "kind": "commanddeclaration"}, {"full_name": "rayOfNeZero", "code": "def rayOfNeZero (v : M) (h : v \u2260 0) : Module.Ray R M :=\n  \u27e6\u27e8v, h\u27e9\u27e7", "start": [252, 1], "end": [254, 11], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.ind", "code": "theorem Module.Ray.ind {C : Module.Ray R M \u2192 Prop} (h : \u2200 (v) (hv : v \u2260 0), C (rayOfNeZero R v hv))\n    (x : Module.Ray R M) : C x", "start": [257, 1], "end": [260, 36], "kind": "commanddeclaration"}, {"full_name": "ray_eq_iff", "code": "theorem ray_eq_iff {v\u2081 v\u2082 : M} (hv\u2081 : v\u2081 \u2260 0) (hv\u2082 : v\u2082 \u2260 0) :\n    rayOfNeZero R _ hv\u2081 = rayOfNeZero R _ hv\u2082 \u2194 SameRay R v\u2081 v\u2082", "start": [268, 1], "end": [272, 15], "kind": "commanddeclaration"}, {"full_name": "ray_pos_smul", "code": "@[simp]\ntheorem ray_pos_smul {v : M} (h : v \u2260 0) {r : R} (hr : 0 < r) (hrv : r \u2022 v \u2260 0) :\n    rayOfNeZero R (r \u2022 v) hrv = rayOfNeZero R v h", "start": [275, 1], "end": [279, 59], "kind": "commanddeclaration"}, {"full_name": "RayVector.mapLinearEquiv", "code": "def RayVector.mapLinearEquiv (e : M \u2243\u2097[R] N) : RayVector R M \u2243 RayVector R N :=\n  Equiv.subtypeEquiv e.toEquiv fun _ => e.map_ne_zero_iff.symm", "start": [282, 1], "end": [284, 63], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.map", "code": "def Module.Ray.map (e : M \u2243\u2097[R] N) : Module.Ray R M \u2243 Module.Ray R N :=\n  Quotient.congr (RayVector.mapLinearEquiv e) fun _ _=> (SameRay.sameRay_map_iff _).symm", "start": [287, 1], "end": [289, 89], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.map_apply", "code": "@[simp]\ntheorem Module.Ray.map_apply (e : M \u2243\u2097[R] N) (v : M) (hv : v \u2260 0) :\n    Module.Ray.map e (rayOfNeZero _ v hv) = rayOfNeZero _ (e v) (e.map_ne_zero_iff.2 hv)", "start": [292, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.map_refl", "code": "@[simp]\ntheorem Module.Ray.map_refl : (Module.Ray.map <| LinearEquiv.refl R M) = Equiv.refl _", "start": [298, 1], "end": [300, 47], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.map_symm", "code": "@[simp]\ntheorem Module.Ray.map_symm (e : M \u2243\u2097[R] N) : (Module.Ray.map e).symm = Module.Ray.map e.symm", "start": [303, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.linearEquiv_smul_eq_map", "code": "@[simp]\ntheorem Module.Ray.linearEquiv_smul_eq_map (e : M \u2243\u2097[R] M) (v : Module.Ray R M) :\n    e \u2022 v = Module.Ray.map e v", "start": [330, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "smul_rayOfNeZero", "code": "@[simp]\ntheorem smul_rayOfNeZero (g : G) (v : M) (hv) :\n    g \u2022 rayOfNeZero R v hv = rayOfNeZero R (g \u2022 v) ((smul_ne_zero_iff_ne _).2 hv)", "start": [337, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.units_smul_of_pos", "code": "theorem units_smul_of_pos (u : R\u02e3) (hu : 0 < (u.1 : R)) (v : Module.Ray R M) : u \u2022 v = v", "start": [348, 1], "end": [352, 43], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.someRayVector", "code": "def someRayVector (x : Module.Ray R M) : RayVector R M :=\n  Quotient.out x", "start": [355, 1], "end": [357, 17], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.someRayVector_ray", "code": "@[simp]\ntheorem someRayVector_ray (x : Module.Ray R M) : (\u27e6x.someRayVector\u27e7 : Module.Ray R M) = x", "start": [360, 1], "end": [363, 20], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.someVector", "code": "def someVector (x : Module.Ray R M) : M :=\n  x.someRayVector", "start": [366, 1], "end": [368, 18], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.someVector_ne_zero", "code": "@[simp]\ntheorem someVector_ne_zero (x : Module.Ray R M) : x.someVector \u2260 0", "start": [371, 1], "end": [374, 27], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.someVector_ray", "code": "@[simp]\ntheorem someVector_ray (x : Module.Ray R M) : rayOfNeZero R _ x.someVector_ne_zero = x", "start": [377, 1], "end": [380, 57], "kind": "commanddeclaration"}, {"full_name": "sameRay_neg_iff", "code": "@[simp]\ntheorem sameRay_neg_iff : SameRay R (-x) (-y) \u2194 SameRay R x y", "start": [393, 1], "end": [396, 54], "kind": "commanddeclaration"}, {"full_name": "SameRay.of_neg", "code": "alias \u27e8SameRay.of_neg, SameRay.neg\u27e9 := sameRay_neg_iff", "start": [399, 1], "end": [399, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SameRay.neg", "code": "alias \u27e8SameRay.of_neg, SameRay.neg\u27e9 := sameRay_neg_iff", "start": [399, 1], "end": [399, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sameRay_neg_swap", "code": "theorem sameRay_neg_swap : SameRay R (-x) y \u2194 SameRay R x (-y)", "start": [403, 1], "end": [403, 101], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_sameRay_neg_smul_right", "code": "theorem eq_zero_of_sameRay_neg_smul_right [NoZeroSMulDivisors R M] {r : R} (hr : r < 0)\n    (h : SameRay R x (r \u2022 x)) : x = 0", "start": [406, 1], "end": [413, 51], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_sameRay_self_neg", "code": "theorem eq_zero_of_sameRay_self_neg [NoZeroSMulDivisors R M] (h : SameRay R x (-x)) : x = 0", "start": [416, 1], "end": [420, 21], "kind": "commanddeclaration"}, {"full_name": "RayVector.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg {R : Type*} (v : RayVector R M) : \u2191(-v) = -(v : M)", "start": [429, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "RayVector.equiv_neg_iff", "code": "@[simp]\ntheorem equiv_neg_iff {v\u2081 v\u2082 : RayVector R M} : -v\u2081 \u2248 -v\u2082 \u2194 v\u2081 \u2248 v\u2082", "start": [441, 1], "end": [444, 18], "kind": "commanddeclaration"}, {"full_name": "neg_rayOfNeZero", "code": "@[simp]\ntheorem neg_rayOfNeZero (v : M) (h : v \u2260 0) :\n    -rayOfNeZero R _ h = rayOfNeZero R (-v) (neg_ne_zero.2 h)", "start": [455, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.ne_neg_self", "code": "theorem ne_neg_self [NoZeroSMulDivisors R M] (x : Module.Ray R M) : x \u2260 -x", "start": [473, 1], "end": [477, 42], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.neg_units_smul", "code": "theorem neg_units_smul (u : R\u02e3) (v : Module.Ray R M) : -u \u2022 v = -(u \u2022 v)", "start": [480, 1], "end": [482, 89], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.units_smul_of_neg", "code": "theorem units_smul_of_neg (u : R\u02e3) (hu : u.1 < 0) (v : Module.Ray R M) : u \u2022 v = -v", "start": [486, 1], "end": [489, 41], "kind": "commanddeclaration"}, {"full_name": "Module.Ray.map_neg", "code": "@[simp]\nprotected theorem map_neg (f : M \u2243\u2097[R] N) (v : Module.Ray R M) : map f (-v) = -map f v", "start": [492, 1], "end": [495, 7], "kind": "commanddeclaration"}, {"full_name": "sameRay_of_mem_orbit", "code": "theorem sameRay_of_mem_orbit {v\u2081 v\u2082 : M} (h : v\u2081 \u2208 MulAction.orbit (\u21a5Units.posSubgroup R) v\u2082) :\n    SameRay R v\u2081 v\u2082", "start": [509, 1], "end": [513, 43], "kind": "commanddeclaration"}, {"full_name": "units_inv_smul", "code": "@[simp]\ntheorem units_inv_smul (u : R\u02e3) (v : Module.Ray R M) : u\u207b\u00b9 \u2022 v = u \u2022 v", "start": [516, 1], "end": [522, 49], "kind": "commanddeclaration"}, {"full_name": "sameRay_smul_right_iff", "code": "@[simp]\ntheorem sameRay_smul_right_iff {v : M} {r : R} : SameRay R v (r \u2022 v) \u2194 0 \u2264 r \u2228 v = 0", "start": [529, 1], "end": [532, 91], "kind": "commanddeclaration"}, {"full_name": "sameRay_smul_right_iff_of_ne", "code": "theorem sameRay_smul_right_iff_of_ne {v : M} (hv : v \u2260 0) {r : R} (hr : r \u2260 0) :\n    SameRay R v (r \u2022 v) \u2194 0 < r", "start": [535, 1], "end": [539, 74], "kind": "commanddeclaration"}, {"full_name": "sameRay_smul_left_iff", "code": "@[simp]\ntheorem sameRay_smul_left_iff {v : M} {r : R} : SameRay R (r \u2022 v) v \u2194 0 \u2264 r \u2228 v = 0", "start": [542, 1], "end": [544, 52], "kind": "commanddeclaration"}, {"full_name": "sameRay_smul_left_iff_of_ne", "code": "theorem sameRay_smul_left_iff_of_ne {v : M} (hv : v \u2260 0) {r : R} (hr : r \u2260 0) :\n    SameRay R (r \u2022 v) v \u2194 0 < r", "start": [547, 1], "end": [551, 66], "kind": "commanddeclaration"}, {"full_name": "sameRay_neg_smul_right_iff", "code": "@[simp]\ntheorem sameRay_neg_smul_right_iff {v : M} {r : R} : SameRay R (-v) (r \u2022 v) \u2194 r \u2264 0 \u2228 v = 0", "start": [554, 1], "end": [556, 82], "kind": "commanddeclaration"}, {"full_name": "sameRay_neg_smul_right_iff_of_ne", "code": "theorem sameRay_neg_smul_right_iff_of_ne {v : M} {r : R} (hv : v \u2260 0) (hr : r \u2260 0) :\n    SameRay R (-v) (r \u2022 v) \u2194 r < 0", "start": [559, 1], "end": [561, 73], "kind": "commanddeclaration"}, {"full_name": "sameRay_neg_smul_left_iff", "code": "@[simp]\ntheorem sameRay_neg_smul_left_iff {v : M} {r : R} : SameRay R (r \u2022 v) (-v) \u2194 r \u2264 0 \u2228 v = 0", "start": [564, 1], "end": [566, 56], "kind": "commanddeclaration"}, {"full_name": "sameRay_neg_smul_left_iff_of_ne", "code": "theorem sameRay_neg_smul_left_iff_of_ne {v : M} {r : R} (hv : v \u2260 0) (hr : r \u2260 0) :\n    SameRay R (r \u2022 v) (-v) \u2194 r < 0", "start": [569, 1], "end": [571, 71], "kind": "commanddeclaration"}, {"full_name": "units_smul_eq_self_iff", "code": "@[simp]\ntheorem units_smul_eq_self_iff {u : R\u02e3} {v : Module.Ray R M} : u \u2022 v = v \u2194 0 < u.1", "start": [575, 1], "end": [578, 101], "kind": "commanddeclaration"}, {"full_name": "units_smul_eq_neg_iff", "code": "@[simp]\ntheorem units_smul_eq_neg_iff {u : R\u02e3} {v : Module.Ray R M} : u \u2022 v = -v \u2194 u.1 < 0", "start": [581, 1], "end": [584, 13], "kind": "commanddeclaration"}, {"full_name": "sameRay_or_sameRay_neg_iff_not_linearIndependent", "code": "theorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y \u2228 SameRay R x (-y) \u2194 \u00acLinearIndependent R ![x, y]", "start": [587, 1], "end": [629, 21], "kind": "commanddeclaration"}, {"full_name": "sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent", "code": "theorem sameRay_or_ne_zero_and_sameRay_neg_iff_not_linearIndependent {x y : M} :\n    SameRay R x y \u2228 x \u2260 0 \u2227 y \u2260 0 \u2227 SameRay R x (-y) \u2194 \u00acLinearIndependent R ![x, y]", "start": [632, 1], "end": [638, 40], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_pos_left", "code": "theorem exists_pos_left (h : SameRay R x y) (hx : x \u2260 0) (hy : y \u2260 0) :\n    \u2203 r : R, 0 < r \u2227 r \u2022 x = y", "start": [651, 1], "end": [654, 88], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_pos_right", "code": "theorem exists_pos_right (h : SameRay R x y) (hx : x \u2260 0) (hy : y \u2260 0) :\n    \u2203 r : R, 0 < r \u2227 x = r \u2022 y", "start": [657, 1], "end": [659, 68], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_nonneg_left", "code": "theorem exists_nonneg_left (h : SameRay R x y) (hx : x \u2260 0) : \u2203 r : R, 0 \u2264 r \u2227 r \u2022 x = y", "start": [662, 1], "end": [667, 71], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_nonneg_right", "code": "theorem exists_nonneg_right (h : SameRay R x y) (hy : y \u2260 0) : \u2203 r : R, 0 \u2264 r \u2227 x = r \u2022 y", "start": [670, 1], "end": [673, 68], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_eq_smul_add", "code": "theorem exists_eq_smul_add (h : SameRay R v\u2081 v\u2082) :\n    \u2203 a b : R, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 (v\u2081 + v\u2082) \u2227 v\u2082 = b \u2022 (v\u2081 + v\u2082)", "start": [676, 1], "end": [690, 98], "kind": "commanddeclaration"}, {"full_name": "SameRay.exists_eq_smul", "code": "theorem exists_eq_smul (h : SameRay R v\u2081 v\u2082) :\n    \u2203 (u : M) (a b : R), 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 v\u2081 = a \u2022 u \u2227 v\u2082 = b \u2022 u", "start": [693, 1], "end": [697, 34], "kind": "commanddeclaration"}, {"full_name": "exists_pos_left_iff_sameRay", "code": "theorem exists_pos_left_iff_sameRay (hx : x \u2260 0) (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 r \u2022 x = y) \u2194 SameRay R x y", "start": [708, 1], "end": [712, 44], "kind": "commanddeclaration"}, {"full_name": "exists_pos_left_iff_sameRay_and_ne_zero", "code": "theorem exists_pos_left_iff_sameRay_and_ne_zero (hx : x \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 r \u2022 x = y) \u2194 SameRay R x y \u2227 y \u2260 0", "start": [715, 1], "end": [721, 52], "kind": "commanddeclaration"}, {"full_name": "exists_nonneg_left_iff_sameRay", "code": "theorem exists_nonneg_left_iff_sameRay (hx : x \u2260 0) :\n    (\u2203 r : R, 0 \u2264 r \u2227 r \u2022 x = y) \u2194 SameRay R x y", "start": [724, 1], "end": [728, 47], "kind": "commanddeclaration"}, {"full_name": "exists_pos_right_iff_sameRay", "code": "theorem exists_pos_right_iff_sameRay (hx : x \u2260 0) (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y", "start": [731, 1], "end": [735, 42], "kind": "commanddeclaration"}, {"full_name": "exists_pos_right_iff_sameRay_and_ne_zero", "code": "theorem exists_pos_right_iff_sameRay_and_ne_zero (hy : y \u2260 0) :\n    (\u2203 r : R, 0 < r \u2227 x = r \u2022 y) \u2194 SameRay R x y \u2227 x \u2260 0", "start": [738, 1], "end": [742, 51], "kind": "commanddeclaration"}, {"full_name": "exists_nonneg_right_iff_sameRay", "code": "theorem exists_nonneg_right_iff_sameRay (hy : y \u2260 0) :\n    (\u2203 r : R, 0 \u2264 r \u2227 x = r \u2022 y) \u2194 SameRay R x y", "start": [745, 1], "end": [749, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Finrank.lean", "imports": ["Mathlib/LinearAlgebra/Dimension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FiniteDimensional.finrank", "code": "noncomputable def finrank (R V : Type*) [Semiring R] [AddCommGroup V] [Module R V] : \u2115 :=\n  Cardinal.toNat (Module.rank R V)", "start": [51, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_of_rank_eq", "code": "theorem finrank_eq_of_rank_eq {n : \u2115} (h : Module.rank K V = \u2191n) : finrank K V = n", "start": [62, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.rank_eq_one_iff_finrank_eq_one", "code": "lemma rank_eq_one_iff_finrank_eq_one : Module.rank K V = 1 \u2194 finrank K V = 1 :=\n  Cardinal.toNat_eq_one.symm", "start": [68, 1], "end": [69, 29], "kind": "mathlibtacticlemma"}, {"full_name": "FiniteDimensional.rank_eq_ofNat_iff_finrank_eq_ofNat", "code": "lemma rank_eq_ofNat_iff_finrank_eq_ofNat (n : \u2115) [Nat.AtLeastTwo n] :\n    Module.rank K V = OfNat.ofNat n \u2194 finrank K V = OfNat.ofNat n :=\n  Cardinal.toNat_eq_ofNat.symm", "start": [71, 1], "end": [74, 31], "kind": "mathlibtacticlemma"}, {"full_name": "FiniteDimensional.finrank_le_of_rank_le", "code": "theorem finrank_le_of_rank_le {n : \u2115} (h : Module.rank K V \u2264 \u2191n) : finrank K V \u2264 n", "start": [76, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_lt_of_rank_lt", "code": "theorem finrank_lt_of_rank_lt {n : \u2115} (h : Module.rank K V < \u2191n) : finrank K V < n", "start": [82, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.lt_rank_of_lt_finrank", "code": "theorem lt_rank_of_lt_finrank {n : \u2115} (h : n < finrank K V) : \u2191n < Module.rank K V", "start": [88, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.one_lt_rank_of_one_lt_finrank", "code": "theorem one_lt_rank_of_one_lt_finrank (h : 1 < finrank K V) : 1 < Module.rank K V", "start": [96, 1], "end": [97, 38], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_le_finrank_of_rank_le_rank", "code": "theorem finrank_le_finrank_of_rank_le_rank\n    (h : lift.{v'} (Module.rank K V) \u2264 Cardinal.lift.{v} (Module.rank K V\u2082))\n    (h' : Module.rank K V\u2082 < \u2135\u2080) : finrank K V \u2264 finrank K V\u2082", "start": [99, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nontrivial_of_finrank_pos", "code": "theorem nontrivial_of_finrank_pos (h : 0 < finrank K V) : Nontrivial V", "start": [109, 1], "end": [111, 55], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nontrivial_of_finrank_eq_succ", "code": "theorem nontrivial_of_finrank_eq_succ {n : \u2115} (hn : finrank K V = n.succ) : Nontrivial V", "start": [114, 1], "end": [117, 59], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_zero_of_subsingleton", "code": "theorem finrank_zero_of_subsingleton [h : Subsingleton V] : finrank K V = 0", "start": [120, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_card_basis", "code": "theorem finrank_eq_card_basis {\u03b9 : Type w} [Fintype \u03b9] (h : Basis \u03b9 K V) :\n    finrank K V = Fintype.card \u03b9", "start": [133, 1], "end": [137, 47], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_card_finset_basis", "code": "theorem finrank_eq_card_finset_basis {\u03b9 : Type w} {b : Finset \u03b9} (h : Basis b K V) :\n    finrank K V = Finset.card b", "start": [140, 1], "end": [143, 85], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_self", "code": "@[simp]\ntheorem finrank_self : finrank K K = 1", "start": [148, 1], "end": [152, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_fintype_fun_eq_card", "code": "@[simp]\ntheorem finrank_fintype_fun_eq_card {\u03b9 : Type v} [Fintype \u03b9] : finrank K (\u03b9 \u2192 K) = Fintype.card \u03b9", "start": [155, 1], "end": [158, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_fin_fun", "code": "theorem finrank_fin_fun {n : \u2115} : finrank K (Fin n \u2192 K) = n", "start": [161, 1], "end": [163, 71], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.Basis.subset_extend", "code": "theorem Basis.subset_extend {s : Set V} (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    s \u2286 hs.extend (Set.subset_univ _)", "start": [175, 1], "end": [177, 21], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_basis_imp_not_finite", "code": "theorem finrank_eq_zero_of_basis_imp_not_finite\n    (h : \u2200 s : Set V, Basis.{v} (s : Set V) K V \u2192 \u00acs.Finite) : finrank K V = 0", "start": [190, 1], "end": [193, 80], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_basis_imp_false", "code": "theorem finrank_eq_zero_of_basis_imp_false (h : \u2200 s : Finset V, Basis.{v} (s : Set V) K V \u2192 False) :\n    finrank K V = 0", "start": [196, 1], "end": [202, 14], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_not_exists_basis", "code": "theorem finrank_eq_zero_of_not_exists_basis\n    (h : \u00ac\u2203 s : Finset V, Nonempty (Basis (s : Set V) K V)) : finrank K V = 0", "start": [205, 1], "end": [207, 59], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_not_exists_basis_finite", "code": "theorem finrank_eq_zero_of_not_exists_basis_finite\n    (h : \u00ac\u2203 (s : Set V) (_ : Basis.{v} (s : Set V) K V), s.Finite) : finrank K V = 0", "start": [210, 1], "end": [212, 69], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_not_exists_basis_finset", "code": "theorem finrank_eq_zero_of_not_exists_basis_finset (h : \u00ac\u2203 s : Finset V, Nonempty (Basis s K V)) :\n    finrank K V = 0", "start": [215, 1], "end": [217, 59], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.finrank_eq", "code": "theorem finrank_eq (f : M \u2243\u2097[R] M\u2082) : finrank R M = finrank R M\u2082", "start": [232, 1], "end": [235, 66], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.finrank_map_eq", "code": "theorem finrank_map_eq (f : M \u2243\u2097[R] M\u2082) (p : Submodule R M) :\n    finrank R (p.map (f : M \u2192\u2097[R] M\u2082)) = finrank R p", "start": [238, 1], "end": [241, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finrank_range_of_inj", "code": "theorem finrank_range_of_inj {f : V \u2192\u2097[K] V\u2082} (hf : Function.Injective f) :\n    finrank K (LinearMap.range f) = finrank K V", "start": [254, 1], "end": [256, 101], "kind": "commanddeclaration"}, {"full_name": "finrank_bot", "code": "@[simp]\ntheorem finrank_bot [Nontrivial K] : finrank K (\u22a5 : Submodule K V) = 0", "start": [271, 1], "end": [273, 39], "kind": "commanddeclaration"}, {"full_name": "finrank_top", "code": "@[simp]\ntheorem finrank_top : finrank K (\u22a4 : Submodule K V) = finrank K V", "start": [276, 1], "end": [279, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.lt_of_le_of_finrank_lt_finrank", "code": "theorem lt_of_le_of_finrank_lt_finrank {s t : Submodule K V} (le : s \u2264 t)\n    (lt : finrank K s < finrank K t) : s < t", "start": [290, 1], "end": [292, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.lt_top_of_finrank_lt_finrank", "code": "theorem lt_top_of_finrank_lt_finrank {s : Submodule K V} (lt : finrank K s < finrank K V) :\n    s < \u22a4", "start": [295, 1], "end": [298, 49], "kind": "commanddeclaration"}, {"full_name": "Set.finrank", "code": "protected noncomputable def Set.finrank (s : Set V) : \u2115 :=\n  finrank K (span K s)", "start": [315, 1], "end": [317, 23], "kind": "commanddeclaration"}, {"full_name": "finrank_span_le_card", "code": "theorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) \u2264 s.toFinset.card", "start": [322, 1], "end": [323, 65], "kind": "commanddeclaration"}, {"full_name": "finrank_span_finset_le_card", "code": "theorem finrank_span_finset_le_card (s : Finset V) : (s : Set V).finrank K \u2264 s.card", "start": [326, 1], "end": [329, 26], "kind": "commanddeclaration"}, {"full_name": "finrank_range_le_card", "code": "theorem finrank_range_le_card {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V} :\n    (Set.range b).finrank K \u2264 Fintype.card \u03b9", "start": [332, 1], "end": [337, 29], "kind": "commanddeclaration"}, {"full_name": "finrank_span_eq_card", "code": "theorem finrank_span_eq_card {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V} (hb : LinearIndependent K b) :\n    finrank K (span K (Set.range b)) = Fintype.card \u03b9", "start": [340, 1], "end": [346, 34], "kind": "commanddeclaration"}, {"full_name": "finrank_span_set_eq_card", "code": "theorem finrank_span_set_eq_card (s : Set V) [Fintype s] (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    finrank K (span K s) = s.toFinset.card", "start": [349, 1], "end": [354, 62], "kind": "commanddeclaration"}, {"full_name": "finrank_span_finset_eq_card", "code": "theorem finrank_span_finset_eq_card (s : Finset V) (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    finrank K (span K (s : Set V)) = s.card", "start": [357, 1], "end": [361, 7], "kind": "commanddeclaration"}, {"full_name": "span_lt_of_subset_of_card_lt_finrank", "code": "theorem span_lt_of_subset_of_card_lt_finrank {s : Set V} [Fintype s] {t : Submodule K V}\n    (subset : s \u2286 t) (card_lt : s.toFinset.card < finrank K t) : span K s < t", "start": [364, 1], "end": [367, 54], "kind": "commanddeclaration"}, {"full_name": "span_lt_top_of_card_lt_finrank", "code": "theorem span_lt_top_of_card_lt_finrank {s : Set V} [Fintype s]\n    (card_lt : s.toFinset.card < finrank K V) : span K s < \u22a4", "start": [370, 1], "end": [372, 81], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_snoc_of_lt_finrank", "code": "theorem exists_linearIndependent_snoc_of_lt_finrank {n : \u2115} {v : Fin n \u2192 V}\n    (hv : LinearIndependent K v) (h : n < finrank K V) :\n    \u2203 (x : V), LinearIndependent K (Fin.snoc v x)", "start": [375, 1], "end": [380, 72], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_cons_of_lt_finrank", "code": "theorem exists_linearIndependent_cons_of_lt_finrank {n : \u2115} {v : Fin n \u2192 V}\n    (hv : LinearIndependent K v) (h : n < finrank K V) :\n    \u2203 (x : V), LinearIndependent K (Fin.cons x v)", "start": [382, 1], "end": [387, 72], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_pair_of_one_lt_finrank", "code": "theorem exists_linearIndependent_pair_of_one_lt_finrank\n    (h : 1 < finrank K V) {x : V} (hx : x \u2260 0) :\n    \u2203 y, LinearIndependent K ![x, y]", "start": [389, 1], "end": [394, 84], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_of_top_le_span_of_card_eq_finrank", "code": "theorem linearIndependent_of_top_le_span_of_card_eq_finrank {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V}\n    (spans : \u22a4 \u2264 span K (Set.range b)) (card_eq : Fintype.card \u03b9 = finrank K V) :\n    LinearIndependent K b", "start": [406, 1], "end": [449, 99], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_card_eq_finrank_span", "code": "theorem linearIndependent_iff_card_eq_finrank_span {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V} :\n    LinearIndependent K b \u2194 Fintype.card \u03b9 = (Set.range b).finrank K", "start": [452, 1], "end": [476, 82], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_card_le_finrank_span", "code": "theorem linearIndependent_iff_card_le_finrank_span {\u03b9 : Type*} [Fintype \u03b9] {b : \u03b9 \u2192 V} :\n    LinearIndependent K b \u2194 Fintype.card \u03b9 \u2264 (Set.range b).finrank K", "start": [479, 1], "end": [481, 83], "kind": "commanddeclaration"}, {"full_name": "basisOfTopLeSpanOfCardEqFinrank", "code": "noncomputable def basisOfTopLeSpanOfCardEqFinrank {\u03b9 : Type*} [Fintype \u03b9] (b : \u03b9 \u2192 V)\n    (le_span : \u22a4 \u2264 span K (Set.range b)) (card_eq : Fintype.card \u03b9 = finrank K V) : Basis \u03b9 K V :=\n  Basis.mk (linearIndependent_of_top_le_span_of_card_eq_finrank le_span card_eq) le_span", "start": [484, 1], "end": [487, 89], "kind": "commanddeclaration"}, {"full_name": "coe_basisOfTopLeSpanOfCardEqFinrank", "code": "@[simp]\ntheorem coe_basisOfTopLeSpanOfCardEqFinrank {\u03b9 : Type*} [Fintype \u03b9] (b : \u03b9 \u2192 V)\n    (le_span : \u22a4 \u2264 span K (Set.range b)) (card_eq : Fintype.card \u03b9 = finrank K V) :\n    \u21d1(basisOfTopLeSpanOfCardEqFinrank b le_span card_eq) = b", "start": [490, 1], "end": [494, 19], "kind": "commanddeclaration"}, {"full_name": "finsetBasisOfTopLeSpanOfCardEqFinrank", "code": "@[simps! repr_apply]\nnoncomputable def finsetBasisOfTopLeSpanOfCardEqFinrank {s : Finset V}\n    (le_span : \u22a4 \u2264 span K (s : Set V)) (card_eq : s.card = finrank K V) : Basis (s : Set V) K V :=\n  basisOfTopLeSpanOfCardEqFinrank ((\u2191) : \u21a5(s : Set V) \u2192 V)\n    ((@Subtype.range_coe_subtype _ fun x => x \u2208 s).symm \u25b8 le_span)\n    (_root_.trans (Fintype.card_coe _) card_eq)", "start": [497, 1], "end": [503, 48], "kind": "commanddeclaration"}, {"full_name": "setBasisOfTopLeSpanOfCardEqFinrank", "code": "@[simps! repr_apply]\nnoncomputable def setBasisOfTopLeSpanOfCardEqFinrank {s : Set V} [Fintype s]\n    (le_span : \u22a4 \u2264 span K s) (card_eq : s.toFinset.card = finrank K V) : Basis s K V :=\n  basisOfTopLeSpanOfCardEqFinrank ((\u2191) : s \u2192 V) ((@Subtype.range_coe_subtype _ s).symm \u25b8 le_span)\n    (_root_.trans s.toFinset_card.symm card_eq)", "start": [509, 1], "end": [514, 48], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_one", "code": "theorem finrank_eq_one (v : V) (n : v \u2260 0) (h : \u2200 w : V, \u2203 c : K, c \u2022 v = w) : finrank K V = 1", "start": [532, 1], "end": [537, 51], "kind": "commanddeclaration"}, {"full_name": "finrank_le_one", "code": "theorem finrank_le_one (v : V) (h : \u2200 w : V, \u2203 c : K, c \u2022 v = w) : finrank K V \u2264 1", "start": [540, 1], "end": [551, 37], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rank_toSubmodule", "code": "@[simp]\ntheorem Subalgebra.rank_toSubmodule (S : Subalgebra F E) :\n    Module.rank F (Subalgebra.toSubmodule S) = Module.rank F S", "start": [562, 1], "end": [565, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finrank_toSubmodule", "code": "@[simp]\ntheorem Subalgebra.finrank_toSubmodule (S : Subalgebra F E) :\n    finrank F (Subalgebra.toSubmodule S) = finrank F S", "start": [568, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "subalgebra_top_rank_eq_submodule_top_rank", "code": "theorem subalgebra_top_rank_eq_submodule_top_rank :\n    Module.rank F (\u22a4 : Subalgebra F E) = Module.rank F (\u22a4 : Submodule F E)", "start": [574, 1], "end": [577, 6], "kind": "commanddeclaration"}, {"full_name": "subalgebra_top_finrank_eq_submodule_top_finrank", "code": "theorem subalgebra_top_finrank_eq_submodule_top_finrank :\n    finrank F (\u22a4 : Subalgebra F E) = finrank F (\u22a4 : Submodule F E)", "start": [580, 1], "end": [583, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rank_top", "code": "theorem Subalgebra.rank_top : Module.rank F (\u22a4 : Subalgebra F E) = Module.rank F E", "start": [586, 1], "end": [588, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rank_bot", "code": "@[simp]\ntheorem Subalgebra.rank_bot : Module.rank F (\u22a5 : Subalgebra F E) = 1", "start": [595, 1], "end": [601, 69], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finrank_bot", "code": "@[simp]\ntheorem Subalgebra.finrank_bot : finrank F (\u22a5 : Subalgebra F E) = 1", "start": [604, 1], "end": [606, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Finite/Basic.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/RingTheory/Finiteness.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.Free.ChooseBasisIndex.fintype", "code": "noncomputable instance ChooseBasisIndex.fintype [Module.Finite R M] :\n    Fintype (Module.Free.ChooseBasisIndex R M) := by\n  refine @Fintype.ofFinite _ ?_\n  cases subsingleton_or_nontrivial R\n  \u00b7 have := Module.subsingleton R M\n    rw [ChooseBasisIndex]\n    infer_instance\n  \u00b7 obtain \u27e8s, hs\u27e9 := id \u2039Module.Finite R M\u203a\n    exact basis_finite_of_finite_spans (\u2191s) s.finite_toSet hs (chooseBasis _ _)", "start": [34, 1], "end": [43, 80], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.of_basis", "code": "theorem _root_.Module.Finite.of_basis {R M \u03b9 : Type*} [CommRing R] [AddCommGroup M] [Module R M]\n    [_root_.Finite \u03b9] (b : Basis \u03b9 R M) : Module.Finite R M", "start": [56, 1], "end": [62, 81], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.matrix", "code": "instance _root_.Module.Finite.matrix {\u03b9\u2081 \u03b9\u2082 : Type*} [_root_.Finite \u03b9\u2081] [_root_.Finite \u03b9\u2082] :\n    Module.Finite R (Matrix \u03b9\u2081 \u03b9\u2082 R) := by\n  cases nonempty_fintype \u03b9\u2081\n  cases nonempty_fintype \u03b9\u2082\n  exact Module.Finite.of_basis (Pi.basis fun _ => Pi.basisFun R _)", "start": [65, 1], "end": [69, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Rank.lean", "imports": ["Mathlib/LinearAlgebra/Dimension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "rank_finsupp", "code": "@[simp]\ntheorem rank_finsupp (\u03b9 : Type w) :\n    Module.rank R (\u03b9 \u2192\u2080 M) = Cardinal.lift.{v} #\u03b9 * Cardinal.lift.{w} (Module.rank R M)", "start": [37, 1], "end": [42, 24], "kind": "commanddeclaration"}, {"full_name": "rank_finsupp'", "code": "theorem rank_finsupp' (\u03b9 : Type v) : Module.rank R (\u03b9 \u2192\u2080 M) = #\u03b9 * Module.rank R M", "start": [45, 1], "end": [46, 22], "kind": "commanddeclaration"}, {"full_name": "rank_finsupp_self", "code": "theorem rank_finsupp_self (\u03b9 : Type w) : Module.rank R (\u03b9 \u2192\u2080 R) = Cardinal.lift.{u} #\u03b9", "start": [49, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "rank_finsupp_self'", "code": "theorem rank_finsupp_self' {\u03b9 : Type u} : Module.rank R (\u03b9 \u2192\u2080 R) = #\u03b9", "start": [56, 1], "end": [57, 81], "kind": "commanddeclaration"}, {"full_name": "rank_directSum", "code": "@[simp]\ntheorem rank_directSum {\u03b9 : Type v} (M : \u03b9 \u2192 Type w) [\u2200 i : \u03b9, AddCommGroup (M i)]\n    [\u2200 i : \u03b9, Module R (M i)] [\u2200 i : \u03b9, Module.Free R (M i)] :\n    Module.rank R (\u2a01 i, M i) = Cardinal.sum fun i => Module.rank R (M i)", "start": [60, 1], "end": [67, 55], "kind": "commanddeclaration"}, {"full_name": "rank_matrix", "code": "@[simp]\ntheorem rank_matrix (m : Type v) (n : Type w) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) =\n      Cardinal.lift.{max v w u, v} #m * Cardinal.lift.{max v w u, w} #n", "start": [70, 1], "end": [79, 21], "kind": "commanddeclaration"}, {"full_name": "rank_matrix'", "code": "@[simp high]\ntheorem rank_matrix' (m n : Type v) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) = Cardinal.lift.{u} (#m * #n)", "start": [82, 1], "end": [87, 47], "kind": "commanddeclaration"}, {"full_name": "rank_matrix''", "code": "theorem rank_matrix'' (m n : Type u) [Finite m] [Finite n] :\n    Module.rank R (Matrix m n R) = #m * #n", "start": [90, 1], "end": [94, 54], "kind": "commanddeclaration"}, {"full_name": "rank_tensorProduct", "code": "@[simp]\ntheorem rank_tensorProduct :\n    Module.rank R (M \u2297[R] N) =\n      Cardinal.lift.{w, v} (Module.rank R M) * Cardinal.lift.{v, w} (Module.rank R N)", "start": [109, 1], "end": [116, 100], "kind": "commanddeclaration"}, {"full_name": "rank_tensorProduct'", "code": "theorem rank_tensorProduct' (N : Type v) [AddCommGroup N] [Module R N] [Module.Free R N] :\n    Module.rank R (M \u2297[R] N) = Module.rank R M * Module.rank R N", "start": [119, 1], "end": [122, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Digits.lean", "imports": ["Mathlib/Data/List/Indexes.lean", "Mathlib/Algebra/Parity.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Data/Nat/Log.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/BigOperators/Lemmas.lean", "Mathlib/Data/Nat/Bits.lean", "Mathlib/Data/List/Palindrome.lean"], "premises": [{"full_name": "Nat.digitsAux0", "code": "def digitsAux0 : \u2115 \u2192 List \u2115\n  | 0 => []\n  | n + 1 => [n + 1]", "start": [39, 1], "end": [42, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.digitsAux1", "code": "def digitsAux1 (n : \u2115) : List \u2115 :=\n  List.replicate n 1", "start": [45, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.digitsAux", "code": "def digitsAux (b : \u2115) (h : 2 \u2264 b) : \u2115 \u2192 List \u2115\n  | 0 => []\n  | n + 1 =>\n    ((n + 1) % b) :: digitsAux b h ((n + 1) / b)\ndecreasing_by exact Nat.div_lt_self (Nat.succ_pos _) h", "start": [50, 1], "end": [55, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.digitsAux_zero", "code": "@[simp]\ntheorem digitsAux_zero (b : \u2115) (h : 2 \u2264 b) : digitsAux b h 0 = []", "start": [58, 1], "end": [59, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.digitsAux_def", "code": "theorem digitsAux_def (b : \u2115) (h : 2 \u2264 b) (n : \u2115) (w : 0 < n) :\n    digitsAux b h n = (n % b) :: digitsAux b h (n / b)", "start": [62, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.digits", "code": "def digits : \u2115 \u2192 \u2115 \u2192 List \u2115\n  | 0 => digitsAux0\n  | 1 => digitsAux1\n  | b + 2 => digitsAux (b + 2) (by norm_num)", "start": [69, 1], "end": [85, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_zero", "code": "@[simp]\ntheorem digits_zero (b : \u2115) : digits b 0 = []", "start": [88, 1], "end": [90, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_zero_zero", "code": "theorem digits_zero_zero : digits 0 0 = []", "start": [94, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_zero_succ", "code": "@[simp]\ntheorem digits_zero_succ (n : \u2115) : digits 0 n.succ = [n + 1]", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_zero_succ'", "code": "theorem digits_zero_succ' : \u2200 {n : \u2115}, n \u2260 0 \u2192 digits 0 n = [n]", "start": [103, 1], "end": [105, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_one", "code": "@[simp]\ntheorem digits_one (n : \u2115) : digits 1 n = List.replicate n 1", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_one_succ", "code": "theorem digits_one_succ (n : \u2115) : digits 1 (n + 1) = 1 :: digits 1 n", "start": [114, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_add_two_add_one", "code": "theorem digits_add_two_add_one (b n : \u2115) :\n    digits (b + 2) (n + 1) = ((n + 1) % (b + 2)) :: digits (b + 2) ((n + 1) / (b + 2))", "start": [118, 1], "end": [120, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_of_two_le_of_pos", "code": "@[simp]\nlemma digits_of_two_le_of_pos {b : \u2115} (hb : 2 \u2264 b) (hn : 0 < n) :\n    Nat.digits b n = n % b :: Nat.digits b (n / b) := by\n  rw [Nat.eq_add_of_sub_eq hb rfl, Nat.eq_add_of_sub_eq hn rfl, Nat.digits_add_two_add_one]", "start": [123, 1], "end": [126, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.digits_def'", "code": "theorem digits_def' :\n    \u2200 {b : \u2115} (_ : 1 < b) {n : \u2115} (_ : 0 < n), digits b n = (n % b) :: digits b (n / b)", "start": [128, 1], "end": [132, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_of_lt", "code": "@[simp]\ntheorem digits_of_lt (b x : \u2115) (hx : x \u2260 0) (hxb : x < b) : digits b x = [x]", "start": [135, 1], "end": [139, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_add", "code": "theorem digits_add (b : \u2115) (h : 1 < b) (x y : \u2115) (hxb : x < b) (hxy : x \u2260 0 \u2228 y \u2260 0) :\n    digits b (x + b * y) = x :: digits b y", "start": [142, 1], "end": [152, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits", "code": "def ofDigits {\u03b1 : Type*} [Semiring \u03b1] (b : \u03b1) : List \u2115 \u2192 \u03b1\n  | [] => 0\n  | h :: t => h + b * ofDigits b t", "start": [158, 1], "end": [163, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_eq_foldr", "code": "theorem ofDigits_eq_foldr {\u03b1 : Type*} [Semiring \u03b1] (b : \u03b1) (L : List \u2115) :\n    ofDigits b L = List.foldr (fun x y => \u2191x + b * y) 0 L", "start": [166, 1], "end": [171, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_eq_sum_map_with_index_aux", "code": "theorem ofDigits_eq_sum_map_with_index_aux (b : \u2115) (l : List \u2115) :\n    ((List.range l.length).zipWith ((fun i a : \u2115 => a * b ^ (i + 1))) l).sum =\n      b * ((List.range l.length).zipWith (fun i a => a * b ^ i) l).sum", "start": [174, 1], "end": [181, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_eq_sum_mapIdx", "code": "theorem ofDigits_eq_sum_mapIdx (b : \u2115) (L : List \u2115) :\n    ofDigits b L = (L.mapIdx fun i a => a * b ^ i).sum", "start": [184, 1], "end": [191, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_singleton", "code": "@[simp]\ntheorem ofDigits_singleton {b n : \u2115} : ofDigits b [n] = n", "start": [194, 1], "end": [195, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_one_cons", "code": "@[simp]\ntheorem ofDigits_one_cons {\u03b1 : Type*} [Semiring \u03b1] (h : \u2115) (L : List \u2115) :\n    ofDigits (1 : \u03b1) (h :: L) = h + ofDigits 1 L", "start": [198, 1], "end": [200, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_append", "code": "theorem ofDigits_append {b : \u2115} {l1 l2 : List \u2115} :\n    ofDigits b (l1 ++ l2) = ofDigits b l1 + b ^ l1.length * ofDigits b l2", "start": [203, 1], "end": [208, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_ofDigits", "code": "@[norm_cast]\ntheorem coe_ofDigits (\u03b1 : Type*) [Semiring \u03b1] (b : \u2115) (L : List \u2115) :\n    ((ofDigits b L : \u2115) : \u03b1) = ofDigits (b : \u03b1) L", "start": [211, 1], "end": [216, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_int_ofDigits", "code": "@[norm_cast]\ntheorem coe_int_ofDigits (b : \u2115) (L : List \u2115) : ((ofDigits b L : \u2115) : \u2124) = ofDigits (b : \u2124) L", "start": [219, 1], "end": [223, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_zero_of_eq_zero", "code": "theorem digits_zero_of_eq_zero {b : \u2115} (h : b \u2260 0) :\n    \u2200 {L : List \u2115} (_ : ofDigits b L = 0), \u2200 l \u2208 L, l = 0", "start": [226, 1], "end": [230, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_ofDigits", "code": "theorem digits_ofDigits (b : \u2115) (h : 1 < b) (L : List \u2115) (w\u2081 : \u2200 l \u2208 L, l < b)\n    (w\u2082 : \u2200 h : L \u2260 [], L.getLast h \u2260 0) : digits b (ofDigits b L) = L", "start": [233, 1], "end": [257, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_digits", "code": "theorem ofDigits_digits (b n : \u2115) : ofDigits b (digits b n) = n", "start": [260, 1], "end": [280, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_one", "code": "theorem ofDigits_one (L : List \u2115) : ofDigits 1 L = L.sum", "start": [283, 1], "end": [286, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_eq_nil_iff_eq_zero", "code": "theorem digits_eq_nil_iff_eq_zero {b n : \u2115} : digits b n = [] \u2194 n = 0", "start": [296, 1], "end": [303, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_ne_nil_iff_ne_zero", "code": "theorem digits_ne_nil_iff_ne_zero {b n : \u2115} : digits b n \u2260 [] \u2194 n \u2260 0", "start": [306, 1], "end": [307, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_eq_cons_digits_div", "code": "theorem digits_eq_cons_digits_div {b n : \u2115} (h : 1 < b) (w : n \u2260 0) :\n    digits b n = (n % b) :: digits b (n / b)", "start": [310, 1], "end": [317, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_getLast", "code": "theorem digits_getLast {b : \u2115} (m : \u2115) (h : 1 < b) (p q) :\n    (digits b m).getLast p = (digits b (m / b)).getLast q", "start": [320, 1], "end": [325, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.digits.injective", "code": "theorem digits.injective (b : \u2115) : Function.Injective b.digits", "start": [328, 1], "end": [329, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_inj_iff", "code": "@[simp]\ntheorem digits_inj_iff {b n m : \u2115} : b.digits n = b.digits m \u2194 n = m", "start": [332, 1], "end": [334, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_len", "code": "theorem digits_len (b n : \u2115) (hb : 1 < b) (hn : n \u2260 0) : (b.digits n).length = b.log n + 1", "start": [337, 1], "end": [347, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.getLast_digit_ne_zero", "code": "theorem getLast_digit_ne_zero (b : \u2115) {m : \u2115} (hm : m \u2260 0) :\n    (digits b m).getLast (digits_ne_nil_iff_ne_zero.mpr hm) \u2260 0", "start": [350, 1], "end": [368, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_lt_base'", "code": "theorem digits_lt_base' {b m : \u2115} : \u2200 {d}, d \u2208 digits (b + 2) m \u2192 d < b + 2", "start": [371, 1], "end": [386, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_lt_base", "code": "theorem digits_lt_base {b m d : \u2115} (hb : 1 < b) (hd : d \u2208 digits b m) : d < b", "start": [389, 1], "end": [392, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_lt_base_pow_length'", "code": "theorem ofDigits_lt_base_pow_length' {b : \u2115} {l : List \u2115} (hl : \u2200 x \u2208 l, x < b + 2) :\n    ofDigits (b + 2) l < (b + 2) ^ l.length", "start": [395, 1], "end": [406, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_lt_base_pow_length", "code": "theorem ofDigits_lt_base_pow_length {b : \u2115} {l : List \u2115} (hb : 1 < b) (hl : \u2200 x \u2208 l, x < b) :\n    ofDigits b l < b ^ l.length", "start": [409, 1], "end": [413, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_base_pow_length_digits'", "code": "theorem lt_base_pow_length_digits' {b m : \u2115} : m < (b + 2) ^ (digits (b + 2) m).length", "start": [416, 1], "end": [419, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_base_pow_length_digits", "code": "theorem lt_base_pow_length_digits {b m : \u2115} (hb : 1 < b) : m < b ^ (digits b m).length", "start": [422, 1], "end": [425, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_digits_append_digits", "code": "theorem ofDigits_digits_append_digits {b m n : \u2115} :\n    ofDigits b (digits b n ++ digits b m) = n + b ^ (digits b n).length * m", "start": [428, 1], "end": [430, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_append_digits", "code": "theorem digits_append_digits {b m n : \u2115} (hb : 0 < b) :\n    digits b n ++ digits b m = digits b (n + b ^ (digits b n).length * m)", "start": [433, 1], "end": [444, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_len_le_digits_len_succ", "code": "theorem digits_len_le_digits_len_succ (b n : \u2115) :\n    (digits b n).length \u2264 (digits b (n + 1)).length", "start": [446, 1], "end": [452, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.le_digits_len_le", "code": "theorem le_digits_len_le (b n m : \u2115) (h : n \u2264 m) : (digits b n).length \u2264 (digits b m).length", "start": [455, 1], "end": [456, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_monotone", "code": "@[mono]\ntheorem ofDigits_monotone {p q : \u2115} (L : List \u2115) (h : p \u2264 q) : ofDigits p L \u2264 ofDigits q L", "start": [459, 1], "end": [464, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_le_ofDigits", "code": "theorem sum_le_ofDigits (L : List \u2115) (h: 1 \u2264 p) : L.sum \u2264 ofDigits p L", "start": [466, 1], "end": [467, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.digit_sum_le", "code": "theorem digit_sum_le (p n : \u2115) : List.sum (digits p n) \u2264 n", "start": [469, 1], "end": [476, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_length_le_mul_ofDigits", "code": "theorem pow_length_le_mul_ofDigits {b : \u2115} {l : List \u2115} (hl : l \u2260 []) (hl2 : l.getLast hl \u2260 0) :\n    (b + 2) ^ l.length \u2264 (b + 2) * ofDigits (b + 2) l", "start": [478, 1], "end": [487, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.base_pow_length_digits_le'", "code": "theorem base_pow_length_digits_le' (b m : \u2115) (hm : m \u2260 0) :\n    (b + 2) ^ (digits (b + 2) m).length \u2264 (b + 2) * m", "start": [490, 1], "end": [498, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.base_pow_length_digits_le", "code": "theorem base_pow_length_digits_le (b m : \u2115) (hb : 1 < b) :\n    m \u2260 0 \u2192 b ^ (digits b m).length \u2264 b * m", "start": [501, 1], "end": [507, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_div_eq_ofDigits_tail", "code": "lemma ofDigits_div_eq_ofDigits_tail (hpos : 0 < p) (digits : List \u2115)\n    (w\u2081 : \u2200 l \u2208 digits, l < p) : ofDigits p digits / p = ofDigits p digits.tail := by\n  induction' digits with hd tl\n  \u00b7 simp [ofDigits]\n  \u00b7 refine' Eq.trans (add_mul_div_left hd _ hpos) _\n    rw [Nat.div_eq_of_lt <| w\u2081 _ <| List.mem_cons_self _ _, zero_add]\n    rfl", "start": [510, 1], "end": [518, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ofDigits_div_pow_eq_ofDigits_drop", "code": "lemma ofDigits_div_pow_eq_ofDigits_drop\n    (i : \u2115) (hpos : 0 < p) (digits : List \u2115) (w\u2081 : \u2200 l \u2208 digits, l < p) :\n    ofDigits p digits / p ^ i = ofDigits p (digits.drop i) := by\n  induction' i with i hi\n  \u00b7 simp\n  \u00b7 rw [Nat.pow_succ, \u2190 Nat.div_div_eq_div_mul, hi, ofDigits_div_eq_ofDigits_tail hpos\n      (List.drop i digits) <| fun x hx \u21a6 w\u2081 x <| List.mem_of_mem_drop hx, \u2190 List.drop_one,\n      List.drop_drop, add_comm]", "start": [520, 1], "end": [529, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.self_div_pow_eq_ofDigits_drop", "code": "lemma self_div_pow_eq_ofDigits_drop (i n : \u2115) (h : 2 \u2264 p):\n    n / p ^ i = ofDigits p ((p.digits n).drop i) := by\n  convert ofDigits_div_pow_eq_ofDigits_drop i (zero_lt_of_lt h) (p.digits n)\n    (fun l hl \u21a6 digits_lt_base h hl)\n  exact (ofDigits_digits p n).symm", "start": [531, 1], "end": [537, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.sub_one_mul_sum_div_pow_eq_sub_sum_digits", "code": "theorem sub_one_mul_sum_div_pow_eq_sub_sum_digits\n    (L : List \u2115) {h_nonempty} (h_ne_zero : L.getLast h_nonempty \u2260 0) (h_lt : \u2200 l \u2208 L, l < p) :\n    (p - 1) * \u2211 i in range L.length, (ofDigits p L) / p ^ i.succ = (ofDigits p L) - L.sum", "start": [541, 1], "end": [573, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_one_mul_sum_log_div_pow_eq_sub_sum_digits", "code": "theorem sub_one_mul_sum_log_div_pow_eq_sub_sum_digits (n : \u2115) :\n    (p - 1) * \u2211 i in range (log p n).succ, n / p ^ i.succ = n - (p.digits n).sum", "start": [575, 1], "end": [587, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.digits_two_eq_bits", "code": "theorem digits_two_eq_bits (n : \u2115) : digits 2 n = n.bits.map fun b => cond b 1 0", "start": [592, 1], "end": [601, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_ofDigits_sub_ofDigits", "code": "theorem dvd_ofDigits_sub_ofDigits {\u03b1 : Type*} [CommRing \u03b1] {a b k : \u03b1} (h : k \u2223 a - b)\n    (L : List \u2115) : k \u2223 ofDigits a L - ofDigits b L", "start": [608, 1], "end": [614, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_modEq'", "code": "theorem ofDigits_modEq' (b b' : \u2115) (k : \u2115) (h : b \u2261 b' [MOD k]) (L : List \u2115) :\n    ofDigits b L \u2261 ofDigits b' L [MOD k]", "start": [617, 1], "end": [624, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_modEq", "code": "theorem ofDigits_modEq (b k : \u2115) (L : List \u2115) : ofDigits b L \u2261 ofDigits (b % k) L [MOD k]", "start": [627, 1], "end": [628, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_mod", "code": "theorem ofDigits_mod (b k : \u2115) (L : List \u2115) : ofDigits b L % k = ofDigits (b % k) L % k", "start": [631, 1], "end": [632, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_zmodeq'", "code": "theorem ofDigits_zmodeq' (b b' : \u2124) (k : \u2115) (h : b \u2261 b' [ZMOD k]) (L : List \u2115) :\n    ofDigits b L \u2261 ofDigits b' L [ZMOD k]", "start": [635, 1], "end": [642, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_zmodeq", "code": "theorem ofDigits_zmodeq (b : \u2124) (k : \u2115) (L : List \u2115) : ofDigits b L \u2261 ofDigits (b % k) L [ZMOD k]", "start": [645, 1], "end": [646, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_zmod", "code": "theorem ofDigits_zmod (b : \u2124) (k : \u2115) (L : List \u2115) : ofDigits b L % k = ofDigits (b % k) L % k", "start": [649, 1], "end": [650, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_digits_sum", "code": "theorem modEq_digits_sum (b b' : \u2115) (h : b' % b = 1) (n : \u2115) : n \u2261 (digits b' n).sum [MOD b]", "start": [653, 1], "end": [660, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_three_digits_sum", "code": "theorem modEq_three_digits_sum (n : \u2115) : n \u2261 (digits 10 n).sum [MOD 3]", "start": [663, 1], "end": [664, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_nine_digits_sum", "code": "theorem modEq_nine_digits_sum (n : \u2115) : n \u2261 (digits 10 n).sum [MOD 9]", "start": [667, 1], "end": [668, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.zmodeq_ofDigits_digits", "code": "theorem zmodeq_ofDigits_digits (b b' : \u2115) (c : \u2124) (h : b' \u2261 c [ZMOD b]) (n : \u2115) :\n    n \u2261 ofDigits c (digits b' n) [ZMOD b]", "start": [671, 1], "end": [678, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.ofDigits_neg_one", "code": "theorem ofDigits_neg_one :\n    \u2200 L : List \u2115, ofDigits (-1 : \u2124) L = (L.map fun n : \u2115 => (n : \u2124)).alternatingSum", "start": [681, 1], "end": [687, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_eleven_digits_sum", "code": "theorem modEq_eleven_digits_sum (n : \u2115) :\n    n \u2261 ((digits 10 n).map fun n : \u2115 => (n : \u2124)).alternatingSum [ZMOD 11]", "start": [690, 1], "end": [693, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_dvd_digits_sum", "code": "theorem dvd_iff_dvd_digits_sum (b b' : \u2115) (h : b' % b = 1) (n : \u2115) :\n    b \u2223 n \u2194 b \u2223 (digits b' n).sum", "start": [699, 1], "end": [703, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.three_dvd_iff", "code": "theorem three_dvd_iff (n : \u2115) : 3 \u2223 n \u2194 3 \u2223 (digits 10 n).sum", "start": [706, 1], "end": [708, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.nine_dvd_iff", "code": "theorem nine_dvd_iff (n : \u2115) : 9 \u2223 n \u2194 9 \u2223 (digits 10 n).sum", "start": [711, 1], "end": [712, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_dvd_ofDigits", "code": "theorem dvd_iff_dvd_ofDigits (b b' : \u2115) (c : \u2124) (h : (b : \u2124) \u2223 (b' : \u2124) - c) (n : \u2115) :\n    b \u2223 n \u2194 (b : \u2124) \u2223 ofDigits c (digits b' n)", "start": [715, 1], "end": [719, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.eleven_dvd_iff", "code": "theorem eleven_dvd_iff :\n    11 \u2223 n \u2194 (11 : \u2124) \u2223 ((digits 10 n).map fun n : \u2115 => (n : \u2124)).alternatingSum", "start": [722, 1], "end": [726, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.eleven_dvd_of_palindrome", "code": "theorem eleven_dvd_of_palindrome (p : (digits 10 n).Palindrome) (h : Even (digits 10 n).length) :\n    11 \u2223 n", "start": [729, 1], "end": [736, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.NormDigits.digits_succ", "code": "theorem digits_succ (b n m r l) (e : r + b * m = n) (hr : r < b)\n    (h : Nat.digits b m = l \u2227 1 < b \u2227 0 < m) : (Nat.digits b n = r :: l) \u2227 1 < b \u2227 0 < n", "start": [744, 1], "end": [751, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.NormDigits.digits_one", "code": "theorem digits_one (b n) (n0 : 0 < n) (nb : n < b) : Nat.digits b n = [n] \u2227 1 < b \u2227 0 < n", "start": [754, 1], "end": [759, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/ENNReal.lean", "imports": ["Mathlib/Topology/Algebra/Order/T5.lean", "Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "Mathlib/Topology/Instances/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/MetricSpace/Lipschitz.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean"], "premises": [{"full_name": "ENNReal.embedding_coe", "code": "theorem embedding_coe : Embedding ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)", "start": [50, 1], "end": [51, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.isOpen_ne_top", "code": "theorem isOpen_ne_top : IsOpen { a : \u211d\u22650\u221e | a \u2260 \u22a4 }", "start": [54, 1], "end": [54, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.isOpen_Ico_zero", "code": "theorem isOpen_Ico_zero : IsOpen (Ico 0 b)", "start": [57, 1], "end": [59, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.openEmbedding_coe", "code": "theorem openEmbedding_coe : OpenEmbedding ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)", "start": [62, 1], "end": [63, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_range_mem_nhds", "code": "theorem coe_range_mem_nhds : range ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e) \u2208 \ud835\udcdd (r : \u211d\u22650\u221e)", "start": [66, 1], "end": [67, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_coe", "code": "@[norm_cast]\ntheorem tendsto_coe {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650} {a : \u211d\u22650} :\n    Tendsto (fun a => (m a : \u211d\u22650\u221e)) f (\ud835\udcdd \u2191a) \u2194 Tendsto m f (\ud835\udcdd a)", "start": [70, 1], "end": [73, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_coe", "code": "theorem continuous_coe : Continuous ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)", "start": [76, 1], "end": [77, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_coe_iff", "code": "theorem continuous_coe_iff {\u03b1} [TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d\u22650} :\n    (Continuous fun a => (f a : \u211d\u22650\u221e)) \u2194 Continuous f", "start": [80, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_coe", "code": "theorem nhds_coe {r : \u211d\u22650} : \ud835\udcdd (r : \u211d\u22650\u221e) = (\ud835\udcdd r).map (\u2191)", "start": [85, 1], "end": [86, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_coe_iff", "code": "theorem tendsto_nhds_coe_iff {\u03b1 : Type*} {l : Filter \u03b1} {x : \u211d\u22650} {f : \u211d\u22650\u221e \u2192 \u03b1} :\n    Tendsto f (\ud835\udcdd \u2191x) l \u2194 Tendsto (f \u2218 (\u2191) : \u211d\u22650 \u2192 \u03b1) (\ud835\udcdd x) l", "start": [89, 1], "end": [91, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousAt_coe_iff", "code": "theorem continuousAt_coe_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] {x : \u211d\u22650} {f : \u211d\u22650\u221e \u2192 \u03b1} :\n    ContinuousAt f \u2191x \u2194 ContinuousAt (f \u2218 (\u2191) : \u211d\u22650 \u2192 \u03b1) x", "start": [94, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_coe_coe", "code": "theorem nhds_coe_coe {r p : \u211d\u22650} :\n    \ud835\udcdd ((r : \u211d\u22650\u221e), (p : \u211d\u22650\u221e)) = (\ud835\udcdd (r, p)).map fun p : \u211d\u22650 \u00d7 \u211d\u22650 => (\u2191p.1, \u2191p.2)", "start": [99, 1], "end": [101, 71], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_ofReal", "code": "theorem continuous_ofReal : Continuous ENNReal.ofReal", "start": [104, 1], "end": [105, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_ofReal", "code": "theorem tendsto_ofReal {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d} {a : \u211d} (h : Tendsto m f (\ud835\udcdd a)) :\n    Tendsto (fun a => ENNReal.ofReal (m a)) f (\ud835\udcdd (ENNReal.ofReal a))", "start": [108, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_toNNReal", "code": "theorem tendsto_toNNReal {a : \u211d\u22650\u221e} (ha : a \u2260 \u22a4) :\n    Tendsto ENNReal.toNNReal (\ud835\udcdd a) (\ud835\udcdd a.toNNReal)", "start": [113, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eventuallyEq_of_toReal_eventuallyEq", "code": "theorem eventuallyEq_of_toReal_eventuallyEq {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hfi : \u2200\u1da0 x in l, f x \u2260 \u221e) (hgi : \u2200\u1da0 x in l, g x \u2260 \u221e)\n    (hfg : (fun x => (f x).toReal) =\u1da0[l] fun x => (g x).toReal) : f =\u1da0[l] g", "start": [120, 1], "end": [124, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousOn_toNNReal", "code": "theorem continuousOn_toNNReal : ContinuousOn ENNReal.toNNReal { a | a \u2260 \u221e }", "start": [127, 1], "end": [128, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_toReal", "code": "theorem tendsto_toReal {a : \u211d\u22650\u221e} (ha : a \u2260 \u22a4) : Tendsto ENNReal.toReal (\ud835\udcdd a) (\ud835\udcdd a.toReal)", "start": [131, 1], "end": [132, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.neTopHomeomorphNNReal", "code": "def neTopHomeomorphNNReal : { a | a \u2260 \u221e } \u2243\u209c \u211d\u22650 where\n  toEquiv := neTopEquivNNReal\n  continuous_toFun := continuousOn_iff_continuous_restrict.1 continuousOn_toNNReal\n  continuous_invFun := continuous_coe.subtype_mk _", "start": [135, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ltTopHomeomorphNNReal", "code": "def ltTopHomeomorphNNReal : { a | a < \u221e } \u2243\u209c \u211d\u22650 := by\n  refine' (Homeomorph.setCongr _).trans neTopHomeomorphNNReal\n  simp only [mem_setOf_eq, lt_top_iff_ne_top]", "start": [142, 1], "end": [145, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_top", "code": "theorem nhds_top : \ud835\udcdd \u221e = \u2a05 (a) (_ : a \u2260 \u221e), \ud835\udcdf (Ioi a)", "start": [148, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_top'", "code": "theorem nhds_top' : \ud835\udcdd \u221e = \u2a05 r : \u211d\u22650, \ud835\udcdf (Ioi \u2191r)", "start": [152, 1], "end": [153, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_top_basis", "code": "theorem nhds_top_basis : (\ud835\udcdd \u221e).HasBasis (fun a => a < \u221e) fun a => Ioi a", "start": [156, 1], "end": [157, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_top_iff_nnreal", "code": "theorem tendsto_nhds_top_iff_nnreal {m : \u03b1 \u2192 \u211d\u22650\u221e} {f : Filter \u03b1} :\n    Tendsto m f (\ud835\udcdd \u22a4) \u2194 \u2200 x : \u211d\u22650, \u2200\u1da0 a in f, \u2191x < m a", "start": [160, 1], "end": [162, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_top_iff_nat", "code": "theorem tendsto_nhds_top_iff_nat {m : \u03b1 \u2192 \u211d\u22650\u221e} {f : Filter \u03b1} :\n    Tendsto m f (\ud835\udcdd \u22a4) \u2194 \u2200 n : \u2115, \u2200\u1da0 a in f, \u2191n < m a", "start": [165, 1], "end": [170, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_top", "code": "theorem tendsto_nhds_top {m : \u03b1 \u2192 \u211d\u22650\u221e} {f : Filter \u03b1} (h : \u2200 n : \u2115, \u2200\u1da0 a in f, \u2191n < m a) :\n    Tendsto m f (\ud835\udcdd \u22a4)", "start": [173, 1], "end": [175, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nat_nhds_top", "code": "theorem tendsto_nat_nhds_top : Tendsto (fun n : \u2115 => \u2191n) atTop (\ud835\udcdd \u221e)", "start": [178, 1], "end": [180, 96], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_coe_nhds_top", "code": "@[simp, norm_cast]\ntheorem tendsto_coe_nhds_top {f : \u03b1 \u2192 \u211d\u22650} {l : Filter \u03b1} :\n    Tendsto (fun x => (f x : \u211d\u22650\u221e)) l (\ud835\udcdd \u221e) \u2194 Tendsto f l atTop", "start": [183, 1], "end": [186, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_ofReal_atTop", "code": "theorem tendsto_ofReal_atTop : Tendsto ENNReal.ofReal atTop (\ud835\udcdd \u221e)", "start": [189, 1], "end": [190, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_zero", "code": "theorem nhds_zero : \ud835\udcdd (0 : \u211d\u22650\u221e) = \u2a05 (a) (_ : a \u2260 0), \ud835\udcdf (Iio a)", "start": [193, 1], "end": [194, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_zero_basis", "code": "theorem nhds_zero_basis : (\ud835\udcdd (0 : \u211d\u22650\u221e)).HasBasis (fun a : \u211d\u22650\u221e => 0 < a) fun a => Iio a", "start": [197, 1], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_zero_basis_Iic", "code": "theorem nhds_zero_basis_Iic : (\ud835\udcdd (0 : \u211d\u22650\u221e)).HasBasis (fun a : \u211d\u22650\u221e => 0 < a) Iic", "start": [201, 1], "end": [202, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Ioi_coe_neBot", "code": "@[instance]\ntheorem nhdsWithin_Ioi_coe_neBot {r : \u211d\u22650} : (\ud835\udcdd[>] (r : \u211d\u22650\u221e)).NeBot", "start": [206, 1], "end": [208, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Ioi_zero_neBot", "code": "@[instance]\ntheorem nhdsWithin_Ioi_zero_neBot : (\ud835\udcdd[>] (0 : \u211d\u22650\u221e)).NeBot", "start": [211, 1], "end": [213, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Ioi_one_neBot", "code": "@[instance]\ntheorem nhdsWithin_Ioi_one_neBot : (\ud835\udcdd[>] (1 : \u211d\u22650\u221e)).NeBot", "start": [216, 1], "end": [217, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Ioi_nat_neBot", "code": "@[instance]\ntheorem nhdsWithin_Ioi_nat_neBot (n : \u2115) : (\ud835\udcdd[>] (n : \u211d\u22650\u221e)).NeBot", "start": [219, 1], "end": [220, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Ioi_ofNat_nebot", "code": "@[instance]\ntheorem nhdsWithin_Ioi_ofNat_nebot (n : \u2115) [n.AtLeastTwo] :\n    (\ud835\udcdd[>] (OfNat.ofNat n : \u211d\u22650\u221e)).NeBot", "start": [222, 1], "end": [224, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhdsWithin_Iio_neBot", "code": "@[instance]\ntheorem nhdsWithin_Iio_neBot [NeZero x] : (\ud835\udcdd[<] x).NeBot", "start": [226, 1], "end": [228, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasBasis_nhds_of_ne_top'", "code": "theorem hasBasis_nhds_of_ne_top' (xt : x \u2260 \u221e) :\n    (\ud835\udcdd x).HasBasis (\u00b7 \u2260 0) (fun \u03b5 => Icc (x - \u03b5) (x + \u03b5))", "start": [230, 1], "end": [247, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasBasis_nhds_of_ne_top", "code": "theorem hasBasis_nhds_of_ne_top (xt : x \u2260 \u221e) :\n    (\ud835\udcdd x).HasBasis (0 < \u00b7) (fun \u03b5 => Icc (x - \u03b5) (x + \u03b5))", "start": [249, 1], "end": [251, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Icc_mem_nhds", "code": "theorem Icc_mem_nhds (xt : x \u2260 \u221e) (\u03b50 : \u03b5 \u2260 0) : Icc (x - \u03b5) (x + \u03b5) \u2208 \ud835\udcdd x", "start": [253, 1], "end": [254, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nhds_of_ne_top", "code": "theorem nhds_of_ne_top (xt : x \u2260 \u22a4) : \ud835\udcdd x = \u2a05 \u03b5 > 0, \ud835\udcdf (Icc (x - \u03b5) (x + \u03b5))", "start": [257, 1], "end": [258, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.biInf_le_nhds", "code": "theorem biInf_le_nhds : \u2200 x : \u211d\u22650\u221e, \u2a05 \u03b5 > 0, \ud835\udcdf (Icc (x - \u03b5) (x + \u03b5)) \u2264 \ud835\udcdd x", "start": [261, 1], "end": [264, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_of_Icc", "code": "protected theorem tendsto_nhds_of_Icc {f : Filter \u03b1} {u : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e}\n    (h : \u2200 \u03b5 > 0, \u2200\u1da0 x in f, u x \u2208 Icc (a - \u03b5) (a + \u03b5)) : Tendsto u f (\ud835\udcdd a)", "start": [267, 1], "end": [270, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds", "code": "protected theorem tendsto_nhds {f : Filter \u03b1} {u : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (ha : a \u2260 \u22a4) :\n    Tendsto u f (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in f, u x \u2208 Icc (a - \u03b5) (a + \u03b5)", "start": [272, 1], "end": [276, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nhds_zero", "code": "protected theorem tendsto_nhds_zero {f : Filter \u03b1} {u : \u03b1 \u2192 \u211d\u22650\u221e} :\n    Tendsto u f (\ud835\udcdd 0) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in f, u x \u2264 \u03b5", "start": [279, 1], "end": [281, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_atTop", "code": "protected theorem tendsto_atTop [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e}\n    (ha : a \u2260 \u22a4) : Tendsto f atTop (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, f n \u2208 Icc (a - \u03b5) (a + \u03b5)", "start": [284, 1], "end": [286, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_atTop_zero", "code": "protected theorem tendsto_atTop_zero [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u211d\u22650\u221e} :\n    Tendsto f atTop (\ud835\udcdd 0) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, f n \u2264 \u03b5", "start": [298, 1], "end": [300, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_sub", "code": "theorem tendsto_sub : \u2200 {a b : \u211d\u22650\u221e}, (a \u2260 \u221e \u2228 b \u2260 \u221e) \u2192\n    Tendsto (fun p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e => p.1 - p.2) (\ud835\udcdd (a, b)) (\ud835\udcdd (a - b))", "start": [303, 1], "end": [321, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.sub", "code": "protected theorem Tendsto.sub {f : Filter \u03b1} {ma : \u03b1 \u2192 \u211d\u22650\u221e} {mb : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hma : Tendsto ma f (\ud835\udcdd a)) (hmb : Tendsto mb f (\ud835\udcdd b)) (h : a \u2260 \u221e \u2228 b \u2260 \u221e) :\n    Tendsto (fun a => ma a - mb a) f (\ud835\udcdd (a - b))", "start": [324, 1], "end": [328, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_mul", "code": "protected theorem tendsto_mul (ha : a \u2260 0 \u2228 b \u2260 \u22a4) (hb : b \u2260 0 \u2228 a \u2260 \u22a4) :\n    Tendsto (fun p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e => p.1 * p.2) (\ud835\udcdd (a, b)) (\ud835\udcdd (a * b))", "start": [331, 1], "end": [350, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.mul", "code": "protected theorem Tendsto.mul {f : Filter \u03b1} {ma : \u03b1 \u2192 \u211d\u22650\u221e} {mb : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hma : Tendsto ma f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 \u22a4) (hmb : Tendsto mb f (\ud835\udcdd b))\n    (hb : b \u2260 0 \u2228 a \u2260 \u22a4) : Tendsto (fun a => ma a * mb a) f (\ud835\udcdd (a * b))", "start": [353, 1], "end": [357, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.ennreal_mul", "code": "theorem _root_.ContinuousOn.ennreal_mul [TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h\u2081 : \u2200 x \u2208 s, f x \u2260 0 \u2228 g x \u2260 \u221e)\n    (h\u2082 : \u2200 x \u2208 s, g x \u2260 0 \u2228 f x \u2260 \u221e) : ContinuousOn (fun x => f x * g x) s", "start": [360, 1], "end": [363, 62], "kind": "commanddeclaration"}, {"full_name": "Continuous.ennreal_mul", "code": "theorem _root_.Continuous.ennreal_mul [TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : Continuous f)\n    (hg : Continuous g) (h\u2081 : \u2200 x, f x \u2260 0 \u2228 g x \u2260 \u221e) (h\u2082 : \u2200 x, g x \u2260 0 \u2228 f x \u2260 \u221e) :\n    Continuous fun x => f x * g x", "start": [366, 1], "end": [370, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.const_mul", "code": "protected theorem Tendsto.const_mul {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hm : Tendsto m f (\ud835\udcdd b)) (hb : b \u2260 0 \u2228 a \u2260 \u22a4) : Tendsto (fun b => a * m b) f (\ud835\udcdd (a * b))", "start": [373, 1], "end": [376, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.mul_const", "code": "protected theorem Tendsto.mul_const {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hm : Tendsto m f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 \u22a4) : Tendsto (fun x => m x * b) f (\ud835\udcdd (a * b))", "start": [379, 1], "end": [381, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_finset_prod_of_ne_top", "code": "theorem tendsto_finset_prod_of_ne_top {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {x : Filter \u03b1} {a : \u03b9 \u2192 \u211d\u22650\u221e}\n    (s : Finset \u03b9) (h : \u2200 i \u2208 s, Tendsto (f i) x (\ud835\udcdd (a i))) (h' : \u2200 i \u2208 s, a i \u2260 \u221e) :\n    Tendsto (fun b => \u220f c in s, f c b) x (\ud835\udcdd (\u220f c in s, a c))", "start": [384, 1], "end": [395, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousAt_const_mul", "code": "protected theorem continuousAt_const_mul {a b : \u211d\u22650\u221e} (h : a \u2260 \u22a4 \u2228 b \u2260 0) :\n    ContinuousAt ((\u00b7 * \u00b7) a) b", "start": [398, 1], "end": [400, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousAt_mul_const", "code": "protected theorem continuousAt_mul_const {a b : \u211d\u22650\u221e} (h : a \u2260 \u22a4 \u2228 b \u2260 0) :\n    ContinuousAt (fun x => x * a) b", "start": [403, 1], "end": [405, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_const_mul", "code": "protected theorem continuous_const_mul {a : \u211d\u22650\u221e} (ha : a \u2260 \u22a4) : Continuous ((\u00b7 * \u00b7) a)", "start": [408, 1], "end": [409, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_mul_const", "code": "protected theorem continuous_mul_const {a : \u211d\u22650\u221e} (ha : a \u2260 \u22a4) : Continuous fun x => x * a", "start": [412, 1], "end": [413, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_div_const", "code": "protected theorem continuous_div_const (c : \u211d\u22650\u221e) (c_ne_zero : c \u2260 0) :\n    Continuous fun x : \u211d\u22650\u221e => x / c", "start": [416, 1], "end": [420, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_pow", "code": "@[continuity]\ntheorem continuous_pow (n : \u2115) : Continuous fun a : \u211d\u22650\u221e => a ^ n", "start": [423, 1], "end": [434, 54], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousOn_sub", "code": "theorem continuousOn_sub :\n    ContinuousOn (fun p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e => p.fst - p.snd) { p : \u211d\u22650\u221e \u00d7 \u211d\u22650\u221e | p \u2260 \u27e8\u221e, \u221e\u27e9 }", "start": [437, 1], "end": [442, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_sub_left", "code": "theorem continuous_sub_left {a : \u211d\u22650\u221e} (a_ne_top : a \u2260 \u22a4) : Continuous (a - \u00b7)", "start": [445, 1], "end": [448, 92], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_nnreal_sub", "code": "theorem continuous_nnreal_sub {a : \u211d\u22650} : Continuous fun x : \u211d\u22650\u221e => (a : \u211d\u22650\u221e) - x", "start": [451, 1], "end": [452, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuousOn_sub_left", "code": "theorem continuousOn_sub_left (a : \u211d\u22650\u221e) : ContinuousOn (a - \u00b7) { x : \u211d\u22650\u221e | x \u2260 \u221e }", "start": [455, 1], "end": [459, 22], "kind": "commanddeclaration"}, {"full_name": "ENNReal.continuous_sub_right", "code": "theorem continuous_sub_right (a : \u211d\u22650\u221e) : Continuous fun x : \u211d\u22650\u221e => x - a", "start": [462, 1], "end": [468, 93], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.pow", "code": "protected theorem Tendsto.pow {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} {n : \u2115}\n    (hm : Tendsto m f (\ud835\udcdd a)) : Tendsto (fun x => m x ^ n) f (\ud835\udcdd (a ^ n))", "start": [471, 1], "end": [473, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_forall_lt_one_mul_le", "code": "theorem le_of_forall_lt_one_mul_le {x y : \u211d\u22650\u221e} (h : \u2200 a < 1, a * x \u2264 y) : x \u2264 y", "start": [476, 1], "end": [480, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul_left'", "code": "theorem iInf_mul_left' {\u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (h : a = \u22a4 \u2192 \u2a05 i, f i = 0 \u2192 \u2203 i, f i = 0)\n    (h0 : a = 0 \u2192 Nonempty \u03b9) : \u2a05 i, a * f i = a * \u2a05 i, f i", "start": [483, 1], "end": [494, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul_left", "code": "theorem iInf_mul_left {\u03b9} [Nonempty \u03b9] {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e}\n    (h : a = \u22a4 \u2192 \u2a05 i, f i = 0 \u2192 \u2203 i, f i = 0) : \u2a05 i, a * f i = a * \u2a05 i, f i", "start": [497, 1], "end": [499, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul_right'", "code": "theorem iInf_mul_right' {\u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (h : a = \u22a4 \u2192 \u2a05 i, f i = 0 \u2192 \u2203 i, f i = 0)\n    (h0 : a = 0 \u2192 Nonempty \u03b9) : \u2a05 i, f i * a = (\u2a05 i, f i) * a", "start": [502, 1], "end": [504, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul_right", "code": "theorem iInf_mul_right {\u03b9} [Nonempty \u03b9] {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e}\n    (h : a = \u22a4 \u2192 \u2a05 i, f i = 0 \u2192 \u2203 i, f i = 0) : \u2a05 i, f i * a = (\u2a05 i, f i) * a", "start": [507, 1], "end": [509, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_map_iInf", "code": "theorem inv_map_iInf {\u03b9 : Sort*} {x : \u03b9 \u2192 \u211d\u22650\u221e} : (iInf x)\u207b\u00b9 = \u2a06 i, (x i)\u207b\u00b9", "start": [512, 1], "end": [513, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_map_iSup", "code": "theorem inv_map_iSup {\u03b9 : Sort*} {x : \u03b9 \u2192 \u211d\u22650\u221e} : (iSup x)\u207b\u00b9 = \u2a05 i, (x i)\u207b\u00b9", "start": [516, 1], "end": [517, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_limsup", "code": "theorem inv_limsup {\u03b9 : Sort _} {x : \u03b9 \u2192 \u211d\u22650\u221e} {l : Filter \u03b9} :\n    (limsup x l)\u207b\u00b9 = liminf (fun i => (x i)\u207b\u00b9) l", "start": [520, 1], "end": [522, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_liminf", "code": "theorem inv_liminf {\u03b9 : Sort _} {x : \u03b9 \u2192 \u211d\u22650\u221e} {l : Filter \u03b9} :\n    (liminf x l)\u207b\u00b9 = limsup (fun i => (x i)\u207b\u00b9) l", "start": [525, 1], "end": [527, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_inv_iff", "code": "@[simp] protected theorem tendsto_inv_iff {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} :\n    Tendsto (fun x => (m x)\u207b\u00b9) f (\ud835\udcdd a\u207b\u00b9) \u2194 Tendsto m f (\ud835\udcdd a)", "start": [532, 1], "end": [535, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.div", "code": "protected theorem Tendsto.div {f : Filter \u03b1} {ma : \u03b1 \u2192 \u211d\u22650\u221e} {mb : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hma : Tendsto ma f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 0) (hmb : Tendsto mb f (\ud835\udcdd b))\n    (hb : b \u2260 \u22a4 \u2228 a \u2260 \u22a4) : Tendsto (fun a => ma a / mb a) f (\ud835\udcdd (a / b))", "start": [538, 1], "end": [541, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.const_div", "code": "protected theorem Tendsto.const_div {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hm : Tendsto m f (\ud835\udcdd b)) (hb : b \u2260 \u22a4 \u2228 a \u2260 \u22a4) : Tendsto (fun b => a / m b) f (\ud835\udcdd (a / b))", "start": [544, 1], "end": [547, 12], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Tendsto.div_const", "code": "protected theorem Tendsto.div_const {f : Filter \u03b1} {m : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n    (hm : Tendsto m f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 0) : Tendsto (fun x => m x / b) f (\ud835\udcdd (a / b))", "start": [550, 1], "end": [553, 12], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_inv_nat_nhds_zero", "code": "protected theorem tendsto_inv_nat_nhds_zero : Tendsto (fun n : \u2115 => (n : \u211d\u22650\u221e)\u207b\u00b9) atTop (\ud835\udcdd 0)", "start": [556, 1], "end": [557, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_add", "code": "theorem iSup_add {\u03b9 : Sort*} {s : \u03b9 \u2192 \u211d\u22650\u221e} [Nonempty \u03b9] : iSup s + a = \u2a06 b, s b + a", "start": [560, 1], "end": [562, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.biSup_add'", "code": "theorem biSup_add' {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} (h : \u2203 i, p i) {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (\u2a06 (i) (_ : p i), f i) + a = \u2a06 (i) (_ : p i), f i + a", "start": [565, 1], "end": [568, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_biSup'", "code": "theorem add_biSup' {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} (h : \u2203 i, p i) {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (a + \u2a06 (i) (_ : p i), f i) = \u2a06 (i) (_ : p i), a + f i", "start": [571, 1], "end": [573, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.biSup_add", "code": "theorem biSup_add {\u03b9} {s : Set \u03b9} (hs : s.Nonempty) {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (\u2a06 i \u2208 s, f i) + a = \u2a06 i \u2208 s, f i + a", "start": [576, 1], "end": [578, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_biSup", "code": "theorem add_biSup {\u03b9} {s : Set \u03b9} (hs : s.Nonempty) {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (a + \u2a06 i \u2208 s, f i) = \u2a06 i \u2208 s, a + f i", "start": [581, 1], "end": [583, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sSup_add", "code": "theorem sSup_add {s : Set \u211d\u22650\u221e} (hs : s.Nonempty) : sSup s + a = \u2a06 b \u2208 s, b + a", "start": [586, 1], "end": [587, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_iSup", "code": "theorem add_iSup {\u03b9 : Sort*} {s : \u03b9 \u2192 \u211d\u22650\u221e} [Nonempty \u03b9] : a + iSup s = \u2a06 b, a + s b", "start": [590, 1], "end": [591, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_add_iSup_le", "code": "theorem iSup_add_iSup_le {\u03b9 \u03b9' : Sort*} [Nonempty \u03b9] [Nonempty \u03b9'] {f : \u03b9 \u2192 \u211d\u22650\u221e} {g : \u03b9' \u2192 \u211d\u22650\u221e}\n    {a : \u211d\u22650\u221e} (h : \u2200 i j, f i + g j \u2264 a) : iSup f + iSup g \u2264 a", "start": [594, 1], "end": [596, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.biSup_add_biSup_le'", "code": "theorem biSup_add_biSup_le' {\u03b9 \u03b9'} {p : \u03b9 \u2192 Prop} {q : \u03b9' \u2192 Prop} (hp : \u2203 i, p i) (hq : \u2203 j, q j)\n    {f : \u03b9 \u2192 \u211d\u22650\u221e} {g : \u03b9' \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (h : \u2200 i, p i \u2192 \u2200 j, q j \u2192 f i + g j \u2264 a) :\n    ((\u2a06 (i) (_ : p i), f i) + \u2a06 (j) (_ : q j), g j) \u2264 a", "start": [599, 1], "end": [603, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.biSup_add_biSup_le", "code": "theorem biSup_add_biSup_le {\u03b9 \u03b9'} {s : Set \u03b9} {t : Set \u03b9'} (hs : s.Nonempty) (ht : t.Nonempty)\n    {f : \u03b9 \u2192 \u211d\u22650\u221e} {g : \u03b9' \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} (h : \u2200 i \u2208 s, \u2200 j \u2208 t, f i + g j \u2264 a) :\n    ((\u2a06 i \u2208 s, f i) + \u2a06 j \u2208 t, g j) \u2264 a", "start": [606, 1], "end": [609, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_add_iSup", "code": "theorem iSup_add_iSup {\u03b9 : Sort*} {f g : \u03b9 \u2192 \u211d\u22650\u221e} (h : \u2200 i j, \u2203 k, f i + g j \u2264 f k + g k) :\n    iSup f + iSup g = \u2a06 a, f a + g a", "start": [612, 1], "end": [619, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_add_iSup_of_monotone", "code": "theorem iSup_add_iSup_of_monotone {\u03b9 : Type*} [SemilatticeSup \u03b9] {f g : \u03b9 \u2192 \u211d\u22650\u221e} (hf : Monotone f)\n    (hg : Monotone g) : iSup f + iSup g = \u2a06 a, f a + g a", "start": [622, 1], "end": [624, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.finset_sum_iSup_nat", "code": "theorem finset_sum_iSup_nat {\u03b1} {\u03b9} [SemilatticeSup \u03b9] {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192 \u211d\u22650\u221e}\n    (hf : \u2200 a, Monotone (f a)) : (\u2211 a in s, iSup (f a)) = \u2a06 n, \u2211 a in s, f a n", "start": [627, 1], "end": [635, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_iSup", "code": "theorem mul_iSup {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} : a * iSup f = \u2a06 i, a * f i", "start": [638, 1], "end": [645, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_sSup", "code": "theorem mul_sSup {s : Set \u211d\u22650\u221e} {a : \u211d\u22650\u221e} : a * sSup s = \u2a06 i \u2208 s, a * i", "start": [648, 1], "end": [649, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_mul", "code": "theorem iSup_mul {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} : iSup f * a = \u2a06 i, f i * a", "start": [652, 1], "end": [653, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smul_iSup", "code": "theorem smul_iSup {\u03b9 : Sort*} {R} [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] (f : \u03b9 \u2192 \u211d\u22650\u221e)\n    (c : R) : (c \u2022 \u2a06 i, f i) = \u2a06 i, c \u2022 f i", "start": [656, 1], "end": [659, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smul_sSup", "code": "theorem smul_sSup {R} [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] (s : Set \u211d\u22650\u221e) (c : R) :\n    c \u2022 sSup s = \u2a06 i \u2208 s, c \u2022 i", "start": [662, 1], "end": [665, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_div", "code": "theorem iSup_div {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650\u221e} {a : \u211d\u22650\u221e} : iSup f / a = \u2a06 i, f i / a", "start": [668, 1], "end": [669, 11], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_coe_sub", "code": "protected theorem tendsto_coe_sub {b : \u211d\u22650\u221e} :\n    Tendsto (fun b : \u211d\u22650\u221e => \u2191r - b) (\ud835\udcdd b) (\ud835\udcdd (\u2191r - b))", "start": [672, 1], "end": [674, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_iSup", "code": "theorem sub_iSup {\u03b9 : Sort*} [Nonempty \u03b9] {b : \u03b9 \u2192 \u211d\u22650\u221e} (hr : a < \u22a4) :\n    (a - \u2a06 i, b i) = \u2a05 i, a - b i", "start": [677, 1], "end": [679, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_countable_dense_no_zero_top", "code": "theorem exists_countable_dense_no_zero_top :\n    \u2203 s : Set \u211d\u22650\u221e, s.Countable \u2227 Dense s \u2227 0 \u2209 s \u2227 \u221e \u2209 s", "start": [682, 1], "end": [687, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_lt_add_of_lt_add", "code": "theorem exists_lt_add_of_lt_add {x y z : \u211d\u22650\u221e} (h : x < y + z) (hy : y \u2260 0) (hz : z \u2260 0) :\n    \u2203 y' z', y' < y \u2227 z' < z \u2227 x < y' + z'", "start": [690, 1], "end": [701, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_frequently_lt_of_liminf_ne_top", "code": "theorem exists_frequently_lt_of_liminf_ne_top {\u03b9 : Type*} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, x n < R", "start": [708, 1], "end": [714, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_frequently_lt_of_liminf_ne_top'", "code": "theorem exists_frequently_lt_of_liminf_ne_top' {\u03b9 : Type*} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, R < x n", "start": [717, 1], "end": [723, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_upcrossings_of_not_bounded_under", "code": "theorem exists_upcrossings_of_not_bounded_under {\u03b9 : Type*} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n    (hf : liminf (fun i => (Real.nnabs (x i) : \u211d\u22650\u221e)) l \u2260 \u221e)\n    (hbdd : \u00acIsBoundedUnder (\u00b7 \u2264 \u00b7) l fun i => |x i|) :\n    \u2203 a b : \u211a, a < b \u2227 (\u2203\u1da0 i in l, x i < a) \u2227 \u2203\u1da0 i in l, \u2191b < x i", "start": [726, 1], "end": [749, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasSum_coe", "code": "@[norm_cast]\nprotected theorem hasSum_coe {f : \u03b1 \u2192 \u211d\u22650} {r : \u211d\u22650} :\n    HasSum (fun a => (f a : \u211d\u22650\u221e)) \u2191r \u2194 HasSum f r", "start": [758, 1], "end": [761, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_coe_eq", "code": "protected theorem tsum_coe_eq {f : \u03b1 \u2192 \u211d\u22650} (h : HasSum f r) : (\u2211' a, (f a : \u211d\u22650\u221e)) = r", "start": [764, 1], "end": [765, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_tsum", "code": "protected theorem coe_tsum {f : \u03b1 \u2192 \u211d\u22650} : Summable f \u2192 \u2191(tsum f) = \u2211' a, (f a : \u211d\u22650\u221e)", "start": [768, 1], "end": [769, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasSum", "code": "protected theorem hasSum : HasSum f (\u2a06 s : Finset \u03b1, \u2211 a in s, f a)", "start": [772, 1], "end": [773, 60], "kind": "commanddeclaration"}, {"full_name": "ENNReal.summable", "code": "@[simp]\nprotected theorem summable : Summable f", "start": [776, 1], "end": [778, 22], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_coe_ne_top_iff_summable", "code": "theorem tsum_coe_ne_top_iff_summable {f : \u03b2 \u2192 \u211d\u22650} : (\u2211' b, (f b : \u211d\u22650\u221e)) \u2260 \u221e \u2194 Summable f", "start": [781, 1], "end": [786, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_iSup_sum", "code": "protected theorem tsum_eq_iSup_sum : \u2211' a, f a = \u2a06 s : Finset \u03b1, \u2211 a in s, f a", "start": [789, 1], "end": [790, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_iSup_sum'", "code": "protected theorem tsum_eq_iSup_sum' {\u03b9 : Type*} (s : \u03b9 \u2192 Finset \u03b1) (hs : \u2200 t, \u2203 i, t \u2286 s i) :\n    \u2211' a, f a = \u2a06 i, \u2211 a in s i, f a", "start": [793, 1], "end": [798, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_sigma", "code": "protected theorem tsum_sigma {\u03b2 : \u03b1 \u2192 Type*} (f : \u2200 a, \u03b2 a \u2192 \u211d\u22650\u221e) :\n    \u2211' p : \u03a3a, \u03b2 a, f p.1 p.2 = \u2211' (a) (b), f a b", "start": [801, 1], "end": [803, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_sigma'", "code": "protected theorem tsum_sigma' {\u03b2 : \u03b1 \u2192 Type*} (f : (\u03a3a, \u03b2 a) \u2192 \u211d\u22650\u221e) :\n    \u2211' p : \u03a3a, \u03b2 a, f p = \u2211' (a) (b), f \u27e8a, b\u27e9", "start": [806, 1], "end": [808, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_prod", "code": "protected theorem tsum_prod {f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e} : \u2211' p : \u03b1 \u00d7 \u03b2, f p.1 p.2 = \u2211' (a) (b), f a b", "start": [811, 1], "end": [812, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_prod'", "code": "protected theorem tsum_prod' {f : \u03b1 \u00d7 \u03b2 \u2192 \u211d\u22650\u221e} : \u2211' p : \u03b1 \u00d7 \u03b2, f p = \u2211' (a) (b), f (a, b)", "start": [815, 1], "end": [816, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_comm", "code": "protected theorem tsum_comm {f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e} : \u2211' a, \u2211' b, f a b = \u2211' b, \u2211' a, f a b", "start": [819, 1], "end": [820, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_add", "code": "protected theorem tsum_add : \u2211' a, (f a + g a) = \u2211' a, f a + \u2211' a, g a", "start": [823, 1], "end": [824, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_le_tsum", "code": "protected theorem tsum_le_tsum (h : \u2200 a, f a \u2264 g a) : \u2211' a, f a \u2264 \u2211' a, g a", "start": [827, 1], "end": [828, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sum_le_tsum", "code": "protected theorem sum_le_tsum {f : \u03b1 \u2192 \u211d\u22650\u221e} (s : Finset \u03b1) : \u2211 x in s, f x \u2264 \u2211' x, f x", "start": [831, 1], "end": [832, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_iSup_nat'", "code": "protected theorem tsum_eq_iSup_nat' {f : \u2115 \u2192 \u211d\u22650\u221e} {N : \u2115 \u2192 \u2115} (hN : Tendsto N atTop atTop) :\n    \u2211' i : \u2115, f i = \u2a06 i : \u2115, \u2211 a in Finset.range (N i), f a", "start": [835, 1], "end": [840, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_iSup_nat", "code": "protected theorem tsum_eq_iSup_nat {f : \u2115 \u2192 \u211d\u22650\u221e} :\n    \u2211' i : \u2115, f i = \u2a06 i : \u2115, \u2211 a in Finset.range i, f a", "start": [843, 1], "end": [845, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_liminf_sum_nat", "code": "protected theorem tsum_eq_liminf_sum_nat {f : \u2115 \u2192 \u211d\u22650\u221e} :\n    \u2211' i, f i = liminf (fun n => \u2211 i in Finset.range n, f i) atTop", "start": [848, 1], "end": [850, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_limsup_sum_nat", "code": "protected theorem tsum_eq_limsup_sum_nat {f : \u2115 \u2192 \u211d\u22650\u221e} :\n    \u2211' i, f i = limsup (fun n => \u2211 i in Finset.range n, f i) atTop", "start": [853, 1], "end": [855, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_tsum", "code": "protected theorem le_tsum (a : \u03b1) : f a \u2264 \u2211' a, f a", "start": [857, 1], "end": [858, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_zero", "code": "@[simp]\nprotected theorem tsum_eq_zero : \u2211' i, f i = 0 \u2194 \u2200 i, f i = 0", "start": [861, 1], "end": [863, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_top_of_eq_top", "code": "protected theorem tsum_eq_top_of_eq_top : (\u2203 a, f a = \u221e) \u2192 \u2211' a, f a = \u221e", "start": [866, 1], "end": [867, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_top_of_tsum_ne_top", "code": "protected theorem lt_top_of_tsum_ne_top {a : \u03b1 \u2192 \u211d\u22650\u221e} (tsum_ne_top : \u2211' i, a i \u2260 \u221e) (j : \u03b1) :\n    a j < \u221e", "start": [870, 1], "end": [873, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_top", "code": "@[simp]\nprotected theorem tsum_top [Nonempty \u03b1] : \u2211' _ : \u03b1, \u221e = \u221e", "start": [876, 1], "end": [879, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_const_eq_top_of_ne_zero", "code": "theorem tsum_const_eq_top_of_ne_zero {\u03b1 : Type*} [Infinite \u03b1] {c : \u211d\u22650\u221e} (hc : c \u2260 0) :\n    \u2211' _ : \u03b1, c = \u221e", "start": [882, 1], "end": [890, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ne_top_of_tsum_ne_top", "code": "protected theorem ne_top_of_tsum_ne_top (h : \u2211' a, f a \u2260 \u221e) (a : \u03b1) : f a \u2260 \u221e", "start": [893, 1], "end": [894, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_mul_left", "code": "protected theorem tsum_mul_left : \u2211' i, a * f i = a * \u2211' i, f i", "start": [897, 1], "end": [904, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_mul_right", "code": "protected theorem tsum_mul_right : \u2211' i, f i * a = (\u2211' i, f i) * a", "start": [907, 1], "end": [908, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_const_smul", "code": "protected theorem tsum_const_smul {R} [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] (a : R) :\n    \u2211' i, a \u2022 f i = a \u2022 \u2211' i, f i", "start": [911, 1], "end": [913, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_iSup_eq", "code": "@[simp]\ntheorem tsum_iSup_eq {\u03b1 : Type*} (a : \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e} : (\u2211' b : \u03b1, \u2a06 _ : a = b, f b) = f a", "start": [916, 1], "end": [918, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasSum_iff_tendsto_nat", "code": "theorem hasSum_iff_tendsto_nat {f : \u2115 \u2192 \u211d\u22650\u221e} (r : \u211d\u22650\u221e) :\n    HasSum f r \u2194 Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop (\ud835\udcdd r)", "start": [921, 1], "end": [926, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_nat_tsum", "code": "theorem tendsto_nat_tsum (f : \u2115 \u2192 \u211d\u22650\u221e) :\n    Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop (\ud835\udcdd (\u2211' n, f n))", "start": [929, 1], "end": [932, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_apply_of_tsum_ne_top", "code": "theorem toNNReal_apply_of_tsum_ne_top {\u03b1 : Type*} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2211' i, f i \u2260 \u221e) (x : \u03b1) :\n    (((ENNReal.toNNReal \u2218 f) x : \u211d\u22650) : \u211d\u22650\u221e) = f x", "start": [935, 1], "end": [937, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.summable_toNNReal_of_tsum_ne_top", "code": "theorem summable_toNNReal_of_tsum_ne_top {\u03b1 : Type*} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2211' i, f i \u2260 \u221e) :\n    Summable (ENNReal.toNNReal \u2218 f)", "start": [940, 1], "end": [942, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_cofinite_zero_of_tsum_ne_top", "code": "theorem tendsto_cofinite_zero_of_tsum_ne_top {\u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2211' x, f x \u2260 \u221e) :\n    Tendsto f cofinite (\ud835\udcdd 0)", "start": [945, 1], "end": [951, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_atTop_zero_of_tsum_ne_top", "code": "theorem tendsto_atTop_zero_of_tsum_ne_top {f : \u2115 \u2192 \u211d\u22650\u221e} (hf : \u2211' x, f x \u2260 \u221e) :\n    Tendsto f atTop (\ud835\udcdd 0)", "start": [954, 1], "end": [957, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_tsum_compl_atTop_zero", "code": "theorem tendsto_tsum_compl_atTop_zero {\u03b1 : Type*} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2211' x, f x \u2260 \u221e) :\n    Tendsto (fun s : Finset \u03b1 => \u2211' b : { x // x \u2209 s }, f b) atTop (\ud835\udcdd 0)", "start": [960, 1], "end": [967, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_apply", "code": "protected theorem tsum_apply {\u03b9 \u03b1 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {x : \u03b1} :\n    (\u2211' i, f i) x = \u2211' i, f i x", "start": [970, 1], "end": [972, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_sub", "code": "theorem tsum_sub {f : \u2115 \u2192 \u211d\u22650\u221e} {g : \u2115 \u2192 \u211d\u22650\u221e} (h\u2081 : \u2211' i, g i \u2260 \u221e) (h\u2082 : g \u2264 f) :\n    \u2211' i, (f i - g i) = \u2211' i, f i - \u2211' i, g i", "start": [975, 1], "end": [978, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_comp_le_tsum_of_injective", "code": "theorem tsum_comp_le_tsum_of_injective {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (g : \u03b2 \u2192 \u211d\u22650\u221e) :\n    \u2211' x, g (f x) \u2264 \u2211' y, g y", "start": [981, 1], "end": [984, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_le_tsum_comp_of_surjective", "code": "theorem tsum_le_tsum_comp_of_surjective {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) (g : \u03b2 \u2192 \u211d\u22650\u221e) :\n    \u2211' y, g y \u2264 \u2211' x, g (f x)", "start": [986, 1], "end": [989, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_mono_subtype", "code": "theorem tsum_mono_subtype (f : \u03b1 \u2192 \u211d\u22650\u221e) {s t : Set \u03b1} (h : s \u2286 t) :\n    \u2211' x : s, f x \u2264 \u2211' x : t, f x", "start": [991, 1], "end": [993, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_iUnion_le_tsum", "code": "theorem tsum_iUnion_le_tsum {\u03b9 : Type*} (f : \u03b1 \u2192 \u211d\u22650\u221e) (t : \u03b9 \u2192 Set \u03b1) :\n    \u2211' x : \u22c3 i, t i, f x \u2264 \u2211' i, \u2211' x : t i, f x", "start": [996, 1], "end": [1000, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_biUnion_le_tsum", "code": "theorem tsum_biUnion_le_tsum {\u03b9 : Type*} (f : \u03b1 \u2192 \u211d\u22650\u221e) (s : Set \u03b9) (t : \u03b9 \u2192 Set \u03b1) :\n    \u2211' x : \u22c3 i \u2208 s , t i, f x \u2264 \u2211' i : s, \u2211' x : t i, f x", "start": [1002, 1], "end": [1005, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_biUnion_le", "code": "theorem tsum_biUnion_le {\u03b9 : Type*} (f : \u03b1 \u2192 \u211d\u22650\u221e) (s : Finset \u03b9) (t : \u03b9 \u2192 Set \u03b1) :\n    \u2211' x : \u22c3 i \u2208 s, t i, f x \u2264 \u2211 i in s, \u2211' x : t i, f x", "start": [1007, 1], "end": [1009, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_iUnion_le", "code": "theorem tsum_iUnion_le {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b1 \u2192 \u211d\u22650\u221e) (t : \u03b9 \u2192 Set \u03b1) :\n    \u2211' x : \u22c3 i, t i, f x \u2264 \u2211 i, \u2211' x : t i, f x", "start": [1012, 1], "end": [1015, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_union_le", "code": "theorem tsum_union_le (f : \u03b1 \u2192 \u211d\u22650\u221e) (s t : Set \u03b1) :\n    \u2211' x : \u2191(s \u222a t), f x \u2264 \u2211' x : s, f x + \u2211' x : t, f x", "start": [1018, 1], "end": [1021, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_eq_add_tsum_ite", "code": "theorem tsum_eq_add_tsum_ite {f : \u03b2 \u2192 \u211d\u22650\u221e} (b : \u03b2) :\n    \u2211' x, f x = f b + \u2211' x, ite (x = b) 0 (f x)", "start": [1024, 1], "end": [1026, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_add_one_eq_top", "code": "theorem tsum_add_one_eq_top {f : \u2115 \u2192 \u211d\u22650\u221e} (hf : \u2211' n, f n = \u221e) (hf0 : f 0 \u2260 \u221e) :\n    \u2211' n, f (n + 1) = \u221e", "start": [1029, 1], "end": [1032, 28], "kind": "commanddeclaration"}, {"full_name": "ENNReal.finite_const_le_of_tsum_ne_top", "code": "theorem finite_const_le_of_tsum_ne_top {\u03b9 : Type*} {a : \u03b9 \u2192 \u211d\u22650\u221e} (tsum_ne_top : \u2211' i, a i \u2260 \u221e)\n    {\u03b5 : \u211d\u22650\u221e} (\u03b5_ne_zero : \u03b5 \u2260 0) : { i : \u03b9 | \u03b5 \u2264 a i }.Finite", "start": [1035, 1], "end": [1044, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.finset_card_const_le_le_of_tsum_le", "code": "theorem finset_card_const_le_le_of_tsum_le {\u03b9 : Type*} {a : \u03b9 \u2192 \u211d\u22650\u221e} {c : \u211d\u22650\u221e} (c_ne_top : c \u2260 \u221e)\n    (tsum_le_c : \u2211' i, a i \u2264 c) {\u03b5 : \u211d\u22650\u221e} (\u03b5_ne_zero : \u03b5 \u2260 0) :\n    \u2203 hf : { i : \u03b9 | \u03b5 \u2264 a i }.Finite, \u2191hf.toFinset.card \u2264 c / \u03b5", "start": [1047, 1], "end": [1057, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_toReal_iff", "code": "theorem tendsto_toReal_iff {\u03b9} {fi : Filter \u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} (hf : \u2200 i, f i \u2260 \u221e) {x : \u211d\u22650\u221e}\n    (hx : x \u2260 \u221e) : Tendsto (fun n => (f n).toReal) fi (\ud835\udcdd x.toReal) \u2194 Tendsto f fi (\ud835\udcdd x)", "start": [1062, 1], "end": [1066, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_coe_ne_top_iff_summable_coe", "code": "theorem tsum_coe_ne_top_iff_summable_coe {f : \u03b1 \u2192 \u211d\u22650} :\n    (\u2211' a, (f a : \u211d\u22650\u221e)) \u2260 \u221e \u2194 Summable fun a => (f a : \u211d)", "start": [1069, 1], "end": [1072, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_coe_eq_top_iff_not_summable_coe", "code": "theorem tsum_coe_eq_top_iff_not_summable_coe {f : \u03b1 \u2192 \u211d\u22650} :\n    (\u2211' a, (f a : \u211d\u22650\u221e)) = \u221e \u2194 \u00acSummable fun a => (f a : \u211d)", "start": [1075, 1], "end": [1077, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasSum_toReal", "code": "theorem hasSum_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hsum : \u2211' x, f x \u2260 \u221e) :\n    HasSum (fun x => (f x).toReal) (\u2211' x, (f x).toReal)", "start": [1080, 1], "end": [1084, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.summable_toReal", "code": "theorem summable_toReal {f : \u03b1 \u2192 \u211d\u22650\u221e} (hsum : \u2211' x, f x \u2260 \u221e) : Summable fun x => (f x).toReal", "start": [1087, 1], "end": [1088, 32], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_eq_toNNReal_tsum", "code": "theorem tsum_eq_toNNReal_tsum {f : \u03b2 \u2192 \u211d\u22650} : \u2211' b, f b = (\u2211' b, (f b : \u211d\u22650\u221e)).toNNReal", "start": [1095, 1], "end": [1100, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists_le_hasSum_of_le", "code": "theorem exists_le_hasSum_of_le {f g : \u03b2 \u2192 \u211d\u22650} {r : \u211d\u22650} (hgf : \u2200 b, g b \u2264 f b) (hfr : HasSum f r) :\n    \u2203 p \u2264 r, HasSum g p", "start": [1103, 1], "end": [1110, 65], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_of_le", "code": "theorem summable_of_le {f g : \u03b2 \u2192 \u211d\u22650} (hgf : \u2200 b, g b \u2264 f b) : Summable f \u2192 Summable g", "start": [1113, 1], "end": [1117, 16], "kind": "commanddeclaration"}, {"full_name": "Summable.countable_support_nnreal", "code": "theorem _root_.Summable.countable_support_nnreal (f : \u03b1 \u2192 \u211d\u22650) (h : Summable f) :\n    f.support.Countable", "start": [1120, 1], "end": [1124, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_iff_tendsto_nat", "code": "theorem hasSum_iff_tendsto_nat {f : \u2115 \u2192 \u211d\u22650} {r : \u211d\u22650} :\n    HasSum f r \u2194 Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop (\ud835\udcdd r)", "start": [1126, 1], "end": [1132, 28], "kind": "commanddeclaration"}, {"full_name": "NNReal.not_summable_iff_tendsto_nat_atTop", "code": "theorem not_summable_iff_tendsto_nat_atTop {f : \u2115 \u2192 \u211d\u22650} :\n    \u00acSummable f \u2194 Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop atTop", "start": [1135, 1], "end": [1142, 81], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_iff_not_tendsto_nat_atTop", "code": "theorem summable_iff_not_tendsto_nat_atTop {f : \u2115 \u2192 \u211d\u22650} :\n    Summable f \u2194 \u00acTendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop atTop", "start": [1145, 1], "end": [1147, 76], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_of_sum_range_le", "code": "theorem summable_of_sum_range_le {f : \u2115 \u2192 \u211d\u22650} {c : \u211d\u22650}\n    (h : \u2200 n, \u2211 i in Finset.range n, f i \u2264 c) : Summable f", "start": [1150, 1], "end": [1154, 40], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_le_of_sum_range_le", "code": "theorem tsum_le_of_sum_range_le {f : \u2115 \u2192 \u211d\u22650} {c : \u211d\u22650}\n    (h : \u2200 n, \u2211 i in Finset.range n, f i \u2264 c) : \u2211' n, f n \u2264 c", "start": [1157, 1], "end": [1159, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_comp_le_tsum_of_inj", "code": "theorem tsum_comp_le_tsum_of_inj {\u03b2 : Type*} {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) {i : \u03b2 \u2192 \u03b1}\n    (hi : Function.Injective i) : (\u2211' x, f (i x)) \u2264 \u2211' x, f x", "start": [1162, 1], "end": [1165, 7], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_sigma", "code": "theorem summable_sigma {\u03b2 : \u03b1 \u2192 Type*} {f : (\u03a3 x, \u03b2 x) \u2192 \u211d\u22650} :\n    Summable f \u2194 (\u2200 x, Summable fun y => f \u27e8x, y\u27e9) \u2227 Summable fun x => \u2211' y, f \u27e8x, y\u27e9", "start": [1168, 1], "end": [1175, 40], "kind": "commanddeclaration"}, {"full_name": "NNReal.indicator_summable", "code": "theorem indicator_summable {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) (s : Set \u03b1) :\n    Summable (s.indicator f)", "start": [1178, 1], "end": [1183, 20], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_indicator_ne_zero", "code": "theorem tsum_indicator_ne_zero {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) {s : Set \u03b1} (h : \u2203 a \u2208 s, f a \u2260 0) :\n    (\u2211' x, (s.indicator f) x) \u2260 0", "start": [1186, 1], "end": [1190, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_sum_nat_add", "code": "theorem tendsto_sum_nat_add (f : \u2115 \u2192 \u211d\u22650) : Tendsto (fun i => \u2211' k, f (k + i)) atTop (\ud835\udcdd 0)", "start": [1195, 1], "end": [1200, 12], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_lt", "code": "nonrec theorem hasSum_lt {f g : \u03b1 \u2192 \u211d\u22650} {sf sg : \u211d\u22650} {i : \u03b1} (h : \u2200 a : \u03b1, f a \u2264 g a)\n    (hi : f i < g i) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg", "start": [1203, 1], "end": [1207, 33], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_strict_mono", "code": "@[mono]\ntheorem hasSum_strict_mono {f g : \u03b1 \u2192 \u211d\u22650} {sf sg : \u211d\u22650} (hf : HasSum f sf) (hg : HasSum g sg)\n    (h : f < g) : sf < sg", "start": [1210, 1], "end": [1214, 25], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_lt_tsum", "code": "theorem tsum_lt_tsum {f g : \u03b1 \u2192 \u211d\u22650} {i : \u03b1} (h : \u2200 a : \u03b1, f a \u2264 g a) (hi : f i < g i)\n    (hg : Summable g) : \u2211' n, f n < \u2211' n, g n", "start": [1217, 1], "end": [1219, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_strict_mono", "code": "@[mono]\ntheorem tsum_strict_mono {f g : \u03b1 \u2192 \u211d\u22650} (hg : Summable g) (h : f < g) : \u2211' n, f n < \u2211' n, g n", "start": [1222, 1], "end": [1225, 25], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_pos", "code": "theorem tsum_pos {g : \u03b1 \u2192 \u211d\u22650} (hg : Summable g) (i : \u03b1) (hi : 0 < g i) : 0 < \u2211' b, g b", "start": [1228, 1], "end": [1230, 48], "kind": "commanddeclaration"}, {"full_name": "NNReal.tsum_eq_add_tsum_ite", "code": "theorem tsum_eq_add_tsum_ite {f : \u03b1 \u2192 \u211d\u22650} (hf : Summable f) (i : \u03b1) :\n    \u2211' x, f x = f i + \u2211' x, ite (x = i) 0 (f x)", "start": [1233, 1], "end": [1237, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_toNNReal_eq", "code": "theorem tsum_toNNReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 a, f a \u2260 \u221e) :\n    (\u2211' a, f a).toNNReal = \u2211' a, (f a).toNNReal", "start": [1244, 1], "end": [1247, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_toReal_eq", "code": "theorem tsum_toReal_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 a, f a \u2260 \u221e) :\n    (\u2211' a, f a).toReal = \u2211' a, (f a).toReal", "start": [1250, 1], "end": [1252, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_sum_nat_add", "code": "theorem tendsto_sum_nat_add (f : \u2115 \u2192 \u211d\u22650\u221e) (hf : \u2211' i, f i \u2260 \u221e) :\n    Tendsto (fun i => \u2211' k, f (k + i)) atTop (\ud835\udcdd 0)", "start": [1255, 1], "end": [1260, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_le_of_sum_range_le", "code": "theorem tsum_le_of_sum_range_le {f : \u2115 \u2192 \u211d\u22650\u221e} {c : \u211d\u22650\u221e}\n    (h : \u2200 n, \u2211 i in Finset.range n, f i \u2264 c) : \u2211' n, f n \u2264 c", "start": [1263, 1], "end": [1265, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.hasSum_lt", "code": "theorem hasSum_lt {f g : \u03b1 \u2192 \u211d\u22650\u221e} {sf sg : \u211d\u22650\u221e} {i : \u03b1} (h : \u2200 a : \u03b1, f a \u2264 g a) (hi : f i < g i)\n    (hsf : sf \u2260 \u22a4) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg", "start": [1268, 1], "end": [1279, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_lt_tsum", "code": "theorem tsum_lt_tsum {f g : \u03b1 \u2192 \u211d\u22650\u221e} {i : \u03b1} (hfi : tsum f \u2260 \u22a4) (h : \u2200 a : \u03b1, f a \u2264 g a)\n    (hi : f i < g i) : \u2211' x, f x < \u2211' x, g x", "start": [1282, 1], "end": [1284, 69], "kind": "commanddeclaration"}, {"full_name": "tsum_comp_le_tsum_of_inj", "code": "theorem tsum_comp_le_tsum_of_inj {\u03b2 : Type*} {f : \u03b1 \u2192 \u211d} (hf : Summable f) (hn : \u2200 a, 0 \u2264 f a)\n    {i : \u03b2 \u2192 \u03b1} (hi : Function.Injective i) : tsum (f \u2218 i) \u2264 tsum f", "start": [1289, 1], "end": [1293, 86], "kind": "commanddeclaration"}, {"full_name": "summable_of_nonneg_of_le", "code": "theorem summable_of_nonneg_of_le {f g : \u03b2 \u2192 \u211d} (hg : \u2200 b, 0 \u2264 g b) (hgf : \u2200 b, g b \u2264 f b)\n    (hf : Summable f) : Summable g", "start": [1296, 1], "end": [1302, 72], "kind": "commanddeclaration"}, {"full_name": "Summable.toNNReal", "code": "theorem Summable.toNNReal {f : \u03b1 \u2192 \u211d} (hf : Summable f) : Summable fun n => (f n).toNNReal", "start": [1305, 1], "end": [1308, 84], "kind": "commanddeclaration"}, {"full_name": "Summable.countable_support_ennreal", "code": "theorem _root_.Summable.countable_support_ennreal {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2211' (i : \u03b1), f i \u2260 \u22a4) :\n    f.support.Countable", "start": [1311, 1], "end": [1315, 92], "kind": "commanddeclaration"}, {"full_name": "hasSum_iff_tendsto_nat_of_nonneg", "code": "theorem hasSum_iff_tendsto_nat_of_nonneg {f : \u2115 \u2192 \u211d} (hf : \u2200 i, 0 \u2264 f i) (r : \u211d) :\n    HasSum f r \u2194 Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop (\ud835\udcdd r)", "start": [1317, 1], "end": [1323, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_tsum_of_nonneg", "code": "theorem ENNReal.ofReal_tsum_of_nonneg {f : \u03b1 \u2192 \u211d} (hf_nonneg : \u2200 n, 0 \u2264 f n) (hf : Summable f) :\n    ENNReal.ofReal (\u2211' n, f n) = \u2211' n, ENNReal.ofReal (f n)", "start": [1326, 1], "end": [1328, 101], "kind": "commanddeclaration"}, {"full_name": "not_summable_iff_tendsto_nat_atTop_of_nonneg", "code": "theorem not_summable_iff_tendsto_nat_atTop_of_nonneg {f : \u2115 \u2192 \u211d} (hf : \u2200 n, 0 \u2264 f n) :\n    \u00acSummable f \u2194 Tendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop atTop", "start": [1331, 1], "end": [1334, 59], "kind": "commanddeclaration"}, {"full_name": "summable_iff_not_tendsto_nat_atTop_of_nonneg", "code": "theorem summable_iff_not_tendsto_nat_atTop_of_nonneg {f : \u2115 \u2192 \u211d} (hf : \u2200 n, 0 \u2264 f n) :\n    Summable f \u2194 \u00acTendsto (fun n : \u2115 => \u2211 i in Finset.range n, f i) atTop atTop", "start": [1337, 1], "end": [1339, 89], "kind": "commanddeclaration"}, {"full_name": "summable_sigma_of_nonneg", "code": "theorem summable_sigma_of_nonneg {\u03b2 : \u03b1 \u2192 Type*} {f : (\u03a3 x, \u03b2 x) \u2192 \u211d} (hf : \u2200 x, 0 \u2264 f x) :\n    Summable f \u2194 (\u2200 x, Summable fun y => f \u27e8x, y\u27e9) \u2227 Summable fun x => \u2211' y, f \u27e8x, y\u27e9", "start": [1342, 1], "end": [1345, 39], "kind": "commanddeclaration"}, {"full_name": "summable_prod_of_nonneg", "code": "theorem summable_prod_of_nonneg {f : (\u03b1 \u00d7 \u03b2) \u2192 \u211d} (hf : 0 \u2264 f) :\n    Summable f \u2194 (\u2200 x, Summable fun y \u21a6 f (x, y)) \u2227 Summable fun x \u21a6 \u2211' y, f (x, y)", "start": [1348, 1], "end": [1350, 94], "kind": "commanddeclaration"}, {"full_name": "summable_of_sum_le", "code": "theorem summable_of_sum_le {\u03b9 : Type*} {f : \u03b9 \u2192 \u211d} {c : \u211d} (hf : 0 \u2264 f)\n    (h : \u2200 u : Finset \u03b9, \u2211 x in u, f x \u2264 c) : Summable f", "start": [1352, 1], "end": [1355, 91], "kind": "commanddeclaration"}, {"full_name": "summable_of_sum_range_le", "code": "theorem summable_of_sum_range_le {f : \u2115 \u2192 \u211d} {c : \u211d} (hf : \u2200 n, 0 \u2264 f n)\n    (h : \u2200 n, \u2211 i in Finset.range n, f i \u2264 c) : Summable f", "start": [1358, 1], "end": [1362, 40], "kind": "commanddeclaration"}, {"full_name": "Real.tsum_le_of_sum_range_le", "code": "theorem Real.tsum_le_of_sum_range_le {f : \u2115 \u2192 \u211d} {c : \u211d} (hf : \u2200 n, 0 \u2264 f n)\n    (h : \u2200 n, \u2211 i in Finset.range n, f i \u2264 c) : \u2211' n, f n \u2264 c", "start": [1365, 1], "end": [1367, 67], "kind": "commanddeclaration"}, {"full_name": "tsum_lt_tsum_of_nonneg", "code": "theorem tsum_lt_tsum_of_nonneg {i : \u2115} {f g : \u2115 \u2192 \u211d} (h0 : \u2200 b : \u2115, 0 \u2264 f b)\n    (h : \u2200 b : \u2115, f b \u2264 g b) (hi : f i < g i) (hg : Summable g) : \u2211' n, f n < \u2211' n, g n", "start": [1370, 1], "end": [1375, 58], "kind": "commanddeclaration"}, {"full_name": "edist_ne_top_of_mem_ball", "code": "theorem edist_ne_top_of_mem_ball {a : \u03b2} {r : \u211d\u22650\u221e} (x y : ball a r) : edist x.1 y.1 \u2260 \u22a4", "start": [1384, 1], "end": [1390, 22], "kind": "commanddeclaration"}, {"full_name": "metricSpaceEMetricBall", "code": "def metricSpaceEMetricBall (a : \u03b2) (r : \u211d\u22650\u221e) : MetricSpace (ball a r) :=\n  EMetricSpace.toMetricSpace edist_ne_top_of_mem_ball", "start": [1393, 1], "end": [1396, 54], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_nhds_emetric_ball", "code": "theorem nhds_eq_nhds_emetric_ball (a x : \u03b2) (r : \u211d\u22650\u221e) (h : x \u2208 ball a r) :\n    \ud835\udcdd x = map ((\u2191) : ball a r \u2192 \u03b2) (\ud835\udcdd \u27e8x, h\u27e9)", "start": [1399, 1], "end": [1401, 81], "kind": "commanddeclaration"}, {"full_name": "tendsto_iff_edist_tendsto_0", "code": "theorem tendsto_iff_edist_tendsto_0 {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} {y : \u03b1} :\n    Tendsto f l (\ud835\udcdd y) \u2194 Tendsto (fun x => edist (f x) y) l (\ud835\udcdd 0)", "start": [1412, 1], "end": [1415, 101], "kind": "commanddeclaration"}, {"full_name": "EMetric.cauchySeq_iff_le_tendsto_0", "code": "theorem EMetric.cauchySeq_iff_le_tendsto_0 [Nonempty \u03b2] [SemilatticeSup \u03b2] {s : \u03b2 \u2192 \u03b1} :\n    CauchySeq s \u2194 \u2203 b : \u03b2 \u2192 \u211d\u22650\u221e, (\u2200 n m N : \u03b2, N \u2264 n \u2192 N \u2264 m \u2192 edist (s n) (s m) \u2264 b N) \u2227\n      Tendsto b atTop (\ud835\udcdd 0)", "start": [1418, 1], "end": [1440, 16], "kind": "commanddeclaration"}, {"full_name": "continuous_of_le_add_edist", "code": "theorem continuous_of_le_add_edist {f : \u03b1 \u2192 \u211d\u22650\u221e} (C : \u211d\u22650\u221e) (hC : C \u2260 \u22a4)\n    (h : \u2200 x y, f x \u2264 f y + C * edist x y) : Continuous f", "start": [1443, 1], "end": [1451, 69], "kind": "commanddeclaration"}, {"full_name": "continuous_edist", "code": "theorem continuous_edist : Continuous fun p : \u03b1 \u00d7 \u03b1 => edist p.1 p.2", "start": [1454, 1], "end": [1462, 79], "kind": "commanddeclaration"}, {"full_name": "Continuous.edist", "code": "@[continuity]\ntheorem Continuous.edist [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => edist (f b) (g b)", "start": [1465, 1], "end": [1468, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.edist", "code": "theorem Filter.Tendsto.edist {f g : \u03b2 \u2192 \u03b1} {x : Filter \u03b2} {a b : \u03b1} (hf : Tendsto f x (\ud835\udcdd a))\n    (hg : Tendsto g x (\ud835\udcdd b)) : Tendsto (fun x => edist (f x) (g x)) x (\ud835\udcdd (edist a b))", "start": [1471, 1], "end": [1473, 62], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_edist_le_of_tsum_ne_top", "code": "theorem cauchySeq_of_edist_le_of_tsum_ne_top {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) (hd : tsum d \u2260 \u221e) : CauchySeq f", "start": [1476, 1], "end": [1480, 50], "kind": "commanddeclaration"}, {"full_name": "EMetric.isClosed_ball", "code": "theorem EMetric.isClosed_ball {a : \u03b1} {r : \u211d\u22650\u221e} : IsClosed (closedBall a r)", "start": [1483, 1], "end": [1484, 70], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_closure", "code": "@[simp]\ntheorem EMetric.diam_closure (s : Set \u03b1) : diam (closure s) = diam s", "start": [1487, 1], "end": [1492, 28], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_closure", "code": "@[simp]\ntheorem Metric.diam_closure {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (s : Set \u03b1) :\n    Metric.diam (closure s) = diam s", "start": [1495, 1], "end": [1497, 89], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_lipschitzOnWith", "code": "theorem isClosed_setOf_lipschitzOnWith {\u03b1 \u03b2} [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650)\n    (s : Set \u03b1) : IsClosed { f : \u03b1 \u2192 \u03b2 | LipschitzOnWith K f s }", "start": [1500, 1], "end": [1504, 78], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_lipschitzWith", "code": "theorem isClosed_setOf_lipschitzWith {\u03b1 \u03b2} [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) :\n    IsClosed { f : \u03b1 \u2192 \u03b2 | LipschitzWith K f }", "start": [1507, 1], "end": [1509, 65], "kind": "commanddeclaration"}, {"full_name": "Real.ediam_eq", "code": "theorem ediam_eq {s : Set \u211d} (h : Bornology.IsBounded s) :\n    EMetric.diam s = ENNReal.ofReal (sSup s - sInf s)", "start": [1514, 1], "end": [1528, 37], "kind": "commanddeclaration"}, {"full_name": "Real.diam_eq", "code": "theorem diam_eq {s : Set \u211d} (h : Bornology.IsBounded s) : Metric.diam s = sSup s - sInf s", "start": [1531, 1], "end": [1535, 51], "kind": "commanddeclaration"}, {"full_name": "Real.ediam_Ioo", "code": "@[simp]\ntheorem ediam_Ioo (a b : \u211d) : EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)", "start": [1538, 1], "end": [1542, 69], "kind": "commanddeclaration"}, {"full_name": "Real.ediam_Icc", "code": "@[simp]\ntheorem ediam_Icc (a b : \u211d) : EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)", "start": [1545, 1], "end": [1549, 19], "kind": "commanddeclaration"}, {"full_name": "Real.ediam_Ico", "code": "@[simp]\ntheorem ediam_Ico (a b : \u211d) : EMetric.diam (Ico a b) = ENNReal.ofReal (b - a)", "start": [1552, 1], "end": [1555, 52], "kind": "commanddeclaration"}, {"full_name": "Real.ediam_Ioc", "code": "@[simp]\ntheorem ediam_Ioc (a b : \u211d) : EMetric.diam (Ioc a b) = ENNReal.ofReal (b - a)", "start": [1558, 1], "end": [1561, 52], "kind": "commanddeclaration"}, {"full_name": "Real.diam_Icc", "code": "theorem diam_Icc {a b : \u211d} (h : a \u2264 b) : Metric.diam (Icc a b) = b - a", "start": [1564, 1], "end": [1565, 61], "kind": "commanddeclaration"}, {"full_name": "Real.diam_Ico", "code": "theorem diam_Ico {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ico a b) = b - a", "start": [1568, 1], "end": [1569, 61], "kind": "commanddeclaration"}, {"full_name": "Real.diam_Ioc", "code": "theorem diam_Ioc {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ioc a b) = b - a", "start": [1572, 1], "end": [1573, 61], "kind": "commanddeclaration"}, {"full_name": "Real.diam_Ioo", "code": "theorem diam_Ioo {a b : \u211d} (h : a \u2264 b) : Metric.diam (Ioo a b) = b - a", "start": [1576, 1], "end": [1577, 61], "kind": "commanddeclaration"}, {"full_name": "edist_le_tsum_of_edist_le_of_tendsto", "code": "theorem edist_le_tsum_of_edist_le_of_tendsto {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    edist (f n) a \u2264 \u2211' m, d (n + m)", "start": [1582, 1], "end": [1590, 62], "kind": "commanddeclaration"}, {"full_name": "edist_le_tsum_of_edist_le_of_tendsto\u2080", "code": "theorem edist_le_tsum_of_edist_le_of_tendsto\u2080 {f : \u2115 \u2192 \u03b1} (d : \u2115 \u2192 \u211d\u22650\u221e)\n    (hf : \u2200 n, edist (f n) (f n.succ) \u2264 d n) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    edist (f 0) a \u2264 \u2211' m, d m", "start": [1593, 1], "end": [1597, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.limsup_sub_const", "code": "lemma limsup_sub_const (F : Filter \u03b9) [NeBot F] (f : \u03b9 \u2192 \u211d\u22650\u221e) (c : \u211d\u22650\u221e) :\n    Filter.limsup (fun i \u21a6 f i - c) F = Filter.limsup f F - c :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : \u211d\u22650\u221e) \u21a6 x - c)\n    (fun _ _ h \u21a6 tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm", "start": [1607, 1], "end": [1610, 85], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.liminf_sub_const", "code": "lemma liminf_sub_const (F : Filter \u03b9) [NeBot F] (f : \u03b9 \u2192 \u211d\u22650\u221e) (c : \u211d\u22650\u221e) :\n    Filter.liminf (fun i \u21a6 f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : \u211d\u22650\u221e) \u21a6 x - c)\n    (fun _ _ h \u21a6 tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm", "start": [1612, 1], "end": [1615, 85], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.limsup_const_sub", "code": "lemma limsup_const_sub (F : Filter \u03b9) [NeBot F] (f : \u03b9 \u2192 \u211d\u22650\u221e)\n    {c : \u211d\u22650\u221e} (c_ne_top : c \u2260 \u221e):\n    Filter.limsup (fun i \u21a6 c - f i) F = c - Filter.liminf f F :=\n  (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : \u211d\u22650\u221e) \u21a6 c - x)\n    (fun _ _ h \u21a6 tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm", "start": [1617, 1], "end": [1621, 90], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.liminf_const_sub", "code": "lemma liminf_const_sub (F : Filter \u03b9) [NeBot F] (f : \u03b9 \u2192 \u211d\u22650\u221e)\n    {c : \u211d\u22650\u221e} (c_ne_top : c \u2260 \u221e):\n    Filter.liminf (fun i \u21a6 c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : \u211d\u22650\u221e) \u21a6 c - x)\n    (fun _ _ h \u21a6 tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm", "start": [1623, 1], "end": [1627, 90], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Algebra/Algebra.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "continuous_algebraMap_iff_smul", "code": "theorem continuous_algebraMap_iff_smul :\n    Continuous (algebraMap R A) \u2194 Continuous fun p : R \u00d7 A => p.1 \u2022 p.2", "start": [42, 1], "end": [48, 58], "kind": "commanddeclaration"}, {"full_name": "continuous_algebraMap", "code": "@[continuity]\ntheorem continuous_algebraMap [ContinuousSMul R A] : Continuous (algebraMap R A)", "start": [51, 1], "end": [53, 57], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_of_algebraMap", "code": "theorem continuousSMul_of_algebraMap (h : Continuous (algebraMap R A)) : ContinuousSMul R A", "start": [56, 1], "end": [57, 45], "kind": "commanddeclaration"}, {"full_name": "algebraMapClm", "code": "@[simps]\ndef algebraMapClm : R \u2192L[R] A :=\n  { Algebra.linearMap R A with\n    toFun := algebraMap R A\n    cont := continuous_algebraMap R A }", "start": [62, 1], "end": [67, 40], "kind": "commanddeclaration"}, {"full_name": "algebraMapClm_coe", "code": "theorem algebraMapClm_coe : \u21d1(algebraMapClm R A) = algebraMap R A", "start": [70, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "algebraMapClm_toLinearMap", "code": "theorem algebraMapClm_toLinearMap : (algebraMapClm R A).toLinearMap = Algebra.linearMap R A", "start": [74, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.continuousSMul", "code": "instance Subalgebra.continuousSMul [TopologicalSpace R] [ContinuousSMul R A] (s : Subalgebra R A) :\n    ContinuousSMul R s :=\n  s.toSubmodule.continuousSMul", "start": [88, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalClosure", "code": "def Subalgebra.topologicalClosure (s : Subalgebra R A) : Subalgebra R A :=\n  {\n    s.toSubsemiring.topologicalClosure with\n    carrier := closure (s : Set A)\n    algebraMap_mem' := fun r => s.toSubsemiring.le_topologicalClosure (s.algebraMap_mem r) }", "start": [95, 1], "end": [100, 93], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalClosure_coe", "code": "@[simp]\ntheorem Subalgebra.topologicalClosure_coe (s : Subalgebra R A) :\n    (s.topologicalClosure : Set A) = closure (s : Set A)", "start": [103, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalSemiring", "code": "instance Subalgebra.topologicalSemiring (s : Subalgebra R A) : TopologicalSemiring s :=\n  s.toSubsemiring.topologicalSemiring", "start": [109, 1], "end": [110, 38], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.le_topologicalClosure", "code": "theorem Subalgebra.le_topologicalClosure (s : Subalgebra R A) : s \u2264 s.topologicalClosure", "start": [113, 1], "end": [114, 17], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isClosed_topologicalClosure", "code": "theorem Subalgebra.isClosed_topologicalClosure (s : Subalgebra R A) :\n    IsClosed (s.topologicalClosure : Set A)", "start": [117, 1], "end": [118, 82], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalClosure_minimal", "code": "theorem Subalgebra.topologicalClosure_minimal (s : Subalgebra R A) {t : Subalgebra R A} (h : s \u2264 t)\n    (ht : IsClosed (t : Set A)) : s.topologicalClosure \u2264 t", "start": [121, 1], "end": [123, 23], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.commSemiringTopologicalClosure", "code": "def Subalgebra.commSemiringTopologicalClosure [T2Space A] (s : Subalgebra R A)\n    (hs : \u2200 x y : s, x * y = y * x) : CommSemiring s.topologicalClosure :=\n  { s.topologicalClosure.toSemiring, s.toSubmonoid.commMonoidTopologicalClosure hs with }", "start": [126, 1], "end": [129, 90], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalClosure_comap_homeomorph", "code": "theorem Subalgebra.topologicalClosure_comap_homeomorph (s : Subalgebra R A) {B : Type*}\n    [TopologicalSpace B] [Ring B] [TopologicalRing B] [Algebra R B] (f : B \u2192\u2090[R] A) (f' : B \u2243\u209c A)\n    (w : (f : B \u2192 A) = f') : s.topologicalClosure.comap f = (s.comap f).topologicalClosure", "start": [132, 1], "end": [144, 30], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.commRingTopologicalClosure", "code": "@[reducible]\ndef Subalgebra.commRingTopologicalClosure [T2Space A] (s : Subalgebra R A)\n    (hs : \u2200 x y : s, x * y = y * x) : CommRing s.topologicalClosure :=\n  { s.topologicalClosure.toRing, s.toSubmonoid.commMonoidTopologicalClosure hs with }", "start": [159, 1], "end": [164, 86], "kind": "commanddeclaration"}, {"full_name": "Algebra.elementalAlgebra", "code": "def Algebra.elementalAlgebra (x : A) : Subalgebra R A :=\n  (Algebra.adjoin R ({x} : Set A)).topologicalClosure", "start": [169, 1], "end": [171, 54], "kind": "commanddeclaration"}, {"full_name": "Algebra.self_mem_elementalAlgebra", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem Algebra.self_mem_elementalAlgebra (x : A) : x \u2208 Algebra.elementalAlgebra R x", "start": [174, 1], "end": [177, 42], "kind": "commanddeclaration"}, {"full_name": "DivisionRing.continuousConstSMul_rat", "code": "instance DivisionRing.continuousConstSMul_rat {A} [DivisionRing A] [TopologicalSpace A]\n    [ContinuousMul A] [CharZero A] : ContinuousConstSMul \u211a A :=\n  \u27e8fun r => by simpa only [Algebra.smul_def] using continuous_const.mul continuous_id\u27e9", "start": [194, 1], "end": [197, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Order.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Basic.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StarOrderedRing", "code": "class StarOrderedRing (R : Type u) [NonUnitalSemiring R] [PartialOrder R] extends StarRing R where\n  \n  le_iff :\n    \u2200 x y : R, x \u2264 y \u2194 \u2203 p, p \u2208 AddSubmonoid.closure (Set.range fun s => star s * s) \u2227 y = x + p", "start": [41, 1], "end": [52, 97], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.toOrderedAddCommMonoid", "code": "instance (priority := 100) toOrderedAddCommMonoid [NonUnitalSemiring R] [PartialOrder R]\n    [StarOrderedRing R] : OrderedAddCommMonoid R where\n  add_le_add_left := fun x y hle z \u21a6 by\n    rw [StarOrderedRing.le_iff] at hle \u22a2\n    refine hle.imp fun s hs \u21a6 ?_\n    rw [hs.2, add_assoc]\n    exact \u27e8hs.1, rfl\u27e9", "start": [58, 1], "end": [64, 22], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.toExistsAddOfLE", "code": "instance (priority := 100) toExistsAddOfLE [NonUnitalSemiring R] [PartialOrder R]\n    [StarOrderedRing R] : ExistsAddOfLE R where\n  exists_add_of_le h :=\n    match (le_iff _ _).mp h with\n    | \u27e8p, _, hp\u27e9 => \u27e8p, hp\u27e9", "start": [68, 1], "end": [72, 28], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.toOrderedAddCommGroup", "code": "instance (priority := 100) toOrderedAddCommGroup [NonUnitalRing R] [PartialOrder R]\n    [StarOrderedRing R] : OrderedAddCommGroup R where\n  add_le_add_left := @add_le_add_left _ _ _ _", "start": [76, 1], "end": [78, 46], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.ofLEIff", "code": "@[reducible]\ndef ofLEIff [NonUnitalSemiring R] [PartialOrder R] [StarRing R]\n    (h_le_iff : \u2200 x y : R, x \u2264 y \u2194 \u2203 s, y = x + star s * s) : StarOrderedRing R where\n  le_iff x y := by\n    refine' \u27e8fun h => _, _\u27e9\n    \u00b7 obtain \u27e8p, hp\u27e9 := (h_le_iff x y).mp h\n      exact \u27e8star p * p, AddSubmonoid.subset_closure \u27e8p, rfl\u27e9, hp\u27e9\n    \u00b7 rintro \u27e8p, hp, hpxy\u27e9\n      revert x y hpxy\n      refine' AddSubmonoid.closure_induction hp _ (fun x y h => add_zero x \u25b8 h.ge) _\n      \u00b7 rintro _ \u27e8s, rfl\u27e9 x y rfl\n        exact (h_le_iff _ _).mpr \u27e8s, rfl\u27e9\n      \u00b7 rintro a b ha hb x y rfl\n        rw [\u2190 add_assoc]\n        exact (ha _ _ rfl).trans (hb _ _ rfl)", "start": [83, 1], "end": [106, 46], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.ofNonnegIff", "code": "@[reducible]\ndef ofNonnegIff [NonUnitalRing R] [PartialOrder R] [StarRing R]\n    (h_add : \u2200 {x y : R}, x \u2264 y \u2192 \u2200 z, z + x \u2264 z + y)\n    (h_nonneg_iff : \u2200 x : R, 0 \u2264 x \u2194 x \u2208 AddSubmonoid.closure (Set.range fun s : R => star s * s)) :\n    StarOrderedRing R where\n  le_iff x y := by\n    haveI : CovariantClass R R (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) := \u27e8fun _ _ _ h => h_add h _\u27e9\n    simpa only [\u2190 sub_eq_iff_eq_add', sub_nonneg, exists_eq_right'] using h_nonneg_iff (y - x)", "start": [110, 1], "end": [120, 95], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.ofNonnegIff'", "code": "@[reducible]\ndef ofNonnegIff' [NonUnitalRing R] [PartialOrder R] [StarRing R]\n    (h_add : \u2200 {x y : R}, x \u2264 y \u2192 \u2200 z, z + x \u2264 z + y)\n    (h_nonneg_iff : \u2200 x : R, 0 \u2264 x \u2194 \u2203 s, x = star s * s) : StarOrderedRing R :=\n  ofLEIff <| by\n    haveI : CovariantClass R R (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) := \u27e8fun _ _ _ h => h_add h _\u27e9\n    simpa [sub_eq_iff_eq_add', sub_nonneg] using fun x y => h_nonneg_iff (y - x)", "start": [124, 1], "end": [137, 81], "kind": "commanddeclaration"}, {"full_name": "StarOrderedRing.nonneg_iff", "code": "theorem nonneg_iff [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R] {x : R} :\n    0 \u2264 x \u2194 x \u2208 AddSubmonoid.closure (Set.range fun s : R => star s * s)", "start": [140, 1], "end": [142, 49], "kind": "commanddeclaration"}, {"full_name": "star_mul_self_nonneg", "code": "theorem star_mul_self_nonneg (r : R) : 0 \u2264 star r * r", "start": [151, 1], "end": [152, 73], "kind": "commanddeclaration"}, {"full_name": "star_mul_self_nonneg'", "code": "theorem star_mul_self_nonneg' (r : R) : 0 \u2264 r * star r", "start": [155, 1], "end": [156, 61], "kind": "commanddeclaration"}, {"full_name": "conjugate_nonneg", "code": "theorem conjugate_nonneg {a : R} (ha : 0 \u2264 a) (c : R) : 0 \u2264 star c * a * c", "start": [159, 1], "end": [169, 40], "kind": "commanddeclaration"}, {"full_name": "conjugate_nonneg'", "code": "theorem conjugate_nonneg' {a : R} (ha : 0 \u2264 a) (c : R) : 0 \u2264 c * a * star c", "start": [172, 1], "end": [173, 60], "kind": "commanddeclaration"}, {"full_name": "conjugate_le_conjugate", "code": "theorem conjugate_le_conjugate {a b : R} (hab : a \u2264 b) (c : R) :\n    star c * a * c \u2264 star c * b * c", "start": [176, 1], "end": [181, 81], "kind": "commanddeclaration"}, {"full_name": "conjugate_le_conjugate'", "code": "theorem conjugate_le_conjugate' {a b : R} (hab : a \u2264 b) (c : R) : c * a * star c \u2264 c * b * star c", "start": [184, 1], "end": [185, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/Basic.lean", "imports": ["Mathlib/Analysis/Normed/Group/Seminorm.lean", "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "Mathlib/Order/LiminfLimsup.lean", "Mathlib/Topology/Sequences.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Instances/Rat.lean", "Mathlib/Topology/MetricSpace/Algebra.lean"], "premises": [{"full_name": "Norm", "code": "@[notation_class]\nclass Norm (E : Type*) where\n  \n  norm : E \u2192 \u211d", "start": [53, 1], "end": [59, 15], "kind": "commanddeclaration"}, {"full_name": "NNNorm", "code": "@[notation_class]\nclass NNNorm (E : Type*) where\n  \n  nnnorm : E \u2192 \u211d\u22650", "start": [62, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "SeminormedAddGroup", "code": "class SeminormedAddGroup (E : Type*) extends Norm E, AddGroup E, PseudoMetricSpace E where\n  dist := fun x y => \u2016x - y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [79, 1], "end": [84, 50], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup", "code": "@[to_additive]\nclass SeminormedGroup (E : Type*) extends Norm E, Group E, PseudoMetricSpace E where\n  dist := fun x y => \u2016x / y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [87, 1], "end": [93, 50], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroup", "code": "class NormedAddGroup (E : Type*) extends Norm E, AddGroup E, MetricSpace E where\n  dist := fun x y => \u2016x - y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [96, 1], "end": [101, 50], "kind": "commanddeclaration"}, {"full_name": "NormedGroup", "code": "@[to_additive]\nclass NormedGroup (E : Type*) extends Norm E, Group E, MetricSpace E where\n  dist := fun x y => \u2016x / y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [104, 1], "end": [110, 50], "kind": "commanddeclaration"}, {"full_name": "SeminormedAddCommGroup", "code": "class SeminormedAddCommGroup (E : Type*) extends Norm E, AddCommGroup E,\n  PseudoMetricSpace E where\n  dist := fun x y => \u2016x - y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [113, 1], "end": [119, 50], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup", "code": "@[to_additive]\nclass SeminormedCommGroup (E : Type*) extends Norm E, CommGroup E, PseudoMetricSpace E where\n  dist := fun x y => \u2016x / y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [122, 1], "end": [128, 50], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup", "code": "class NormedAddCommGroup (E : Type*) extends Norm E, AddCommGroup E, MetricSpace E where\n  dist := fun x y => \u2016x - y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x - y\u2016 := by aesop", "start": [131, 1], "end": [136, 50], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup", "code": "@[to_additive]\nclass NormedCommGroup (E : Type*) extends Norm E, CommGroup E, MetricSpace E where\n  dist := fun x y => \u2016x / y\u2016\n  \n  dist_eq : \u2200 x y, dist x y = \u2016x / y\u2016 := by aesop", "start": [139, 1], "end": [145, 50], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.toSeminormedGroup", "code": "@[to_additive]\ninstance (priority := 100) NormedGroup.toSeminormedGroup [NormedGroup E] : SeminormedGroup E :=\n  { \u2039NormedGroup E\u203a with }", "start": [149, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.toSeminormedCommGroup", "code": "@[to_additive]\ninstance (priority := 100) NormedCommGroup.toSeminormedCommGroup [NormedCommGroup E] :\n    SeminormedCommGroup E :=\n  { \u2039NormedCommGroup E\u203a with }", "start": [156, 1], "end": [159, 31], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.toSeminormedGroup", "code": "@[to_additive]\ninstance (priority := 100) SeminormedCommGroup.toSeminormedGroup [SeminormedCommGroup E] :\n    SeminormedGroup E :=\n  { \u2039SeminormedCommGroup E\u203a with }", "start": [164, 1], "end": [167, 35], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.toNormedGroup", "code": "@[to_additive]\ninstance (priority := 100) NormedCommGroup.toNormedGroup [NormedCommGroup E] : NormedGroup E :=\n  { \u2039NormedCommGroup E\u203a with }", "start": [172, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.ofSeparation", "code": "@[to_additive (attr := reducible) \"Construct a `NormedAddGroup` from a `SeminormedAddGroup`\nsatisfying `\u2200 x, \u2016x\u2016 = 0 \u2192 x = 0`. This avoids having to go back to the `(Pseudo)MetricSpace`\nlevel when declaring a `NormedAddGroup` instance as a special case of a more general\n`SeminormedAddGroup` instance.\"]\ndef NormedGroup.ofSeparation [SeminormedGroup E] (h : \u2200 x : E, \u2016x\u2016 = 0 \u2192 x = 1) : NormedGroup E :=\n  { \u2039SeminormedGroup E\u203a with\n    toMetricSpace :=\n      { eq_of_dist_eq_zero := fun hxy =>\n          div_eq_one.1 <| h _ <| by exact (\u2039SeminormedGroup E\u203a.dist_eq _ _).symm.trans hxy } }", "start": [179, 1], "end": [190, 95], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.ofSeparation", "code": "@[to_additive (attr := reducible) \"Construct a `NormedAddCommGroup` from a\n`SeminormedAddCommGroup` satisfying `\u2200 x, \u2016x\u2016 = 0 \u2192 x = 0`. This avoids having to go back to the\n`(Pseudo)MetricSpace` level when declaring a `NormedAddCommGroup` instance as a special case\nof a more general `SeminormedAddCommGroup` instance.\"]\ndef NormedCommGroup.ofSeparation [SeminormedCommGroup E] (h : \u2200 x : E, \u2016x\u2016 = 0 \u2192 x = 1) :\n    NormedCommGroup E :=\n  { \u2039SeminormedCommGroup E\u203a, NormedGroup.ofSeparation h with }", "start": [199, 1], "end": [209, 63], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.ofMulDist", "code": "@[to_additive \"Construct a seminormed group from a translation-invariant distance.\"]\ndef SeminormedGroup.ofMulDist [Norm E] [Group E] [PseudoMetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist x y \u2264 dist (x * z) (y * z)) :\n    SeminormedGroup E where\n  dist_eq x y := by\n    rw [h\u2081]; apply le_antisymm\n    \u00b7 simpa only [div_eq_mul_inv, \u2190 mul_right_inv y] using h\u2082 _ _ _\n    \u00b7 simpa only [div_mul_cancel', one_mul] using h\u2082 (x / y) 1 y", "start": [213, 1], "end": [221, 65], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.ofMulDist'", "code": "@[to_additive \"Construct a seminormed group from a translation-invariant pseudodistance.\"]\ndef SeminormedGroup.ofMulDist' [Norm E] [Group E] [PseudoMetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist (x * z) (y * z) \u2264 dist x y) :\n    SeminormedGroup E where\n  dist_eq x y := by\n    rw [h\u2081]; apply le_antisymm\n    \u00b7 simpa only [div_mul_cancel', one_mul] using h\u2082 (x / y) 1 y\n    \u00b7 simpa only [div_eq_mul_inv, \u2190 mul_right_inv y] using h\u2082 _ _ _", "start": [225, 1], "end": [233, 68], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.ofMulDist", "code": "@[to_additive \"Construct a seminormed group from a translation-invariant pseudodistance.\"]\ndef SeminormedCommGroup.ofMulDist [Norm E] [CommGroup E] [PseudoMetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist x y \u2264 dist (x * z) (y * z)) :\n    SeminormedCommGroup E :=\n  { SeminormedGroup.ofMulDist h\u2081 h\u2082 with\n    mul_comm := mul_comm }", "start": [237, 1], "end": [243, 27], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.ofMulDist'", "code": "@[to_additive \"Construct a seminormed group from a translation-invariant pseudodistance.\"]\ndef SeminormedCommGroup.ofMulDist' [Norm E] [CommGroup E] [PseudoMetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist (x * z) (y * z) \u2264 dist x y) :\n    SeminormedCommGroup E :=\n  { SeminormedGroup.ofMulDist' h\u2081 h\u2082 with\n    mul_comm := mul_comm }", "start": [247, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.ofMulDist", "code": "@[to_additive \"Construct a normed group from a translation-invariant distance.\"]\ndef NormedGroup.ofMulDist [Norm E] [Group E] [MetricSpace E] (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1)\n    (h\u2082 : \u2200 x y z : E, dist x y \u2264 dist (x * z) (y * z)) : NormedGroup E :=\n  { SeminormedGroup.ofMulDist h\u2081 h\u2082 with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [257, 1], "end": [262, 47], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.ofMulDist'", "code": "@[to_additive \"Construct a normed group from a translation-invariant pseudodistance.\"]\ndef NormedGroup.ofMulDist' [Norm E] [Group E] [MetricSpace E] (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1)\n    (h\u2082 : \u2200 x y z : E, dist (x * z) (y * z) \u2264 dist x y) : NormedGroup E :=\n  { SeminormedGroup.ofMulDist' h\u2081 h\u2082 with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [266, 1], "end": [271, 47], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.ofMulDist", "code": "@[to_additive \"Construct a normed group from a translation-invariant pseudodistance.\"]\ndef NormedCommGroup.ofMulDist [Norm E] [CommGroup E] [MetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist x y \u2264 dist (x * z) (y * z)) :\n    NormedCommGroup E :=\n  { NormedGroup.ofMulDist h\u2081 h\u2082 with\n    mul_comm := mul_comm }", "start": [275, 1], "end": [281, 27], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.ofMulDist'", "code": "@[to_additive \"Construct a normed group from a translation-invariant pseudodistance.\"]\ndef NormedCommGroup.ofMulDist' [Norm E] [CommGroup E] [MetricSpace E]\n    (h\u2081 : \u2200 x : E, \u2016x\u2016 = dist x 1) (h\u2082 : \u2200 x y z : E, dist (x * z) (y * z) \u2264 dist x y) :\n    NormedCommGroup E :=\n  { NormedGroup.ofMulDist' h\u2081 h\u2082 with\n    mul_comm := mul_comm }", "start": [285, 1], "end": [291, 27], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.toSeminormedGroup", "code": "@[to_additive \"Construct a seminormed group from a seminorm, i.e., registering the pseudodistance\nand the pseudometric space structure from the seminorm properties. Note that in most cases this\ninstance creates bad definitional equalities (e.g., it does not take into account a possibly\nexisting `UniformSpace` instance on `E`).\"]\ndef GroupSeminorm.toSeminormedGroup [Group E] (f : GroupSeminorm E) : SeminormedGroup E where\n  dist x y := f (x / y)\n  norm := f\n  dist_eq x y := rfl\n  dist_self x := by simp only [div_self', map_one_eq_zero]\n  dist_triangle := le_map_div_add_map_div f\n  dist_comm := map_div_rev f\n  edist_dist x y := by exact ENNReal.coe_nnreal_eq _", "start": [295, 1], "end": [310, 53], "kind": "commanddeclaration"}, {"full_name": "GroupSeminorm.toSeminormedCommGroup", "code": "@[to_additive \"Construct a seminormed group from a seminorm, i.e., registering the pseudodistance\nand the pseudometric space structure from the seminorm properties. Note that in most cases this\ninstance creates bad definitional equalities (e.g., it does not take into account a possibly\nexisting `UniformSpace` instance on `E`).\"]\ndef GroupSeminorm.toSeminormedCommGroup [CommGroup E] (f : GroupSeminorm E) :\n    SeminormedCommGroup E :=\n  { f.toSeminormedGroup with\n    mul_comm := mul_comm }", "start": [315, 1], "end": [326, 27], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.toNormedGroup", "code": "@[to_additive \"Construct a normed group from a norm, i.e., registering the distance and the metric\nspace structure from the norm properties. Note that in most cases this instance creates bad\ndefinitional equalities (e.g., it does not take into account a possibly existing `UniformSpace`\ninstance on `E`).\"]\ndef GroupNorm.toNormedGroup [Group E] (f : GroupNorm E) : NormedGroup E :=\n  { f.toGroupSeminorm.toSeminormedGroup with\n    eq_of_dist_eq_zero := fun h => div_eq_one.1 <| eq_one_of_map_eq_zero f h }", "start": [330, 1], "end": [340, 79], "kind": "commanddeclaration"}, {"full_name": "GroupNorm.toNormedCommGroup", "code": "@[to_additive \"Construct a normed group from a norm, i.e., registering the distance and the metric\nspace structure from the norm properties. Note that in most cases this instance creates bad\ndefinitional equalities (e.g., it does not take into account a possibly existing `UniformSpace`\ninstance on `E`).\"]\ndef GroupNorm.toNormedCommGroup [CommGroup E] (f : GroupNorm E) : NormedCommGroup E :=\n  { f.toNormedGroup with\n    mul_comm := mul_comm }", "start": [344, 1], "end": [354, 27], "kind": "commanddeclaration"}, {"full_name": "PUnit.normedAddCommGroup", "code": "instance PUnit.normedAddCommGroup : NormedAddCommGroup PUnit where\n  norm := Function.const _ 0\n  dist_eq _ _ := rfl", "start": [358, 1], "end": [360, 21], "kind": "commanddeclaration"}, {"full_name": "PUnit.norm_eq_zero", "code": "@[simp]\ntheorem PUnit.norm_eq_zero (r : PUnit) : \u2016r\u2016 = 0", "start": [362, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "dist_eq_norm_div", "code": "@[to_additive]\ntheorem dist_eq_norm_div (a b : E) : dist a b = \u2016a / b\u2016", "start": [372, 1], "end": [374, 30], "kind": "commanddeclaration"}, {"full_name": "dist_eq_norm_div'", "code": "@[to_additive]\ntheorem dist_eq_norm_div' (a b : E) : dist a b = \u2016b / a\u2016", "start": [378, 1], "end": [379, 96], "kind": "commanddeclaration"}, {"full_name": "dist_eq_norm", "code": "alias dist_eq_norm := dist_eq_norm_sub", "start": [383, 1], "end": [383, 39], "kind": "stdtacticaliasalias"}, {"full_name": "dist_eq_norm'", "code": "alias dist_eq_norm' := dist_eq_norm_sub'", "start": [386, 1], "end": [386, 41], "kind": "stdtacticaliasalias"}, {"full_name": "NormedGroup.to_isometricSMul_right", "code": "@[to_additive]\ninstance NormedGroup.to_isometricSMul_right : IsometricSMul E\u1d50\u1d52\u1d56 E :=\n  \u27e8fun a => Isometry.of_dist_eq fun b c => by simp [dist_eq_norm_div]\u27e9", "start": [389, 1], "end": [391, 71], "kind": "commanddeclaration"}, {"full_name": "dist_one_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_one_right (a : E) : dist a 1 = \u2016a\u2016", "start": [395, 1], "end": [396, 85], "kind": "commanddeclaration"}, {"full_name": "dist_one_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_one_left : dist (1 : E) = norm", "start": [400, 1], "end": [402, 52], "kind": "commanddeclaration"}, {"full_name": "Isometry.norm_map_of_map_one", "code": "@[to_additive]\ntheorem Isometry.norm_map_of_map_one {f : E \u2192 F} (hi : Isometry f) (h\u2081 : f 1 = 1) (x : E) :\n    \u2016f x\u2016 = \u2016x\u2016", "start": [406, 1], "end": [408, 78], "kind": "commanddeclaration"}, {"full_name": "comap_norm_atTop'", "code": "@[to_additive (attr := simp) comap_norm_atTop]\ntheorem comap_norm_atTop' : comap norm atTop = cobounded E", "start": [412, 1], "end": [414, 67], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_atTop_iff_cobounded'", "code": "@[to_additive (attr := simp) tendsto_norm_atTop_iff_cobounded]\ntheorem tendsto_norm_atTop_iff_cobounded' {f : \u03b1 \u2192 E} {l : Filter \u03b1} :\n    Tendsto (\u2016f \u00b7\u2016) l atTop \u2194 Tendsto f l (cobounded E)", "start": [416, 1], "end": [419, 51], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_cobounded_atTop'", "code": "@[to_additive tendsto_norm_cobounded_atTop]\ntheorem tendsto_norm_cobounded_atTop' : Tendsto norm (cobounded E) atTop", "start": [421, 1], "end": [423, 49], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_cocompact_atTop'", "code": "@[to_additive tendsto_norm_cocompact_atTop]\ntheorem tendsto_norm_cocompact_atTop' [ProperSpace E] : Tendsto norm (cocompact E) atTop", "start": [425, 1], "end": [427, 66], "kind": "commanddeclaration"}, {"full_name": "norm_div_rev", "code": "@[to_additive]\ntheorem norm_div_rev (a b : E) : \u2016a / b\u2016 = \u2016b / a\u2016", "start": [431, 1], "end": [433, 52], "kind": "commanddeclaration"}, {"full_name": "norm_inv'", "code": "@[to_additive (attr := simp) norm_neg]\ntheorem norm_inv' (a : E) : \u2016a\u207b\u00b9\u2016 = \u2016a\u2016", "start": [437, 1], "end": [438, 75], "kind": "commanddeclaration"}, {"full_name": "dist_mulIndicator", "code": "@[to_additive]\ntheorem dist_mulIndicator (s t : Set \u03b1) (f : \u03b1 \u2192 E) (x : \u03b1) :\n    dist (s.mulIndicator f x) (t.mulIndicator f x) = \u2016(s \u2206 t).mulIndicator f x\u2016", "start": [442, 1], "end": [445, 67], "kind": "commanddeclaration"}, {"full_name": "dist_mul_self_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_mul_self_right (a b : E) : dist b (a * b) = \u2016a\u2016", "start": [447, 1], "end": [449, 56], "kind": "commanddeclaration"}, {"full_name": "dist_mul_self_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_mul_self_left (a b : E) : dist (a * b) b = \u2016a\u2016", "start": [453, 1], "end": [455, 38], "kind": "commanddeclaration"}, {"full_name": "dist_div_eq_dist_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_div_eq_dist_mul_left (a b c : E) : dist (a / b) c = dist a (c * b)", "start": [459, 1], "end": [461, 47], "kind": "commanddeclaration"}, {"full_name": "dist_div_eq_dist_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_div_eq_dist_mul_right (a b c : E) : dist a (b / c) = dist (a * c) b", "start": [465, 1], "end": [467, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_inv_cobounded", "code": "@[to_additive \"In a (semi)normed group, negation `x \u21a6 -x` tends to infinity at infinity. TODO: use\n`Bornology.cobounded` instead of `Filter.comap Norm.norm Filter.atTop`.\"]\ntheorem Filter.tendsto_inv_cobounded :\n    Tendsto (Inv.inv : E \u2192 E) (comap norm atTop) (comap norm atTop)", "start": [471, 1], "end": [477, 73], "kind": "commanddeclaration"}, {"full_name": "norm_mul_le'", "code": "@[to_additive norm_add_le \"**Triangle inequality** for the norm.\"]\ntheorem norm_mul_le' (a b : E) : \u2016a * b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016", "start": [481, 1], "end": [484, 55], "kind": "commanddeclaration"}, {"full_name": "norm_mul_le_of_le", "code": "@[to_additive]\ntheorem norm_mul_le_of_le (h\u2081 : \u2016a\u2081\u2016 \u2264 r\u2081) (h\u2082 : \u2016a\u2082\u2016 \u2264 r\u2082) : \u2016a\u2081 * a\u2082\u2016 \u2264 r\u2081 + r\u2082", "start": [488, 1], "end": [490, 49], "kind": "commanddeclaration"}, {"full_name": "norm_mul\u2083_le", "code": "@[to_additive norm_add\u2083_le]\ntheorem norm_mul\u2083_le (a b c : E) : \u2016a * b * c\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016 + \u2016c\u2016", "start": [494, 1], "end": [496, 46], "kind": "commanddeclaration"}, {"full_name": "norm_nonneg'", "code": "@[to_additive (attr := simp) norm_nonneg]\ntheorem norm_nonneg' (a : E) : 0 \u2264 \u2016a\u2016", "start": [500, 1], "end": [503, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalMulNorm", "code": "@[positivity Norm.norm _]\ndef evalMulNorm : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app _ a \u2190 whnfR e | throwError \"not \u2016 \u00b7 \u2016\"\n  let p \u2190 mkAppM ``norm_nonneg' #[a]\n  pure (.nonnegative p)", "start": [511, 1], "end": [517, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalAddNorm", "code": "@[positivity Norm.norm _]\ndef evalAddNorm : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app _ a \u2190 whnfR e | throwError \"not \u2016 \u00b7 \u2016\"\n  let p \u2190 mkAppM ``norm_nonneg #[a]\n  pure (.nonnegative p)", "start": [519, 1], "end": [524, 24], "kind": "commanddeclaration"}, {"full_name": "norm_one'", "code": "@[to_additive (attr := simp) norm_zero]\ntheorem norm_one' : \u2016(1 : E)\u2016 = 0", "start": [528, 1], "end": [529, 73], "kind": "commanddeclaration"}, {"full_name": "ne_one_of_norm_ne_zero", "code": "@[to_additive]\ntheorem ne_one_of_norm_ne_zero : \u2016a\u2016 \u2260 0 \u2192 a \u2260 1", "start": [533, 1], "end": [537, 20], "kind": "commanddeclaration"}, {"full_name": "norm_of_subsingleton'", "code": "@[to_additive (attr := nontriviality) norm_of_subsingleton]\ntheorem norm_of_subsingleton' [Subsingleton E] (a : E) : \u2016a\u2016 = 0", "start": [541, 1], "end": [543, 40], "kind": "commanddeclaration"}, {"full_name": "zero_lt_one_add_norm_sq'", "code": "@[to_additive zero_lt_one_add_norm_sq]\ntheorem zero_lt_one_add_norm_sq' (x : E) : 0 < 1 + \u2016x\u2016 ^ 2", "start": [547, 1], "end": [549, 13], "kind": "commanddeclaration"}, {"full_name": "norm_div_le", "code": "@[to_additive]\ntheorem norm_div_le (a b : E) : \u2016a / b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016", "start": [553, 1], "end": [555, 53], "kind": "commanddeclaration"}, {"full_name": "norm_div_le_of_le", "code": "@[to_additive]\ntheorem norm_div_le_of_le {r\u2081 r\u2082 : \u211d} (H\u2081 : \u2016a\u2081\u2016 \u2264 r\u2081) (H\u2082 : \u2016a\u2082\u2016 \u2264 r\u2082) : \u2016a\u2081 / a\u2082\u2016 \u2264 r\u2081 + r\u2082", "start": [559, 1], "end": [561, 48], "kind": "commanddeclaration"}, {"full_name": "dist_le_norm_add_norm'", "code": "@[to_additive dist_le_norm_add_norm]\ntheorem dist_le_norm_add_norm' (a b : E) : dist a b \u2264 \u2016a\u2016 + \u2016b\u2016", "start": [565, 1], "end": [568, 20], "kind": "commanddeclaration"}, {"full_name": "abs_norm_sub_norm_le'", "code": "@[to_additive abs_norm_sub_norm_le]\ntheorem abs_norm_sub_norm_le' (a b : E) : |\u2016a\u2016 - \u2016b\u2016| \u2264 \u2016a / b\u2016", "start": [572, 1], "end": [574, 55], "kind": "commanddeclaration"}, {"full_name": "norm_sub_norm_le'", "code": "@[to_additive norm_sub_norm_le]\ntheorem norm_sub_norm_le' (a b : E) : \u2016a\u2016 - \u2016b\u2016 \u2264 \u2016a / b\u2016", "start": [578, 1], "end": [580, 52], "kind": "commanddeclaration"}, {"full_name": "dist_norm_norm_le'", "code": "@[to_additive dist_norm_norm_le]\ntheorem dist_norm_norm_le' (a b : E) : dist \u2016a\u2016 \u2016b\u2016 \u2264 \u2016a / b\u2016", "start": [584, 1], "end": [586, 28], "kind": "commanddeclaration"}, {"full_name": "norm_le_norm_add_norm_div'", "code": "@[to_additive]\ntheorem norm_le_norm_add_norm_div' (u v : E) : \u2016u\u2016 \u2264 \u2016v\u2016 + \u2016u / v\u2016", "start": [590, 1], "end": [594, 23], "kind": "commanddeclaration"}, {"full_name": "norm_le_norm_add_norm_div", "code": "@[to_additive]\ntheorem norm_le_norm_add_norm_div (u v : E) : \u2016v\u2016 \u2264 \u2016u\u2016 + \u2016u / v\u2016", "start": [598, 1], "end": [601, 39], "kind": "commanddeclaration"}, {"full_name": "norm_le_insert'", "code": "alias norm_le_insert' := norm_le_norm_add_norm_sub'", "start": [605, 1], "end": [605, 52], "kind": "stdtacticaliasalias"}, {"full_name": "norm_le_insert", "code": "alias norm_le_insert := norm_le_norm_add_norm_sub", "start": [608, 1], "end": [608, 50], "kind": "stdtacticaliasalias"}, {"full_name": "norm_le_mul_norm_add", "code": "@[to_additive]\ntheorem norm_le_mul_norm_add (u v : E) : \u2016u\u2016 \u2264 \u2016u * v\u2016 + \u2016v\u2016", "start": [611, 1], "end": [615, 41], "kind": "commanddeclaration"}, {"full_name": "ball_eq'", "code": "@[to_additive ball_eq]\ntheorem ball_eq' (y : E) (\u03b5 : \u211d) : ball y \u03b5 = { x | \u2016x / y\u2016 < \u03b5 }", "start": [619, 1], "end": [621, 46], "kind": "commanddeclaration"}, {"full_name": "ball_one_eq", "code": "@[to_additive]\ntheorem ball_one_eq (r : \u211d) : ball (1 : E) r = { x | \u2016x\u2016 < r }", "start": [625, 1], "end": [627, 27], "kind": "commanddeclaration"}, {"full_name": "mem_ball_iff_norm''", "code": "@[to_additive mem_ball_iff_norm]\ntheorem mem_ball_iff_norm'' : b \u2208 ball a r \u2194 \u2016b / a\u2016 < r", "start": [631, 1], "end": [632, 95], "kind": "commanddeclaration"}, {"full_name": "mem_ball_iff_norm'''", "code": "@[to_additive mem_ball_iff_norm']\ntheorem mem_ball_iff_norm''' : b \u2208 ball a r \u2194 \u2016a / b\u2016 < r", "start": [636, 1], "end": [637, 97], "kind": "commanddeclaration"}, {"full_name": "mem_ball_one_iff", "code": "@[to_additive] theorem mem_ball_one_iff : a \u2208 ball (1 : E) r \u2194 \u2016a\u2016 < r", "start": [641, 1], "end": [642, 92], "kind": "commanddeclaration"}, {"full_name": "mem_closedBall_iff_norm''", "code": "@[to_additive mem_closedBall_iff_norm]\ntheorem mem_closedBall_iff_norm'' : b \u2208 closedBall a r \u2194 \u2016b / a\u2016 \u2264 r", "start": [646, 1], "end": [648, 40], "kind": "commanddeclaration"}, {"full_name": "mem_closedBall_one_iff", "code": "@[to_additive] theorem mem_closedBall_one_iff : a \u2208 closedBall (1 : E) r \u2194 \u2016a\u2016 \u2264 r", "start": [652, 1], "end": [654, 38], "kind": "commanddeclaration"}, {"full_name": "mem_closedBall_iff_norm'''", "code": "@[to_additive mem_closedBall_iff_norm']\ntheorem mem_closedBall_iff_norm''' : b \u2208 closedBall a r \u2194 \u2016a / b\u2016 \u2264 r", "start": [658, 1], "end": [660, 41], "kind": "commanddeclaration"}, {"full_name": "norm_le_of_mem_closedBall'", "code": "@[to_additive norm_le_of_mem_closedBall]\ntheorem norm_le_of_mem_closedBall' (h : b \u2208 closedBall a r) : \u2016b\u2016 \u2264 \u2016a\u2016 + r", "start": [664, 1], "end": [666, 92], "kind": "commanddeclaration"}, {"full_name": "norm_le_norm_add_const_of_dist_le'", "code": "@[to_additive norm_le_norm_add_const_of_dist_le]\ntheorem norm_le_norm_add_const_of_dist_le' : dist a b \u2264 r \u2192 \u2016a\u2016 \u2264 \u2016b\u2016 + r", "start": [670, 1], "end": [672, 29], "kind": "commanddeclaration"}, {"full_name": "norm_lt_of_mem_ball'", "code": "@[to_additive norm_lt_of_mem_ball]\ntheorem norm_lt_of_mem_ball' (h : b \u2208 ball a r) : \u2016b\u2016 < \u2016a\u2016 + r", "start": [676, 1], "end": [678, 95], "kind": "commanddeclaration"}, {"full_name": "norm_div_sub_norm_div_le_norm_div", "code": "@[to_additive]\ntheorem norm_div_sub_norm_div_le_norm_div (u v w : E) : \u2016u / w\u2016 - \u2016v / w\u2016 \u2264 \u2016u / v\u2016", "start": [682, 1], "end": [684, 81], "kind": "commanddeclaration"}, {"full_name": "isBounded_iff_forall_norm_le'", "code": "@[to_additive isBounded_iff_forall_norm_le]\ntheorem isBounded_iff_forall_norm_le' : Bornology.IsBounded s \u2194 \u2203 C, \u2200 x \u2208 s, \u2016x\u2016 \u2264 C", "start": [688, 1], "end": [690, 100], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.exists_norm_le'", "code": "alias \u27e8Bornology.IsBounded.exists_norm_le', _\u27e9 := isBounded_iff_forall_norm_le'", "start": [694, 1], "end": [694, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsBounded.exists_norm_le", "code": "alias \u27e8Bornology.IsBounded.exists_norm_le, _\u27e9 := isBounded_iff_forall_norm_le", "start": [697, 1], "end": [697, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsBounded.exists_pos_norm_le'", "code": "@[to_additive exists_pos_norm_le]\ntheorem Bornology.IsBounded.exists_pos_norm_le' (hs : IsBounded s) : \u2203 R > 0, \u2200 x \u2208 s, \u2016x\u2016 \u2264 R", "start": [702, 1], "end": [705, 77], "kind": "commanddeclaration"}, {"full_name": "mem_sphere_iff_norm'", "code": "@[to_additive (attr := simp 1001) mem_sphere_iff_norm]\ntheorem mem_sphere_iff_norm' : b \u2208 sphere a r \u2194 \u2016b / a\u2016 = r", "start": [709, 1], "end": [711, 90], "kind": "commanddeclaration"}, {"full_name": "mem_sphere_one_iff_norm", "code": "@[to_additive] theorem mem_sphere_one_iff_norm : a \u2208 sphere (1 : E) r \u2194 \u2016a\u2016 = r", "start": [715, 1], "end": [716, 95], "kind": "commanddeclaration"}, {"full_name": "norm_eq_of_mem_sphere'", "code": "@[to_additive (attr := simp) norm_eq_of_mem_sphere]\ntheorem norm_eq_of_mem_sphere' (x : sphere (1 : E) r) : \u2016(x : E)\u2016 = r", "start": [720, 1], "end": [722, 33], "kind": "commanddeclaration"}, {"full_name": "ne_one_of_mem_sphere", "code": "@[to_additive]\ntheorem ne_one_of_mem_sphere (hr : r \u2260 0) (x : sphere (1 : E) r) : (x : E) \u2260 1", "start": [726, 1], "end": [728, 62], "kind": "commanddeclaration"}, {"full_name": "ne_one_of_mem_unit_sphere", "code": "@[to_additive ne_zero_of_mem_unit_sphere]\ntheorem ne_one_of_mem_unit_sphere (x : sphere (1 : E) 1) : (x : E) \u2260 1", "start": [732, 1], "end": [734, 37], "kind": "commanddeclaration"}, {"full_name": "normGroupSeminorm", "code": "@[to_additive \"The norm of a seminormed group as an additive group seminorm.\"]\ndef normGroupSeminorm : GroupSeminorm E :=\n  \u27e8norm, norm_one', norm_mul_le', norm_inv'\u27e9", "start": [740, 1], "end": [743, 45], "kind": "commanddeclaration"}, {"full_name": "coe_normGroupSeminorm", "code": "@[to_additive (attr := simp)]\ntheorem coe_normGroupSeminorm : \u21d1(normGroupSeminorm E) = norm", "start": [747, 1], "end": [749, 6], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.tendsto_nhds_one", "code": "@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_one {f : \u03b1 \u2192 E} {l : Filter \u03b1} :\n    Tendsto f l (\ud835\udcdd 1) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in l, \u2016f x\u2016 < \u03b5", "start": [755, 1], "end": [758, 61], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.tendsto_nhds_nhds", "code": "@[to_additive]\ntheorem NormedCommGroup.tendsto_nhds_nhds {f : E \u2192 F} {x : E} {y : F} :\n    Tendsto f (\ud835\udcdd x) (\ud835\udcdd y) \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x', \u2016x' / x\u2016 < \u03b4 \u2192 \u2016f x' / y\u2016 < \u03b5", "start": [762, 1], "end": [765, 55], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.cauchySeq_iff", "code": "@[to_additive]\ntheorem NormedCommGroup.cauchySeq_iff [Nonempty \u03b1] [SemilatticeSup \u03b1] {u : \u03b1 \u2192 E} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m, N \u2264 m \u2192 \u2200 n, N \u2264 n \u2192 \u2016u m / u n\u2016 < \u03b5", "start": [769, 1], "end": [772, 48], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.nhds_basis_norm_lt", "code": "@[to_additive]\ntheorem NormedCommGroup.nhds_basis_norm_lt (x : E) :\n    (\ud835\udcdd x).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { y | \u2016y / x\u2016 < \u03b5 }", "start": [776, 1], "end": [780, 31], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.nhds_one_basis_norm_lt", "code": "@[to_additive]\ntheorem NormedCommGroup.nhds_one_basis_norm_lt :\n    (\ud835\udcdd (1 : E)).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { y | \u2016y\u2016 < \u03b5 }", "start": [784, 1], "end": [788, 7], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.uniformity_basis_dist", "code": "@[to_additive]\ntheorem NormedCommGroup.uniformity_basis_dist :\n    (\ud835\udce4 E).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { p : E \u00d7 E | \u2016p.fst / p.snd\u2016 < \u03b5 }", "start": [792, 1], "end": [796, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.lipschitz_of_bound", "code": "@[to_additive \"A homomorphism `f` of seminormed groups is Lipschitz, if there exists a constant\n`C` such that for all `x`, one has `\u2016f x\u2016 \u2264 C * \u2016x\u2016`. The analogous condition for a linear map of\n(semi)normed spaces is in `Mathlib/Analysis/NormedSpace/OperatorNorm.lean`.\"]\ntheorem MonoidHomClass.lipschitz_of_bound [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) (C : \u211d)\n    (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : LipschitzWith (Real.toNNReal C) f", "start": [802, 1], "end": [810, 97], "kind": "commanddeclaration"}, {"full_name": "lipschitzOnWith_iff_norm_div_le", "code": "@[to_additive]\ntheorem lipschitzOnWith_iff_norm_div_le {f : E \u2192 F} {C : \u211d\u22650} :\n    LipschitzOnWith C f s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2016f x / f y\u2016 \u2264 C * \u2016x / y\u2016", "start": [814, 1], "end": [817, 64], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.norm_div_le", "code": "alias \u27e8LipschitzOnWith.norm_div_le, _\u27e9 := lipschitzOnWith_iff_norm_div_le", "start": [821, 1], "end": [821, 74], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzOnWith.norm_div_le_of_le", "code": "@[to_additive]\ntheorem LipschitzOnWith.norm_div_le_of_le {f : E \u2192 F} {C : \u211d\u22650} (h : LipschitzOnWith C f s)\n    (ha : a \u2208 s) (hb : b \u2208 s) (hr : \u2016a / b\u2016 \u2264 r) : \u2016f a / f b\u2016 \u2264 C * r", "start": [826, 1], "end": [829, 43], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_iff_norm_div_le", "code": "@[to_additive]\ntheorem lipschitzWith_iff_norm_div_le {f : E \u2192 F} {C : \u211d\u22650} :\n    LipschitzWith C f \u2194 \u2200 x y, \u2016f x / f y\u2016 \u2264 C * \u2016x / y\u2016", "start": [833, 1], "end": [836, 62], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.norm_div_le", "code": "alias \u27e8LipschitzWith.norm_div_le, _\u27e9 := lipschitzWith_iff_norm_div_le", "start": [840, 1], "end": [840, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzWith.norm_div_le_of_le", "code": "@[to_additive]\ntheorem LipschitzWith.norm_div_le_of_le {f : E \u2192 F} {C : \u211d\u22650} (h : LipschitzWith C f)\n    (hr : \u2016a / b\u2016 \u2264 r) : \u2016f a / f b\u2016 \u2264 C * r", "start": [845, 1], "end": [848, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.continuous_of_bound", "code": "@[to_additive \"A homomorphism `f` of seminormed groups is continuous, if there exists a constant `C`\nsuch that for all `x`, one has `\u2016f x\u2016 \u2264 C * \u2016x\u2016`\"]\ntheorem MonoidHomClass.continuous_of_bound [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) (C : \u211d)\n    (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : Continuous f", "start": [852, 1], "end": [858, 55], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.uniformContinuous_of_bound", "code": "@[to_additive]\ntheorem MonoidHomClass.uniformContinuous_of_bound [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) (C : \u211d)\n    (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : UniformContinuous f", "start": [862, 1], "end": [865, 62], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_bound_of_continuousOn'", "code": "@[to_additive IsCompact.exists_bound_of_continuousOn]\ntheorem IsCompact.exists_bound_of_continuousOn' [TopologicalSpace \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    {f : \u03b1 \u2192 E} (hf : ContinuousOn f s) : \u2203 C, \u2200 x \u2208 s, \u2016f x\u2016 \u2264 C", "start": [869, 1], "end": [873, 38], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.exists_bound_of_continuous", "code": "@[to_additive]\ntheorem HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace \u03b1]\n    {f : \u03b1 \u2192 E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C", "start": [877, 1], "end": [880, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.isometry_iff_norm", "code": "@[to_additive]\ntheorem MonoidHomClass.isometry_iff_norm [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) :\n    Isometry f \u2194 \u2200 x, \u2016f x\u2016 = \u2016x\u2016", "start": [882, 1], "end": [887, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.isometry_of_norm", "code": "alias \u27e8_, MonoidHomClass.isometry_of_norm\u27e9 := MonoidHomClass.isometry_iff_norm", "start": [891, 1], "end": [891, 79], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SeminormedGroup.toNNNorm", "code": "@[to_additive]\ninstance (priority := 100) SeminormedGroup.toNNNorm : NNNorm E :=\n  \u27e8fun a => \u27e8\u2016a\u2016, norm_nonneg' a\u27e9\u27e9", "start": [899, 1], "end": [901, 35], "kind": "commanddeclaration"}, {"full_name": "coe_nnnorm'", "code": "@[to_additive (attr := simp, norm_cast) coe_nnnorm]\ntheorem coe_nnnorm' (a : E) : (\u2016a\u2016\u208a : \u211d) = \u2016a\u2016", "start": [905, 1], "end": [907, 6], "kind": "commanddeclaration"}, {"full_name": "coe_comp_nnnorm'", "code": "@[to_additive (attr := simp) coe_comp_nnnorm]\ntheorem coe_comp_nnnorm' : (toReal : \u211d\u22650 \u2192 \u211d) \u2218 (nnnorm : E \u2192 \u211d\u22650) = norm", "start": [911, 1], "end": [913, 6], "kind": "commanddeclaration"}, {"full_name": "norm_toNNReal'", "code": "@[to_additive norm_toNNReal]\ntheorem norm_toNNReal' : \u2016a\u2016.toNNReal = \u2016a\u2016\u208a", "start": [917, 1], "end": [919, 26], "kind": "commanddeclaration"}, {"full_name": "nndist_eq_nnnorm_div", "code": "@[to_additive]\ntheorem nndist_eq_nnnorm_div (a b : E) : nndist a b = \u2016a / b\u2016\u208a", "start": [923, 1], "end": [925, 36], "kind": "commanddeclaration"}, {"full_name": "nndist_eq_nnnorm", "code": "alias nndist_eq_nnnorm := nndist_eq_nnnorm_sub", "start": [929, 1], "end": [929, 47], "kind": "stdtacticaliasalias"}, {"full_name": "nnnorm_one'", "code": "@[to_additive (attr := simp) nnnorm_zero]\ntheorem nnnorm_one' : \u2016(1 : E)\u2016\u208a = 0", "start": [932, 1], "end": [934, 22], "kind": "commanddeclaration"}, {"full_name": "ne_one_of_nnnorm_ne_zero", "code": "@[to_additive]\ntheorem ne_one_of_nnnorm_ne_zero {a : E} : \u2016a\u2016\u208a \u2260 0 \u2192 a \u2260 1", "start": [938, 1], "end": [942, 22], "kind": "commanddeclaration"}, {"full_name": "nnnorm_mul_le'", "code": "@[to_additive nnnorm_add_le]\ntheorem nnnorm_mul_le' (a b : E) : \u2016a * b\u2016\u208a \u2264 \u2016a\u2016\u208a + \u2016b\u2016\u208a", "start": [946, 1], "end": [948, 42], "kind": "commanddeclaration"}, {"full_name": "nnnorm_inv'", "code": "@[to_additive (attr := simp) nnnorm_neg]\ntheorem nnnorm_inv' (a : E) : \u2016a\u207b\u00b9\u2016\u208a = \u2016a\u2016\u208a", "start": [952, 1], "end": [954, 27], "kind": "commanddeclaration"}, {"full_name": "nndist_mulIndicator", "code": "@[to_additive]\ntheorem nndist_mulIndicator (s t : Set \u03b1) (f : \u03b1 \u2192 E) (x : \u03b1) :\n    nndist (s.mulIndicator f x) (t.mulIndicator f x) = \u2016(s \u2206 t).mulIndicator f x\u2016\u208a", "start": [958, 1], "end": [961, 41], "kind": "commanddeclaration"}, {"full_name": "nnnorm_div_le", "code": "@[to_additive]\ntheorem nnnorm_div_le (a b : E) : \u2016a / b\u2016\u208a \u2264 \u2016a\u2016\u208a + \u2016b\u2016\u208a", "start": [963, 1], "end": [965, 41], "kind": "commanddeclaration"}, {"full_name": "nndist_nnnorm_nnnorm_le'", "code": "@[to_additive nndist_nnnorm_nnnorm_le]\ntheorem nndist_nnnorm_nnnorm_le' (a b : E) : nndist \u2016a\u2016\u208a \u2016b\u2016\u208a \u2264 \u2016a / b\u2016\u208a", "start": [969, 1], "end": [971, 48], "kind": "commanddeclaration"}, {"full_name": "nnnorm_le_nnnorm_add_nnnorm_div", "code": "@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div (a b : E) : \u2016b\u2016\u208a \u2264 \u2016a\u2016\u208a + \u2016a / b\u2016\u208a", "start": [975, 1], "end": [977, 32], "kind": "commanddeclaration"}, {"full_name": "nnnorm_le_nnnorm_add_nnnorm_div'", "code": "@[to_additive]\ntheorem nnnorm_le_nnnorm_add_nnnorm_div' (a b : E) : \u2016a\u2016\u208a \u2264 \u2016b\u2016\u208a + \u2016a / b\u2016\u208a", "start": [981, 1], "end": [983, 33], "kind": "commanddeclaration"}, {"full_name": "nnnorm_le_insert'", "code": "alias nnnorm_le_insert' := nnnorm_le_nnnorm_add_nnnorm_sub'", "start": [987, 1], "end": [987, 60], "kind": "stdtacticaliasalias"}, {"full_name": "nnnorm_le_insert", "code": "alias nnnorm_le_insert := nnnorm_le_nnnorm_add_nnnorm_sub", "start": [990, 1], "end": [990, 58], "kind": "stdtacticaliasalias"}, {"full_name": "nnnorm_le_mul_nnnorm_add", "code": "@[to_additive]\ntheorem nnnorm_le_mul_nnnorm_add (a b : E) : \u2016a\u2016\u208a \u2264 \u2016a * b\u2016\u208a + \u2016b\u2016\u208a", "start": [993, 1], "end": [995, 27], "kind": "commanddeclaration"}, {"full_name": "ofReal_norm_eq_coe_nnnorm'", "code": "@[to_additive ofReal_norm_eq_coe_nnnorm]\ntheorem ofReal_norm_eq_coe_nnnorm' (a : E) : ENNReal.ofReal \u2016a\u2016 = \u2016a\u2016\u208a", "start": [999, 1], "end": [1001, 33], "kind": "commanddeclaration"}, {"full_name": "edist_eq_coe_nnnorm_div", "code": "@[to_additive]\ntheorem edist_eq_coe_nnnorm_div (a b : E) : edist a b = \u2016a / b\u2016\u208a", "start": [1005, 1], "end": [1007, 64], "kind": "commanddeclaration"}, {"full_name": "edist_eq_coe_nnnorm'", "code": "@[to_additive edist_eq_coe_nnnorm]\ntheorem edist_eq_coe_nnnorm' (x : E) : edist x 1 = (\u2016x\u2016\u208a : \u211d\u22650\u221e)", "start": [1011, 1], "end": [1013, 40], "kind": "commanddeclaration"}, {"full_name": "edist_mulIndicator", "code": "@[to_additive]\ntheorem edist_mulIndicator (s t : Set \u03b1) (f : \u03b1 \u2192 E) (x : \u03b1) :\n    edist (s.mulIndicator f x) (t.mulIndicator f x) = \u2016(s \u2206 t).mulIndicator f x\u2016\u208a", "start": [1017, 1], "end": [1020, 41], "kind": "commanddeclaration"}, {"full_name": "mem_emetric_ball_one_iff", "code": "@[to_additive]\ntheorem mem_emetric_ball_one_iff {r : \u211d\u22650\u221e} : a \u2208 EMetric.ball (1 : E) r \u2194 \u2191\u2016a\u2016\u208a < r", "start": [1022, 1], "end": [1024, 46], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.lipschitz_of_bound_nnnorm", "code": "@[to_additive]\ntheorem MonoidHomClass.lipschitz_of_bound_nnnorm [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) (C : \u211d\u22650)\n    (h : \u2200 x, \u2016f x\u2016\u208a \u2264 C * \u2016x\u2016\u208a) : LipschitzWith C f", "start": [1028, 1], "end": [1031, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.antilipschitz_of_bound", "code": "@[to_additive]\ntheorem MonoidHomClass.antilipschitz_of_bound [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) {K : \u211d\u22650}\n    (h : \u2200 x, \u2016x\u2016 \u2264 K * \u2016f x\u2016) : AntilipschitzWith K f", "start": [1035, 1], "end": [1039, 59], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.norm_le_mul'", "code": "@[to_additive LipschitzWith.norm_le_mul]\ntheorem LipschitzWith.norm_le_mul' {f : E \u2192 F} {K : \u211d\u22650} (h : LipschitzWith K f) (hf : f 1 = 1)\n    (x) : \u2016f x\u2016 \u2264 K * \u2016x\u2016", "start": [1043, 1], "end": [1045, 88], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.nnorm_le_mul'", "code": "@[to_additive LipschitzWith.nnorm_le_mul]\ntheorem LipschitzWith.nnorm_le_mul' {f : E \u2192 F} {K : \u211d\u22650} (h : LipschitzWith K f) (hf : f 1 = 1)\n    (x) : \u2016f x\u2016\u208a \u2264 K * \u2016x\u2016\u208a", "start": [1049, 1], "end": [1052, 22], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_norm'", "code": "@[to_additive AntilipschitzWith.le_mul_norm]\ntheorem AntilipschitzWith.le_mul_norm' {f : E \u2192 F} {K : \u211d\u22650} (h : AntilipschitzWith K f)\n    (hf : f 1 = 1) (x) : \u2016x\u2016 \u2264 K * \u2016f x\u2016", "start": [1056, 1], "end": [1059, 58], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_nnnorm'", "code": "@[to_additive AntilipschitzWith.le_mul_nnnorm]\ntheorem AntilipschitzWith.le_mul_nnnorm' {f : E \u2192 F} {K : \u211d\u22650} (h : AntilipschitzWith K f)\n    (hf : f 1 = 1) (x) : \u2016x\u2016\u208a \u2264 K * \u2016f x\u2016\u208a", "start": [1063, 1], "end": [1066, 22], "kind": "commanddeclaration"}, {"full_name": "OneHomClass.bound_of_antilipschitz", "code": "@[to_additive]\ntheorem OneHomClass.bound_of_antilipschitz [OneHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) {K : \u211d\u22650}\n    (h : AntilipschitzWith K f) (x) : \u2016x\u2016 \u2264 K * \u2016f x\u2016", "start": [1070, 1], "end": [1073, 33], "kind": "commanddeclaration"}, {"full_name": "tendsto_iff_norm_div_tendsto_zero", "code": "@[to_additive]\ntheorem tendsto_iff_norm_div_tendsto_zero {f : \u03b1 \u2192 E} {a : Filter \u03b1} {b : E} :\n    Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (fun e => \u2016f e / b\u2016) a (\ud835\udcdd 0)", "start": [1079, 1], "end": [1082, 66], "kind": "commanddeclaration"}, {"full_name": "tendsto_one_iff_norm_tendsto_zero", "code": "@[to_additive]\ntheorem tendsto_one_iff_norm_tendsto_zero {f : \u03b1 \u2192 E} {a : Filter \u03b1} :\n    Tendsto f a (\ud835\udcdd 1) \u2194 Tendsto (\u2016f \u00b7\u2016) a (\ud835\udcdd 0)", "start": [1086, 1], "end": [1089, 68], "kind": "commanddeclaration"}, {"full_name": "comap_norm_nhds_one", "code": "@[to_additive]\ntheorem comap_norm_nhds_one : comap norm (\ud835\udcdd 0) = \ud835\udcdd (1 : E)", "start": [1093, 1], "end": [1095, 60], "kind": "commanddeclaration"}, {"full_name": "squeeze_one_norm'", "code": "@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is eventually bounded by a\nreal function `a` which tends to `0`, then `f` tends to `1`. In this pair of lemmas\n(`squeeze_zero_norm'` and `squeeze_zero_norm`), following a convention of similar lemmas in\n`Topology.MetricSpace.Basic` and `Topology.Algebra.Order`, the `'` version is phrased using\n\\\"eventually\\\" and the non-`'` version is phrased absolutely.\"]\ntheorem squeeze_one_norm' {f : \u03b1 \u2192 E} {a : \u03b1 \u2192 \u211d} {t\u2080 : Filter \u03b1} (h : \u2200\u1da0 n in t\u2080, \u2016f n\u2016 \u2264 a n)\n    (h' : Tendsto a t\u2080 (\ud835\udcdd 0)) : Tendsto f t\u2080 (\ud835\udcdd 1)", "start": [1099, 1], "end": [1112, 71], "kind": "commanddeclaration"}, {"full_name": "squeeze_one_norm", "code": "@[to_additive \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`.\"]\ntheorem squeeze_one_norm {f : \u03b1 \u2192 E} {a : \u03b1 \u2192 \u211d} {t\u2080 : Filter \u03b1} (h : \u2200 n, \u2016f n\u2016 \u2264 a n) :\n    Tendsto a t\u2080 (\ud835\udcdd 0) \u2192 Tendsto f t\u2080 (\ud835\udcdd 1)", "start": [1116, 1], "end": [1122, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_div_self", "code": "@[to_additive]\ntheorem tendsto_norm_div_self (x : E) : Tendsto (fun a => \u2016a / x\u2016) (\ud835\udcdd x) (\ud835\udcdd 0)", "start": [1126, 1], "end": [1129, 79], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm'", "code": "@[to_additive tendsto_norm]\ntheorem tendsto_norm' {x : E} : Tendsto (fun a => \u2016a\u2016) (\ud835\udcdd x) (\ud835\udcdd \u2016x\u2016)", "start": [1133, 1], "end": [1135, 85], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_one", "code": "@[to_additive]\ntheorem tendsto_norm_one : Tendsto (fun a : E => \u2016a\u2016) (\ud835\udcdd 1) (\ud835\udcdd 0)", "start": [1139, 1], "end": [1141, 44], "kind": "commanddeclaration"}, {"full_name": "continuous_norm'", "code": "@[to_additive (attr := continuity) continuous_norm]\ntheorem continuous_norm' : Continuous fun a : E => \u2016a\u2016", "start": [1145, 1], "end": [1147, 83], "kind": "commanddeclaration"}, {"full_name": "continuous_nnnorm'", "code": "@[to_additive (attr := continuity) continuous_nnnorm]\ntheorem continuous_nnnorm' : Continuous fun a : E => \u2016a\u2016\u208a", "start": [1151, 1], "end": [1153, 32], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_one_norm'", "code": "@[to_additive lipschitzWith_one_norm]\ntheorem lipschitzWith_one_norm' : LipschitzWith 1 (norm : E \u2192 \u211d)", "start": [1157, 1], "end": [1159, 68], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_one_nnnorm'", "code": "@[to_additive lipschitzWith_one_nnnorm]\ntheorem lipschitzWith_one_nnnorm' : LipschitzWith 1 (NNNorm.nnnorm : E \u2192 \u211d\u22650)", "start": [1163, 1], "end": [1165, 26], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_norm'", "code": "@[to_additive uniformContinuous_norm]\ntheorem uniformContinuous_norm' : UniformContinuous (norm : E \u2192 \u211d)", "start": [1169, 1], "end": [1171, 44], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_nnnorm'", "code": "@[to_additive uniformContinuous_nnnorm]\ntheorem uniformContinuous_nnnorm' : UniformContinuous fun a : E => \u2016a\u2016\u208a", "start": [1175, 1], "end": [1177, 39], "kind": "commanddeclaration"}, {"full_name": "mem_closure_one_iff_norm", "code": "@[to_additive]\ntheorem mem_closure_one_iff_norm {x : E} : x \u2208 closure ({1} : Set E) \u2194 \u2016x\u2016 = 0", "start": [1181, 1], "end": [1183, 78], "kind": "commanddeclaration"}, {"full_name": "closure_one_eq", "code": "@[to_additive]\ntheorem closure_one_eq : closure ({1} : Set E) = { x | \u2016x\u2016 = 0 }", "start": [1187, 1], "end": [1189, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.op_one_isBoundedUnder_le'", "code": "@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E \u2192 F \u2192 G` with an estimate `\u2016op x y\u2016 \u2264 A * \u2016x\u2016 * \u2016y\u2016` for some constant A instead\nof multiplication so that it can be applied to `(*)`, `flip (*)`, `(\u2022)`, and `flip (\u2022)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le' {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\n    (hf : Tendsto f l (\ud835\udcdd 1)) (hg : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 g)) (op : E \u2192 F \u2192 G)\n    (h_op : \u2203 A, \u2200 x y, \u2016op x y\u2016 \u2264 A * \u2016x\u2016 * \u2016y\u2016) : Tendsto (fun x => op (f x) (g x)) l (\ud835\udcdd 1)", "start": [1193, 1], "end": [1217, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.op_one_isBoundedUnder_le", "code": "@[to_additive \"A helper lemma used to prove that the (scalar or usual) product of a function that\ntends to zero and a bounded function tends to zero. This lemma is formulated for any binary\noperation `op : E \u2192 F \u2192 G` with an estimate `\u2016op x y\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016` instead of multiplication so\nthat it can be applied to `(*)`, `flip (*)`, `(\u2022)`, and `flip (\u2022)`.\"]\ntheorem Filter.Tendsto.op_one_isBoundedUnder_le {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : Filter \u03b1}\n    (hf : Tendsto f l (\ud835\udcdd 1)) (hg : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 g)) (op : E \u2192 F \u2192 G)\n    (h_op : \u2200 x y, \u2016op x y\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016) : Tendsto (fun x => op (f x) (g x)) l (\ud835\udcdd 1)", "start": [1221, 1], "end": [1232, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.norm'", "code": "@[to_additive Filter.Tendsto.norm]\ntheorem Filter.Tendsto.norm' (h : Tendsto f l (\ud835\udcdd a)) : Tendsto (fun x => \u2016f x\u2016) l (\ud835\udcdd \u2016a\u2016)", "start": [1240, 1], "end": [1242, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nnnorm'", "code": "@[to_additive Filter.Tendsto.nnnorm]\ntheorem Filter.Tendsto.nnnorm' (h : Tendsto f l (\ud835\udcdd a)) : Tendsto (fun x => \u2016f x\u2016\u208a) l (\ud835\udcdd \u2016a\u2016\u208a)", "start": [1246, 1], "end": [1248, 49], "kind": "commanddeclaration"}, {"full_name": "Continuous.norm'", "code": "@[to_additive Continuous.norm]\ntheorem Continuous.norm' : Continuous f \u2192 Continuous fun x => \u2016f x\u2016", "start": [1258, 1], "end": [1260, 24], "kind": "commanddeclaration"}, {"full_name": "Continuous.nnnorm'", "code": "@[to_additive Continuous.nnnorm]\ntheorem Continuous.nnnorm' : Continuous f \u2192 Continuous fun x => \u2016f x\u2016\u208a", "start": [1264, 1], "end": [1266, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.norm'", "code": "@[to_additive ContinuousAt.norm]\ntheorem ContinuousAt.norm' {a : \u03b1} (h : ContinuousAt f a) : ContinuousAt (fun x => \u2016f x\u2016) a", "start": [1270, 1], "end": [1272, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.nnnorm'", "code": "@[to_additive ContinuousAt.nnnorm]\ntheorem ContinuousAt.nnnorm' {a : \u03b1} (h : ContinuousAt f a) : ContinuousAt (fun x => \u2016f x\u2016\u208a) a", "start": [1276, 1], "end": [1278, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.norm'", "code": "@[to_additive ContinuousWithinAt.norm]\ntheorem ContinuousWithinAt.norm' {s : Set \u03b1} {a : \u03b1} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => \u2016f x\u2016) s a", "start": [1282, 1], "end": [1285, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.nnnorm'", "code": "@[to_additive ContinuousWithinAt.nnnorm]\ntheorem ContinuousWithinAt.nnnorm' {s : Set \u03b1} {a : \u03b1} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => \u2016f x\u2016\u208a) s a", "start": [1289, 1], "end": [1292, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.norm'", "code": "@[to_additive ContinuousOn.norm]\ntheorem ContinuousOn.norm' {s : Set \u03b1} (h : ContinuousOn f s) : ContinuousOn (fun x => \u2016f x\u2016) s", "start": [1296, 1], "end": [1298, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.nnnorm'", "code": "@[to_additive ContinuousOn.nnnorm]\ntheorem ContinuousOn.nnnorm' {s : Set \u03b1} (h : ContinuousOn f s) :\n    ContinuousOn (fun x => \u2016f x\u2016\u208a) s", "start": [1302, 1], "end": [1304, 69], "kind": "commanddeclaration"}, {"full_name": "eventually_ne_of_tendsto_norm_atTop'", "code": "@[to_additive eventually_ne_of_tendsto_norm_atTop \"If `\u2016y\u2016\u2192\u221e`, then we can assume `y\u2260x` for any\nfixed `x`\"]\ntheorem eventually_ne_of_tendsto_norm_atTop' {l : Filter \u03b1} {f : \u03b1 \u2192 E}\n    (h : Tendsto (fun y => \u2016f y\u2016) l atTop) (x : E) : \u2200\u1da0 y in l, f y \u2260 x", "start": [1310, 1], "end": [1315, 63], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.mem_closure_iff", "code": "@[to_additive]\ntheorem SeminormedCommGroup.mem_closure_iff : a \u2208 closure s \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 b \u2208 s, \u2016a / b\u2016 < \u03b5", "start": [1319, 1], "end": [1321, 53], "kind": "commanddeclaration"}, {"full_name": "norm_le_zero_iff'''", "code": "@[to_additive norm_le_zero_iff']\ntheorem norm_le_zero_iff''' [T0Space E] {a : E} : \u2016a\u2016 \u2264 0 \u2194 a = 1", "start": [1325, 1], "end": [1329, 38], "kind": "commanddeclaration"}, {"full_name": "norm_eq_zero'''", "code": "@[to_additive norm_eq_zero']\ntheorem norm_eq_zero''' [T0Space E] {a : E} : \u2016a\u2016 = 0 \u2194 a = 1", "start": [1333, 1], "end": [1335, 60], "kind": "commanddeclaration"}, {"full_name": "norm_pos_iff'''", "code": "@[to_additive norm_pos_iff']\ntheorem norm_pos_iff''' [T0Space E] {a : E} : 0 < \u2016a\u2016 \u2194 a \u2260 1", "start": [1339, 1], "end": [1341, 37], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.tendstoUniformlyOn_one", "code": "@[to_additive]\ntheorem SeminormedGroup.tendstoUniformlyOn_one {f : \u03b9 \u2192 \u03ba \u2192 G} {s : Set \u03ba} {l : Filter \u03b9} :\n    TendstoUniformlyOn f 1 l s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 i in l, \u2200 x \u2208 s, \u2016f i x\u2016 < \u03b5", "start": [1345, 1], "end": [1348, 64], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one", "code": "@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one {f : \u03b9 \u2192 \u03ba \u2192 G}\n    {l : Filter \u03b9} {l' : Filter \u03ba} :\n    UniformCauchySeqOnFilter f l l' \u2194\n      TendstoUniformlyOnFilter (fun n : \u03b9 \u00d7 \u03b9 => fun z => f n.fst z / f n.snd z) 1 (l \u00d7\u02e2 l) l'", "start": [1352, 1], "end": [1367, 52], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one", "code": "@[to_additive]\ntheorem SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one {f : \u03b9 \u2192 \u03ba \u2192 G} {s : Set \u03ba}\n    {l : Filter \u03b9} :\n    UniformCauchySeqOn f l s \u2194\n      TendstoUniformlyOn (fun n : \u03b9 \u00d7 \u03b9 => fun z => f n.fst z / f n.snd z) 1 (l \u00d7\u02e2 l) s", "start": [1371, 1], "end": [1378, 79], "kind": "commanddeclaration"}, {"full_name": "SeminormedGroup.induced", "code": "@[to_additive (attr := reducible) \"A group homomorphism from an `AddGroup` to a\n`SeminormedAddGroup` induces a `SeminormedAddGroup` structure on the domain.\"]\ndef SeminormedGroup.induced [Group E] [SeminormedGroup F] [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) :\n    SeminormedGroup E :=\n  { PseudoMetricSpace.induced f toPseudoMetricSpace with\n    norm := fun x => \u2016f x\u2016\n    dist_eq := fun x y => by simp only [map_div, \u2190 dist_eq_norm_div]; rfl }", "start": [1389, 1], "end": [1398, 76], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.induced", "code": "@[to_additive (attr := reducible) \"A group homomorphism from an `AddCommGroup` to a\n`SeminormedAddGroup` induces a `SeminormedAddCommGroup` structure on the domain.\"]\ndef SeminormedCommGroup.induced [CommGroup E] [SeminormedGroup F] [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) :\n    SeminormedCommGroup E :=\n  { SeminormedGroup.induced E F f with\n    mul_comm := mul_comm }", "start": [1403, 1], "end": [1410, 27], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.induced", "code": "@[to_additive (attr := reducible) \"An injective group homomorphism from an `AddGroup` to a\n`NormedAddGroup` induces a `NormedAddGroup` structure on the domain.\"]\ndef NormedGroup.induced [Group E] [NormedGroup F] [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5) (h : Injective f) :\n    NormedGroup E :=\n  { SeminormedGroup.induced E F f, MetricSpace.induced f h _ with }", "start": [1415, 1], "end": [1421, 68], "kind": "commanddeclaration"}, {"full_name": "NormedCommGroup.induced", "code": "@[to_additive (attr := reducible) \"An injective group homomorphism from a `CommGroup` to a\n`NormedCommGroup` induces a `NormedCommGroup` structure on the domain.\"]\ndef NormedCommGroup.induced [CommGroup E] [NormedGroup F] [MonoidHomClass \ud835\udcd5 E F] (f : \ud835\udcd5)\n    (h : Injective f) : NormedCommGroup E :=\n  { SeminormedGroup.induced E F f, MetricSpace.induced f h _ with\n    mul_comm := mul_comm }", "start": [1426, 1], "end": [1433, 27], "kind": "commanddeclaration"}, {"full_name": "NormedGroup.to_isometricSMul_left", "code": "@[to_additive]\ninstance NormedGroup.to_isometricSMul_left : IsometricSMul E E :=\n  \u27e8fun a => Isometry.of_dist_eq fun b c => by simp [dist_eq_norm_div]\u27e9", "start": [1443, 1], "end": [1445, 71], "kind": "commanddeclaration"}, {"full_name": "dist_inv", "code": "@[to_additive]\ntheorem dist_inv (x y : E) : dist x\u207b\u00b9 y = dist x y\u207b\u00b9", "start": [1449, 1], "end": [1451, 87], "kind": "commanddeclaration"}, {"full_name": "dist_self_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem dist_self_mul_right (a b : E) : dist a (a * b) = \u2016b\u2016", "start": [1455, 1], "end": [1457, 55], "kind": "commanddeclaration"}, {"full_name": "dist_self_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem dist_self_mul_left (a b : E) : dist (a * b) a = \u2016b\u2016", "start": [1461, 1], "end": [1463, 38], "kind": "commanddeclaration"}, {"full_name": "dist_self_div_right", "code": "@[to_additive (attr := simp 1001)]\ntheorem dist_self_div_right (a b : E) : dist a (a / b) = \u2016b\u2016", "start": [1467, 1], "end": [1470, 54], "kind": "commanddeclaration"}, {"full_name": "dist_self_div_left", "code": "@[to_additive (attr := simp 1001)]\ntheorem dist_self_div_left (a b : E) : dist (a / b) a = \u2016b\u2016", "start": [1474, 1], "end": [1477, 38], "kind": "commanddeclaration"}, {"full_name": "dist_mul_mul_le", "code": "@[to_additive]\ntheorem dist_mul_mul_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) : dist (a\u2081 * a\u2082) (b\u2081 * b\u2082) \u2264 dist a\u2081 b\u2081 + dist a\u2082 b\u2082", "start": [1481, 1], "end": [1483, 95], "kind": "commanddeclaration"}, {"full_name": "dist_mul_mul_le_of_le", "code": "@[to_additive]\ntheorem dist_mul_mul_le_of_le (h\u2081 : dist a\u2081 b\u2081 \u2264 r\u2081) (h\u2082 : dist a\u2082 b\u2082 \u2264 r\u2082) :\n    dist (a\u2081 * a\u2082) (b\u2081 * b\u2082) \u2264 r\u2081 + r\u2082", "start": [1487, 1], "end": [1490, 58], "kind": "commanddeclaration"}, {"full_name": "dist_div_div_le", "code": "@[to_additive]\ntheorem dist_div_div_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) : dist (a\u2081 / a\u2082) (b\u2081 / b\u2082) \u2264 dist a\u2081 b\u2081 + dist a\u2082 b\u2082", "start": [1494, 1], "end": [1496, 82], "kind": "commanddeclaration"}, {"full_name": "dist_div_div_le_of_le", "code": "@[to_additive]\ntheorem dist_div_div_le_of_le (h\u2081 : dist a\u2081 b\u2081 \u2264 r\u2081) (h\u2082 : dist a\u2082 b\u2082 \u2264 r\u2082) :\n    dist (a\u2081 / a\u2082) (b\u2081 / b\u2082) \u2264 r\u2081 + r\u2082", "start": [1500, 1], "end": [1503, 58], "kind": "commanddeclaration"}, {"full_name": "abs_dist_sub_le_dist_mul_mul", "code": "@[to_additive]\ntheorem abs_dist_sub_le_dist_mul_mul (a\u2081 a\u2082 b\u2081 b\u2082 : E) :\n    |dist a\u2081 b\u2081 - dist a\u2082 b\u2082| \u2264 dist (a\u2081 * a\u2082) (b\u2081 * b\u2082)", "start": [1507, 1], "end": [1511, 50], "kind": "commanddeclaration"}, {"full_name": "norm_multiset_sum_le", "code": "theorem norm_multiset_sum_le {E} [SeminormedAddCommGroup E] (m : Multiset E) :\n    \u2016m.sum\u2016 \u2264 (m.map fun x => \u2016x\u2016).sum", "start": [1515, 1], "end": [1517, 53], "kind": "commanddeclaration"}, {"full_name": "norm_multiset_prod_le", "code": "@[to_additive existing]\ntheorem norm_multiset_prod_le (m : Multiset E) : \u2016m.prod\u2016 \u2264 (m.map fun x => \u2016x\u2016).sum", "start": [1520, 1], "end": [1525, 27], "kind": "commanddeclaration"}, {"full_name": "norm_sum_le", "code": "theorem norm_sum_le {\u03b9 E} [SeminormedAddCommGroup E] (s : Finset \u03b9) (f : \u03b9 \u2192 E) :\n    \u2016\u2211 i in s, f i\u2016 \u2264 \u2211 i in s, \u2016f i\u2016", "start": [1530, 1], "end": [1532, 55], "kind": "commanddeclaration"}, {"full_name": "norm_prod_le", "code": "@[to_additive existing]\ntheorem norm_prod_le (s : Finset \u03b9) (f : \u03b9 \u2192 E) : \u2016\u220f i in s, f i\u2016 \u2264 \u2211 i in s, \u2016f i\u2016", "start": [1535, 1], "end": [1540, 27], "kind": "commanddeclaration"}, {"full_name": "norm_prod_le_of_le", "code": "@[to_additive]\ntheorem norm_prod_le_of_le (s : Finset \u03b9) {f : \u03b9 \u2192 E} {n : \u03b9 \u2192 \u211d} (h : \u2200 b \u2208 s, \u2016f b\u2016 \u2264 n b) :\n    \u2016\u220f b in s, f b\u2016 \u2264 \u2211 b in s, n b", "start": [1543, 1], "end": [1546, 50], "kind": "commanddeclaration"}, {"full_name": "dist_prod_prod_le_of_le", "code": "@[to_additive]\ntheorem dist_prod_prod_le_of_le (s : Finset \u03b9) {f a : \u03b9 \u2192 E} {d : \u03b9 \u2192 \u211d}\n    (h : \u2200 b \u2208 s, dist (f b) (a b) \u2264 d b) :\n    dist (\u220f b in s, f b) (\u220f b in s, a b) \u2264 \u2211 b in s, d b", "start": [1550, 1], "end": [1555, 31], "kind": "commanddeclaration"}, {"full_name": "dist_prod_prod_le", "code": "@[to_additive]\ntheorem dist_prod_prod_le (s : Finset \u03b9) (f a : \u03b9 \u2192 E) :\n    dist (\u220f b in s, f b) (\u220f b in s, a b) \u2264 \u2211 b in s, dist (f b) (a b)", "start": [1559, 1], "end": [1562, 46], "kind": "commanddeclaration"}, {"full_name": "mul_mem_ball_iff_norm", "code": "@[to_additive]\ntheorem mul_mem_ball_iff_norm : a * b \u2208 ball a r \u2194 \u2016b\u2016 < r", "start": [1566, 1], "end": [1568, 46], "kind": "commanddeclaration"}, {"full_name": "mul_mem_closedBall_iff_norm", "code": "@[to_additive]\ntheorem mul_mem_closedBall_iff_norm : a * b \u2208 closedBall a r \u2194 \u2016b\u2016 \u2264 r", "start": [1572, 1], "end": [1574, 52], "kind": "commanddeclaration"}, {"full_name": "preimage_mul_ball", "code": "@[to_additive (attr := simp 1001)]\ntheorem preimage_mul_ball (a b : E) (r : \u211d) : (\u00b7 * \u00b7) b \u207b\u00b9' ball a r = ball (a / b) r", "start": [1578, 1], "end": [1582, 89], "kind": "commanddeclaration"}, {"full_name": "preimage_mul_closedBall", "code": "@[to_additive (attr := simp 1001)]\ntheorem preimage_mul_closedBall (a b : E) (r : \u211d) :\n    (\u00b7 * \u00b7) b \u207b\u00b9' closedBall a r = closedBall (a / b) r", "start": [1586, 1], "end": [1591, 95], "kind": "commanddeclaration"}, {"full_name": "preimage_mul_sphere", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_sphere (a b : E) (r : \u211d) : (\u00b7 * \u00b7) b \u207b\u00b9' sphere a r = sphere (a / b) r", "start": [1595, 1], "end": [1598, 83], "kind": "commanddeclaration"}, {"full_name": "norm_pow_le_mul_norm", "code": "@[to_additive norm_nsmul_le]\ntheorem norm_pow_le_mul_norm (n : \u2115) (a : E) : \u2016a ^ n\u2016 \u2264 n * \u2016a\u2016", "start": [1602, 1], "end": [1605, 92], "kind": "commanddeclaration"}, {"full_name": "nnnorm_pow_le_mul_norm", "code": "@[to_additive nnnorm_nsmul_le]\ntheorem nnnorm_pow_le_mul_norm (n : \u2115) (a : E) : \u2016a ^ n\u2016\u208a \u2264 n * \u2016a\u2016\u208a", "start": [1609, 1], "end": [1612, 29], "kind": "commanddeclaration"}, {"full_name": "pow_mem_closedBall", "code": "@[to_additive]\ntheorem pow_mem_closedBall {n : \u2115} (h : a \u2208 closedBall b r) :\n    a ^ n \u2208 closedBall (b ^ n) (n \u2022 r)", "start": [1616, 1], "end": [1621, 76], "kind": "commanddeclaration"}, {"full_name": "pow_mem_ball", "code": "@[to_additive]\ntheorem pow_mem_ball {n : \u2115} (hn : 0 < n) (h : a \u2208 ball b r) : a ^ n \u2208 ball (b ^ n) (n \u2022 r)", "start": [1625, 1], "end": [1632, 12], "kind": "commanddeclaration"}, {"full_name": "mul_mem_closedBall_mul_iff", "code": "@[to_additive] theorem mul_mem_closedBall_mul_iff {c : E} : a * c \u2208 closedBall (b * c) r \u2194 a \u2208 closedBall b r", "start": [1636, 1], "end": [1638, 73], "kind": "commanddeclaration"}, {"full_name": "mul_mem_ball_mul_iff", "code": "@[to_additive] theorem mul_mem_ball_mul_iff {c : E} : a * c \u2208 ball (b * c) r \u2194 a \u2208 ball b r", "start": [1642, 1], "end": [1644, 67], "kind": "commanddeclaration"}, {"full_name": "smul_closedBall''", "code": "@[to_additive]\ntheorem smul_closedBall'' : a \u2022 closedBall b r = closedBall (a \u2022 b) r", "start": [1648, 1], "end": [1652, 38], "kind": "commanddeclaration"}, {"full_name": "smul_ball''", "code": "@[to_additive]\ntheorem smul_ball'' : a \u2022 ball b r = ball (a \u2022 b) r", "start": [1657, 1], "end": [1661, 40], "kind": "commanddeclaration"}, {"full_name": "controlled_prod_of_mem_closure", "code": "@[to_additive]\ntheorem controlled_prod_of_mem_closure {s : Subgroup E} (hg : a \u2208 closure (s : Set E)) {b : \u2115 \u2192 \u211d}\n    (b_pos : \u2200 n, 0 < b n) :\n    \u2203 v : \u2115 \u2192 E,\n      Tendsto (fun n => \u220f i in range (n + 1), v i) atTop (\ud835\udcdd a) \u2227\n        (\u2200 n, v n \u2208 s) \u2227 \u2016v 0 / a\u2016 < b 0 \u2227 \u2200 n, 0 < n \u2192 \u2016v n\u2016 < b n", "start": [1667, 1], "end": [1697, 13], "kind": "commanddeclaration"}, {"full_name": "controlled_prod_of_mem_closure_range", "code": "@[to_additive]\ntheorem controlled_prod_of_mem_closure_range {j : E \u2192* F} {b : F}\n    (hb : b \u2208 closure (j.range : Set F)) {f : \u2115 \u2192 \u211d} (b_pos : \u2200 n, 0 < f n) :\n    \u2203 a : \u2115 \u2192 E,\n      Tendsto (fun n => \u220f i in range (n + 1), j (a i)) atTop (\ud835\udcdd b) \u2227\n        \u2016j (a 0) / b\u2016 < f 0 \u2227 \u2200 n, 0 < n \u2192 \u2016j (a n)\u2016 < f n", "start": [1701, 1], "end": [1711, 51], "kind": "commanddeclaration"}, {"full_name": "nndist_mul_mul_le", "code": "@[to_additive]\ntheorem nndist_mul_mul_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) :\n    nndist (a\u2081 * a\u2082) (b\u2081 * b\u2082) \u2264 nndist a\u2081 b\u2081 + nndist a\u2082 b\u2082", "start": [1715, 1], "end": [1718, 53], "kind": "commanddeclaration"}, {"full_name": "edist_mul_mul_le", "code": "@[to_additive]\ntheorem edist_mul_mul_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) :\n    edist (a\u2081 * a\u2082) (b\u2081 * b\u2082) \u2264 edist a\u2081 b\u2081 + edist a\u2082 b\u2082", "start": [1722, 1], "end": [1727, 26], "kind": "commanddeclaration"}, {"full_name": "nnnorm_multiset_prod_le", "code": "@[to_additive]\ntheorem nnnorm_multiset_prod_le (m : Multiset E) : \u2016m.prod\u2016\u208a \u2264 (m.map fun x => \u2016x\u2016\u208a).sum", "start": [1731, 1], "end": [1736, 34], "kind": "commanddeclaration"}, {"full_name": "nnnorm_prod_le", "code": "@[to_additive]\ntheorem nnnorm_prod_le (s : Finset \u03b9) (f : \u03b9 \u2192 E) : \u2016\u220f a in s, f a\u2016\u208a \u2264 \u2211 a in s, \u2016f a\u2016\u208a", "start": [1740, 1], "end": [1744, 27], "kind": "commanddeclaration"}, {"full_name": "nnnorm_prod_le_of_le", "code": "@[to_additive]\ntheorem nnnorm_prod_le_of_le (s : Finset \u03b9) {f : \u03b9 \u2192 E} {n : \u03b9 \u2192 \u211d\u22650} (h : \u2200 b \u2208 s, \u2016f b\u2016\u208a \u2264 n b) :\n    \u2016\u220f b in s, f b\u2016\u208a \u2264 \u2211 b in s, n b", "start": [1748, 1], "end": [1751, 56], "kind": "commanddeclaration"}, {"full_name": "Real.norm", "code": "instance norm : Norm \u211d where\n  norm r := |r|", "start": [1757, 1], "end": [1758, 16], "kind": "commanddeclaration"}, {"full_name": "Real.norm_eq_abs", "code": "@[simp]\ntheorem norm_eq_abs (r : \u211d) : \u2016r\u2016 = |r|", "start": [1760, 1], "end": [1762, 6], "kind": "commanddeclaration"}, {"full_name": "Real.normedAddCommGroup", "code": "instance normedAddCommGroup : NormedAddCommGroup \u211d :=\n  \u27e8fun _r _y => rfl\u27e9", "start": [1765, 1], "end": [1766, 21], "kind": "commanddeclaration"}, {"full_name": "Real.norm_of_nonneg", "code": "theorem norm_of_nonneg (hr : 0 \u2264 r) : \u2016r\u2016 = r", "start": [1768, 1], "end": [1769, 19], "kind": "commanddeclaration"}, {"full_name": "Real.norm_of_nonpos", "code": "theorem norm_of_nonpos (hr : r \u2264 0) : \u2016r\u2016 = -r", "start": [1772, 1], "end": [1773, 19], "kind": "commanddeclaration"}, {"full_name": "Real.le_norm_self", "code": "theorem le_norm_self (r : \u211d) : r \u2264 \u2016r\u2016", "start": [1776, 1], "end": [1777, 16], "kind": "commanddeclaration"}, {"full_name": "Real.norm_coe_nat", "code": "theorem norm_coe_nat (n : \u2115) : \u2016(n : \u211d)\u2016 = n", "start": [1781, 1], "end": [1782, 30], "kind": "commanddeclaration"}, {"full_name": "Real.nnnorm_coe_nat", "code": "@[simp]\ntheorem nnnorm_coe_nat (n : \u2115) : \u2016(n : \u211d)\u2016\u208a = n", "start": [1785, 1], "end": [1787, 30], "kind": "commanddeclaration"}, {"full_name": "Real.norm_two", "code": "theorem norm_two : \u2016(2 : \u211d)\u2016 = 2", "start": [1791, 1], "end": [1792, 25], "kind": "commanddeclaration"}, {"full_name": "Real.nnnorm_two", "code": "@[simp]\ntheorem nnnorm_two : \u2016(2 : \u211d)\u2016\u208a = 2", "start": [1795, 1], "end": [1797, 23], "kind": "commanddeclaration"}, {"full_name": "Real.nnnorm_of_nonneg", "code": "theorem nnnorm_of_nonneg (hr : 0 \u2264 r) : \u2016r\u2016\u208a = \u27e8r, hr\u27e9", "start": [1800, 1], "end": [1801, 33], "kind": "commanddeclaration"}, {"full_name": "Real.nnnorm_abs", "code": "@[simp]\ntheorem nnnorm_abs (r : \u211d) : \u2016|r|\u2016\u208a = \u2016r\u2016\u208a", "start": [1804, 1], "end": [1805, 63], "kind": "commanddeclaration"}, {"full_name": "Real.ennnorm_eq_ofReal", "code": "theorem ennnorm_eq_ofReal (hr : 0 \u2264 r) : (\u2016r\u2016\u208a : \u211d\u22650\u221e) = ENNReal.ofReal r", "start": [1808, 1], "end": [1809, 54], "kind": "commanddeclaration"}, {"full_name": "Real.ennnorm_eq_ofReal_abs", "code": "theorem ennnorm_eq_ofReal_abs (r : \u211d) : (\u2016r\u2016\u208a : \u211d\u22650\u221e) = ENNReal.ofReal |r|", "start": [1812, 1], "end": [1813, 66], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_eq_nnnorm_of_nonneg", "code": "theorem toNNReal_eq_nnnorm_of_nonneg (hr : 0 \u2264 r) : r.toNNReal = \u2016r\u2016\u208a", "start": [1816, 1], "end": [1819, 66], "kind": "commanddeclaration"}, {"full_name": "Real.ofReal_le_ennnorm", "code": "theorem ofReal_le_ennnorm (r : \u211d) : ENNReal.ofReal r \u2264 \u2016r\u2016\u208a", "start": [1823, 1], "end": [1827, 17], "kind": "commanddeclaration"}, {"full_name": "Int.normedAddCommGroup", "code": "instance normedAddCommGroup : NormedAddCommGroup \u2124 where\n  norm n := \u2016(n : \u211d)\u2016\n  dist_eq m n := by simp only [Int.dist_eq, norm, Int.cast_sub]", "start": [1835, 1], "end": [1837, 64], "kind": "commanddeclaration"}, {"full_name": "Int.norm_cast_real", "code": "@[norm_cast]\ntheorem norm_cast_real (m : \u2124) : \u2016(m : \u211d)\u2016 = \u2016m\u2016", "start": [1839, 1], "end": [1841, 6], "kind": "commanddeclaration"}, {"full_name": "Int.norm_eq_abs", "code": "theorem norm_eq_abs (n : \u2124) : \u2016n\u2016 = |n|", "start": [1844, 1], "end": [1845, 58], "kind": "commanddeclaration"}, {"full_name": "Int.norm_coe_nat", "code": "@[simp]\ntheorem norm_coe_nat (n : \u2115) : \u2016(n : \u2124)\u2016 = n", "start": [1849, 1], "end": [1850, 74], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_natAbs", "code": "theorem _root_.NNReal.coe_natAbs (n : \u2124) : (n.natAbs : \u211d\u22650) = \u2016n\u2016\u208a", "start": [1853, 1], "end": [1858, 38], "kind": "commanddeclaration"}, {"full_name": "Int.abs_le_floor_nnreal_iff", "code": "theorem abs_le_floor_nnreal_iff (z : \u2124) (c : \u211d\u22650) : |z| \u2264 \u230ac\u230b\u208a \u2194 \u2016z\u2016\u208a \u2264 c", "start": [1861, 1], "end": [1862, 90], "kind": "commanddeclaration"}, {"full_name": "Rat.normedAddCommGroup", "code": "instance normedAddCommGroup : NormedAddCommGroup \u211a where\n  norm r := \u2016(r : \u211d)\u2016\n  dist_eq r\u2081 r\u2082 := by simp only [Rat.dist_eq, norm, Rat.cast_sub]", "start": [1869, 1], "end": [1871, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.norm_cast_real", "code": "@[norm_cast, simp 1001]\ntheorem norm_cast_real (r : \u211a) : \u2016(r : \u211d)\u2016 = \u2016r\u2016", "start": [1873, 1], "end": [1876, 6], "kind": "commanddeclaration"}, {"full_name": "Int.norm_cast_rat", "code": "@[norm_cast, simp]\ntheorem _root_.Int.norm_cast_rat (m : \u2124) : \u2016(m : \u211a)\u2016 = \u2016m\u2016", "start": [1879, 1], "end": [1881, 59], "kind": "commanddeclaration"}, {"full_name": "norm_zpow_le_mul_norm", "code": "@[to_additive norm_zsmul_le]\ntheorem norm_zpow_le_mul_norm (n : \u2124) (a : \u03b1) : \u2016a ^ n\u2016 \u2264 \u2016n\u2016 * \u2016a\u2016", "start": [1892, 1], "end": [1894, 86], "kind": "commanddeclaration"}, {"full_name": "nnnorm_zpow_le_mul_norm", "code": "@[to_additive nnnorm_zsmul_le]\ntheorem nnnorm_zpow_le_mul_norm (n : \u2124) (a : \u03b1) : \u2016a ^ n\u2016\u208a \u2264 \u2016n\u2016\u208a * \u2016a\u2016\u208a", "start": [1898, 1], "end": [1900, 83], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.inv", "code": "@[to_additive]\ntheorem inv (hf : LipschitzWith K f) : LipschitzWith K fun x => (f x)\u207b\u00b9", "start": [1910, 1], "end": [1912, 41], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mul'", "code": "@[to_additive add]\ntheorem mul' (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (Kf + Kg) fun x => f x * g x", "start": [1916, 1], "end": [1923, 54], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.div", "code": "@[to_additive]\ntheorem div (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (Kf + Kg) fun x => f x / g x", "start": [1927, 1], "end": [1930, 51], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.mul_lipschitzWith", "code": "@[to_additive]\ntheorem mul_lipschitzWith (hf : AntilipschitzWith Kf f) (hg : LipschitzWith Kg g) (hK : Kg < Kf\u207b\u00b9) :\n    AntilipschitzWith (Kf\u207b\u00b9 - Kg)\u207b\u00b9 fun x => f x * g x", "start": [1940, 1], "end": [1952, 77], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.mul_div_lipschitzWith", "code": "@[to_additive]\ntheorem mul_div_lipschitzWith (hf : AntilipschitzWith Kf f) (hg : LipschitzWith Kg (g / f))\n    (hK : Kg < Kf\u207b\u00b9) : AntilipschitzWith (Kf\u207b\u00b9 - Kg)\u207b\u00b9 g", "start": [1956, 1], "end": [1959, 84], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_norm_div", "code": "@[to_additive le_mul_norm_sub]\ntheorem le_mul_norm_div {f : E \u2192 F} (hf : AntilipschitzWith K f) (x y : E) :\n    \u2016x / y\u2016 \u2264 K * \u2016f x / f y\u2016", "start": [1963, 1], "end": [1965, 82], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.to_lipschitzMul", "code": "@[to_additive]\ninstance (priority := 100) SeminormedCommGroup.to_lipschitzMul : LipschitzMul E :=\n  \u27e8\u27e81 + 1, LipschitzWith.prod_fst.mul' LipschitzWith.prod_snd\u27e9\u27e9", "start": [1972, 1], "end": [1974, 64], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.to_uniformGroup", "code": "@[to_additive \"A seminormed group is a uniform additive group, i.e., addition and subtraction are\nuniformly continuous.\"]\ninstance (priority := 100) SeminormedCommGroup.to_uniformGroup : UniformGroup E :=\n  \u27e8(LipschitzWith.prod_fst.div LipschitzWith.prod_snd).uniformContinuous\u27e9", "start": [1979, 1], "end": [1984, 74], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommGroup.toTopologicalGroup", "code": "@[to_additive]\ninstance (priority := 100) SeminormedCommGroup.toTopologicalGroup : TopologicalGroup E :=\n  inferInstance", "start": [1990, 1], "end": [1992, 16], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_prod_of_eventually_eq", "code": "@[to_additive]\ntheorem cauchySeq_prod_of_eventually_eq {u v : \u2115 \u2192 E} {N : \u2115} (huv : \u2200 n \u2265 N, u n = v n)\n    (hv : CauchySeq fun n => \u220f k in range (n + 1), v k) :\n    CauchySeq fun n => \u220f k in range (n + 1), u k", "start": [1996, 1], "end": [2008, 29], "kind": "commanddeclaration"}, {"full_name": "norm_eq_zero''", "code": "@[to_additive (attr := simp) norm_eq_zero]\ntheorem norm_eq_zero'' : \u2016a\u2016 = 0 \u2194 a = 1", "start": [2018, 1], "end": [2020, 18], "kind": "commanddeclaration"}, {"full_name": "norm_ne_zero_iff'", "code": "@[to_additive norm_ne_zero_iff]\ntheorem norm_ne_zero_iff' : \u2016a\u2016 \u2260 0 \u2194 a \u2260 1", "start": [2024, 1], "end": [2026, 21], "kind": "commanddeclaration"}, {"full_name": "norm_pos_iff''", "code": "@[to_additive (attr := simp) norm_pos_iff]\ntheorem norm_pos_iff'' : 0 < \u2016a\u2016 \u2194 a \u2260 1", "start": [2030, 1], "end": [2032, 18], "kind": "commanddeclaration"}, {"full_name": "norm_le_zero_iff''", "code": "@[to_additive (attr := simp) norm_le_zero_iff]\ntheorem norm_le_zero_iff'' : \u2016a\u2016 \u2264 0 \u2194 a = 1", "start": [2036, 1], "end": [2038, 22], "kind": "commanddeclaration"}, {"full_name": "norm_div_eq_zero_iff", "code": "@[to_additive]\ntheorem norm_div_eq_zero_iff : \u2016a / b\u2016 = 0 \u2194 a = b", "start": [2042, 1], "end": [2043, 89], "kind": "commanddeclaration"}, {"full_name": "norm_div_pos_iff", "code": "@[to_additive]\ntheorem norm_div_pos_iff : 0 < \u2016a / b\u2016 \u2194 a \u2260 b", "start": [2047, 1], "end": [2050, 33], "kind": "commanddeclaration"}, {"full_name": "eq_of_norm_div_le_zero", "code": "@[to_additive eq_of_norm_sub_le_zero]\ntheorem eq_of_norm_div_le_zero (h : \u2016a / b\u2016 \u2264 0) : a = b", "start": [2054, 1], "end": [2056, 43], "kind": "commanddeclaration"}, {"full_name": "eq_of_norm_div_eq_zero", "code": "alias \u27e8eq_of_norm_div_eq_zero, _\u27e9 := norm_div_eq_zero_iff", "start": [2060, 1], "end": [2060, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "nnnorm_eq_zero'", "code": "@[to_additive (attr := simp) nnnorm_eq_zero]\ntheorem nnnorm_eq_zero' : \u2016a\u2016\u208a = 0 \u2194 a = 1", "start": [2065, 1], "end": [2067, 57], "kind": "commanddeclaration"}, {"full_name": "nnnorm_ne_zero_iff'", "code": "@[to_additive nnnorm_ne_zero_iff]\ntheorem nnnorm_ne_zero_iff' : \u2016a\u2016\u208a \u2260 0 \u2194 a \u2260 1", "start": [2071, 1], "end": [2073, 22], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_div_self_punctured_nhds", "code": "@[to_additive]\ntheorem tendsto_norm_div_self_punctured_nhds (a : E) :\n    Tendsto (fun x => \u2016x / a\u2016) (\ud835\udcdd[\u2260] a) (\ud835\udcdd[>] 0)", "start": [2077, 1], "end": [2081, 83], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_nhdsWithin_one", "code": "@[to_additive]\ntheorem tendsto_norm_nhdsWithin_one : Tendsto (norm : E \u2192 \u211d) (\ud835\udcdd[\u2260] 1) (\ud835\udcdd[>] 0)", "start": [2085, 1], "end": [2087, 83], "kind": "commanddeclaration"}, {"full_name": "normGroupNorm", "code": "@[to_additive \"The norm of a normed group as an additive group norm.\"]\ndef normGroupNorm : GroupNorm E :=\n  { normGroupSeminorm _ with eq_one_of_map_eq_zero' := fun _ => norm_eq_zero''.1 }", "start": [2093, 1], "end": [2096, 83], "kind": "commanddeclaration"}, {"full_name": "coe_normGroupNorm", "code": "@[simp]\ntheorem coe_normGroupNorm : \u21d1(normGroupNorm E) = norm", "start": [2100, 1], "end": [2102, 6], "kind": "commanddeclaration"}, {"full_name": "hasCompactSupport_norm_iff", "code": "theorem hasCompactSupport_norm_iff : (HasCompactSupport fun x => \u2016f x\u2016) \u2194 HasCompactSupport f", "start": [2114, 1], "end": [2115, 43], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.norm", "code": "alias \u27e8_, HasCompactSupport.norm\u27e9 := hasCompactSupport_norm_iff", "start": [2118, 1], "end": [2118, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Continuous.bounded_above_of_compact_support", "code": "theorem Continuous.bounded_above_of_compact_support (hf : Continuous f) (h : HasCompactSupport f) :\n    \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C", "start": [2121, 1], "end": [2123, 80], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.exists_pos_le_norm", "code": "@[to_additive]\ntheorem HasCompactMulSupport.exists_pos_le_norm [One E] (hf : HasCompactMulSupport f) :\n    \u2203 R : \u211d, 0 < R \u2227 \u2200 x : \u03b1, R \u2264 \u2016x\u2016 \u2192 f x = 1", "start": [2132, 1], "end": [2141, 43], "kind": "commanddeclaration"}, {"full_name": "ULift.norm", "code": "instance norm : Norm (ULift E) :=\n  \u27e8fun x => \u2016x.down\u2016\u27e9", "start": [2156, 1], "end": [2157, 22], "kind": "commanddeclaration"}, {"full_name": "ULift.norm_def", "code": "theorem norm_def (x : ULift E) : \u2016x\u2016 = \u2016x.down\u2016", "start": [2159, 1], "end": [2160, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.norm_up", "code": "@[simp]\ntheorem norm_up (x : E) : \u2016ULift.up x\u2016 = \u2016x\u2016", "start": [2163, 1], "end": [2165, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.norm_down", "code": "@[simp]\ntheorem norm_down (x : ULift E) : \u2016x.down\u2016 = \u2016x\u2016", "start": [2168, 1], "end": [2170, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.nnnorm", "code": "instance nnnorm : NNNorm (ULift E) :=\n  \u27e8fun x => \u2016x.down\u2016\u208a\u27e9", "start": [2179, 1], "end": [2180, 23], "kind": "commanddeclaration"}, {"full_name": "ULift.nnnorm_def", "code": "theorem nnnorm_def (x : ULift E) : \u2016x\u2016\u208a = \u2016x.down\u2016\u208a", "start": [2182, 1], "end": [2183, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.nnnorm_up", "code": "@[simp]\ntheorem nnnorm_up (x : E) : \u2016ULift.up x\u2016\u208a = \u2016x\u2016\u208a", "start": [2186, 1], "end": [2188, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.nnnorm_down", "code": "@[simp]\ntheorem nnnorm_down (x : ULift E) : \u2016x.down\u2016\u208a = \u2016x\u2016\u208a", "start": [2191, 1], "end": [2193, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.seminormedGroup", "code": "@[to_additive]\ninstance seminormedGroup [SeminormedGroup E] : SeminormedGroup (ULift E) :=\n  SeminormedGroup.induced _ _\n  { toFun := ULift.down,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl : ULift E \u2192* E }", "start": [2198, 1], "end": [2203, 48], "kind": "commanddeclaration"}, {"full_name": "ULift.seminormedCommGroup", "code": "@[to_additive]\ninstance seminormedCommGroup [SeminormedCommGroup E] : SeminormedCommGroup (ULift E) :=\n  SeminormedCommGroup.induced _ _\n  { toFun := ULift.down,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl : ULift E \u2192* E }", "start": [2207, 1], "end": [2212, 48], "kind": "commanddeclaration"}, {"full_name": "ULift.normedGroup", "code": "@[to_additive]\ninstance normedGroup [NormedGroup E] : NormedGroup (ULift E) :=\n  NormedGroup.induced _ _\n  { toFun := ULift.down,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl : ULift E \u2192* E }\n  down_injective", "start": [2216, 1], "end": [2222, 17], "kind": "commanddeclaration"}, {"full_name": "ULift.normedCommGroup", "code": "@[to_additive]\ninstance normedCommGroup [NormedCommGroup E] : NormedCommGroup (ULift E) :=\n  NormedCommGroup.induced _ _\n  { toFun := ULift.down,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl : ULift E \u2192* E }\n  down_injective", "start": [2226, 1], "end": [2232, 17], "kind": "commanddeclaration"}, {"full_name": "Additive.toNorm", "code": "instance Additive.toNorm : Norm (Additive E) :=\n  \u2039Norm E\u203a", "start": [2249, 1], "end": [2250, 11], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toNorm", "code": "instance Multiplicative.toNorm : Norm (Multiplicative E) :=\n  \u2039Norm E\u203a", "start": [2252, 1], "end": [2253, 11], "kind": "commanddeclaration"}, {"full_name": "norm_toMul", "code": "@[simp]\ntheorem norm_toMul (x) : \u2016(toMul x : E)\u2016 = \u2016x\u2016", "start": [2255, 1], "end": [2257, 6], "kind": "commanddeclaration"}, {"full_name": "norm_ofMul", "code": "@[simp]\ntheorem norm_ofMul (x : E) : \u2016ofMul x\u2016 = \u2016x\u2016", "start": [2260, 1], "end": [2262, 6], "kind": "commanddeclaration"}, {"full_name": "norm_toAdd", "code": "@[simp]\ntheorem norm_toAdd (x) : \u2016(toAdd x : E)\u2016 = \u2016x\u2016", "start": [2265, 1], "end": [2267, 6], "kind": "commanddeclaration"}, {"full_name": "norm_ofAdd", "code": "@[simp]\ntheorem norm_ofAdd (x : E) : \u2016ofAdd x\u2016 = \u2016x\u2016", "start": [2270, 1], "end": [2272, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.toNNNorm", "code": "instance Additive.toNNNorm : NNNorm (Additive E) :=\n  \u2039NNNorm E\u203a", "start": [2281, 1], "end": [2282, 13], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toNNNorm", "code": "instance Multiplicative.toNNNorm : NNNorm (Multiplicative E) :=\n  \u2039NNNorm E\u203a", "start": [2284, 1], "end": [2285, 13], "kind": "commanddeclaration"}, {"full_name": "nnnorm_toMul", "code": "@[simp]\ntheorem nnnorm_toMul (x) : \u2016(toMul x : E)\u2016\u208a = \u2016x\u2016\u208a", "start": [2287, 1], "end": [2289, 6], "kind": "commanddeclaration"}, {"full_name": "nnnorm_ofMul", "code": "@[simp]\ntheorem nnnorm_ofMul (x : E) : \u2016ofMul x\u2016\u208a = \u2016x\u2016\u208a", "start": [2292, 1], "end": [2294, 6], "kind": "commanddeclaration"}, {"full_name": "nnnorm_toAdd", "code": "@[simp]\ntheorem nnnorm_toAdd (x) : \u2016(toAdd x : E)\u2016\u208a = \u2016x\u2016\u208a", "start": [2297, 1], "end": [2299, 6], "kind": "commanddeclaration"}, {"full_name": "nnnorm_ofAdd", "code": "@[simp]\ntheorem nnnorm_ofAdd (x : E) : \u2016ofAdd x\u2016\u208a = \u2016x\u2016\u208a", "start": [2302, 1], "end": [2304, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.seminormedAddGroup", "code": "instance Additive.seminormedAddGroup [SeminormedGroup E] : SeminormedAddGroup (Additive E) where\n  dist_eq := fun x y => dist_eq_norm_div (toMul x) (toMul y)", "start": [2309, 1], "end": [2310, 61], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.seminormedGroup", "code": "instance Multiplicative.seminormedGroup [SeminormedAddGroup E] :\n    SeminormedGroup (Multiplicative E) where\n  dist_eq := fun x y => dist_eq_norm_sub (toMul x) (toMul y)", "start": [2313, 1], "end": [2315, 61], "kind": "commanddeclaration"}, {"full_name": "Additive.seminormedCommGroup", "code": "instance Additive.seminormedCommGroup [SeminormedCommGroup E] :\n    SeminormedAddCommGroup (Additive E) :=\n  { Additive.seminormedAddGroup with\n    add_comm := add_comm }", "start": [2317, 1], "end": [2320, 27], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.seminormedAddCommGroup", "code": "instance Multiplicative.seminormedAddCommGroup [SeminormedAddCommGroup E] :\n    SeminormedCommGroup (Multiplicative E) :=\n  { Multiplicative.seminormedGroup with\n    mul_comm := mul_comm }", "start": [2322, 1], "end": [2325, 27], "kind": "commanddeclaration"}, {"full_name": "Additive.normedAddGroup", "code": "instance Additive.normedAddGroup [NormedGroup E] : NormedAddGroup (Additive E) :=\n  { Additive.seminormedAddGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2327, 1], "end": [2329, 47], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.normedGroup", "code": "instance Multiplicative.normedGroup [NormedAddGroup E] : NormedGroup (Multiplicative E) :=\n  { Multiplicative.seminormedGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2331, 1], "end": [2333, 47], "kind": "commanddeclaration"}, {"full_name": "Additive.normedAddCommGroup", "code": "instance Additive.normedAddCommGroup [NormedCommGroup E] : NormedAddCommGroup (Additive E) :=\n  { Additive.seminormedAddGroup with\n    add_comm := add_comm\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2335, 1], "end": [2338, 47], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.normedCommGroup", "code": "instance Multiplicative.normedCommGroup [NormedAddCommGroup E] :\n    NormedCommGroup (Multiplicative E) :=\n  { Multiplicative.seminormedGroup with\n    mul_comm := mul_comm\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2340, 1], "end": [2344, 47], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toNorm", "code": "instance OrderDual.toNorm : Norm E\u1d52\u1d48 :=\n  \u2039Norm E\u203a", "start": [2359, 1], "end": [2360, 11], "kind": "commanddeclaration"}, {"full_name": "norm_toDual", "code": "@[simp]\ntheorem norm_toDual (x : E) : \u2016toDual x\u2016 = \u2016x\u2016", "start": [2362, 1], "end": [2364, 6], "kind": "commanddeclaration"}, {"full_name": "norm_ofDual", "code": "@[simp]\ntheorem norm_ofDual (x : E\u1d52\u1d48) : \u2016ofDual x\u2016 = \u2016x\u2016", "start": [2367, 1], "end": [2369, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toNNNorm", "code": "instance OrderDual.toNNNorm : NNNorm E\u1d52\u1d48 :=\n  \u2039NNNorm E\u203a", "start": [2378, 1], "end": [2379, 13], "kind": "commanddeclaration"}, {"full_name": "nnnorm_toDual", "code": "@[simp]\ntheorem nnnorm_toDual (x : E) : \u2016toDual x\u2016\u208a = \u2016x\u2016\u208a", "start": [2381, 1], "end": [2383, 6], "kind": "commanddeclaration"}, {"full_name": "nnnorm_ofDual", "code": "@[simp]\ntheorem nnnorm_ofDual (x : E\u1d52\u1d48) : \u2016ofDual x\u2016\u208a = \u2016x\u2016\u208a", "start": [2386, 1], "end": [2388, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.seminormedGroup", "code": "@[to_additive]\ninstance (priority := 100) seminormedGroup [SeminormedGroup E] : SeminormedGroup E\u1d52\u1d48 :=\n  \u2039SeminormedGroup E\u203a", "start": [2396, 1], "end": [2398, 22], "kind": "commanddeclaration"}, {"full_name": "OrderDual.seminormedCommGroup", "code": "@[to_additive]\ninstance (priority := 100) seminormedCommGroup [SeminormedCommGroup E] :\n    SeminormedCommGroup E\u1d52\u1d48 :=\n  \u2039SeminormedCommGroup E\u203a", "start": [2401, 1], "end": [2404, 26], "kind": "commanddeclaration"}, {"full_name": "OrderDual.normedGroup", "code": "@[to_additive]\ninstance (priority := 100) normedGroup [NormedGroup E] : NormedGroup E\u1d52\u1d48 :=\n  \u2039NormedGroup E\u203a", "start": [2407, 1], "end": [2409, 18], "kind": "commanddeclaration"}, {"full_name": "OrderDual.normedCommGroup", "code": "@[to_additive]\ninstance (priority := 100) normedCommGroup [NormedCommGroup E] : NormedCommGroup E\u1d52\u1d48 :=\n  \u2039NormedCommGroup E\u203a", "start": [2412, 1], "end": [2414, 22], "kind": "commanddeclaration"}, {"full_name": "Prod.toNorm", "code": "instance Prod.toNorm : Norm (E \u00d7 F) :=\n  \u27e8fun x => \u2016x.1\u2016 \u2294 \u2016x.2\u2016\u27e9", "start": [2427, 1], "end": [2428, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.norm_def", "code": "theorem Prod.norm_def (x : E \u00d7 F) : \u2016x\u2016 = max \u2016x.1\u2016 \u2016x.2\u2016", "start": [2430, 1], "end": [2431, 6], "kind": "commanddeclaration"}, {"full_name": "norm_fst_le", "code": "theorem norm_fst_le (x : E \u00d7 F) : \u2016x.1\u2016 \u2264 \u2016x\u2016", "start": [2434, 1], "end": [2435, 18], "kind": "commanddeclaration"}, {"full_name": "norm_snd_le", "code": "theorem norm_snd_le (x : E \u00d7 F) : \u2016x.2\u2016 \u2264 \u2016x\u2016", "start": [2438, 1], "end": [2439, 19], "kind": "commanddeclaration"}, {"full_name": "norm_prod_le_iff", "code": "theorem norm_prod_le_iff : \u2016x\u2016 \u2264 r \u2194 \u2016x.1\u2016 \u2264 r \u2227 \u2016x.2\u2016 \u2264 r", "start": [2442, 1], "end": [2443, 13], "kind": "commanddeclaration"}, {"full_name": "Prod.seminormedGroup", "code": "@[to_additive \"Product of seminormed groups, using the sup norm.\"]\ninstance Prod.seminormedGroup : SeminormedGroup (E \u00d7 F) :=\n  \u27e8fun x y => by\n    simp only [Prod.norm_def, Prod.dist_eq, dist_eq_norm_div, Prod.fst_div, Prod.snd_div]\u27e9", "start": [2452, 1], "end": [2456, 91], "kind": "commanddeclaration"}, {"full_name": "Prod.nnorm_def", "code": "@[to_additive Prod.nnnorm_def']\ntheorem Prod.nnorm_def (x : E \u00d7 F) : \u2016x\u2016\u208a = max \u2016x.1\u2016\u208a \u2016x.2\u2016\u208a", "start": [2458, 1], "end": [2460, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.seminormedCommGroup", "code": "@[to_additive \"Product of seminormed groups, using the sup norm.\"]\ninstance seminormedCommGroup [SeminormedCommGroup E] [SeminormedCommGroup F] :\n    SeminormedCommGroup (E \u00d7 F) :=\n  { Prod.seminormedGroup with\n    mul_comm := mul_comm }", "start": [2468, 1], "end": [2473, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.normedGroup", "code": "@[to_additive \"Product of normed groups, using the sup norm.\"]\ninstance normedGroup [NormedGroup E] [NormedGroup F] : NormedGroup (E \u00d7 F) :=\n  { Prod.seminormedGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2475, 1], "end": [2479, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.normedCommGroup", "code": "@[to_additive \"Product of normed groups, using the sup norm.\"]\ninstance normedCommGroup [NormedCommGroup E] [NormedCommGroup F] : NormedCommGroup (E \u00d7 F) :=\n  { Prod.seminormedGroup with\n    mul_comm := mul_comm\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2481, 1], "end": [2486, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.seminormedGroup", "code": "@[to_additive \"Finite product of seminormed groups, using the sup norm.\"]\ninstance Pi.seminormedGroup : SeminormedGroup (\u2200 i, \u03c0 i) where\n  norm f := \u2191(Finset.univ.sup fun b => \u2016f b\u2016\u208a)\n  dist_eq x y :=\n    congr_arg (toReal : \u211d\u22650 \u2192 \u211d) <|\n      congr_arg (Finset.sup Finset.univ) <|\n        funext fun a => show nndist (x a) (y a) = \u2016x a / y a\u2016\u208a from nndist_eq_nnnorm_div (x a) (y a)", "start": [2500, 1], "end": [2507, 101], "kind": "commanddeclaration"}, {"full_name": "Pi.norm_def'", "code": "@[to_additive Pi.norm_def]\ntheorem Pi.norm_def' : \u2016f\u2016 = \u2191(Finset.univ.sup fun b => \u2016f b\u2016\u208a)", "start": [2509, 1], "end": [2511, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.nnnorm_def'", "code": "@[to_additive Pi.nnnorm_def]\ntheorem Pi.nnnorm_def' : \u2016f\u2016\u208a = Finset.univ.sup fun b => \u2016f b\u2016\u208a", "start": [2515, 1], "end": [2517, 18], "kind": "commanddeclaration"}, {"full_name": "pi_norm_le_iff_of_nonneg'", "code": "@[to_additive pi_norm_le_iff_of_nonneg \"The seminorm of an element in a product space is `\u2264 r` if\nand only if the norm of each component is.\"]\ntheorem pi_norm_le_iff_of_nonneg' (hr : 0 \u2264 r) : \u2016x\u2016 \u2264 r \u2194 \u2200 i, \u2016x i\u2016 \u2264 r", "start": [2521, 1], "end": [2526, 64], "kind": "commanddeclaration"}, {"full_name": "pi_nnnorm_le_iff'", "code": "@[to_additive pi_nnnorm_le_iff]\ntheorem pi_nnnorm_le_iff' {r : \u211d\u22650} : \u2016x\u2016\u208a \u2264 r \u2194 \u2200 i, \u2016x i\u2016\u208a \u2264 r", "start": [2530, 1], "end": [2532, 41], "kind": "commanddeclaration"}, {"full_name": "pi_norm_le_iff_of_nonempty'", "code": "@[to_additive pi_norm_le_iff_of_nonempty]\ntheorem pi_norm_le_iff_of_nonempty' [Nonempty \u03b9] : \u2016f\u2016 \u2264 r \u2194 \u2200 b, \u2016f b\u2016 \u2264 r", "start": [2536, 1], "end": [2542, 67], "kind": "commanddeclaration"}, {"full_name": "pi_norm_lt_iff'", "code": "@[to_additive pi_norm_lt_iff \"The seminorm of an element in a product space is `< r` if and only\nif the norm of each component is.\"]\ntheorem pi_norm_lt_iff' (hr : 0 < r) : \u2016x\u2016 < r \u2194 \u2200 i, \u2016x i\u2016 < r", "start": [2546, 1], "end": [2551, 64], "kind": "commanddeclaration"}, {"full_name": "pi_nnnorm_lt_iff'", "code": "@[to_additive pi_nnnorm_lt_iff]\ntheorem pi_nnnorm_lt_iff' {r : \u211d\u22650} (hr : 0 < r) : \u2016x\u2016\u208a < r \u2194 \u2200 i, \u2016x i\u2016\u208a < r", "start": [2555, 1], "end": [2557, 21], "kind": "commanddeclaration"}, {"full_name": "norm_le_pi_norm'", "code": "@[to_additive norm_le_pi_norm]\ntheorem norm_le_pi_norm' (i : \u03b9) : \u2016f i\u2016 \u2264 \u2016f\u2016", "start": [2561, 1], "end": [2563, 59], "kind": "commanddeclaration"}, {"full_name": "nnnorm_le_pi_nnnorm'", "code": "@[to_additive nnnorm_le_pi_nnnorm]\ntheorem nnnorm_le_pi_nnnorm' (i : \u03b9) : \u2016f i\u2016\u208a \u2264 \u2016f\u2016\u208a", "start": [2567, 1], "end": [2569, 23], "kind": "commanddeclaration"}, {"full_name": "pi_norm_const_le'", "code": "@[to_additive pi_norm_const_le]\ntheorem pi_norm_const_le' (a : E) : \u2016fun _ : \u03b9 => a\u2016 \u2264 \u2016a\u2016", "start": [2573, 1], "end": [2575, 66], "kind": "commanddeclaration"}, {"full_name": "pi_nnnorm_const_le'", "code": "@[to_additive pi_nnnorm_const_le]\ntheorem pi_nnnorm_const_le' (a : E) : \u2016fun _ : \u03b9 => a\u2016\u208a \u2264 \u2016a\u2016\u208a", "start": [2579, 1], "end": [2581, 22], "kind": "commanddeclaration"}, {"full_name": "pi_norm_const'", "code": "@[to_additive (attr := simp) pi_norm_const]\ntheorem pi_norm_const' [Nonempty \u03b9] (a : E) : \u2016fun _i : \u03b9 => a\u2016 = \u2016a\u2016", "start": [2585, 1], "end": [2587, 56], "kind": "commanddeclaration"}, {"full_name": "pi_nnnorm_const'", "code": "@[to_additive (attr := simp) pi_nnnorm_const]\ntheorem pi_nnnorm_const' [Nonempty \u03b9] (a : E) : \u2016fun _i : \u03b9 => a\u2016\u208a = \u2016a\u2016\u208a", "start": [2591, 1], "end": [2593, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.sum_norm_apply_le_norm'", "code": "@[to_additive Pi.sum_norm_apply_le_norm \"The $L^1$ norm is less than the $L^\\\\infty$ norm scaled by\nthe cardinality.\"]\ntheorem Pi.sum_norm_apply_le_norm' : \u2211 i, \u2016f i\u2016 \u2264 Fintype.card \u03b9 \u2022 \u2016f\u2016", "start": [2597, 1], "end": [2601, 67], "kind": "commanddeclaration"}, {"full_name": "Pi.sum_nnnorm_apply_le_nnnorm'", "code": "@[to_additive Pi.sum_nnnorm_apply_le_nnnorm \"The $L^1$ norm is less than the $L^\\\\infty$ norm\nscaled by the cardinality.\"]\ntheorem Pi.sum_nnnorm_apply_le_nnnorm' : \u2211 i, \u2016f i\u2016\u208a \u2264 Fintype.card \u03b9 \u2022 \u2016f\u2016\u208a", "start": [2605, 1], "end": [2609, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.seminormedCommGroup", "code": "@[to_additive \"Finite product of seminormed groups, using the sup norm.\"]\ninstance Pi.seminormedCommGroup [\u2200 i, SeminormedCommGroup (\u03c0 i)] : SeminormedCommGroup (\u2200 i, \u03c0 i) :=\n  { Pi.seminormedGroup with\n    mul_comm := mul_comm }", "start": [2615, 1], "end": [2619, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.normedGroup", "code": "@[to_additive \"Finite product of seminormed groups, using the sup norm.\"]\ninstance Pi.normedGroup [\u2200 i, NormedGroup (\u03c0 i)] : NormedGroup (\u2200 i, \u03c0 i) :=\n  { Pi.seminormedGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2623, 1], "end": [2627, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.normedCommGroup", "code": "@[to_additive \"Finite product of seminormed groups, using the sup norm.\"]\ninstance Pi.normedCommGroup [\u2200 i, NormedCommGroup (\u03c0 i)] : NormedCommGroup (\u2200 i, \u03c0 i) :=\n  { Pi.seminormedGroup with\n    mul_comm := mul_comm\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2631, 1], "end": [2636, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.seminormedAddGroup", "code": "instance seminormedAddGroup [SeminormedAddGroup E] : SeminormedAddGroup E\u1d50\u1d52\u1d56 where\n  norm x := \u2016x.unop\u2016\n  dist_eq _ _ := dist_eq_norm _ _\n  toPseudoMetricSpace := MulOpposite.instPseudoMetricSpaceMulOpposite", "start": [2647, 1], "end": [2658, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.norm_op", "code": "theorem norm_op [SeminormedAddGroup E] (a : E) : \u2016MulOpposite.op a\u2016 = \u2016a\u2016", "start": [2660, 1], "end": [2661, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.norm_unop", "code": "theorem norm_unop [SeminormedAddGroup E] (a : E\u1d50\u1d52\u1d56) : \u2016MulOpposite.unop a\u2016 = \u2016a\u2016", "start": [2664, 1], "end": [2665, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nnnorm_op", "code": "theorem nnnorm_op [SeminormedAddGroup E] (a : E) : \u2016MulOpposite.op a\u2016\u208a = \u2016a\u2016\u208a", "start": [2668, 1], "end": [2669, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nnnorm_unop", "code": "theorem nnnorm_unop [SeminormedAddGroup E] (a : E\u1d50\u1d52\u1d56) : \u2016MulOpposite.unop a\u2016\u208a = \u2016a\u2016\u208a", "start": [2672, 1], "end": [2673, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normedAddGroup", "code": "instance normedAddGroup [NormedAddGroup E] : NormedAddGroup E\u1d50\u1d52\u1d56 :=\n  { MulOpposite.seminormedAddGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2676, 1], "end": [2678, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.seminormedAddCommGroup", "code": "instance seminormedAddCommGroup [SeminormedAddCommGroup E] : SeminormedAddCommGroup E\u1d50\u1d52\u1d56 where\n  dist_eq _ _ := dist_eq_norm _ _", "start": [2680, 1], "end": [2681, 34], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normedAddCommGroup", "code": "instance normedAddCommGroup [NormedAddCommGroup E] : NormedAddCommGroup E\u1d50\u1d52\u1d56 :=\n  { MulOpposite.seminormedAddCommGroup with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2683, 1], "end": [2685, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.seminormedGroup", "code": "@[to_additive \"A subgroup of a seminormed group is also a seminormed group, with the restriction of\nthe norm.\"]\ninstance seminormedGroup : SeminormedGroup s :=\n  SeminormedGroup.induced _ _ s.subtype", "start": [2698, 1], "end": [2703, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_norm", "code": "@[to_additive (attr := simp) \"If `x` is an element of a subgroup `s` of a seminormed group `E`, its\nnorm in `s` is equal to its norm in `E`.\"]\ntheorem coe_norm (x : s) : \u2016x\u2016 = \u2016(x : E)\u2016", "start": [2707, 1], "end": [2712, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.norm_coe", "code": "@[to_additive (attr := norm_cast) \"If `x` is an element of a subgroup `s` of a seminormed group `E`,\nits norm in `s` is equal to its norm in `E`.\n\nThis is a reversed version of the `simp` lemma `AddSubgroup.coe_norm` for use by `norm_cast`.\"]\ntheorem norm_coe {s : Subgroup E} (x : s) : \u2016(x : E)\u2016 = \u2016x\u2016", "start": [2716, 1], "end": [2725, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.seminormedCommGroup", "code": "@[to_additive]\ninstance seminormedCommGroup [SeminormedCommGroup E] {s : Subgroup E} : SeminormedCommGroup s :=\n  SeminormedCommGroup.induced _ _ s.subtype", "start": [2731, 1], "end": [2733, 44], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normedGroup", "code": "@[to_additive]\ninstance normedGroup [NormedGroup E] {s : Subgroup E} : NormedGroup s :=\n  NormedGroup.induced _ _ s.subtype Subtype.coe_injective", "start": [2737, 1], "end": [2739, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normedCommGroup", "code": "@[to_additive]\ninstance normedCommGroup [NormedCommGroup E] {s : Subgroup E} : NormedCommGroup s :=\n  NormedCommGroup.induced _ _ s.subtype Subtype.coe_injective", "start": [2743, 1], "end": [2745, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.seminormedAddCommGroup", "code": "instance seminormedAddCommGroup [Ring \ud835\udd5c] [SeminormedAddCommGroup E] [Module \ud835\udd5c E]\n    (s : Submodule \ud835\udd5c E) : SeminormedAddCommGroup s :=\n  SeminormedAddCommGroup.induced _ _ s.subtype.toAddMonoidHom", "start": [2757, 1], "end": [2761, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_norm", "code": "@[simp]\ntheorem coe_norm [Ring \ud835\udd5c] [SeminormedAddCommGroup E] [Module \ud835\udd5c E] {s : Submodule \ud835\udd5c E}\n    (x : s) : \u2016x\u2016 = \u2016(x : E)\u2016", "start": [2765, 1], "end": [2770, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.norm_coe", "code": "@[norm_cast]\ntheorem norm_coe [Ring \ud835\udd5c] [SeminormedAddCommGroup E] [Module \ud835\udd5c E] {s : Submodule \ud835\udd5c E}\n    (x : s) : \u2016(x : E)\u2016 = \u2016x\u2016", "start": [2774, 1], "end": [2781, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.normedAddCommGroup", "code": "instance normedAddCommGroup [Ring \ud835\udd5c] [NormedAddCommGroup E] [Module \ud835\udd5c E]\n    (s : Submodule \ud835\udd5c E) : NormedAddCommGroup s :=\n  { Submodule.seminormedAddCommGroup s with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [2785, 1], "end": [2789, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Pointwise.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "Mathlib/Data/Set/Pointwise/Basic.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.star", "code": "protected def star [Star \u03b1] : Star (Set \u03b1) := \u27e8preimage Star.star\u27e9", "start": [33, 1], "end": [36, 67], "kind": "commanddeclaration"}, {"full_name": "Set.star_empty", "code": "@[simp]\ntheorem star_empty [Star \u03b1] : (\u2205 : Set \u03b1)\u22c6 = \u2205", "start": [41, 1], "end": [42, 54], "kind": "commanddeclaration"}, {"full_name": "Set.star_univ", "code": "@[simp]\ntheorem star_univ [Star \u03b1] : (univ : Set \u03b1)\u22c6 = univ", "start": [45, 1], "end": [46, 59], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_star", "code": "@[simp]\ntheorem nonempty_star [InvolutiveStar \u03b1] {s : Set \u03b1} : s\u22c6.Nonempty \u2194 s.Nonempty", "start": [49, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.star", "code": "theorem Nonempty.star [InvolutiveStar \u03b1] {s : Set \u03b1} (h : s.Nonempty) : s\u22c6.Nonempty", "start": [54, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "Set.mem_star", "code": "@[simp]\ntheorem mem_star [Star \u03b1] : a \u2208 s\u22c6 \u2194 a\u22c6 \u2208 s", "start": [58, 1], "end": [59, 55], "kind": "commanddeclaration"}, {"full_name": "Set.star_mem_star", "code": "theorem star_mem_star [InvolutiveStar \u03b1] : a\u22c6 \u2208 s\u22c6 \u2194 a \u2208 s", "start": [62, 1], "end": [62, 97], "kind": "commanddeclaration"}, {"full_name": "Set.star_preimage", "code": "@[simp]\ntheorem star_preimage [Star \u03b1] : Star.star \u207b\u00b9' s = s\u22c6", "start": [65, 1], "end": [66, 61], "kind": "commanddeclaration"}, {"full_name": "Set.image_star", "code": "@[simp]\ntheorem image_star [InvolutiveStar \u03b1] : Star.star '' s = s\u22c6", "start": [69, 1], "end": [72, 72], "kind": "commanddeclaration"}, {"full_name": "Set.inter_star", "code": "@[simp]\ntheorem inter_star [Star \u03b1] : (s \u2229 t)\u22c6 = s\u22c6 \u2229 t\u22c6", "start": [75, 1], "end": [76, 67], "kind": "commanddeclaration"}, {"full_name": "Set.union_star", "code": "@[simp]\ntheorem union_star [Star \u03b1] : (s \u222a t)\u22c6 = s\u22c6 \u222a t\u22c6", "start": [79, 1], "end": [80, 67], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_star", "code": "@[simp]\ntheorem iInter_star {\u03b9 : Sort*} [Star \u03b1] (s : \u03b9 \u2192 Set \u03b1) : (\u22c2 i, s i)\u22c6 = \u22c2 i, (s i)\u22c6", "start": [83, 1], "end": [85, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_star", "code": "@[simp]\ntheorem iUnion_star {\u03b9 : Sort*} [Star \u03b1] (s : \u03b9 \u2192 Set \u03b1) : (\u22c3 i, s i)\u22c6 = \u22c3 i, (s i)\u22c6", "start": [88, 1], "end": [90, 18], "kind": "commanddeclaration"}, {"full_name": "Set.compl_star", "code": "@[simp]\ntheorem compl_star [Star \u03b1] : s\u1d9c\u22c6 = s\u22c6\u1d9c", "start": [93, 1], "end": [94, 58], "kind": "commanddeclaration"}, {"full_name": "Set.star_subset_star", "code": "@[simp]\ntheorem star_subset_star [InvolutiveStar \u03b1] {s t : Set \u03b1} : s\u22c6 \u2286 t\u22c6 \u2194 s \u2286 t", "start": [102, 1], "end": [104, 53], "kind": "commanddeclaration"}, {"full_name": "Set.star_subset", "code": "theorem star_subset [InvolutiveStar \u03b1] {s t : Set \u03b1} : s\u22c6 \u2286 t \u2194 s \u2286 t\u22c6", "start": [107, 1], "end": [108, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.star", "code": "theorem Finite.star [InvolutiveStar \u03b1] {s : Set \u03b1} (hs : s.Finite) : s\u22c6.Finite", "start": [111, 1], "end": [112, 40], "kind": "commanddeclaration"}, {"full_name": "Set.star_singleton", "code": "theorem star_singleton {\u03b2 : Type*} [InvolutiveStar \u03b2] (x : \u03b2) : ({x} : Set \u03b2)\u22c6 = {x\u22c6}", "start": [115, 1], "end": [117, 84], "kind": "commanddeclaration"}, {"full_name": "Set.star_mul", "code": "protected theorem star_mul [Mul \u03b1] [StarMul \u03b1] (s t : Set \u03b1) : (s * t)\u22c6 = t\u22c6 * s\u22c6", "start": [120, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "Set.star_add", "code": "protected theorem star_add [AddMonoid \u03b1] [StarAddMonoid \u03b1] (s t : Set \u03b1) : (s + t)\u22c6 = s\u22c6 + t\u22c6", "start": [125, 1], "end": [127, 13], "kind": "commanddeclaration"}, {"full_name": "Set.star_inv", "code": "protected theorem star_inv [Group \u03b1] [StarMul \u03b1] (s : Set \u03b1) : s\u207b\u00b9\u22c6 = s\u22c6\u207b\u00b9", "start": [137, 1], "end": [139, 42], "kind": "commanddeclaration"}, {"full_name": "Set.star_inv'", "code": "protected theorem star_inv' [DivisionSemiring \u03b1] [StarRing \u03b1] (s : Set \u03b1) : s\u207b\u00b9\u22c6 = s\u22c6\u207b\u00b9", "start": [142, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.star_coe_eq", "code": "@[simp]\nlemma StarMemClass.star_coe_eq {S \u03b1 : Type*} [InvolutiveStar \u03b1] [SetLike S \u03b1]\n    [StarMemClass S \u03b1] (s : S) : star (s : Set \u03b1) = s := by\n  ext x\n  simp only [Set.mem_star, SetLike.mem_coe]\n  exact \u27e8by simpa only [star_star] using star_mem (s := s) (r := star x), star_mem\u27e9", "start": [149, 1], "end": [154, 84], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/CommSq.lean", "imports": ["Mathlib/CategoryTheory/Arrow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.CommSq", "code": "structure CommSq {W X Y Z : C} (f : W \u27f6 X) (g : W \u27f6 Y) (h : X \u27f6 Z) (i : Y \u27f6 Z) : Prop where\n  \n  w : f \u226b h = g \u226b i", "start": [32, 1], "end": [46, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.flip", "code": "theorem flip (p : CommSq f g h i) : CommSq g f i h", "start": [55, 1], "end": [56, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.of_arrow", "code": "theorem of_arrow {f g : Arrow C} (h : f \u27f6 g) : CommSq f.hom h.left h.right g.hom", "start": [59, 1], "end": [60, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.op", "code": "theorem op (p : CommSq f g h i) : CommSq i.op h.op g.op f.op", "start": [63, 1], "end": [65, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.unop", "code": "theorem unop {W X Y Z : C\u1d52\u1d56} {f : W \u27f6 X} {g : W \u27f6 Y} {h : X \u27f6 Z} {i : Y \u27f6 Z} (p : CommSq f g h i) :\n    CommSq i.unop h.unop g.unop f.unop", "start": [68, 1], "end": [71, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_commSq", "code": "theorem map_commSq (s : CommSq f g h i) : CommSq (F.map f) (F.map g) (F.map h) (F.map i)", "start": [82, 1], "end": [83, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.map", "code": "alias CommSq.map := Functor.map_commSq", "start": [88, 1], "end": [88, 39], "kind": "stdtacticaliasalias"}, {"full_name": "CategoryTheory.CommSq.LiftStruct", "code": "@[ext]\nstructure LiftStruct (sq : CommSq f i p g) where\n  \n  l : B \u27f6 X\n  \n  fac_left : i \u226b l = f\n  \n  fac_right: l \u226b p = g", "start": [96, 1], "end": [116, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.LiftStruct.op", "code": "@[simps]\ndef op {sq : CommSq f i p g} (l : LiftStruct sq) : LiftStruct sq.op\n    where\n  l := l.l.op\n  fac_left := by rw [\u2190 op_comp, l.fac_right]\n  fac_right := by rw [\u2190 op_comp, l.fac_left]", "start": [121, 1], "end": [128, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.LiftStruct.unop", "code": "@[simps]\ndef unop {A B X Y : C\u1d52\u1d56} {f : A \u27f6 X} {i : A \u27f6 B} {p : X \u27f6 Y} {g : B \u27f6 Y} {sq : CommSq f i p g}\n    (l : LiftStruct sq) : LiftStruct sq.unop\n    where\n  l := l.l.unop\n  fac_left := by rw [\u2190 unop_comp, l.fac_right]\n  fac_right := by rw [\u2190 unop_comp, l.fac_left]", "start": [131, 1], "end": [139, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.LiftStruct.opEquiv", "code": "@[simps]\ndef opEquiv (sq : CommSq f i p g) : LiftStruct sq \u2243 LiftStruct sq.op\n    where\n  toFun := op\n  invFun := unop\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [142, 1], "end": [150, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.LiftStruct.unopEquiv", "code": "def unopEquiv {A B X Y : C\u1d52\u1d56} {f : A \u27f6 X} {i : A \u27f6 B} {p : X \u27f6 Y} {g : B \u27f6 Y}\n    (sq : CommSq f i p g) : LiftStruct sq \u2243 LiftStruct sq.unop\n    where\n  toFun := unop\n  invFun := op\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [153, 1], "end": [161, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.subsingleton_liftStruct_of_epi", "code": "instance subsingleton_liftStruct_of_epi (sq : CommSq f i p g) [Epi i] :\n    Subsingleton (LiftStruct sq) :=\n  \u27e8fun l\u2081 l\u2082 => by\n    ext\n    rw [\u2190 cancel_epi i]\n    simp only [LiftStruct.fac_left]\u27e9", "start": [166, 1], "end": [171, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.subsingleton_liftStruct_of_mono", "code": "instance subsingleton_liftStruct_of_mono (sq : CommSq f i p g) [Mono p] :\n    Subsingleton (LiftStruct sq) :=\n  \u27e8fun l\u2081 l\u2082 => by\n    ext\n    rw [\u2190 cancel_mono p]\n    simp only [LiftStruct.fac_right]\u27e9", "start": [174, 1], "end": [179, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.HasLift", "code": "class HasLift : Prop where\n  \n  exists_lift : Nonempty sq.LiftStruct", "start": [185, 1], "end": [188, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.HasLift.mk'", "code": "theorem mk' (l : sq.LiftStruct) : HasLift sq", "start": [195, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.HasLift.iff", "code": "theorem iff : HasLift sq \u2194 Nonempty sq.LiftStruct", "start": [201, 1], "end": [203, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.HasLift.iff_op", "code": "theorem iff_op : HasLift sq \u2194 HasLift sq.op", "start": [206, 1], "end": [208, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.HasLift.iff_unop", "code": "theorem iff_unop {A B X Y : C\u1d52\u1d56} {f : A \u27f6 X} {i : A \u27f6 B} {p : X \u27f6 Y} {g : B \u27f6 Y}\n    (sq : CommSq f i p g) : HasLift sq \u2194 HasLift sq.unop", "start": [211, 1], "end": [214, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.lift", "code": "noncomputable def lift [hsq : HasLift sq] : B \u27f6 X :=\n  hsq.exists_lift.some.l", "start": [219, 1], "end": [222, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.fac_left", "code": "@[reassoc (attr := simp)]\ntheorem fac_left [hsq : HasLift sq] : i \u226b sq.lift = f", "start": [225, 1], "end": [227, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.fac_right", "code": "@[reassoc (attr := simp)]\ntheorem fac_right [hsq : HasLift sq] : sq.lift \u226b p = g", "start": [230, 1], "end": [232, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/EpiMono.lean", "imports": ["Mathlib/CategoryTheory/Opposites.lean", "Mathlib/CategoryTheory/Groupoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.unop_mono_of_epi", "code": "instance unop_mono_of_epi {A B : C\u1d52\u1d56} (f : A \u27f6 B) [Epi f] : Mono f.unop :=\n  \u27e8fun _ _ eq => Quiver.Hom.op_inj ((cancel_epi f).1 (Quiver.Hom.unop_inj eq))\u27e9", "start": [25, 1], "end": [26, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unop_epi_of_mono", "code": "instance unop_epi_of_mono {A B : C\u1d52\u1d56} (f : A \u27f6 B) [Mono f] : Epi f.unop :=\n  \u27e8fun _ _ eq => Quiver.Hom.op_inj ((cancel_mono f).1 (Quiver.Hom.unop_inj eq))\u27e9", "start": [29, 1], "end": [30, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_mono_of_epi", "code": "instance op_mono_of_epi {A B : C} (f : A \u27f6 B) [Epi f] : Mono f.op :=\n  \u27e8fun _ _ eq => Quiver.Hom.unop_inj ((cancel_epi f).1 (Quiver.Hom.op_inj eq))\u27e9", "start": [33, 1], "end": [34, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_epi_of_mono", "code": "instance op_epi_of_mono {A B : C} (f : A \u27f6 B) [Mono f] : Epi f.op :=\n  \u27e8fun _ _ eq => Quiver.Hom.unop_inj ((cancel_mono f).1 (Quiver.Hom.op_inj eq))\u27e9", "start": [37, 1], "end": [38, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitMono", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X \u27f6 Y) where\n  \n  retraction : Y \u27f6 X\n  \n  id : f \u226b retraction = \ud835\udfd9 X := by aesop_cat", "start": [41, 1], "end": [53, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitMono", "code": "class IsSplitMono {X Y : C} (f : X \u27f6 Y) : Prop where\n  \n  exists_splitMono : Nonempty (SplitMono f)", "start": [58, 1], "end": [61, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitMono.mk'", "code": "theorem IsSplitMono.mk' {X Y : C} {f : X \u27f6 Y} (sm : SplitMono f) : IsSplitMono f", "start": [65, 1], "end": [67, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitEpi", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X \u27f6 Y) where\n  \n  section_ : Y \u27f6 X\n  \n  id : section_ \u226b f = \ud835\udfd9 Y := by aesop_cat", "start": [70, 1], "end": [83, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitEpi", "code": "class IsSplitEpi {X Y : C} (f : X \u27f6 Y) : Prop where\n  \n  exists_splitEpi : Nonempty (SplitEpi f)", "start": [88, 1], "end": [91, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitEpi.mk'", "code": "theorem IsSplitEpi.mk' {X Y : C} {f : X \u27f6 Y} (se : SplitEpi f) : IsSplitEpi f", "start": [95, 1], "end": [97, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.retraction", "code": "noncomputable def retraction {X Y : C} (f : X \u27f6 Y) [hf : IsSplitMono f] : Y \u27f6 X :=\n  hf.exists_splitMono.some.retraction", "start": [100, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitMono.id", "code": "@[reassoc (attr := simp)]\ntheorem IsSplitMono.id {X Y : C} (f : X \u27f6 Y) [hf : IsSplitMono f] : f \u226b retraction f = \ud835\udfd9 X", "start": [105, 1], "end": [107, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitMono.splitEpi", "code": "def SplitMono.splitEpi {X Y : C} {f : X \u27f6 Y} (sm : SplitMono f) : SplitEpi sm.retraction where\n  section_ := f", "start": [110, 1], "end": [112, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.retraction_isSplitEpi", "code": "instance retraction_isSplitEpi {X Y : C} (f : X \u27f6 Y) [IsSplitMono f] :\n    IsSplitEpi (retraction f) :=\n  IsSplitEpi.mk' (SplitMono.splitEpi _)", "start": [115, 1], "end": [118, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_epi_of_isSplitMono", "code": "theorem isIso_of_epi_of_isSplitMono {X Y : C} (f : X \u27f6 Y) [IsSplitMono f] [Epi f] : IsIso f", "start": [121, 1], "end": [123, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.section_", "code": "noncomputable def section_ {X Y : C} (f : X \u27f6 Y) [hf : IsSplitEpi f] : Y \u27f6 X :=\n  hf.exists_splitEpi.some.section_", "start": [126, 1], "end": [130, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitEpi.id", "code": "@[reassoc (attr := simp)]\ntheorem IsSplitEpi.id {X Y : C} (f : X \u27f6 Y) [hf : IsSplitEpi f] : section_ f \u226b f = \ud835\udfd9 Y", "start": [133, 1], "end": [135, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitEpi.splitMono", "code": "def SplitEpi.splitMono {X Y : C} {f : X \u27f6 Y} (se : SplitEpi f) : SplitMono se.section_ where\n  retraction := f", "start": [138, 1], "end": [140, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.section_isSplitMono", "code": "instance section_isSplitMono {X Y : C} (f : X \u27f6 Y) [IsSplitEpi f] : IsSplitMono (section_ f) :=\n  IsSplitMono.mk' (SplitEpi.splitMono _)", "start": [143, 1], "end": [145, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_mono_of_isSplitEpi", "code": "theorem isIso_of_mono_of_isSplitEpi {X Y : C} (f : X \u27f6 Y) [Mono f] [IsSplitEpi f] : IsIso f", "start": [148, 1], "end": [150, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitMono.of_iso", "code": "instance (priority := 100) IsSplitMono.of_iso {X Y : C} (f : X \u27f6 Y) [IsIso f] : IsSplitMono f :=\n  IsSplitMono.mk' { retraction := inv f }", "start": [153, 1], "end": [155, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitEpi.of_iso", "code": "instance (priority := 100) IsSplitEpi.of_iso {X Y : C} (f : X \u27f6 Y) [IsIso f] : IsSplitEpi f :=\n  IsSplitEpi.mk' { section_ := inv f }", "start": [158, 1], "end": [160, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitMono.mono", "code": "theorem SplitMono.mono {X Y : C} {f : X \u27f6 Y} (sm : SplitMono f) : Mono f", "start": [163, 1], "end": [164, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitMono.mono", "code": "instance (priority := 100) IsSplitMono.mono {X Y : C} (f : X \u27f6 Y) [hf : IsSplitMono f] : Mono f :=\n  hf.exists_splitMono.some.mono", "start": [167, 1], "end": [169, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitEpi.epi", "code": "theorem SplitEpi.epi {X Y : C} {f : X \u27f6 Y} (se : SplitEpi f) : Epi f", "start": [172, 1], "end": [173, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSplitEpi.epi", "code": "instance (priority := 100) IsSplitEpi.epi {X Y : C} (f : X \u27f6 Y) [hf : IsSplitEpi f] : Epi f :=\n  hf.exists_splitEpi.some.epi", "start": [176, 1], "end": [178, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_mono_retraction'", "code": "theorem IsIso.of_mono_retraction' {X Y : C} {f : X \u27f6 Y} (hf : SplitMono f) [Mono <| hf.retraction] :\n    IsIso f", "start": [181, 1], "end": [184, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_mono_retraction", "code": "theorem IsIso.of_mono_retraction {X Y : C} (f : X \u27f6 Y) [hf : IsSplitMono f]\n    [hf' : Mono <| retraction f] : IsIso f", "start": [187, 1], "end": [190, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_epi_section'", "code": "theorem IsIso.of_epi_section' {X Y : C} {f : X \u27f6 Y} (hf : SplitEpi f) [Epi <| hf.section_] :\n    IsIso f", "start": [193, 1], "end": [196, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_epi_section", "code": "theorem IsIso.of_epi_section {X Y : C} (f : X \u27f6 Y) [hf : IsSplitEpi f] [hf' : Epi <| section_ f] :\n    IsIso f", "start": [199, 1], "end": [202, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Groupoid.ofTruncSplitMono", "code": "noncomputable def Groupoid.ofTruncSplitMono\n    (all_split_mono : \u2200 {X Y : C} (f : X \u27f6 Y), Trunc (IsSplitMono f)) : Groupoid.{v\u2081} C := by\n  apply Groupoid.ofIsIso\n  intro X Y f\n  have \u27e8a,_\u27e9 := Trunc.exists_rep <| all_split_mono f\n  have \u27e8b,_\u27e9 := Trunc.exists_rep <| all_split_mono <| retraction f\n  apply IsIso.of_mono_retraction", "start": [206, 1], "end": [213, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitMonoCategory", "code": "class SplitMonoCategory : Prop where\n  \n  isSplitMono_of_mono : \u2200 {X Y : C} (f : X \u27f6 Y) [Mono f], IsSplitMono f", "start": [220, 1], "end": [223, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitEpiCategory", "code": "class SplitEpiCategory : Prop where\n  \n  isSplitEpi_of_epi : \u2200 {X Y : C} (f : X \u27f6 Y) [Epi f], IsSplitEpi f", "start": [227, 1], "end": [230, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSplitMono_of_mono", "code": "theorem isSplitMono_of_mono [SplitMonoCategory C] {X Y : C} (f : X \u27f6 Y) [Mono f] : IsSplitMono f", "start": [236, 1], "end": [239, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSplitEpi_of_epi", "code": "theorem isSplitEpi_of_epi [SplitEpiCategory C] {X Y : C} (f : X \u27f6 Y) [Epi f] : IsSplitEpi f", "start": [242, 1], "end": [245, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitMono.map", "code": "@[simps]\ndef SplitMono.map {X Y : C} {f : X \u27f6 Y} (sm : SplitMono f) (F : C \u2964 D) : SplitMono (F.map f)\n    where\n  retraction := F.map sm.retraction\n  id := by rw [\u2190 Functor.map_comp, SplitMono.id, Functor.map_id]", "start": [252, 1], "end": [257, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SplitEpi.map", "code": "@[simps]\ndef SplitEpi.map {X Y : C} {f : X \u27f6 Y} (se : SplitEpi f) (F : C \u2964 D) : SplitEpi (F.map f)\n    where\n  section_ := F.map se.section_\n  id := by rw [\u2190 Functor.map_comp, SplitEpi.id, Functor.map_id]", "start": [260, 1], "end": [265, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Support.lean", "imports": ["Mathlib/Data/Finset/Card.lean", "Mathlib/GroupTheory/Perm/Basic.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.Perm.Disjoint", "code": "def Disjoint (f g : Perm \u03b1) :=\n  \u2200 x, f x = x \u2228 g x = x", "start": [35, 1], "end": [38, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.symm", "code": "@[symm]\ntheorem Disjoint.symm : Disjoint f g \u2192 Disjoint g f", "start": [43, 1], "end": [44, 98], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.symmetric", "code": "theorem Disjoint.symmetric : Symmetric (@Disjoint \u03b1)", "start": [47, 1], "end": [47, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_comm", "code": "theorem disjoint_comm : Disjoint f g \u2194 Disjoint g f", "start": [53, 1], "end": [54, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.commute", "code": "theorem Disjoint.commute (h : Disjoint f g) : Commute f g", "start": [57, 1], "end": [65, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_one_left", "code": "@[simp]\ntheorem disjoint_one_left (f : Perm \u03b1) : Disjoint 1 f", "start": [68, 1], "end": [69, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_one_right", "code": "@[simp]\ntheorem disjoint_one_right (f : Perm \u03b1) : Disjoint f 1", "start": [72, 1], "end": [73, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_iff_eq_or_eq", "code": "theorem disjoint_iff_eq_or_eq : Disjoint f g \u2194 \u2200 x : \u03b1, f x = x \u2228 g x = x", "start": [76, 1], "end": [77, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_refl_iff", "code": "@[simp]\ntheorem disjoint_refl_iff : Disjoint f f \u2194 f = 1", "start": [80, 1], "end": [84, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.inv_left", "code": "theorem Disjoint.inv_left (h : Disjoint f g) : Disjoint f\u207b\u00b9 g", "start": [87, 1], "end": [90, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.inv_right", "code": "theorem Disjoint.inv_right (h : Disjoint f g) : Disjoint f g\u207b\u00b9", "start": [93, 1], "end": [94, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_inv_left_iff", "code": "@[simp]\ntheorem disjoint_inv_left_iff : Disjoint f\u207b\u00b9 g \u2194 Disjoint f g", "start": [97, 1], "end": [100, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_inv_right_iff", "code": "@[simp]\ntheorem disjoint_inv_right_iff : Disjoint f g\u207b\u00b9 \u2194 Disjoint f g", "start": [103, 1], "end": [105, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mul_left", "code": "theorem Disjoint.mul_left (H1 : Disjoint f h) (H2 : Disjoint g h) : Disjoint (f * g) h", "start": [108, 1], "end": [109, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mul_right", "code": "theorem Disjoint.mul_right (H1 : Disjoint f g) (H2 : Disjoint f h) : Disjoint f (g * h)", "start": [112, 1], "end": [114, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_conj", "code": "theorem disjoint_conj (h : Perm \u03b1) : Disjoint (h * f * h\u207b\u00b9) (h * g * h\u207b\u00b9) \u2194 Disjoint f g", "start": [118, 1], "end": [119, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.conj", "code": "theorem Disjoint.conj (H : Disjoint f g) (h : Perm \u03b1) : Disjoint (h * f * h\u207b\u00b9) (h * g * h\u207b\u00b9)", "start": [121, 1], "end": [122, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_prod_right", "code": "theorem disjoint_prod_right (l : List (Perm \u03b1)) (h : \u2200 g \u2208 l, Disjoint f g) :\n    Disjoint f l.prod", "start": [124, 1], "end": [129, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_prod_perm", "code": "theorem disjoint_prod_perm {l\u2081 l\u2082 : List (Perm \u03b1)} (hl : l\u2081.Pairwise Disjoint) (hp : l\u2081 ~ l\u2082) :\n    l\u2081.prod = l\u2082.prod", "start": [132, 1], "end": [134, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nodup_of_pairwise_disjoint", "code": "theorem nodup_of_pairwise_disjoint {l : List (Perm \u03b1)} (h1 : (1 : Perm \u03b1) \u2209 l)\n    (h2 : l.Pairwise Disjoint) : l.Nodup", "start": [137, 1], "end": [145, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_apply_eq_self_of_apply_eq_self", "code": "theorem pow_apply_eq_self_of_apply_eq_self {x : \u03b1} (hfx : f x = x) : \u2200 n : \u2115, (f ^ n) x = x", "start": [148, 1], "end": [150, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.zpow_apply_eq_self_of_apply_eq_self", "code": "theorem zpow_apply_eq_self_of_apply_eq_self {x : \u03b1} (hfx : f x = x) : \u2200 n : \u2124, (f ^ n) x = x", "start": [153, 1], "end": [155, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_apply_eq_of_apply_apply_eq_self", "code": "theorem pow_apply_eq_of_apply_apply_eq_self {x : \u03b1} (hffx : f (f x) = x) :\n    \u2200 n : \u2115, (f ^ n) x = x \u2228 (f ^ n) x = f x", "start": [158, 1], "end": [164, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.zpow_apply_eq_of_apply_apply_eq_self", "code": "theorem zpow_apply_eq_of_apply_apply_eq_self {x : \u03b1} (hffx : f (f x) = x) :\n    \u2200 i : \u2124, (f ^ i) x = x \u2228 (f ^ i) x = f x", "start": [167, 1], "end": [173, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mul_apply_eq_iff", "code": "theorem Disjoint.mul_apply_eq_iff {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3\u03c4 : Disjoint \u03c3 \u03c4) {a : \u03b1} :\n    (\u03c3 * \u03c4) a = a \u2194 \u03c3 a = a \u2227 \u03c4 a = a", "start": [176, 1], "end": [181, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mul_eq_one_iff", "code": "theorem Disjoint.mul_eq_one_iff {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3\u03c4 : Disjoint \u03c3 \u03c4) : \u03c3 * \u03c4 = 1 \u2194 \u03c3 = 1 \u2227 \u03c4 = 1", "start": [184, 1], "end": [185, 68], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.zpow_disjoint_zpow", "code": "theorem Disjoint.zpow_disjoint_zpow {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3\u03c4 : Disjoint \u03c3 \u03c4) (m n : \u2124) :\n    Disjoint (\u03c3 ^ m) (\u03c4 ^ n)", "start": [188, 1], "end": [191, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.pow_disjoint_pow", "code": "theorem Disjoint.pow_disjoint_pow {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3\u03c4 : Disjoint \u03c3 \u03c4) (m n : \u2115) :\n    Disjoint (\u03c3 ^ m) (\u03c4 ^ n)", "start": [194, 1], "end": [196, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsSwap", "code": "def IsSwap (f : Perm \u03b1) : Prop :=\n  \u2203 x y, x \u2260 y \u2227 f = swap x y", "start": [205, 1], "end": [207, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype_swap_eq", "code": "@[simp]\ntheorem ofSubtype_swap_eq {p : \u03b1 \u2192 Prop} [DecidablePred p] (x y : Subtype p) :\n    ofSubtype (Equiv.swap x y) = Equiv.swap \u2191x \u2191y", "start": [210, 1], "end": [229, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsSwap.of_subtype_isSwap", "code": "theorem IsSwap.of_subtype_isSwap {p : \u03b1 \u2192 Prop} [DecidablePred p] {f : Perm (Subtype p)}\n    (h : f.IsSwap) : (ofSubtype f).IsSwap", "start": [232, 1], "end": [238, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ne_and_ne_of_swap_mul_apply_ne_self", "code": "theorem ne_and_ne_of_swap_mul_apply_ne_self {f : Perm \u03b1} {x y : \u03b1} (hy : (swap x (f x) * f) y \u2260 y) :\n    f y \u2260 y \u2227 y \u2260 x", "start": [241, 1], "end": [246, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.set_support_inv_eq", "code": "theorem set_support_inv_eq : { x | p\u207b\u00b9 x \u2260 x } = { x | p x \u2260 x }", "start": [257, 1], "end": [260, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.set_support_apply_mem", "code": "theorem set_support_apply_mem {p : Perm \u03b1} {a : \u03b1} : p a \u2208 { x | p x \u2260 x } \u2194 a \u2208 { x | p x \u2260 x }", "start": [263, 1], "end": [264, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.set_support_zpow_subset", "code": "theorem set_support_zpow_subset (n : \u2124) : { x | (p ^ n) x \u2260 x } \u2286 { x | p x \u2260 x }", "start": [267, 1], "end": [271, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.set_support_mul_subset", "code": "theorem set_support_mul_subset : { x | (p * q) x \u2260 x } \u2286 { x | p x \u2260 x } \u222a { x | q x \u2260 x }", "start": [274, 1], "end": [277, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support", "code": "def support (f : Perm \u03b1) : Finset \u03b1 :=\n  univ.filter fun x => f x \u2260 x", "start": [284, 1], "end": [286, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_support", "code": "@[simp]\ntheorem mem_support {x : \u03b1} : x \u2208 f.support \u2194 f x \u2260 x", "start": [289, 1], "end": [291, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.not_mem_support", "code": "theorem not_mem_support {x : \u03b1} : x \u2209 f.support \u2194 f x = x", "start": [294, 1], "end": [294, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.coe_support_eq_set_support", "code": "theorem coe_support_eq_set_support (f : Perm \u03b1) : (f.support : Set \u03b1) = { x | f x \u2260 x }", "start": [297, 1], "end": [299, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_eq_empty_iff", "code": "@[simp]\ntheorem support_eq_empty_iff {\u03c3 : Perm \u03b1} : \u03c3.support = \u2205 \u2194 \u03c3 = 1", "start": [302, 1], "end": [305, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_one", "code": "@[simp]\ntheorem support_one : (1 : Perm \u03b1).support = \u2205", "start": [308, 1], "end": [309, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_refl", "code": "@[simp]\ntheorem support_refl : support (Equiv.refl \u03b1) = \u2205", "start": [312, 1], "end": [314, 14], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_congr", "code": "theorem support_congr (h : f.support \u2286 g.support) (h' : \u2200 x \u2208 g.support, f x = g x) : f = g", "start": [317, 1], "end": [322, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_mul_le", "code": "theorem support_mul_le (f g : Perm \u03b1) : (f * g).support \u2264 f.support \u2294 g.support", "start": [325, 1], "end": [329, 14], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.exists_mem_support_of_mem_support_prod", "code": "theorem exists_mem_support_of_mem_support_prod {l : List (Perm \u03b1)} {x : \u03b1}\n    (hx : x \u2208 l.prod.support) : \u2203 f : Perm \u03b1, f \u2208 l \u2227 x \u2208 f.support", "start": [332, 1], "end": [343, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_pow_le", "code": "theorem support_pow_le (\u03c3 : Perm \u03b1) (n : \u2115) : (\u03c3 ^ n).support \u2264 \u03c3.support", "start": [346, 1], "end": [347, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_inv", "code": "@[simp]\ntheorem support_inv (\u03c3 : Perm \u03b1) : support \u03c3\u207b\u00b9 = \u03c3.support", "start": [350, 1], "end": [352, 96], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.apply_mem_support", "code": "theorem apply_mem_support {x : \u03b1} : f x \u2208 f.support \u2194 x \u2208 f.support", "start": [356, 1], "end": [357, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.apply_pow_apply_eq_iff", "code": "@[simp]\ntheorem apply_pow_apply_eq_iff (f : Perm \u03b1) (n : \u2115) {x : \u03b1} :\n    f ((f ^ n) x) = (f ^ n) x \u2194 f x = x", "start": [361, 1], "end": [364, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_apply_mem_support", "code": "theorem pow_apply_mem_support {n : \u2115} {x : \u03b1} : (f ^ n) x \u2208 f.support \u2194 x \u2208 f.support", "start": [367, 1], "end": [368, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.apply_zpow_apply_eq_iff", "code": "@[simp]\ntheorem apply_zpow_apply_eq_iff (f : Perm \u03b1) (n : \u2124) {x : \u03b1} :\n    f ((f ^ n) x) = (f ^ n) x \u2194 f x = x", "start": [372, 1], "end": [375, 68], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.zpow_apply_mem_support", "code": "theorem zpow_apply_mem_support {n : \u2124} {x : \u03b1} : (f ^ n) x \u2208 f.support \u2194 x \u2208 f.support", "start": [378, 1], "end": [379, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_eq_on_of_mem_support", "code": "theorem pow_eq_on_of_mem_support (h : \u2200 x \u2208 f.support \u2229 g.support, f x = g x) (k : \u2115) :\n    \u2200 x \u2208 f.support \u2229 g.support, (f ^ k) x = (g ^ k) x", "start": [382, 1], "end": [388, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_iff_disjoint_support", "code": "theorem disjoint_iff_disjoint_support : Disjoint f g \u2194 _root_.Disjoint f.support g.support", "start": [391, 1], "end": [393, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.disjoint_support", "code": "theorem Disjoint.disjoint_support (h : Disjoint f g) : _root_.Disjoint f.support g.support", "start": [396, 1], "end": [397, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.support_mul", "code": "theorem Disjoint.support_mul (h : Disjoint f g) : (f * g).support = f.support \u222a g.support", "start": [400, 1], "end": [405, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_prod_of_pairwise_disjoint", "code": "theorem support_prod_of_pairwise_disjoint (l : List (Perm \u03b1)) (h : l.Pairwise Disjoint) :\n    l.prod.support = (l.map support).foldr (\u00b7 \u2294 \u00b7) \u22a5", "start": [408, 1], "end": [414, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_prod_le", "code": "theorem support_prod_le (l : List (Perm \u03b1)) : l.prod.support \u2264 (l.map support).foldr (\u00b7 \u2294 \u00b7) \u22a5", "start": [417, 1], "end": [422, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_zpow_le", "code": "theorem support_zpow_le (\u03c3 : Perm \u03b1) (n : \u2124) : (\u03c3 ^ n).support \u2264 \u03c3.support", "start": [425, 1], "end": [426, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_swap", "code": "@[simp]\ntheorem support_swap {x y : \u03b1} (h : x \u2260 y) : support (swap x y) = {x, y}", "start": [429, 1], "end": [436, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_swap_iff", "code": "theorem support_swap_iff (x y : \u03b1) : support (swap x y) = {x, y} \u2194 x \u2260 y", "start": [439, 1], "end": [448, 17], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_swap_mul_swap", "code": "theorem support_swap_mul_swap {x y z : \u03b1} (h : List.Nodup [x, y, z]) :\n    support (swap x y * swap y z) = {x, y, z}", "start": [451, 1], "end": [467, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_swap_mul_ge_support_diff", "code": "theorem support_swap_mul_ge_support_diff (f : Perm \u03b1) (x y : \u03b1) :\n    f.support \\ {x, y} \u2264 (swap x y * f).support", "start": [470, 1], "end": [478, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_swap_mul_eq", "code": "theorem support_swap_mul_eq (f : Perm \u03b1) (x : \u03b1) (h : f (f x) \u2260 x) :\n    (swap x (f x) * f).support = f.support \\ {x}", "start": [481, 1], "end": [492, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_support_swap_mul_imp_mem_support_ne", "code": "theorem mem_support_swap_mul_imp_mem_support_ne {x y : \u03b1} (hy : y \u2208 support (swap x (f x) * f)) :\n    y \u2208 support f \u2227 y \u2260 x", "start": [495, 1], "end": [503, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mem_imp", "code": "theorem Disjoint.mem_imp (h : Disjoint f g) {x : \u03b1} (hx : x \u2208 f.support) : x \u2209 g.support", "start": [506, 1], "end": [507, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.eq_on_support_mem_disjoint", "code": "theorem eq_on_support_mem_disjoint {l : List (Perm \u03b1)} (h : f \u2208 l) (hl : l.Pairwise Disjoint) :\n    \u2200 x \u2208 f.support, f x = l.prod x", "start": [510, 1], "end": [522, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.mono", "code": "theorem Disjoint.mono {x y : Perm \u03b1} (h : Disjoint f g) (hf : x.support \u2264 f.support)\n    (hg : y.support \u2264 g.support) : Disjoint x y", "start": [525, 1], "end": [528, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_le_prod_of_mem", "code": "theorem support_le_prod_of_mem {l : List (Perm \u03b1)} (h : f \u2208 l) (hl : l.Pairwise Disjoint) :\n    f.support \u2264 l.prod.support", "start": [531, 1], "end": [534, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_extend_domain", "code": "@[simp]\ntheorem support_extend_domain (f : \u03b1 \u2243 Subtype p) {g : Perm \u03b1} :\n    support (g.extendDomain f) = g.support.map f.asEmbedding", "start": [541, 1], "end": [564, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_extend_domain", "code": "theorem card_support_extend_domain (f : \u03b1 \u2243 Subtype p) {g : Perm \u03b1} :\n    (g.extendDomain f).support.card = g.support.card", "start": [567, 1], "end": [568, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_eq_zero", "code": "theorem card_support_eq_zero {f : Perm \u03b1} : f.support.card = 0 \u2194 f = 1", "start": [576, 1], "end": [577, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_lt_card_support_of_ne_one", "code": "theorem one_lt_card_support_of_ne_one {f : Perm \u03b1} (h : f \u2260 1) : 1 < f.support.card", "start": [580, 1], "end": [585, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_ne_one", "code": "theorem card_support_ne_one (f : Perm \u03b1) : f.support.card \u2260 1", "start": [588, 1], "end": [591, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_le_one", "code": "@[simp]\ntheorem card_support_le_one {f : Perm \u03b1} : f.support.card \u2264 1 \u2194 f = 1", "start": [594, 1], "end": [597, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.two_le_card_support_of_ne_one", "code": "theorem two_le_card_support_of_ne_one {f : Perm \u03b1} (h : f \u2260 1) : 2 \u2264 f.support.card", "start": [600, 1], "end": [601, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_swap_mul", "code": "theorem card_support_swap_mul {f : Perm \u03b1} {x : \u03b1} (hx : f x \u2260 x) :\n    (swap x (f x) * f).support.card < f.support.card", "start": [604, 1], "end": [608, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_swap", "code": "theorem card_support_swap {x y : \u03b1} (hxy : x \u2260 y) : (swap x y).support.card = 2", "start": [611, 1], "end": [613, 68], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_eq_two", "code": "@[simp]\ntheorem card_support_eq_two {f : Perm \u03b1} : f.support.card = 2 \u2194 IsSwap f", "start": [616, 1], "end": [633, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.card_support_mul", "code": "theorem Disjoint.card_support_mul (h : Disjoint f g) :\n    (f * g).support.card = f.support.card + g.support.card", "start": [636, 1], "end": [642, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_prod_list_of_pairwise_disjoint", "code": "theorem card_support_prod_list_of_pairwise_disjoint {l : List (Perm \u03b1)} (h : l.Pairwise Disjoint) :\n    l.prod.support.card = (l.map (Finset.card \u2218 support)).sum", "start": [645, 1], "end": [651, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_subtype_perm", "code": "@[simp]\ntheorem support_subtype_perm [DecidableEq \u03b1] {s : Finset \u03b1} (f : Perm \u03b1) (h) :\n    ((f.subtypePerm h : Perm { x // x \u2208 s }).support) =\n    (s.attach.filter ((fun x => decide (f x \u2260 x))) : Finset { x // x \u2208 s })", "start": [658, 1], "end": [663, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/OrderOfElement.lean", "imports": ["Mathlib/Data/Set/Intervals/Infinite.lean", "Mathlib/Dynamics/PeriodicPts.lean", "Mathlib/GroupTheory/Index.lean", "Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Hom/Iterate.lean", "Mathlib/Data/Set/Pointwise/Basic.lean"], "premises": [{"full_name": "isPeriodicPt_mul_iff_pow_eq_one", "code": "@[to_additive]\ntheorem isPeriodicPt_mul_iff_pow_eq_one (x : G) : IsPeriodicPt ((\u00b7 * \u00b7) x) n 1 \u2194 x ^ n = 1", "start": [46, 1], "end": [48, 70], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder", "code": "@[to_additive \"`IsOfFinAddOrder` is a predicate on an element `a` of an\nadditive monoid to be of finite order, i.e. there exists `n \u2265 1` such that `n \u2022 a = 0`.\"]\ndef IsOfFinOrder (x : G) : Prop :=\n  (1 : G) \u2208 periodicPts ((\u00b7 * \u00b7) x)", "start": [52, 1], "end": [57, 36], "kind": "commanddeclaration"}, {"full_name": "isOfFinAddOrder_ofMul_iff", "code": "theorem isOfFinAddOrder_ofMul_iff : IsOfFinAddOrder (Additive.ofMul x) \u2194 IsOfFinOrder x", "start": [61, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "isOfFinOrder_ofAdd_iff", "code": "theorem isOfFinOrder_ofAdd_iff : IsOfFinOrder (Multiplicative.ofAdd a) \u2194 IsOfFinAddOrder a", "start": [65, 1], "end": [66, 10], "kind": "commanddeclaration"}, {"full_name": "isOfFinOrder_iff_pow_eq_one", "code": "@[to_additive]\ntheorem isOfFinOrder_iff_pow_eq_one (x : G) : IsOfFinOrder x \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1", "start": [69, 1], "end": [71, 72], "kind": "commanddeclaration"}, {"full_name": "not_isOfFinOrder_of_injective_pow", "code": "@[to_additive \"See also `injective_nsmul_iff_not_isOfFinAddOrder`.\"]\ntheorem not_isOfFinOrder_of_injective_pow {x : G} (h : Injective fun n : \u2115 => x ^ n) :\n    \u00acIsOfFinOrder x", "start": [75, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "isOfFinOrder_iff_coe", "code": "@[to_additive \"Elements of finite order are of finite order in submonoids.\"]\ntheorem isOfFinOrder_iff_coe (H : Submonoid G) (x : H) : IsOfFinOrder x \u2194 IsOfFinOrder (x : G)", "start": [87, 1], "end": [91, 12], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.isOfFinOrder", "code": "@[to_additive \"The image of an element of finite additive order has finite additive order.\"]\ntheorem MonoidHom.isOfFinOrder [Monoid H] (f : G \u2192* H) {x : G} (h : IsOfFinOrder x) :\n    IsOfFinOrder <| f x", "start": [95, 1], "end": [101, 56], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.apply", "code": "@[to_additive \"If a direct product has finite additive order then so does each component.\"]\ntheorem IsOfFinOrder.apply {\u03b7 : Type*} {Gs : \u03b7 \u2192 Type*} [\u2200 i, Monoid (Gs i)] {x : \u2200 i, Gs i}\n    (h : IsOfFinOrder x) : \u2200 i, IsOfFinOrder (x i)", "start": [105, 1], "end": [110, 91], "kind": "commanddeclaration"}, {"full_name": "isOfFinOrder_one", "code": "@[to_additive \"0 is of finite order in any additive monoid.\"]\ntheorem isOfFinOrder_one : IsOfFinOrder (1 : G)", "start": [114, 1], "end": [117, 66], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.groupPowers", "code": "@[to_additive IsOfFinAddOrder.addGroupMultiples \"The additive submonoid generated by an element is\nan additive group if that element has finite order.\"]\nnoncomputable abbrev IsOfFinOrder.groupPowers (hx : IsOfFinOrder x) :\n    Group (Submonoid.powers x) := by\n  obtain \u27e8hpos, hx\u27e9 := ((isOfFinOrder_iff_pow_eq_one x).1 hx).choose_spec\n  exact Submonoid.groupPowers hpos hx", "start": [121, 1], "end": [127, 38], "kind": "commanddeclaration"}, {"full_name": "orderOf", "code": "@[to_additive\n  \"`addOrderOf a` is the order of the element `a`, i.e. the `n \u2265 1`, s.t. `n \u2022 a = 0` if it\n  exists. Otherwise, i.e. if `a` is of infinite order, then `addOrderOf a` is `0` by convention.\"]\nnoncomputable def orderOf (x : G) : \u2115 :=\n  minimalPeriod (x * \u00b7) 1", "start": [131, 1], "end": [137, 26], "kind": "commanddeclaration"}, {"full_name": "addOrderOf_ofMul_eq_orderOf", "code": "@[simp]\ntheorem addOrderOf_ofMul_eq_orderOf (x : G) : addOrderOf (Additive.ofMul x) = orderOf x", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "orderOf_ofAdd_eq_addOrderOf", "code": "@[simp]\ntheorem orderOf_ofAdd_eq_addOrderOf (a : A) : orderOf (Multiplicative.ofAdd a) = addOrderOf a", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "orderOf_pos'", "code": "@[to_additive]\ntheorem orderOf_pos' (h : IsOfFinOrder x) : 0 < orderOf x", "start": [151, 1], "end": [153, 41], "kind": "commanddeclaration"}, {"full_name": "pow_orderOf_eq_one", "code": "@[to_additive addOrderOf_nsmul_eq_zero]\ntheorem pow_orderOf_eq_one (x : G) : x ^ orderOf x = 1", "start": [157, 1], "end": [162, 54], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_zero", "code": "@[to_additive]\ntheorem orderOf_eq_zero (h : \u00acIsOfFinOrder x) : orderOf x = 0", "start": [166, 1], "end": [168, 40], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_zero_iff", "code": "@[to_additive]\ntheorem orderOf_eq_zero_iff : orderOf x = 0 \u2194 \u00acIsOfFinOrder x", "start": [172, 1], "end": [174, 55], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_zero_iff'", "code": "@[to_additive]\ntheorem orderOf_eq_zero_iff' : orderOf x = 0 \u2194 \u2200 n : \u2115, 0 < n \u2192 x ^ n \u2260 1", "start": [178, 1], "end": [180, 82], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_iff", "code": "@[to_additive]\ntheorem orderOf_eq_iff {n} (h : 0 < n) :\n    orderOf x = n \u2194 x ^ n = 1 \u2227 \u2200 m, m < n \u2192 0 < m \u2192 x ^ m \u2260 1", "start": [184, 1], "end": [196, 24], "kind": "commanddeclaration"}, {"full_name": "orderOf_pos_iff", "code": "@[to_additive\n      \"A group element has finite additive order iff its order is positive.\"]\ntheorem orderOf_pos_iff : 0 < orderOf x \u2194 IsOfFinOrder x", "start": [200, 1], "end": [204, 60], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.mono", "code": "@[to_additive]\ntheorem IsOfFinOrder.mono [Monoid \u03b2] {y : \u03b2} (hx : IsOfFinOrder x) (h : orderOf y \u2223 orderOf x) :\n    IsOfFinOrder y", "start": [208, 1], "end": [210, 90], "kind": "commanddeclaration"}, {"full_name": "pow_ne_one_of_lt_orderOf'", "code": "@[to_additive]\ntheorem pow_ne_one_of_lt_orderOf' (n0 : n \u2260 0) (h : n < orderOf x) : x ^ n \u2260 1", "start": [214, 1], "end": [216, 95], "kind": "commanddeclaration"}, {"full_name": "orderOf_le_of_pow_eq_one", "code": "@[to_additive]\ntheorem orderOf_le_of_pow_eq_one (hn : 0 < n) (h : x ^ n = 1) : orderOf x \u2264 n", "start": [220, 1], "end": [222, 78], "kind": "commanddeclaration"}, {"full_name": "orderOf_one", "code": "@[to_additive (attr := simp)]\ntheorem orderOf_one : orderOf (1 : G) = 1", "start": [226, 1], "end": [228, 65], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_one_iff", "code": "@[to_additive (attr := simp) AddMonoid.addOrderOf_eq_one_iff]\ntheorem orderOf_eq_one_iff : orderOf x = 1 \u2194 x = 1", "start": [232, 1], "end": [234, 71], "kind": "commanddeclaration"}, {"full_name": "pow_eq_mod_orderOf", "code": "@[to_additive]\ntheorem pow_eq_mod_orderOf {n : \u2115} : x ^ n = x ^ (n % orderOf x)", "start": [238, 1], "end": [242, 78], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_of_pow_eq_one", "code": "@[to_additive]\ntheorem orderOf_dvd_of_pow_eq_one (h : x ^ n = 1) : orderOf x \u2223 n", "start": [246, 1], "end": [248, 77], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_iff_pow_eq_one", "code": "@[to_additive]\ntheorem orderOf_dvd_iff_pow_eq_one {n : \u2115} : orderOf x \u2223 n \u2194 x ^ n = 1", "start": [252, 1], "end": [255, 31], "kind": "commanddeclaration"}, {"full_name": "orderOf_pow_dvd", "code": "@[to_additive addOrderOf_smul_dvd]\ntheorem orderOf_pow_dvd (n : \u2115) : orderOf (x ^ n) \u2223 orderOf x", "start": [259, 1], "end": [261, 79], "kind": "commanddeclaration"}, {"full_name": "pow_injective_of_lt_orderOf", "code": "@[to_additive]\ntheorem pow_injective_of_lt_orderOf (x : G) (hn : n < orderOf x) (hm : m < orderOf x)\n    (eq : x ^ n = x ^ m) :\n    n = m", "start": [265, 1], "end": [269, 90], "kind": "commanddeclaration"}, {"full_name": "mem_powers_iff_mem_range_order_of'", "code": "@[to_additive mem_multiples_iff_mem_range_addOrderOf']\ntheorem mem_powers_iff_mem_range_order_of' [DecidableEq G] (hx : 0 < orderOf x) :\n    y \u2208 Submonoid.powers x \u2194 y \u2208 (Finset.range (orderOf x)).image ((x ^ \u00b7) : \u2115 \u2192 G)", "start": [273, 1], "end": [276, 87], "kind": "commanddeclaration"}, {"full_name": "pow_eq_one_iff_modEq", "code": "@[to_additive]\ntheorem pow_eq_one_iff_modEq : x ^ n = 1 \u2194 n \u2261 0 [MOD orderOf x]", "start": [280, 1], "end": [282, 54], "kind": "commanddeclaration"}, {"full_name": "orderOf_map_dvd", "code": "@[to_additive]\ntheorem orderOf_map_dvd {H : Type*} [Monoid H] (\u03c8 : G \u2192* H) (x : G) :\n    orderOf (\u03c8 x) \u2223 orderOf x", "start": [286, 1], "end": [291, 16], "kind": "commanddeclaration"}, {"full_name": "exists_pow_eq_self_of_coprime", "code": "@[to_additive]\ntheorem exists_pow_eq_self_of_coprime (h : n.Coprime (orderOf x)) : \u2203 m : \u2115, (x ^ n) ^ m = x", "start": [295, 1], "end": [303, 63], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_of_pow_and_pow_div_prime", "code": "@[to_additive addOrderOf_eq_of_nsmul_and_div_prime_nsmul \"If `n * x = 0`, but `n/p * x \u2260 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"]\ntheorem orderOf_eq_of_pow_and_pow_div_prime (hn : 0 < n) (hx : x ^ n = 1)\n    (hd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 n \u2192 x ^ (n / p) \u2260 1) : orderOf x = n", "start": [307, 1], "end": [328, 39], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_orderOf_iff", "code": "@[to_additive]\ntheorem orderOf_eq_orderOf_iff {H : Type*} [Monoid H] {y : H} :\n    orderOf x = orderOf y \u2194 \u2200 n : \u2115, x ^ n = 1 \u2194 y ^ n = 1", "start": [332, 1], "end": [335, 93], "kind": "commanddeclaration"}, {"full_name": "orderOf_injective", "code": "@[to_additive]\ntheorem orderOf_injective {H : Type*} [Monoid H] (f : G \u2192* H) (hf : Function.Injective f) (x : G) :\n    orderOf (f x) = orderOf x", "start": [339, 1], "end": [342, 86], "kind": "commanddeclaration"}, {"full_name": "orderOf_submonoid", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem orderOf_submonoid {H : Submonoid G} (y : H) : orderOf (y : G) = orderOf y", "start": [346, 1], "end": [348, 54], "kind": "commanddeclaration"}, {"full_name": "orderOf_units", "code": "@[to_additive]\ntheorem orderOf_units {y : G\u02e3} : orderOf (y : G) = orderOf y", "start": [352, 1], "end": [354, 49], "kind": "commanddeclaration"}, {"full_name": "orderOf_pow'", "code": "@[to_additive]\ntheorem orderOf_pow' (h : n \u2260 0) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n", "start": [360, 1], "end": [363, 62], "kind": "commanddeclaration"}, {"full_name": "orderOf_pow''", "code": "@[to_additive]\ntheorem orderOf_pow'' (h : IsOfFinOrder x) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n", "start": [369, 1], "end": [372, 63], "kind": "commanddeclaration"}, {"full_name": "orderOf_pow_coprime", "code": "@[to_additive]\ntheorem orderOf_pow_coprime (h : (orderOf y).Coprime m) : orderOf (y ^ m) = orderOf y", "start": [376, 1], "end": [380, 84], "kind": "commanddeclaration"}, {"full_name": "Commute.orderOf_mul_dvd_lcm", "code": "@[to_additive]\ntheorem orderOf_mul_dvd_lcm : orderOf (x * y) \u2223 Nat.lcm (orderOf x) (orderOf y)", "start": [388, 1], "end": [391, 83], "kind": "commanddeclaration"}, {"full_name": "Commute.orderOf_dvd_lcm_mul", "code": "@[to_additive]\ntheorem orderOf_dvd_lcm_mul : orderOf y \u2223 Nat.lcm (orderOf x) (orderOf (x * y))", "start": [395, 1], "end": [405, 88], "kind": "commanddeclaration"}, {"full_name": "Commute.orderOf_mul_dvd_mul_orderOf", "code": "@[to_additive addOrderOf_add_dvd_mul_addOrderOf]\ntheorem orderOf_mul_dvd_mul_orderOf : orderOf (x * y) \u2223 orderOf x * orderOf y", "start": [409, 1], "end": [411, 52], "kind": "commanddeclaration"}, {"full_name": "Commute.orderOf_mul_eq_mul_orderOf_of_coprime", "code": "@[to_additive addOrderOf_add_eq_mul_addOrderOf_of_coprime]\ntheorem orderOf_mul_eq_mul_orderOf_of_coprime (hco : (orderOf x).Coprime (orderOf y)) :\n    orderOf (x * y) = orderOf x * orderOf y", "start": [415, 1], "end": [419, 80], "kind": "commanddeclaration"}, {"full_name": "Commute.isOfFinOrder_mul", "code": "@[to_additive \"Commuting elements of finite additive order are closed under addition.\"]\ntheorem isOfFinOrder_mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)", "start": [423, 1], "end": [427, 99], "kind": "commanddeclaration"}, {"full_name": "Commute.orderOf_mul_eq_right_of_forall_prime_mul_dvd", "code": "@[to_additive addOrderOf_add_eq_right_of_forall_prime_mul_dvd\n  \"If each prime factor of\n  `addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\n  then `x + y` has the same order as `y`.\"]\ntheorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (hy : IsOfFinOrder y)\n    (hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 orderOf x \u2192 p * orderOf x \u2223 orderOf y) :\n    orderOf (x * y) = orderOf y", "start": [431, 1], "end": [448, 83], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_prime", "code": "@[to_additive]\ntheorem orderOf_eq_prime (hg : x ^ p = 1) (hg1 : x \u2260 1) : orderOf x = p", "start": [458, 1], "end": [461, 34], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_prime_pow", "code": "@[to_additive addOrderOf_eq_prime_pow]\ntheorem orderOf_eq_prime_pow (hnot : \u00acx ^ p ^ n = 1) (hfin : x ^ p ^ (n + 1) = 1) :\n    orderOf x = p ^ (n + 1)", "start": [465, 1], "end": [468, 77], "kind": "commanddeclaration"}, {"full_name": "exists_orderOf_eq_prime_pow_iff", "code": "@[to_additive exists_addOrderOf_eq_prime_pow_iff]\ntheorem exists_orderOf_eq_prime_pow_iff :\n    (\u2203 k : \u2115, orderOf x = p ^ k) \u2194 \u2203 m : \u2115, x ^ (p : \u2115) ^ m = 1", "start": [472, 1], "end": [477, 19], "kind": "commanddeclaration"}, {"full_name": "pow_eq_pow_iff_modEq", "code": "@[to_additive]\ntheorem pow_eq_pow_iff_modEq : x ^ n = x ^ m \u2194 n \u2261 m [MOD orderOf x]", "start": [489, 1], "end": [495, 83], "kind": "commanddeclaration"}, {"full_name": "injective_pow_iff_not_isOfFinOrder", "code": "@[to_additive (attr := simp)]\ntheorem injective_pow_iff_not_isOfFinOrder {x : G} :\n    (Injective fun n : \u2115 => x ^ n) \u2194 \u00acIsOfFinOrder x", "start": [499, 1], "end": [503, 79], "kind": "commanddeclaration"}, {"full_name": "pow_inj_mod", "code": "@[to_additive]\ntheorem pow_inj_mod {n m : \u2115} : x ^ n = x ^ m \u2194 n % orderOf x = m % orderOf x", "start": [507, 1], "end": [509, 25], "kind": "commanddeclaration"}, {"full_name": "pow_inj_iff_of_orderOf_eq_zero", "code": "@[to_additive]\ntheorem pow_inj_iff_of_orderOf_eq_zero (h : orderOf x = 0) {n m : \u2115} : x ^ n = x ^ m \u2194 n = m", "start": [513, 1], "end": [515, 47], "kind": "commanddeclaration"}, {"full_name": "infinite_not_isOfFinOrder", "code": "@[to_additive]\ntheorem infinite_not_isOfFinOrder {x : G} (h : \u00acIsOfFinOrder x) :\n    { y : G | \u00acIsOfFinOrder y }.Infinite", "start": [519, 1], "end": [535, 70], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.inv", "code": "@[to_additive \"Inverses of elements of finite additive order have finite additive order.\"]\ntheorem IsOfFinOrder.inv {x : G} (hx : IsOfFinOrder x) : IsOfFinOrder x\u207b\u00b9", "start": [545, 1], "end": [550, 57], "kind": "commanddeclaration"}, {"full_name": "isOfFinOrder_inv_iff", "code": "@[to_additive (attr := simp) \"Inverses of elements of finite additive order\nhave finite additive order.\"]\ntheorem isOfFinOrder_inv_iff {x : G} : IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x", "start": [554, 1], "end": [558, 49], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_iff_zpow_eq_one", "code": "@[to_additive]\ntheorem orderOf_dvd_iff_zpow_eq_one : (orderOf x : \u2124) \u2223 i \u2194 x ^ i = 1", "start": [562, 1], "end": [566, 96], "kind": "commanddeclaration"}, {"full_name": "orderOf_inv", "code": "@[to_additive (attr := simp)]\ntheorem orderOf_inv (x : G) : orderOf x\u207b\u00b9 = orderOf x", "start": [570, 1], "end": [571, 90], "kind": "commanddeclaration"}, {"full_name": "orderOf_subgroup", "code": "@[to_additive (attr := norm_cast)] theorem orderOf_subgroup {H : Subgroup G} (y : H) : orderOf (y : G) = orderOf y", "start": [575, 1], "end": [577, 54], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_mod_orderOf", "code": "@[to_additive]\ntheorem zpow_eq_mod_orderOf : x ^ i = x ^ (i % (orderOf x : \u2124))", "start": [581, 1], "end": [585, 86], "kind": "commanddeclaration"}, {"full_name": "zpow_pow_orderOf", "code": "@[to_additive (attr := simp) zsmul_smul_addOrderOf]\ntheorem zpow_pow_orderOf : (x ^ i) ^ orderOf x = 1", "start": [589, 1], "end": [593, 44], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.zpow", "code": "@[to_additive]\ntheorem IsOfFinOrder.zpow (h : IsOfFinOrder x) {i : \u2124} : IsOfFinOrder (x ^ i)", "start": [597, 1], "end": [599, 84], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.of_mem_zpowers", "code": "@[to_additive IsOfFinAddOrder.of_mem_zmultiples]\ntheorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y \u2208 Subgroup.zpowers x) :\n    IsOfFinOrder y", "start": [603, 1], "end": [607, 15], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_of_mem_zpowers", "code": "@[to_additive addOrderOf_dvd_of_mem_zmultiples]\ntheorem orderOf_dvd_of_mem_zpowers (h : y \u2208 Subgroup.zpowers x) : orderOf y \u2223 orderOf x", "start": [611, 1], "end": [615, 25], "kind": "commanddeclaration"}, {"full_name": "smul_eq_self_of_mem_zpowers", "code": "theorem smul_eq_self_of_mem_zpowers {\u03b1 : Type*} [MulAction G \u03b1] (hx : x \u2208 Subgroup.zpowers y)\n    {a : \u03b1} (hs : y \u2022 a = a) : x \u2022 a = a", "start": [619, 1], "end": [624, 53], "kind": "commanddeclaration"}, {"full_name": "vadd_eq_self_of_mem_zmultiples", "code": "theorem vadd_eq_self_of_mem_zmultiples {\u03b1 G : Type*} [AddGroup G] [AddAction G \u03b1] {x y : G}\n    (hx : x \u2208 AddSubgroup.zmultiples y) {a : \u03b1} (hs : y +\u1d65 a = a) : x +\u1d65 a = a", "start": [627, 1], "end": [629, 68], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.mul", "code": "@[to_additive \"Elements of finite additive order are closed under addition.\"]\ntheorem IsOfFinOrder.mul (hx : IsOfFinOrder x) (hy : IsOfFinOrder y) : IsOfFinOrder (x * y)", "start": [640, 1], "end": [643, 43], "kind": "commanddeclaration"}, {"full_name": "sum_card_orderOf_eq_card_pow_eq_one", "code": "@[to_additive]\ntheorem sum_card_orderOf_eq_card_pow_eq_one [Fintype G] [DecidableEq G] (hn : n \u2260 0) :\n    (\u2211 m in (Finset.range n.succ).filter (\u00b7 \u2223 n),\n        (Finset.univ.filter fun x : G => orderOf x = m).card) =\n      (Finset.univ.filter fun x : G => x ^ n = 1).card", "start": [655, 1], "end": [678, 87], "kind": "commanddeclaration"}, {"full_name": "orderOf_le_card_univ", "code": "@[to_additive ]\ntheorem orderOf_le_card_univ [Fintype G] : orderOf x \u2264 Fintype.card G", "start": [682, 1], "end": [685, 40], "kind": "commanddeclaration"}, {"full_name": "exists_pow_eq_one", "code": "@[to_additive]\ntheorem exists_pow_eq_one [Finite G] (x : G) : IsOfFinOrder x", "start": [697, 1], "end": [701, 79], "kind": "commanddeclaration"}, {"full_name": "orderOf_pos", "code": "@[to_additive \"This is the same as `addOrderOf_pos'` but with one fewer explicit\nassumption since this is automatic in case of a finite cancellative additive monoid.\"]\ntheorem orderOf_pos [Finite G] (x : G) : 0 < orderOf x", "start": [705, 1], "end": [710, 37], "kind": "commanddeclaration"}, {"full_name": "orderOf_pow", "code": "@[to_additive \"This is the same as `addOrderOf_nsmul'` and\n`addOrderOf_nsmul` but with one assumption less which is automatic in the case of a\nfinite cancellative additive monoid.\"]\ntheorem orderOf_pow [Finite G] (x : G) : orderOf (x ^ n) = orderOf x / gcd (orderOf x) n", "start": [716, 1], "end": [722, 42], "kind": "commanddeclaration"}, {"full_name": "mem_powers_iff_mem_range_orderOf", "code": "@[to_additive mem_multiples_iff_mem_range_addOrderOf]\ntheorem mem_powers_iff_mem_range_orderOf [Finite G] [DecidableEq G] :\n    y \u2208 Submonoid.powers x \u2194 y \u2208 (Finset.range (orderOf x)).image ((\u00b7 ^ \u00b7) x : \u2115 \u2192 G)", "start": [726, 1], "end": [729, 100], "kind": "commanddeclaration"}, {"full_name": "decidablePowers", "code": "@[to_additive decidableMultiples]\nnoncomputable instance decidablePowers : DecidablePred (\u00b7 \u2208 Submonoid.powers x) :=\n  Classical.decPred _", "start": [733, 1], "end": [735, 22], "kind": "commanddeclaration"}, {"full_name": "finEquivPowers", "code": "@[to_additive finEquivMultiples\n  \"The equivalence between `Fin (addOrderOf a)` and\n  `AddSubmonoid.multiples a`, sending `i` to `i \u2022 a`.\"]\nnoncomputable def finEquivPowers [Finite G] (x : G) :\n    Fin (orderOf x) \u2243 (Submonoid.powers x : Set G) :=\n  Equiv.ofBijective (fun n => \u27e8x ^ (n:\u2115), \u27e8n, rfl\u27e9\u27e9)\n    \u27e8fun \u27e8_, h\u2081\u27e9 \u27e8_, h\u2082\u27e9 ij =>\n      Fin.ext (pow_injective_of_lt_orderOf x h\u2081 h\u2082 (Subtype.mk_eq_mk.1 ij)), fun \u27e8_, i, rfl\u27e9 =>\n      \u27e8\u27e8i % orderOf x, mod_lt i (orderOf_pos x)\u27e9, Subtype.eq pow_eq_mod_orderOf.symm\u27e9\u27e9", "start": [739, 1], "end": [748, 87], "kind": "commanddeclaration"}, {"full_name": "finEquivPowers_apply", "code": "@[to_additive (attr := simp, nolint simpNF) finEquivMultiples_apply]\ntheorem finEquivPowers_apply [Finite G] {x : G} {n : Fin (orderOf x)} :\n    finEquivPowers x n = \u27e8x ^ (n : \u2115), n, rfl\u27e9", "start": [753, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "finEquivPowers_symm_apply", "code": "@[to_additive (attr := simp, nolint simpNF) finEquivMultiples_symm_apply]\ntheorem finEquivPowers_symm_apply [Finite G] (x : G) (n : \u2115) {hn : \u2203 m : \u2115, x ^ m = x ^ n} :\n    (finEquivPowers x).symm \u27e8x ^ n, hn\u27e9 = \u27e8n % orderOf x, Nat.mod_lt _ (orderOf_pos x)\u27e9", "start": [761, 1], "end": [764, 99], "kind": "commanddeclaration"}, {"full_name": "powersEquivPowers", "code": "@[to_additive multiplesEquivMultiples\n  \"The equivalence between `Submonoid.multiples` of two elements `a, b` of the same additive order,\n  mapping `i \u2022 a` to `i \u2022 b`.\"]\nnoncomputable def powersEquivPowers [Finite G] (h : orderOf x = orderOf y) :\n    (Submonoid.powers x : Set G) \u2243 (Submonoid.powers y : Set G) :=\n  (finEquivPowers x).symm.trans ((Fin.castIso h).toEquiv.trans (finEquivPowers y))", "start": [768, 1], "end": [775, 83], "kind": "commanddeclaration"}, {"full_name": "powersEquivPowers_apply", "code": "@[to_additive (attr := simp, nolint simpNF) multiplesEquivMultiples_apply]\ntheorem powersEquivPowers_apply [Finite G] (h : orderOf x = orderOf y) (n : \u2115) :\n    powersEquivPowers h \u27e8x ^ n, n, rfl\u27e9 = \u27e8y ^ n, n, rfl\u27e9", "start": [781, 1], "end": [786, 11], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_card_powers", "code": "@[to_additive addOrderOf_eq_card_multiples]\ntheorem orderOf_eq_card_powers [Fintype G] :\n    orderOf x = Fintype.card (Submonoid.powers x : Set G)", "start": [796, 1], "end": [799, 83], "kind": "commanddeclaration"}, {"full_name": "exists_zpow_eq_one", "code": "@[to_additive]\ntheorem exists_zpow_eq_one [Finite G] (x : G) : \u2203 (i : \u2124) (_ : i \u2260 0), x ^ (i : \u2124) = 1", "start": [809, 1], "end": [814, 51], "kind": "commanddeclaration"}, {"full_name": "mem_powers_iff_mem_zpowers", "code": "@[to_additive mem_multiples_iff_mem_zmultiples]\ntheorem mem_powers_iff_mem_zpowers [Finite G] : y \u2208 Submonoid.powers x \u2194 y \u2208 zpowers x", "start": [820, 1], "end": [827, 31], "kind": "commanddeclaration"}, {"full_name": "powers_eq_zpowers", "code": "@[to_additive multiples_eq_zmultiples]\ntheorem powers_eq_zpowers [Finite G] (x : G) : (Submonoid.powers x : Set G) = zpowers x", "start": [831, 1], "end": [833, 46], "kind": "commanddeclaration"}, {"full_name": "mem_zpowers_iff_mem_range_orderOf", "code": "@[to_additive mem_zmultiples_iff_mem_range_addOrderOf]\ntheorem mem_zpowers_iff_mem_range_orderOf [Finite G] [DecidableEq G] :\n    y \u2208 Subgroup.zpowers x \u2194 y \u2208 (Finset.range (orderOf x)).image ((\u00b7 ^ \u00b7) x : \u2115 \u2192 G)", "start": [837, 1], "end": [840, 70], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_one_iff_modEq", "code": "@[to_additive]\ntheorem zpow_eq_one_iff_modEq {n : \u2124} : x ^ n = 1 \u2194 n \u2261 0 [ZMOD orderOf x]", "start": [844, 1], "end": [846, 59], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_zpow_iff_modEq", "code": "@[to_additive]\ntheorem zpow_eq_zpow_iff_modEq {m n : \u2124} : x ^ m = x ^ n \u2194 m \u2261 n [ZMOD orderOf x]", "start": [850, 1], "end": [853, 23], "kind": "commanddeclaration"}, {"full_name": "injective_zpow_iff_not_isOfFinOrder", "code": "@[to_additive (attr := simp)]\ntheorem injective_zpow_iff_not_isOfFinOrder : (Injective fun n : \u2124 => x ^ n) \u2194 \u00acIsOfFinOrder x", "start": [857, 1], "end": [863, 98], "kind": "commanddeclaration"}, {"full_name": "decidableZpowers", "code": "@[to_additive decidableZmultiples]\nnoncomputable instance decidableZpowers : DecidablePred (\u00b7 \u2208 Subgroup.zpowers x) :=\n  Classical.decPred _", "start": [867, 1], "end": [869, 22], "kind": "commanddeclaration"}, {"full_name": "finEquivZpowers", "code": "@[to_additive finEquivZmultiples \"The equivalence between `Fin (addOrderOf a)` and\n`Subgroup.zmultiples a`, sending `i` to `i \u2022 a`.\"]\nnoncomputable def finEquivZpowers [Finite G] (x : G) :\n    Fin (orderOf x) \u2243 (Subgroup.zpowers x : Set G) :=\n  (finEquivPowers x).trans (Equiv.Set.ofEq (powers_eq_zpowers x))", "start": [873, 1], "end": [878, 66], "kind": "commanddeclaration"}, {"full_name": "finEquivZpowers_apply", "code": "@[to_additive (attr := simp, nolint simpNF) finEquivZmultiples_apply]\ntheorem finEquivZpowers_apply [Finite G] {n : Fin (orderOf x)} :\n    finEquivZpowers x n = \u27e8x ^ (n : \u2115), n, zpow_ofNat x n\u27e9", "start": [883, 1], "end": [886, 6], "kind": "commanddeclaration"}, {"full_name": "finEquivZpowers_symm_apply", "code": "@[to_additive (attr := simp, nolint simpNF) finEquivZmultiples_symm_apply]\ntheorem finEquivZpowers_symm_apply [Finite G] (x : G) (n : \u2115) {hn : \u2203 m : \u2124, x ^ m = x ^ n} :\n    (finEquivZpowers x).symm \u27e8x ^ n, hn\u27e9 = \u27e8n % orderOf x, Nat.mod_lt _ (orderOf_pos x)\u27e9", "start": [891, 1], "end": [895, 38], "kind": "commanddeclaration"}, {"full_name": "zpowersEquivZpowers", "code": "@[to_additive zmultiplesEquivZmultiples\n  \"The equivalence between `Subgroup.zmultiples` of two elements `a, b` of the same additive order,\n  mapping `i \u2022 a` to `i \u2022 b`.\"]\nnoncomputable def zpowersEquivZpowers [Finite G] (h : orderOf x = orderOf y) :\n    (Subgroup.zpowers x : Set G) \u2243 (Subgroup.zpowers y : Set G) :=\n  (finEquivZpowers x).symm.trans ((Fin.castIso h).toEquiv.trans (finEquivZpowers y))", "start": [899, 1], "end": [906, 85], "kind": "commanddeclaration"}, {"full_name": "zpowersEquivZpowers_apply", "code": "@[to_additive (attr := simp, nolint simpNF) zmultiples_equiv_zmultiples_apply]\ntheorem zpowersEquivZpowers_apply [Finite G] (h : orderOf x = orderOf y) (n : \u2115) :\n    zpowersEquivZpowers h \u27e8x ^ n, n, zpow_ofNat x n\u27e9 = \u27e8y ^ n, n, zpow_ofNat y n\u27e9", "start": [912, 1], "end": [917, 11], "kind": "commanddeclaration"}, {"full_name": "orderOf_eq_card_zpowers", "code": "@[to_additive addOrderOf_eq_card_zmultiples \"See also `Nat.card_zmultiples'`.\"]\ntheorem orderOf_eq_card_zpowers : orderOf x = Fintype.card (zpowers x)", "start": [923, 1], "end": [926, 84], "kind": "commanddeclaration"}, {"full_name": "card_zpowers_le", "code": "@[to_additive card_zmultiples_le]\ntheorem card_zpowers_le (a : G) {k : \u2115} (k_pos : k \u2260 0)\n    (ha : a ^ k = 1) : Fintype.card (Subgroup.zpowers a) \u2264 k", "start": [930, 1], "end": [934, 49], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_card_univ", "code": "@[to_additive]\ntheorem orderOf_dvd_card_univ : orderOf x \u2223 Fintype.card G", "start": [939, 1], "end": [961, 100], "kind": "commanddeclaration"}, {"full_name": "orderOf_dvd_nat_card", "code": "@[to_additive]\ntheorem orderOf_dvd_nat_card {G : Type*} [Group G] {x : G} : orderOf x \u2223 Nat.card G", "start": [965, 1], "end": [969, 51], "kind": "commanddeclaration"}, {"full_name": "pow_card_eq_one'", "code": "@[to_additive (attr := simp) card_nsmul_eq_zero']\ntheorem pow_card_eq_one' {G : Type*} [Group G] {x : G} : x ^ Nat.card G = 1", "start": [973, 1], "end": [975, 53], "kind": "commanddeclaration"}, {"full_name": "pow_card_eq_one", "code": "@[to_additive (attr := simp) card_nsmul_eq_zero]\ntheorem pow_card_eq_one : x ^ Fintype.card G = 1", "start": [979, 1], "end": [981, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pow_index_mem", "code": "@[to_additive]\ntheorem Subgroup.pow_index_mem {G : Type*} [Group G] (H : Subgroup G) [Normal H] (g : G) :\n    g ^ index H \u2208 H", "start": [985, 1], "end": [987, 93], "kind": "commanddeclaration"}, {"full_name": "pow_eq_mod_card", "code": "@[to_additive]\ntheorem pow_eq_mod_card (n : \u2115) : x ^ n = x ^ (n % Fintype.card G)", "start": [991, 1], "end": [993, 94], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_mod_card", "code": "@[to_additive]\ntheorem zpow_eq_mod_card (n : \u2124) : x ^ n = x ^ (n % Fintype.card G : \u2124)", "start": [997, 1], "end": [1000, 25], "kind": "commanddeclaration"}, {"full_name": "powCoprime", "code": "@[to_additive (attr := simps) \"If `gcd(|G|,n)=1` then the smul by `n` is a bijection\"]\nnoncomputable def powCoprime {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : G \u2243 G\n    where\n  toFun g := g ^ n\n  invFun g := g ^ (Nat.card G).gcdB n\n  left_inv g := by\n    have key := congr_arg ((\u00b7 ^ \u00b7) g) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul, zpow_ofNat, zpow_ofNat, zpow_ofNat, h.gcd_eq_one, pow_one,\n      pow_card_eq_one', one_zpow, one_mul, eq_comm] at key\n  right_inv g := by\n    have key := congr_arg ((\u00b7 ^ \u00b7) g) ((Nat.card G).gcd_eq_gcd_ab n)\n    dsimp only at key\n    rwa [zpow_add, zpow_mul, zpow_mul', zpow_ofNat, zpow_ofNat, zpow_ofNat, h.gcd_eq_one, pow_one,\n      pow_card_eq_one', one_zpow, one_mul, eq_comm] at key", "start": [1004, 1], "end": [1019, 59], "kind": "commanddeclaration"}, {"full_name": "powCoprime_one", "code": "@[to_additive] theorem powCoprime_one {G : Type*} [Group G] (h : (Nat.card G).Coprime n) : powCoprime h 1 = 1", "start": [1023, 1], "end": [1025, 12], "kind": "commanddeclaration"}, {"full_name": "powCoprime_inv", "code": "@[to_additive] theorem powCoprime_inv {G : Type*} [Group G] (h : (Nat.card G).Coprime n) {g : G} :\n    powCoprime h g\u207b\u00b9 = (powCoprime h g)\u207b\u00b9", "start": [1029, 1], "end": [1032, 14], "kind": "commanddeclaration"}, {"full_name": "inf_eq_bot_of_coprime", "code": "@[to_additive add_inf_eq_bot_of_coprime]\ntheorem inf_eq_bot_of_coprime {G : Type*} [Group G] {H K : Subgroup G} [Fintype H] [Fintype K]\n    (h : Nat.Coprime (Fintype.card H) (Fintype.card K)) : H \u2293 K = \u22a5", "start": [1036, 1], "end": [1043, 95], "kind": "commanddeclaration"}, {"full_name": "image_range_orderOf", "code": "@[to_additive]\ntheorem image_range_orderOf [DecidableEq G] :\n    Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (zpowers x : Set G).toFinset", "start": [1048, 1], "end": [1052, 76], "kind": "commanddeclaration"}, {"full_name": "pow_gcd_card_eq_one_iff", "code": "@[to_additive gcd_nsmul_card_eq_zero_iff]\ntheorem pow_gcd_card_eq_one_iff : x ^ n = 1 \u2194 x ^ gcd n (Fintype.card G) = 1", "start": [1057, 1], "end": [1061, 34], "kind": "commanddeclaration"}, {"full_name": "submonoidOfIdempotent", "code": "@[to_additive \"A nonempty idempotent subset of a finite cancellative add monoid is a submonoid\"]\ndef submonoidOfIdempotent {M : Type*} [LeftCancelMonoid M] [Fintype M] (S : Set M)\n    (hS1 : S.Nonempty) (hS2 : S * S = S) : Submonoid M :=\n  have pow_mem : \u2200 a : M, a \u2208 S \u2192 \u2200 n : \u2115, a ^ (n + 1) \u2208 S := fun a ha =>\n    Nat.rec (by rwa [Nat.zero_eq, zero_add, pow_one]) fun n ih =>\n      (congr_arg\u2082 (\u00b7 \u2208 \u00b7) (pow_succ a (n + 1)).symm hS2).mp (Set.mul_mem_mul ha ih)\n  { carrier := S\n    one_mem' := by\n      obtain \u27e8a, ha\u27e9 := hS1\n      rw [\u2190 pow_orderOf_eq_one a, \u2190 tsub_add_cancel_of_le (succ_le_of_lt (orderOf_pos a))]\n      exact pow_mem a ha (orderOf a - 1)\n    mul_mem' := fun ha hb => (congr_arg\u2082 (\u00b7 \u2208 \u00b7) rfl hS2).mp (Set.mul_mem_mul ha hb) }", "start": [1069, 1], "end": [1081, 87], "kind": "commanddeclaration"}, {"full_name": "subgroupOfIdempotent", "code": "@[to_additive \"A nonempty idempotent subset of a finite add group is a subgroup\"]\ndef subgroupOfIdempotent {G : Type*} [Group G] [Fintype G] (S : Set G) (hS1 : S.Nonempty)\n    (hS2 : S * S = S) : Subgroup G :=\n  { submonoidOfIdempotent S hS1 hS2 with\n    carrier := S\n    inv_mem' := fun {a} ha => show a\u207b\u00b9 \u2208 submonoidOfIdempotent S hS1 hS2 by\n      rw [\u2190 one_mul a\u207b\u00b9, \u2190 pow_one a, \u2190 pow_orderOf_eq_one a, \u2190 pow_sub a (orderOf_pos a)]\n      exact pow_mem ha (orderOf a - 1) }", "start": [1085, 1], "end": [1093, 41], "kind": "commanddeclaration"}, {"full_name": "powCardSubgroup", "code": "@[to_additive (attr := simps!) smulCardAddSubgroup\n  \"If `S` is a nonempty subset of a finite add group `G`, then `|G| \u2022 S` is a subgroup\"]\ndef powCardSubgroup {G : Type*} [Group G] [Fintype G] (S : Set G) (hS : S.Nonempty) : Subgroup G :=\n  have one_mem : (1 : G) \u2208 S ^ Fintype.card G := by\n    obtain \u27e8a, ha\u27e9 := hS\n    rw [\u2190 pow_card_eq_one]\n    exact Set.pow_mem_pow ha (Fintype.card G)\n  subgroupOfIdempotent (S ^ Fintype.card G) \u27e81, one_mem\u27e9 $ by\n    classical!\n    apply (Set.eq_of_subset_of_card_le (Set.subset_mul_left _ one_mem) (ge_of_eq _)).symm\n    simp_rw [\u2190 pow_add,\n        Group.card_pow_eq_card_pow_card_univ S (Fintype.card G + Fintype.card G) le_add_self]", "start": [1097, 1], "end": [1109, 94], "kind": "commanddeclaration"}, {"full_name": "orderOf_abs_ne_one", "code": "theorem orderOf_abs_ne_one (h : |x| \u2260 1) : orderOf x = 0", "start": [1119, 1], "end": [1125, 46], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.orderOf_le_two", "code": "theorem LinearOrderedRing.orderOf_le_two : orderOf x \u2264 2", "start": [1128, 1], "end": [1133, 46], "kind": "commanddeclaration"}, {"full_name": "Prod.orderOf", "code": "@[to_additive Prod.add_orderOf]\nprotected theorem Prod.orderOf (x : \u03b1 \u00d7 \u03b2) : orderOf x = (orderOf x.1).lcm (orderOf x.2)", "start": [1142, 1], "end": [1144, 31], "kind": "commanddeclaration"}, {"full_name": "orderOf_fst_dvd_orderOf", "code": "@[to_additive add_orderOf_fst_dvd_add_orderOf]\ntheorem orderOf_fst_dvd_orderOf : orderOf x.1 \u2223 orderOf x", "start": [1148, 1], "end": [1150, 24], "kind": "commanddeclaration"}, {"full_name": "orderOf_snd_dvd_orderOf", "code": "@[to_additive add_orderOf_snd_dvd_add_orderOf]\ntheorem orderOf_snd_dvd_orderOf : orderOf x.2 \u2223 orderOf x", "start": [1154, 1], "end": [1156, 24], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.fst", "code": "@[to_additive]\ntheorem IsOfFinOrder.fst {x : \u03b1 \u00d7 \u03b2} (hx : IsOfFinOrder x) : IsOfFinOrder x.1", "start": [1160, 1], "end": [1162, 34], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.snd", "code": "@[to_additive]\ntheorem IsOfFinOrder.snd {x : \u03b1 \u00d7 \u03b2} (hx : IsOfFinOrder x) : IsOfFinOrder x.2", "start": [1166, 1], "end": [1168, 34], "kind": "commanddeclaration"}, {"full_name": "IsOfFinOrder.prod_mk", "code": "@[to_additive IsOfFinAddOrder.prod_mk]\ntheorem IsOfFinOrder.prod_mk : IsOfFinOrder a \u2192 IsOfFinOrder b \u2192 IsOfFinOrder (a, b)", "start": [1172, 1], "end": [1174, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Fin.lean", "imports": ["Mathlib/Data/Finset/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.attachFin", "code": "def attachFin (s : Finset \u2115) {n : \u2115} (h : \u2200 m \u2208 s, m < n) : Finset (Fin n) :=\n  \u27e8s.1.pmap (fun a ha \u21a6 \u27e8a, ha\u27e9) h, s.nodup.pmap fun _ _ _ _ \u21a6 Fin.veq_of_eq\u27e9", "start": [25, 1], "end": [28, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_attachFin", "code": "@[simp]\ntheorem mem_attachFin {n : \u2115} {s : Finset \u2115} (h : \u2200 m \u2208 s, m < n) {a : Fin n} :\n    a \u2208 s.attachFin h \u2194 (a : \u2115) \u2208 s", "start": [31, 1], "end": [37, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.card_attachFin", "code": "@[simp]\ntheorem card_attachFin {n : \u2115} (s : Finset \u2115) (h : \u2200 m \u2208 s, m < n) :\n    (s.attachFin h).card = s.card", "start": [40, 1], "end": [43, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Order/Units.lean", "imports": ["Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Int/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.isUnit_iff_abs_eq", "code": "theorem isUnit_iff_abs_eq {x : \u2124} : IsUnit x \u2194 abs x = 1", "start": [19, 1], "end": [20, 74], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_sq", "code": "theorem isUnit_sq {a : \u2124} (ha : IsUnit a) : a ^ 2 = 1", "start": [23, 1], "end": [23, 88], "kind": "commanddeclaration"}, {"full_name": "Int.units_sq", "code": "@[simp]\ntheorem units_sq (u : \u2124\u02e3) : u ^ 2 = 1", "start": [26, 1], "end": [28, 82], "kind": "commanddeclaration"}, {"full_name": "Int.units_pow_two", "code": "alias units_pow_two := units_sq", "start": [31, 1], "end": [31, 32], "kind": "stdtacticaliasalias"}, {"full_name": "Int.units_mul_self", "code": "@[simp]\ntheorem units_mul_self (u : \u2124\u02e3) : u * u = 1", "start": [34, 1], "end": [35, 70], "kind": "commanddeclaration"}, {"full_name": "Int.units_inv_eq_self", "code": "@[simp]\ntheorem units_inv_eq_self (u : \u2124\u02e3) : u\u207b\u00b9 = u", "start": [38, 1], "end": [39, 94], "kind": "commanddeclaration"}, {"full_name": "Int.units_coe_mul_self", "code": "@[simp]\ntheorem units_coe_mul_self (u : \u2124\u02e3) : (u * u : \u2124) = 1", "start": [43, 1], "end": [45, 54], "kind": "commanddeclaration"}, {"full_name": "Int.neg_one_pow_ne_zero", "code": "@[simp]\ntheorem neg_one_pow_ne_zero {n : \u2115} : (-1 : \u2124) ^ n \u2260 0", "start": [48, 1], "end": [50, 39], "kind": "commanddeclaration"}, {"full_name": "Int.sq_eq_one_of_sq_lt_four", "code": "theorem sq_eq_one_of_sq_lt_four {x : \u2124} (h1 : x ^ 2 < 4) (h2 : x \u2260 0) : x ^ 2 = 1", "start": [53, 1], "end": [57, 47], "kind": "commanddeclaration"}, {"full_name": "Int.sq_eq_one_of_sq_le_three", "code": "theorem sq_eq_one_of_sq_le_three {x : \u2124} (h1 : x ^ 2 \u2264 3) (h2 : x \u2260 0) : x ^ 2 = 1", "start": [60, 1], "end": [61, 70], "kind": "commanddeclaration"}, {"full_name": "Int.units_pow_eq_pow_mod_two", "code": "theorem units_pow_eq_pow_mod_two (u : \u2124\u02e3) (n : \u2115) : u ^ n = u ^ (n % 2)", "start": [64, 1], "end": [68, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Prod.lean", "imports": ["Mathlib/Util/CompileInductive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "imports": ["Mathlib/Data/ENat/Basic.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.trailingDegree", "code": "def trailingDegree (p : R[X]) : \u2115\u221e :=\n  p.support.min", "start": [41, 1], "end": [47, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_lt_wf", "code": "theorem trailingDegree_lt_wf : WellFounded fun p q : R[X] => trailingDegree p < trailingDegree q", "start": [50, 1], "end": [51, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree", "code": "def natTrailingDegree (p : R[X]) : \u2115 :=\n  (trailingDegree p).getD 0", "start": [54, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingCoeff", "code": "def trailingCoeff (p : R[X]) : R :=\n  coeff p (natTrailingDegree p)", "start": [60, 1], "end": [62, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.TrailingMonic", "code": "def TrailingMonic (p : R[X]) :=\n  trailingCoeff p = (1 : R)", "start": [65, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.TrailingMonic.def", "code": "theorem TrailingMonic.def : TrailingMonic p \u2194 trailingCoeff p = 1", "start": [70, 1], "end": [71, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.TrailingMonic.decidable", "code": "instance TrailingMonic.decidable [DecidableEq R] : Decidable (TrailingMonic p) :=\n  inferInstanceAs <| Decidable (trailingCoeff p = (1 : R))", "start": [74, 1], "end": [75, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.TrailingMonic.trailingCoeff", "code": "@[simp]\ntheorem TrailingMonic.trailingCoeff {p : R[X]} (hp : p.TrailingMonic) : trailingCoeff p = 1", "start": [78, 1], "end": [80, 5], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_zero", "code": "@[simp]\ntheorem trailingDegree_zero : trailingDegree (0 : R[X]) = \u22a4", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingCoeff_zero", "code": "@[simp]\ntheorem trailingCoeff_zero : trailingCoeff (0 : R[X]) = 0", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_zero", "code": "@[simp]\ntheorem natTrailingDegree_zero : natTrailingDegree (0 : R[X]) = 0", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_eq_top", "code": "theorem trailingDegree_eq_top : trailingDegree p = \u22a4 \u2194 p = 0", "start": [98, 1], "end": [99, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_eq_natTrailingDegree", "code": "theorem trailingDegree_eq_natTrailingDegree (hp : p \u2260 0) :\n    trailingDegree p = (natTrailingDegree p : \u2115\u221e)", "start": [102, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_eq_iff_natTrailingDegree_eq", "code": "theorem trailingDegree_eq_iff_natTrailingDegree_eq {p : R[X]} {n : \u2115} (hp : p \u2260 0) :\n    p.trailingDegree = n \u2194 p.natTrailingDegree = n", "start": [111, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_eq_iff_natTrailingDegree_eq_of_pos", "code": "theorem trailingDegree_eq_iff_natTrailingDegree_eq_of_pos {p : R[X]} {n : \u2115} (hn : 0 < n) :\n    p.trailingDegree = n \u2194 p.natTrailingDegree = n", "start": [117, 1], "end": [130, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_eq_of_trailingDegree_eq_some", "code": "theorem natTrailingDegree_eq_of_trailingDegree_eq_some {p : R[X]} {n : \u2115}\n    (h : trailingDegree p = n) : natTrailingDegree p = n", "start": [133, 1], "end": [137, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_trailingDegree", "code": "@[simp]\ntheorem natTrailingDegree_le_trailingDegree : \u2191(natTrailingDegree p) \u2264 trailingDegree p", "start": [140, 1], "end": [145, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_eq_of_trailingDegree_eq", "code": "theorem natTrailingDegree_eq_of_trailingDegree_eq [Semiring S] {q : S[X]}\n    (h : trailingDegree p = trailingDegree q) : natTrailingDegree p = natTrailingDegree q", "start": [148, 1], "end": [151, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_of_ne_zero", "code": "theorem le_trailingDegree_of_ne_zero (h : coeff p n \u2260 0) : trailingDegree p \u2264 n", "start": [154, 1], "end": [155, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_of_ne_zero", "code": "theorem natTrailingDegree_le_of_ne_zero (h : coeff p n \u2260 0) : natTrailingDegree p \u2264 n", "start": [158, 1], "end": [164, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_le_trailingDegree", "code": "theorem trailingDegree_le_trailingDegree (h : coeff q (natTrailingDegree p) \u2260 0) :\n    trailingDegree q \u2264 trailingDegree p", "start": [167, 1], "end": [173, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_ne_of_natTrailingDegree_ne", "code": "theorem trailingDegree_ne_of_natTrailingDegree_ne {n : \u2115} :\n    p.natTrailingDegree \u2260 n \u2192 trailingDegree p \u2260 n", "start": [176, 1], "end": [180, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_of_trailingDegree_le", "code": "theorem natTrailingDegree_le_of_trailingDegree_le {n : \u2115} {hp : p \u2260 0}\n    (H : (n : \u2115\u221e) \u2264 trailingDegree p) : n \u2264 natTrailingDegree p", "start": [183, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_natTrailingDegree", "code": "theorem natTrailingDegree_le_natTrailingDegree {hq : q \u2260 0}\n    (hpq : p.trailingDegree \u2264 q.trailingDegree) : p.natTrailingDegree \u2264 q.natTrailingDegree", "start": [189, 1], "end": [195, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_monomial", "code": "@[simp]\ntheorem trailingDegree_monomial (ha : a \u2260 0) : trailingDegree (monomial n a) = n", "start": [198, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_monomial", "code": "theorem natTrailingDegree_monomial (ha : a \u2260 0) : natTrailingDegree (monomial n a) = n", "start": [204, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_monomial_le", "code": "theorem natTrailingDegree_monomial_le : natTrailingDegree (monomial n a) \u2264 n", "start": [209, 1], "end": [211, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_monomial", "code": "theorem le_trailingDegree_monomial : \u2191n \u2264 trailingDegree (monomial n a)", "start": [214, 1], "end": [216, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_C", "code": "@[simp]\ntheorem trailingDegree_C (ha : a \u2260 0) : trailingDegree (C a) = (0 : \u2115\u221e)", "start": [219, 1], "end": [221, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_C", "code": "theorem le_trailingDegree_C : (0 : \u2115\u221e) \u2264 trailingDegree (C a)", "start": [225, 1], "end": [226, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_one_le", "code": "theorem trailingDegree_one_le : (0 : \u2115\u221e) \u2264 trailingDegree (1 : R[X])", "start": [230, 1], "end": [232, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_C", "code": "@[simp]\ntheorem natTrailingDegree_C (a : R) : natTrailingDegree (C a) = 0", "start": [235, 1], "end": [237, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_one", "code": "@[simp]\ntheorem natTrailingDegree_one : natTrailingDegree (1 : R[X]) = 0", "start": [241, 1], "end": [243, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_nat_cast", "code": "@[simp]\ntheorem natTrailingDegree_nat_cast (n : \u2115) : natTrailingDegree (n : R[X]) = 0", "start": [246, 1], "end": [248, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_C_mul_X_pow", "code": "@[simp]\ntheorem trailingDegree_C_mul_X_pow (n : \u2115) (ha : a \u2260 0) : trailingDegree (C a * X ^ n) = n", "start": [251, 1], "end": [253, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_C_mul_X_pow", "code": "theorem le_trailingDegree_C_mul_X_pow (n : \u2115) (a : R) :\n    (n : \u2115\u221e) \u2264 trailingDegree (C a * X ^ n)", "start": [257, 1], "end": [260, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_eq_zero_of_trailingDegree_lt", "code": "theorem coeff_eq_zero_of_trailingDegree_lt (h : (n : \u2115\u221e) < trailingDegree p) : coeff p n = 0", "start": [264, 1], "end": [265, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_eq_zero_of_lt_natTrailingDegree", "code": "theorem coeff_eq_zero_of_lt_natTrailingDegree {p : R[X]} {n : \u2115} (h : n < p.natTrailingDegree) :\n    p.coeff n = 0", "start": [268, 1], "end": [275, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_natTrailingDegree_pred_eq_zero", "code": "@[simp]\ntheorem coeff_natTrailingDegree_pred_eq_zero {p : R[X]} {hp : (0 : \u2115\u221e) < natTrailingDegree p} :\n    p.coeff (p.natTrailingDegree - 1) = 0", "start": [278, 1], "end": [282, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_X_pow", "code": "theorem le_trailingDegree_X_pow (n : \u2115) : (n : \u2115\u221e) \u2264 trailingDegree (X ^ n : R[X])", "start": [285, 1], "end": [286, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_X", "code": "theorem le_trailingDegree_X : (1 : \u2115\u221e) \u2264 trailingDegree (X : R[X])", "start": [290, 1], "end": [291, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_X_le", "code": "theorem natTrailingDegree_X_le : (X : R[X]).natTrailingDegree \u2264 1", "start": [295, 1], "end": [296, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingCoeff_eq_zero", "code": "@[simp]\ntheorem trailingCoeff_eq_zero : trailingCoeff p = 0 \u2194 p = 0", "start": [300, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingCoeff_nonzero_iff_nonzero", "code": "theorem trailingCoeff_nonzero_iff_nonzero : trailingCoeff p \u2260 0 \u2194 p \u2260 0", "start": [309, 1], "end": [310, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_mem_support_of_nonzero", "code": "theorem natTrailingDegree_mem_support_of_nonzero : p \u2260 0 \u2192 natTrailingDegree p \u2208 p.support", "start": [313, 1], "end": [314, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_of_mem_supp", "code": "theorem natTrailingDegree_le_of_mem_supp (a : \u2115) : a \u2208 p.support \u2192 natTrailingDegree p \u2264 a", "start": [317, 1], "end": [318, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_eq_support_min'", "code": "theorem natTrailingDegree_eq_support_min' (h : p \u2260 0) :\n    natTrailingDegree p = p.support.min' (nonempty_support_iff.mpr h)", "start": [321, 1], "end": [328, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_natTrailingDegree", "code": "theorem le_natTrailingDegree (hp : p \u2260 0) (hn : \u2200 m < n, p.coeff m = 0) :\n    n \u2264 p.natTrailingDegree", "start": [331, 1], "end": [334, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_le_natDegree", "code": "theorem natTrailingDegree_le_natDegree (p : R[X]) : p.natTrailingDegree \u2264 p.natDegree", "start": [337, 1], "end": [340, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_mul_X_pow", "code": "theorem natTrailingDegree_mul_X_pow {p : R[X]} (hp : p \u2260 0) (n : \u2115) :\n    (p * X ^ n).natTrailingDegree = p.natTrailingDegree + n", "start": [343, 1], "end": [354, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_trailingDegree_mul", "code": "theorem le_trailingDegree_mul : p.trailingDegree + q.trailingDegree \u2264 (p * q).trailingDegree", "start": [358, 1], "end": [366, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_natTrailingDegree_mul", "code": "theorem le_natTrailingDegree_mul (h : p * q \u2260 0) :\n    p.natTrailingDegree + q.natTrailingDegree \u2264 (p * q).natTrailingDegree", "start": [369, 1], "end": [379, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_natTrailingDegree_add_natTrailingDegree", "code": "theorem coeff_mul_natTrailingDegree_add_natTrailingDegree : (p * q).coeff\n    (p.natTrailingDegree + q.natTrailingDegree) = p.trailingCoeff * q.trailingCoeff", "start": [382, 1], "end": [396, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_mul'", "code": "theorem trailingDegree_mul' (h : p.trailingCoeff * q.trailingCoeff \u2260 0) :\n    (p * q).trailingDegree = p.trailingDegree + q.trailingDegree", "start": [399, 1], "end": [407, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_mul'", "code": "theorem natTrailingDegree_mul' (h : p.trailingCoeff * q.trailingCoeff \u2260 0) :\n    (p * q).natTrailingDegree = p.natTrailingDegree + q.natTrailingDegree", "start": [410, 1], "end": [421, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_mul", "code": "theorem natTrailingDegree_mul [NoZeroDivisors R] (hp : p \u2260 0) (hq : q \u2260 0) :\n    (p * q).natTrailingDegree = p.natTrailingDegree + q.natTrailingDegree", "start": [424, 1], "end": [427, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_one", "code": "@[simp]\ntheorem trailingDegree_one : trailingDegree (1 : R[X]) = (0 : \u2115\u221e)", "start": [436, 1], "end": [438, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_X", "code": "@[simp]\ntheorem trailingDegree_X : trailingDegree (X : R[X]) = 1", "start": [441, 1], "end": [443, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_X", "code": "@[simp]\ntheorem natTrailingDegree_X : (X : R[X]).natTrailingDegree = 1", "start": [447, 1], "end": [449, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_neg", "code": "@[simp]\ntheorem trailingDegree_neg (p : R[X]) : trailingDegree (-p) = trailingDegree p", "start": [459, 1], "end": [462, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_neg", "code": "@[simp]\ntheorem natTrailingDegree_neg (p : R[X]) : natTrailingDegree (-p) = natTrailingDegree p", "start": [465, 1], "end": [467, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_int_cast", "code": "@[simp]\ntheorem natTrailingDegree_int_cast (n : \u2124) : natTrailingDegree (n : R[X]) = 0", "start": [470, 1], "end": [472, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeffUp", "code": "def nextCoeffUp (p : R[X]) : R :=\n  if p.natTrailingDegree = 0 then 0 else p.coeff (p.natTrailingDegree + 1)", "start": [481, 1], "end": [483, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeffUp_C_eq_zero", "code": "@[simp]\ntheorem nextCoeffUp_C_eq_zero (c : R) : nextCoeffUp (C c) = 0", "start": [486, 1], "end": [489, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeffUp_of_pos_natTrailingDegree", "code": "theorem nextCoeffUp_of_pos_natTrailingDegree (p : R[X]) (hp : 0 < p.natTrailingDegree) :\n    nextCoeffUp p = p.coeff (p.natTrailingDegree + 1)", "start": [493, 1], "end": [497, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_natTrailingDegree_eq_zero_of_trailingDegree_lt", "code": "theorem coeff_natTrailingDegree_eq_zero_of_trailingDegree_lt\n    (h : trailingDegree p < trailingDegree q) : coeff q (natTrailingDegree p) = 0", "start": [506, 1], "end": [508, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_trailingDegree_lt", "code": "theorem ne_zero_of_trailingDegree_lt {n : \u2115\u221e} (h : trailingDegree p < n) : p \u2260 0", "start": [511, 1], "end": [512, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/EraseLead.lean", "imports": ["Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.eraseLead", "code": "def eraseLead (f : R[X]) : R[X] :=\n  Polynomial.erase f.natDegree f", "start": [34, 1], "end": [37, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_support", "code": "theorem eraseLead_support (f : R[X]) : f.eraseLead.support = f.support.erase f.natDegree", "start": [42, 1], "end": [43, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_coeff", "code": "theorem eraseLead_coeff (i : \u2115) : f.eraseLead.coeff i = if i = f.natDegree then 0 else f.coeff i", "start": [46, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_coeff_natDegree", "code": "@[simp]\ntheorem eraseLead_coeff_natDegree : f.eraseLead.coeff f.natDegree = 0", "start": [50, 1], "end": [51, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_coeff_of_ne", "code": "theorem eraseLead_coeff_of_ne (i : \u2115) (hi : i \u2260 f.natDegree) : f.eraseLead.coeff i = f.coeff i", "start": [54, 1], "end": [55, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_zero", "code": "@[simp]\ntheorem eraseLead_zero : eraseLead (0 : R[X]) = 0", "start": [58, 1], "end": [59, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_add_monomial_natDegree_leadingCoeff", "code": "@[simp]\ntheorem eraseLead_add_monomial_natDegree_leadingCoeff (f : R[X]) :\n    f.eraseLead + monomial f.natDegree f.leadingCoeff = f", "start": [62, 1], "end": [65, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_add_C_mul_X_pow", "code": "@[simp]\ntheorem eraseLead_add_C_mul_X_pow (f : R[X]) :\n    f.eraseLead + C f.leadingCoeff * X ^ f.natDegree = f", "start": [68, 1], "end": [71, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.self_sub_monomial_natDegree_leadingCoeff", "code": "@[simp]\ntheorem self_sub_monomial_natDegree_leadingCoeff {R : Type*} [Ring R] (f : R[X]) :\n    f - monomial f.natDegree f.leadingCoeff = f.eraseLead", "start": [75, 1], "end": [78, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.self_sub_C_mul_X_pow", "code": "@[simp]\ntheorem self_sub_C_mul_X_pow {R : Type*} [Ring R] (f : R[X]) :\n    f - C f.leadingCoeff * X ^ f.natDegree = f.eraseLead", "start": [81, 1], "end": [84, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_ne_zero", "code": "theorem eraseLead_ne_zero (f0 : 2 \u2264 f.support.card) : eraseLead f \u2260 0", "start": [88, 1], "end": [91, 101], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lt_natDegree_of_mem_eraseLead_support", "code": "theorem lt_natDegree_of_mem_eraseLead_support {a : \u2115} (h : a \u2208 (eraseLead f).support) :\n    a < f.natDegree", "start": [94, 1], "end": [97, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_natDegree_of_mem_eraseLead_support", "code": "theorem ne_natDegree_of_mem_eraseLead_support {a : \u2115} (h : a \u2208 (eraseLead f).support) :\n    a \u2260 f.natDegree", "start": [100, 1], "end": [102, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_not_mem_eraseLead_support", "code": "theorem natDegree_not_mem_eraseLead_support : f.natDegree \u2209 (eraseLead f).support", "start": [105, 1], "end": [106, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_support_card_lt", "code": "theorem eraseLead_support_card_lt (h : f \u2260 0) : (eraseLead f).support.card < f.support.card", "start": [109, 1], "end": [111, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_card_support", "code": "theorem eraseLead_card_support {c : \u2115} (fc : f.support.card = c) :\n    f.eraseLead.support.card = c - 1", "start": [114, 1], "end": [118, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_card_support'", "code": "theorem eraseLead_card_support' {c : \u2115} (fc : f.support.card = c + 1) :\n    f.eraseLead.support.card = c", "start": [121, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_monomial", "code": "@[simp]\ntheorem eraseLead_monomial (i : \u2115) (r : R) : eraseLead (monomial i r) = 0", "start": [126, 1], "end": [132, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_C", "code": "@[simp]\ntheorem eraseLead_C (r : R) : eraseLead (C r) = 0", "start": [135, 1], "end": [137, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_X", "code": "@[simp]\ntheorem eraseLead_X : eraseLead (X : R[X]) = 0", "start": [141, 1], "end": [143, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_X_pow", "code": "@[simp]\ntheorem eraseLead_X_pow (n : \u2115) : eraseLead (X ^ n : R[X]) = 0", "start": [147, 1], "end": [149, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_C_mul_X_pow", "code": "@[simp]\ntheorem eraseLead_C_mul_X_pow (r : R) (n : \u2115) : eraseLead (C r * X ^ n) = 0", "start": [153, 1], "end": [155, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_add_of_natDegree_lt_left", "code": "theorem eraseLead_add_of_natDegree_lt_left {p q : R[X]} (pq : q.natDegree < p.natDegree) :\n    (p + q).eraseLead = p.eraseLead + q", "start": [159, 1], "end": [167, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_add_of_natDegree_lt_right", "code": "theorem eraseLead_add_of_natDegree_lt_right {p q : R[X]} (pq : p.natDegree < q.natDegree) :\n    (p + q).eraseLead = p + q.eraseLead", "start": [170, 1], "end": [178, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_degree_le", "code": "theorem eraseLead_degree_le : (eraseLead f).degree \u2264 f.degree", "start": [181, 1], "end": [182, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_natDegree_le_aux", "code": "theorem eraseLead_natDegree_le_aux : (eraseLead f).natDegree \u2264 f.natDegree", "start": [185, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_natDegree_lt", "code": "theorem eraseLead_natDegree_lt (f0 : 2 \u2264 f.support.card) : (eraseLead f).natDegree < f.natDegree", "start": [189, 1], "end": [192, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_natDegree_lt_or_eraseLead_eq_zero", "code": "theorem eraseLead_natDegree_lt_or_eraseLead_eq_zero (f : R[X]) :\n    (eraseLead f).natDegree < f.natDegree \u2228 f.eraseLead = 0", "start": [195, 1], "end": [202, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eraseLead_natDegree_le", "code": "theorem eraseLead_natDegree_le (f : R[X]) : (eraseLead f).natDegree \u2264 f.natDegree - 1", "start": [205, 1], "end": [208, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.induction_with_natDegree_le", "code": "theorem induction_with_natDegree_le (P : R[X] \u2192 Prop) (N : \u2115) (P_0 : P 0)\n    (P_C_mul_pow : \u2200 n : \u2115, \u2200 r : R, r \u2260 0 \u2192 n \u2264 N \u2192 P (C r * X ^ n))\n    (P_C_add : \u2200 f g : R[X], f.natDegree < g.natDegree \u2192 g.natDegree \u2264 N \u2192 P f \u2192 P g \u2192 P (f + g)) :\n    \u2200 f : R[X], f.natDegree \u2264 N \u2192 P f", "start": [213, 1], "end": [246, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mono_map_natDegree_eq", "code": "theorem mono_map_natDegree_eq {S F : Type*} [Semiring S] [AddMonoidHomClass F R[X] S[X]] {\u03c6 : F}\n    {p : R[X]} (k : \u2115) (fu : \u2115 \u2192 \u2115) (fu0 : \u2200 {n}, n \u2264 k \u2192 fu n = 0)\n    (fc : \u2200 {n m}, k \u2264 n \u2192 n < m \u2192 fu n < fu m) (\u03c6_k : \u2200 {f : R[X]}, f.natDegree < k \u2192 \u03c6 f = 0)\n    (\u03c6_mon_nat : \u2200 n c, c \u2260 0 \u2192 (\u03c6 (monomial n c)).natDegree = fu n) :\n    (\u03c6 p).natDegree = fu p.natDegree", "start": [249, 1], "end": [271, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_natDegree_eq_sub", "code": "theorem map_natDegree_eq_sub {S F : Type*} [Semiring S] [AddMonoidHomClass F R[X] S[X]] {\u03c6 : F}\n    {p : R[X]} {k : \u2115} (\u03c6_k : \u2200 f : R[X], f.natDegree < k \u2192 \u03c6 f = 0)\n    (\u03c6_mon : \u2200 n c, c \u2260 0 \u2192 (\u03c6 (monomial n c)).natDegree = n - k) :\n    (\u03c6 p).natDegree = p.natDegree - k", "start": [274, 1], "end": [280, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_natDegree_eq_natDegree", "code": "theorem map_natDegree_eq_natDegree {S F : Type*} [Semiring S] [AddMonoidHomClass F R[X] S[X]]\n    {\u03c6 : F} (p) (\u03c6_mon_nat : \u2200 n c, c \u2260 0 \u2192 (\u03c6 (monomial n c)).natDegree = n) :\n    (\u03c6 p).natDegree = p.natDegree", "start": [283, 1], "end": [287, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq'", "code": "theorem card_support_eq' {n : \u2115} (k : Fin n \u2192 \u2115) (x : Fin n \u2192 R) (hk : Function.Injective k)\n    (hx : \u2200 i, x i \u2260 0) : (\u2211 i, C (x i) * X ^ k i).support.card = n", "start": [292, 1], "end": [304, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq", "code": "theorem card_support_eq {n : \u2115} :\n    f.support.card = n \u2194\n      \u2203 (k : Fin n \u2192 \u2115) (x : Fin n \u2192 R) (hk : StrictMono k) (hx : \u2200 i, x i \u2260 0),\n        f = \u2211 i, C (x i) * X ^ k i", "start": [307, 1], "end": [350, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq_one", "code": "theorem card_support_eq_one : f.support.card = 1 \u2194\n    \u2203 (k : \u2115) (x : R) (hx : x \u2260 0), f = C x * X ^ k", "start": [353, 1], "end": [359, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq_two", "code": "theorem card_support_eq_two :\n    f.support.card = 2 \u2194\n      \u2203 (k m : \u2115) (hkm : k < m) (x y : R) (hx : x \u2260 0) (hy : y \u2260 0),\n        f = C x * X ^ k + C y * X ^ m", "start": [362, 1], "end": [372, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq_three", "code": "theorem card_support_eq_three :\n    f.support.card = 3 \u2194\n      \u2203 (k m n : \u2115) (hkm : k < m) (hmn : m < n) (x y z : R) (hx : x \u2260 0) (hy : y \u2260 0) (hz : z \u2260 0),\n        f = C x * X ^ k + C y * X ^ m + C z * X ^ n", "start": [375, 1], "end": [387, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Eval.lean", "imports": ["Mathlib/Data/Polynomial/Induction.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.eval\u2082", "code": "irreducible_def eval\u2082 (p : R[X]) : S :=\n  p.sum fun e a => f a * x ^ e", "start": [43, 1], "end": [46, 31], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Polynomial.eval\u2082_eq_sum", "code": "theorem eval\u2082_eq_sum {f : R \u2192+* S} {x : S} : p.eval\u2082 f x = p.sum fun e a => f a * x ^ e", "start": [49, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_congr", "code": "theorem eval\u2082_congr {R S : Type*} [Semiring R] [Semiring S] {f g : R \u2192+* S} {s t : S}\n    {\u03c6 \u03c8 : R[X]} : f = g \u2192 s = t \u2192 \u03c6 = \u03c8 \u2192 eval\u2082 f s \u03c6 = eval\u2082 g t \u03c8", "start": [53, 1], "end": [55, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_zero", "code": "@[simp]\ntheorem eval\u2082_at_zero : p.eval\u2082 f 0 = f (coeff p 0)", "start": [58, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_zero", "code": "@[simp]\ntheorem eval\u2082_zero : (0 : R[X]).eval\u2082 f x = 0", "start": [65, 1], "end": [66, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_C", "code": "@[simp]\ntheorem eval\u2082_C : (C a).eval\u2082 f x = f a", "start": [69, 1], "end": [70, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_X", "code": "@[simp]\ntheorem eval\u2082_X : X.eval\u2082 f x = x", "start": [73, 1], "end": [74, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_monomial", "code": "@[simp]\ntheorem eval\u2082_monomial {n : \u2115} {r : R} : (monomial n r).eval\u2082 f x = f r * x ^ n", "start": [77, 1], "end": [79, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_X_pow", "code": "@[simp]\ntheorem eval\u2082_X_pow {n : \u2115} : (X ^ n).eval\u2082 f x = x ^ n", "start": [82, 1], "end": [86, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_add", "code": "@[simp]\ntheorem eval\u2082_add : (p + q).eval\u2082 f x = p.eval\u2082 f x + q.eval\u2082 f x", "start": [89, 1], "end": [92, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_one", "code": "@[simp]\ntheorem eval\u2082_one : (1 : R[X]).eval\u2082 f x = 1", "start": [95, 1], "end": [96, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_bit0", "code": "@[simp]\ntheorem eval\u2082_bit0 : (bit0 p).eval\u2082 f x = bit0 (p.eval\u2082 f x)", "start": [100, 1], "end": [101, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_bit1", "code": "@[simp]\ntheorem eval\u2082_bit1 : (bit1 p).eval\u2082 f x = bit1 (p.eval\u2082 f x)", "start": [105, 1], "end": [107, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_smul", "code": "@[simp]\ntheorem eval\u2082_smul (g : R \u2192+* S) (p : R[X]) (x : S) {s : R} :\n    eval\u2082 g x (s \u2022 p) = g s * eval\u2082 g x p", "start": [110, 1], "end": [116, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_C_X", "code": "@[simp]\ntheorem eval\u2082_C_X : eval\u2082 C X p = p", "start": [119, 1], "end": [122, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082AddMonoidHom", "code": "@[simps]\ndef eval\u2082AddMonoidHom : R[X] \u2192+ S where\n  toFun := eval\u2082 f x\n  map_zero' := eval\u2082_zero _ _\n  map_add' _ _ := eval\u2082_add _ _", "start": [125, 1], "end": [131, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_nat_cast", "code": "@[simp]\ntheorem eval\u2082_nat_cast (n : \u2115) : (n : R[X]).eval\u2082 f x = n", "start": [135, 1], "end": [140, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_ofNat", "code": "@[simp]\nlemma eval\u2082_ofNat {S : Type*} [Semiring S] (n : \u2115) [n.AtLeastTwo] (f : R \u2192+* S) (a : S) :\n    (no_index (OfNat.ofNat n : R[X])).eval\u2082 f a = OfNat.ofNat n := by\n  simp [OfNat.ofNat]", "start": [143, 1], "end": [146, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.eval\u2082_sum", "code": "theorem eval\u2082_sum (p : T[X]) (g : \u2115 \u2192 T \u2192 R[X]) (x : S) :\n    (p.sum g).eval\u2082 f x = p.sum fun n a => (g n a).eval\u2082 f x", "start": [150, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_list_sum", "code": "theorem eval\u2082_list_sum (l : List R[X]) (x : S) : eval\u2082 f x l.sum = (l.map (eval\u2082 f x)).sum", "start": [161, 1], "end": [162, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_multiset_sum", "code": "theorem eval\u2082_multiset_sum (s : Multiset R[X]) (x : S) :\n    eval\u2082 f x s.sum = (s.map (eval\u2082 f x)).sum", "start": [165, 1], "end": [167, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_finset_sum", "code": "theorem eval\u2082_finset_sum (s : Finset \u03b9) (g : \u03b9 \u2192 R[X]) (x : S) :\n    (\u2211 i in s, g i).eval\u2082 f x = \u2211 i in s, (g i).eval\u2082 f x", "start": [170, 1], "end": [172, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_ofFinsupp", "code": "theorem eval\u2082_ofFinsupp {f : R \u2192+* S} {x : S} {p : R[\u2115]} :\n    eval\u2082 f x (\u27e8p\u27e9 : R[X]) = liftNC (\u2191f) (powersHom S x) p", "start": [175, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul_noncomm", "code": "theorem eval\u2082_mul_noncomm (hf : \u2200 k, Commute (f <| q.coeff k) x) :\n    eval\u2082 f x (p * q) = eval\u2082 f x p * eval\u2082 f x q", "start": [181, 1], "end": [186, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul_X", "code": "@[simp]\ntheorem eval\u2082_mul_X : eval\u2082 f x (p * X) = eval\u2082 f x p * x", "start": [189, 1], "end": [194, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_X_mul", "code": "@[simp]\ntheorem eval\u2082_X_mul : eval\u2082 f x (X * p) = eval\u2082 f x p * x", "start": [197, 1], "end": [198, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul_C'", "code": "theorem eval\u2082_mul_C' (h : Commute (f a) x) : eval\u2082 f x (p * C a) = eval\u2082 f x p * f a", "start": [201, 1], "end": [206, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_list_prod_noncomm", "code": "theorem eval\u2082_list_prod_noncomm (ps : List R[X])\n    (hf : \u2200 p \u2208 ps, \u2200 (k), Commute (f <| coeff p k) x) :\n    eval\u2082 f x ps.prod = (ps.map (Polynomial.eval\u2082 f x)).prod", "start": [209, 1], "end": [215, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082RingHom'", "code": "def eval\u2082RingHom' (f : R \u2192+* S) (x : S) (hf : \u2200 a, Commute (f a) x) : R[X] \u2192+* S where\n  toFun := eval\u2082 f x\n  map_add' _ _ := eval\u2082_add _ _\n  map_zero' := eval\u2082_zero _ _\n  map_mul' _p q := eval\u2082_mul_noncomm f x fun k => hf <| coeff q k\n  map_one' := eval\u2082_one _ _", "start": [218, 1], "end": [224, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_eq_sum_range", "code": "theorem eval\u2082_eq_sum_range :\n    p.eval\u2082 f x = \u2211 i in Finset.range (p.natDegree + 1), f (p.coeff i) * x ^ i", "start": [242, 1], "end": [245, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_eq_sum_range'", "code": "theorem eval\u2082_eq_sum_range' (f : R \u2192+* S) {p : R[X]} {n : \u2115} (hn : p.natDegree < n) (x : S) :\n    eval\u2082 f x p = \u2211 i in Finset.range n, f (p.coeff i) * x ^ i", "start": [248, 1], "end": [252, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul", "code": "@[simp]\ntheorem eval\u2082_mul : (p * q).eval\u2082 f x = p.eval\u2082 f x * q.eval\u2082 f x", "start": [261, 1], "end": [263, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul_eq_zero_of_left", "code": "theorem eval\u2082_mul_eq_zero_of_left (q : R[X]) (hp : p.eval\u2082 f x = 0) : (p * q).eval\u2082 f x = 0", "start": [266, 1], "end": [268, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_mul_eq_zero_of_right", "code": "theorem eval\u2082_mul_eq_zero_of_right (p : R[X]) (hq : q.eval\u2082 f x = 0) : (p * q).eval\u2082 f x = 0", "start": [271, 1], "end": [273, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082RingHom", "code": "def eval\u2082RingHom (f : R \u2192+* S) (x : S) : R[X] \u2192+* S :=\n  { eval\u2082AddMonoidHom f x with\n    map_one' := eval\u2082_one _ _\n    map_mul' := fun _ _ => eval\u2082_mul _ _ }", "start": [276, 1], "end": [280, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_eval\u2082RingHom", "code": "@[simp]\ntheorem coe_eval\u2082RingHom (f : R \u2192+* S) (x) : \u21d1(eval\u2082RingHom f x) = eval\u2082 f x", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_pow", "code": "theorem eval\u2082_pow (n : \u2115) : (p ^ n).eval\u2082 f x = p.eval\u2082 f x ^ n", "start": [288, 1], "end": [289, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_dvd", "code": "theorem eval\u2082_dvd : p \u2223 q \u2192 eval\u2082 f x p \u2223 eval\u2082 f x q", "start": [292, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_eq_zero_of_dvd_of_eval\u2082_eq_zero", "code": "theorem eval\u2082_eq_zero_of_dvd_of_eval\u2082_eq_zero (h : p \u2223 q) (h0 : eval\u2082 f x p = 0) :\n    eval\u2082 f x q = 0", "start": [296, 1], "end": [298, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_list_prod", "code": "theorem eval\u2082_list_prod (l : List R[X]) (x : S) : eval\u2082 f x l.prod = (l.map (eval\u2082 f x)).prod", "start": [301, 1], "end": [302, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval", "code": "def eval : R \u2192 R[X] \u2192 R :=\n  eval\u2082 (RingHom.id _)", "start": [313, 1], "end": [315, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_eq_sum", "code": "theorem eval_eq_sum : p.eval x = p.sum fun e a => a * x ^ e", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_eq_sum_range", "code": "theorem eval_eq_sum_range {p : R[X]} (x : R) :\n    p.eval x = \u2211 i in Finset.range (p.natDegree + 1), p.coeff i * x ^ i", "start": [323, 1], "end": [325, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_eq_sum_range'", "code": "theorem eval_eq_sum_range' {p : R[X]} {n : \u2115} (hn : p.natDegree < n) (x : R) :\n    p.eval x = \u2211 i in Finset.range n, p.coeff i * x ^ i", "start": [328, 1], "end": [330, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_apply", "code": "@[simp]\ntheorem eval\u2082_at_apply {S : Type*} [Semiring S] (f : R \u2192+* S) (r : R) :\n    p.eval\u2082 f (f r) = f (p.eval r)", "start": [333, 1], "end": [337, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_one", "code": "@[simp]\ntheorem eval\u2082_at_one {S : Type*} [Semiring S] (f : R \u2192+* S) : p.eval\u2082 f 1 = f (p.eval 1)", "start": [340, 1], "end": [343, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_nat_cast", "code": "@[simp]\ntheorem eval\u2082_at_nat_cast {S : Type*} [Semiring S] (f : R \u2192+* S) (n : \u2115) :\n    p.eval\u2082 f n = f (p.eval n)", "start": [346, 1], "end": [350, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_ofNat", "code": "@[simp]\ntheorem eval\u2082_at_ofNat {S : Type*} [Semiring S] (f : R \u2192+* S) (n : \u2115) [n.AtLeastTwo] :\n    p.eval\u2082 f (no_index (OfNat.ofNat n)) = f (p.eval (OfNat.ofNat n))", "start": [353, 1], "end": [356, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_C", "code": "@[simp]\ntheorem eval_C : (C a).eval x = a", "start": [358, 1], "end": [360, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_nat_cast", "code": "@[simp]\ntheorem eval_nat_cast {n : \u2115} : (n : R[X]).eval x = n", "start": [363, 1], "end": [364, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_ofNat", "code": "@[simp]\nlemma eval_ofNat (n : \u2115) [n.AtLeastTwo] (a : R) :\n    (no_index (OfNat.ofNat n : R[X])).eval a = OfNat.ofNat n := by\n  simp only [OfNat.ofNat, eval_nat_cast]", "start": [367, 1], "end": [370, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.eval_X", "code": "@[simp]\ntheorem eval_X : X.eval x = x", "start": [372, 1], "end": [374, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_monomial", "code": "@[simp]\ntheorem eval_monomial {n a} : (monomial n a).eval x = a * x ^ n", "start": [377, 1], "end": [379, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_zero", "code": "@[simp]\ntheorem eval_zero : (0 : R[X]).eval x = 0", "start": [382, 1], "end": [384, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_add", "code": "@[simp]\ntheorem eval_add : (p + q).eval x = p.eval x + q.eval x", "start": [387, 1], "end": [389, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_one", "code": "@[simp]\ntheorem eval_one : (1 : R[X]).eval x = 1", "start": [392, 1], "end": [394, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_bit0", "code": "@[simp]\ntheorem eval_bit0 : (bit0 p).eval x = bit0 (p.eval x)", "start": [398, 1], "end": [400, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_bit1", "code": "@[simp]\ntheorem eval_bit1 : (bit1 p).eval x = bit1 (p.eval x)", "start": [404, 1], "end": [406, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_smul", "code": "@[simp]\ntheorem eval_smul [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S) (p : R[X])\n    (x : R) : (s \u2022 p).eval x = s \u2022 p.eval x", "start": [409, 1], "end": [412, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_C_mul", "code": "@[simp]\ntheorem eval_C_mul : (C a * p).eval x = a * p.eval x", "start": [415, 1], "end": [422, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_monomial_one_add_sub", "code": "theorem eval_monomial_one_add_sub [CommRing S] (d : \u2115) (y : S) :\n    eval (1 + y) (monomial d (d + 1 : S)) - eval y (monomial d (d + 1 : S)) =\n      \u2211 x_1 : \u2115 in range (d + 1), \u2191((d + 1).choose x_1) * (\u2191x_1 * y ^ (x_1 - 1))", "start": [425, 1], "end": [446, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leval", "code": "@[simps]\ndef leval {R : Type*} [Semiring R] (r : R) : R[X] \u2192\u2097[R] R where\n  toFun f := f.eval r\n  map_add' _f _g := eval_add\n  map_smul' c f := eval_smul c f r", "start": [449, 1], "end": [454, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_nat_cast_mul", "code": "@[simp]\ntheorem eval_nat_cast_mul {n : \u2115} : ((n : R[X]) * p).eval x = n * p.eval x", "start": [458, 1], "end": [460, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_mul_X", "code": "@[simp]\ntheorem eval_mul_X : (p * X).eval x = p.eval x * x", "start": [463, 1], "end": [471, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_mul_X_pow", "code": "@[simp]\ntheorem eval_mul_X_pow {k : \u2115} : (p * X ^ k).eval x = p.eval x * x ^ k", "start": [474, 1], "end": [478, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_sum", "code": "theorem eval_sum (p : R[X]) (f : \u2115 \u2192 R \u2192 R[X]) (x : R) :\n    (p.sum f).eval x = p.sum fun n a => (f n a).eval x", "start": [481, 1], "end": [483, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_finset_sum", "code": "theorem eval_finset_sum (s : Finset \u03b9) (g : \u03b9 \u2192 R[X]) (x : R) :\n    (\u2211 i in s, g i).eval x = \u2211 i in s, (g i).eval x", "start": [486, 1], "end": [488, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot", "code": "def IsRoot (p : R[X]) (a : R) : Prop :=\n  p.eval a = 0", "start": [491, 1], "end": [493, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.decidable", "code": "instance IsRoot.decidable [DecidableEq R] : Decidable (IsRoot p a) := by\n  unfold IsRoot; infer_instance", "start": [496, 1], "end": [497, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.def", "code": "@[simp]\ntheorem IsRoot.def : IsRoot p a \u2194 p.eval a = 0", "start": [500, 1], "end": [502, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.eq_zero", "code": "theorem IsRoot.eq_zero (h : IsRoot p x) : eval x p = 0", "start": [505, 1], "end": [506, 4], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_eq_eval_zero", "code": "theorem coeff_zero_eq_eval_zero (p : R[X]) : coeff p 0 = p.eval 0", "start": [509, 1], "end": [516, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_isRoot_of_coeff_zero_eq_zero", "code": "theorem zero_isRoot_of_coeff_zero_eq_zero {p : R[X]} (hp : p.coeff 0 = 0) : IsRoot p 0", "start": [519, 1], "end": [520, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.dvd", "code": "theorem IsRoot.dvd {R : Type*} [CommSemiring R] {p q : R[X]} {x : R} (h : p.IsRoot x)\n    (hpq : p \u2223 q) : q.IsRoot x", "start": [523, 1], "end": [525, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_isRoot_C", "code": "theorem not_isRoot_C (r a : R) (hr : r \u2260 0) : \u00acIsRoot (C r) a", "start": [528, 1], "end": [528, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_surjective", "code": "theorem eval_surjective (x : R) : Function.Surjective <| eval x", "start": [531, 1], "end": [531, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp", "code": "def comp (p q : R[X]) : R[X] :=\n  p.eval\u2082 C q", "start": [538, 1], "end": [540, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_eq_sum_left", "code": "theorem comp_eq_sum_left : p.comp q = p.sum fun e a => C a * q ^ e", "start": [543, 1], "end": [543, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_X", "code": "@[simp]\ntheorem comp_X : p.comp X = p", "start": [546, 1], "end": [549, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_comp", "code": "@[simp]\ntheorem X_comp : X.comp p = p", "start": [552, 1], "end": [554, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_C", "code": "@[simp]\ntheorem comp_C : p.comp (C a) = C (p.eval a)", "start": [557, 1], "end": [558, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_comp", "code": "@[simp]\ntheorem C_comp : (C a).comp p = C a", "start": [561, 1], "end": [563, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nat_cast_comp", "code": "@[simp]\ntheorem nat_cast_comp {n : \u2115} : (n : R[X]).comp p = n", "start": [566, 1], "end": [567, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofNat_comp", "code": "@[simp]\ntheorem ofNat_comp (n : \u2115) [n.AtLeastTwo] : (no_index (OfNat.ofNat n) : R[X]).comp p = n", "start": [571, 1], "end": [573, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_zero", "code": "@[simp]\ntheorem comp_zero : p.comp (0 : R[X]) = C (p.eval 0)", "start": [575, 1], "end": [576, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_comp", "code": "@[simp]\ntheorem zero_comp : comp (0 : R[X]) p = 0", "start": [579, 1], "end": [580, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_one", "code": "@[simp]\ntheorem comp_one : p.comp 1 = C (p.eval 1)", "start": [583, 1], "end": [584, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.one_comp", "code": "@[simp]\ntheorem one_comp : comp (1 : R[X]) p = 1", "start": [587, 1], "end": [588, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.add_comp", "code": "@[simp]\ntheorem add_comp : (p + q).comp r = p.comp r + q.comp r", "start": [591, 1], "end": [593, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_comp", "code": "@[simp]\ntheorem monomial_comp (n : \u2115) : (monomial n a).comp p = C a * p ^ n", "start": [596, 1], "end": [598, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_X_comp", "code": "@[simp]\ntheorem mul_X_comp : (p * X).comp r = p.comp r * r", "start": [601, 1], "end": [608, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_comp", "code": "@[simp]\ntheorem X_pow_comp {k : \u2115} : (X ^ k).comp p = p ^ k", "start": [611, 1], "end": [615, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_X_pow_comp", "code": "@[simp]\ntheorem mul_X_pow_comp {k : \u2115} : (p * X ^ k).comp r = p.comp r * r ^ k", "start": [618, 1], "end": [622, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_comp", "code": "@[simp]\ntheorem C_mul_comp : (C a * p).comp r = C a * p.comp r", "start": [625, 1], "end": [632, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nat_cast_mul_comp", "code": "@[simp]\ntheorem nat_cast_mul_comp {n : \u2115} : ((n : R[X]) * p).comp r = n * p.comp r", "start": [635, 1], "end": [637, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_X_add_nat_cast_comp", "code": "theorem mul_X_add_nat_cast_comp {n : \u2115} :\n    (p * (X + (n : R[X]))).comp q = p.comp q * (q + n)", "start": [640, 1], "end": [642, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_comp", "code": "@[simp]\ntheorem mul_comp {R : Type*} [CommSemiring R] (p q r : R[X]) :\n    (p * q).comp r = p.comp r * q.comp r", "start": [646, 1], "end": [649, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.pow_comp", "code": "@[simp]\ntheorem pow_comp {R : Type*} [CommSemiring R] (p q : R[X]) (n : \u2115) :\n    (p ^ n).comp q = p.comp q ^ n", "start": [652, 1], "end": [656, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bit0_comp", "code": "@[simp]\ntheorem bit0_comp : comp (bit0 p : R[X]) q = bit0 (p.comp q)", "start": [660, 1], "end": [661, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bit1_comp", "code": "@[simp]\ntheorem bit1_comp : comp (bit1 p : R[X]) q = bit1 (p.comp q)", "start": [665, 1], "end": [667, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_comp", "code": "@[simp]\ntheorem smul_comp [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S) (p q : R[X]) :\n    (s \u2022 p).comp q = s \u2022 p.comp q", "start": [670, 1], "end": [673, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_assoc", "code": "theorem comp_assoc {R : Type*} [CommSemiring R] (\u03c6 \u03c8 \u03c7 : R[X]) :\n    (\u03c6.comp \u03c8).comp \u03c7 = \u03c6.comp (\u03c8.comp \u03c7)", "start": [676, 1], "end": [680, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_comp_degree_mul_degree", "code": "theorem coeff_comp_degree_mul_degree (hqd0 : natDegree q \u2260 0) :\n    coeff (p.comp q) (natDegree p * natDegree q) =\n    leadingCoeff p * leadingCoeff q ^ natDegree p", "start": [683, 1], "end": [698, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_comp", "code": "@[simp] lemma sum_comp (s : Finset \u03b9) (p : \u03b9 \u2192 R[X]) (q : R[X]) :\n    (\u2211 i in s, p i).comp q = \u2211 i in s, (p i).comp q := Polynomial.eval\u2082_finset_sum _ _ _ _", "start": [701, 1], "end": [702, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.map", "code": "def map : R[X] \u2192 S[X] :=\n  eval\u2082 (C.comp f) X", "start": [712, 1], "end": [714, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_C", "code": "@[simp]\ntheorem map_C : (C a).map f = C (f a)", "start": [717, 1], "end": [719, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_X", "code": "@[simp]\ntheorem map_X : X.map f = X", "start": [722, 1], "end": [724, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_monomial", "code": "@[simp]\ntheorem map_monomial {n a} : (monomial n a).map f = monomial n (f a)", "start": [727, 1], "end": [730, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_zero", "code": "@[simp]\nprotected theorem map_zero : (0 : R[X]).map f = 0", "start": [733, 1], "end": [735, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_add", "code": "@[simp]\nprotected theorem map_add : (p + q).map f = p.map f + q.map f", "start": [738, 1], "end": [740, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_one", "code": "@[simp]\nprotected theorem map_one : (1 : R[X]).map f = 1", "start": [743, 1], "end": [745, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_mul", "code": "@[simp]\nprotected theorem map_mul : (p * q).map f = p.map f * q.map f", "start": [748, 1], "end": [751, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_smul", "code": "@[simp]\nprotected theorem map_smul (r : R) : (r \u2022 p).map f = f r \u2022 p.map f", "start": [754, 1], "end": [756, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapRingHom", "code": "def mapRingHom (f : R \u2192+* S) : R[X] \u2192+* S[X] where\n  toFun := Polynomial.map f\n  map_add' _ _ := Polynomial.map_add f\n  map_zero' := Polynomial.map_zero f\n  map_mul' _ _ := Polynomial.map_mul f\n  map_one' := Polynomial.map_one f", "start": [765, 1], "end": [771, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_mapRingHom", "code": "@[simp]\ntheorem coe_mapRingHom (f : R \u2192+* S) : \u21d1(mapRingHom f) = map f", "start": [774, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_nat_cast", "code": "@[simp]\nprotected theorem map_nat_cast (n : \u2115) : (n : R[X]).map f = n", "start": [780, 1], "end": [782, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_ofNat", "code": "@[simp]\nprotected theorem map_ofNat (n : \u2115) [n.AtLeastTwo] :\n    (no_index (OfNat.ofNat n) : R[X]).map f = OfNat.ofNat n", "start": [786, 1], "end": [789, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_bit0", "code": "@[simp]\nprotected theorem map_bit0 : (bit0 p).map f = bit0 (p.map f)", "start": [792, 1], "end": [794, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_bit1", "code": "@[simp]\nprotected theorem map_bit1 : (bit1 p).map f = bit1 (p.map f)", "start": [798, 1], "end": [800, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_dvd", "code": "theorem map_dvd (f : R \u2192+* S) {x y : R[X]} : x \u2223 y \u2192 x.map f \u2223 y.map f", "start": [804, 1], "end": [805, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_map", "code": "@[simp]\ntheorem coeff_map (n : \u2115) : coeff (p.map f) n = f (coeff p n)", "start": [808, 1], "end": [815, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapEquiv", "code": "@[simps!]\ndef mapEquiv (e : R \u2243+* S) : R[X] \u2243+* S[X] :=\n  RingEquiv.ofHomInv (mapRingHom (e : R \u2192+* S)) (mapRingHom (e.symm : S \u2192+* R)) (by ext <;> simp)\n    (by ext <;> simp)", "start": [818, 1], "end": [822, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_map", "code": "theorem map_map [Semiring T] (g : S \u2192+* T) (p : R[X]) : (p.map f).map g = p.map (g.comp f)", "start": [827, 1], "end": [828, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_id", "code": "@[simp]\ntheorem map_id : p.map (RingHom.id _) = p", "start": [831, 1], "end": [832, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_eq_eval_map", "code": "theorem eval\u2082_eq_eval_map {x : S} : p.eval\u2082 f x = (p.map f).eval x", "start": [835, 1], "end": [841, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_injective", "code": "theorem map_injective (hf : Function.Injective f) : Function.Injective (map f)", "start": [844, 1], "end": [845, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_surjective", "code": "theorem map_surjective (hf : Function.Surjective f) : Function.Surjective (map f)", "start": [848, 1], "end": [856, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_map_le", "code": "theorem degree_map_le (p : R[X]) : degree (p.map f) \u2264 degree p", "start": [859, 1], "end": [862, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_map_le", "code": "theorem natDegree_map_le (p : R[X]) : natDegree (p.map f) \u2264 natDegree p", "start": [865, 1], "end": [866, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_eq_zero_iff", "code": "protected theorem map_eq_zero_iff (hf : Function.Injective f) : p.map f = 0 \u2194 p = 0", "start": [871, 1], "end": [872, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_ne_zero_iff", "code": "protected theorem map_ne_zero_iff (hf : Function.Injective f) : p.map f \u2260 0 \u2194 p \u2260 0", "start": [875, 1], "end": [876, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_monic_eq_zero_iff", "code": "theorem map_monic_eq_zero_iff (hp : p.Monic) : p.map f = 0 \u2194 \u2200 x, f x = 0", "start": [879, 1], "end": [886, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_monic_ne_zero", "code": "theorem map_monic_ne_zero (hp : p.Monic) [Nontrivial S] : p.map f \u2260 0", "start": [889, 1], "end": [890, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_map_eq_of_leadingCoeff_ne_zero", "code": "theorem degree_map_eq_of_leadingCoeff_ne_zero (f : R \u2192+* S) (hf : f (leadingCoeff p) \u2260 0) :\n    degree (p.map f) = degree p", "start": [893, 1], "end": [901, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_map_of_leadingCoeff_ne_zero", "code": "theorem natDegree_map_of_leadingCoeff_ne_zero (f : R \u2192+* S) (hf : f (leadingCoeff p) \u2260 0) :\n    natDegree (p.map f) = natDegree p", "start": [904, 1], "end": [906, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_map_of_leadingCoeff_ne_zero", "code": "theorem leadingCoeff_map_of_leadingCoeff_ne_zero (f : R \u2192+* S) (hf : f (leadingCoeff p) \u2260 0) :\n    leadingCoeff (p.map f) = f (leadingCoeff p)", "start": [909, 1], "end": [912, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapRingHom_id", "code": "@[simp]\ntheorem mapRingHom_id : mapRingHom (RingHom.id R) = RingHom.id R[X]", "start": [917, 1], "end": [919, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mapRingHom_comp", "code": "@[simp]\ntheorem mapRingHom_comp [Semiring T] (f : S \u2192+* T) (g : R \u2192+* S) :\n    (mapRingHom f).comp (mapRingHom g) = mapRingHom (f.comp g)", "start": [922, 1], "end": [925, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_list_prod", "code": "protected theorem map_list_prod (L : List R[X]) : L.prod.map f = (L.map <| map f).prod", "start": [928, 1], "end": [929, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_pow", "code": "@[simp]\nprotected theorem map_pow (n : \u2115) : (p ^ n).map f = p.map f ^ n", "start": [932, 1], "end": [934, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_map_rangeS", "code": "theorem mem_map_rangeS {p : S[X]} : p \u2208 (mapRingHom f).rangeS \u2194 \u2200 n, p.coeff n \u2208 f.rangeS", "start": [937, 1], "end": [948, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_map_range", "code": "theorem mem_map_range {R S : Type*} [Ring R] [Ring S] (f : R \u2192+* S) {p : S[X]} :\n    p \u2208 (mapRingHom f).range \u2194 \u2200 n, p.coeff n \u2208 f.range", "start": [951, 1], "end": [953, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_map", "code": "theorem eval\u2082_map [Semiring T] (g : S \u2192+* T) (x : T) : (p.map f).eval\u2082 g x = p.eval\u2082 (g.comp f) x", "start": [956, 1], "end": [957, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_map", "code": "theorem eval_map (x : S) : (p.map f).eval x = p.eval\u2082 f x", "start": [960, 1], "end": [961, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_sum", "code": "protected theorem map_sum {\u03b9 : Type*} (g : \u03b9 \u2192 R[X]) (s : Finset \u03b9) :\n    (\u2211 i in s, g i).map f = \u2211 i in s, (g i).map f", "start": [964, 1], "end": [966, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_comp", "code": "theorem map_comp (p q : R[X]) : map f (p.comp q) = (map f p).comp (map f q)", "start": [969, 1], "end": [976, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_zero_map", "code": "@[simp]\ntheorem eval_zero_map (f : R \u2192+* S) (p : R[X]) : (p.map f).eval 0 = f (p.eval 0)", "start": [979, 1], "end": [981, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_one_map", "code": "@[simp]\ntheorem eval_one_map (f : R \u2192+* S) (p : R[X]) : (p.map f).eval 1 = f (p.eval 1)", "start": [984, 1], "end": [991, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_nat_cast_map", "code": "@[simp]\ntheorem eval_nat_cast_map (f : R \u2192+* S) (p : R[X]) (n : \u2115) :\n    (p.map f).eval (n : S) = f (p.eval n)", "start": [994, 1], "end": [1002, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_int_cast_map", "code": "@[simp]\ntheorem eval_int_cast_map {R S : Type*} [Ring R] [Ring S] (f : R \u2192+* S) (p : R[X]) (i : \u2124) :\n    (p.map f).eval (i : S) = f (p.eval i)", "start": [1005, 1], "end": [1013, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hom_eval\u2082", "code": "theorem hom_eval\u2082 (x : S) : g (p.eval\u2082 f x) = p.eval\u2082 (g.comp f) (g x)", "start": [1029, 1], "end": [1030, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_hom", "code": "theorem eval\u2082_hom (x : R) : p.eval\u2082 f (f x) = f (p.eval x)", "start": [1045, 1], "end": [1046, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_comp", "code": "theorem eval\u2082_comp {x : S} : eval\u2082 f x (p.comp q) = eval\u2082 f (eval\u2082 f x q) p", "start": [1055, 1], "end": [1056, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_comp_eval\u2082", "code": "@[simp]\ntheorem iterate_comp_eval\u2082 (k : \u2115) (t : S) :\n    eval\u2082 f t (p.comp^[k] q) = (fun x => eval\u2082 f x p)^[k] (eval\u2082 f t q)", "start": [1059, 1], "end": [1064, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_mul", "code": "@[simp]\ntheorem eval_mul : (p * q).eval x = p.eval x * q.eval x", "start": [1073, 1], "end": [1075, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.evalRingHom", "code": "def evalRingHom : R \u2192 R[X] \u2192+* R :=\n  eval\u2082RingHom (RingHom.id _)", "start": [1078, 1], "end": [1080, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_evalRingHom", "code": "@[simp]\ntheorem coe_evalRingHom (r : R) : (evalRingHom r : R[X] \u2192 R) = eval r", "start": [1083, 1], "end": [1085, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.evalRingHom_zero", "code": "theorem evalRingHom_zero : evalRingHom 0 = constantCoeff", "start": [1088, 1], "end": [1089, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_pow", "code": "@[simp]\ntheorem eval_pow (n : \u2115) : (p ^ n).eval x = p.eval x ^ n", "start": [1092, 1], "end": [1094, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_comp", "code": "@[simp]\ntheorem eval_comp : (p.comp q).eval x = p.eval (q.eval x)", "start": [1097, 1], "end": [1104, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_comp_eval", "code": "@[simp]\ntheorem iterate_comp_eval :\n    \u2200 (k : \u2115) (t : R), (p.comp^[k] q).eval t = (fun x => p.eval x)^[k] (q.eval t)", "start": [1107, 1], "end": [1110, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.compRingHom", "code": "def compRingHom : R[X] \u2192 R[X] \u2192+* R[X] :=\n  eval\u2082RingHom C", "start": [1113, 1], "end": [1115, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_compRingHom", "code": "@[simp]\ntheorem coe_compRingHom (q : R[X]) : (compRingHom q : R[X] \u2192 R[X]) = fun p => comp p q", "start": [1118, 1], "end": [1120, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_compRingHom_apply", "code": "theorem coe_compRingHom_apply (p q : R[X]) : (compRingHom q : R[X] \u2192 R[X]) p = comp p q", "start": [1123, 1], "end": [1124, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_mul_left_of_isRoot", "code": "theorem root_mul_left_of_isRoot (p : R[X]) {q : R[X]} : IsRoot q a \u2192 IsRoot (p * q) a", "start": [1127, 1], "end": [1128, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_mul_right_of_isRoot", "code": "theorem root_mul_right_of_isRoot {p : R[X]} (q : R[X]) : IsRoot p a \u2192 IsRoot (p * q) a", "start": [1131, 1], "end": [1132, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_multiset_prod", "code": "theorem eval\u2082_multiset_prod (s : Multiset R[X]) (x : S) :\n    eval\u2082 f x s.prod = (s.map (eval\u2082 f x)).prod", "start": [1135, 1], "end": [1137, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_finset_prod", "code": "theorem eval\u2082_finset_prod (s : Finset \u03b9) (g : \u03b9 \u2192 R[X]) (x : S) :\n    (\u220f i in s, g i).eval\u2082 f x = \u220f i in s, (g i).eval\u2082 f x", "start": [1140, 1], "end": [1142, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_list_prod", "code": "theorem eval_list_prod (l : List R[X]) (x : R) : eval x l.prod = (l.map (eval x)).prod", "start": [1145, 1], "end": [1148, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_multiset_prod", "code": "theorem eval_multiset_prod (s : Multiset R[X]) (x : R) : eval x s.prod = (s.map (eval x)).prod", "start": [1151, 1], "end": [1154, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_prod", "code": "theorem eval_prod {\u03b9 : Type*} (s : Finset \u03b9) (p : \u03b9 \u2192 R[X]) (x : R) :\n    eval x (\u220f j in s, p j) = \u220f j in s, eval x (p j)", "start": [1157, 1], "end": [1161, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.list_prod_comp", "code": "theorem list_prod_comp (l : List R[X]) (q : R[X]) :\n    l.prod.comp q = (l.map fun p : R[X] => p.comp q).prod", "start": [1164, 1], "end": [1166, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.multiset_prod_comp", "code": "theorem multiset_prod_comp (s : Multiset R[X]) (q : R[X]) :\n    s.prod.comp q = (s.map fun p : R[X] => p.comp q).prod", "start": [1169, 1], "end": [1171, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_comp", "code": "theorem prod_comp {\u03b9 : Type*} (s : Finset \u03b9) (p : \u03b9 \u2192 R[X]) (q : R[X]) :\n    (\u220f j in s, p j).comp q = \u220f j in s, (p j).comp q", "start": [1174, 1], "end": [1176, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_prod", "code": "theorem isRoot_prod {R} [CommRing R] [IsDomain R] {\u03b9 : Type*} (s : Finset \u03b9) (p : \u03b9 \u2192 R[X])\n    (x : R) : IsRoot (\u220f j in s, p j) x \u2194 \u2203 i \u2208 s, IsRoot (p i) x", "start": [1179, 1], "end": [1181, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_dvd", "code": "theorem eval_dvd : p \u2223 q \u2192 eval x p \u2223 eval x q", "start": [1184, 1], "end": [1185, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_eq_zero_of_dvd_of_eval_eq_zero", "code": "theorem eval_eq_zero_of_dvd_of_eval_eq_zero : p \u2223 q \u2192 eval x p = 0 \u2192 eval x q = 0", "start": [1188, 1], "end": [1189, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_geom_sum", "code": "@[simp]\ntheorem eval_geom_sum {R} [CommSemiring R] {n : \u2115} {x : R} :\n    eval x (\u2211 i in range n, X ^ i) = \u2211 i in range n, x ^ i", "start": [1192, 1], "end": [1194, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_map_subset", "code": "theorem support_map_subset [Semiring R] [Semiring S] (f : R \u2192+* S) (p : R[X]) :\n    (map f p).support \u2286 p.support", "start": [1203, 1], "end": [1207, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_map_of_injective", "code": "theorem support_map_of_injective [Semiring R] [Semiring S] (p : R[X]) {f : R \u2192+* S}\n    (hf : Function.Injective f) : (map f p).support = p.support", "start": [1210, 1], "end": [1213, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_multiset_prod", "code": "protected theorem map_multiset_prod (m : Multiset R[X]) : m.prod.map f = (m.map <| map f).prod", "start": [1218, 1], "end": [1219, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_prod", "code": "protected theorem map_prod {\u03b9 : Type*} (g : \u03b9 \u2192 R[X]) (s : Finset \u03b9) :\n    (\u220f i in s, g i).map f = \u220f i in s, (g i).map f", "start": [1222, 1], "end": [1224, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.map", "code": "theorem IsRoot.map {f : R \u2192+* S} {x : R} {p : R[X]} (h : IsRoot p x) : IsRoot (p.map f) (f x)", "start": [1227, 1], "end": [1228, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.IsRoot.of_map", "code": "theorem IsRoot.of_map {R} [CommRing R] {f : R \u2192+* S} {x : R} {p : R[X]} (h : IsRoot (p.map f) (f x))\n    (hf : Function.Injective f) : IsRoot p x", "start": [1231, 1], "end": [1233, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_map_iff", "code": "theorem isRoot_map_iff {R : Type*} [CommRing R] {f : R \u2192+* S} {x : R} {p : R[X]}\n    (hf : Function.Injective f) : IsRoot (p.map f) (f x) \u2194 IsRoot p x", "start": [1236, 1], "end": [1238, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_sub", "code": "@[simp]\nprotected theorem map_sub {S} [Ring S] (f : R \u2192+* S) : (p - q).map f = p.map f - q.map f", "start": [1249, 1], "end": [1251, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_neg", "code": "@[simp]\nprotected theorem map_neg {S} [Ring S] (f : R \u2192+* S) : (-p).map f = -p.map f", "start": [1254, 1], "end": [1256, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_int_cast", "code": "@[simp]\ntheorem map_int_cast {S} [Ring S] (f : R \u2192+* S) (n : \u2124) : map f \u2191n = \u2191n", "start": [1259, 1], "end": [1261, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_int_cast", "code": "@[simp]\ntheorem eval_int_cast {n : \u2124} {x : R} : (n : R[X]).eval x = n", "start": [1264, 1], "end": [1266, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_neg", "code": "@[simp]\ntheorem eval\u2082_neg {S} [Ring S] (f : R \u2192+* S) {x : S} : (-p).eval\u2082 f x = -p.eval\u2082 f x", "start": [1269, 1], "end": [1271, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_sub", "code": "@[simp]\ntheorem eval\u2082_sub {S} [Ring S] (f : R \u2192+* S) {x : S} :\n    (p - q).eval\u2082 f x = p.eval\u2082 f x - q.eval\u2082 f x", "start": [1274, 1], "end": [1277, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_neg", "code": "@[simp]\ntheorem eval_neg (p : R[X]) (x : R) : (-p).eval x = -p.eval x", "start": [1280, 1], "end": [1282, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_sub", "code": "@[simp]\ntheorem eval_sub (p q : R[X]) (x : R) : (p - q).eval x = p.eval x - q.eval x", "start": [1285, 1], "end": [1287, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_X_sub_C", "code": "theorem root_X_sub_C : IsRoot (X - C a) b \u2194 a = b", "start": [1290, 1], "end": [1291, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.neg_comp", "code": "@[simp]\ntheorem neg_comp : (-p).comp q = -p.comp q", "start": [1294, 1], "end": [1296, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sub_comp", "code": "@[simp]\ntheorem sub_comp : (p - q).comp r = p.comp r - q.comp r", "start": [1299, 1], "end": [1301, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cast_int_comp", "code": "@[simp]\ntheorem cast_int_comp (i : \u2124) : comp (i : R[X]) p = i", "start": [1304, 1], "end": [1305, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_at_int_cast", "code": "@[simp]\ntheorem eval\u2082_at_int_cast {S : Type*} [Ring S] (f : R \u2192+* S) (n : \u2124) :\n    p.eval\u2082 f n = f (p.eval n)", "start": [1308, 1], "end": [1312, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_X_sub_int_cast_comp", "code": "theorem mul_X_sub_int_cast_comp {n : \u2115} :\n    (p * (X - (n : R[X]))).comp q = p.comp q * (q - n)", "start": [1314, 1], "end": [1316, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "imports": ["Mathlib/Data/Set/Countable.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Measurability.lean", "Mathlib/Order/Disjointed.lean", "Mathlib/Logic/Encodable/Lattice.lean"], "premises": [{"full_name": "MeasurableSpace", "code": "@[class] structure MeasurableSpace (\u03b1 : Type*) where\n  \n  MeasurableSet' : Set \u03b1 \u2192 Prop\n  \n  measurableSet_empty : MeasurableSet' \u2205\n  \n  measurableSet_compl : \u2200 s, MeasurableSet' s \u2192 MeasurableSet' s\u1d9c\n  \n  measurableSet_iUnion : \u2200 f : \u2115 \u2192 Set \u03b1, (\u2200 i, MeasurableSet' (f i)) \u2192 MeasurableSet' (\u22c3 i, f i)", "start": [47, 1], "end": [58, 98], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet", "code": "def MeasurableSet [MeasurableSpace \u03b1] (s : Set \u03b1) : Prop :=\n  \u2039MeasurableSpace \u03b1\u203a.MeasurableSet' s", "start": [63, 1], "end": [65, 39], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.empty", "code": "@[simp, measurability]\ntheorem MeasurableSet.empty [MeasurableSpace \u03b1] : MeasurableSet (\u2205 : Set \u03b1)", "start": [79, 1], "end": [81, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.compl", "code": "@[measurability]\nprotected theorem MeasurableSet.compl : MeasurableSet s \u2192 MeasurableSet s\u1d9c", "start": [86, 1], "end": [88, 42], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.of_compl", "code": "protected theorem MeasurableSet.of_compl (h : MeasurableSet s\u1d9c) : MeasurableSet s", "start": [91, 1], "end": [92, 26], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.compl_iff", "code": "@[simp]\ntheorem MeasurableSet.compl_iff : MeasurableSet s\u1d9c \u2194 MeasurableSet s", "start": [95, 1], "end": [97, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.univ", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.univ : MeasurableSet (univ : Set \u03b1)", "start": [100, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.measurableSet", "code": "@[nontriviality, measurability]\ntheorem Subsingleton.measurableSet [Subsingleton \u03b1] {s : Set \u03b1} : MeasurableSet s", "start": [105, 1], "end": [107, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.congr", "code": "theorem MeasurableSet.congr {s t : Set \u03b1} (hs : MeasurableSet s) (h : s = t) : MeasurableSet t", "start": [110, 1], "end": [111, 12], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.iUnion", "code": "@[measurability]\nprotected theorem MeasurableSet.iUnion [Countable \u03b9] \u2983f : \u03b9 \u2192 Set \u03b1\u2984\n    (h : \u2200 b, MeasurableSet (f b)) : MeasurableSet (\u22c3 b, f b)", "start": [114, 1], "end": [121, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.biUnion_decode\u2082", "code": "@[deprecated MeasurableSet.iUnion]\ntheorem MeasurableSet.biUnion_decode\u2082 [Encodable \u03b2] \u2983f : \u03b2 \u2192 Set \u03b1\u2984 (h : \u2200 b, MeasurableSet (f b))\n    (n : \u2115) : MeasurableSet (\u22c3 b \u2208 decode\u2082 \u03b2 n, f b)", "start": [124, 1], "end": [127, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.biUnion", "code": "protected theorem MeasurableSet.biUnion {f : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hs : s.Countable)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c3 b \u2208 s, f b)", "start": [130, 1], "end": [134, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measurableSet_biUnion", "code": "theorem Set.Finite.measurableSet_biUnion {f : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hs : s.Finite)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c3 b \u2208 s, f b)", "start": [137, 1], "end": [139, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.measurableSet_biUnion", "code": "theorem Finset.measurableSet_biUnion {f : \u03b2 \u2192 Set \u03b1} (s : Finset \u03b2)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c3 b \u2208 s, f b)", "start": [142, 1], "end": [144, 41], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.sUnion", "code": "protected theorem MeasurableSet.sUnion {s : Set (Set \u03b1)} (hs : s.Countable)\n    (h : \u2200 t \u2208 s, MeasurableSet t) : MeasurableSet (\u22c3\u2080 s)", "start": [147, 1], "end": [150, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measurableSet_sUnion", "code": "theorem Set.Finite.measurableSet_sUnion {s : Set (Set \u03b1)} (hs : s.Finite)\n    (h : \u2200 t \u2208 s, MeasurableSet t) : MeasurableSet (\u22c3\u2080 s)", "start": [153, 1], "end": [155, 38], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.iInter", "code": "@[measurability]\ntheorem MeasurableSet.iInter [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} (h : \u2200 b, MeasurableSet (f b)) :\n    MeasurableSet (\u22c2 b, f b)", "start": [158, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.biInter", "code": "theorem MeasurableSet.biInter {f : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hs : s.Countable)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c2 b \u2208 s, f b)", "start": [164, 1], "end": [166, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measurableSet_biInter", "code": "theorem Set.Finite.measurableSet_biInter {f : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hs : s.Finite)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c2 b \u2208 s, f b)", "start": [169, 1], "end": [171, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.measurableSet_biInter", "code": "theorem Finset.measurableSet_biInter {f : \u03b2 \u2192 Set \u03b1} (s : Finset \u03b2)\n    (h : \u2200 b \u2208 s, MeasurableSet (f b)) : MeasurableSet (\u22c2 b \u2208 s, f b)", "start": [174, 1], "end": [176, 41], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.sInter", "code": "theorem MeasurableSet.sInter {s : Set (Set \u03b1)} (hs : s.Countable) (h : \u2200 t \u2208 s, MeasurableSet t) :\n    MeasurableSet (\u22c2\u2080 s)", "start": [179, 1], "end": [182, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measurableSet_sInter", "code": "theorem Set.Finite.measurableSet_sInter {s : Set (Set \u03b1)} (hs : s.Finite)\n    (h : \u2200 t \u2208 s, MeasurableSet t) : MeasurableSet (\u22c2\u2080 s)", "start": [185, 1], "end": [187, 38], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.union", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.union {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081)\n    (h\u2082 : MeasurableSet s\u2082) : MeasurableSet (s\u2081 \u222a s\u2082)", "start": [190, 1], "end": [194, 46], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.inter", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.inter {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081)\n    (h\u2082 : MeasurableSet s\u2082) : MeasurableSet (s\u2081 \u2229 s\u2082)", "start": [197, 1], "end": [201, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.diff", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.diff {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081)\n    (h\u2082 : MeasurableSet s\u2082) : MeasurableSet (s\u2081 \\ s\u2082)", "start": [204, 1], "end": [207, 20], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.symmDiff", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.symmDiff {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081)\n    (h\u2082 : MeasurableSet s\u2082) : MeasurableSet (s\u2081 \u2206 s\u2082)", "start": [210, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.ite", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.ite {t s\u2081 s\u2082 : Set \u03b1} (ht : MeasurableSet t)\n    (h\u2081 : MeasurableSet s\u2081) (h\u2082 : MeasurableSet s\u2082) : MeasurableSet (t.ite s\u2081 s\u2082)", "start": [216, 1], "end": [219, 35], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.ite'", "code": "theorem MeasurableSet.ite' {s t : Set \u03b1} {p : Prop} (hs : p \u2192 MeasurableSet s)\n    (ht : \u00acp \u2192 MeasurableSet t) : MeasurableSet (ite p s t)", "start": [222, 1], "end": [225, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.cond", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.cond {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081)\n    (h\u2082 : MeasurableSet s\u2082) {i : Bool} : MeasurableSet (cond i s\u2081 s\u2082)", "start": [228, 1], "end": [232, 18], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.disjointed", "code": "@[simp, measurability]\nprotected theorem MeasurableSet.disjointed {f : \u2115 \u2192 Set \u03b1} (h : \u2200 i, MeasurableSet (f i)) (n) :\n    MeasurableSet (disjointed f n)", "start": [235, 1], "end": [238, 67], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.const", "code": "protected theorem MeasurableSet.const (p : Prop) : MeasurableSet { _a : \u03b1 | p }", "start": [241, 1], "end": [242, 26], "kind": "commanddeclaration"}, {"full_name": "nonempty_measurable_superset", "code": "theorem nonempty_measurable_superset (s : Set \u03b1) : Nonempty { t // s \u2286 t \u2227 MeasurableSet t }", "start": [245, 1], "end": [247, 46], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_injective", "code": "theorem MeasurableSpace.measurableSet_injective : Injective (@MeasurableSet \u03b1)", "start": [252, 1], "end": [253, 46], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.ext", "code": "@[ext]\ntheorem MeasurableSpace.ext {m\u2081 m\u2082 : MeasurableSpace \u03b1}\n    (h : \u2200 s : Set \u03b1, MeasurableSet[m\u2081] s \u2194 MeasurableSet[m\u2082] s) : m\u2081 = m\u2082", "start": [255, 1], "end": [258, 59], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.ext_iff", "code": "theorem MeasurableSpace.ext_iff {m\u2081 m\u2082 : MeasurableSpace \u03b1} :\n    m\u2081 = m\u2082 \u2194 \u2200 s : Set \u03b1, MeasurableSet[m\u2081] s \u2194 MeasurableSet[m\u2082] s", "start": [261, 1], "end": [263, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableSingletonClass", "code": "class MeasurableSingletonClass (\u03b1 : Type*) [MeasurableSpace \u03b1] : Prop where\n  \n  measurableSet_singleton : \u2200 x, MeasurableSet ({x} : Set \u03b1)", "start": [266, 1], "end": [269, 61], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.singleton", "code": "@[simp]\nlemma MeasurableSet.singleton [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1] (a : \u03b1) :\n    MeasurableSet {a} :=\n  measurableSet_singleton a", "start": [274, 1], "end": [277, 28], "kind": "mathlibtacticlemma"}, {"full_name": "measurableSet_eq", "code": "@[measurability]\ntheorem measurableSet_eq {a : \u03b1} : MeasurableSet { x | x = a }", "start": [283, 1], "end": [284, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.insert", "code": "@[measurability]\nprotected theorem MeasurableSet.insert {s : Set \u03b1} (hs : MeasurableSet s) (a : \u03b1) :\n    MeasurableSet (insert a s)", "start": [287, 1], "end": [290, 27], "kind": "commanddeclaration"}, {"full_name": "measurableSet_insert", "code": "@[simp]\ntheorem measurableSet_insert {a : \u03b1} {s : Set \u03b1} : MeasurableSet (insert a s) \u2194 MeasurableSet s", "start": [293, 1], "end": [298, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.measurableSet", "code": "theorem Set.Subsingleton.measurableSet {s : Set \u03b1} (hs : s.Subsingleton) : MeasurableSet s", "start": [301, 1], "end": [302, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.measurableSet", "code": "theorem Set.Finite.measurableSet {s : Set \u03b1} (hs : s.Finite) : MeasurableSet s", "start": [305, 1], "end": [306, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.measurableSet", "code": "@[measurability]\nprotected theorem Finset.measurableSet (s : Finset \u03b1) : MeasurableSet (\u2191s : Set \u03b1)", "start": [309, 1], "end": [311, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.measurableSet", "code": "theorem Set.Countable.measurableSet {s : Set \u03b1} (hs : s.Countable) : MeasurableSet s", "start": [314, 1], "end": [316, 44], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.copy", "code": "protected def copy (m : MeasurableSpace \u03b1) (p : Set \u03b1 \u2192 Prop) (h : \u2200 s, p s \u2194 MeasurableSet[m] s) :\n    MeasurableSpace \u03b1 where\n  MeasurableSet' := p\n  measurableSet_empty := by simpa only [h] using m.measurableSet_empty\n  measurableSet_compl := by simpa only [h] using m.measurableSet_compl\n  measurableSet_iUnion := by simpa only [h] using m.measurableSet_iUnion", "start": [323, 1], "end": [330, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_copy", "code": "lemma measurableSet_copy {m : MeasurableSpace \u03b1} {p : Set \u03b1 \u2192 Prop}\n    (h : \u2200 s, p s \u2194 MeasurableSet[m] s) {s} : MeasurableSet[.copy m p h] s \u2194 p s :=\n  Iff.rfl", "start": [332, 1], "end": [334, 10], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableSpace.copy_eq", "code": "lemma copy_eq {m : MeasurableSpace \u03b1} {p : Set \u03b1 \u2192 Prop} (h : \u2200 s, p s \u2194 MeasurableSet[m] s) :\n    m.copy p h = m :=\n  ext h", "start": [336, 1], "end": [338, 8], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableSpace.le_def", "code": "theorem le_def {\u03b1} {a b : MeasurableSpace \u03b1} : a \u2264 b \u2194 a.MeasurableSet' \u2264 b.MeasurableSet'", "start": [344, 1], "end": [345, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.GenerateMeasurable", "code": "inductive GenerateMeasurable (s : Set (Set \u03b1)) : Set \u03b1 \u2192 Prop\n  | protected basic : \u2200 u \u2208 s, GenerateMeasurable s u\n  | protected empty : GenerateMeasurable s \u2205\n  | protected compl : \u2200 t, GenerateMeasurable s t \u2192 GenerateMeasurable s t\u1d9c\n  | protected iUnion : \u2200 f : \u2115 \u2192 Set \u03b1, (\u2200 n, GenerateMeasurable s (f n)) \u2192\n      GenerateMeasurable s (\u22c3 i, f i)", "start": [353, 1], "end": [359, 38], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom", "code": "def generateFrom (s : Set (Set \u03b1)) : MeasurableSpace \u03b1 where\n  MeasurableSet' := GenerateMeasurable s\n  measurableSet_empty := .empty\n  measurableSet_compl := .compl\n  measurableSet_iUnion := .iUnion", "start": [362, 1], "end": [367, 34], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_generateFrom", "code": "theorem measurableSet_generateFrom {s : Set (Set \u03b1)} {t : Set \u03b1} (ht : t \u2208 s) :\n    MeasurableSet[generateFrom s] t", "start": [370, 1], "end": [372, 14], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_induction", "code": "@[elab_as_elim]\ntheorem generateFrom_induction (p : Set \u03b1 \u2192 Prop) (C : Set (Set \u03b1)) (hC : \u2200 t \u2208 C, p t)\n    (h_empty : p \u2205) (h_compl : \u2200 t, p t \u2192 p t\u1d9c)\n    (h_Union : \u2200 f : \u2115 \u2192 Set \u03b1, (\u2200 n, p (f n)) \u2192 p (\u22c3 i, f i)) {s : Set \u03b1}\n    (hs : MeasurableSet[generateFrom C] s) : p s", "start": [375, 1], "end": [381, 61], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_le", "code": "theorem generateFrom_le {s : Set (Set \u03b1)} {m : MeasurableSpace \u03b1}\n    (h : \u2200 t \u2208 s, MeasurableSet[m] t) : generateFrom s \u2264 m", "start": [384, 1], "end": [387, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_le_iff", "code": "theorem generateFrom_le_iff {s : Set (Set \u03b1)} (m : MeasurableSpace \u03b1) :\n    generateFrom s \u2264 m \u2194 s \u2286 { t | MeasurableSet[m] t }", "start": [390, 1], "end": [392, 92], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_measurableSet", "code": "@[simp]\ntheorem generateFrom_measurableSet [MeasurableSpace \u03b1] :\n    generateFrom { s : Set \u03b1 | MeasurableSet s } = \u2039_\u203a", "start": [395, 1], "end": [398, 80], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.forall_generateFrom_mem_iff_mem_iff", "code": "theorem forall_generateFrom_mem_iff_mem_iff {S : Set (Set \u03b1)} {x y : \u03b1} :\n    (\u2200 s, MeasurableSet[generateFrom S] s \u2192 (x \u2208 s \u2194 y \u2208 s)) \u2194 (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s)", "start": [401, 1], "end": [409, 31], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.mkOfClosure", "code": "protected def mkOfClosure (g : Set (Set \u03b1)) (hg : { t | MeasurableSet[generateFrom g] t } = g) :\n    MeasurableSpace \u03b1 :=\n  (generateFrom g).copy (\u00b7 \u2208 g) <| Set.ext_iff.1 hg.symm", "start": [411, 1], "end": [415, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.mkOfClosure_sets", "code": "theorem mkOfClosure_sets {s : Set (Set \u03b1)} {hs : { t | MeasurableSet[generateFrom s] t } = s} :\n    MeasurableSpace.mkOfClosure s hs = generateFrom s", "start": [418, 1], "end": [420, 12], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.giGenerateFrom", "code": "def giGenerateFrom : GaloisInsertion (@generateFrom \u03b1) fun m => { t | MeasurableSet[m] t } where\n  gc _ := generateFrom_le_iff\n  le_l_u _ _ := measurableSet_generateFrom\n  choice g hg := MeasurableSpace.mkOfClosure g <| le_antisymm hg <| (generateFrom_le_iff _).1 le_rfl\n  choice_eq _ _ := mkOfClosure_sets", "start": [423, 1], "end": [429, 36], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_mono", "code": "@[mono]\ntheorem generateFrom_mono {s t : Set (Set \u03b1)} (h : s \u2286 t) : generateFrom s \u2264 generateFrom t", "start": [437, 1], "end": [439, 33], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_sup_generateFrom", "code": "theorem generateFrom_sup_generateFrom {s t : Set (Set \u03b1)} :\n    generateFrom s \u2294 generateFrom t = generateFrom (s \u222a t)", "start": [442, 1], "end": [444, 36], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_singleton_empty", "code": "theorem generateFrom_singleton_empty : generateFrom {\u2205} = (\u22a5 : MeasurableSpace \u03b1)", "start": [447, 1], "end": [448, 69], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_singleton_univ", "code": "theorem generateFrom_singleton_univ : generateFrom {Set.univ} = (\u22a5 : MeasurableSpace \u03b1)", "start": [451, 1], "end": [452, 42], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_insert_univ", "code": "@[simp]\ntheorem generateFrom_insert_univ (S : Set (Set \u03b1)) :\n    generateFrom (insert Set.univ S) = generateFrom S", "start": [455, 1], "end": [458, 91], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_insert_empty", "code": "@[simp]\ntheorem generateFrom_insert_empty (S : Set (Set \u03b1)) :\n    generateFrom (insert \u2205 S) = generateFrom S", "start": [461, 1], "end": [464, 92], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_bot_iff", "code": "theorem measurableSet_bot_iff {s : Set \u03b1} : MeasurableSet[\u22a5] s \u2194 s = \u2205 \u2228 s = univ", "start": [467, 1], "end": [477, 17], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_top", "code": "@[simp, measurability] theorem measurableSet_top {s : Set \u03b1} : MeasurableSet[\u22a4] s", "start": [480, 1], "end": [480, 93], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_inf", "code": "@[simp, nolint simpNF] theorem measurableSet_inf {m\u2081 m\u2082 : MeasurableSpace \u03b1} {s : Set \u03b1} :\n    MeasurableSet[m\u2081 \u2293 m\u2082] s \u2194 MeasurableSet[m\u2081] s \u2227 MeasurableSet[m\u2082] s", "start": [483, 1], "end": [486, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_sInf", "code": "@[simp]\ntheorem measurableSet_sInf {ms : Set (MeasurableSpace \u03b1)} {s : Set \u03b1} :\n    MeasurableSet[sInf ms] s \u2194 \u2200 m \u2208 ms, MeasurableSet[m] s", "start": [489, 1], "end": [492, 28], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_iInf", "code": "theorem measurableSet_iInf {\u03b9} {m : \u03b9 \u2192 MeasurableSpace \u03b1} {s : Set \u03b1} :\n    MeasurableSet[iInf m] s \u2194 \u2200 i, MeasurableSet[m i] s", "start": [495, 1], "end": [497, 50], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_sup", "code": "theorem measurableSet_sup {m\u2081 m\u2082 : MeasurableSpace \u03b1} {s : Set \u03b1} :\n    MeasurableSet[m\u2081 \u2294 m\u2082] s \u2194 GenerateMeasurable (MeasurableSet[m\u2081] \u222a MeasurableSet[m\u2082]) s", "start": [500, 1], "end": [502, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_sSup", "code": "theorem measurableSet_sSup {ms : Set (MeasurableSpace \u03b1)} {s : Set \u03b1} :\n    MeasurableSet[sSup ms] s \u2194\n      GenerateMeasurable { s : Set \u03b1 | \u2203 m \u2208 ms, MeasurableSet[m] s } s", "start": [505, 1], "end": [509, 24], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSet_iSup", "code": "theorem measurableSet_iSup {\u03b9} {m : \u03b9 \u2192 MeasurableSpace \u03b1} {s : Set \u03b1} :\n    MeasurableSet[iSup m] s \u2194 GenerateMeasurable { s : Set \u03b1 | \u2203 i, MeasurableSet[m i] s } s", "start": [512, 1], "end": [514, 60], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurableSpace_iSup_eq", "code": "theorem measurableSpace_iSup_eq (m : \u03b9 \u2192 MeasurableSpace \u03b1) :\n    \u2a06 n, m n = generateFrom { s | \u2203 n, MeasurableSet[m n] s }", "start": [517, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.generateFrom_iUnion_measurableSet", "code": "theorem generateFrom_iUnion_measurableSet (m : \u03b9 \u2192 MeasurableSpace \u03b1) :\n    generateFrom (\u22c3 n, { t | MeasurableSet[m n] t }) = \u2a06 n, m n", "start": [524, 1], "end": [526, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable", "code": "def Measurable [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983t : Set \u03b2\u2984, MeasurableSet t \u2192 MeasurableSet (f \u207b\u00b9' t)", "start": [533, 1], "end": [536, 59], "kind": "commanddeclaration"}, {"full_name": "measurable_id", "code": "@[measurability]\ntheorem measurable_id {_ : MeasurableSpace \u03b1} : Measurable (@id \u03b1)", "start": [549, 1], "end": [550, 82], "kind": "commanddeclaration"}, {"full_name": "measurable_id'", "code": "@[measurability]\ntheorem measurable_id' {_ : MeasurableSpace \u03b1} : Measurable fun a : \u03b1 => a", "start": [553, 1], "end": [554, 92], "kind": "commanddeclaration"}, {"full_name": "Measurable.comp", "code": "protected theorem Measurable.comp {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2}\n    {_ : MeasurableSpace \u03b3} {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Measurable g) (hf : Measurable f) :\n    Measurable (g \u2218 f)", "start": [557, 1], "end": [560, 23], "kind": "commanddeclaration"}, {"full_name": "Measurable.comp'", "code": "@[aesop safe 50 (rule_sets [Measurable])]\nprotected theorem Measurable.comp' {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2}\n    {_ : MeasurableSpace \u03b3} {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Measurable g) (hf : Measurable f) :\n    Measurable (fun x => g (f x))", "start": [564, 1], "end": [567, 59], "kind": "commanddeclaration"}, {"full_name": "measurable_const", "code": "@[simp, measurability]\ntheorem measurable_const {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2} {a : \u03b1} :\n    Measurable fun _ : \u03b2 => a", "start": [569, 1], "end": [571, 59], "kind": "commanddeclaration"}, {"full_name": "Measurable.le", "code": "theorem Measurable.le {\u03b1} {m m0 : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2} (hm : m \u2264 m0)\n    {f : \u03b1 \u2192 \u03b2} (hf : Measurable[m] f) : Measurable[m0] f", "start": [574, 1], "end": [575, 86], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.Top.measurable", "code": "theorem MeasurableSpace.Top.measurable {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    Measurable[\u22a4] f", "start": [578, 1], "end": [579, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Segment.lean", "imports": ["Mathlib/LinearAlgebra/Ray.lean", "Mathlib/Algebra/Order/SMul.lean", "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Algebra/Order/Invertible.lean"], "premises": [{"full_name": "segment", "code": "def segment (x y : E) : Set E :=\n  { z : E | \u2203 (a b : \ud835\udd5c) (_ : 0 \u2264 a) (_ : 0 \u2264 b) (_ : a + b = 1), a \u2022 x + b \u2022 y = z }", "start": [49, 1], "end": [51, 85], "kind": "commanddeclaration"}, {"full_name": "openSegment", "code": "def openSegment (x y : E) : Set E :=\n  { z : E | \u2203 (a b : \ud835\udd5c) (_ : 0 < a) (_ : 0 < b) (_ : a + b = 1), a \u2022 x + b \u2022 y = z }", "start": [54, 1], "end": [57, 85], "kind": "commanddeclaration"}, {"full_name": "segment_eq_image\u2082", "code": "theorem segment_eq_image\u2082 (x y : E) :\n    [x -[\ud835\udd5c] y] =\n      (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 \u2022 x + p.2 \u2022 y) '' { p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1 }", "start": [62, 1], "end": [65, 83], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_image\u2082", "code": "theorem openSegment_eq_image\u2082 (x y : E) :\n    openSegment \ud835\udd5c x y =\n      (fun p : \ud835\udd5c \u00d7 \ud835\udd5c => p.1 \u2022 x + p.2 \u2022 y) '' { p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1 }", "start": [68, 1], "end": [71, 87], "kind": "commanddeclaration"}, {"full_name": "segment_symm", "code": "theorem segment_symm (x y : E) : [x -[\ud835\udd5c] y] = [y -[\ud835\udd5c] x]", "start": [74, 1], "end": [78, 72], "kind": "commanddeclaration"}, {"full_name": "openSegment_symm", "code": "theorem openSegment_symm (x y : E) : openSegment \ud835\udd5c x y = openSegment \ud835\udd5c y x", "start": [81, 1], "end": [85, 72], "kind": "commanddeclaration"}, {"full_name": "openSegment_subset_segment", "code": "theorem openSegment_subset_segment (x y : E) : openSegment \ud835\udd5c x y \u2286 [x -[\ud835\udd5c] y]", "start": [88, 1], "end": [89, 65], "kind": "commanddeclaration"}, {"full_name": "segment_subset_iff", "code": "theorem segment_subset_iff :\n    [x -[\ud835\udd5c] y] \u2286 s \u2194 \u2200 a b : \ud835\udd5c, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [92, 1], "end": [95, 26], "kind": "commanddeclaration"}, {"full_name": "openSegment_subset_iff", "code": "theorem openSegment_subset_iff :\n    openSegment \ud835\udd5c x y \u2286 s \u2194 \u2200 a b : \ud835\udd5c, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [98, 1], "end": [101, 26], "kind": "commanddeclaration"}, {"full_name": "left_mem_segment", "code": "theorem left_mem_segment (x y : E) : x \u2208 [x -[\ud835\udd5c] y]", "start": [114, 1], "end": [115, 84], "kind": "commanddeclaration"}, {"full_name": "right_mem_segment", "code": "theorem right_mem_segment (x y : E) : y \u2208 [x -[\ud835\udd5c] y]", "start": [118, 1], "end": [119, 46], "kind": "commanddeclaration"}, {"full_name": "segment_same", "code": "@[simp]\ntheorem segment_same (x : E) : [x -[\ud835\udd5c] x] = {x}", "start": [129, 1], "end": [134, 63], "kind": "commanddeclaration"}, {"full_name": "insert_endpoints_openSegment", "code": "theorem insert_endpoints_openSegment (x y : E) :\n    insert x (insert y (openSegment \ud835\udd5c x y)) = [x -[\ud835\udd5c] y]", "start": [137, 1], "end": [147, 37], "kind": "commanddeclaration"}, {"full_name": "mem_openSegment_of_ne_left_right", "code": "theorem mem_openSegment_of_ne_left_right (hx : x \u2260 z) (hy : y \u2260 z) (hz : z \u2208 [x -[\ud835\udd5c] y]) :\n    z \u2208 openSegment \ud835\udd5c x y", "start": [152, 1], "end": [155, 55], "kind": "commanddeclaration"}, {"full_name": "openSegment_subset_iff_segment_subset", "code": "theorem openSegment_subset_iff_segment_subset (hx : x \u2208 s) (hy : y \u2208 s) :\n    openSegment \ud835\udd5c x y \u2286 s \u2194 [x -[\ud835\udd5c] y] \u2286 s", "start": [158, 1], "end": [160, 81], "kind": "commanddeclaration"}, {"full_name": "openSegment_same", "code": "@[simp]\ntheorem openSegment_same (x : E) : openSegment \ud835\udd5c x x = {x}", "start": [178, 1], "end": [186, 59], "kind": "commanddeclaration"}, {"full_name": "segment_eq_image", "code": "theorem segment_eq_image (x y : E) :\n    [x -[\ud835\udd5c] y] = (fun \u03b8 : \ud835\udd5c => (1 - \u03b8) \u2022 x + \u03b8 \u2022 y) '' Icc (0 : \ud835\udd5c) 1", "start": [191, 1], "end": [196, 92], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_image", "code": "theorem openSegment_eq_image (x y : E) :\n    openSegment \ud835\udd5c x y = (fun \u03b8 : \ud835\udd5c => (1 - \u03b8) \u2022 x + \u03b8 \u2022 y) '' Ioo (0 : \ud835\udd5c) 1", "start": [199, 1], "end": [204, 89], "kind": "commanddeclaration"}, {"full_name": "segment_eq_image'", "code": "theorem segment_eq_image' (x y : E) :\n    [x -[\ud835\udd5c] y] = (fun \u03b8 : \ud835\udd5c => x + \u03b8 \u2022 (y - x)) '' Icc (0 : \ud835\udd5c) 1", "start": [207, 1], "end": [211, 7], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_image'", "code": "theorem openSegment_eq_image' (x y : E) :\n    openSegment \ud835\udd5c x y = (fun \u03b8 : \ud835\udd5c => x + \u03b8 \u2022 (y - x)) '' Ioo (0 : \ud835\udd5c) 1", "start": [214, 1], "end": [218, 7], "kind": "commanddeclaration"}, {"full_name": "segment_eq_image_lineMap", "code": "theorem segment_eq_image_lineMap (x y : E) : [x -[\ud835\udd5c] y] =\n    AffineMap.lineMap x y '' Icc (0 : \ud835\udd5c) 1", "start": [221, 1], "end": [224, 45], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_image_lineMap", "code": "theorem openSegment_eq_image_lineMap (x y : E) :\n    openSegment \ud835\udd5c x y = AffineMap.lineMap x y '' Ioo (0 : \ud835\udd5c) 1", "start": [227, 1], "end": [230, 45], "kind": "commanddeclaration"}, {"full_name": "image_segment", "code": "@[simp]\ntheorem image_segment (f : E \u2192\u1d43[\ud835\udd5c] F) (a b : E) : f '' [a -[\ud835\udd5c] b] = [f a -[\ud835\udd5c] f b]", "start": [233, 1], "end": [236, 101], "kind": "commanddeclaration"}, {"full_name": "image_openSegment", "code": "@[simp]\ntheorem image_openSegment (f : E \u2192\u1d43[\ud835\udd5c] F) (a b : E) :\n    f '' openSegment \ud835\udd5c a b = openSegment \ud835\udd5c (f a) (f b)", "start": [239, 1], "end": [244, 31], "kind": "commanddeclaration"}, {"full_name": "vadd_segment", "code": "@[simp]\ntheorem vadd_segment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    a +\u1d65 [b -[\ud835\udd5c] c] = [a +\u1d65 b -[\ud835\udd5c] a +\u1d65 c]", "start": [247, 1], "end": [250, 68], "kind": "commanddeclaration"}, {"full_name": "vadd_openSegment", "code": "@[simp]\ntheorem vadd_openSegment [AddTorsor G E] [VAddCommClass G E E] (a : G) (b c : E) :\n    a +\u1d65 openSegment \ud835\udd5c b c = openSegment \ud835\udd5c (a +\u1d65 b) (a +\u1d65 c)", "start": [253, 1], "end": [256, 72], "kind": "commanddeclaration"}, {"full_name": "mem_segment_translate", "code": "@[simp]\ntheorem mem_segment_translate (a : E) {x b c} : a + x \u2208 [a + b -[\ud835\udd5c] a + c] \u2194 x \u2208 [b -[\ud835\udd5c] c]", "start": [259, 1], "end": [261, 65], "kind": "commanddeclaration"}, {"full_name": "mem_openSegment_translate", "code": "@[simp]\ntheorem mem_openSegment_translate (a : E) {x b c : E} :\n    a + x \u2208 openSegment \ud835\udd5c (a + b) (a + c) \u2194 x \u2208 openSegment \ud835\udd5c b c", "start": [264, 1], "end": [267, 69], "kind": "commanddeclaration"}, {"full_name": "segment_translate_preimage", "code": "theorem segment_translate_preimage (a b c : E) :\n    (fun x => a + x) \u207b\u00b9' [a + b -[\ud835\udd5c] a + c] = [b -[\ud835\udd5c] c]", "start": [270, 1], "end": [272, 45], "kind": "commanddeclaration"}, {"full_name": "openSegment_translate_preimage", "code": "theorem openSegment_translate_preimage (a b c : E) :\n    (fun x => a + x) \u207b\u00b9' openSegment \ud835\udd5c (a + b) (a + c) = openSegment \ud835\udd5c b c", "start": [275, 1], "end": [277, 49], "kind": "commanddeclaration"}, {"full_name": "segment_translate_image", "code": "theorem segment_translate_image (a b c : E) : (fun x => a + x) '' [b -[\ud835\udd5c] c] = [a + b -[\ud835\udd5c] a + c]", "start": [280, 1], "end": [281, 84], "kind": "commanddeclaration"}, {"full_name": "openSegment_translate_image", "code": "theorem openSegment_translate_image (a b c : E) :\n    (fun x => a + x) '' openSegment \ud835\udd5c b c = openSegment \ud835\udd5c (a + b) (a + c)", "start": [284, 1], "end": [286, 88], "kind": "commanddeclaration"}, {"full_name": "segment_inter_eq_endpoint_of_linearIndependent_sub", "code": "lemma segment_inter_eq_endpoint_of_linearIndependent_sub\n    {c x y : E} (h : LinearIndependent \ud835\udd5c ![x - c, y - c]) :\n    [c -[\ud835\udd5c] x] \u2229 [c -[\ud835\udd5c] y] = {c} := by\n  apply Subset.antisymm; swap\n  \u00b7 simp [singleton_subset_iff, left_mem_segment]\n  intro z \u27e8hzt, hzs\u27e9\n  rw [segment_eq_image, mem_image] at hzt hzs\n  rcases hzt with \u27e8p, \u27e8p0, p1\u27e9, rfl\u27e9\n  rcases hzs with \u27e8q, \u27e8q0, q1\u27e9, H\u27e9\n  have Hx : x = (x - c) + c := by abel\n  have Hy : y = (y - c) + c := by abel\n  rw [Hx, Hy, smul_add, smul_add] at H\n  have : c + q \u2022 (y - c) = c + p \u2022 (x - c) := by\n    convert H using 1 <;> simp [sub_smul]\n  obtain \u27e8rfl, rfl\u27e9 : p = 0 \u2227 q = 0 := h.eq_zero_of_pair' ((add_right_inj c).1 this).symm\n  simp", "start": [289, 1], "end": [304, 7], "kind": "mathlibtacticlemma"}, {"full_name": "sameRay_of_mem_segment", "code": "theorem sameRay_of_mem_segment [StrictOrderedCommRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}\n    (h : x \u2208 [y -[\ud835\udd5c] z]) : SameRay \ud835\udd5c (x - y) (z - x)", "start": [308, 1], "end": [313, 88], "kind": "commanddeclaration"}, {"full_name": "segment_inter_eq_endpoint_of_linearIndependent_of_ne", "code": "lemma segment_inter_eq_endpoint_of_linearIndependent_of_ne [OrderedCommRing \ud835\udd5c] [NoZeroDivisors \ud835\udd5c]\n    [AddCommGroup E] [Module \ud835\udd5c E]\n    {x y : E} (h : LinearIndependent \ud835\udd5c ![x, y]) {s t : \ud835\udd5c} (hs : s \u2260 t) (c : E) :\n    [c + x -[\ud835\udd5c] c + t \u2022 y] \u2229 [c + x -[\ud835\udd5c] c + s \u2022 y] = {c + x} := by\n  apply segment_inter_eq_endpoint_of_linearIndependent_sub\n  simp only [add_sub_add_left_eq_sub]\n  suffices H : LinearIndependent \ud835\udd5c ![(-1 : \ud835\udd5c) \u2022 x + t \u2022 y, (-1 : \ud835\udd5c) \u2022 x + s \u2022 y] by\n    convert H using 1; simp only [neg_smul, one_smul]; abel_nf\n  apply h.linear_combination_pair_of_det_ne_zero\n  contrapose! hs\n  apply Eq.symm\n  simpa [neg_mul, one_mul, mul_neg, mul_one, sub_neg_eq_add, add_comm _ t,\n    \u2190 sub_eq_add_neg, sub_eq_zero] using hs", "start": [316, 1], "end": [328, 44], "kind": "mathlibtacticlemma"}, {"full_name": "midpoint_mem_segment", "code": "theorem midpoint_mem_segment [Invertible (2 : \ud835\udd5c)] (x y : E) : midpoint \ud835\udd5c x y \u2208 [x -[\ud835\udd5c] y]", "start": [334, 1], "end": [336, 76], "kind": "commanddeclaration"}, {"full_name": "mem_segment_sub_add", "code": "theorem mem_segment_sub_add [Invertible (2 : \ud835\udd5c)] (x y : E) : x \u2208 [x - y -[\ud835\udd5c] x + y]", "start": [339, 1], "end": [341, 24], "kind": "commanddeclaration"}, {"full_name": "mem_segment_add_sub", "code": "theorem mem_segment_add_sub [Invertible (2 : \ud835\udd5c)] (x y : E) : x \u2208 [x + y -[\ud835\udd5c] x - y]", "start": [344, 1], "end": [346, 24], "kind": "commanddeclaration"}, {"full_name": "left_mem_openSegment_iff", "code": "@[simp]\ntheorem left_mem_openSegment_iff [DenselyOrdered \ud835\udd5c] [NoZeroSMulDivisors \ud835\udd5c E] :\n    x \u2208 openSegment \ud835\udd5c x y \u2194 x = y", "start": [349, 1], "end": [358, 26], "kind": "commanddeclaration"}, {"full_name": "right_mem_openSegment_iff", "code": "@[simp]\ntheorem right_mem_openSegment_iff [DenselyOrdered \ud835\udd5c] [NoZeroSMulDivisors \ud835\udd5c E] :\n    y \u2208 openSegment \ud835\udd5c x y \u2194 x = y", "start": [361, 1], "end": [363, 97], "kind": "commanddeclaration"}, {"full_name": "mem_segment_iff_div", "code": "theorem mem_segment_iff_div :\n    x \u2208 [y -[\ud835\udd5c] z] \u2194\n      \u2203 a b : \ud835\udd5c, 0 \u2264 a \u2227 0 \u2264 b \u2227 0 < a + b \u2227 (a / (a + b)) \u2022 y + (b / (a + b)) \u2022 z = x", "start": [372, 1], "end": [381, 37], "kind": "commanddeclaration"}, {"full_name": "mem_openSegment_iff_div", "code": "theorem mem_openSegment_iff_div : x \u2208 openSegment \ud835\udd5c y z \u2194\n    \u2203 a b : \ud835\udd5c, 0 < a \u2227 0 < b \u2227 (a / (a + b)) \u2022 y + (b / (a + b)) \u2022 z = x", "start": [384, 1], "end": [393, 37], "kind": "commanddeclaration"}, {"full_name": "mem_segment_iff_sameRay", "code": "theorem mem_segment_iff_sameRay : x \u2208 [y -[\ud835\udd5c] z] \u2194 SameRay \ud835\udd5c (x - y) (z - x)", "start": [402, 1], "end": [408, 98], "kind": "commanddeclaration"}, {"full_name": "openSegment_subset_union", "code": "theorem openSegment_subset_union (x y : E) {z : E} (hz : z \u2208 range (lineMap x y : \ud835\udd5c \u2192 E)) :\n    openSegment \ud835\udd5c x y \u2286 insert z (openSegment \ud835\udd5c x z \u222a openSegment \ud835\udd5c z y)", "start": [413, 1], "end": [437, 57], "kind": "commanddeclaration"}, {"full_name": "segment_subset_Icc", "code": "theorem segment_subset_Icc (h : x \u2264 y) : [x -[\ud835\udd5c] y] \u2286 Icc x y", "start": [457, 1], "end": [465, 37], "kind": "commanddeclaration"}, {"full_name": "openSegment_subset_Ioo", "code": "theorem openSegment_subset_Ioo (h : x < y) : openSegment \ud835\udd5c x y \u2286 Ioo x y", "start": [474, 1], "end": [482, 37], "kind": "commanddeclaration"}, {"full_name": "segment_subset_uIcc", "code": "theorem segment_subset_uIcc (x y : E) : [x -[\ud835\udd5c] y] \u2286 uIcc x y", "start": [491, 1], "end": [496, 31], "kind": "commanddeclaration"}, {"full_name": "Convex.min_le_combo", "code": "theorem Convex.min_le_combo (x y : E) (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    min x y \u2264 a \u2022 x + b \u2022 y", "start": [499, 1], "end": [501, 55], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_le_max", "code": "theorem Convex.combo_le_max (x y : E) (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a \u2022 x + b \u2022 y \u2264 max x y", "start": [504, 1], "end": [506, 55], "kind": "commanddeclaration"}, {"full_name": "Icc_subset_segment", "code": "theorem Icc_subset_segment : Icc x y \u2286 [x -[\ud835\udd5c] y]", "start": [517, 1], "end": [527, 93], "kind": "commanddeclaration"}, {"full_name": "segment_eq_Icc", "code": "@[simp]\ntheorem segment_eq_Icc (h : x \u2264 y) : [x -[\ud835\udd5c] y] = Icc x y", "start": [530, 1], "end": [532, 53], "kind": "commanddeclaration"}, {"full_name": "Ioo_subset_openSegment", "code": "theorem Ioo_subset_openSegment : Ioo x y \u2286 openSegment \ud835\udd5c x y", "start": [535, 1], "end": [536, 100], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_Ioo", "code": "@[simp]\ntheorem openSegment_eq_Ioo (h : x < y) : openSegment \ud835\udd5c x y = Ioo x y", "start": [539, 1], "end": [541, 61], "kind": "commanddeclaration"}, {"full_name": "segment_eq_Icc'", "code": "theorem segment_eq_Icc' (x y : \ud835\udd5c) : [x -[\ud835\udd5c] y] = Icc (min x y) (max x y)", "start": [544, 1], "end": [547, 71], "kind": "commanddeclaration"}, {"full_name": "openSegment_eq_Ioo'", "code": "theorem openSegment_eq_Ioo' (hxy : x \u2260 y) : openSegment \ud835\udd5c x y = Ioo (min x y) (max x y)", "start": [550, 1], "end": [553, 85], "kind": "commanddeclaration"}, {"full_name": "segment_eq_uIcc", "code": "theorem segment_eq_uIcc (x y : \ud835\udd5c) : [x -[\ud835\udd5c] y] = uIcc x y", "start": [556, 1], "end": [557, 22], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_Icc", "code": "theorem Convex.mem_Icc (h : x \u2264 y) :\n    z \u2208 Icc x y \u2194 \u2203 a b, 0 \u2264 a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 a * x + b * y = z", "start": [560, 1], "end": [565, 6], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_Ioo", "code": "theorem Convex.mem_Ioo (h : x < y) :\n    z \u2208 Ioo x y \u2194 \u2203 a b, 0 < a \u2227 0 < b \u2227 a + b = 1 \u2227 a * x + b * y = z", "start": [568, 1], "end": [574, 6], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_Ioc", "code": "theorem Convex.mem_Ioc (h : x < y) :\n    z \u2208 Ioc x y \u2194 \u2203 a b, 0 \u2264 a \u2227 0 < b \u2227 a + b = 1 \u2227 a * x + b * y = z", "start": [577, 1], "end": [592, 81], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_Ico", "code": "theorem Convex.mem_Ico (h : x < y) :\n    z \u2208 Ico x y \u2194 \u2203 a b, 0 < a \u2227 0 \u2264 b \u2227 a + b = 1 \u2227 a * x + b * y = z", "start": [595, 1], "end": [610, 81], "kind": "commanddeclaration"}, {"full_name": "Prod.segment_subset", "code": "theorem segment_subset (x y : E \u00d7 F) : segment \ud835\udd5c x y \u2286 segment \ud835\udd5c x.1 y.1 \u00d7\u02e2 segment \ud835\udd5c x.2 y.2", "start": [619, 1], "end": [621, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.openSegment_subset", "code": "theorem openSegment_subset (x y : E \u00d7 F) :\n    openSegment \ud835\udd5c x y \u2286 openSegment \ud835\udd5c x.1 y.1 \u00d7\u02e2 openSegment \ud835\udd5c x.2 y.2", "start": [624, 1], "end": [627, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.image_mk_segment_left", "code": "theorem image_mk_segment_left (x\u2081 x\u2082 : E) (y : F) :\n    (fun x => (x, y)) '' [x\u2081 -[\ud835\udd5c] x\u2082] = [(x\u2081, y) -[\ud835\udd5c] (x\u2082, y)]", "start": [630, 1], "end": [636, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.image_mk_segment_right", "code": "theorem image_mk_segment_right (x : E) (y\u2081 y\u2082 : F) :\n    (fun y => (x, y)) '' [y\u2081 -[\ud835\udd5c] y\u2082] = [(x, y\u2081) -[\ud835\udd5c] (x, y\u2082)]", "start": [639, 1], "end": [645, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.image_mk_openSegment_left", "code": "theorem image_mk_openSegment_left (x\u2081 x\u2082 : E) (y : F) :\n    (fun x => (x, y)) '' openSegment \ud835\udd5c x\u2081 x\u2082 = openSegment \ud835\udd5c (x\u2081, y) (x\u2082, y)", "start": [648, 1], "end": [654, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.image_mk_openSegment_right", "code": "@[simp]\ntheorem image_mk_openSegment_right (x : E) (y\u2081 y\u2082 : F) :\n    (fun y => (x, y)) '' openSegment \ud835\udd5c y\u2081 y\u2082 = openSegment \ud835\udd5c (x, y\u2081) (x, y\u2082)", "start": [657, 1], "end": [664, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.segment_subset", "code": "theorem segment_subset (x y : \u2200 i, \u03c0 i) : segment \ud835\udd5c x y \u2286 s.pi fun i => segment \ud835\udd5c (x i) (y i)", "start": [673, 1], "end": [675, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.openSegment_subset", "code": "theorem openSegment_subset (x y : \u2200 i, \u03c0 i) :\n    openSegment \ud835\udd5c x y \u2286 s.pi fun i => openSegment \ud835\udd5c (x i) (y i)", "start": [678, 1], "end": [681, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.image_update_segment", "code": "theorem image_update_segment (i : \u03b9) (x\u2081 x\u2082 : \u03c0 i) (y : \u2200 i, \u03c0 i) :\n    update y i '' [x\u2081 -[\ud835\udd5c] x\u2082] = [update y i x\u2081 -[\ud835\udd5c] update y i x\u2082]", "start": [686, 1], "end": [692, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.image_update_openSegment", "code": "theorem image_update_openSegment (i : \u03b9) (x\u2081 x\u2082 : \u03c0 i) (y : \u2200 i, \u03c0 i) :\n    update y i '' openSegment \ud835\udd5c x\u2081 x\u2082 = openSegment \ud835\udd5c (update y i x\u2081) (update y i x\u2082)", "start": [695, 1], "end": [701, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Rank.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Basic.lean", "Mathlib/LinearAlgebra/Finrank.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FiniteDimensional.Submodule.finrank_map_subtype_eq", "code": "@[simp]\ntheorem Submodule.finrank_map_subtype_eq (p : Submodule R M) (q : Submodule R p) :\n    finrank R (q.map p.subtype) = finrank R q", "start": [42, 1], "end": [45, 50], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_ulift", "code": "@[simp]\ntheorem finrank_ulift : finrank R (ULift M) = finrank R M", "start": [48, 1], "end": [50, 44], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.rank_lt_aleph0", "code": "theorem rank_lt_aleph0 : Module.rank R M < \u2135\u2080", "start": [62, 1], "end": [69, 55], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_rank", "code": "@[simp]\ntheorem finrank_eq_rank : \u2191(finrank R M) = Module.rank R M", "start": [72, 1], "end": [75, 61], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_card_chooseBasisIndex", "code": "theorem finrank_eq_card_chooseBasisIndex :\n    finrank R M = card (ChooseBasisIndex R M)", "start": [88, 1], "end": [91, 48], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_finsupp", "code": "@[simp]\ntheorem finrank_finsupp {\u03b9 : Type v} [Fintype \u03b9] : finrank R (\u03b9 \u2192\u2080 R) = card \u03b9", "start": [94, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_pi", "code": "theorem finrank_pi {\u03b9 : Type v} [Fintype \u03b9] : finrank R (\u03b9 \u2192 R) = card \u03b9", "start": [100, 1], "end": [102, 17], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_directSum", "code": "@[simp]\ntheorem finrank_directSum {\u03b9 : Type v} [Fintype \u03b9] (M : \u03b9 \u2192 Type w) [\u2200 i : \u03b9, AddCommGroup (M i)]\n    [\u2200 i : \u03b9, Module R (M i)] [\u2200 i : \u03b9, Module.Free R (M i)] [\u2200 i : \u03b9, Module.Finite R (M i)] :\n    finrank R (\u2a01 i, M i) = \u2211 i, finrank R (M i)", "start": [105, 1], "end": [112, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_prod", "code": "@[simp]\ntheorem finrank_prod : finrank R (M \u00d7 N) = finrank R M + finrank R N", "start": [115, 1], "end": [118, 57], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_pi_fintype", "code": "theorem finrank_pi_fintype {\u03b9 : Type v} [Fintype \u03b9] {M : \u03b9 \u2192 Type w} [\u2200 i : \u03b9, AddCommGroup (M i)]\n    [\u2200 i : \u03b9, Module R (M i)] [\u2200 i : \u03b9, Module.Free R (M i)] [\u2200 i : \u03b9, Module.Finite R (M i)] :\n    finrank R (\u2200 i, M i) = \u2211 i, finrank R (M i)", "start": [122, 1], "end": [128, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_matrix", "code": "theorem finrank_matrix (m n : Type*) [Fintype m] [Fintype n] :\n    finrank R (Matrix m n R) = card m * card n", "start": [131, 1], "end": [134, 68], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nonempty_linearEquiv_of_finrank_eq", "code": "theorem nonempty_linearEquiv_of_finrank_eq (cond : finrank R M = finrank R N) :\n    Nonempty (M \u2243\u2097[R] N)", "start": [139, 1], "end": [142, 95], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.nonempty_linearEquiv_iff_finrank_eq", "code": "theorem nonempty_linearEquiv_iff_finrank_eq : Nonempty (M \u2243\u2097[R] N) \u2194 finrank R M = finrank R N", "start": [145, 1], "end": [147, 75], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofFinrankEq", "code": "noncomputable def _root_.LinearEquiv.ofFinrankEq (cond : finrank R M = finrank R N) : M \u2243\u2097[R] N :=\n  Classical.choice <| nonempty_linearEquiv_of_finrank_eq cond", "start": [152, 1], "end": [154, 62], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_tensorProduct", "code": "@[simp]\ntheorem finrank_tensorProduct (M : Type v) (N : Type w) [AddCommGroup M] [Module R M]\n    [Module.Free R M] [AddCommGroup N] [Module R N] [Module.Free R N] :\n    finrank R (M \u2297[R] N) = finrank R M * finrank R N", "start": [167, 1], "end": [171, 74], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finrank_le_finrank_of_injective", "code": "theorem LinearMap.finrank_le_finrank_of_injective [Module.Finite R N] {f : M \u2192\u2097[R] N}\n    (hf : Function.Injective f) : finrank R M \u2264 finrank R N", "start": [190, 1], "end": [192, 101], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finrank_range_le", "code": "theorem LinearMap.finrank_range_le [Module.Finite R M] (f : M \u2192\u2097[R] N) :\n    finrank R (LinearMap.range f) \u2264 finrank R M", "start": [195, 1], "end": [197, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_le", "code": "theorem Submodule.finrank_le [Module.Finite R M] (s : Submodule R M) :\n    finrank R s \u2264 finrank R M", "start": [200, 1], "end": [204, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_quotient_le", "code": "theorem Submodule.finrank_quotient_le [Module.Finite R M] (s : Submodule R M) :\n    finrank R (M \u29f8 s) \u2264 finrank R M", "start": [207, 1], "end": [212, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_map_le", "code": "theorem Submodule.finrank_map_le (f : M \u2192\u2097[R] N) (p : Submodule R M) [Module.Finite R p] :\n    finrank R (p.map f) \u2264 finrank R p", "start": [215, 1], "end": [218, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_le_finrank_of_le", "code": "theorem Submodule.finrank_le_finrank_of_le {s t : Submodule R M} [Module.Finite R t] (hst : s \u2264 t) :\n    finrank R s \u2264 finrank R t", "start": [221, 1], "end": [226, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Finiteness.lean", "imports": ["Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/RingTheory/Finiteness.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsNoetherian.iff_rank_lt_aleph0", "code": "theorem iff_rank_lt_aleph0 : IsNoetherian K V \u2194 Module.rank K V < \u2135\u2080", "start": [27, 1], "end": [41, 90], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.rank_lt_aleph0", "code": "theorem rank_lt_aleph0 : \u2200 [IsNoetherian K V], Module.rank K V < \u2135\u2080", "start": [46, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.fintypeBasisIndex", "code": "noncomputable def fintypeBasisIndex {\u03b9 : Type*} [IsNoetherian K V] (b : Basis \u03b9 K V) : Fintype \u03b9 :=\n  b.fintypeIndexOfRankLtAleph0 (rank_lt_aleph0 K V)", "start": [54, 1], "end": [56, 52], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.finite_basis_index", "code": "theorem finite_basis_index {\u03b9 : Type*} {s : Set \u03b9} [IsNoetherian K V] (b : Basis s K V) :\n    s.Finite", "start": [64, 1], "end": [68, 56], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.finsetBasisIndex", "code": "noncomputable def finsetBasisIndex [IsNoetherian K V] : Finset V :=\n  (finite_basis_index (Basis.ofVectorSpace K V)).toFinset", "start": [73, 1], "end": [76, 58], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.coe_finsetBasisIndex", "code": "@[simp]\ntheorem coe_finsetBasisIndex [IsNoetherian K V] :\n    (\u2191(finsetBasisIndex K V) : Set V) = Basis.ofVectorSpaceIndex K V", "start": [79, 1], "end": [82, 28], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.coeSort_finsetBasisIndex", "code": "@[simp]\ntheorem coeSort_finsetBasisIndex [IsNoetherian K V] :\n    (finsetBasisIndex K V : Type _) = Basis.ofVectorSpaceIndex K V", "start": [85, 1], "end": [88, 32], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.finsetBasis", "code": "noncomputable def finsetBasis [IsNoetherian K V] : Basis (finsetBasisIndex K V) K V :=\n  (Basis.ofVectorSpace K V).reindex (by rw [coeSort_finsetBasisIndex])", "start": [91, 1], "end": [97, 71], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.range_finsetBasis", "code": "@[simp]\ntheorem range_finsetBasis [IsNoetherian K V] :\n    Set.range (finsetBasis K V) = Basis.ofVectorSpaceIndex K V", "start": [100, 1], "end": [103, 67], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.iff_fg", "code": "theorem iff_fg : IsNoetherian K V \u2194 Module.Finite K V", "start": [108, 1], "end": [118, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Multiplicity.lean", "imports": ["Mathlib/Algebra/BigOperators/Intervals.lean", "Mathlib/Data/Nat/Log.lean", "Mathlib/Data/Nat/Bitwise.lean", "Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Multiplicity.lean", "Mathlib/Data/Nat/Digits.lean", "Mathlib/Algebra/GeomSum.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "Nat.multiplicity_eq_card_pow_dvd", "code": "theorem multiplicity_eq_card_pow_dvd {m n b : \u2115} (hm : m \u2260 1) (hn : 0 < n) (hb : log m n < b) :\n    multiplicity m n = \u2191((Finset.Ico 1 b).filter fun i => m ^ i \u2223 n).card", "start": [58, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_one", "code": "theorem multiplicity_one {p : \u2115} (hp : p.Prime) : multiplicity p 1 = 0", "start": [82, 1], "end": [83, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_mul", "code": "theorem multiplicity_mul {p m n : \u2115} (hp : p.Prime) :\n    multiplicity p (m * n) = multiplicity p m + multiplicity p n", "start": [86, 1], "end": [88, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_pow", "code": "theorem multiplicity_pow {p m n : \u2115} (hp : p.Prime) :\n    multiplicity p (m ^ n) = n \u2022 multiplicity p m", "start": [91, 1], "end": [93, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_self", "code": "theorem multiplicity_self {p : \u2115} (hp : p.Prime) : multiplicity p p = 1", "start": [96, 1], "end": [97, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_pow_self", "code": "theorem multiplicity_pow_self {p n : \u2115} (hp : p.Prime) : multiplicity p (p ^ n) = n", "start": [100, 1], "end": [101, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_factorial", "code": "theorem multiplicity_factorial {p : \u2115} (hp : p.Prime) :\n    \u2200 {n b : \u2115}, log p n < b \u2192 multiplicity p n ! = (\u2211 i in Ico 1 b, n / p ^ i : \u2115)", "start": [104, 1], "end": [123, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.sub_one_mul_multiplicity_factorial", "code": "theorem sub_one_mul_multiplicity_factorial {n p : \u2115} (hp : p.Prime) :\n     (p - 1) * (multiplicity p n !).get (finite_nat_iff.mpr \u27e8hp.ne_one, factorial_pos n\u27e9) =\n     n - (p.digits n).sum", "start": [126, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_factorial_mul_succ", "code": "theorem multiplicity_factorial_mul_succ {n p : \u2115} (hp : p.Prime) :\n    multiplicity p (p * (n + 1))! = multiplicity p (p * n)! + multiplicity p (n + 1) + 1", "start": [136, 1], "end": [160, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_factorial_mul", "code": "theorem multiplicity_factorial_mul {n p : \u2115} (hp : p.Prime) :\n    multiplicity p (p * n)! = multiplicity p n ! + n", "start": [163, 1], "end": [171, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_dvd_factorial_iff", "code": "theorem pow_dvd_factorial_iff {p : \u2115} {n r b : \u2115} (hp : p.Prime) (hbn : log p n < b) :\n    p ^ r \u2223 n ! \u2194 r \u2264 \u2211 i in Ico 1 b, n / p ^ i", "start": [174, 1], "end": [178, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_factorial_le_div_pred", "code": "theorem multiplicity_factorial_le_div_pred {p : \u2115} (hp : p.Prime) (n : \u2115) :\n    multiplicity p n ! \u2264 (n / (p - 1) : \u2115)", "start": [181, 1], "end": [184, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_choose_aux", "code": "theorem multiplicity_choose_aux {p n b k : \u2115} (hp : p.Prime) (hkn : k \u2264 n) :\n    \u2211 i in Finset.Ico 1 b, n / p ^ i =\n      ((\u2211 i in Finset.Ico 1 b, k / p ^ i) + \u2211 i in Finset.Ico 1 b, (n - k) / p ^ i) +\n        ((Finset.Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + (n - k) % p ^ i).card", "start": [187, 1], "end": [197, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_choose'", "code": "theorem multiplicity_choose' {p n k b : \u2115} (hp : p.Prime) (hnb : log p (n + k) < b) :\n    multiplicity p (choose (n + k) k) =\n      ((Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + n % p ^ i).card", "start": [200, 1], "end": [219, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_choose", "code": "theorem multiplicity_choose {p n k b : \u2115} (hp : p.Prime) (hkn : k \u2264 n) (hnb : log p n < b) :\n    multiplicity p (choose n k) =\n      ((Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + (n - k) % p ^ i).card", "start": [221, 1], "end": [230, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_le_multiplicity_choose_add", "code": "theorem multiplicity_le_multiplicity_choose_add {p : \u2115} (hp : p.Prime) :\n    \u2200 n k : \u2115, multiplicity p n \u2264 multiplicity p (choose n k) + multiplicity p k", "start": [233, 1], "end": [242, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_choose_prime_pow_add_multiplicity", "code": "theorem multiplicity_choose_prime_pow_add_multiplicity (hp : p.Prime) (hkn : k \u2264 p ^ n)\n    (hk0 : k \u2260 0) : multiplicity p (choose (p ^ n) k) + multiplicity p k = n", "start": [247, 1], "end": [264, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.multiplicity_choose_prime_pow", "code": "theorem multiplicity_choose_prime_pow {p n k : \u2115} (hp : p.Prime) (hkn : k \u2264 p ^ n) (hk0 : k \u2260 0) :\n    multiplicity p (choose (p ^ n) k) =\n      \u2191(n - (multiplicity p k).get (finite_nat_iff.2 \u27e8hp.ne_one, hk0.bot_lt\u27e9))", "start": [267, 1], "end": [271, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_choose_pow", "code": "theorem dvd_choose_pow (hp : Prime p) (hk : k \u2260 0) (hkp : k \u2260 p ^ n) : p \u2223 (p ^ n).choose k", "start": [274, 1], "end": [280, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_choose_pow_iff", "code": "theorem dvd_choose_pow_iff (hp : Prime p) : p \u2223 (p ^ n).choose k \u2194 k \u2260 0 \u2227 k \u2260 p ^ n", "start": [283, 1], "end": [285, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.multiplicity_two_factorial_lt", "code": "theorem multiplicity_two_factorial_lt : \u2200 {n : \u2115} (_ : n \u2260 0), multiplicity 2 n ! < n", "start": [290, 1], "end": [314, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Denumerable.lean", "imports": ["Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/Data/Rat/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.denumerable_aux", "code": "private def denumerable_aux : \u211a \u2243 { x : \u2124 \u00d7 \u2115 // 0 < x.2 \u2227 x.1.natAbs.Coprime x.2 }\n    where\n  toFun x := \u27e8\u27e8x.1, x.2\u27e9, Nat.pos_of_ne_zero x.3, x.4\u27e9\n  invFun x := \u27e8x.1.1, x.1.2, ne_zero_of_lt x.2.1, x.2.2\u27e9\n  left_inv := fun \u27e8_, _, _, _\u27e9 => rfl\n  right_inv := fun \u27e8\u27e8_, _\u27e9, _, _\u27e9 => rfl", "start": [25, 1], "end": [30, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mkRat", "code": "theorem Cardinal.mkRat : #\u211a = \u2135\u2080", "start": [44, 1], "end": [44, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecificLimits/Basic.lean", "imports": ["Mathlib/Order/Iterate.lean", "Mathlib/Order/Filter/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Algebra/GeomSum.lean"], "premises": [{"full_name": "tendsto_inverse_atTop_nhds_0_nat", "code": "theorem tendsto_inverse_atTop_nhds_0_nat : Tendsto (fun n : \u2115 => (n : \u211d)\u207b\u00b9) atTop (\ud835\udcdd 0)", "start": [31, 1], "end": [32, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_div_atTop_nhds_0_nat", "code": "theorem tendsto_const_div_atTop_nhds_0_nat (C : \u211d) : Tendsto (fun n : \u2115 => C / n) atTop (\ud835\udcdd 0)", "start": [35, 1], "end": [36, 86], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_inverse_atTop_nhds_0_nat", "code": "theorem NNReal.tendsto_inverse_atTop_nhds_0_nat :\n    Tendsto (fun n : \u2115 => (n : \u211d\u22650)\u207b\u00b9) atTop (\ud835\udcdd 0)", "start": [39, 1], "end": [42, 48], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_const_div_atTop_nhds_0_nat", "code": "theorem NNReal.tendsto_const_div_atTop_nhds_0_nat (C : \u211d\u22650) :\n    Tendsto (fun n : \u2115 => C / n) atTop (\ud835\udcdd 0)", "start": [45, 1], "end": [47, 77], "kind": "commanddeclaration"}, {"full_name": "tendsto_one_div_add_atTop_nhds_0_nat", "code": "theorem tendsto_one_div_add_atTop_nhds_0_nat :\n    Tendsto (fun n : \u2115 => 1 / ((n : \u211d) + 1)) atTop (\ud835\udcdd 0)", "start": [50, 1], "end": [53, 80], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_algebraMap_inverse_atTop_nhds_0_nat", "code": "theorem NNReal.tendsto_algebraMap_inverse_atTop_nhds_0_nat (\ud835\udd5c : Type*) [Semiring \ud835\udd5c] [Algebra \u211d\u22650 \ud835\udd5c]\n    [TopologicalSpace \ud835\udd5c] [TopologicalSemiring \ud835\udd5c] [ContinuousSMul \u211d\u22650 \ud835\udd5c] :\n    Tendsto (algebraMap \u211d\u22650 \ud835\udd5c \u2218 fun n : \u2115 => (n : \u211d\u22650)\u207b\u00b9) atTop (nhds 0)", "start": [56, 1], "end": [60, 16], "kind": "commanddeclaration"}, {"full_name": "tendsto_algebraMap_inverse_atTop_nhds_0_nat", "code": "theorem tendsto_algebraMap_inverse_atTop_nhds_0_nat (\ud835\udd5c : Type*) [Semiring \ud835\udd5c] [Algebra \u211d \ud835\udd5c]\n    [TopologicalSpace \ud835\udd5c] [TopologicalSemiring \ud835\udd5c] [ContinuousSMul \u211d \ud835\udd5c] :\n    Tendsto (algebraMap \u211d \ud835\udd5c \u2218 fun n : \u2115 => (n : \u211d)\u207b\u00b9) atTop (nhds 0)", "start": [62, 1], "end": [65, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_coe_nat_div_add_atTop", "code": "theorem tendsto_coe_nat_div_add_atTop {\ud835\udd5c : Type*} [DivisionRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c]\n    [CharZero \ud835\udd5c] [Algebra \u211d \ud835\udd5c] [ContinuousSMul \u211d \ud835\udd5c] [TopologicalDivisionRing \ud835\udd5c] (x : \ud835\udd5c) :\n    Tendsto (fun n : \u2115 => (n : \ud835\udd5c) / (n + x)) atTop (\ud835\udcdd 1)", "start": [67, 1], "end": [88, 54], "kind": "commanddeclaration"}, {"full_name": "tendsto_add_one_pow_atTop_atTop_of_pos", "code": "theorem tendsto_add_one_pow_atTop_atTop_of_pos [LinearOrderedSemiring \u03b1] [Archimedean \u03b1] {r : \u03b1}\n    (h : 0 < r) : Tendsto (fun n : \u2115 => (r + 1) ^ n) atTop atTop", "start": [94, 1], "end": [97, 91], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_atTop_of_one_lt", "code": "theorem tendsto_pow_atTop_atTop_of_one_lt [LinearOrderedRing \u03b1] [Archimedean \u03b1] {r : \u03b1}\n    (h : 1 < r) : Tendsto (fun n : \u2115 => r ^ n) atTop atTop", "start": [100, 1], "end": [102, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.tendsto_pow_atTop_atTop_of_one_lt", "code": "theorem Nat.tendsto_pow_atTop_atTop_of_one_lt {m : \u2115} (h : 1 < m) :\n    Tendsto (fun n : \u2115 => m ^ n) atTop atTop", "start": [105, 1], "end": [107, 97], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_nhds_0_of_lt_1", "code": "theorem tendsto_pow_atTop_nhds_0_of_lt_1 {\ud835\udd5c : Type*} [LinearOrderedField \ud835\udd5c] [Archimedean \ud835\udd5c]\n    [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c] {r : \ud835\udd5c} (h\u2081 : 0 \u2264 r) (h\u2082 : r < 1) :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd 0)", "start": [110, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_nhds_0_iff", "code": "@[simp] theorem tendsto_pow_atTop_nhds_0_iff {\ud835\udd5c : Type*} [LinearOrderedField \ud835\udd5c] [Archimedean \ud835\udd5c]\n    [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c] {r : \ud835\udd5c} :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd 0) \u2194 |r| < 1", "start": [121, 1], "end": [135, 85], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_nhdsWithin_0_of_lt_1", "code": "theorem tendsto_pow_atTop_nhdsWithin_0_of_lt_1 {\ud835\udd5c : Type*} [LinearOrderedField \ud835\udd5c] [Archimedean \ud835\udd5c]\n    [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c] {r : \ud835\udd5c} (h\u2081 : 0 < r) (h\u2082 : r < 1) :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd[>] 0)", "start": [137, 1], "end": [142, 73], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_dist_pow_of_lt_1", "code": "theorem uniformity_basis_dist_pow_of_lt_1 {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {r : \u211d} (h\u2080 : 0 < r)\n    (h\u2081 : r < 1) :\n    (uniformity \u03b1).HasBasis (fun _ : \u2115 => True) fun k => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < r ^ k }", "start": [145, 1], "end": [149, 69], "kind": "commanddeclaration"}, {"full_name": "geom_lt", "code": "theorem geom_lt {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) {n : \u2115} (hn : 0 < n)\n    (h : \u2200 k < n, c * u k < u (k + 1)) : c ^ n * u 0 < u n", "start": [152, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "geom_le", "code": "theorem geom_le {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) (n : \u2115) (h : \u2200 k < n, c * u k \u2264 u (k + 1)) :\n    c ^ n * u 0 \u2264 u n", "start": [159, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "lt_geom", "code": "theorem lt_geom {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) {n : \u2115} (hn : 0 < n)\n    (h : \u2200 k < n, u (k + 1) < c * u k) : u n < c ^ n * u 0", "start": [165, 1], "end": [169, 47], "kind": "commanddeclaration"}, {"full_name": "le_geom", "code": "theorem le_geom {u : \u2115 \u2192 \u211d} {c : \u211d} (hc : 0 \u2264 c) (n : \u2115) (h : \u2200 k < n, u (k + 1) \u2264 c * u k) :\n    u n \u2264 c ^ n * u 0", "start": [172, 1], "end": [175, 47], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_of_geom_le", "code": "theorem tendsto_atTop_of_geom_le {v : \u2115 \u2192 \u211d} {c : \u211d} (h\u2080 : 0 < v 0) (hc : 1 < c)\n    (hu : \u2200 n, c * v n \u2264 v (n + 1)) : Tendsto v atTop atTop", "start": [178, 1], "end": [183, 62], "kind": "commanddeclaration"}, {"full_name": "NNReal.tendsto_pow_atTop_nhds_0_of_lt_1", "code": "theorem NNReal.tendsto_pow_atTop_nhds_0_of_lt_1 {r : \u211d\u22650} (hr : r < 1) :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd 0)", "start": [186, 1], "end": [190, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1", "code": "theorem ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1 {r : \u211d\u22650\u221e} (hr : r < 1) :\n    Tendsto (fun n : \u2115 => r ^ n) atTop (\ud835\udcdd 0)", "start": [193, 1], "end": [198, 51], "kind": "commanddeclaration"}, {"full_name": "hasSum_geometric_of_lt_1", "code": "theorem hasSum_geometric_of_lt_1 {r : \u211d} (h\u2081 : 0 \u2264 r) (h\u2082 : r < 1) :\n    HasSum (fun n : \u2115 => r ^ n) (1 - r)\u207b\u00b9", "start": [206, 1], "end": [212, 52], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_of_lt_1", "code": "theorem summable_geometric_of_lt_1 {r : \u211d} (h\u2081 : 0 \u2264 r) (h\u2082 : r < 1) :\n    Summable fun n : \u2115 => r ^ n", "start": [215, 1], "end": [217, 38], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_of_lt_1", "code": "theorem tsum_geometric_of_lt_1 {r : \u211d} (h\u2081 : 0 \u2264 r) (h\u2082 : r < 1) : \u2211' n : \u2115, r ^ n = (1 - r)\u207b\u00b9", "start": [220, 1], "end": [221, 43], "kind": "commanddeclaration"}, {"full_name": "hasSum_geometric_two", "code": "theorem hasSum_geometric_two : HasSum (fun n : \u2115 => ((1 : \u211d) / 2) ^ n) 2", "start": [224, 1], "end": [225, 52], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_two", "code": "theorem summable_geometric_two : Summable fun n : \u2115 => ((1 : \u211d) / 2) ^ n", "start": [228, 1], "end": [229, 28], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_two_encode", "code": "theorem summable_geometric_two_encode {\u03b9 : Type*} [Encodable \u03b9] :\n    Summable fun i : \u03b9 => (1 / 2 : \u211d) ^ Encodable.encode i", "start": [232, 1], "end": [234, 67], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_two", "code": "theorem tsum_geometric_two : (\u2211' n : \u2115, ((1 : \u211d) / 2) ^ n) = 2", "start": [237, 1], "end": [238, 31], "kind": "commanddeclaration"}, {"full_name": "sum_geometric_two_le", "code": "theorem sum_geometric_two_le (n : \u2115) : (\u2211 i : \u2115 in range n, (1 / (2 : \u211d)) ^ i) \u2264 2", "start": [241, 1], "end": [247, 32], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_inv_two", "code": "theorem tsum_geometric_inv_two : (\u2211' n : \u2115, (2 : \u211d)\u207b\u00b9 ^ n) = 2", "start": [250, 1], "end": [251, 53], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_inv_two_ge", "code": "theorem tsum_geometric_inv_two_ge (n : \u2115) :\n    (\u2211' i, ite (n \u2264 i) ((2 : \u211d)\u207b\u00b9 ^ i) 0) = 2 * 2\u207b\u00b9 ^ n", "start": [254, 1], "end": [265, 84], "kind": "commanddeclaration"}, {"full_name": "hasSum_geometric_two'", "code": "theorem hasSum_geometric_two' (a : \u211d) : HasSum (fun n : \u2115 => a / 2 / 2 ^ n) a", "start": [268, 1], "end": [274, 13], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_two'", "code": "theorem summable_geometric_two' (a : \u211d) : Summable fun n : \u2115 => a / 2 / 2 ^ n", "start": [277, 1], "end": [278, 31], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_two'", "code": "theorem tsum_geometric_two' (a : \u211d) : \u2211' n : \u2115, a / 2 / 2 ^ n = a", "start": [281, 1], "end": [282, 36], "kind": "commanddeclaration"}, {"full_name": "NNReal.hasSum_geometric", "code": "theorem NNReal.hasSum_geometric {r : \u211d\u22650} (hr : r < 1) : HasSum (fun n : \u2115 => r ^ n) (1 - r)\u207b\u00b9", "start": [285, 1], "end": [290, 49], "kind": "commanddeclaration"}, {"full_name": "NNReal.summable_geometric", "code": "theorem NNReal.summable_geometric {r : \u211d\u22650} (hr : r < 1) : Summable fun n : \u2115 => r ^ n", "start": [293, 1], "end": [294, 34], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_nnreal", "code": "theorem tsum_geometric_nnreal {r : \u211d\u22650} (hr : r < 1) : \u2211' n : \u2115, r ^ n = (1 - r)\u207b\u00b9", "start": [297, 1], "end": [298, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.tsum_geometric", "code": "@[simp]\ntheorem ENNReal.tsum_geometric (r : \u211d\u22650\u221e) : \u2211' n : \u2115, r ^ n = (1 - r)\u207b\u00b9", "start": [301, 1], "end": [315, 77], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_edist_le_geometric", "code": "theorem cauchySeq_of_edist_le_geometric : CauchySeq f", "start": [335, 1], "end": [341, 35], "kind": "commanddeclaration"}, {"full_name": "edist_le_of_edist_le_geometric_of_tendsto", "code": "theorem edist_le_of_edist_le_geometric_of_tendsto {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    edist (f n) a \u2264 C * r ^ n / (1 - r)", "start": [344, 1], "end": [349, 96], "kind": "commanddeclaration"}, {"full_name": "edist_le_of_edist_le_geometric_of_tendsto\u2080", "code": "theorem edist_le_of_edist_le_geometric_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    edist (f 0) a \u2264 C / (1 - r)", "start": [352, 1], "end": [356, 100], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_edist_le_geometric_two", "code": "theorem cauchySeq_of_edist_le_geometric_two : CauchySeq f", "start": [366, 1], "end": [370, 28], "kind": "commanddeclaration"}, {"full_name": "edist_le_of_edist_le_geometric_two_of_tendsto", "code": "theorem edist_le_of_edist_le_geometric_two_of_tendsto (n : \u2115) : edist (f n) a \u2264 2 * C / 2 ^ n", "start": [373, 1], "end": [379, 56], "kind": "commanddeclaration"}, {"full_name": "edist_le_of_edist_le_geometric_two_of_tendsto\u2080", "code": "theorem edist_le_of_edist_le_geometric_two_of_tendsto\u2080 : edist (f 0) a \u2264 2 * C", "start": [382, 1], "end": [386, 60], "kind": "commanddeclaration"}, {"full_name": "aux_hasSum_of_le_geometric", "code": "theorem aux_hasSum_of_le_geometric : HasSum (fun n : \u2115 => C * r ^ n) (C / (1 - r))", "start": [396, 1], "end": [400, 47], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_le_geometric", "code": "theorem cauchySeq_of_le_geometric : CauchySeq f", "start": [405, 1], "end": [408, 78], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_le_geometric_of_tendsto\u2080", "code": "theorem dist_le_of_le_geometric_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    dist (f 0) a \u2264 C / (1 - r)", "start": [411, 1], "end": [416, 86], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_le_geometric_of_tendsto", "code": "theorem dist_le_of_le_geometric_of_tendsto {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    dist (f n) a \u2264 C * r ^ n / (1 - r)", "start": [419, 1], "end": [427, 39], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_le_geometric_two", "code": "theorem cauchySeq_of_le_geometric_two : CauchySeq f", "start": [432, 1], "end": [434, 73], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_le_geometric_two_of_tendsto\u2080", "code": "theorem dist_le_of_le_geometric_two_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\n    dist (f 0) a \u2264 C", "start": [437, 1], "end": [441, 99], "kind": "commanddeclaration"}, {"full_name": "dist_le_of_le_geometric_two_of_tendsto", "code": "theorem dist_le_of_le_geometric_two_of_tendsto {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    dist (f n) a \u2264 C / 2 ^ n", "start": [444, 1], "end": [451, 56], "kind": "commanddeclaration"}, {"full_name": "summable_one_div_pow_of_le", "code": "theorem summable_one_div_pow_of_le {m : \u211d} {f : \u2115 \u2192 \u2115} (hm : 1 < m) (fi : \u2200 i, i \u2264 f i) :\n    Summable fun i => 1 / m ^ f i", "start": [459, 1], "end": [469, 43], "kind": "commanddeclaration"}, {"full_name": "posSumOfEncodable", "code": "def posSumOfEncodable {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) (\u03b9) [Encodable \u03b9] :\n    { \u03b5' : \u03b9 \u2192 \u211d // (\u2200 i, 0 < \u03b5' i) \u2227 \u2203 c, HasSum \u03b5' c \u2227 c \u2264 \u03b5 } := by\n  let f n := \u03b5 / 2 / 2 ^ n\n  have hf : HasSum f \u03b5 := hasSum_geometric_two' _\n  have f0 : \u2200 n, 0 < f n := fun n => div_pos (half_pos h\u03b5) (pow_pos zero_lt_two _)\n  refine' \u27e8f \u2218 Encodable.encode, fun i => f0 _, _\u27e9\n  rcases hf.summable.comp_injective (@Encodable.encode_injective \u03b9 _) with \u27e8c, hg\u27e9\n  refine' \u27e8c, hg, hasSum_le_inj _ (@Encodable.encode_injective \u03b9 _) _ _ hg hf\u27e9\n  \u00b7 intro i _\n    exact le_of_lt (f0 _)\n  \u00b7 intro n\n    exact le_rfl", "start": [475, 1], "end": [487, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.exists_pos_hasSum_le", "code": "theorem Set.Countable.exists_pos_hasSum_le {\u03b9 : Type*} {s : Set \u03b9} (hs : s.Countable) {\u03b5 : \u211d}\n    (h\u03b5 : 0 < \u03b5) : \u2203 \u03b5' : \u03b9 \u2192 \u211d, (\u2200 i, 0 < \u03b5' i) \u2227 \u2203 c, HasSum (fun i : s => \u03b5' i) c \u2227 c \u2264 \u03b5", "start": [490, 1], "end": [498, 60], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.exists_pos_forall_sum_le", "code": "theorem Set.Countable.exists_pos_forall_sum_le {\u03b9 : Type*} {s : Set \u03b9} (hs : s.Countable) {\u03b5 : \u211d}\n    (h\u03b5 : 0 < \u03b5) : \u2203 \u03b5' : \u03b9 \u2192 \u211d,\n    (\u2200 i, 0 < \u03b5' i) \u2227 \u2200 t : Finset \u03b9, \u2191t \u2286 s \u2192 \u2211 i in t, \u03b5' i \u2264 \u03b5", "start": [501, 1], "end": [508, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists_pos_sum_of_countable", "code": "theorem exists_pos_sum_of_countable {\u03b5 : \u211d\u22650} (h\u03b5 : \u03b5 \u2260 0) (\u03b9) [Countable \u03b9] :\n    \u2203 \u03b5' : \u03b9 \u2192 \u211d\u22650, (\u2200 i, 0 < \u03b5' i) \u2227 \u2203 c, HasSum \u03b5' c \u2227 c < \u03b5", "start": [513, 1], "end": [521, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_pos_sum_of_countable", "code": "theorem exists_pos_sum_of_countable {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) (\u03b9) [Countable \u03b9] :\n    \u2203 \u03b5' : \u03b9 \u2192 \u211d\u22650, (\u2200 i, 0 < \u03b5' i) \u2227 (\u2211' i, (\u03b5' i : \u211d\u22650\u221e)) < \u03b5", "start": [528, 1], "end": [533, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_pos_sum_of_countable'", "code": "theorem exists_pos_sum_of_countable' {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) (\u03b9) [Countable \u03b9] :\n    \u2203 \u03b5' : \u03b9 \u2192 \u211d\u22650\u221e, (\u2200 i, 0 < \u03b5' i) \u2227 \u2211' i, \u03b5' i < \u03b5", "start": [536, 1], "end": [539, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_pos_tsum_mul_lt_of_countable", "code": "theorem exists_pos_tsum_mul_lt_of_countable {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) {\u03b9} [Countable \u03b9] (w : \u03b9 \u2192 \u211d\u22650\u221e)\n    (hw : \u2200 i, w i \u2260 \u221e) : \u2203 \u03b4 : \u03b9 \u2192 \u211d\u22650, (\u2200 i, 0 < \u03b4 i) \u2227 (\u2211' i, (w i * \u03b4 i : \u211d\u22650\u221e)) < \u03b5", "start": [542, 1], "end": [551, 40], "kind": "commanddeclaration"}, {"full_name": "factorial_tendsto_atTop", "code": "theorem factorial_tendsto_atTop : Tendsto Nat.factorial atTop atTop", "start": [561, 1], "end": [562, 91], "kind": "commanddeclaration"}, {"full_name": "tendsto_factorial_div_pow_self_atTop", "code": "theorem tendsto_factorial_div_pow_self_atTop :\n    Tendsto (fun n => n ! / (n : \u211d) ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [565, 1], "end": [586, 18], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_floor_atTop", "code": "theorem tendsto_nat_floor_atTop {\u03b1 : Type*} [LinearOrderedSemiring \u03b1] [FloorSemiring \u03b1] :\n    Tendsto (fun x : \u03b1 => \u230ax\u230b\u208a) atTop atTop", "start": [596, 1], "end": [598, 90], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_floor_mul_div_atTop", "code": "theorem tendsto_nat_floor_mul_div_atTop {a : R} (ha : 0 \u2264 a) :\n    Tendsto (fun x => (\u230aa * x\u230b\u208a : R) / x) atTop (\ud835\udcdd a)", "start": [603, 1], "end": [616, 63], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_floor_div_atTop", "code": "theorem tendsto_nat_floor_div_atTop : Tendsto (fun x => (\u230ax\u230b\u208a : R) / x) atTop (\ud835\udcdd 1)", "start": [619, 1], "end": [620, 63], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_ceil_mul_div_atTop", "code": "theorem tendsto_nat_ceil_mul_div_atTop {a : R} (ha : 0 \u2264 a) :\n    Tendsto (fun x => (\u2308a * x\u2309\u208a : R) / x) atTop (\ud835\udcdd a)", "start": [623, 1], "end": [634, 80], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_ceil_div_atTop", "code": "theorem tendsto_nat_ceil_div_atTop : Tendsto (fun x => (\u2308x\u2309\u208a : R) / x) atTop (\ud835\udcdd 1)", "start": [637, 1], "end": [638, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.tendsto_div_const_atTop", "code": "lemma Nat.tendsto_div_const_atTop {n : \u2115} (hn : n \u2260 0) : Tendsto (\u03bb x \u21a6 x / n) atTop atTop := by\n  simp_rw [\u2190@Nat.floor_div_eq_div \u211a]\n  exact tendsto_nat_floor_atTop.comp (tendsto_nat_cast_atTop_atTop.atTop_div_const $ by positivity)", "start": [641, 1], "end": [643, 100], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/SetTheory/Cardinal/Continuum.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Cardinal.continuum", "code": "def continuum : Cardinal.{u} :=\n  2 ^ \u2135\u2080", "start": [28, 1], "end": [30, 9], "kind": "commanddeclaration"}, {"full_name": "Cardinal.two_power_aleph0", "code": "@[simp]\ntheorem two_power_aleph0 : 2 ^ aleph0.{u} = continuum.{u}", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_continuum", "code": "@[simp]\ntheorem lift_continuum : lift.{v} \ud835\udd20 = \ud835\udd20", "start": [41, 1], "end": [43, 73], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_le_lift", "code": "@[simp]\ntheorem continuum_le_lift {c : Cardinal.{u}} : \ud835\udd20 \u2264 lift.{v} c \u2194 \ud835\udd20 \u2264 c", "start": [46, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_le_continuum", "code": "@[simp]\ntheorem lift_le_continuum {c : Cardinal.{u}} : lift.{v} c \u2264 \ud835\udd20 \u2194 c \u2264 \ud835\udd20", "start": [52, 1], "end": [55, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_lt_lift", "code": "@[simp]\ntheorem continuum_lt_lift {c : Cardinal.{u}} : \ud835\udd20 < lift.{v} c \u2194 \ud835\udd20 < c", "start": [58, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt_continuum", "code": "@[simp]\ntheorem lift_lt_continuum {c : Cardinal.{u}} : lift.{v} c < \ud835\udd20 \u2194 c < \ud835\udd20", "start": [64, 1], "end": [67, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_lt_continuum", "code": "theorem aleph0_lt_continuum : \u2135\u2080 < \ud835\udd20", "start": [75, 1], "end": [76, 12], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_continuum", "code": "theorem aleph0_le_continuum : \u2135\u2080 \u2264 \ud835\udd20", "start": [79, 1], "end": [80, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_one", "code": "@[simp]\ntheorem beth_one : beth 1 = \ud835\udd20", "start": [83, 1], "end": [84, 60], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_lt_continuum", "code": "theorem nat_lt_continuum (n : \u2115) : \u2191n < \ud835\udd20", "start": [87, 1], "end": [88, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_set_nat", "code": "theorem mk_set_nat : #(Set \u2115) = \ud835\udd20", "start": [91, 1], "end": [91, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_pos", "code": "theorem continuum_pos : 0 < \ud835\udd20", "start": [94, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_ne_zero", "code": "theorem continuum_ne_zero : \ud835\udd20 \u2260 0", "start": [98, 1], "end": [99, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_one_le_continuum", "code": "theorem aleph_one_le_continuum : aleph 1 \u2264 \ud835\udd20", "start": [102, 1], "end": [104, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_toNat", "code": "@[simp]\ntheorem continuum_toNat : toNat continuum = 0", "start": [107, 1], "end": [109, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_toPartENat", "code": "@[simp]\ntheorem continuum_toPartENat : toPartENat continuum = \u22a4", "start": [112, 1], "end": [114, 52], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_add_continuum", "code": "@[simp]\ntheorem aleph0_add_continuum : \u2135\u2080 + \ud835\udd20 = \ud835\udd20", "start": [122, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_add_aleph0", "code": "@[simp]\ntheorem continuum_add_aleph0 : \ud835\udd20 + \u2135\u2080 = \ud835\udd20", "start": [127, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_add_self", "code": "@[simp]\ntheorem continuum_add_self : \ud835\udd20 + \ud835\udd20 = \ud835\udd20", "start": [132, 1], "end": [134, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_add_continuum", "code": "@[simp]\ntheorem nat_add_continuum (n : \u2115) : \u2191n + \ud835\udd20 = \ud835\udd20", "start": [137, 1], "end": [139, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_add_nat", "code": "@[simp]\ntheorem continuum_add_nat (n : \u2115) : \ud835\udd20 + n = \ud835\udd20", "start": [142, 1], "end": [144, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ofNat_add_continuum", "code": "@[simp]\ntheorem ofNat_add_continuum {n : \u2115} [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) + \ud835\udd20 = \ud835\udd20", "start": [148, 1], "end": [150, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_add_ofNat", "code": "@[simp]\ntheorem continuum_add_ofNat {n : \u2115} [Nat.AtLeastTwo n] : \ud835\udd20 + no_index (OfNat.ofNat n) = \ud835\udd20", "start": [153, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_mul_self", "code": "@[simp]\ntheorem continuum_mul_self : \ud835\udd20 * \ud835\udd20 = \ud835\udd20", "start": [162, 1], "end": [164, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_mul_aleph0", "code": "@[simp]\ntheorem continuum_mul_aleph0 : \ud835\udd20 * \u2135\u2080 = \ud835\udd20", "start": [167, 1], "end": [169, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_continuum", "code": "@[simp]\ntheorem aleph0_mul_continuum : \u2135\u2080 * \ud835\udd20 = \ud835\udd20", "start": [172, 1], "end": [174, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_mul_continuum", "code": "@[simp]\ntheorem nat_mul_continuum {n : \u2115} (hn : n \u2260 0) : \u2191n * \ud835\udd20 = \ud835\udd20", "start": [177, 1], "end": [179, 83], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_mul_nat", "code": "@[simp]\ntheorem continuum_mul_nat {n : \u2115} (hn : n \u2260 0) : \ud835\udd20 * n = \ud835\udd20", "start": [182, 1], "end": [184, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ofNat_mul_continuum", "code": "@[simp]\ntheorem ofNat_mul_continuum {n : \u2115} [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) * \ud835\udd20 = \ud835\udd20", "start": [188, 1], "end": [190, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_mul_ofNat", "code": "@[simp]\ntheorem continuum_mul_ofNat {n : \u2115} [Nat.AtLeastTwo n] : \ud835\udd20 * no_index (OfNat.ofNat n) = \ud835\udd20", "start": [193, 1], "end": [195, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_power_aleph0", "code": "@[simp]\ntheorem aleph0_power_aleph0 : aleph0.{u} ^ aleph0.{u} = \ud835\udd20", "start": [202, 1], "end": [204, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_power_aleph0", "code": "@[simp]\ntheorem nat_power_aleph0 {n : \u2115} (hn : 2 \u2264 n) : (n ^ aleph0.{u} : Cardinal.{u}) = \ud835\udd20", "start": [207, 1], "end": [209, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.continuum_power_aleph0", "code": "@[simp]\ntheorem continuum_power_aleph0 : continuum.{u} ^ aleph0.{u} = \ud835\udd20", "start": [212, 1], "end": [214, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Sqrt.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Algebra/Star/Order.lean", "Mathlib/Topology/Instances/NNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Order/MonotoneContinuity.lean"], "premises": [{"full_name": "NNReal.sqrt", "code": "noncomputable def sqrt : \u211d\u22650 \u2243o \u211d\u22650 :=\n  OrderIso.symm <| powOrderIso 2 two_ne_zero", "start": [48, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_le_sqrt_iff", "code": "theorem sqrt_le_sqrt_iff : sqrt x \u2264 sqrt y \u2194 x \u2264 y", "start": [54, 1], "end": [55, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_lt_sqrt_iff", "code": "theorem sqrt_lt_sqrt_iff : sqrt x < sqrt y \u2194 x < y", "start": [58, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_eq_iff_sq_eq", "code": "theorem sqrt_eq_iff_sq_eq : sqrt x = y \u2194 y ^ 2 = x", "start": [62, 1], "end": [63, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_le_iff", "code": "theorem sqrt_le_iff : sqrt x \u2264 y \u2194 x \u2264 y ^ 2", "start": [66, 1], "end": [67, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_sqrt_iff", "code": "theorem le_sqrt_iff : x \u2264 sqrt y \u2194 x ^ 2 \u2264 y", "start": [70, 1], "end": [71, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_eq_zero", "code": "@[simp]\ntheorem sqrt_eq_zero : sqrt x = 0 \u2194 x = 0", "start": [74, 1], "end": [76, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_zero", "code": "@[simp]\ntheorem sqrt_zero : sqrt 0 = 0", "start": [79, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_one", "code": "@[simp]\ntheorem sqrt_one : sqrt 1 = 1", "start": [84, 1], "end": [86, 35], "kind": "commanddeclaration"}, {"full_name": "NNReal.sq_sqrt", "code": "@[simp]\ntheorem sq_sqrt (x : \u211d\u22650) : sqrt x ^ 2 = x", "start": [89, 1], "end": [91, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_self_sqrt", "code": "@[simp]\ntheorem mul_self_sqrt (x : \u211d\u22650) : sqrt x * sqrt x = x", "start": [94, 1], "end": [95, 79], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_sq", "code": "@[simp]\ntheorem sqrt_sq (x : \u211d\u22650) : sqrt (x ^ 2) = x", "start": [98, 1], "end": [100, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_mul_self", "code": "@[simp]\ntheorem sqrt_mul_self (x : \u211d\u22650) : sqrt (x * x) = x", "start": [103, 1], "end": [104, 78], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_mul", "code": "theorem sqrt_mul (x y : \u211d\u22650) : sqrt (x * y) = sqrt x * sqrt y", "start": [107, 1], "end": [108, 52], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrtHom", "code": "noncomputable def sqrtHom : \u211d\u22650 \u2192*\u2080 \u211d\u22650 :=\n  \u27e8\u27e8sqrt, sqrt_zero\u27e9, sqrt_one, sqrt_mul\u27e9", "start": [111, 1], "end": [113, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_inv", "code": "theorem sqrt_inv (x : \u211d\u22650) : sqrt x\u207b\u00b9 = (sqrt x)\u207b\u00b9", "start": [116, 1], "end": [117, 21], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_div", "code": "theorem sqrt_div (x y : \u211d\u22650) : sqrt (x / y) = sqrt x / sqrt y", "start": [120, 1], "end": [121, 23], "kind": "commanddeclaration"}, {"full_name": "NNReal.continuous_sqrt", "code": "theorem continuous_sqrt : Continuous sqrt", "start": [124, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_pos", "code": "@[simp] theorem sqrt_pos : 0 < sqrt x \u2194 0 < x", "start": [127, 1], "end": [127, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.sqrt_pos_of_pos", "code": "alias \u27e8_, sqrt_pos_of_pos\u27e9 := sqrt_pos", "start": [129, 1], "end": [129, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Real.sqrtAux", "code": "def sqrtAux (f : CauSeq \u211a abs) : \u2115 \u2192 \u211a\n  | 0 => mkRat (f 0).num.toNat.sqrt (f 0).den.sqrt\n  | n + 1 =>\n    let s := sqrtAux f n\n    max 0 <| (s + f (n + 1) / s) / 2", "start": [135, 1], "end": [141, 37], "kind": "commanddeclaration"}, {"full_name": "Real.sqrtAux_nonneg", "code": "theorem sqrtAux_nonneg (f : CauSeq \u211a abs) : \u2200 i : \u2115, 0 \u2264 sqrtAux f i", "start": [144, 1], "end": [148, 29], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt", "code": "noncomputable def sqrt (x : \u211d) : \u211d :=\n  NNReal.sqrt (Real.toNNReal x)", "start": [165, 1], "end": [167, 32], "kind": "commanddeclaration"}, {"full_name": "Real.coe_sqrt", "code": "@[simp, norm_cast]\ntheorem coe_sqrt {x : \u211d\u22650} : (NNReal.sqrt x : \u211d) = Real.sqrt x", "start": [181, 1], "end": [183, 36], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_sqrt", "code": "@[continuity]\ntheorem continuous_sqrt : Continuous sqrt", "start": [186, 1], "end": [188, 85], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_zero_of_nonpos", "code": "theorem sqrt_eq_zero_of_nonpos (h : x \u2264 0) : sqrt x = 0", "start": [191, 1], "end": [191, 101], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_nonneg", "code": "theorem sqrt_nonneg (x : \u211d) : 0 \u2264 sqrt x", "start": [194, 1], "end": [195, 22], "kind": "commanddeclaration"}, {"full_name": "Real.mul_self_sqrt", "code": "@[simp]\ntheorem mul_self_sqrt (h : 0 \u2264 x) : sqrt x * sqrt x = x", "start": [198, 1], "end": [200, 75], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_mul_self", "code": "@[simp]\ntheorem sqrt_mul_self (h : 0 \u2264 x) : sqrt (x * x) = x", "start": [203, 1], "end": [205, 83], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_cases", "code": "theorem sqrt_eq_cases : sqrt x = y \u2194 y * y = x \u2227 0 \u2264 y \u2228 x < 0 \u2227 y = 0", "start": [208, 1], "end": [215, 60], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_iff_mul_self_eq", "code": "theorem sqrt_eq_iff_mul_self_eq (hx : 0 \u2264 x) (hy : 0 \u2264 y) : sqrt x = y \u2194 y * y = x", "start": [218, 1], "end": [219, 83], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_iff_mul_self_eq_of_pos", "code": "theorem sqrt_eq_iff_mul_self_eq_of_pos (h : 0 < y) : sqrt x = y \u2194 y * y = x", "start": [222, 1], "end": [223, 36], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_one", "code": "@[simp]\ntheorem sqrt_eq_one : sqrt x = 1 \u2194 x = 1", "start": [226, 1], "end": [230, 42], "kind": "commanddeclaration"}, {"full_name": "Real.sq_sqrt", "code": "@[simp]\ntheorem sq_sqrt (h : 0 \u2264 x) : sqrt x ^ 2 = x", "start": [233, 1], "end": [234, 76], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_sq", "code": "@[simp]\ntheorem sqrt_sq (h : 0 \u2264 x) : sqrt (x ^ 2) = x", "start": [237, 1], "end": [238, 78], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_iff_sq_eq", "code": "theorem sqrt_eq_iff_sq_eq (hx : 0 \u2264 x) (hy : 0 \u2264 y) : sqrt x = y \u2194 y ^ 2 = x", "start": [241, 1], "end": [242, 41], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_mul_self_eq_abs", "code": "theorem sqrt_mul_self_eq_abs (x : \u211d) : sqrt (x * x) = |x|", "start": [245, 1], "end": [246, 58], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_sq_eq_abs", "code": "theorem sqrt_sq_eq_abs (x : \u211d) : sqrt (x ^ 2) = |x|", "start": [249, 1], "end": [249, 88], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_zero", "code": "@[simp]\ntheorem sqrt_zero : sqrt 0 = 0", "start": [252, 1], "end": [253, 49], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_one", "code": "@[simp]\ntheorem sqrt_one : sqrt 1 = 1", "start": [256, 1], "end": [257, 48], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_le_sqrt_iff", "code": "@[simp]\ntheorem sqrt_le_sqrt_iff (hy : 0 \u2264 y) : sqrt x \u2264 sqrt y \u2194 x \u2264 y", "start": [260, 1], "end": [262, 96], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_lt_sqrt_iff", "code": "@[simp]\ntheorem sqrt_lt_sqrt_iff (hx : 0 \u2264 x) : sqrt x < sqrt y \u2194 x < y", "start": [265, 1], "end": [267, 47], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_lt_sqrt_iff_of_pos", "code": "theorem sqrt_lt_sqrt_iff_of_pos (hy : 0 < y) : sqrt x < sqrt y \u2194 x < y", "start": [270, 1], "end": [271, 91], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_le_sqrt", "code": "theorem sqrt_le_sqrt (h : x \u2264 y) : sqrt x \u2264 sqrt y", "start": [274, 1], "end": [276, 31], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_lt_sqrt", "code": "theorem sqrt_lt_sqrt (hx : 0 \u2264 x) (h : x < y) : sqrt x < sqrt y", "start": [279, 1], "end": [280, 28], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_le_left", "code": "theorem sqrt_le_left (hy : 0 \u2264 y) : sqrt x \u2264 y \u2194 x \u2264 y ^ 2", "start": [283, 1], "end": [285, 59], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_le_iff", "code": "theorem sqrt_le_iff : sqrt x \u2264 y \u2194 0 \u2264 y \u2227 x \u2264 y ^ 2", "start": [288, 1], "end": [290, 21], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_lt", "code": "theorem sqrt_lt (hx : 0 \u2264 x) (hy : 0 \u2264 y) : sqrt x < y \u2194 x < y ^ 2", "start": [293, 1], "end": [294, 41], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_lt'", "code": "theorem sqrt_lt' (hy : 0 < y) : sqrt x < y \u2194 x < y ^ 2", "start": [297, 1], "end": [298, 63], "kind": "commanddeclaration"}, {"full_name": "Real.le_sqrt", "code": "theorem le_sqrt (hx : 0 \u2264 x) (hy : 0 \u2264 y) : x \u2264 sqrt y \u2194 x ^ 2 \u2264 y", "start": [301, 1], "end": [304, 45], "kind": "commanddeclaration"}, {"full_name": "Real.le_sqrt'", "code": "theorem le_sqrt' (hx : 0 < x) : x \u2264 sqrt y \u2194 x ^ 2 \u2264 y", "start": [307, 1], "end": [308, 43], "kind": "commanddeclaration"}, {"full_name": "Real.abs_le_sqrt", "code": "theorem abs_le_sqrt (h : x ^ 2 \u2264 y) : |x| \u2264 sqrt y", "start": [311, 1], "end": [312, 46], "kind": "commanddeclaration"}, {"full_name": "Real.sq_le", "code": "theorem sq_le (h : 0 \u2264 y) : x ^ 2 \u2264 y \u2194 -sqrt y \u2264 x \u2227 x \u2264 sqrt y", "start": [315, 1], "end": [319, 40], "kind": "commanddeclaration"}, {"full_name": "Real.neg_sqrt_le_of_sq_le", "code": "theorem neg_sqrt_le_of_sq_le (h : x ^ 2 \u2264 y) : -sqrt y \u2264 x", "start": [322, 1], "end": [323, 43], "kind": "commanddeclaration"}, {"full_name": "Real.le_sqrt_of_sq_le", "code": "theorem le_sqrt_of_sq_le (h : x ^ 2 \u2264 y) : x \u2264 sqrt y", "start": [326, 1], "end": [327, 43], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_inj", "code": "@[simp]\ntheorem sqrt_inj (hx : 0 \u2264 x) (hy : 0 \u2264 y) : sqrt x = sqrt y \u2194 x = y", "start": [330, 1], "end": [332, 33], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_zero", "code": "@[simp]\ntheorem sqrt_eq_zero (h : 0 \u2264 x) : sqrt x = 0 \u2194 x = 0", "start": [335, 1], "end": [336, 90], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_eq_zero'", "code": "theorem sqrt_eq_zero' : sqrt x = 0 \u2194 x \u2264 0", "start": [339, 1], "end": [340, 76], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_ne_zero", "code": "theorem sqrt_ne_zero (h : 0 \u2264 x) : sqrt x \u2260 0 \u2194 x \u2260 0", "start": [343, 1], "end": [343, 93], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_ne_zero'", "code": "theorem sqrt_ne_zero' : sqrt x \u2260 0 \u2194 0 < x", "start": [346, 1], "end": [346, 91], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_pos", "code": "@[simp]\ntheorem sqrt_pos : 0 < sqrt x \u2194 0 < x", "start": [349, 1], "end": [351, 92], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_pos_of_pos", "code": "alias \u27e8_, sqrt_pos_of_pos\u27e9 := sqrt_pos", "start": [354, 1], "end": [354, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Mathlib.Meta.Positivity.evalNNRealSqrt", "code": "@[positivity NNReal.sqrt _]\ndef evalNNRealSqrt : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(NNReal))) \u2190 whnfR e | throwError \"not NNReal.sqrt\"\n  let z\u03b1' \u2190 synthInstanceQ (q(Zero NNReal) : Q(Type))\n  let p\u03b1' \u2190 synthInstanceQ (q(PartialOrder NNReal) : Q(Type))\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  assertInstancesCommute\n  match ra with\n  | .positive pa => pure (.positive (q(NNReal.sqrt_pos_of_pos $pa) : Expr))\n  | _ => failure", "start": [363, 1], "end": [374, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalSqrt", "code": "@[positivity Real.sqrt _]\ndef evalSqrt : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(Real))) \u2190 whnfR e | throwError \"not Real.sqrt\"\n  let z\u03b1' \u2190 synthInstanceQ (q(Zero Real) : Q(Type))\n  let p\u03b1' \u2190 synthInstanceQ (q(PartialOrder Real) : Q(Type))\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  assertInstancesCommute\n  match ra with\n  | .positive pa => pure (.positive (q(Real.sqrt_pos_of_pos $pa) : Expr))\n  | _ => pure (.nonnegative (q(Real.sqrt_nonneg $a) : Expr))", "start": [376, 1], "end": [387, 61], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_mul", "code": "@[simp]\ntheorem sqrt_mul (hx : 0 \u2264 x) (y : \u211d) : sqrt (x * y) = sqrt x * sqrt y", "start": [393, 1], "end": [395, 89], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_mul'", "code": "@[simp]\ntheorem sqrt_mul' (x) {y : \u211d} (hy : 0 \u2264 y) : sqrt (x * y) = sqrt x * sqrt y", "start": [398, 1], "end": [400, 39], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_inv", "code": "@[simp]\ntheorem sqrt_inv (x : \u211d) : sqrt x\u207b\u00b9 = (sqrt x)\u207b\u00b9", "start": [403, 1], "end": [405, 70], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_div", "code": "@[simp]\ntheorem sqrt_div (hx : 0 \u2264 x) (y : \u211d) : sqrt (x / y) = sqrt x / sqrt y", "start": [408, 1], "end": [410, 57], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_div'", "code": "@[simp]\ntheorem sqrt_div' (x) {y : \u211d} (hy : 0 \u2264 y) : sqrt (x / y) = sqrt x / sqrt y", "start": [413, 1], "end": [415, 75], "kind": "commanddeclaration"}, {"full_name": "Real.div_sqrt", "code": "@[simp]\ntheorem div_sqrt : x / sqrt x = sqrt x", "start": [418, 1], "end": [422, 62], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_div_self'", "code": "theorem sqrt_div_self' : sqrt x / x = 1 / sqrt x", "start": [425, 1], "end": [425, 94], "kind": "commanddeclaration"}, {"full_name": "Real.sqrt_div_self", "code": "theorem sqrt_div_self : sqrt x / x = (sqrt x)\u207b\u00b9", "start": [428, 1], "end": [428, 83], "kind": "commanddeclaration"}, {"full_name": "Real.lt_sqrt", "code": "theorem lt_sqrt (hx : 0 \u2264 x) : x < sqrt y \u2194 x ^ 2 < y", "start": [431, 1], "end": [432, 52], "kind": "commanddeclaration"}, {"full_name": "Real.sq_lt", "code": "theorem sq_lt : x ^ 2 < y \u2194 -sqrt y < x \u2227 x < sqrt y", "start": [435, 1], "end": [436, 50], "kind": "commanddeclaration"}, {"full_name": "Real.neg_sqrt_lt_of_sq_lt", "code": "theorem neg_sqrt_lt_of_sq_lt (h : x ^ 2 < y) : -sqrt y < x", "start": [439, 1], "end": [440, 17], "kind": "commanddeclaration"}, {"full_name": "Real.lt_sqrt_of_sq_lt", "code": "theorem lt_sqrt_of_sq_lt (h : x ^ 2 < y) : x < sqrt y", "start": [443, 1], "end": [444, 17], "kind": "commanddeclaration"}, {"full_name": "Real.lt_sq_of_sqrt_lt", "code": "theorem lt_sq_of_sqrt_lt {x y : \u211d} (h : sqrt x < y) : x < y ^ 2", "start": [447, 1], "end": [449, 68], "kind": "commanddeclaration"}, {"full_name": "Real.nat_sqrt_le_real_sqrt", "code": "theorem nat_sqrt_le_real_sqrt {a : \u2115} : \u2191(Nat.sqrt a) \u2264 Real.sqrt \u2191a", "start": [452, 1], "end": [456, 23], "kind": "commanddeclaration"}, {"full_name": "Real.real_sqrt_le_nat_sqrt_succ", "code": "theorem real_sqrt_le_nat_sqrt_succ {a : \u2115} : Real.sqrt \u2191a \u2264 Nat.sqrt a + 1", "start": [459, 1], "end": [466, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.sqrt", "code": "theorem Filter.Tendsto.sqrt {f : \u03b1 \u2192 \u211d} {l : Filter \u03b1} {x : \u211d} (h : Tendsto f l (\ud835\udcdd x)) :\n    Tendsto (fun x => sqrt (f x)) l (\ud835\udcdd (sqrt x))", "start": [486, 1], "end": [488, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.sqrt", "code": "nonrec theorem ContinuousWithinAt.sqrt (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => sqrt (f x)) s x", "start": [493, 1], "end": [495, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.sqrt", "code": "nonrec theorem ContinuousAt.sqrt (h : ContinuousAt f x) : ContinuousAt (fun x => sqrt (f x)) x", "start": [498, 1], "end": [499, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.sqrt", "code": "theorem ContinuousOn.sqrt (h : ContinuousOn f s) : ContinuousOn (fun x => sqrt (f x)) s", "start": [502, 1], "end": [503, 28], "kind": "commanddeclaration"}, {"full_name": "Continuous.sqrt", "code": "@[continuity]\ntheorem Continuous.sqrt (h : Continuous f) : Continuous fun x => sqrt (f x)", "start": [506, 1], "end": [508, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Bitwise.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Power.lean", "Mathlib/Data/Int/Bitwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "zpow_bit1\u2080", "code": "theorem zpow_bit1\u2080 (a : G\u2080) (n : \u2124) : a ^ bit1 n = a ^ n * a ^ n * a", "start": [26, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1'", "code": "theorem zpow_bit1' (a : G\u2080) (n : \u2124) : a ^ bit1 n = (a * a) ^ n * a", "start": [33, 1], "end": [34, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Field/Basic.lean", "imports": ["Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonUnitalSeminormedRing", "code": "class NonUnitalSeminormedRing (\u03b1 : Type*) extends Norm \u03b1, NonUnitalRing \u03b1,\n  PseudoMetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul : \u2200 a b, norm (a * b) \u2264 norm a * norm b", "start": [26, 1], "end": [33, 51], "kind": "commanddeclaration"}, {"full_name": "SeminormedRing", "code": "class SeminormedRing (\u03b1 : Type*) extends Norm \u03b1, Ring \u03b1, PseudoMetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul : \u2200 a b, norm (a * b) \u2264 norm a * norm b", "start": [36, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "SeminormedRing.toNonUnitalSeminormedRing", "code": "instance (priority := 100) SeminormedRing.toNonUnitalSeminormedRing [\u03b2 : SeminormedRing \u03b1] :\n    NonUnitalSeminormedRing \u03b1 :=\n  { \u03b2 with }", "start": [46, 1], "end": [49, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNormedRing", "code": "class NonUnitalNormedRing (\u03b1 : Type*) extends Norm \u03b1, NonUnitalRing \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul : \u2200 a b, norm (a * b) \u2264 norm a * norm b", "start": [52, 1], "end": [58, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNormedRing.toNonUnitalSeminormedRing", "code": "instance (priority := 100) NonUnitalNormedRing.toNonUnitalSeminormedRing\n    [\u03b2 : NonUnitalNormedRing \u03b1] : NonUnitalSeminormedRing \u03b1 :=\n  { \u03b2 with }", "start": [62, 1], "end": [65, 13], "kind": "commanddeclaration"}, {"full_name": "NormedRing", "code": "class NormedRing (\u03b1 : Type*) extends Norm \u03b1, Ring \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul : \u2200 a b, norm (a * b) \u2264 norm a * norm b", "start": [68, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing", "code": "class NormedDivisionRing (\u03b1 : Type*) extends Norm \u03b1, DivisionRing \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul' : \u2200 a b, norm (a * b) = norm a * norm b", "start": [76, 1], "end": [82, 52], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing.toNormedRing", "code": "instance (priority := 100) NormedDivisionRing.toNormedRing [\u03b2 : NormedDivisionRing \u03b1] :\n    NormedRing \u03b1 :=\n  { \u03b2 with norm_mul := fun a b => (NormedDivisionRing.norm_mul' a b).le }", "start": [86, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "NormedRing.toSeminormedRing", "code": "instance (priority := 100) NormedRing.toSeminormedRing [\u03b2 : NormedRing \u03b1] : SeminormedRing \u03b1 :=\n  { \u03b2 with }", "start": [93, 1], "end": [95, 13], "kind": "commanddeclaration"}, {"full_name": "NormedRing.toNonUnitalNormedRing", "code": "instance (priority := 100) NormedRing.toNonUnitalNormedRing [\u03b2 : NormedRing \u03b1] :\n    NonUnitalNormedRing \u03b1 :=\n  { \u03b2 with }", "start": [99, 1], "end": [102, 13], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommRing", "code": "class SeminormedCommRing (\u03b1 : Type*) extends SeminormedRing \u03b1 where\n  \n  mul_comm : \u2200 x y : \u03b1, x * y = y * x", "start": [105, 1], "end": [109, 38], "kind": "commanddeclaration"}, {"full_name": "NormedCommRing", "code": "class NormedCommRing (\u03b1 : Type*) extends NormedRing \u03b1 where\n  \n  mul_comm : \u2200 x y : \u03b1, x * y = y * x", "start": [112, 1], "end": [116, 38], "kind": "commanddeclaration"}, {"full_name": "NormedCommRing.toSeminormedCommRing", "code": "instance (priority := 100) NormedCommRing.toSeminormedCommRing [\u03b2 : NormedCommRing \u03b1] :\n    SeminormedCommRing \u03b1 :=\n  { \u03b2 with }", "start": [120, 1], "end": [123, 13], "kind": "commanddeclaration"}, {"full_name": "PUnit.normedCommRing", "code": "instance PUnit.normedCommRing : NormedCommRing PUnit :=\n  { PUnit.normedAddCommGroup, PUnit.commRing with\n    norm_mul := fun _ _ => by simp }", "start": [126, 1], "end": [128, 37], "kind": "commanddeclaration"}, {"full_name": "NormOneClass", "code": "class NormOneClass (\u03b1 : Type*) [Norm \u03b1] [One \u03b1] : Prop where\n  \n  norm_one : \u2016(1 : \u03b1)\u2016 = 1", "start": [130, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "nnnorm_one", "code": "@[simp]\ntheorem nnnorm_one [SeminormedAddCommGroup \u03b1] [One \u03b1] [NormOneClass \u03b1] : \u2016(1 : \u03b1)\u2016\u208a = 1", "start": [141, 1], "end": [143, 21], "kind": "commanddeclaration"}, {"full_name": "NormOneClass.nontrivial", "code": "theorem NormOneClass.nontrivial (\u03b1 : Type*) [SeminormedAddCommGroup \u03b1] [One \u03b1] [NormOneClass \u03b1] :\n    Nontrivial \u03b1", "start": [146, 1], "end": [148, 57], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommRing.toCommRing", "code": "instance (priority := 100) SeminormedCommRing.toCommRing [\u03b2 : SeminormedCommRing \u03b1] : CommRing \u03b1 :=\n  { \u03b2 with }", "start": [152, 1], "end": [153, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNormedRing.toNormedAddCommGroup", "code": "instance (priority := 100) NonUnitalNormedRing.toNormedAddCommGroup [\u03b2 : NonUnitalNormedRing \u03b1] :\n    NormedAddCommGroup \u03b1 :=\n  { \u03b2 with }", "start": [157, 1], "end": [159, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSeminormedRing.toSeminormedAddCommGroup", "code": "instance (priority := 100) NonUnitalSeminormedRing.toSeminormedAddCommGroup\n    [NonUnitalSeminormedRing \u03b1] : SeminormedAddCommGroup \u03b1 :=\n  { \u2039NonUnitalSeminormedRing \u03b1\u203a with }", "start": [163, 1], "end": [165, 39], "kind": "commanddeclaration"}, {"full_name": "ULift.normOneClass", "code": "instance ULift.normOneClass [SeminormedAddCommGroup \u03b1] [One \u03b1] [NormOneClass \u03b1] :\n    NormOneClass (ULift \u03b1) :=\n  \u27e8by simp [ULift.norm_def]\u27e9", "start": [168, 1], "end": [170, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.normOneClass", "code": "instance Prod.normOneClass [SeminormedAddCommGroup \u03b1] [One \u03b1] [NormOneClass \u03b1]\n    [SeminormedAddCommGroup \u03b2] [One \u03b2] [NormOneClass \u03b2] : NormOneClass (\u03b1 \u00d7 \u03b2) :=\n  \u27e8by simp [Prod.norm_def]\u27e9", "start": [172, 1], "end": [174, 28], "kind": "commanddeclaration"}, {"full_name": "Pi.normOneClass", "code": "instance Pi.normOneClass {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [Nonempty \u03b9] [Fintype \u03b9]\n    [\u2200 i, SeminormedAddCommGroup (\u03b1 i)] [\u2200 i, One (\u03b1 i)] [\u2200 i, NormOneClass (\u03b1 i)] :\n    NormOneClass (\u2200 i, \u03b1 i) :=\n  \u27e8by simp [Pi.norm_def]; exact Finset.sup_const Finset.univ_nonempty 1\u27e9", "start": [177, 1], "end": [180, 73], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normOneClass", "code": "instance MulOpposite.normOneClass [SeminormedAddCommGroup \u03b1] [One \u03b1] [NormOneClass \u03b1] :\n    NormOneClass \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8@norm_one \u03b1 _ _ _\u27e9", "start": [183, 1], "end": [185, 22], "kind": "commanddeclaration"}, {"full_name": "norm_mul_le", "code": "theorem norm_mul_le (a b : \u03b1) : \u2016a * b\u2016 \u2264 \u2016a\u2016 * \u2016b\u2016", "start": [192, 1], "end": [193, 39], "kind": "commanddeclaration"}, {"full_name": "nnnorm_mul_le", "code": "theorem nnnorm_mul_le (a b : \u03b1) : \u2016a * b\u2016\u208a \u2264 \u2016a\u2016\u208a * \u2016b\u2016\u208a", "start": [196, 1], "end": [198, 41], "kind": "commanddeclaration"}, {"full_name": "one_le_norm_one", "code": "theorem one_le_norm_one (\u03b2) [NormedRing \u03b2] [Nontrivial \u03b2] : 1 \u2264 \u2016(1 : \u03b2)\u2016", "start": [201, 1], "end": [203, 58], "kind": "commanddeclaration"}, {"full_name": "one_le_nnnorm_one", "code": "theorem one_le_nnnorm_one (\u03b2) [NormedRing \u03b2] [Nontrivial \u03b2] : 1 \u2264 \u2016(1 : \u03b2)\u2016\u208a", "start": [206, 1], "end": [207, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.zero_mul_isBoundedUnder_le", "code": "theorem Filter.Tendsto.zero_mul_isBoundedUnder_le {f g : \u03b9 \u2192 \u03b1} {l : Filter \u03b9}\n    (hf : Tendsto f l (\ud835\udcdd 0)) (hg : IsBoundedUnder (\u00b7 \u2264 \u00b7) l ((\u2016\u00b7\u2016) \u2218 g)) :\n    Tendsto (fun x => f x * g x) l (\ud835\udcdd 0)", "start": [210, 1], "end": [213, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.isBoundedUnder_le_mul_tendsto_zero", "code": "theorem Filter.isBoundedUnder_le_mul_tendsto_zero {f g : \u03b9 \u2192 \u03b1} {l : Filter \u03b9}\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f)) (hg : Tendsto g l (\ud835\udcdd 0)) :\n    Tendsto (fun x => f x * g x) l (\ud835\udcdd 0)", "start": [216, 1], "end": [220, 46], "kind": "commanddeclaration"}, {"full_name": "mulLeft_bound", "code": "theorem mulLeft_bound (x : \u03b1) : \u2200 y : \u03b1, \u2016AddMonoidHom.mulLeft x y\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016", "start": [223, 1], "end": [225, 16], "kind": "commanddeclaration"}, {"full_name": "mulRight_bound", "code": "theorem mulRight_bound (x : \u03b1) : \u2200 y : \u03b1, \u2016AddMonoidHom.mulRight x y\u2016 \u2264 \u2016x\u2016 * \u2016y\u2016", "start": [228, 1], "end": [231, 24], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalSeminormedRing", "code": "instance ULift.nonUnitalSeminormedRing : NonUnitalSeminormedRing (ULift \u03b1) :=\n  { ULift.seminormedAddCommGroup, ULift.nonUnitalRing with\n    norm_mul := fun x y => (norm_mul_le x.down y.down : _) }", "start": [234, 1], "end": [236, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.nonUnitalSeminormedRing", "code": "instance Prod.nonUnitalSeminormedRing [NonUnitalSeminormedRing \u03b2] :\n    NonUnitalSeminormedRing (\u03b1 \u00d7 \u03b2) :=\n  { seminormedAddCommGroup, instNonUnitalRing with\n    norm_mul := fun x y =>\n      calc\n        \u2016x * y\u2016 = \u2016(x.1 * y.1, x.2 * y.2)\u2016 := rfl\n        _ = max \u2016x.1 * y.1\u2016 \u2016x.2 * y.2\u2016 := rfl\n        _ \u2264 max (\u2016x.1\u2016 * \u2016y.1\u2016) (\u2016x.2\u2016 * \u2016y.2\u2016) :=\n          (max_le_max (norm_mul_le x.1 y.1) (norm_mul_le x.2 y.2))\n        _ = max (\u2016x.1\u2016 * \u2016y.1\u2016) (\u2016y.2\u2016 * \u2016x.2\u2016) := by simp [mul_comm]\n        _ \u2264 max \u2016x.1\u2016 \u2016x.2\u2016 * max \u2016y.2\u2016 \u2016y.1\u2016 := by\n          apply max_mul_mul_le_max_mul_max <;> simp [norm_nonneg]\n        _ = max \u2016x.1\u2016 \u2016x.2\u2016 * max \u2016y.1\u2016 \u2016y.2\u2016 := by simp [max_comm]\n        _ = \u2016x\u2016 * \u2016y\u2016 := rfl\n         }", "start": [238, 1], "end": [254, 11], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalSeminormedRing", "code": "instance Pi.nonUnitalSeminormedRing {\u03c0 : \u03b9 \u2192 Type*} [Fintype \u03b9]\n    [\u2200 i, NonUnitalSeminormedRing (\u03c0 i)] : NonUnitalSeminormedRing (\u2200 i, \u03c0 i) :=\n  { Pi.seminormedAddCommGroup, Pi.nonUnitalRing with\n    norm_mul := fun x y =>\n      NNReal.coe_mono <|\n        calc\n          (Finset.univ.sup fun i => \u2016x i * y i\u2016\u208a) \u2264\n              Finset.univ.sup ((fun i => \u2016x i\u2016\u208a) * fun i => \u2016y i\u2016\u208a) :=\n            Finset.sup_mono_fun fun _ _ => norm_mul_le _ _\n          _ \u2264 (Finset.univ.sup fun i => \u2016x i\u2016\u208a) * Finset.univ.sup fun i => \u2016y i\u2016\u208a :=\n            Finset.sup_mul_le_mul_sup_of_nonneg _ (fun _ _ => zero_le _) fun _ _ => zero_le _\n           }", "start": [257, 1], "end": [270, 13], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalSeminormedRing", "code": "instance MulOpposite.nonUnitalSeminormedRing : NonUnitalSeminormedRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.seminormedAddCommGroup, MulOpposite.nonUnitalRing \u03b1 with\n    norm_mul :=\n      MulOpposite.rec' fun x =>\n        MulOpposite.rec' fun y => (norm_mul_le y x).trans_eq (mul_comm _ _) }", "start": [273, 1], "end": [277, 78], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.seminormedRing", "code": "instance Subalgebra.seminormedRing {\ud835\udd5c : Type*} [CommRing \ud835\udd5c] {E : Type*} [SeminormedRing E]\n    [Algebra \ud835\udd5c E] (s : Subalgebra \ud835\udd5c E) : SeminormedRing s :=\n  { s.toSubmodule.seminormedAddCommGroup, s.toRing with\n    norm_mul := fun a b => norm_mul_le a.1 b.1 }", "start": [286, 1], "end": [292, 49], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.normedRing", "code": "instance Subalgebra.normedRing {\ud835\udd5c : Type*} [CommRing \ud835\udd5c] {E : Type*} [NormedRing E]\n    [Algebra \ud835\udd5c E] (s : Subalgebra \ud835\udd5c E) : NormedRing s :=\n  { s.seminormedRing with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero }", "start": [295, 1], "end": [301, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.norm_cast_le", "code": "theorem Nat.norm_cast_le : \u2200 n : \u2115, \u2016(n : \u03b1)\u2016 \u2264 n * \u2016(1 : \u03b1)\u2016", "start": [304, 1], "end": [308, 56], "kind": "commanddeclaration"}, {"full_name": "List.norm_prod_le'", "code": "theorem List.norm_prod_le' : \u2200 {l : List \u03b1}, l \u2260 [] \u2192 \u2016l.prod\u2016 \u2264 (l.map norm).prod", "start": [311, 1], "end": [317, 52], "kind": "commanddeclaration"}, {"full_name": "List.nnnorm_prod_le'", "code": "theorem List.nnnorm_prod_le' {l : List \u03b1} (hl : l \u2260 []) : \u2016l.prod\u2016\u208a \u2264 (l.map nnnorm).prod", "start": [320, 1], "end": [321, 83], "kind": "commanddeclaration"}, {"full_name": "List.norm_prod_le", "code": "theorem List.norm_prod_le [NormOneClass \u03b1] : \u2200 l : List \u03b1, \u2016l.prod\u2016 \u2264 (l.map norm).prod", "start": [324, 1], "end": [326, 54], "kind": "commanddeclaration"}, {"full_name": "List.nnnorm_prod_le", "code": "theorem List.nnnorm_prod_le [NormOneClass \u03b1] (l : List \u03b1) : \u2016l.prod\u2016\u208a \u2264 (l.map nnnorm).prod", "start": [329, 1], "end": [330, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.norm_prod_le'", "code": "theorem Finset.norm_prod_le' {\u03b1 : Type*} [NormedCommRing \u03b1] (s : Finset \u03b9) (hs : s.Nonempty)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i in s, f i\u2016 \u2264 \u220f i in s, \u2016f i\u2016", "start": [333, 1], "end": [337, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.nnnorm_prod_le'", "code": "theorem Finset.nnnorm_prod_le' {\u03b1 : Type*} [NormedCommRing \u03b1] (s : Finset \u03b9) (hs : s.Nonempty)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i in s, f i\u2016\u208a \u2264 \u220f i in s, \u2016f i\u2016\u208a", "start": [340, 1], "end": [342, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.norm_prod_le", "code": "theorem Finset.norm_prod_le {\u03b1 : Type*} [NormedCommRing \u03b1] [NormOneClass \u03b1] (s : Finset \u03b9)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i in s, f i\u2016 \u2264 \u220f i in s, \u2016f i\u2016", "start": [345, 1], "end": [348, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.nnnorm_prod_le", "code": "theorem Finset.nnnorm_prod_le {\u03b1 : Type*} [NormedCommRing \u03b1] [NormOneClass \u03b1] (s : Finset \u03b9)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i in s, f i\u2016\u208a \u2264 \u220f i in s, \u2016f i\u2016\u208a", "start": [351, 1], "end": [353, 59], "kind": "commanddeclaration"}, {"full_name": "nnnorm_pow_le'", "code": "theorem nnnorm_pow_le' (a : \u03b1) : \u2200 {n : \u2115}, 0 < n \u2192 \u2016a ^ n\u2016\u208a \u2264 \u2016a\u2016\u208a ^ n", "start": [356, 1], "end": [362, 86], "kind": "commanddeclaration"}, {"full_name": "nnnorm_pow_le", "code": "theorem nnnorm_pow_le [NormOneClass \u03b1] (a : \u03b1) (n : \u2115) : \u2016a ^ n\u2016\u208a \u2264 \u2016a\u2016\u208a ^ n", "start": [365, 1], "end": [369, 45], "kind": "commanddeclaration"}, {"full_name": "norm_pow_le'", "code": "theorem norm_pow_le' (a : \u03b1) {n : \u2115} (h : 0 < n) : \u2016a ^ n\u2016 \u2264 \u2016a\u2016 ^ n", "start": [372, 1], "end": [374, 85], "kind": "commanddeclaration"}, {"full_name": "norm_pow_le", "code": "theorem norm_pow_le [NormOneClass \u03b1] (a : \u03b1) (n : \u2115) : \u2016a ^ n\u2016 \u2264 \u2016a\u2016 ^ n", "start": [377, 1], "end": [380, 43], "kind": "commanddeclaration"}, {"full_name": "eventually_norm_pow_le", "code": "theorem eventually_norm_pow_le (a : \u03b1) : \u2200\u1da0 n : \u2115 in atTop, \u2016a ^ n\u2016 \u2264 \u2016a\u2016 ^ n", "start": [383, 1], "end": [384, 78], "kind": "commanddeclaration"}, {"full_name": "ULift.seminormedRing", "code": "instance ULift.seminormedRing : SeminormedRing (ULift \u03b1) :=\n  { ULift.nonUnitalSeminormedRing, ULift.ring with }", "start": [387, 1], "end": [388, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.seminormedRing", "code": "instance Prod.seminormedRing [SeminormedRing \u03b2] : SeminormedRing (\u03b1 \u00d7 \u03b2) :=\n  { nonUnitalSeminormedRing, instRing with }", "start": [390, 1], "end": [393, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.seminormedRing", "code": "instance Pi.seminormedRing {\u03c0 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, SeminormedRing (\u03c0 i)] :\n    SeminormedRing (\u2200 i, \u03c0 i) :=\n  { Pi.nonUnitalSeminormedRing, Pi.ring with }", "start": [396, 1], "end": [400, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.seminormedRing", "code": "instance MulOpposite.seminormedRing : SeminormedRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.nonUnitalSeminormedRing, MulOpposite.ring \u03b1 with }", "start": [403, 1], "end": [404, 67], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalNormedRing", "code": "instance ULift.nonUnitalNormedRing : NonUnitalNormedRing (ULift \u03b1) :=\n  { ULift.nonUnitalSeminormedRing, ULift.normedAddCommGroup with }", "start": [413, 1], "end": [414, 67], "kind": "commanddeclaration"}, {"full_name": "Prod.nonUnitalNormedRing", "code": "instance Prod.nonUnitalNormedRing [NonUnitalNormedRing \u03b2] : NonUnitalNormedRing (\u03b1 \u00d7 \u03b2) :=\n  { Prod.nonUnitalSeminormedRing, Prod.normedAddCommGroup with }", "start": [416, 1], "end": [419, 65], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalNormedRing", "code": "instance Pi.nonUnitalNormedRing {\u03c0 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, NonUnitalNormedRing (\u03c0 i)] :\n    NonUnitalNormedRing (\u2200 i, \u03c0 i) :=\n  { Pi.nonUnitalSeminormedRing, Pi.normedAddCommGroup with }", "start": [422, 1], "end": [426, 61], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalNormedRing", "code": "instance MulOpposite.nonUnitalNormedRing : NonUnitalNormedRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.nonUnitalSeminormedRing, MulOpposite.normedAddCommGroup with }", "start": [429, 1], "end": [430, 79], "kind": "commanddeclaration"}, {"full_name": "Units.norm_pos", "code": "theorem Units.norm_pos [Nontrivial \u03b1] (x : \u03b1\u02e3) : 0 < \u2016(x : \u03b1)\u2016", "start": [439, 1], "end": [440, 37], "kind": "commanddeclaration"}, {"full_name": "Units.nnnorm_pos", "code": "theorem Units.nnnorm_pos [Nontrivial \u03b1] (x : \u03b1\u02e3) : 0 < \u2016(x : \u03b1)\u2016\u208a", "start": [443, 1], "end": [444, 13], "kind": "commanddeclaration"}, {"full_name": "ULift.normedRing", "code": "instance ULift.normedRing : NormedRing (ULift \u03b1) :=\n  { ULift.seminormedRing, ULift.normedAddCommGroup with }", "start": [447, 1], "end": [448, 58], "kind": "commanddeclaration"}, {"full_name": "Prod.normedRing", "code": "instance Prod.normedRing [NormedRing \u03b2] : NormedRing (\u03b1 \u00d7 \u03b2) :=\n  { nonUnitalNormedRing, instRing with }", "start": [450, 1], "end": [452, 41], "kind": "commanddeclaration"}, {"full_name": "Pi.normedRing", "code": "instance Pi.normedRing {\u03c0 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, NormedRing (\u03c0 i)] :\n    NormedRing (\u2200 i, \u03c0 i) :=\n  { Pi.seminormedRing, Pi.normedAddCommGroup with }", "start": [455, 1], "end": [458, 52], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normedRing", "code": "instance MulOpposite.normedRing : NormedRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.seminormedRing, MulOpposite.normedAddCommGroup with }", "start": [461, 1], "end": [462, 70], "kind": "commanddeclaration"}, {"full_name": "semi_normed_ring_top_monoid", "code": "instance (priority := 100) semi_normed_ring_top_monoid [NonUnitalSeminormedRing \u03b1] :\n    ContinuousMul \u03b1 :=\n  \u27e8continuous_iff_continuousAt.2 fun x =>\n      tendsto_iff_norm_sub_tendsto_zero.2 <| by\n        have : \u2200 e : \u03b1 \u00d7 \u03b1,\n            \u2016e.1 * e.2 - x.1 * x.2\u2016 \u2264 \u2016e.1\u2016 * \u2016e.2 - x.2\u2016 + \u2016e.1 - x.1\u2016 * \u2016x.2\u2016 := by\n          intro e\n          calc\n            \u2016e.1 * e.2 - x.1 * x.2\u2016 \u2264 \u2016e.1 * (e.2 - x.2) + (e.1 - x.1) * x.2\u2016 := by\n              rw [_root_.mul_sub, _root_.sub_mul, sub_add_sub_cancel]\n            _ \u2264 \u2016e.1\u2016 * \u2016e.2 - x.2\u2016 + \u2016e.1 - x.1\u2016 * \u2016x.2\u2016 :=\n              norm_add_le_of_le (norm_mul_le _ _) (norm_mul_le _ _)\n        refine squeeze_zero (fun e => norm_nonneg _) this ?_\n        convert\n          ((continuous_fst.tendsto x).norm.mul\n                ((continuous_snd.tendsto x).sub tendsto_const_nhds).norm).add\n            (((continuous_fst.tendsto x).sub tendsto_const_nhds).norm.mul _)\n        rotate_right\n        show Tendsto _ _ _\n        exact tendsto_const_nhds\n        simp\u27e9", "start": [468, 1], "end": [490, 14], "kind": "commanddeclaration"}, {"full_name": "semi_normed_top_ring", "code": "instance (priority := 100) semi_normed_top_ring [NonUnitalSeminormedRing \u03b1] : TopologicalRing \u03b1\n    where", "start": [494, 1], "end": [496, 10], "kind": "commanddeclaration"}, {"full_name": "norm_mul", "code": "@[simp]\ntheorem norm_mul (a b : \u03b1) : \u2016a * b\u2016 = \u2016a\u2016 * \u2016b\u2016", "start": [503, 1], "end": [505, 35], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing.to_normOneClass", "code": "instance (priority := 900) NormedDivisionRing.to_normOneClass : NormOneClass \u03b1 :=\n  \u27e8mul_left_cancel\u2080 (mt norm_eq_zero.1 (one_ne_zero' \u03b1)) <| by rw [\u2190 norm_mul, mul_one, mul_one]\u27e9", "start": [508, 1], "end": [509, 98], "kind": "commanddeclaration"}, {"full_name": "isAbsoluteValue_norm", "code": "instance isAbsoluteValue_norm : IsAbsoluteValue (norm : \u03b1 \u2192 \u211d)\n    where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := norm_eq_zero\n  abv_add' := norm_add_le\n  abv_mul' := norm_mul", "start": [512, 1], "end": [517, 23], "kind": "commanddeclaration"}, {"full_name": "nnnorm_mul", "code": "@[simp]\ntheorem nnnorm_mul (a b : \u03b1) : \u2016a * b\u2016\u208a = \u2016a\u2016\u208a * \u2016b\u2016\u208a", "start": [520, 1], "end": [522, 28], "kind": "commanddeclaration"}, {"full_name": "normHom", "code": "@[simps]\ndef normHom : \u03b1 \u2192*\u2080 \u211d where\n  toFun := (\u2016\u00b7\u2016)\n  map_zero' := norm_zero\n  map_one' := norm_one\n  map_mul' := norm_mul", "start": [525, 1], "end": [531, 23], "kind": "commanddeclaration"}, {"full_name": "nnnormHom", "code": "@[simps]\ndef nnnormHom : \u03b1 \u2192*\u2080 \u211d\u22650 where\n  toFun := (\u2016\u00b7\u2016\u208a)\n  map_zero' := nnnorm_zero\n  map_one' := nnnorm_one\n  map_mul' := nnnorm_mul", "start": [534, 1], "end": [540, 25], "kind": "commanddeclaration"}, {"full_name": "norm_pow", "code": "@[simp]\ntheorem norm_pow (a : \u03b1) : \u2200 n : \u2115, \u2016a ^ n\u2016 = \u2016a\u2016 ^ n", "start": [543, 1], "end": [545, 43], "kind": "commanddeclaration"}, {"full_name": "nnnorm_pow", "code": "@[simp]\ntheorem nnnorm_pow (a : \u03b1) (n : \u2115) : \u2016a ^ n\u2016\u208a = \u2016a\u2016\u208a ^ n", "start": [548, 1], "end": [550, 49], "kind": "commanddeclaration"}, {"full_name": "List.norm_prod", "code": "protected theorem List.norm_prod (l : List \u03b1) : \u2016l.prod\u2016 = (l.map norm).prod", "start": [553, 1], "end": [554, 49], "kind": "commanddeclaration"}, {"full_name": "List.nnnorm_prod", "code": "protected theorem List.nnnorm_prod (l : List \u03b1) : \u2016l.prod\u2016\u208a = (l.map nnnorm).prod", "start": [557, 1], "end": [558, 53], "kind": "commanddeclaration"}, {"full_name": "norm_div", "code": "@[simp]\ntheorem norm_div (a b : \u03b1) : \u2016a / b\u2016 = \u2016a\u2016 / \u2016b\u2016", "start": [561, 1], "end": [563, 35], "kind": "commanddeclaration"}, {"full_name": "nnnorm_div", "code": "@[simp]\ntheorem nnnorm_div (a b : \u03b1) : \u2016a / b\u2016\u208a = \u2016a\u2016\u208a / \u2016b\u2016\u208a", "start": [566, 1], "end": [568, 39], "kind": "commanddeclaration"}, {"full_name": "norm_inv", "code": "@[simp]\ntheorem norm_inv (a : \u03b1) : \u2016a\u207b\u00b9\u2016 = \u2016a\u2016\u207b\u00b9", "start": [571, 1], "end": [573, 33], "kind": "commanddeclaration"}, {"full_name": "nnnorm_inv", "code": "@[simp]\ntheorem nnnorm_inv (a : \u03b1) : \u2016a\u207b\u00b9\u2016\u208a = \u2016a\u2016\u208a\u207b\u00b9", "start": [576, 1], "end": [578, 23], "kind": "commanddeclaration"}, {"full_name": "norm_zpow", "code": "@[simp]\ntheorem norm_zpow : \u2200 (a : \u03b1) (n : \u2124), \u2016a ^ n\u2016 = \u2016a\u2016 ^ n", "start": [581, 1], "end": [583, 32], "kind": "commanddeclaration"}, {"full_name": "nnnorm_zpow", "code": "@[simp]\ntheorem nnnorm_zpow : \u2200 (a : \u03b1) (n : \u2124), \u2016a ^ n\u2016\u208a = \u2016a\u2016\u208a ^ n", "start": [586, 1], "end": [588, 36], "kind": "commanddeclaration"}, {"full_name": "dist_inv_inv\u2080", "code": "theorem dist_inv_inv\u2080 {z w : \u03b1} (hz : z \u2260 0) (hw : w \u2260 0) :\n    dist z\u207b\u00b9 w\u207b\u00b9 = dist z w / (\u2016z\u2016 * \u2016w\u2016)", "start": [591, 1], "end": [594, 55], "kind": "commanddeclaration"}, {"full_name": "nndist_inv_inv\u2080", "code": "theorem nndist_inv_inv\u2080 {z w : \u03b1} (hz : z \u2260 0) (hw : w \u2260 0) :\n    nndist z\u207b\u00b9 w\u207b\u00b9 = nndist z w / (\u2016z\u2016\u208a * \u2016w\u2016\u208a)", "start": [597, 1], "end": [600, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_left_cobounded", "code": "theorem Filter.tendsto_mul_left_cobounded {a : \u03b1} (ha : a \u2260 0) :\n    Tendsto ((\u00b7 * \u00b7) a) (comap norm atTop) (comap norm atTop)", "start": [603, 1], "end": [608, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_right_cobounded", "code": "theorem Filter.tendsto_mul_right_cobounded {a : \u03b1} (ha : a \u2260 0) :\n    Tendsto (fun x => x * a) (comap norm atTop) (comap norm atTop)", "start": [611, 1], "end": [616, 67], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing.to_hasContinuousInv\u2080", "code": "instance (priority := 100) NormedDivisionRing.to_hasContinuousInv\u2080 : HasContinuousInv\u2080 \u03b1 := by\n  refine' \u27e8fun r r0 => tendsto_iff_norm_sub_tendsto_zero.2 _\u27e9\n  have r0' : 0 < \u2016r\u2016 := norm_pos_iff.2 r0\n  rcases exists_between r0' with \u27e8\u03b5, \u03b50, \u03b5r\u27e9\n  have : \u2200\u1da0 e in \ud835\udcdd r, \u2016e\u207b\u00b9 - r\u207b\u00b9\u2016 \u2264 \u2016r - e\u2016 / \u2016r\u2016 / \u03b5 := by\n    filter_upwards [(isOpen_lt continuous_const continuous_norm).eventually_mem \u03b5r] with e he\n    have e0 : e \u2260 0 := norm_pos_iff.1 (\u03b50.trans he)\n    calc\n      \u2016e\u207b\u00b9 - r\u207b\u00b9\u2016 = \u2016r\u2016\u207b\u00b9 * \u2016r - e\u2016 * \u2016e\u2016\u207b\u00b9 := by\n        rw [\u2190 norm_inv, \u2190 norm_inv, \u2190 norm_mul, \u2190 norm_mul, _root_.mul_sub, _root_.sub_mul,\n          mul_assoc _ e, inv_mul_cancel r0, mul_inv_cancel e0, one_mul, mul_one]\n      _ = \u2016r - e\u2016 / \u2016r\u2016 / \u2016e\u2016 := by field_simp [mul_comm]\n      _ \u2264 \u2016r - e\u2016 / \u2016r\u2016 / \u03b5 := by gcongr\n  refine' squeeze_zero' (eventually_of_forall fun _ => norm_nonneg _) this _\n  refine' (((continuous_const.sub continuous_id).norm.div_const _).div_const _).tendsto' _ _ _\n  simp", "start": [620, 1], "end": [636, 7], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing.to_topologicalDivisionRing", "code": "instance (priority := 100) NormedDivisionRing.to_topologicalDivisionRing : TopologicalDivisionRing \u03b1\n    where", "start": [640, 1], "end": [642, 10], "kind": "commanddeclaration"}, {"full_name": "norm_map_one_of_pow_eq_one", "code": "theorem norm_map_one_of_pow_eq_one [Monoid \u03b2] (\u03c6 : \u03b2 \u2192* \u03b1) {x : \u03b2} {k : \u2115+} (h : x ^ (k : \u2115) = 1) :\n    \u2016\u03c6 x\u2016 = 1", "start": [645, 1], "end": [648, 45], "kind": "commanddeclaration"}, {"full_name": "norm_one_of_pow_eq_one", "code": "theorem norm_one_of_pow_eq_one {x : \u03b1} {k : \u2115+} (h : x ^ (k : \u2115) = 1) : \u2016x\u2016 = 1", "start": [651, 1], "end": [652, 48], "kind": "commanddeclaration"}, {"full_name": "NormedField", "code": "class NormedField (\u03b1 : Type*) extends Norm \u03b1, Field \u03b1, MetricSpace \u03b1 where\n  \n  dist_eq : \u2200 x y, dist x y = norm (x - y)\n  \n  norm_mul' : \u2200 a b, norm (a * b) = norm a * norm b", "start": [657, 1], "end": [662, 52], "kind": "commanddeclaration"}, {"full_name": "NontriviallyNormedField", "code": "class NontriviallyNormedField (\u03b1 : Type*) extends NormedField \u03b1 where\n  \n  non_trivial : \u2203 x : \u03b1, 1 < \u2016x\u2016", "start": [665, 1], "end": [670, 33], "kind": "commanddeclaration"}, {"full_name": "DenselyNormedField", "code": "class DenselyNormedField (\u03b1 : Type*) extends NormedField \u03b1 where\n  \n  lt_norm_lt : \u2200 x y : \u211d, 0 \u2264 x \u2192 x < y \u2192 \u2203 a : \u03b1, x < \u2016a\u2016 \u2227 \u2016a\u2016 < y", "start": [673, 1], "end": [678, 69], "kind": "commanddeclaration"}, {"full_name": "DenselyNormedField.toNontriviallyNormedField", "code": "instance (priority := 100) DenselyNormedField.toNontriviallyNormedField [DenselyNormedField \u03b1] :\n    NontriviallyNormedField \u03b1 where\n  non_trivial :=\n    let \u27e8a, h, _\u27e9 := DenselyNormedField.lt_norm_lt 1 2 zero_le_one one_lt_two\n    \u27e8a, h\u27e9", "start": [683, 1], "end": [689, 11], "kind": "commanddeclaration"}, {"full_name": "NormedField.toNormedDivisionRing", "code": "instance (priority := 100) NormedField.toNormedDivisionRing : NormedDivisionRing \u03b1 :=\n  { \u2039NormedField \u03b1\u203a with }", "start": [695, 1], "end": [696, 27], "kind": "commanddeclaration"}, {"full_name": "NormedField.toNormedCommRing", "code": "instance (priority := 100) NormedField.toNormedCommRing : NormedCommRing \u03b1 :=\n  { \u2039NormedField \u03b1\u203a with norm_mul := fun a b => (norm_mul a b).le }", "start": [700, 1], "end": [701, 68], "kind": "commanddeclaration"}, {"full_name": "norm_prod", "code": "@[simp]\ntheorem norm_prod (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2016\u220f b in s, f b\u2016 = \u220f b in s, \u2016f b\u2016", "start": [704, 1], "end": [706, 46], "kind": "commanddeclaration"}, {"full_name": "nnnorm_prod", "code": "@[simp]\ntheorem nnnorm_prod (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2016\u220f b in s, f b\u2016\u208a = \u220f b in s, \u2016f b\u2016\u208a", "start": [709, 1], "end": [711, 50], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_one_lt_norm", "code": "theorem exists_one_lt_norm : \u2203 x : \u03b1, 1 < \u2016x\u2016", "start": [722, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_lt_norm", "code": "theorem exists_lt_norm (r : \u211d) : \u2203 x : \u03b1, r < \u2016x\u2016", "start": [726, 1], "end": [729, 29], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_norm_lt", "code": "theorem exists_norm_lt {r : \u211d} (hr : 0 < r) : \u2203 x : \u03b1, 0 < \u2016x\u2016 \u2227 \u2016x\u2016 < r", "start": [732, 1], "end": [734, 80], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_norm_lt_one", "code": "theorem exists_norm_lt_one : \u2203 x : \u03b1, 0 < \u2016x\u2016 \u2227 \u2016x\u2016 < 1", "start": [737, 1], "end": [738, 27], "kind": "commanddeclaration"}, {"full_name": "NormedField.punctured_nhds_neBot", "code": "@[instance]\ntheorem punctured_nhds_neBot (x : \u03b1) : NeBot (\ud835\udcdd[\u2260] x)", "start": [743, 1], "end": [749, 49], "kind": "commanddeclaration"}, {"full_name": "NormedField.nhdsWithin_isUnit_neBot", "code": "@[instance]\ntheorem nhdsWithin_isUnit_neBot : NeBot (\ud835\udcdd[{ x : \u03b1 | IsUnit x }] 0)", "start": [752, 1], "end": [754, 69], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_lt_norm_lt", "code": "theorem exists_lt_norm_lt {r\u2081 r\u2082 : \u211d} (h\u2080 : 0 \u2264 r\u2081) (h : r\u2081 < r\u2082) : \u2203 x : \u03b1, r\u2081 < \u2016x\u2016 \u2227 \u2016x\u2016 < r\u2082", "start": [763, 1], "end": [764, 43], "kind": "commanddeclaration"}, {"full_name": "NormedField.exists_lt_nnnorm_lt", "code": "theorem exists_lt_nnnorm_lt {r\u2081 r\u2082 : \u211d\u22650} (h : r\u2081 < r\u2082) : \u2203 x : \u03b1, r\u2081 < \u2016x\u2016\u208a \u2227 \u2016x\u2016\u208a < r\u2082", "start": [767, 1], "end": [768, 47], "kind": "commanddeclaration"}, {"full_name": "NormedField.denselyOrdered_range_norm", "code": "instance denselyOrdered_range_norm : DenselyOrdered (Set.range (norm : \u03b1 \u2192 \u211d)) where\n  dense := by\n    rintro \u27e8-, x, rfl\u27e9 \u27e8-, y, rfl\u27e9 hxy\n    let \u27e8z, h\u27e9 := exists_lt_norm_lt \u03b1 (norm_nonneg _) hxy\n    exact \u27e8\u27e8\u2016z\u2016, z, rfl\u27e9, h\u27e9", "start": [771, 1], "end": [775, 29], "kind": "commanddeclaration"}, {"full_name": "NormedField.denselyOrdered_range_nnnorm", "code": "instance denselyOrdered_range_nnnorm : DenselyOrdered (Set.range (nnnorm : \u03b1 \u2192 \u211d\u22650)) where\n  dense := by\n    rintro \u27e8-, x, rfl\u27e9 \u27e8-, y, rfl\u27e9 hxy\n    let \u27e8z, h\u27e9 := exists_lt_nnnorm_lt \u03b1 hxy\n    exact \u27e8\u27e8\u2016z\u2016\u208a, z, rfl\u27e9, h\u27e9", "start": [778, 1], "end": [782, 30], "kind": "commanddeclaration"}, {"full_name": "NormedField.denseRange_nnnorm", "code": "theorem denseRange_nnnorm : DenseRange (nnnorm : \u03b1 \u2192 \u211d\u22650)", "start": [785, 1], "end": [788, 24], "kind": "commanddeclaration"}, {"full_name": "Real.normedCommRing", "code": "instance Real.normedCommRing : NormedCommRing \u211d :=\n  { Real.normedAddCommGroup, Real.commRing with norm_mul := fun x y => (abs_mul x y).le }", "start": [795, 1], "end": [796, 90], "kind": "commanddeclaration"}, {"full_name": "Real.normedField", "code": "noncomputable instance Real.normedField : NormedField \u211d :=\n  { Real.normedAddCommGroup, Real.field with\n    norm_mul' := abs_mul }", "start": [798, 1], "end": [800, 27], "kind": "commanddeclaration"}, {"full_name": "Real.denselyNormedField", "code": "noncomputable instance Real.denselyNormedField : DenselyNormedField \u211d where\n  lt_norm_lt _ _ h\u2080 hr :=\n    let \u27e8x, h\u27e9 := exists_between hr\n    \u27e8x, by rwa [Real.norm_eq_abs, abs_of_nonneg (h\u2080.trans h.1.le)]\u27e9", "start": [802, 1], "end": [805, 68], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_mul_nnnorm", "code": "theorem toNNReal_mul_nnnorm {x : \u211d} (y : \u211d) (hx : 0 \u2264 x) : x.toNNReal * \u2016y\u2016\u208a = \u2016x * y\u2016\u208a", "start": [809, 1], "end": [812, 12], "kind": "commanddeclaration"}, {"full_name": "Real.nnnorm_mul_toNNReal", "code": "theorem nnnorm_mul_toNNReal (x : \u211d) {y : \u211d} (hy : 0 \u2264 y) : \u2016x\u2016\u208a * y.toNNReal = \u2016x * y\u2016\u208a", "start": [815, 1], "end": [816, 54], "kind": "commanddeclaration"}, {"full_name": "NNReal.norm_eq", "code": "theorem norm_eq (x : \u211d\u22650) : \u2016(x : \u211d)\u2016 = x", "start": [826, 1], "end": [826, 80], "kind": "commanddeclaration"}, {"full_name": "NNReal.nnnorm_eq", "code": "@[simp]\ntheorem nnnorm_eq (x : \u211d\u22650) : \u2016(x : \u211d)\u2016\u208a = x", "start": [829, 1], "end": [831, 39], "kind": "commanddeclaration"}, {"full_name": "norm_norm", "code": "@[simp 1001] theorem norm_norm [SeminormedAddCommGroup \u03b1] (x : \u03b1) : \u2016\u2016x\u2016\u2016 = \u2016x\u2016", "start": [836, 1], "end": [838, 38], "kind": "commanddeclaration"}, {"full_name": "nnnorm_norm", "code": "@[simp]\ntheorem nnnorm_norm [SeminormedAddCommGroup \u03b1] (a : \u03b1) : \u2016\u2016a\u2016\u2016\u208a = \u2016a\u2016\u208a", "start": [841, 1], "end": [843, 50], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.tendsto_atTop", "code": "theorem NormedAddCommGroup.tendsto_atTop [Nonempty \u03b1] [SemilatticeSup \u03b1] {\u03b2 : Type*}\n    [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2} {b : \u03b2} :\n    Tendsto f atTop (\ud835\udcdd b) \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 N, \u2200 n, N \u2264 n \u2192 \u2016f n - b\u2016 < \u03b5", "start": [846, 1], "end": [850, 82], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.tendsto_atTop'", "code": "theorem NormedAddCommGroup.tendsto_atTop' [Nonempty \u03b1] [SemilatticeSup \u03b1] [NoMaxOrder \u03b1]\n    {\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2} {b : \u03b2} :\n    Tendsto f atTop (\ud835\udcdd b) \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 N, \u2200 n, N < n \u2192 \u2016f n - b\u2016 < \u03b5", "start": [853, 1], "end": [859, 86], "kind": "commanddeclaration"}, {"full_name": "Int.normedCommRing", "code": "instance Int.normedCommRing : NormedCommRing \u2124 :=\n  { Int.normedAddCommGroup, Int.instRingInt with\n    norm_mul := fun m n => le_of_eq <| by simp only [norm, Int.cast_mul, abs_mul]\n    mul_comm := mul_comm }", "start": [862, 1], "end": [865, 27], "kind": "commanddeclaration"}, {"full_name": "Int.normOneClass", "code": "instance Int.normOneClass : NormOneClass \u2124 :=\n  \u27e8by simp [\u2190 Int.norm_cast_real]\u27e9", "start": [867, 1], "end": [868, 35], "kind": "commanddeclaration"}, {"full_name": "Rat.normedField", "code": "instance Rat.normedField : NormedField \u211a :=\n  { Rat.normedAddCommGroup, Rat.field with\n    norm_mul' := fun r\u2081 r\u2082 => by simp only [norm, Rat.cast_mul, abs_mul] }", "start": [870, 1], "end": [872, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.denselyNormedField", "code": "instance Rat.denselyNormedField : DenselyNormedField \u211a where\n  lt_norm_lt r\u2081 r\u2082 h\u2080 hr :=\n    let \u27e8q, h\u27e9 := exists_rat_btwn hr\n    \u27e8q, by rwa [\u2190Rat.norm_cast_real, Real.norm_eq_abs, abs_of_pos (h\u2080.trans_lt h.1)]\u27e9", "start": [874, 1], "end": [877, 86], "kind": "commanddeclaration"}, {"full_name": "RingHomIsometric", "code": "class RingHomIsometric [Semiring R\u2081] [Semiring R\u2082] [Norm R\u2081] [Norm R\u2082] (\u03c3 : R\u2081 \u2192+* R\u2082) : Prop where\n  \n  is_iso : \u2200 {x : R\u2081}, \u2016\u03c3 x\u2016 = \u2016x\u2016", "start": [882, 1], "end": [886, 35], "kind": "commanddeclaration"}, {"full_name": "RingHomIsometric.ids", "code": "instance RingHomIsometric.ids : RingHomIsometric (RingHom.id R\u2081) :=\n  \u27e8rfl\u27e9", "start": [893, 1], "end": [894, 8], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSeminormedRing.induced", "code": "@[reducible]\ndef NonUnitalSeminormedRing.induced [NonUnitalRing R] [NonUnitalSeminormedRing S]\n    [NonUnitalRingHomClass F R S] (f : F) : NonUnitalSeminormedRing R :=\n  { SeminormedAddCommGroup.induced R S f, \u2039NonUnitalRing R\u203a with\n    norm_mul := fun x y => by\n      show \u2016f (x * y)\u2016 \u2264 \u2016f x\u2016 * \u2016f y\u2016\n      exact (map_mul f x y).symm \u25b8 norm_mul_le (f x) (f y) }", "start": [906, 1], "end": [916, 61], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNormedRing.induced", "code": "@[reducible]\ndef NonUnitalNormedRing.induced [NonUnitalRing R] [NonUnitalNormedRing S]\n    [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Injective f) : NonUnitalNormedRing R :=\n  { NonUnitalSeminormedRing.induced R S f, NormedAddCommGroup.induced R S f hf with }", "start": [919, 1], "end": [926, 86], "kind": "commanddeclaration"}, {"full_name": "SeminormedRing.induced", "code": "@[reducible]\ndef SeminormedRing.induced [Ring R] [SeminormedRing S] [NonUnitalRingHomClass F R S] (f : F) :\n    SeminormedRing R :=\n  { NonUnitalSeminormedRing.induced R S f, SeminormedAddCommGroup.induced R S f, \u2039Ring R\u203a with }", "start": [929, 1], "end": [936, 97], "kind": "commanddeclaration"}, {"full_name": "NormedRing.induced", "code": "@[reducible]\ndef NormedRing.induced [Ring R] [NormedRing S] [NonUnitalRingHomClass F R S] (f : F)\n    (hf : Function.Injective f) : NormedRing R :=\n  { NonUnitalSeminormedRing.induced R S f, NormedAddCommGroup.induced R S f hf, \u2039Ring R\u203a with }", "start": [939, 1], "end": [946, 96], "kind": "commanddeclaration"}, {"full_name": "SeminormedCommRing.induced", "code": "@[reducible]\ndef SeminormedCommRing.induced [CommRing R] [SeminormedRing S] [NonUnitalRingHomClass F R S]\n    (f : F) : SeminormedCommRing R :=\n  { NonUnitalSeminormedRing.induced R S f, SeminormedAddCommGroup.induced R S f, \u2039CommRing R\u203a with }", "start": [949, 1], "end": [956, 101], "kind": "commanddeclaration"}, {"full_name": "NormedCommRing.induced", "code": "@[reducible]\ndef NormedCommRing.induced [CommRing R] [NormedRing S] [NonUnitalRingHomClass F R S] (f : F)\n    (hf : Function.Injective f) : NormedCommRing R :=\n  { SeminormedCommRing.induced R S f, NormedAddCommGroup.induced R S f hf with }", "start": [959, 1], "end": [966, 81], "kind": "commanddeclaration"}, {"full_name": "NormedDivisionRing.induced", "code": "@[reducible]\ndef NormedDivisionRing.induced [DivisionRing R] [NormedDivisionRing S] [NonUnitalRingHomClass F R S]\n    (f : F) (hf : Function.Injective f) : NormedDivisionRing R :=\n  { NormedAddCommGroup.induced R S f hf, \u2039DivisionRing R\u203a with\n    norm_mul' := fun x y => by\n      show \u2016f (x * y)\u2016 = \u2016f x\u2016 * \u2016f y\u2016\n      exact (map_mul f x y).symm \u25b8 norm_mul (f x) (f y) }", "start": [969, 1], "end": [979, 58], "kind": "commanddeclaration"}, {"full_name": "NormedField.induced", "code": "@[reducible]\ndef NormedField.induced [Field R] [NormedField S] [NonUnitalRingHomClass F R S] (f : F)\n    (hf : Function.Injective f) : NormedField R :=\n  { NormedDivisionRing.induced R S f hf with\n    mul_comm := mul_comm }", "start": [982, 1], "end": [990, 27], "kind": "commanddeclaration"}, {"full_name": "NormOneClass.induced", "code": "theorem NormOneClass.induced {F : Type*} (R S : Type*) [Ring R] [SeminormedRing S]\n    [NormOneClass S] [RingHomClass F R S] (f : F) :\n    @NormOneClass R (SeminormedRing.induced R S f).toNorm _", "start": [993, 1], "end": [1000, 62], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toSeminormedRing", "code": "instance toSeminormedRing [SeminormedRing R] [SubringClass S R] (s : S) : SeminormedRing s :=\n  SeminormedRing.induced s R (SubringClass.subtype s)", "start": [1009, 1], "end": [1010, 54], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toNormedRing", "code": "instance toNormedRing [NormedRing R] [SubringClass S R] (s : S) : NormedRing s :=\n  NormedRing.induced s R (SubringClass.subtype s) Subtype.val_injective", "start": [1013, 1], "end": [1014, 72], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toSeminormedCommRing", "code": "instance toSeminormedCommRing [SeminormedCommRing R] [_h : SubringClass S R] (s : S) :\n    SeminormedCommRing s :=\n  { SubringClass.toSeminormedRing s with mul_comm := mul_comm }", "start": [1017, 1], "end": [1019, 64], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toNormedCommRing", "code": "instance toNormedCommRing [NormedCommRing R] [SubringClass S R] (s : S) : NormedCommRing s :=\n  { SubringClass.toNormedRing s with mul_comm := mul_comm }", "start": [1022, 1], "end": [1023, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Center.lean", "imports": ["Mathlib/GroupTheory/Subsemigroup/Center.lean", "Mathlib/Algebra/Star/Pointwise.lean", "Mathlib/Algebra/Star/Basic.lean", "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.star_mem_center", "code": "theorem Set.star_mem_center (ha : a \u2208 Set.center R) : star a \u2208 Set.center R", "start": [15, 1], "end": [17, 65], "kind": "commanddeclaration"}, {"full_name": "Set.star_mem_centralizer'", "code": "theorem Set.star_mem_centralizer' (h : \u2200 a : R, a \u2208 s \u2192 star a \u2208 s) (ha : a \u2208 Set.centralizer s) :\n    star a \u2208 Set.centralizer s", "start": [19, 1], "end": [20, 97], "kind": "commanddeclaration"}, {"full_name": "Set.star_mem_centralizer", "code": "theorem Set.star_mem_centralizer (ha : a \u2208 Set.centralizer (s \u222a star s)) :\n    star a \u2208 Set.centralizer (s \u222a star s)", "start": [24, 1], "end": [27, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/StarAlgHom.lean", "imports": ["Mathlib/Algebra/Hom/NonUnitalAlg.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Prod.lean", "Mathlib/Algebra/Star/Prod.lean", "Mathlib/Algebra/Algebra/Equiv.lean"], "premises": [{"full_name": "NonUnitalStarAlgHom", "code": "structure NonUnitalStarAlgHom (R A B : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n  [DistribMulAction R A] [Star A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n  [Star B] extends A \u2192\u2099\u2090[R] B where\n  \n  map_star' : \u2200 a : A, toFun (star a) = star (toFun a)", "start": [49, 1], "end": [56, 55], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHomClass", "code": "class NonUnitalStarAlgHomClass (F : Type*) (R : outParam (Type*)) (A : outParam (Type*))\n  (B : outParam (Type*)) [Monoid R] [Star A] [Star B] [NonUnitalNonAssocSemiring A]\n  [NonUnitalNonAssocSemiring B] [DistribMulAction R A] [DistribMulAction R B] extends\n  NonUnitalAlgHomClass F R A B, StarHomClass F A B", "start": [67, 1], "end": [72, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHomClass.toNonUnitalStarAlgHom", "code": "@[coe]\ndef toNonUnitalStarAlgHom [NonUnitalStarAlgHomClass F R A B] (f : F) : A \u2192\u22c6\u2099\u2090[R] B :=\n  { (f : A \u2192\u2099\u2090[R] B) with\n    map_star' := map_star f }", "start": [87, 1], "end": [92, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.Simps.apply", "code": "def Simps.apply (f : A \u2192\u22c6\u2099\u2090[R] B) : A \u2192 B := f", "start": [130, 1], "end": [131, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_coe", "code": "@[simp]\nprotected theorem coe_coe {F : Type*} [NonUnitalStarAlgHomClass F R A B] (f : F) :\n    \u21d1(f : A \u2192\u22c6\u2099\u2090[R] B) = f", "start": [136, 1], "end": [138, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_toNonUnitalAlgHom", "code": "@[simp]\ntheorem coe_toNonUnitalAlgHom {f : A \u2192\u22c6\u2099\u2090[R] B} : (f.toNonUnitalAlgHom : A \u2192 B) = f", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.ext", "code": "@[ext]\ntheorem ext {f g : A \u2192\u22c6\u2099\u2090[R] B} (h : \u2200 x, f x = g x) : f = g", "start": [146, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.copy", "code": "protected def copy (f : A \u2192\u22c6\u2099\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : A \u2192\u22c6\u2099\u2090[R] B\n    where\n  toFun := f'\n  map_smul' := h.symm \u25b8 map_smul f\n  map_zero' := h.symm \u25b8 map_zero f\n  map_add' := h.symm \u25b8 map_add f\n  map_mul' := h.symm \u25b8 map_mul f\n  map_star' := h.symm \u25b8 map_star f", "start": [151, 1], "end": [160, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : A \u2192\u22c6\u2099\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.copy_eq", "code": "theorem copy_eq (f : A \u2192\u22c6\u2099\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : f.copy f' h = f", "start": [168, 1], "end": [169, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : A \u2192 B) (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) :\n    ((\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9, h\u2085\u27e9 : A \u2192\u22c6\u2099\u2090[R] B) : A \u2192 B) = f", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : A \u2192\u2099\u2090[R] B) (h) :\n    ((\u27e8f, h\u27e9 : A \u2192\u22c6\u2099\u2090[R] B) : A \u2192 B) = f", "start": [180, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : A \u2192\u22c6\u2099\u2090[R] B) (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) :\n    (\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9, h\u2085\u27e9 : A \u2192\u22c6\u2099\u2090[R] B) = f", "start": [186, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.id", "code": "protected def id : A \u2192\u22c6\u2099\u2090[R] A :=\n  { (1 : A \u2192\u2099\u2090[R] A) with map_star' := fun _ => rfl }", "start": [197, 1], "end": [199, 54], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(NonUnitalStarAlgHom.id R A) = id", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.comp", "code": "def comp (f : B \u2192\u22c6\u2099\u2090[R] C) (g : A \u2192\u22c6\u2099\u2090[R] B) : A \u2192\u22c6\u2099\u2090[R] C :=\n  { f.toNonUnitalAlgHom.comp g.toNonUnitalAlgHom with\n    map_star' := by\n      simp only [map_star, NonUnitalAlgHom.toFun_eq_coe, eq_self_iff_true, NonUnitalAlgHom.coe_comp,\n        coe_toNonUnitalAlgHom, Function.comp_apply, forall_const] }", "start": [209, 1], "end": [215, 68], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : B \u2192\u22c6\u2099\u2090[R] C) (g : A \u2192\u22c6\u2099\u2090[R] B) : \u21d1(comp f g) = f \u2218 g", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : B \u2192\u22c6\u2099\u2090[R] C) (g : A \u2192\u22c6\u2099\u2090[R] B) (a : A) : comp f g a = f (g a)", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : C \u2192\u22c6\u2099\u2090[R] D) (g : B \u2192\u22c6\u2099\u2090[R] C) (h : A \u2192\u22c6\u2099\u2090[R] B) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [228, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : A \u2192\u22c6\u2099\u2090[R] B) : (NonUnitalStarAlgHom.id _ _).comp f = f", "start": [234, 1], "end": [236, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : A \u2192\u22c6\u2099\u2090[R] B) : f.comp (NonUnitalStarAlgHom.id _ _) = f", "start": [239, 1], "end": [241, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : A \u2192\u22c6\u2099\u2090[R] A) : A \u2192 A) = id", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.one_apply", "code": "theorem one_apply (a : A) : (1 : A \u2192\u22c6\u2099\u2090[R] A) a = a", "start": [256, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_zero", "code": "@[simp]\ntheorem coe_zero : ((0 : A \u2192\u22c6\u2099\u2090[R] B) : A \u2192 B) = 0", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.zero_apply", "code": "theorem zero_apply (a : A) : (0 : A \u2192\u22c6\u2099\u2090[R] B) a = 0", "start": [288, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom", "code": "structure StarAlgHom (R A B : Type*) [CommSemiring R] [Semiring A] [Algebra R A] [Star A]\n  [Semiring B] [Algebra R B] [Star B] extends AlgHom R A B where\n  \n  map_star' : \u2200 x : A, toFun (star x) = star (toFun x)", "start": [301, 1], "end": [306, 55], "kind": "commanddeclaration"}, {"full_name": "StarAlgHomClass", "code": "class StarAlgHomClass (F : Type*) (R : outParam (Type*)) (A : outParam (Type*))\n  (B : outParam (Type*)) [CommSemiring R] [Semiring A] [Algebra R A] [Star A] [Semiring B]\n  [Algebra R B] [Star B] extends AlgHomClass F R A B, StarHomClass F A B", "start": [317, 1], "end": [322, 73], "kind": "commanddeclaration"}, {"full_name": "StarAlgHomClass.toNonUnitalStarAlgHomClass", "code": "instance (priority := 100) toNonUnitalStarAlgHomClass [CommSemiring R] [Semiring A]\n  [Algebra R A] [Star A] [Semiring B] [Algebra R B] [Star B]\n  [StarAlgHomClass F R A B] :\n  NonUnitalStarAlgHomClass F R A B :=\n  { StarAlgHomClass.toAlgHomClass, StarAlgHomClass.toStarHomClass R with\n    map_smul := map_smul }", "start": [334, 1], "end": [339, 27], "kind": "commanddeclaration"}, {"full_name": "StarAlgHomClass.toStarAlgHom", "code": "@[coe]\ndef toStarAlgHom (f : F) : A \u2192\u22c6\u2090[R] B :=\n  { (f : A \u2192\u2090[R] B) with\n    map_star' := map_star f }", "start": [347, 1], "end": [352, 30], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_coe", "code": "@[simp]\nprotected theorem coe_coe {F : Type*} [StarAlgHomClass F R A B] (f : F) : \u21d1(f : A \u2192\u22c6\u2090[R] B) = f", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.Simps.apply", "code": "def Simps.apply (f : A \u2192\u22c6\u2090[R] B) : A \u2192 B := f", "start": [381, 1], "end": [382, 46], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_toAlgHom", "code": "@[simp]\ntheorem coe_toAlgHom {f : A \u2192\u22c6\u2090[R] B} : (f.toAlgHom : A \u2192 B) = f", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.ext", "code": "@[ext]\ntheorem ext {f g : A \u2192\u22c6\u2090[R] B} (h : \u2200 x, f x = g x) : f = g", "start": [391, 1], "end": [393, 20], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.copy", "code": "protected def copy (f : A \u2192\u22c6\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : A \u2192\u22c6\u2090[R] B\n    where\n  toFun := f'\n  map_one' := h.symm \u25b8 map_one f\n  map_mul' := h.symm \u25b8 map_mul f\n  map_zero' := h.symm \u25b8 map_zero f\n  map_add' := h.symm \u25b8 map_add f\n  commutes' := h.symm \u25b8 AlgHomClass.commutes f\n  map_star' := h.symm \u25b8 map_star f", "start": [396, 1], "end": [406, 35], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : A \u2192\u22c6\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.copy_eq", "code": "theorem copy_eq (f : A \u2192\u22c6\u2090[R] B) (f' : A \u2192 B) (h : f' = f) : f.copy f' h = f", "start": [414, 1], "end": [415, 17], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : A \u2192 B) (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085 h\u2086) :\n    ((\u27e8\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085\u27e9, h\u2086\u27e9 : A \u2192\u22c6\u2090[R] B) : A \u2192 B) = f", "start": [419, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : A \u2192\u2090[R] B) (h) :\n    ((\u27e8f, h\u27e9 : A \u2192\u22c6\u2090[R] B) : A \u2192 B) = f", "start": [426, 1], "end": [429, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : A \u2192\u22c6\u2090[R] B) (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085 h\u2086) :\n    (\u27e8\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085\u27e9, h\u2086\u27e9 : A \u2192\u22c6\u2090[R] B) = f", "start": [432, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.id", "code": "protected def id : A \u2192\u22c6\u2090[R] A :=\n  { AlgHom.id _ _ with map_star' := fun _ => rfl }", "start": [443, 1], "end": [445, 51], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(StarAlgHom.id R A) = id", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.comp", "code": "def comp (f : B \u2192\u22c6\u2090[R] C) (g : A \u2192\u22c6\u2090[R] B) : A \u2192\u22c6\u2090[R] C :=\n  { f.toAlgHom.comp g.toAlgHom with\n    map_star' := by\n      simp only [map_star, AlgHom.toFun_eq_coe, AlgHom.coe_comp, coe_toAlgHom,\n        Function.comp_apply, eq_self_iff_true, forall_const] }", "start": [458, 1], "end": [463, 63], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : B \u2192\u22c6\u2090[R] C) (g : A \u2192\u22c6\u2090[R] B) : \u21d1(comp f g) = f \u2218 g", "start": [466, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : B \u2192\u22c6\u2090[R] C) (g : A \u2192\u22c6\u2090[R] B) (a : A) : comp f g a = f (g a)", "start": [471, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : C \u2192\u22c6\u2090[R] D) (g : B \u2192\u22c6\u2090[R] C) (h : A \u2192\u22c6\u2090[R] B) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [476, 1], "end": [479, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : A \u2192\u22c6\u2090[R] B) : (StarAlgHom.id _ _).comp f = f", "start": [482, 1], "end": [484, 19], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : A \u2192\u22c6\u2090[R] B) : f.comp (StarAlgHom.id _ _) = f", "start": [487, 1], "end": [489, 19], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.toNonUnitalStarAlgHom", "code": "def toNonUnitalStarAlgHom (f : A \u2192\u22c6\u2090[R] B) : A \u2192\u22c6\u2099\u2090[R] B :=\n  { f with map_smul' := map_smul f }", "start": [499, 1], "end": [501, 37], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_toNonUnitalStarAlgHom", "code": "@[simp]\ntheorem coe_toNonUnitalStarAlgHom (f : A \u2192\u22c6\u2090[R] B) : (f.toNonUnitalStarAlgHom : A \u2192 B) = f", "start": [504, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.fst", "code": "@[simps!]\ndef fst : A \u00d7 B \u2192\u22c6\u2099\u2090[R] A :=\n  { NonUnitalAlgHom.fst R A B with map_star' := fun _ => rfl }", "start": [526, 1], "end": [529, 63], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.snd", "code": "@[simps!]\ndef snd : A \u00d7 B \u2192\u22c6\u2099\u2090[R] B :=\n  { NonUnitalAlgHom.snd R A B with map_star' := fun _ => rfl }", "start": [532, 1], "end": [535, 63], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.prod", "code": "@[simps!]\ndef prod (f : A \u2192\u22c6\u2099\u2090[R] B) (g : A \u2192\u22c6\u2099\u2090[R] C) : A \u2192\u22c6\u2099\u2090[R] B \u00d7 C :=\n  { f.toNonUnitalAlgHom.prod g.toNonUnitalAlgHom with\n    map_star' := fun x => by simp [map_star, Prod.star_def] }", "start": [540, 1], "end": [544, 62], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_prod", "code": "theorem coe_prod (f : A \u2192\u22c6\u2099\u2090[R] B) (g : A \u2192\u22c6\u2099\u2090[R] C) : \u21d1(f.prod g) = Pi.prod f g", "start": [547, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.fst_prod", "code": "@[simp]\ntheorem fst_prod (f : A \u2192\u22c6\u2099\u2090[R] B) (g : A \u2192\u22c6\u2099\u2090[R] C) : (fst R B C).comp (prod f g) = f", "start": [551, 1], "end": [553, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.snd_prod", "code": "@[simp]\ntheorem snd_prod (f : A \u2192\u22c6\u2099\u2090[R] B) (g : A \u2192\u22c6\u2099\u2090[R] C) : (snd R B C).comp (prod f g) = g", "start": [556, 1], "end": [558, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.prod_fst_snd", "code": "@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1", "start": [561, 1], "end": [563, 40], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.prodEquiv", "code": "@[simps]\ndef prodEquiv : (A \u2192\u22c6\u2099\u2090[R] B) \u00d7 (A \u2192\u22c6\u2099\u2090[R] C) \u2243 (A \u2192\u22c6\u2099\u2090[R] B \u00d7 C)\n    where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl", "start": [566, 1], "end": [574, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.inl", "code": "def inl : A \u2192\u22c6\u2099\u2090[R] A \u00d7 B :=\n  prod 1 0", "start": [585, 1], "end": [587, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.inr", "code": "def inr : B \u2192\u22c6\u2099\u2090[R] A \u00d7 B :=\n  prod 0 1", "start": [590, 1], "end": [592, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_inl", "code": "@[simp]\ntheorem coe_inl : (inl R A B : A \u2192 A \u00d7 B) = fun x => (x, 0)", "start": [597, 1], "end": [599, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.inl_apply", "code": "theorem inl_apply (x : A) : inl R A B x = (x, 0)", "start": [602, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.coe_inr", "code": "@[simp]\ntheorem coe_inr : (inr R A B : B \u2192 A \u00d7 B) = Prod.mk 0", "start": [606, 1], "end": [608, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalStarAlgHom.inr_apply", "code": "theorem inr_apply (x : B) : inr R A B x = (0, x)", "start": [611, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.fst", "code": "@[simps!]\ndef fst : A \u00d7 B \u2192\u22c6\u2090[R] A :=\n  { AlgHom.fst R A B with map_star' := fun _ => rfl }", "start": [624, 1], "end": [627, 54], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.snd", "code": "@[simps!]\ndef snd : A \u00d7 B \u2192\u22c6\u2090[R] B :=\n  { AlgHom.snd R A B with map_star' := fun _ => rfl }", "start": [630, 1], "end": [633, 54], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.prod", "code": "@[simps!]\ndef prod (f : A \u2192\u22c6\u2090[R] B) (g : A \u2192\u22c6\u2090[R] C) : A \u2192\u22c6\u2090[R] B \u00d7 C :=\n  { f.toAlgHom.prod g.toAlgHom with map_star' := fun x => by simp [Prod.star_def, map_star] }", "start": [638, 1], "end": [641, 94], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_prod", "code": "theorem coe_prod (f : A \u2192\u22c6\u2090[R] B) (g : A \u2192\u22c6\u2090[R] C) : \u21d1(f.prod g) = Pi.prod f g", "start": [644, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.fst_prod", "code": "@[simp]\ntheorem fst_prod (f : A \u2192\u22c6\u2090[R] B) (g : A \u2192\u22c6\u2090[R] C) : (fst R B C).comp (prod f g) = f", "start": [648, 1], "end": [650, 11], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.snd_prod", "code": "@[simp]\ntheorem snd_prod (f : A \u2192\u22c6\u2090[R] B) (g : A \u2192\u22c6\u2090[R] C) : (snd R B C).comp (prod f g) = g", "start": [653, 1], "end": [655, 11], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.prod_fst_snd", "code": "@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1", "start": [658, 1], "end": [660, 40], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.prodEquiv", "code": "@[simps]\ndef prodEquiv : (A \u2192\u22c6\u2090[R] B) \u00d7 (A \u2192\u22c6\u2090[R] C) \u2243 (A \u2192\u22c6\u2090[R] B \u00d7 C)\n    where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl", "start": [663, 1], "end": [671, 32], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv", "code": "structure StarAlgEquiv (R A B : Type*) [Add A] [Add B] [Mul A] [Mul B] [SMul R A] [SMul R B]\n  [Star A] [Star B] extends A \u2243+* B where\n  \n  map_star' : \u2200 a : A, toFun (star a) = star (toFun a)\n  \n  map_smul' : \u2200 (r : R) (a : A), toFun (r \u2022 a) = r \u2022 toFun a", "start": [680, 1], "end": [689, 61], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquivClass", "code": "class StarAlgEquivClass (F : Type*) (R : outParam (Type*)) (A : outParam (Type*))\n  (B : outParam (Type*)) [Add A] [Mul A] [SMul R A] [Star A] [Add B] [Mul B] [SMul R B]\n  [Star B] extends RingEquivClass F A B where\n  \n  map_star : \u2200 (f : F) (a : A), f (star a) = star (f a)\n  \n  map_smul : \u2200 (f : F) (r : R) (a : A), f (r \u2022 a) = r \u2022 f a", "start": [700, 1], "end": [710, 60], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquivClass.instStarAlgHomClass", "code": "instance (priority := 100) instStarAlgHomClass (F R A B : Type*) [CommSemiring R] [Semiring A]\n    [Algebra R A] [Star A] [Semiring B] [Algebra R B] [Star B]\n    [hF : StarAlgEquivClass F R A B] : StarAlgHomClass F R A B :=\n  { hF with\n    coe := fun f => f\n    coe_injective' := FunLike.coe_injective\n    map_one := map_one\n    map_zero := map_zero\n    commutes := fun f r => by simp only [Algebra.algebraMap_eq_smul_one, map_smul, map_one] }", "start": [755, 1], "end": [763, 94], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquivClass.toAlgEquivClass", "code": "instance (priority := 100) toAlgEquivClass {F R A B : Type*} [CommSemiring R]\n    [Ring A] [Ring B] [Algebra R A] [Algebra R B] [Star A] [Star B] [StarAlgEquivClass F R A B] :\n    AlgEquivClass F R A B :=\n  { StarAlgEquivClass.toRingEquivClass,\n    StarAlgEquivClass.instStarAlgHomClass F R A B with\n    coe := fun f => f\n    inv := fun f => EquivLike.inv f }", "start": [766, 1], "end": [772, 38], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.toRingEquiv_eq_coe", "code": "@[simp]\ntheorem toRingEquiv_eq_coe (e : A \u2243\u22c6\u2090[R] B) : e.toRingEquiv = e", "start": [798, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ext", "code": "@[ext]\ntheorem ext {f g : A \u2243\u22c6\u2090[R] B} (h : \u2200 a, f a = g a) : f = g", "start": [808, 1], "end": [810, 20], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ext_iff", "code": "theorem ext_iff {f g : A \u2243\u22c6\u2090[R] B} : f = g \u2194 \u2200 a, f a = g a", "start": [813, 1], "end": [814, 18], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.refl", "code": "@[refl]\ndef refl : A \u2243\u22c6\u2090[R] A :=\n  { RingEquiv.refl A with\n    map_smul' := fun _ _ => rfl\n    map_star' := fun _ => rfl }", "start": [817, 1], "end": [822, 32], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(refl : A \u2243\u22c6\u2090[R] A) = id", "start": [828, 1], "end": [830, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm", "code": "@[symm]\nnonrec def symm (e : A \u2243\u22c6\u2090[R] B) : B \u2243\u22c6\u2090[R] A :=\n  { e.symm with\n    map_star' := fun b => by\n      simpa only [apply_inv_apply, inv_apply_apply] using\n        congr_arg (inv e) (map_star e (inv e b)).symm\n    map_smul' := fun r b => by\n      simpa only [apply_inv_apply, inv_apply_apply] using\n        congr_arg (inv e) (map_smul e r (inv e b)).symm }", "start": [834, 1], "end": [843, 58], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.Simps.apply", "code": "def Simps.apply (e : A \u2243\u22c6\u2090[R] B) : A \u2192 B := e", "start": [847, 1], "end": [848, 46], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : A \u2243\u22c6\u2090[R] B) : B \u2192 A :=\n  e.symm", "start": [850, 1], "end": [852, 9], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.invFun_eq_symm", "code": "@[simp]\ntheorem invFun_eq_symm {e : A \u2243\u22c6\u2090[R] B} : EquivLike.inv e = e.symm", "start": [858, 1], "end": [860, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : A \u2243\u22c6\u2090[R] B) : e.symm.symm = e", "start": [863, 1], "end": [866, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_bijective", "code": "theorem symm_bijective : Function.Bijective (symm : (A \u2243\u22c6\u2090[R] B) \u2192 B \u2243\u22c6\u2090[R] A)", "start": [869, 1], "end": [870, 53], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.mk_coe'", "code": "@[simp]\ntheorem mk_coe' (e : A \u2243\u22c6\u2090[R] B) (f h\u2081 h\u2082 h\u2083 h\u2084 h\u2085 h\u2086) :\n    (\u27e8\u27e8\u27e8f, e, h\u2081, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085, h\u2086\u27e9 : B \u2243\u22c6\u2090[R] A) = e.symm", "start": [874, 1], "end": [877, 47], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_mk", "code": "@[simp]\ntheorem symm_mk (f f') (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085 h\u2086) :\n    (\u27e8\u27e8\u27e8f, f', h\u2081, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085, h\u2086\u27e9 : A \u2243\u22c6\u2090[R] B).symm =\n      { (\u27e8\u27e8\u27e8f, f', h\u2081, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085, h\u2086\u27e9 : A \u2243\u22c6\u2090[R] B).symm with\n        toFun := f'\n        invFun := f }", "start": [881, 1], "end": [887, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm : (StarAlgEquiv.refl : A \u2243\u22c6\u2090[R] A).symm = StarAlgEquiv.refl", "start": [890, 1], "end": [892, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.to_ringEquiv_symm", "code": "theorem to_ringEquiv_symm (f : A \u2243\u22c6\u2090[R] B) : (f : A \u2243+* B).symm = f.symm", "start": [896, 1], "end": [897, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_to_ringEquiv", "code": "@[simp]\ntheorem symm_to_ringEquiv (e : A \u2243\u22c6\u2090[R] B) : (e.symm : B \u2243+* A) = (e : A \u2243+* B).symm", "start": [900, 1], "end": [902, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.trans", "code": "@[trans]\ndef trans (e\u2081 : A \u2243\u22c6\u2090[R] B) (e\u2082 : B \u2243\u22c6\u2090[R] C) : A \u2243\u22c6\u2090[R] C :=\n  { e\u2081.toRingEquiv.trans\n      e\u2082.toRingEquiv with\n    map_smul' := fun r a =>\n      show e\u2082.toFun (e\u2081.toFun (r \u2022 a)) = r \u2022 e\u2082.toFun (e\u2081.toFun a) by\n        rw [e\u2081.map_smul', e\u2082.map_smul']\n    map_star' := fun a =>\n      show e\u2082.toFun (e\u2081.toFun (star a)) = star (e\u2082.toFun (e\u2081.toFun a)) by\n        rw [e\u2081.map_star', e\u2082.map_star'] }", "start": [905, 1], "end": [915, 42], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : A \u2243\u22c6\u2090[R] B) : \u2200 x, e (e.symm x) = x", "start": [918, 1], "end": [920, 33], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : A \u2243\u22c6\u2090[R] B) : \u2200 x, e.symm (e x) = x", "start": [923, 1], "end": [925, 33], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (e\u2081 : A \u2243\u22c6\u2090[R] B) (e\u2082 : B \u2243\u22c6\u2090[R] C) (x : C) :\n    (e\u2081.trans e\u2082).symm x = e\u2081.symm (e\u2082.symm x)", "start": [928, 1], "end": [931, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e\u2081 : A \u2243\u22c6\u2090[R] B) (e\u2082 : B \u2243\u22c6\u2090[R] C) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081", "start": [934, 1], "end": [936, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : A \u2243\u22c6\u2090[R] B) (e\u2082 : B \u2243\u22c6\u2090[R] C) (x : A) : (e\u2081.trans e\u2082) x = e\u2082 (e\u2081 x)", "start": [939, 1], "end": [941, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.leftInverse_symm", "code": "theorem leftInverse_symm (e : A \u2243\u22c6\u2090[R] B) : Function.LeftInverse e.symm e", "start": [944, 1], "end": [945, 13], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.rightInverse_symm", "code": "theorem rightInverse_symm (e : A \u2243\u22c6\u2090[R] B) : Function.RightInverse e.symm e", "start": [948, 1], "end": [949, 14], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofStarAlgHom", "code": "@[simps]\ndef ofStarAlgHom (f : F) (g : G) (h\u2081 : \u2200 x, g (f x) = x) (h\u2082 : \u2200 x, f (g x) = x) : A \u2243\u22c6\u2090[R] B\n    where\n  toFun := f\n  invFun := g\n  left_inv := h\u2081\n  right_inv := h\u2082\n  map_add' := map_add f\n  map_mul' := map_mul f\n  map_smul' := map_smul f\n  map_star' := map_star f", "start": [964, 1], "end": [976, 26], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofBijective", "code": "noncomputable def ofBijective (f : F) (hf : Function.Bijective f) : A \u2243\u22c6\u2090[R] B :=\n  {\n    RingEquiv.ofBijective f\n      (hf : Function.Bijective (f : A \u2192 B)) with\n    toFun := f\n    map_star' := map_star f\n    map_smul' := map_smul f }", "start": [979, 1], "end": [986, 30], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.coe_ofBijective", "code": "@[simp]\ntheorem coe_ofBijective {f : F} (hf : Function.Bijective f) :\n    (StarAlgEquiv.ofBijective f hf : A \u2192 B) = f", "start": [989, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofBijective_apply", "code": "theorem ofBijective_apply {f : F} (hf : Function.Bijective f) (a : A) :\n    (StarAlgEquiv.ofBijective f hf) a = f a", "start": [995, 1], "end": [997, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Prime.lean", "imports": ["Mathlib/Data/List/Perm.lean", "Mathlib/Data/List/BigOperators/Lemmas.lean", "Mathlib/Algebra/Associated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prime.dvd_prod_iff", "code": "theorem Prime.dvd_prod_iff {p : M} {L : List M} (pp : Prime p) : p \u2223 L.prod \u2194 \u2203 a \u2208 L, p \u2223 a", "start": [26, 1], "end": [38, 60], "kind": "commanddeclaration"}, {"full_name": "Prime.not_dvd_prod", "code": "theorem Prime.not_dvd_prod {p : M} {L : List M} (pp : Prime p) (hL : \u2200 a \u2208 L, \u00acp \u2223 a) :\n    \u00acp \u2223 L.prod", "start": [41, 1], "end": [43, 76], "kind": "commanddeclaration"}, {"full_name": "mem_list_primes_of_dvd_prod", "code": "theorem mem_list_primes_of_dvd_prod {p : M} (hp : Prime p) {L : List M} (hL : \u2200 q \u2208 L, Prime q)\n    (hpL : p \u2223 L.prod) : p \u2208 L", "start": [52, 1], "end": [55, 54], "kind": "commanddeclaration"}, {"full_name": "perm_of_prod_eq_prod", "code": "theorem perm_of_prod_eq_prod :\n    \u2200 {l\u2081 l\u2082 : List M}, l\u2081.prod = l\u2082.prod \u2192 (\u2200 p \u2208 l\u2081, Prime p) \u2192 (\u2200 p \u2208 l\u2082, Prime p) \u2192 Perm l\u2081 l\u2082", "start": [58, 1], "end": [78, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "imports": ["Mathlib/CategoryTheory/CommSq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.HasLiftingProperty", "code": "class HasLiftingProperty : Prop where\n  \n  sq_hasLift : \u2200 {f : A \u27f6 X} {g : B \u27f6 Y} (sq : CommSq f i p g), sq.HasLift", "start": [38, 1], "end": [43, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sq_hasLift_of_hasLiftingProperty", "code": "instance (priority := 100) sq_hasLift_of_hasLiftingProperty {f : A \u27f6 X} {g : B \u27f6 Y}\n    (sq : CommSq f i p g) [hip : HasLiftingProperty i p] : sq.HasLift := by apply hip.sq_hasLift", "start": [47, 1], "end": [48, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.op", "code": "theorem op (h : HasLiftingProperty i p) : HasLiftingProperty p.op i.op", "start": [55, 1], "end": [58, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.unop", "code": "theorem unop {A B X Y : C\u1d52\u1d56} {i : A \u27f6 B} {p : X \u27f6 Y} (h : HasLiftingProperty i p) :\n    HasLiftingProperty p.unop i.unop", "start": [61, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.iff_op", "code": "theorem iff_op : HasLiftingProperty i p \u2194 HasLiftingProperty p.op i.op", "start": [69, 1], "end": [70, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.iff_unop", "code": "theorem iff_unop {A B X Y : C\u1d52\u1d56} (i : A \u27f6 B) (p : X \u27f6 Y) :\n    HasLiftingProperty i p \u2194 HasLiftingProperty p.unop i.unop", "start": [73, 1], "end": [75, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_left_iso", "code": "instance (priority := 100) of_left_iso [IsIso i] : HasLiftingProperty i p :=\n  \u27e8fun {f} {g} sq =>\n    CommSq.HasLift.mk'\n      { l := inv i \u226b f\n        fac_left := by simp only [IsIso.hom_inv_id_assoc]\n        fac_right := by simp only [sq.w, assoc, IsIso.inv_hom_id_assoc] }\u27e9", "start": [80, 1], "end": [85, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_right_iso", "code": "instance (priority := 100) of_right_iso [IsIso p] : HasLiftingProperty i p :=\n  \u27e8fun {f} {g} sq =>\n    CommSq.HasLift.mk'\n      { l := g \u226b inv p\n        fac_left := by simp only [\u2190 sq.w_assoc, IsIso.hom_inv_id, comp_id]\n        fac_right := by simp only [assoc, IsIso.inv_hom_id, comp_id] }\u27e9", "start": [88, 1], "end": [93, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_comp_left", "code": "instance of_comp_left [HasLiftingProperty i p] [HasLiftingProperty i' p] :\n    HasLiftingProperty (i \u226b i') p :=\n  \u27e8fun {f} {g} sq => by\n    have fac := sq.w\n    rw [assoc] at fac\n    exact\n      CommSq.HasLift.mk'\n        { l := (CommSq.mk (CommSq.mk fac).fac_right).lift\n          fac_left := by simp only [assoc, CommSq.fac_left]\n          fac_right := by simp only [CommSq.fac_right] }\u27e9", "start": [96, 1], "end": [105, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_comp_right", "code": "instance of_comp_right [HasLiftingProperty i p] [HasLiftingProperty i p'] :\n    HasLiftingProperty i (p \u226b p') :=\n  \u27e8fun {f} {g} sq => by\n    have fac := sq.w\n    rw [\u2190 assoc] at fac\n    let _ := (CommSq.mk (CommSq.mk fac).fac_left.symm).lift\n    exact\n      CommSq.HasLift.mk'\n        { l := (CommSq.mk (CommSq.mk fac).fac_left.symm).lift\n          fac_left := by simp only [CommSq.fac_left]\n          fac_right := by simp only [CommSq.fac_right_assoc, CommSq.fac_right] }\u27e9", "start": [108, 1], "end": [118, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_arrow_iso_left", "code": "theorem of_arrow_iso_left {A B A' B' X Y : C} {i : A \u27f6 B} {i' : A' \u27f6 B'}\n    (e : Arrow.mk i \u2245 Arrow.mk i') (p : X \u27f6 Y) [hip : HasLiftingProperty i p] :\n    HasLiftingProperty i' p", "start": [121, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.of_arrow_iso_right", "code": "theorem of_arrow_iso_right {A B X Y X' Y' : C} (i : A \u27f6 B) {p : X \u27f6 Y} {p' : X' \u27f6 Y'}\n    (e : Arrow.mk p \u2245 Arrow.mk p') [hip : HasLiftingProperty i p] : HasLiftingProperty i p'", "start": [128, 1], "end": [131, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_left", "code": "theorem iff_of_arrow_iso_left {A B A' B' X Y : C} {i : A \u27f6 B} {i' : A' \u27f6 B'}\n    (e : Arrow.mk i \u2245 Arrow.mk i') (p : X \u27f6 Y) :\n    HasLiftingProperty i p \u2194 HasLiftingProperty i' p", "start": [134, 1], "end": [138, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasLiftingProperty.iff_of_arrow_iso_right", "code": "theorem iff_of_arrow_iso_right {A B X Y X' Y' : C} (i : A \u27f6 B) {p : X \u27f6 Y} {p' : X' \u27f6 Y'}\n    (e : Arrow.mk p \u2245 Arrow.mk p') : HasLiftingProperty i p \u2194 HasLiftingProperty i p'", "start": [141, 1], "end": [144, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Balanced.lean", "imports": ["Mathlib/CategoryTheory/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Balanced", "code": "class Balanced : Prop where\n  isIso_of_mono_of_epi : \u2200 {X Y : C} (f : X \u27f6 Y) [Mono f] [Epi f], IsIso f", "start": [32, 1], "end": [34, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_mono_of_epi", "code": "theorem isIso_of_mono_of_epi [Balanced C] {X Y : C} (f : X \u27f6 Y) [Mono f] [Epi f] : IsIso f", "start": [39, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_iff_mono_and_epi", "code": "theorem isIso_iff_mono_and_epi [Balanced C] {X Y : C} (f : X \u27f6 Y) : IsIso f \u2194 Mono f \u2227 Epi f", "start": [43, 1], "end": [44, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.balanced_opposite", "code": "theorem balanced_opposite [Balanced C] : Balanced C\u1d52\u1d56", "start": [51, 1], "end": [54, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Basic.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Adjunction", "code": "structure Adjunction (F : C \u2964 D) (G : D \u2964 C) where\n  \n  homEquiv : \u2200 X Y, (F.obj X \u27f6 Y) \u2243 (X \u27f6 G.obj Y)\n  \n  unit : \ud835\udfed C \u27f6 F.comp G\n  \n  counit : G.comp F \u27f6 \ud835\udfed D\n  \n  homEquiv_unit : \u2200 {X Y f}, (homEquiv X Y) f = (unit : _ \u27f6 _).app X \u226b G.map f := by aesop_cat\n  \n  homEquiv_counit : \u2200 {X Y g}, (homEquiv X Y).symm g = F.map g \u226b counit.app Y := by aesop_cat", "start": [49, 1], "end": [73, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsLeftAdjoint", "code": "class IsLeftAdjoint (left : C \u2964 D) where\n  \n  right : D \u2964 C\n  \n  adj : left \u22a3 right", "start": [85, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsRightAdjoint", "code": "class IsRightAdjoint (right : D \u2964 C) where\n  \n  left : C \u2964 D\n  \n  adj : left \u22a3 right", "start": [93, 1], "end": [98, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.leftAdjoint", "code": "def leftAdjoint (R : D \u2964 C) [IsRightAdjoint R] : C \u2964 D :=\n  IsRightAdjoint.left R", "start": [101, 1], "end": [103, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.rightAdjoint", "code": "def rightAdjoint (L : C \u2964 D) [IsLeftAdjoint L] : D \u2964 C :=\n  IsLeftAdjoint.right L", "start": [106, 1], "end": [108, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.ofLeftAdjoint", "code": "def Adjunction.ofLeftAdjoint (left : C \u2964 D) [IsLeftAdjoint left] :\n    Adjunction left (rightAdjoint left) :=\n  IsLeftAdjoint.adj", "start": [111, 1], "end": [114, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.ofRightAdjoint", "code": "def Adjunction.ofRightAdjoint (right : C \u2964 D) [IsRightAdjoint right] :\n    Adjunction (leftAdjoint right) right :=\n  IsRightAdjoint.adj", "start": [117, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_id", "code": "theorem homEquiv_id (X : C) : adj.homEquiv X _ (\ud835\udfd9 _) = adj.unit.app X", "start": [136, 1], "end": [136, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_symm_id", "code": "theorem homEquiv_symm_id (X : D) : (adj.homEquiv _ X).symm (\ud835\udfd9 _) = adj.counit.app X", "start": [139, 1], "end": [139, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_naturality_left_symm", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_naturality_left_symm (f : X' \u27f6 X) (g : X \u27f6 G.obj Y) :\n    (adj.homEquiv X' Y).symm (f \u226b g) = F.map f \u226b (adj.homEquiv X Y).symm g", "start": [147, 1], "end": [150, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_naturality_left", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_naturality_left (f : X' \u27f6 X) (g : F.obj X \u27f6 Y) :\n    (adj.homEquiv X' Y) (F.map f \u226b g) = f \u226b (adj.homEquiv X Y) g", "start": [154, 1], "end": [158, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_naturality_right", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_naturality_right (f : F.obj X \u27f6 Y) (g : Y \u27f6 Y') :\n    (adj.homEquiv X Y') (f \u226b g) = (adj.homEquiv X Y) f \u226b G.map g", "start": [162, 1], "end": [165, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_naturality_right_symm", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_naturality_right_symm (f : X \u27f6 G.obj Y) (g : Y \u27f6 Y') :\n    (adj.homEquiv X Y').symm (f \u226b G.map g) = (adj.homEquiv X Y).symm f \u226b g", "start": [169, 1], "end": [173, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.left_triangle", "code": "@[simp]\ntheorem left_triangle : whiskerRight adj.unit F \u226b whiskerLeft F adj.counit = \ud835\udfd9 _", "start": [176, 1], "end": [180, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.right_triangle", "code": "@[simp]\ntheorem right_triangle : whiskerLeft G adj.unit \u226b whiskerRight adj.counit G = \ud835\udfd9 _", "start": [183, 1], "end": [187, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.left_triangle_components", "code": "@[reassoc (attr := simp)]\ntheorem left_triangle_components :\n    F.map (adj.unit.app X) \u226b adj.counit.app (F.obj X) = \ud835\udfd9 (F.obj X)", "start": [190, 1], "end": [193, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.right_triangle_components", "code": "@[reassoc (attr := simp)]\ntheorem right_triangle_components {Y : D} :\n    adj.unit.app (G.obj Y) \u226b G.map (adj.counit.app Y) = \ud835\udfd9 (G.obj Y)", "start": [196, 1], "end": [199, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.counit_naturality", "code": "@[reassoc (attr := simp)]\ntheorem counit_naturality {X Y : D} (f : X \u27f6 Y) :\n    F.map (G.map f) \u226b adj.counit.app Y = adj.counit.app X \u226b f", "start": [202, 1], "end": [205, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.unit_naturality", "code": "@[reassoc (attr := simp)]\ntheorem unit_naturality {X Y : C} (f : X \u27f6 Y) :\n    adj.unit.app X \u226b G.map (F.map f) = f \u226b adj.unit.app Y", "start": [208, 1], "end": [211, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.homEquiv_apply_eq", "code": "theorem homEquiv_apply_eq {A : C} {B : D} (f : F.obj A \u27f6 B) (g : A \u27f6 G.obj B) :\n    adj.homEquiv A B f = g \u2194 f = (adj.homEquiv A B).symm g", "start": [214, 1], "end": [220, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.eq_homEquiv_apply", "code": "theorem eq_homEquiv_apply {A : C} {B : D} (f : F.obj A \u27f6 B) (g : A \u27f6 G.obj B) :\n    g = adj.homEquiv A B f \u2194 (adj.homEquiv A B).symm g = f", "start": [223, 1], "end": [229, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreHomEquiv", "code": "structure CoreHomEquiv (F : C \u2964 D) (G : D \u2964 C) where\n  \n  homEquiv : \u2200 X Y, (F.obj X \u27f6 Y) \u2243 (X \u27f6 G.obj Y)\n  \n  homEquiv_naturality_left_symm :\n    \u2200 {X' X Y} (f : X' \u27f6 X) (g : X \u27f6 G.obj Y),\n      (homEquiv X' Y).symm (f \u226b g) = F.map f \u226b (homEquiv X Y).symm g := by\n    aesop_cat\n  \n  homEquiv_naturality_right :\n    \u2200 {X Y Y'} (f : F.obj X \u27f6 Y) (g : Y \u27f6 Y'),\n      (homEquiv X Y') (f \u226b g) = (homEquiv X Y) f \u226b G.map g := by\n    aesop_cat", "start": [238, 1], "end": [256, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left_aux", "code": "@[simp]\ntheorem homEquiv_naturality_left_aux (f : X' \u27f6 X) (g : F.obj X \u27f6 Y) :\n    (adj.homEquiv X' (F.obj X)) (F.map f) \u226b G.map g = f \u226b (adj.homEquiv X Y) g", "start": [276, 1], "end": [279, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left", "code": "theorem homEquiv_naturality_left (f : X' \u27f6 X) (g : F.obj X \u27f6 Y) :\n    (adj.homEquiv X' Y) (F.map f \u226b g) = f \u226b (adj.homEquiv X Y) g", "start": [282, 1], "end": [284, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right_symm_aux", "code": "@[simp]\ntheorem homEquiv_naturality_right_symm_aux (f : X \u27f6 G.obj Y) (g : Y \u27f6 Y') :\n    F.map f \u226b (adj.homEquiv (G.obj Y) Y').symm (G.map g) = (adj.homEquiv X Y).symm f \u226b g", "start": [287, 1], "end": [290, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right_symm", "code": "theorem homEquiv_naturality_right_symm (f : X \u27f6 G.obj Y) (g : Y \u27f6 Y') :\n    (adj.homEquiv X Y').symm (f \u226b G.map g) = (adj.homEquiv X Y).symm f \u226b g", "start": [293, 1], "end": [295, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.CoreUnitCounit", "code": "structure CoreUnitCounit (F : C \u2964 D) (G : D \u2964 C) where\n  \n  unit : \ud835\udfed C \u27f6 F.comp G\n  \n  counit : G.comp F \u27f6 \ud835\udfed D\n  \n  left_triangle :\n    whiskerRight unit F \u226b (Functor.associator F G F).hom \u226b whiskerLeft F counit =\n      NatTrans.id (\ud835\udfed C \u22d9 F) := by\n    aesop_cat\n  \n  right_triangle :\n    whiskerLeft G unit \u226b (Functor.associator G F G).inv \u226b whiskerRight counit G =\n      NatTrans.id (G \u22d9 \ud835\udfed C) := by\n    aesop_cat", "start": [300, 1], "end": [322, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.mkOfHomEquiv", "code": "@[simps]\ndef mkOfHomEquiv (adj : CoreHomEquiv F G) : F \u22a3 G :=\n  { adj with\n    unit :=\n      { app := fun X => (adj.homEquiv X (F.obj X)) (\ud835\udfd9 (F.obj X))\n        naturality := by\n          intros\n          erw [\u2190 adj.homEquiv_naturality_left, \u2190 adj.homEquiv_naturality_right]\n          dsimp; simp }\n    counit :=\n      { app := fun Y => (adj.homEquiv _ _).invFun (\ud835\udfd9 (G.obj Y))\n        naturality := by\n          intros\n          erw [\u2190 adj.homEquiv_naturality_left_symm, \u2190 adj.homEquiv_naturality_right_symm]\n          dsimp; simp }\n    homEquiv_unit := @fun X Y f => by erw [\u2190 adj.homEquiv_naturality_right]; simp\n    homEquiv_counit := @fun X Y f => by erw [\u2190 adj.homEquiv_naturality_left_symm]; simp\n  }", "start": [337, 1], "end": [357, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.mkOfUnitCounit", "code": "@[simps!]\ndef mkOfUnitCounit (adj : CoreUnitCounit F G) : F \u22a3 G :=\n  { adj with\n    homEquiv := fun X Y =>\n      { toFun := fun f => adj.unit.app X \u226b G.map f\n        invFun := fun g => F.map g \u226b adj.counit.app Y\n        left_inv := fun f => by\n          change F.map (_ \u226b _) \u226b _ = _\n          rw [F.map_comp, assoc, \u2190 Functor.comp_map, adj.counit.naturality, \u2190 assoc]\n          convert id_comp f\n          have t := congrArg (fun (s : NatTrans (\ud835\udfed C \u22d9 F) (F \u22d9 \ud835\udfed D)) => s.app X) adj.left_triangle\n          dsimp at t\n          simp only [id_comp] at t\n          exact t\n        right_inv := fun g => by\n          change _ \u226b G.map (_ \u226b _) = _\n          rw [G.map_comp, \u2190 assoc, \u2190 Functor.comp_map, \u2190 adj.unit.naturality, assoc]\n          convert comp_id g\n          have t := congrArg (fun t : NatTrans (G \u22d9 \ud835\udfed C) (\ud835\udfed D \u22d9 G) => t.app Y) adj.right_triangle\n          dsimp at t\n          simp only [id_comp] at t\n          exact t } }", "start": [360, 1], "end": [384, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.id", "code": "def id : \ud835\udfed C \u22a3 \ud835\udfed C where\n  homEquiv X Y := Equiv.refl _\n  unit := \ud835\udfd9 _\n  counit := \ud835\udfd9 _", "start": [392, 1], "end": [396, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.equivHomsetLeftOfNatIso", "code": "@[simps]\ndef equivHomsetLeftOfNatIso {F F' : C \u2964 D} (iso : F \u2245 F') {X : C} {Y : D} :\n    (F.obj X \u27f6 Y) \u2243 (F'.obj X \u27f6 Y)\n    where\n  toFun f := iso.inv.app _ \u226b f\n  invFun g := iso.hom.app _ \u226b g\n  left_inv f := by simp\n  right_inv g := by simp", "start": [403, 1], "end": [411, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.equivHomsetRightOfNatIso", "code": "@[simps]\ndef equivHomsetRightOfNatIso {G G' : D \u2964 C} (iso : G \u2245 G') {X : C} {Y : D} :\n    (X \u27f6 G.obj Y) \u2243 (X \u27f6 G'.obj Y)\n    where\n  toFun f := f \u226b iso.hom.app _\n  invFun g := g \u226b iso.inv.app _\n  left_inv f := by simp\n  right_inv g := by simp", "start": [414, 1], "end": [422, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.ofNatIsoLeft", "code": "def ofNatIsoLeft {F G : C \u2964 D} {H : D \u2964 C} (adj : F \u22a3 H) (iso : F \u2245 G) : G \u22a3 H :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y => (equivHomsetLeftOfNatIso iso.symm).trans (adj.homEquiv X Y) }", "start": [425, 1], "end": [428, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.ofNatIsoRight", "code": "def ofNatIsoRight {F : C \u2964 D} {G H : D \u2964 C} (adj : F \u22a3 G) (iso : G \u2245 H) : F \u22a3 H :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y => (adj.homEquiv X Y).trans (equivHomsetRightOfNatIso iso) }", "start": [431, 1], "end": [434, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointOfNatIso", "code": "def rightAdjointOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [r : IsRightAdjoint F] : IsRightAdjoint G\n    where\n  left := r.left\n  adj := ofNatIsoRight r.adj h", "start": [437, 1], "end": [441, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointOfNatIso", "code": "def leftAdjointOfNatIso {F G : C \u2964 D} (h : F \u2245 G) [r : IsLeftAdjoint F] : IsLeftAdjoint G\n    where\n  right := r.right\n  adj := ofNatIsoLeft r.adj h", "start": [444, 1], "end": [448, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.comp", "code": "def comp (adj\u2081 : F \u22a3 G) (adj\u2082 : H \u22a3 I) : F \u22d9 H \u22a3 I \u22d9 G\n    where\n  homEquiv X Z := Equiv.trans (adj\u2082.homEquiv _ _) (adj\u2081.homEquiv _ _)\n  unit := adj\u2081.unit \u226b (whiskerLeft F <| whiskerRight adj\u2082.unit G) \u226b (Functor.associator _ _ _).inv\n  counit :=\n    (Functor.associator _ _ _).hom \u226b (whiskerLeft I <| whiskerRight adj\u2081.counit H) \u226b adj\u2082.counit", "start": [455, 1], "end": [464, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointOfComp", "code": "instance leftAdjointOfComp {E : Type u\u2083} [Category.{v\u2083} E] (F : C \u2964 D) (G : D \u2964 E)\n    [Fl : IsLeftAdjoint F] [Gl : IsLeftAdjoint G] : IsLeftAdjoint (F \u22d9 G)\n    where\n  right := Gl.right \u22d9 Fl.right\n  adj := Fl.adj.comp Gl.adj", "start": [467, 1], "end": [472, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointOfComp", "code": "instance rightAdjointOfComp {E : Type u\u2083} [Category.{v\u2083} E] {F : C \u2964 D} {G : D \u2964 E}\n    [Fr : IsRightAdjoint F] [Gr : IsRightAdjoint G] : IsRightAdjoint (F \u22d9 G)\n    where\n  left := Gr.left \u22d9 Fr.left\n  adj := Gr.adj.comp Fr.adj", "start": [475, 1], "end": [480, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.he'", "code": "private theorem he' {X Y Y'} (f g) : (e X Y').symm (f \u226b G.map g) = (e X Y).symm f \u226b g", "start": [498, 1], "end": [499, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.leftAdjointOfEquiv", "code": "@[simps!]\ndef leftAdjointOfEquiv : C \u2964 D where\n  obj := F_obj\n  map {X} {X'} f := (e X (F_obj X')).symm (f \u226b e X' (F_obj X') (\ud835\udfd9 _))\n  map_comp := fun f f' => by\n    rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]\n    conv =>\n      rhs\n      rw [assoc, \u2190 he, id_comp, Equiv.apply_symm_apply]\n    simp", "start": [502, 1], "end": [515, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.adjunctionOfEquivLeft", "code": "@[simps!]\ndef adjunctionOfEquivLeft : leftAdjointOfEquiv e he \u22a3 G :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := fun {X'} {X} {Y} f g => by\n        have := @he' C _ D _ G F_obj e he\n        erw [\u2190 this, \u2190 Equiv.apply_eq_iff_eq (e X' Y)]\n        simp only [leftAdjointOfEquiv_obj, Equiv.apply_symm_apply, assoc]\n        congr\n        rw [\u2190 he]\n        simp\n    }", "start": [518, 1], "end": [531, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.he''", "code": "private theorem he'' {X' X Y} (f g) : F.map f \u226b (e X Y).symm g = (e X' Y).symm (f \u226b g)", "start": [545, 1], "end": [546, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.rightAdjointOfEquiv", "code": "@[simps!]\ndef rightAdjointOfEquiv : D \u2964 C where\n  obj := G_obj\n  map {Y} {Y'} g := (e (G_obj Y) Y') ((e (G_obj Y) Y).symm (\ud835\udfd9 _) \u226b g)\n  map_comp := fun {Y} {Y'} {Y''} g g' => by\n    rw [\u2190 Equiv.eq_symm_apply, \u2190 he'' e he, Equiv.symm_apply_apply]\n    conv =>\n      rhs\n      rw [\u2190 assoc, he'' e he, comp_id, Equiv.symm_apply_apply]\n    simp", "start": [549, 1], "end": [562, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.adjunctionOfEquivRight", "code": "@[simps!]\ndef adjunctionOfEquivRight : F \u22a3 (rightAdjointOfEquiv e he) :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := by\n        intro X X' Y f g; rw [Equiv.symm_apply_eq]; dsimp; rw [he]; simp\n      homEquiv_naturality_right := by\n        intro X Y Y' g h\n        erw [\u2190 he, Equiv.apply_eq_iff_eq, \u2190 assoc, he'' e he, comp_id, Equiv.symm_apply_apply] }", "start": [565, 1], "end": [575, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.toEquivalence", "code": "@[simps!]\nnoncomputable def toEquivalence (adj : F \u22a3 G) [\u2200 X, IsIso (adj.unit.app X)]\n    [\u2200 Y, IsIso (adj.counit.app Y)] : C \u224c D\n    where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)", "start": [580, 1], "end": [591, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.isRightAdjointToIsEquivalence", "code": "@[simps!]\nnoncomputable def isRightAdjointToIsEquivalence [IsRightAdjoint G]\n    [\u2200 X, IsIso ((Adjunction.ofRightAdjoint G).unit.app X)]\n    [\u2200 Y, IsIso ((Adjunction.ofRightAdjoint G).counit.app Y)] : IsEquivalence G :=\n  IsEquivalence.ofEquivalenceInverse (Adjunction.ofRightAdjoint G).toEquivalence", "start": [594, 1], "end": [602, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.toAdjunction", "code": "@[pp_dot, simps! unit counit]\ndef toAdjunction (e : C \u224c D) : e.functor \u22a3 e.inverse :=\n  mkOfUnitCounit\n    \u27e8e.unit, e.counit, by\n      ext\n      dsimp\n      simp only [id_comp]\n      exact e.functor_unit_comp _, by\n      ext\n      dsimp\n      simp only [id_comp]\n      exact e.unit_inverse_comp _\u27e9", "start": [611, 1], "end": [624, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.adjunction", "code": "def adjunction (E : C \u2964 D) [IsEquivalence E] : E \u22a3 E.inv :=\n  E.asEquivalence.toAdjunction", "start": [634, 1], "end": [636, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftAdjointOfEquivalence", "code": "instance (priority := 10) leftAdjointOfEquivalence {F : C \u2964 D} [IsEquivalence F] : IsLeftAdjoint F\n    where\n  right := _\n  adj := Functor.adjunction F", "start": [639, 1], "end": [643, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightAdjoint_of_isEquivalence", "code": "@[simp]\ntheorem rightAdjoint_of_isEquivalence {F : C \u2964 D} [IsEquivalence F] : rightAdjoint F = inv F", "start": [646, 1], "end": [648, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightAdjointOfEquivalence", "code": "instance (priority := 10) rightAdjointOfEquivalence {F : C \u2964 D} [IsEquivalence F] : IsRightAdjoint F\n    where\n  left := _\n  adj := Functor.adjunction F.inv", "start": [651, 1], "end": [655, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftAdjoint_of_isEquivalence", "code": "@[simp]\ntheorem leftAdjoint_of_isEquivalence {F : C \u2964 D} [IsEquivalence F] : leftAdjoint F = inv F", "start": [658, 1], "end": [660, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Sign.lean", "imports": ["Mathlib/Data/Int/Order/Units.lean", "Mathlib/Data/Finset/Fin.lean", "Mathlib/GroupTheory/OrderOfElement.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Perm/Support.lean"], "premises": [{"full_name": "Equiv.Perm.modSwap", "code": "def modSwap [DecidableEq \u03b1] (i j : \u03b1) : Setoid (Perm \u03b1) :=\n  \u27e8fun \u03c3 \u03c4 => \u03c3 = \u03c4 \u2228 \u03c3 = swap i j * \u03c4, fun \u03c3 => Or.inl (refl \u03c3), fun {\u03c3 \u03c4} h =>\n    Or.casesOn h (fun h => Or.inl h.symm) fun h => Or.inr (by rw [h, swap_mul_self_mul]),\n    fun {\u03c3 \u03c4 \u03c5} h\u03c3\u03c4 h\u03c4\u03c5 => by\n    cases' h\u03c3\u03c4 with h\u03c3\u03c4 h\u03c3\u03c4 <;> cases' h\u03c4\u03c5 with h\u03c4\u03c5 h\u03c4\u03c5 <;> try rw [h\u03c3\u03c4, h\u03c4\u03c5, swap_mul_self_mul] <;>\n    simp [h\u03c3\u03c4, h\u03c4\u03c5] \u00b7 simp [h\u03c3\u03c4, h\u03c4\u03c5]\n    \u00b7 simp [h\u03c3\u03c4, h\u03c4\u03c5]\n    \u00b7 simp [h\u03c3\u03c4, h\u03c4\u03c5]\u27e9", "start": [39, 1], "end": [52, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.perm_inv_on_of_perm_on_finset", "code": "theorem perm_inv_on_of_perm_on_finset {s : Finset \u03b1} {f : Perm \u03b1} (h : \u2200 x \u2208 s, f x \u2208 s) {y : \u03b1}\n    (hy : y \u2208 s) : f\u207b\u00b9 y \u2208 s", "start": [59, 1], "end": [67, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.perm_inv_mapsTo_of_mapsTo", "code": "theorem perm_inv_mapsTo_of_mapsTo (f : Perm \u03b1) {s : Set \u03b1} [Finite s] (h : Set.MapsTo f s s) :\n    Set.MapsTo (f\u207b\u00b9 : _) s s", "start": [70, 1], "end": [77, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.perm_inv_mapsTo_iff_mapsTo", "code": "@[simp]\ntheorem perm_inv_mapsTo_iff_mapsTo {f : Perm \u03b1} {s : Set \u03b1} [Finite s] :\n    Set.MapsTo (f\u207b\u00b9 : _) s s \u2194 Set.MapsTo f s s", "start": [80, 1], "end": [83, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.perm_inv_on_of_perm_on_finite", "code": "theorem perm_inv_on_of_perm_on_finite {f : Perm \u03b1} {p : \u03b1 \u2192 Prop} [Finite { x // p x }]\n    (h : \u2200 x, p x \u2192 p (f x)) {x : \u03b1} (hx : p x) : p (f\u207b\u00b9 x)", "start": [86, 1], "end": [91, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePermOfFintype", "code": "abbrev subtypePermOfFintype (f : Perm \u03b1) {p : \u03b1 \u2192 Prop} [Fintype { x // p x }]\n    (h : \u2200 x, p x \u2192 p (f x)) : Perm { x // p x } :=\n  f.subtypePerm fun x => \u27e8h x, fun h\u2082 => f.inv_apply_self x \u25b8 perm_inv_on_of_perm_on_finite h h\u2082\u27e9", "start": [94, 1], "end": [99, 98], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePermOfFintype_apply", "code": "@[simp]\ntheorem subtypePermOfFintype_apply (f : Perm \u03b1) {p : \u03b1 \u2192 Prop} [Fintype { x // p x }]\n    (h : \u2200 x, p x \u2192 p (f x)) (x : { x // p x }) : subtypePermOfFintype f h x = \u27e8f x, h x x.2\u27e9", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePermOfFintype_one", "code": "theorem subtypePermOfFintype_one (p : \u03b1 \u2192 Prop) [Fintype { x // p x }]\n    (h : \u2200 x, p x \u2192 p ((1 : Perm \u03b1) x)) : @subtypePermOfFintype \u03b1 1 p _ h = 1", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.perm_mapsTo_inl_iff_mapsTo_inr", "code": "theorem perm_mapsTo_inl_iff_mapsTo_inr {m n : Type*} [Finite m] [Finite n] (\u03c3 : Perm (Sum m n)) :\n    Set.MapsTo \u03c3 (Set.range Sum.inl) (Set.range Sum.inl) \u2194\n      Set.MapsTo \u03c3 (Set.range Sum.inr) (Set.range Sum.inr)", "start": [113, 1], "end": [133, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_sumCongrHom_range_of_perm_mapsTo_inl", "code": "theorem mem_sumCongrHom_range_of_perm_mapsTo_inl {m n : Type*} [Finite m] [Finite n]\n    {\u03c3 : Perm (Sum m n)} (h : Set.MapsTo \u03c3 (Set.range Sum.inl) (Set.range Sum.inl)) :\n    \u03c3 \u2208 (sumCongrHom m n).range", "start": [136, 1], "end": [169, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.orderOf", "code": "nonrec theorem Disjoint.orderOf {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3\u03c4 : Disjoint \u03c3 \u03c4) :\n    orderOf (\u03c3 * \u03c4) = Nat.lcm (orderOf \u03c3) (orderOf \u03c4)", "start": [172, 1], "end": [179, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.extendDomain", "code": "theorem Disjoint.extendDomain {\u03b1 : Type*} {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p)\n    {\u03c3 \u03c4 : Perm \u03b1} (h : Disjoint \u03c3 \u03c4) : Disjoint (\u03c3.extendDomain f) (\u03c4.extendDomain f)", "start": [182, 1], "end": [190, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_pow_coprime", "code": "theorem support_pow_coprime {\u03c3 : Perm \u03b1} {n : \u2115} (h : Nat.Coprime n (orderOf \u03c3)) :\n    (\u03c3 ^ n).support = \u03c3.support", "start": [199, 1], "end": [204, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.swapFactorsAux", "code": "def swapFactorsAux :\n    \u2200 (l : List \u03b1) (f : Perm \u03b1),\n      (\u2200 {x}, f x \u2260 x \u2192 x \u2208 l) \u2192 { l : List (Perm \u03b1) // l.prod = f \u2227 \u2200 g \u2208 l, IsSwap g }\n  | [] => fun f h =>\n    \u27e8[],\n      Equiv.ext fun x => by\n        rw [List.prod_nil]\n        exact (Classical.not_not.1 (mt h (List.not_mem_nil _))).symm,\n      by simp\u27e9\n  | x::l => fun f h =>\n    if hfx : x = f x then\n      swapFactorsAux l f fun {y} hy =>\n        List.mem_of_ne_of_mem (fun h : y = x => by simp [h, hfx.symm] at hy) (h hy)\n    else\n      let m :=\n        swapFactorsAux l (swap x (f x) * f) fun {y} hy =>\n          have : f y \u2260 y \u2227 y \u2260 x := ne_and_ne_of_swap_mul_apply_ne_self hy\n          List.mem_of_ne_of_mem this.2 (h this.1)\n      \u27e8swap x (f x)::m.1, by\n        rw [List.prod_cons, m.2.1, \u2190 mul_assoc, mul_def (swap x (f x)), swap_swap, \u2190 one_def,\n          one_mul],\n        fun {g} hg => ((List.mem_cons).1 hg).elim (fun h => \u27e8x, f x, hfx, h\u27e9) (m.2.2 _)\u27e9", "start": [209, 1], "end": [232, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.swapFactors", "code": "def swapFactors [Fintype \u03b1] [LinearOrder \u03b1] (f : Perm \u03b1) :\n    { l : List (Perm \u03b1) // l.prod = f \u2227 \u2200 g \u2208 l, IsSwap g } :=\n  swapFactorsAux ((@univ \u03b1 _).sort (\u00b7 \u2264 \u00b7)) f fun {_ _} => (mem_sort _).2 (mem_univ _)", "start": [235, 1], "end": [240, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.truncSwapFactors", "code": "def truncSwapFactors [Fintype \u03b1] (f : Perm \u03b1) :\n    Trunc { l : List (Perm \u03b1) // l.prod = f \u2227 \u2200 g \u2208 l, IsSwap g } :=\n  Quotient.recOnSubsingleton (@univ \u03b1 _).1 (fun l h => Trunc.mk (swapFactorsAux l f (h _)))\n    (show \u2200 x, f x \u2260 x \u2192 x \u2208 (@univ \u03b1 _).1 from fun _ _ => mem_univ _)", "start": [243, 1], "end": [248, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.swap_induction_on", "code": "@[elab_as_elim]\ntheorem swap_induction_on [Finite \u03b1] {P : Perm \u03b1 \u2192 Prop} (f : Perm \u03b1) :\n    P 1 \u2192 (\u2200 f x y, x \u2260 y \u2192 P f \u2192 P (swap x y * f)) \u2192 P f", "start": [251, 1], "end": [265, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_isSwap", "code": "theorem closure_isSwap [Finite \u03b1] : Subgroup.closure { \u03c3 : Perm \u03b1 | IsSwap \u03c3 } = \u22a4", "start": [268, 1], "end": [273, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.swap_induction_on'", "code": "@[elab_as_elim]\ntheorem swap_induction_on' [Finite \u03b1] {P : Perm \u03b1 \u2192 Prop} (f : Perm \u03b1) :\n    P 1 \u2192 (\u2200 f x y, x \u2260 y \u2192 P f \u2192 P (f * swap x y)) \u2192 P f", "start": [276, 1], "end": [283, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isConj_swap", "code": "theorem isConj_swap {w x y z : \u03b1} (hwx : w \u2260 x) (hyz : y \u2260 z) : IsConj (swap w x) (swap y z)", "start": [286, 1], "end": [298, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.finPairsLT", "code": "def finPairsLT (n : \u2115) : Finset (\u03a3_ : Fin n, Fin n) :=\n  (univ : Finset (Fin n)).sigma fun a => (range a).attachFin fun _ hm => (mem_range.1 hm).trans a.2", "start": [301, 1], "end": [303, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_finPairsLT", "code": "theorem mem_finPairsLT {n : \u2115} {a : \u03a3_ : Fin n, Fin n} : a \u2208 finPairsLT n \u2194 a.2 < a.1", "start": [306, 1], "end": [308, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux", "code": "def signAux {n : \u2115} (a : Perm (Fin n)) : \u2124\u02e3 :=\n  \u220f x in finPairsLT n, if a x.1 \u2264 a x.2 then -1 else 1", "start": [311, 1], "end": [314, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_one", "code": "@[simp]\ntheorem signAux_one (n : \u2115) : signAux (1 : Perm (Fin n)) = 1", "start": [317, 1], "end": [321, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signBijAux", "code": "def signBijAux {n : \u2115} (f : Perm (Fin n)) (a : \u03a3_ : Fin n, Fin n) : \u03a3_ : Fin n, Fin n :=\n  if _ : f a.2 < f a.1 then \u27e8f a.1, f a.2\u27e9 else \u27e8f a.2, f a.1\u27e9", "start": [324, 1], "end": [326, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signBijAux_inj", "code": "theorem signBijAux_inj {n : \u2115} {f : Perm (Fin n)} :\n    \u2200 a b : \u03a3_a : Fin n, Fin n,\n      a \u2208 finPairsLT n \u2192 b \u2208 finPairsLT n \u2192 signBijAux f a = signBijAux f b \u2192 a = b", "start": [331, 1], "end": [341, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signBijAux_surj", "code": "theorem signBijAux_surj {n : \u2115} {f : Perm (Fin n)} :\n    \u2200 a \u2208 finPairsLT n, \u2203 (b: \u03a3 (_: Fin n), Fin n) (_H: b \u2208 finPairsLT n), a = signBijAux f b", "start": [344, 1], "end": [357, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signBijAux_mem", "code": "theorem signBijAux_mem {n : \u2115} {f : Perm (Fin n)} :\n    \u2200 a : \u03a3_ : Fin n, Fin n, a \u2208 finPairsLT n \u2192 signBijAux f a \u2208 finPairsLT n", "start": [360, 1], "end": [367, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_inv", "code": "@[simp]\ntheorem signAux_inv {n : \u2115} (f : Perm (Fin n)) : signAux f\u207b\u00b9 = signAux f", "start": [370, 1], "end": [393, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_mul", "code": "theorem signAux_mul {n : \u2115} (f g : Perm (Fin n)) : signAux (f * g) = signAux f * signAux g", "start": [396, 1], "end": [421, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_swap_zero_one'", "code": "private theorem signAux_swap_zero_one' (n : \u2115) : signAux (swap (0 : Fin (n + 2)) 1) = -1", "start": [424, 1], "end": [446, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_swap_zero_one", "code": "private theorem signAux_swap_zero_one {n : \u2115} (hn : 2 \u2264 n) :\n    signAux (swap (\u27e80, lt_of_lt_of_le (by decide) hn\u27e9 : Fin n) \u27e81, lt_of_lt_of_le (by decide) hn\u27e9) =\n      -1", "start": [448, 1], "end": [454, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_swap", "code": "theorem signAux_swap : \u2200 {n : \u2115} {x y : Fin n} (_hxy : x \u2260 y), signAux (swap x y) = -1", "start": [456, 1], "end": [466, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux2", "code": "def signAux2 : List \u03b1 \u2192 Perm \u03b1 \u2192 \u2124\u02e3\n  | [], _ => 1\n  | x::l, f => if x = f x then signAux2 l f else -signAux2 l (swap x (f x) * f)", "start": [469, 1], "end": [473, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux_eq_signAux2", "code": "theorem signAux_eq_signAux2 {n : \u2115} :\n    \u2200 (l : List \u03b1) (f : Perm \u03b1) (e : \u03b1 \u2243 Fin n) (_h : \u2200 x, f x \u2260 x \u2192 x \u2208 l),\n      signAux ((e.symm.trans f).trans e) = signAux2 l f", "start": [476, 1], "end": [501, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux3", "code": "def signAux3 [Fintype \u03b1] (f : Perm \u03b1) {s : Multiset \u03b1} : (\u2200 x, x \u2208 s) \u2192 \u2124\u02e3 :=\n  Quotient.hrecOn s (fun l _ => signAux2 l f)\n    (Trunc.induction_on (Fintype.truncEquivFin \u03b1) fun e l\u2081 l\u2082 h =>\n      Function.hfunext (show (\u2200 x, x \u2208 l\u2081) = \u2200 x, x \u2208 l\u2082 by simp only [h.mem_iff]) fun h\u2081 h\u2082 _ => by\n        rw [\u2190 signAux_eq_signAux2 _ _ e fun _ _ => h\u2081 _,\n            \u2190 signAux_eq_signAux2 _ _ e fun _ _ => h\u2082 _])", "start": [504, 1], "end": [511, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux3_mul_and_swap", "code": "theorem signAux3_mul_and_swap [Fintype \u03b1] (f g : Perm \u03b1) (s : Multiset \u03b1) (hs : \u2200 x, x \u2208 s) :\n    signAux3 (f * g) hs = signAux3 f hs * signAux3 g hs \u2227\n      \u2200 x y, x \u2260 y \u2192 signAux3 (swap x y) hs = -1", "start": [514, 1], "end": [531, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign", "code": "def sign [Fintype \u03b1] : Perm \u03b1 \u2192* \u2124\u02e3 :=\n  MonoidHom.mk' (fun f => signAux3 f mem_univ) fun f g => (signAux3_mul_and_swap f g _ mem_univ).1", "start": [534, 1], "end": [538, 99], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_mul", "code": "theorem sign_mul (f g : Perm \u03b1) : sign (f * g) = sign f * sign g", "start": [546, 1], "end": [547, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_trans", "code": "@[simp]\ntheorem sign_trans (f g : Perm \u03b1) : sign (f.trans g) = sign g * sign f", "start": [550, 1], "end": [552, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_one", "code": "theorem sign_one : sign (1 : Perm \u03b1) = 1", "start": [556, 1], "end": [557, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_refl", "code": "@[simp]\ntheorem sign_refl : sign (Equiv.refl \u03b1) = 1", "start": [560, 1], "end": [562, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_inv", "code": "theorem sign_inv (f : Perm \u03b1) : sign f\u207b\u00b9 = sign f", "start": [566, 1], "end": [567, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_symm", "code": "@[simp]\ntheorem sign_symm (e : Perm \u03b1) : sign e.symm = sign e", "start": [570, 1], "end": [572, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_swap", "code": "theorem sign_swap {x y : \u03b1} (h : x \u2260 y) : sign (swap x y) = -1", "start": [575, 1], "end": [576, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_swap'", "code": "@[simp]\ntheorem sign_swap' {x y : \u03b1} : sign (swap x y) = if x = y then 1 else -1", "start": [579, 1], "end": [581, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsSwap.sign_eq", "code": "theorem IsSwap.sign_eq {f : Perm \u03b1} (h : f.IsSwap) : sign f = -1", "start": [584, 1], "end": [586, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.signAux3_symm_trans_trans", "code": "theorem signAux3_symm_trans_trans [DecidableEq \u03b2] [Fintype \u03b2] (f : Perm \u03b1) (e : \u03b1 \u2243 \u03b2)\n    {s : Multiset \u03b1} {t : Multiset \u03b2} (hs : \u2200 x, x \u2208 s) (ht : \u2200 x, x \u2208 t) :\n    signAux3 ((e.symm.trans f).trans e) ht = signAux3 f hs", "start": [589, 1], "end": [599, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_symm_trans_trans", "code": "@[simp]\ntheorem sign_symm_trans_trans [DecidableEq \u03b2] [Fintype \u03b2] (f : Perm \u03b1) (e : \u03b1 \u2243 \u03b2) :\n    sign ((e.symm.trans f).trans e) = sign f", "start": [602, 1], "end": [605, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_trans_trans_symm", "code": "@[simp]\ntheorem sign_trans_trans_symm [DecidableEq \u03b2] [Fintype \u03b2] (f : Perm \u03b2) (e : \u03b1 \u2243 \u03b2) :\n    sign ((e.trans f).trans e.symm) = sign f", "start": [608, 1], "end": [611, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_prod_list_swap", "code": "theorem sign_prod_list_swap {l : List (Perm \u03b1)} (hl : \u2200 g \u2208 l, IsSwap g) :\n    sign l.prod = (-1) ^ l.length", "start": [614, 1], "end": [621, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_surjective", "code": "theorem sign_surjective [Nontrivial \u03b1] : Function.Surjective (sign : Perm \u03b1 \u2192 \u2124\u02e3)", "start": [626, 1], "end": [629, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.eq_sign_of_surjective_hom", "code": "theorem eq_sign_of_surjective_hom {s : Perm \u03b1 \u2192* \u2124\u02e3} (hs : Surjective s) : s = sign", "start": [634, 1], "end": [656, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_subtypePerm", "code": "theorem sign_subtypePerm (f : Perm \u03b1) {p : \u03b1 \u2192 Prop} [DecidablePred p] (h\u2081 : \u2200 x, p x \u2194 p (f x))\n    (h\u2082 : \u2200 x, f x \u2260 x \u2192 p x) : sign (subtypePerm f h\u2081) = sign f", "start": [659, 1], "end": [672, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_eq_sign_of_equiv", "code": "theorem sign_eq_sign_of_equiv [DecidableEq \u03b2] [Fintype \u03b2] (f : Perm \u03b1) (g : Perm \u03b2) (e : \u03b1 \u2243 \u03b2)\n    (h : \u2200 x, e (f x) = g (e x)) : sign f = sign g", "start": [675, 1], "end": [678, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_bij", "code": "theorem sign_bij [DecidableEq \u03b2] [Fintype \u03b2] {f : Perm \u03b1} {g : Perm \u03b2} (i : \u2200 x : \u03b1, f x \u2260 x \u2192 \u03b2)\n    (h : \u2200 x hx hx', i (f x) hx' = g (i x hx)) (hi : \u2200 x\u2081 x\u2082 hx\u2081 hx\u2082, i x\u2081 hx\u2081 = i x\u2082 hx\u2082 \u2192 x\u2081 = x\u2082)\n    (hg : \u2200 y, g y \u2260 y \u2192 \u2203 x hx, i x hx = y) : sign f = sign g", "start": [681, 1], "end": [700, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prod_prodExtendRight", "code": "theorem prod_prodExtendRight {\u03b1 : Type*} [DecidableEq \u03b1] (\u03c3 : \u03b1 \u2192 Perm \u03b2) {l : List \u03b1}\n    (hl : l.Nodup) (mem_l : \u2200 a, a \u2208 l) :\n    (l.map fun a => prodExtendRight a (\u03c3 a)).prod = prodCongrRight \u03c3", "start": [703, 1], "end": [729, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_prodExtendRight", "code": "@[simp]\ntheorem sign_prodExtendRight (a : \u03b1) (\u03c3 : Perm \u03b2) : sign (prodExtendRight a \u03c3) = sign \u03c3", "start": [736, 1], "end": [742, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_prodCongrRight", "code": "theorem sign_prodCongrRight (\u03c3 : \u03b1 \u2192 Perm \u03b2) : sign (prodCongrRight \u03c3) = \u220f k, sign (\u03c3 k)", "start": [745, 1], "end": [753, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_prodCongrLeft", "code": "theorem sign_prodCongrLeft (\u03c3 : \u03b1 \u2192 Perm \u03b2) : sign (prodCongrLeft \u03c3) = \u220f k, sign (\u03c3 k)", "start": [756, 1], "end": [759, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_permCongr", "code": "@[simp]\ntheorem sign_permCongr (e : \u03b1 \u2243 \u03b2) (p : Perm \u03b1) : sign (e.permCongr p) = sign p", "start": [762, 1], "end": [764, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_sumCongr", "code": "@[simp]\ntheorem sign_sumCongr (\u03c3a : Perm \u03b1) (\u03c3b : Perm \u03b2) : sign (sumCongr \u03c3a \u03c3b) = sign \u03c3a * sign \u03c3b", "start": [767, 1], "end": [779, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_subtypeCongr", "code": "@[simp]\ntheorem sign_subtypeCongr {p : \u03b1 \u2192 Prop} [DecidablePred p] (ep : Perm { a // p a })\n    (en : Perm { a // \u00acp a }) : sign (ep.subtypeCongr en) = sign ep * sign en", "start": [782, 1], "end": [785, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_extendDomain", "code": "@[simp]\ntheorem sign_extendDomain (e : Perm \u03b1) {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p) :\n    Equiv.Perm.sign (e.extendDomain f) = Equiv.Perm.sign e", "start": [788, 1], "end": [791, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_ofSubtype", "code": "@[simp]\ntheorem sign_ofSubtype {p : \u03b1 \u2192 Prop} [DecidablePred p] (f : Equiv.Perm (Subtype p)) :\n    sign (ofSubtype f) = sign f", "start": [794, 1], "end": [797, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/IteSimp.lean", "imports": ["Mathlib/Init/Data/Bool/Basic.lean", "Mathlib/Init/Data/Bool/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "if_true_right_eq_or", "code": "@[simp]\ntheorem if_true_right_eq_or (p : Prop) [h : Decidable p] (q : Prop) :\n    (if p then q else True) = (\u00acp \u2228 q)", "start": [20, 1], "end": [22, 69], "kind": "commanddeclaration"}, {"full_name": "if_true_left_eq_or", "code": "@[simp]\ntheorem if_true_left_eq_or (p : Prop) [h : Decidable p] (q : Prop) :\n    (if p then True else q) = (p \u2228 q)", "start": [25, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "if_false_right_eq_and", "code": "@[simp]\ntheorem if_false_right_eq_and (p : Prop) [h : Decidable p] (q : Prop) :\n    (if p then q else False) = (p \u2227 q)", "start": [30, 1], "end": [32, 69], "kind": "commanddeclaration"}, {"full_name": "if_false_left_eq_and", "code": "@[simp]\ntheorem if_false_left_eq_and (p : Prop) [h : Decidable p] (q : Prop) :\n    (if p then False else q) = (\u00acp \u2227 q)", "start": [35, 1], "end": [37, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Antidiagonal.lean", "imports": ["Mathlib/Data/Multiset/Powerset.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.antidiagonal", "code": "def antidiagonal (s : Multiset \u03b1) : Multiset (Multiset \u03b1 \u00d7 Multiset \u03b1) :=\n  Quot.liftOn s (fun l \u21a6 (revzip (powersetAux l) : Multiset (Multiset \u03b1 \u00d7 Multiset \u03b1)))\n    fun _ _ h \u21a6 Quot.sound (revzip_powersetAux_perm h)", "start": [25, 1], "end": [29, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_coe", "code": "theorem antidiagonal_coe (l : List \u03b1) : @antidiagonal \u03b1 l = revzip (powersetAux l)", "start": [32, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_coe'", "code": "@[simp]\ntheorem antidiagonal_coe' (l : List \u03b1) : @antidiagonal \u03b1 l = revzip (powersetAux' l)", "start": [36, 1], "end": [38, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_antidiagonal", "code": "@[simp]\ntheorem mem_antidiagonal {s : Multiset \u03b1} {x : Multiset \u03b1 \u00d7 Multiset \u03b1} :\n    x \u2208 antidiagonal s \u2194 x.1 + x.2 = s", "start": [43, 1], "end": [55, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_map_fst", "code": "@[simp]\ntheorem antidiagonal_map_fst (s : Multiset \u03b1) : (antidiagonal s).map Prod.fst = powerset s", "start": [58, 1], "end": [60, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_map_snd", "code": "@[simp]\ntheorem antidiagonal_map_snd (s : Multiset \u03b1) : (antidiagonal s).map Prod.snd = powerset s", "start": [63, 1], "end": [65, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_zero", "code": "@[simp]\ntheorem antidiagonal_zero : @antidiagonal \u03b1 0 = {(0, 0)}", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_cons", "code": "@[simp]\ntheorem antidiagonal_cons (a : \u03b1) (s) :\n    antidiagonal (a ::\u2098 s) =\n      map (Prod.map id (cons a)) (antidiagonal s) + map (Prod.map (cons a) id) (antidiagonal s)", "start": [73, 1], "end": [82, 11], "kind": "commanddeclaration"}, {"full_name": "Multiset.antidiagonal_eq_map_powerset", "code": "theorem antidiagonal_eq_map_powerset [DecidableEq \u03b1] (s : Multiset \u03b1) :\n    s.antidiagonal = s.powerset.map fun t \u21a6 (s - t, t)", "start": [85, 1], "end": [94, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_antidiagonal", "code": "@[simp]\ntheorem card_antidiagonal (s : Multiset \u03b1) : card (antidiagonal s) = 2 ^ card s", "start": [97, 1], "end": [100, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_add", "code": "theorem prod_map_add [CommSemiring \u03b2] {s : Multiset \u03b1} {f g : \u03b1 \u2192 \u03b2} :\n    prod (s.map fun a \u21a6 f a + g a) =\n      sum ((antidiagonal s).map fun p \u21a6 (p.1.map f).prod * (p.2.map g).prod)", "start": [103, 1], "end": [112, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/MonoidLocalization.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/Init/Data/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Congruence.lean"], "premises": [{"full_name": "AddSubmonoid.LocalizationMap", "code": "structure LocalizationMap extends AddMonoidHom M N where\n  map_add_units' : \u2200 y : S, IsAddUnit (toFun y)\n  surj' : \u2200 z : N, \u2203 x : M \u00d7 S, z + toFun x.2 = toFun x.1\n  eq_iff_exists' : \u2200 x y, toFun x = toFun y \u2194 \u2203 c : S, \u2191c + x = \u2191c + y", "start": [84, 1], "end": [91, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap", "code": "structure LocalizationMap extends MonoidHom M N where\n  map_units' : \u2200 y : S, IsUnit (toFun y)\n  surj' : \u2200 z : N, \u2203 x : M \u00d7 S, z * toFun x.2 = toFun x.1\n  eq_iff_exists' : \u2200 x y, toFun x = toFun y \u2194 \u2203 c : S, \u2191c * x = c * y", "start": [110, 1], "end": [117, 70], "kind": "commanddeclaration"}, {"full_name": "Localization.r", "code": "@[to_additive AddLocalization.r\n    \"The congruence relation on `M \u00d7 S`, `M` an `AddCommMonoid` and `S` an `add_submonoid` of `M`,\nwhose quotient is the localization of `M` at `S`, defined as the unique congruence relation on\n`M \u00d7 S` such that for any other congruence relation `s` on `M \u00d7 S` where for all `y \u2208 S`,\n`(0, 0) \u223c (y, y)` under `s`, we have that `(x\u2081, y\u2081) \u223c (x\u2082, y\u2082)` by `r` implies\n`(x\u2081, y\u2081) \u223c (x\u2082, y\u2082)` by `s`.\"]\ndef r (S : Submonoid M) : Con (M \u00d7 S) :=\n  sInf { c | \u2200 y : S, c 1 (y, y) }", "start": [140, 1], "end": [152, 35], "kind": "commanddeclaration"}, {"full_name": "Localization.r'", "code": "@[to_additive AddLocalization.r'\n    \"An alternate form of the congruence relation on `M \u00d7 S`, `M` a `CommMonoid` and `S` a\nsubmonoid of `M`, whose quotient is the localization of `M` at `S`.\"]\ndef r' : Con (M \u00d7 S) := by\n  refine\n    { r := fun a b : M \u00d7 S \u21a6 \u2203 c : S, \u2191c * (\u2191b.2 * a.1) = c * (a.2 * b.1)\n      iseqv := \u27e8fun a \u21a6 \u27e81, rfl\u27e9, fun \u27e8c, hc\u27e9 \u21a6 \u27e8c, hc.symm\u27e9, ?_\u27e9\n      mul' := ?_ }\n  \u00b7 rintro a b c \u27e8t\u2081, ht\u2081\u27e9 \u27e8t\u2082, ht\u2082\u27e9\n    use t\u2082 * t\u2081 * b.2\n    simp only [Submonoid.coe_mul]\n    calc\n      (t\u2082 * t\u2081 * b.2 : M) * (c.2 * a.1) = t\u2082 * c.2 * (t\u2081 * (b.2 * a.1)) := by ac_rfl\n      _ = t\u2081 * a.2 * (t\u2082 * (c.2 * b.1)) := by rw [ht\u2081]; ac_rfl\n      _ = t\u2082 * t\u2081 * b.2 * (a.2 * c.1) := by rw [ht\u2082]; ac_rfl\n  \u00b7 rintro a b c d \u27e8t\u2081, ht\u2081\u27e9 \u27e8t\u2082, ht\u2082\u27e9\n    use t\u2082 * t\u2081\n    calc\n      (t\u2082 * t\u2081 : M) * (b.2 * d.2 * (a.1 * c.1)) = t\u2082 * (d.2 * c.1) * (t\u2081 * (b.2 * a.1)) := by ac_rfl\n      _ = (t\u2082 * t\u2081 : M) * (a.2 * c.2 * (b.1 * d.1)) := by rw [ht\u2081, ht\u2082]; ac_rfl", "start": [156, 1], "end": [178, 80], "kind": "commanddeclaration"}, {"full_name": "Localization.r_eq_r'", "code": "@[to_additive AddLocalization.r_eq_r'\n    \"The additive congruence relation used to localize an `AddCommMonoid` at a submonoid can be\nexpressed equivalently as an infimum (see `AddLocalization.r`) or explicitly\n(see `AddLocalization.r'`).\"]\ntheorem r_eq_r' : r S = r' S", "start": [182, 1], "end": [196, 44], "kind": "commanddeclaration"}, {"full_name": "Localization.r_iff_exists", "code": "@[to_additive AddLocalization.r_iff_exists]\ntheorem r_iff_exists {x y : M \u00d7 S} : r S x y \u2194 \u2203 c : S, \u2191c * (\u2191y.2 * x.1) = c * (x.2 * y.1)", "start": [202, 1], "end": [204, 22], "kind": "commanddeclaration"}, {"full_name": "Localization", "code": "@[to_additive AddLocalization\n    \"The localization of an `AddCommMonoid` at one of its submonoids (as a quotient type).\"]\ndef Localization := (Localization.r S).Quotient", "start": [210, 1], "end": [213, 48], "kind": "commanddeclaration"}, {"full_name": "Localization.inhabited", "code": "@[to_additive]\ninstance inhabited : Inhabited (Localization S) := Con.Quotient.inhabited", "start": [219, 1], "end": [220, 74], "kind": "commanddeclaration"}, {"full_name": "Localization.mul", "code": "@[to_additive \"Addition in an `AddLocalization` is defined as `\u27e8a, b\u27e9 + \u27e8c, d\u27e9 = \u27e8a + c, b + d\u27e9`.\nShould not be confused with the ring localization counterpart `Localization.add`, which maps\n`\u27e8a, b\u27e9 + \u27e8c, d\u27e9` to `\u27e8d * a + b * c, b * d\u27e9`.\"]\nprotected irreducible_def mul : Localization S \u2192 Localization S \u2192 Localization S :=\n  (r S).commMonoid.mul", "start": [224, 1], "end": [229, 23], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.one", "code": "@[to_additive \"The identity element of an `AddLocalization` is defined as `\u27e80, 0\u27e9`.\n\nShould not be confused with the ring localization counterpart `Localization.zero`,\nwhich is defined as `\u27e80, 1\u27e9`.\"]\nprotected irreducible_def one : Localization S := (r S).commMonoid.one", "start": [236, 1], "end": [241, 71], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.npow", "code": "@[to_additive \"Multiplication with a natural in an `AddLocalization` is defined as\n`n \u2022 \u27e8a, b\u27e9 = \u27e8n \u2022 a, n \u2022 b\u27e9`.\n\nThis is a separate `irreducible` def to ensure the elaborator doesn't waste its time\ntrying to unify some huge recursive definition with itself, but unfolded one step less.\"]\nprotected irreducible_def npow : \u2115 \u2192 Localization S \u2192 Localization S := (r S).commMonoid.npow", "start": [248, 1], "end": [258, 94], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.commMonoid", "code": "@[to_additive]\ninstance commMonoid : CommMonoid (Localization S) where\n  mul := (\u00b7 * \u00b7)\n  one := 1\n  mul_assoc x y z := show (x.mul S y).mul S z = x.mul S (y.mul S z) by\n    rw [Localization.mul]; apply (r S).commMonoid.mul_assoc\n  mul_comm x y := show x.mul S y = y.mul S x by\n    rw [Localization.mul]; apply (r S).commMonoid.mul_comm\n  mul_one x := show x.mul S (.one S) = x by\n    rw [Localization.mul, Localization.one]; apply (r S).commMonoid.mul_one\n  one_mul x := show (Localization.one S).mul S x = x by\n    rw [Localization.mul, Localization.one]; apply (r S).commMonoid.one_mul\n  npow := Localization.npow S\n  npow_zero x := show Localization.npow S 0 x = .one S by\n    rw [Localization.npow, Localization.one]; apply (r S).commMonoid.npow_zero\n  npow_succ n x := show .npow S n.succ x = x.mul S (.npow S n x) by\n    rw [Localization.npow, Localization.mul]; apply (r S).commMonoid.npow_succ", "start": [262, 1], "end": [278, 79], "kind": "commanddeclaration"}, {"full_name": "Localization.mk", "code": "@[to_additive\n    \"Given an `AddCommMonoid` `M` and submonoid `S`, `mk` sends `x : M`, `y \u2208 S` to\nthe equivalence class of `(x, y)` in the localization of `M` at `S`.\"]\ndef mk (x : M) (y : S) : Localization S := (r S).mk' (x, y)", "start": [282, 1], "end": [287, 60], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_mk_iff", "code": "@[to_additive]\ntheorem mk_eq_mk_iff {a c : M} {b d : S} : mk a b = mk c d \u2194 r S \u27e8a, b\u27e9 \u27e8c, d\u27e9", "start": [291, 1], "end": [292, 91], "kind": "commanddeclaration"}, {"full_name": "Localization.rec", "code": "@[to_additive (attr := elab_as_elim)\n    \"Dependent recursion principle for `AddLocalizations`: given elements `f a b : p (mk a b)`\nfor all `a b`, such that `r S (a, b) (c, d)` implies `f a b = f c d` (with the correct coercions),\nthen `f` is defined on the whole `AddLocalization S`.\"]\ndef rec {p : Localization S \u2192 Sort u} (f : \u2200 (a : M) (b : S), p (mk a b))\n    (H : \u2200 {a c : M} {b d : S} (h : r S (a, b) (c, d)),\n      (Eq.ndrec (f a b) (mk_eq_mk_iff.mpr h) : p (mk c d)) = f c d) (x) : p x :=\n  Quot.rec (fun y \u21a6 Eq.ndrec (f y.1 y.2) (by rfl)) (fun y z h \u21a6 by cases y; cases z; exact H h) x", "start": [298, 1], "end": [308, 98], "kind": "commanddeclaration"}, {"full_name": "Localization.recOnSubsingleton\u2082", "code": "@[to_additive (attr := elab_as_elim) \"Copy of `Quotient.recOnSubsingleton\u2082` for `AddLocalization`\"]\ndef recOnSubsingleton\u2082 {r : Localization S \u2192 Localization S \u2192 Sort u}\n    [h : \u2200 (a c : M) (b d : S), Subsingleton (r (mk a b) (mk c d))] (x y : Localization S)\n    (f : \u2200 (a c : M) (b d : S), r (mk a b) (mk c d)) : r x y :=\n  @Quotient.recOnSubsingleton\u2082' _ _ _ _ r (Prod.rec fun _ _ => Prod.rec fun _ _ => h _ _ _ _) x y\n    (Prod.rec fun _ _ => Prod.rec fun _ _ => f _ _ _ _)", "start": [312, 1], "end": [318, 56], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_mul", "code": "@[to_additive]\ntheorem mk_mul (a c : M) (b d : S) : mk a b * mk c d = mk (a * c) (b * d)", "start": [322, 1], "end": [324, 64], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_one", "code": "@[to_additive]\ntheorem mk_one : mk 1 (1 : S) = 1", "start": [328, 1], "end": [330, 53], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_pow", "code": "@[to_additive]\ntheorem mk_pow (n : \u2115) (a : M) (b : S) : mk a b ^ n = mk (a ^ n) (b ^ n)", "start": [334, 1], "end": [336, 66], "kind": "commanddeclaration"}, {"full_name": "Localization.ndrec_mk", "code": "@[to_additive (attr := simp)]\ntheorem ndrec_mk {p : Localization S \u2192 Sort u} (f : \u2200 (a : M) (b : S), p (mk a b)) (H) (a : M)\n    (b : S) : (rec f H (mk a b) : p (mk a b)) = f a b", "start": [341, 1], "end": [343, 61], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn", "code": "@[to_additive\n    \"Non-dependent recursion principle for `AddLocalization`s: given elements `f a b : p`\nfor all `a b`, such that `r S (a, b) (c, d)` implies `f a b = f c d`,\nthen `f` is defined on the whole `Localization S`.\"]\ndef liftOn {p : Sort u} (x : Localization S) (f : M \u2192 S \u2192 p)\n    (H : \u2200 {a c : M} {b d : S} (_ : r S (a, b) (c, d)), f a b = f c d) : p :=\n  rec f (fun h \u21a6 (by simpa only [eq_rec_constant] using H h)) x", "start": [347, 1], "end": [358, 64], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn_mk", "code": "@[to_additive]\ntheorem liftOn_mk {p : Sort u} (f : \u2200 (_a : M) (_b : S), p) (H) (a : M) (b : S) :\n    liftOn (mk a b) f H = f a b", "start": [362, 1], "end": [364, 39], "kind": "commanddeclaration"}, {"full_name": "Localization.ind", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem ind {p : Localization S \u2192 Prop} (H : \u2200 y : M \u00d7 S, p (mk y.1 y.2)) (x) : p x", "start": [368, 1], "end": [370, 43], "kind": "commanddeclaration"}, {"full_name": "Localization.induction_on", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {p : Localization S \u2192 Prop} (x) (H : \u2200 y : M \u00d7 S, p (mk y.1 y.2)) : p x", "start": [374, 1], "end": [376, 10], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn\u2082", "code": "@[to_additive\n    \"Non-dependent recursion principle for localizations: given elements `f x y : p`\nfor all `x` and `y`, such that `r S x x'` and `r S y y'` implies `f x y = f x' y'`,\nthen `f` is defined on the whole `Localization S`.\"]\ndef liftOn\u2082 {p : Sort u} (x y : Localization S) (f : M \u2192 S \u2192 M \u2192 S \u2192 p)\n    (H : \u2200 {a a' b b' c c' d d'} (_ : r S (a, b) (a', b')) (_ : r S (c, d) (c', d')),\n      f a b c d = f a' b' c' d') : p :=\n  liftOn x (fun a b \u21a6 liftOn y (f a b) fun hy \u21a6 H ((r S).refl _) hy) fun hx \u21a6\n    induction_on y fun \u27e8_, _\u27e9 \u21a6 H hx ((r S).refl _)", "start": [380, 1], "end": [393, 52], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn\u2082_mk", "code": "@[to_additive]\ntheorem liftOn\u2082_mk {p : Sort*} (f : M \u2192 S \u2192 M \u2192 S \u2192 p) (H) (a c : M) (b d : S) :\n    liftOn\u2082 (mk a b) (mk c d) f H = f a b c d", "start": [397, 1], "end": [399, 53], "kind": "commanddeclaration"}, {"full_name": "Localization.induction_on\u2082", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on\u2082 {p : Localization S \u2192 Localization S \u2192 Prop} (x y)\n    (H : \u2200 x y : M \u00d7 S, p (mk x.1 x.2) (mk y.1 y.2)) : p x y", "start": [403, 1], "end": [406, 47], "kind": "commanddeclaration"}, {"full_name": "Localization.induction_on\u2083", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on\u2083 {p : Localization S \u2192 Localization S \u2192 Localization S \u2192 Prop} (x y z)\n    (H : \u2200 x y z : M \u00d7 S, p (mk x.1 x.2) (mk y.1 y.2) (mk z.1 z.2)) : p x y z", "start": [410, 1], "end": [413, 54], "kind": "commanddeclaration"}, {"full_name": "Localization.one_rel", "code": "@[to_additive]\ntheorem one_rel (y : S) : r S 1 (y, y)", "start": [417, 1], "end": [418, 58], "kind": "commanddeclaration"}, {"full_name": "Localization.r_of_eq", "code": "@[to_additive]\ntheorem r_of_eq {x y : M \u00d7 S} (h : \u2191y.2 * x.1 = \u2191x.2 * y.1) : r S x y", "start": [422, 1], "end": [424, 32], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_self", "code": "@[to_additive]\ntheorem mk_self (a : S) : mk (a : M) a = 1", "start": [428, 1], "end": [432, 18], "kind": "commanddeclaration"}, {"full_name": "Localization.smul", "code": "protected irreducible_def smul [SMul R M] [IsScalarTower R M M] (c : R) (z : Localization S) :\n  Localization S :=\n    Localization.liftOn z (fun a b \u21a6 mk (c \u2022 a) b)\n      (fun {a a' b b'} h \u21a6 mk_eq_mk_iff.2 (by\n        cases' b with b hb\n        cases' b' with b' hb'\n        rw [r_eq_r'] at h \u22a2\n        cases' h with t ht\n        use t\n        dsimp only [Subtype.coe_mk] at ht \u22a2\nhaveI : SMulCommClass R M M :=\n          \u27e8fun r m\u2081 m\u2082 \u21a6 by simp_rw [smul_eq_mul, mul_comm m\u2081, smul_mul_assoc]\u27e9\n        simp only [mul_smul_comm, ht]))", "start": [440, 1], "end": [455, 40], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.instSMulLocalization", "code": "instance instSMulLocalization [SMul R M] [IsScalarTower R M M] : SMul R (Localization S) where\n  smul := Localization.smul", "start": [458, 1], "end": [459, 28], "kind": "commanddeclaration"}, {"full_name": "Localization.smul_mk", "code": "theorem smul_mk [SMul R M] [IsScalarTower R M M] (c : R) (a b) :\n    c \u2022 (mk a b : Localization S) = mk (c \u2022 a) b", "start": [461, 1], "end": [465, 49], "kind": "commanddeclaration"}, {"full_name": "Localization.smulCommClass_right", "code": "instance smulCommClass_right {R : Type*} [SMul R M] [IsScalarTower R M M] :\n  SMulCommClass R (Localization S) (Localization S) where\n  smul_comm s :=\n      Localization.ind <|\n        Prod.rec fun r\u2081 x\u2081 \u21a6\n          Localization.ind <|\n            Prod.rec fun r\u2082 x\u2082 \u21a6 by\n              simp only [smul_mk, smul_eq_mul, mk_mul, mul_comm r\u2081, smul_mul_assoc]", "start": [476, 1], "end": [483, 84], "kind": "commanddeclaration"}, {"full_name": "Localization.isScalarTower_right", "code": "instance isScalarTower_right {R : Type*} [SMul R M] [IsScalarTower R M M] :\n  IsScalarTower R (Localization S) (Localization S) where\n  smul_assoc s :=\n    Localization.ind <|\n      Prod.rec fun r\u2081 x\u2081 \u21a6\n        Localization.ind <|\n          Prod.rec fun r\u2082 x\u2082 \u21a6 by simp only [smul_mk, smul_eq_mul, mk_mul, smul_mul_assoc]", "start": [486, 1], "end": [492, 91], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toLocalizationMap", "code": "@[to_additive\n    \"Makes a localization map from an `AddCommMonoid` hom satisfying the characteristic predicate.\"]\ndef toLocalizationMap (f : M \u2192* N) (H1 : \u2200 y : S, IsUnit (f y))\n    (H2 : \u2200 z, \u2203 x : M \u00d7 S, z * f x.2 = f x.1) (H3 : \u2200 x y, f x = f y \u2194 \u2203 c : S, \u2191c * x = \u2191c * y) :\n    Submonoid.LocalizationMap S N :=\n  { f with\n    map_units' := H1\n    surj' := H2\n    eq_iff_exists' := H3 }", "start": [528, 1], "end": [537, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.toMap", "code": "@[to_additive \"Short for `toAddMonoidHom`; used to apply a localization map as a function.\"]\nabbrev toMap (f : LocalizationMap S N) := f.toMonoidHom", "start": [547, 1], "end": [549, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext {f g : LocalizationMap S N} (h : \u2200 x, f.toMap x = g.toMap x) : f = g", "start": [553, 1], "end": [558, 21], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ext_iff", "code": "@[to_additive]\ntheorem ext_iff {f g : LocalizationMap S N} : f = g \u2194 \u2200 x, f.toMap x = g.toMap x", "start": [562, 1], "end": [564, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.toMap_injective", "code": "@[to_additive]\ntheorem toMap_injective : Function.Injective (@LocalizationMap.toMap _ _ S N _)", "start": [568, 1], "end": [570, 41], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_units", "code": "@[to_additive]\ntheorem map_units (f : LocalizationMap S N) (y : S) : IsUnit (f.toMap y)", "start": [574, 1], "end": [576, 8], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.surj", "code": "@[to_additive]\ntheorem surj (f : LocalizationMap S N) (z : N) : \u2203 x : M \u00d7 S, z * f.toMap x.2 = f.toMap x.1", "start": [580, 1], "end": [582, 8], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq_iff_exists", "code": "@[to_additive]\ntheorem eq_iff_exists (f : LocalizationMap S N) {x y} :\n    f.toMap x = f.toMap y \u2194 \u2203 c : S, \u2191c * x = c * y", "start": [586, 1], "end": [588, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.sec", "code": "@[to_additive\n    \"Given a localization map `f : M \u2192+ N`, a section function sending `z : N`\nto some `(x, y) : M \u00d7 S` such that `f x - f y = z`.\"]\nnoncomputable def sec (f : LocalizationMap S N) (z : N) : M \u00d7 S := Classical.choose <| f.surj z", "start": [592, 1], "end": [597, 96], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.sec_spec", "code": "@[to_additive]\ntheorem sec_spec {f : LocalizationMap S N} (z : N) :\n    z * f.toMap (f.sec z).2 = f.toMap (f.sec z).1", "start": [601, 1], "end": [603, 87], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.sec_spec'", "code": "@[to_additive]\ntheorem sec_spec' {f : LocalizationMap S N} (z : N) :\n    f.toMap (f.sec z).1 = f.toMap (f.sec z).2 * z", "start": [607, 1], "end": [609, 80], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mul_inv_left", "code": "@[to_additive\n    \"Given an AddMonoidHom `f : M \u2192+ N` and Submonoid `S \u2286 M` such that\n`f(S) \u2286 AddUnits N`, for all `w, z : N` and `y \u2208 S`, we have `w - f y = z \u2194 w = f y + z`.\"]\ntheorem mul_inv_left {f : M \u2192* N} (h : \u2200 y : S, IsUnit (f y)) (y : S) (w z : N) :\n    w * (IsUnit.liftRight (f.restrict S) h y)\u207b\u00b9 = z \u2194 w = f y * z", "start": [613, 1], "end": [621, 74], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mul_inv_right", "code": "@[to_additive\n    \"Given an AddMonoidHom `f : M \u2192+ N` and Submonoid `S \u2286 M` such that\n`f(S) \u2286 AddUnits N`, for all `w, z : N` and `y \u2208 S`, we have `z = w - f y \u2194 z + f y = w`.\"]\ntheorem mul_inv_right {f : M \u2192* N} (h : \u2200 y : S, IsUnit (f y)) (y : S) (w z : N) :\n    z = w * (IsUnit.liftRight (f.restrict S) h y)\u207b\u00b9 \u2194 z * f y = w", "start": [625, 1], "end": [632, 50], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mul_inv", "code": "@[to_additive (attr := simp)\n    \"Given an AddMonoidHom `f : M \u2192+ N` and Submonoid `S \u2286 M` such that\n`f(S) \u2286 AddUnits N`, for all `x\u2081 x\u2082 : M` and `y\u2081, y\u2082 \u2208 S`, we have\n`f x\u2081 - f y\u2081 = f x\u2082 - f y\u2082 \u2194 f (x\u2081 + y\u2082) = f (x\u2082 + y\u2081)`.\"]\ntheorem mul_inv {f : M \u2192* N} (h : \u2200 y : S, IsUnit (f y)) {x\u2081 x\u2082} {y\u2081 y\u2082 : S} :\n    f x\u2081 * (IsUnit.liftRight (f.restrict S) h y\u2081)\u207b\u00b9 =\n        f x\u2082 * (IsUnit.liftRight (f.restrict S) h y\u2082)\u207b\u00b9 \u2194\n      f (x\u2081 * y\u2082) = f (x\u2082 * y\u2081)", "start": [636, 1], "end": [648, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.inv_inj", "code": "@[to_additive\n    \"Given an AddMonoidHom `f : M \u2192+ N` and Submonoid `S \u2286 M` such that\n`f(S) \u2286 AddUnits N`, for all `y, z \u2208 S`, we have `- (f y) = - (f z) \u2192 f y = f z`.\"]\ntheorem inv_inj {f : M \u2192* N} (hf : \u2200 y : S, IsUnit (f y)) {y z : S}\n    (h : (IsUnit.liftRight (f.restrict S) hf y)\u207b\u00b9 = (IsUnit.liftRight (f.restrict S) hf z)\u207b\u00b9) :\n      f y = f z", "start": [652, 1], "end": [661, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.inv_unique", "code": "@[to_additive\n    \"Given an AddMonoidHom `f : M \u2192+ N` and Submonoid `S \u2286 M` such that\n`f(S) \u2286 AddUnits N`, for all `y \u2208 S`, `- (f y)` is unique.\"]\ntheorem inv_unique {f : M \u2192* N} (h : \u2200 y : S, IsUnit (f y)) {y : S} {z : N} (H : f y * z = 1) :\n    (IsUnit.liftRight (f.restrict S) h y)\u207b\u00b9 = z", "start": [665, 1], "end": [673, 15], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_right_cancel", "code": "@[to_additive]\ntheorem map_right_cancel {x y} {c : S} (h : f.toMap (c * x) = f.toMap (c * y)) :\n    f.toMap x = f.toMap y", "start": [679, 1], "end": [685, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_left_cancel", "code": "@[to_additive]\ntheorem map_left_cancel {x y} {c : S} (h : f.toMap (x * c) = f.toMap (y * c)) :\n    f.toMap x = f.toMap y", "start": [689, 1], "end": [692, 62], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'", "code": "@[to_additive\n      \"Given a localization map `f : M \u2192+ N`, the surjection sending `(x, y) : M \u00d7 S`\nto `f x - f y`.\"]\nnoncomputable def mk' (f : LocalizationMap S N) (x : M) (y : S) : N :=\n  f.toMap x * \u2191(IsUnit.liftRight (f.toMap.restrict S) f.map_units y)\u207b\u00b9", "start": [696, 1], "end": [702, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_mul", "code": "@[to_additive]\ntheorem mk'_mul (x\u2081 x\u2082 : M) (y\u2081 y\u2082 : S) : f.mk' (x\u2081 * x\u2082) (y\u2081 * y\u2082) = f.mk' x\u2081 y\u2081 * f.mk' x\u2082 y\u2082", "start": [706, 1], "end": [713, 13], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_one", "code": "@[to_additive]\ntheorem mk'_one (x) : f.mk' x (1 : S) = f.toMap x", "start": [717, 1], "end": [720, 18], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_sec", "code": "@[to_additive (attr := simp)\n    \"Given a localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, for all `z : N`\nwe have that if `x : M, y \u2208 S` are such that `z + f y = f x`, then `f x - f y = z`.\"]\ntheorem mk'_sec (z : N) : f.mk' (f.sec z).1 (f.sec z).2 = z", "start": [724, 1], "end": [730, 60], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_surjective", "code": "@[to_additive]\ntheorem mk'_surjective (z : N) : \u2203 (x : _) (y : S), f.mk' x y = z", "start": [734, 1], "end": [736, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_spec", "code": "@[to_additive]\ntheorem mk'_spec (x) (y : S) : f.mk' x y * f.toMap y = f.toMap x", "start": [740, 1], "end": [742, 100], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_spec'", "code": "@[to_additive]\ntheorem mk'_spec' (x) (y : S) : f.toMap y * f.mk' x y = f.toMap x", "start": [746, 1], "end": [747, 96], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq_mk'_iff_mul_eq", "code": "@[to_additive]\ntheorem eq_mk'_iff_mul_eq {x} {y : S} {z} : z = f.mk' x y \u2194 z * f.toMap y = f.toMap x", "start": [751, 1], "end": [753, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem mk'_eq_iff_eq_mul {x} {y : S} {z} : f.mk' x y = z \u2194 f.toMap x = z * f.toMap y", "start": [757, 1], "end": [759, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_iff_eq", "code": "@[to_additive]\ntheorem mk'_eq_iff_eq {x\u2081 x\u2082} {y\u2081 y\u2082 : S} :\n    f.mk' x\u2081 y\u2081 = f.mk' x\u2082 y\u2082 \u2194 f.toMap (y\u2082 * x\u2081) = f.toMap (y\u2081 * x\u2082)", "start": [763, 1], "end": [772, 34], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_iff_eq'", "code": "@[to_additive]\ntheorem mk'_eq_iff_eq' {x\u2081 x\u2082} {y\u2081 y\u2082 : S} :\n    f.mk' x\u2081 y\u2081 = f.mk' x\u2082 y\u2082 \u2194 f.toMap (x\u2081 * y\u2082) = f.toMap (x\u2082 * y\u2081)", "start": [776, 1], "end": [779, 40], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq", "code": "@[to_additive]\nprotected theorem eq {a\u2081 b\u2081} {a\u2082 b\u2082 : S} :\n    f.mk' a\u2081 a\u2082 = f.mk' b\u2081 b\u2082 \u2194 \u2203 c : S, \u2191c * (\u2191b\u2082 * a\u2081) = c * (a\u2082 * b\u2081)", "start": [783, 1], "end": [786, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq'", "code": "@[to_additive]\nprotected theorem eq' {a\u2081 b\u2081} {a\u2082 b\u2082 : S} :\n    f.mk' a\u2081 a\u2082 = f.mk' b\u2081 b\u2082 \u2194 Localization.r S (a\u2081, a\u2082) (b\u2081, b\u2082)", "start": [790, 1], "end": [793, 39], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq_iff_eq", "code": "@[to_additive]\ntheorem eq_iff_eq (g : LocalizationMap S P) {x y} : f.toMap x = f.toMap y \u2194 g.toMap x = g.toMap y", "start": [797, 1], "end": [799, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_iff_mk'_eq", "code": "@[to_additive]\ntheorem mk'_eq_iff_mk'_eq (g : LocalizationMap S P) {x\u2081 x\u2082} {y\u2081 y\u2082 : S} :\n    f.mk' x\u2081 y\u2081 = f.mk' x\u2082 y\u2082 \u2194 g.mk' x\u2081 y\u2081 = g.mk' x\u2082 y\u2082", "start": [803, 1], "end": [806, 25], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.exists_of_sec_mk'", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, for all `x\u2081 : M`\nand `y\u2081 \u2208 S`, if `x\u2082 : M, y\u2082 \u2208 S` are such that `(f x\u2081 - f y\u2081) + f y\u2082 = f x\u2082`, then there exists\n`c \u2208 S` such that `x\u2081 + y\u2082 + c = x\u2082 + y\u2081 + c`.\"]\ntheorem exists_of_sec_mk' (x) (y : S) :\n    \u2203 c : S, \u2191c * (\u2191(f.sec <| f.mk' x y).2 * x) = c * (y * (f.sec <| f.mk' x y).1)", "start": [810, 1], "end": [819, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_of_eq", "code": "@[to_additive]\ntheorem mk'_eq_of_eq {a\u2081 b\u2081 : M} {a\u2082 b\u2082 : S} (H : \u2191a\u2082 * b\u2081 = \u2191b\u2082 * a\u2081) :\n    f.mk' a\u2081 a\u2082 = f.mk' b\u2081 b\u2082", "start": [823, 1], "end": [826, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_eq_of_eq'", "code": "@[to_additive]\ntheorem mk'_eq_of_eq' {a\u2081 b\u2081 : M} {a\u2082 b\u2082 : S} (H : b\u2081 * \u2191a\u2082 = a\u2081 * \u2191b\u2082) :\n    f.mk' a\u2081 a\u2082 = f.mk' b\u2081 b\u2082", "start": [830, 1], "end": [833, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_self'", "code": "@[to_additive (attr := simp)]\ntheorem mk'_self' (y : S) : f.mk' (y : M) y = 1", "start": [837, 1], "end": [839, 47], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_self", "code": "@[to_additive (attr := simp)]\ntheorem mk'_self (x) (H : x \u2208 S) : f.mk' x \u27e8x, H\u27e9 = 1", "start": [843, 1], "end": [844, 76], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mul_mk'_eq_mk'_of_mul", "code": "@[to_additive]\ntheorem mul_mk'_eq_mk'_of_mul (x\u2081 x\u2082) (y : S) : f.toMap x\u2081 * f.mk' x\u2082 y = f.mk' (x\u2081 * x\u2082) y", "start": [848, 1], "end": [850, 37], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_mul_eq_mk'_of_mul", "code": "@[to_additive]\ntheorem mk'_mul_eq_mk'_of_mul (x\u2081 x\u2082) (y : S) : f.mk' x\u2082 y * f.toMap x\u2081 = f.mk' (x\u2081 * x\u2082) y", "start": [854, 1], "end": [856, 39], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mul_mk'_one_eq_mk'", "code": "@[to_additive]\ntheorem mul_mk'_one_eq_mk' (x) (y : S) : f.toMap x * f.mk' 1 y = f.mk' x y", "start": [860, 1], "end": [862, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_mul_cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem mk'_mul_cancel_right (x : M) (y : S) : f.mk' (x * y) y = f.toMap x", "start": [866, 1], "end": [868, 96], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mk'_mul_cancel_left", "code": "@[to_additive]\ntheorem mk'_mul_cancel_left (x) (y : S) : f.mk' ((y : M) * x) y = f.toMap x", "start": [872, 1], "end": [874, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.isUnit_comp", "code": "@[to_additive]\ntheorem isUnit_comp (j : N \u2192* P) (y : S) : IsUnit (j.comp f.toMap y)", "start": [878, 1], "end": [881, 96], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.eq_of_eq", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M` and a map of\n`AddCommMonoid`s `g : M \u2192+ P` such that `g(S) \u2286 AddUnits P`, `f x = f y \u2192 g x = g y`\nfor all `x y : M`.\"]\ntheorem eq_of_eq (hg : \u2200 y : S, IsUnit (g y)) {x y} (h : f.toMap x = f.toMap y) : g x = g y", "start": [887, 1], "end": [897, 72], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.comp_eq_of_eq", "code": "@[to_additive\n    \"Given `AddCommMonoid`s `M, P`, Localization maps `f : M \u2192+ N, k : P \u2192+ Q` for Submonoids\n`S, T` respectively, and `g : M \u2192+ P` such that `g(S) \u2286 T`, `f x = f y`\nimplies `k (g x) = k (g y)`.\"]\ntheorem comp_eq_of_eq {T : Submonoid P} {Q : Type*} [CommMonoid Q] (hg : \u2200 y : S, g y \u2208 T)\n    (k : LocalizationMap T Q) {x y} (h : f.toMap x = f.toMap y) : k.toMap (g x) = k.toMap (g y)", "start": [901, 1], "end": [910, 89], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift", "code": "@[to_additive\n    \"Given a localization map `f : M \u2192+ N` for a submonoid `S \u2286 M` and a map of\n`AddCommMonoid`s `g : M \u2192+ P` such that `g y` is invertible for all `y : S`, the homomorphism\ninduced from `N` to `P` sending `z : N` to `g x - g y`, where `(x, y) : M \u00d7 S` are such that\n`z = f x - f y`.\"]\nnoncomputable def lift : N \u2192* P where\n  toFun z := g (f.sec z).1 * (IsUnit.liftRight (g.restrict S) hg (f.sec z).2)\u207b\u00b9\n  map_one' := by rw [mul_inv_left, mul_one]; exact f.eq_of_eq hg (by rw [\u2190 sec_spec, one_mul])\n  map_mul' x y := by\n    dsimp only\n    rw [mul_inv_left hg, \u2190 mul_assoc, \u2190 mul_assoc, mul_inv_right hg, mul_comm _ (g (f.sec y).1), \u2190\n      mul_assoc, \u2190 mul_assoc, mul_inv_right hg]\n    repeat' rw [\u2190 g.map_mul]\n    exact f.eq_of_eq hg (by simp_rw [f.toMap.map_mul, sec_spec']; ac_rfl)", "start": [916, 1], "end": [933, 74], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_mk'", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M` and a map of\n`AddCommMonoid`s `g : M \u2192+ P` such that `g y` is invertible for all `y : S`, the homomorphism\ninduced from `N` to `P` maps `f x - f y` to `g x - g y` for all `x : M, y \u2208 S`.\"]\ntheorem lift_mk' (x y) : f.lift hg (f.mk' x y) = g x * (IsUnit.liftRight (g.restrict S) hg y)\u207b\u00b9", "start": [937, 1], "end": [947, 76], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_spec", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, if an\n`AddCommMonoid` map `g : M \u2192+ P` induces a map `f.lift hg : N \u2192+ P` then for all\n`z : N, v : P`, we have `f.lift hg z = v \u2194 g x = g y + v`, where `x : M, y \u2208 S` are such that\n`z + f y = f x`.\"]\ntheorem lift_spec (z v) : f.lift hg z = v \u2194 g (f.sec z).1 = g (f.sec z).2 * v", "start": [951, 1], "end": [960, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_spec_mul", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, if an `AddCommMonoid` map\n`g : M \u2192+ P` induces a map `f.lift hg : N \u2192+ P` then for all\n`z : N, v w : P`, we have `f.lift hg z + w = v \u2194 g x + w = g y + v`, where `x : M, y \u2208 S` are such\nthat `z + f y = f x`.\"]\ntheorem lift_spec_mul (z w v) : f.lift hg z * w = v \u2194 g (f.sec z).1 * w = g (f.sec z).2 * v", "start": [964, 1], "end": [974, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_mk'_spec", "code": "@[to_additive]\ntheorem lift_mk'_spec (x v) (y : S) : f.lift hg (f.mk' x y) = v \u2194 g x = g y * v", "start": [978, 1], "end": [980, 50], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_mul_right", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, if an `AddCommMonoid`\nmap `g : M \u2192+ P` induces a map `f.lift hg : N \u2192+ P` then for all `z : N`, we have\n`f.lift hg z + g y = g x`, where `x : M, y \u2208 S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_right (z) : f.lift hg z * g (f.sec z).2 = g (f.sec z).1", "start": [984, 1], "end": [992, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_mul_left", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S \u2286 M`, if an `AddCommMonoid` map\n`g : M \u2192+ P` induces a map `f.lift hg : N \u2192+ P` then for all `z : N`, we have\n`g y + f.lift hg z = g x`, where `x : M, y \u2208 S` are such that `z + f y = f x`.\"]\ntheorem lift_mul_left (z) : g (f.sec z).2 * f.lift hg z = g (f.sec z).1", "start": [996, 1], "end": [1004, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_eq", "code": "@[to_additive (attr := simp)]\ntheorem lift_eq (x : M) : f.lift hg (f.toMap x) = g x", "start": [1008, 1], "end": [1010, 88], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_eq_iff", "code": "@[to_additive]\ntheorem lift_eq_iff {x y : M \u00d7 S} :\n    f.lift hg (f.mk' x.1 x.2) = f.lift hg (f.mk' y.1 y.2) \u2194 g (x.1 * y.2) = g (y.1 * x.2)", "start": [1014, 1], "end": [1017, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_comp", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp : (f.lift hg).comp f.toMap = g", "start": [1021, 1], "end": [1022, 81], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_of_comp", "code": "@[to_additive (attr := simp)]\ntheorem lift_of_comp (j : N \u2192* P) : f.lift (f.isUnit_comp j) = j", "start": [1026, 1], "end": [1031, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.epic_of_localizationMap", "code": "@[to_additive]\ntheorem epic_of_localizationMap {j k : N \u2192* P} (h : \u2200 a, j.comp f.toMap a = k.comp f.toMap a) :\n    j = k", "start": [1035, 1], "end": [1039, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_unique", "code": "@[to_additive]\ntheorem lift_unique {j : N \u2192* P} (hj : \u2200 x, j (f.toMap x) = g x) : f.lift hg = j", "start": [1043, 1], "end": [1048, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_id", "code": "@[to_additive (attr := simp)]\ntheorem lift_id (x) : f.lift f.map_units x = x", "start": [1052, 1], "end": [1054, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_left_inverse", "code": "@[to_additive (attr := simp)\n    \"Given two Localization maps `f : M \u2192+ N, k : M \u2192+ P` for a Submonoid `S \u2286 M`, the hom\nfrom `P` to `N` induced by `f` is left inverse to the hom from `N` to `P` induced by `k`.\"]\ntheorem lift_left_inverse {k : LocalizationMap S P} (z : N) :\n    k.lift f.map_units (f.lift k.map_units z) = z", "start": [1058, 1], "end": [1078, 9], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_surjective_iff", "code": "@[to_additive]\ntheorem lift_surjective_iff :\n    Function.Surjective (f.lift hg) \u2194 \u2200 v : P, \u2203 x : M \u00d7 S, v * g x.2 = g x.1", "start": [1082, 1], "end": [1095, 51], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.lift_injective_iff", "code": "@[to_additive]\ntheorem lift_injective_iff :\n    Function.Injective (f.lift hg) \u2194 \u2200 x y, f.toMap x = f.toMap y \u2194 g x = g y", "start": [1099, 1], "end": [1113, 66], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map", "code": "@[to_additive\n    \"Given an `AddCommMonoid` homomorphism `g : M \u2192+ P` where for Submonoids `S \u2286 M, T \u2286 P` we have\n`g(S) \u2286 T`, the induced AddMonoid homomorphism from the Localization of `M` at `S` to the\nLocalization of `P` at `T`: if `f : M \u2192+ N` and `k : P \u2192+ Q` are Localization maps for `S` and\n`T` respectively, we send `z : N` to `k (g x) - k (g y)`, where `(x, y) : M \u00d7 S` are such\nthat `z = f x - f y`.\"]\nnoncomputable def map : N \u2192* Q :=\n  @lift _ _ _ _ _ _ _ f (k.toMap.comp g) fun y \u21a6 k.map_units \u27e8g y, hy y\u27e9", "start": [1120, 1], "end": [1132, 73], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_eq", "code": "@[to_additive]\ntheorem map_eq (x) : f.map hy k (f.toMap x) = k.toMap (g x)", "start": [1138, 1], "end": [1140, 48], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_comp", "code": "@[to_additive (attr := simp)]\ntheorem map_comp : (f.map hy k).comp f.toMap = k.toMap.comp g", "start": [1144, 1], "end": [1146, 46], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_mk'", "code": "@[to_additive]\ntheorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) \u27e8g y, hy y\u27e9", "start": [1150, 1], "end": [1155, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_spec", "code": "@[to_additive\n    \"Given Localization maps `f : M \u2192+ N, k : P \u2192+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M \u2192+ P` induces a `f.map hy k : N \u2192+ Q`, then for all `z : N`,\n`u : Q`, we have `f.map hy k z = u \u2194 k (g x) = k (g y) + u` where `x : M, y \u2208 S` are such that\n`z + f y = f x`.\"]\ntheorem map_spec (z u) : f.map hy k z = u \u2194 k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u", "start": [1159, 1], "end": [1169, 52], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_mul_right", "code": "@[to_additive\n    \"Given Localization maps `f : M \u2192+ N, k : P \u2192+ Q` for Submonoids `S, T` respectively, if an\n`AddCommMonoid` homomorphism `g : M \u2192+ P` induces a `f.map hy k : N \u2192+ Q`, then for all `z : N`,\nwe have `f.map hy k z + k (g y) = k (g x)` where `x : M, y \u2208 S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_right (z) : f.map hy k z * k.toMap (g (f.sec z).2) = k.toMap (g (f.sec z).1)", "start": [1173, 1], "end": [1183, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_mul_left", "code": "@[to_additive\n    \"Given Localization maps `f : M \u2192+ N, k : P \u2192+ Q` for Submonoids `S, T` respectively if an\n`AddCommMonoid` homomorphism `g : M \u2192+ P` induces a `f.map hy k : N \u2192+ Q`, then for all `z : N`,\nwe have `k (g y) + f.map hy k z = k (g x)` where `x : M, y \u2208 S` are such that\n`z + f y = f x`.\"]\ntheorem map_mul_left (z) : k.toMap (g (f.sec z).2) * f.map hy k z = k.toMap (g (f.sec z).1)", "start": [1187, 1], "end": [1197, 33], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id (z : N) : f.map (fun y \u21a6 show MonoidHom.id M y \u2208 S from y.2) f z = z", "start": [1201, 1], "end": [1203, 14], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_comp_map", "code": "@[to_additive\n    \"If `AddCommMonoid` homs `g : M \u2192+ P, l : P \u2192+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l \u2218 g`.\"]\ntheorem map_comp_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P \u2192* A} (hl : \u2200 w : T, l w \u2208 U) :\n    (k.map hl j).comp (f.map hy k) =\n    f.map (fun x \u21a6 show l.comp g x \u2208 U from hl \u27e8g x, hy x\u27e9) j", "start": [1207, 1], "end": [1223, 86], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.map_map", "code": "@[to_additive\n    \"If `AddCommMonoid` homs `g : M \u2192+ P, l : P \u2192+ A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l \u2218 g`.\"]\ntheorem map_map {A : Type*} [CommMonoid A] {U : Submonoid A} {R} [CommMonoid R]\n    (j : LocalizationMap U R) {l : P \u2192* A} (hl : \u2200 w : T, l w \u2208 U) (x) :\n    k.map hl j (f.map hy k x) = f.map (fun x \u21a6 show l.comp g x \u2208 U from hl \u27e8g x, hy x\u27e9) j x", "start": [1227, 1], "end": [1240, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.AwayMap", "code": "@[to_additive (attr := reducible)\n    \"Given `x : M`, the type of `AddCommMonoid` homomorphisms `f : M \u2192+ N` such that `N`\nis isomorphic to the localization of `M` at the AddSubmonoid generated by `x`.\"]\ndef AwayMap (N' : Type*) [CommMonoid N'] := LocalizationMap (powers x) N'", "start": [1248, 1], "end": [1253, 74], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.AwayMap.invSelf", "code": "noncomputable def AwayMap.invSelf : N := F.mk' 1 \u27e8x, mem_powers _\u27e9", "start": [1259, 1], "end": [1260, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.AwayMap.lift", "code": "noncomputable def AwayMap.lift (hg : IsUnit (g x)) : N \u2192* P :=\n  Submonoid.LocalizationMap.lift F fun y \u21a6\n    show IsUnit (g y.1) by\n      obtain \u27e8n, hn\u27e9 := y.2\n      rw [\u2190 hn, g.map_pow]\n      exact IsUnit.pow n hg", "start": [1263, 1], "end": [1271, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.AwayMap.lift_eq", "code": "@[simp]\ntheorem AwayMap.lift_eq (hg : IsUnit (g x)) (a : M) : F.lift x hg (F.toMap a) = g a", "start": [1274, 1], "end": [1276, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.AwayMap.lift_comp", "code": "@[simp]\ntheorem AwayMap.lift_comp (hg : IsUnit (g x)) : (F.lift x hg).comp F.toMap = g", "start": [1279, 1], "end": [1281, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.awayToAwayRight", "code": "noncomputable def awayToAwayRight (y : M) (G : AwayMap (x * y) P) : N \u2192* P :=\n  F.lift x <|\n    show IsUnit (G.toMap x) from\n      isUnit_of_mul_eq_one (G.toMap x) (G.mk' y \u27e8x * y, mem_powers _\u27e9) <| by\n        rw [mul_mk'_eq_mk'_of_mul, mk'_self]", "start": [1284, 1], "end": [1290, 45], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.LocalizationMap.AwayMap.negSelf", "code": "noncomputable def AwayMap.negSelf : B :=\n  F.mk' 0 \u27e8x, mem_multiples _\u27e9", "start": [1308, 1], "end": [1310, 31], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.LocalizationMap.AwayMap.lift", "code": "noncomputable def AwayMap.lift (hg : IsAddUnit (g x)) : B \u2192+ C :=\n  AddSubmonoid.LocalizationMap.lift F fun y \u21a6\n    show IsAddUnit (g y.1) by\n      obtain \u27e8n, hn\u27e9 := y.2\n      rw [\u2190 hn]\n      dsimp\n      rw [g.map_nsmul]\n      exact IsAddUnit.map (nsmulAddMonoidHom n : C \u2192+ C) hg", "start": [1313, 1], "end": [1323, 60], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.LocalizationMap.AwayMap.lift_eq", "code": "@[simp]\ntheorem AwayMap.lift_eq (hg : IsAddUnit (g x)) (a : A) : F.lift x hg (F.toMap a) = g a", "start": [1326, 1], "end": [1328, 45], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.LocalizationMap.AwayMap.lift_comp", "code": "@[simp]\ntheorem AwayMap.lift_comp (hg : IsAddUnit (g x)) : (F.lift x hg).comp F.toMap = g", "start": [1331, 1], "end": [1333, 45], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.LocalizationMap.awayToAwayRight", "code": "noncomputable def awayToAwayRight (y : A) (G : AwayMap (x + y) C) : B \u2192+ C :=\n  F.lift x <|\n    show IsAddUnit (G.toMap x) from\n      isAddUnit_of_add_eq_zero (G.toMap x) (G.mk' y \u27e8x + y, mem_multiples _\u27e9) <| by\n        rw [add_mk'_eq_mk'_of_add, mk'_self]", "start": [1336, 1], "end": [1342, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations", "code": "@[to_additive\n    \"If `f : M \u2192+ N` and `k : M \u2192+ R` are Localization maps for an AddSubmonoid `S`, we get an\nisomorphism of `N` and `R`.\"]\nnoncomputable def mulEquivOfLocalizations (k : LocalizationMap S P) : N \u2243* P :=\n{ toFun := f.lift k.map_units\n  invFun := k.lift f.map_units\n  left_inv := f.lift_left_inverse\n  right_inv := k.lift_left_inverse\n  map_mul' := MonoidHom.map_mul _ }", "start": [1358, 1], "end": [1368, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_apply {k : LocalizationMap S P} {x} :\n    f.mulEquivOfLocalizations k x = f.lift k.map_units x", "start": [1372, 1], "end": [1374, 64], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulEquivOfLocalizations_symm_apply {k : LocalizationMap S P} {x} :\n    (f.mulEquivOfLocalizations k).symm x = k.lift f.map_units x", "start": [1378, 1], "end": [1380, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_symm_eq_mulEquivOfLocalizations", "code": "@[to_additive]\ntheorem mulEquivOfLocalizations_symm_eq_mulEquivOfLocalizations {k : LocalizationMap S P} :\n    (k.mulEquivOfLocalizations f).symm = f.mulEquivOfLocalizations k", "start": [1384, 1], "end": [1386, 76], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations", "code": "@[to_additive\n    \"If `f : M \u2192+ N` is a Localization map for a Submonoid `S` and `k : N \u2243+ P` is an isomorphism\nof `AddCommMonoid`s, `k \u2218 f` is a Localization map for `M` at `S`.\"]\ndef ofMulEquivOfLocalizations (k : N \u2243* P) : LocalizationMap S P :=\n  (k.toMonoidHom.comp f.toMap).toLocalizationMap (fun y \u21a6 isUnit_comp f k.toMonoidHom y)\n    (fun v \u21a6\n      let \u27e8z, hz\u27e9 := k.toEquiv.surjective v\n      let \u27e8x, hx\u27e9 := f.surj z\n      \u27e8x, show v * k _ = k _ by rw [\u2190 hx, k.map_mul, \u2190 hz]; rfl\u27e9)\n    fun x y \u21a6 k.apply_eq_iff_eq.trans f.eq_iff_exists", "start": [1390, 1], "end": [1401, 54], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations_apply", "code": "@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_apply {k : N \u2243* P} (x) :\n    (f.ofMulEquivOfLocalizations k).toMap x = k (f.toMap x)", "start": [1405, 1], "end": [1407, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations_eq", "code": "@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq {k : N \u2243* P} :\n    (f.ofMulEquivOfLocalizations k).toMap = k.toMonoidHom.comp f.toMap", "start": [1411, 1], "end": [1413, 78], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.symm_comp_ofMulEquivOfLocalizations_apply", "code": "@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply {k : N \u2243* P} (x) :\n    k.symm ((f.ofMulEquivOfLocalizations k).toMap x) = f.toMap x", "start": [1417, 1], "end": [1419, 99], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.symm_comp_ofMulEquivOfLocalizations_apply'", "code": "@[to_additive]\ntheorem symm_comp_ofMulEquivOfLocalizations_apply' {k : P \u2243* N} (x) :\n    k ((f.ofMulEquivOfLocalizations k.symm).toMap x) = f.toMap x", "start": [1423, 1], "end": [1425, 99], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations_eq_iff_eq", "code": "@[to_additive]\ntheorem ofMulEquivOfLocalizations_eq_iff_eq {k : N \u2243* P} {x y} :\n    (f.ofMulEquivOfLocalizations k).toMap x = y \u2194 f.toMap x = k.symm y", "start": [1429, 1], "end": [1432, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_right_inv", "code": "@[to_additive addEquivOfLocalizations_right_inv]\ntheorem mulEquivOfLocalizations_right_inv (k : LocalizationMap S P) :\n    f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k) = k", "start": [1436, 1], "end": [1439, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_right_inv_apply", "code": "@[to_additive addEquivOfLocalizations_right_inv_apply]\ntheorem mulEquivOfLocalizations_right_inv_apply {k : LocalizationMap S P} {x} :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfLocalizations k)).toMap x = k.toMap x", "start": [1444, 1], "end": [1446, 95], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_left_inv", "code": "@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv (k : N \u2243* P) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) = k", "start": [1450, 1], "end": [1453, 77], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfLocalizations_left_inv_apply", "code": "@[to_additive]\ntheorem mulEquivOfLocalizations_left_inv_apply {k : N \u2243* P} (x) :\n    f.mulEquivOfLocalizations (f.ofMulEquivOfLocalizations k) x = k x", "start": [1458, 1], "end": [1460, 81], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations_id", "code": "@[to_additive (attr := simp)]\ntheorem ofMulEquivOfLocalizations_id : f.ofMulEquivOfLocalizations (MulEquiv.refl N) = f", "start": [1464, 1], "end": [1466, 11], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfLocalizations_comp", "code": "@[to_additive]\ntheorem ofMulEquivOfLocalizations_comp {k : N \u2243* P} {j : P \u2243* Q} :\n    (f.ofMulEquivOfLocalizations (k.trans j)).toMap =\n      j.toMonoidHom.comp (f.ofMulEquivOfLocalizations k).toMap", "start": [1470, 1], "end": [1474, 14], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom", "code": "@[to_additive\n    \"Given `AddCommMonoid`s `M, P` and `AddSubmonoid`s `S \u2286 M, T \u2286 P`, if `f : M \u2192* N` is a\n    Localization map for `S` and `k : P \u2243+ M` is an isomorphism of `AddCommMonoid`s such that\n    `k(T) = S`, `f \u2218 k` is a Localization map for `T`.\"]\ndef ofMulEquivOfDom {k : P \u2243* M} (H : T.map k.toMonoidHom = S) : LocalizationMap T N :=\n  let H' : S.comap k.toMonoidHom = T :=\n    H \u25b8 (SetLike.coe_injective <| T.1.1.preimage_image_eq k.toEquiv.injective)\n  (f.toMap.comp k.toMonoidHom).toLocalizationMap\n    (fun y \u21a6\n      let \u27e8z, hz\u27e9 := f.map_units \u27e8k y, H \u25b8 Set.mem_image_of_mem k y.2\u27e9\n      \u27e8z, hz\u27e9)\n    (fun z \u21a6\n      let \u27e8x, hx\u27e9 := f.surj z\n      let \u27e8v, hv\u27e9 := k.toEquiv.surjective x.1\n      let \u27e8w, hw\u27e9 := k.toEquiv.surjective x.2\n      \u27e8(v, \u27e8w, H' \u25b8 show k w \u2208 S from hw.symm \u25b8 x.2.2\u27e9),\n        show z * f.toMap (k.toEquiv w) = f.toMap (k.toEquiv v) by erw [hv, hw, hx]\u27e9)\n    fun x y \u21a6\n    show f.toMap _ = f.toMap _ \u2194 _ by\n      erw [f.eq_iff_exists]\n      exact\n        \u27e8fun \u27e8c, hc\u27e9 \u21a6\n          let \u27e8d, hd\u27e9 := k.toEquiv.surjective c\n          \u27e8\u27e8d, H' \u25b8 show k d \u2208 S from hd.symm \u25b8 c.2\u27e9, by\n            erw [\u2190 hd, \u2190 k.map_mul, \u2190 k.map_mul] at hc; exact k.toEquiv.injective hc\u27e9,\n          fun \u27e8c, hc\u27e9 \u21a6\n          \u27e8\u27e8k c, H \u25b8 Set.mem_image_of_mem k c.2\u27e9, by\n            erw [\u2190 k.map_mul]; rw [hc, k.map_mul]; rfl\u27e9\u27e9", "start": [1478, 1], "end": [1508, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom_apply", "code": "@[to_additive (attr := simp)]\ntheorem ofMulEquivOfDom_apply {k : P \u2243* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap x = f.toMap (k x)", "start": [1512, 1], "end": [1514, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom_eq", "code": "@[to_additive]\ntheorem ofMulEquivOfDom_eq {k : P \u2243* M} (H : T.map k.toMonoidHom = S) :\n    (f.ofMulEquivOfDom H).toMap = f.toMap.comp k.toMonoidHom", "start": [1518, 1], "end": [1520, 68], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom_comp_symm", "code": "@[to_additive]\ntheorem ofMulEquivOfDom_comp_symm {k : P \u2243* M} (H : T.map k.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k.symm x) = f.toMap x", "start": [1524, 1], "end": [1527, 44], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom_comp", "code": "@[to_additive]\ntheorem ofMulEquivOfDom_comp {k : M \u2243* P} (H : T.map k.symm.toMonoidHom = S) (x) :\n    (f.ofMulEquivOfDom H).toMap (k x) = f.toMap x", "start": [1531, 1], "end": [1533, 95], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.ofMulEquivOfDom_id", "code": "@[to_additive (attr := simp) \"A special case of `f \u2218 id = f`, `f` a Localization map.\"]\ntheorem ofMulEquivOfDom_id :\n    f.ofMulEquivOfDom\n        (show S.map (MulEquiv.refl M).toMonoidHom = S from\n          Submonoid.ext fun x \u21a6 \u27e8fun \u27e8_, hy, h\u27e9 \u21a6 h \u25b8 hy, fun h \u21a6 \u27e8x, h, rfl\u27e9\u27e9) = f", "start": [1537, 1], "end": [1543, 14], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfMulEquiv", "code": "@[to_additive\n    \"Given Localization maps `f : M \u2192+ N, k : P \u2192+ U` for Submonoids `S, T` respectively, an\nisomorphism `j : M \u2243+ P` such that `j(S) = T` induces an isomorphism of localizations `N \u2243+ U`.\"]\nnoncomputable def mulEquivOfMulEquiv (k : LocalizationMap T Q) {j : M \u2243* P}\n    (H : S.map j.toMonoidHom = T) : N \u2243* Q :=\n  f.mulEquivOfLocalizations <| k.ofMulEquivOfDom H", "start": [1547, 1], "end": [1554, 51], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq_map_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulEquivOfMulEquiv_eq_map_apply {k : LocalizationMap T Q} {j : M \u2243* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    f.mulEquivOfMulEquiv k H x =\n      f.map (fun y : S \u21a6 show j.toMonoidHom y \u2208 T from H \u25b8 Set.mem_image_of_mem j y.2) k x", "start": [1558, 1], "end": [1562, 98], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq_map", "code": "@[to_additive]\ntheorem mulEquivOfMulEquiv_eq_map {k : LocalizationMap T Q} {j : M \u2243* P}\n    (H : S.map j.toMonoidHom = T) :\n    (f.mulEquivOfMulEquiv k H).toMonoidHom =\n      f.map (fun y : S \u21a6 show j.toMonoidHom y \u2208 T from H \u25b8 Set.mem_image_of_mem j y.2) k", "start": [1566, 1], "end": [1570, 96], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfMulEquiv_eq", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_eq {k : LocalizationMap T Q} {j : M \u2243* P} (H : S.map j.toMonoidHom = T)\n    (x) :\n    f.mulEquivOfMulEquiv k H (f.toMap x) = k.toMap (j x)", "start": [1574, 1], "end": [1578, 58], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.mulEquivOfMulEquiv_mk'", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfMulEquiv_mk' {k : LocalizationMap T Q} {j : M \u2243* P} (H : S.map j.toMonoidHom = T)\n    (x y) :\n    f.mulEquivOfMulEquiv k H (f.mk' x y) = k.mk' (j x) \u27e8j y, H \u25b8 Set.mem_image_of_mem j y.2\u27e9", "start": [1582, 1], "end": [1586, 61], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.of_mulEquivOfMulEquiv_apply", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem of_mulEquivOfMulEquiv_apply {k : LocalizationMap T Q} {j : M \u2243* P}\n    (H : S.map j.toMonoidHom = T) (x) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap x = k.toMap (j x)", "start": [1590, 1], "end": [1594, 74], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.of_mulEquivOfMulEquiv", "code": "@[to_additive]\ntheorem of_mulEquivOfMulEquiv {k : LocalizationMap T Q} {j : M \u2243* P} (H : S.map j.toMonoidHom = T) :\n    (f.ofMulEquivOfLocalizations (f.mulEquivOfMulEquiv k H)).toMap = k.toMap.comp j.toMonoidHom", "start": [1598, 1], "end": [1601, 51], "kind": "commanddeclaration"}, {"full_name": "Localization.monoidOf", "code": "@[to_additive\n    \"Natural homomorphism sending `x : M`, `M` an `AddCommMonoid`, to the equivalence class of\n`(x, 0)` in the Localization of `M` at a Submonoid.\"]\ndef monoidOf : Submonoid.LocalizationMap S (Localization S) :=\n  { (r S).mk'.comp <| MonoidHom.inl M\n        S with\n    toFun := fun x \u21a6 mk x 1\n    map_one' := mk_one\n    map_mul' := fun x y \u21a6 by dsimp only; rw [mk_mul, mul_one]\n    map_units' := fun y \u21a6\n      isUnit_iff_exists_inv.2 \u27e8mk 1 y, by dsimp only; rw [mk_mul, mul_one, one_mul, mk_self]\u27e9\n    surj' := fun z \u21a6 induction_on z fun x \u21a6\n      \u27e8x, by dsimp only; rw [mk_mul, mul_comm x.fst, \u2190 mk_mul, mk_self, one_mul]\u27e9\n    eq_iff_exists' := fun x y \u21a6\n      mk_eq_mk_iff.trans <|\n        r_iff_exists.trans <|\n          show (\u2203 c : S, \u2191c * (1 * x) = c * (1 * y)) \u2194 _ by rw [one_mul, one_mul] }", "start": [1613, 1], "end": [1631, 84], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_one_eq_monoidOf_mk", "code": "@[to_additive]\ntheorem mk_one_eq_monoidOf_mk (x) : mk x 1 = (monoidOf S).toMap x", "start": [1637, 1], "end": [1638, 73], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_monoidOf_mk'_apply", "code": "@[to_additive]\ntheorem mk_eq_monoidOf_mk'_apply (x y) : mk x y = (monoidOf S).mk' x y", "start": [1642, 1], "end": [1648, 99], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_monoidOf_mk'", "code": "@[to_additive (attr := simp)]\ntheorem mk_eq_monoidOf_mk' : mk = (monoidOf S).mk'", "start": [1652, 1], "end": [1654, 61], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn_mk'", "code": "@[to_additive (attr := simp)]\ntheorem liftOn_mk' {p : Sort u} (f : \u2200 (_ : M) (_ : S), p) (H) (a : M) (b : S) :\n    liftOn ((monoidOf S).mk' a b) f H = f a b", "start": [1660, 1], "end": [1662, 89], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn\u2082_mk'", "code": "@[to_additive (attr := simp)]\ntheorem liftOn\u2082_mk' {p : Sort*} (f : M \u2192 S \u2192 M \u2192 S \u2192 p) (H) (a c : M) (b d : S) :\n    liftOn\u2082 ((monoidOf S).mk' a b) ((monoidOf S).mk' c d) f H = f a b c d", "start": [1666, 1], "end": [1669, 40], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient", "code": "@[to_additive\n    \"Given a Localization map `f : M \u2192+ N` for a Submonoid `S`, we get an isomorphism between\nthe Localization of `M` at `S` as a quotient type and `N`.\"]\nnoncomputable def mulEquivOfQuotient (f : Submonoid.LocalizationMap S N) : Localization S \u2243* N :=\n  (monoidOf S).mulEquivOfLocalizations f", "start": [1675, 1], "end": [1681, 41], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_apply", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfQuotient_apply (x) : mulEquivOfQuotient f x = (monoidOf S).lift f.map_units x", "start": [1688, 1], "end": [1690, 6], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_mk'", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mulEquivOfQuotient_mk' (x y) : mulEquivOfQuotient f ((monoidOf S).mk' x y) = f.mk' x y", "start": [1694, 1], "end": [1696, 30], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_mk", "code": "@[to_additive]\ntheorem mulEquivOfQuotient_mk (x y) : mulEquivOfQuotient f (mk x y) = f.mk' x y", "start": [1700, 1], "end": [1702, 66], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_monoidOf", "code": "@[to_additive]\ntheorem mulEquivOfQuotient_monoidOf (x) : mulEquivOfQuotient f ((monoidOf S).toMap x) = f.toMap x", "start": [1707, 1], "end": [1709, 10], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_symm_mk'", "code": "@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_mk' (x y) :\n    (mulEquivOfQuotient f).symm (f.mk' x y) = (monoidOf S).mk' x y", "start": [1713, 1], "end": [1716, 40], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_symm_mk", "code": "@[to_additive]\ntheorem mulEquivOfQuotient_symm_mk (x y) : (mulEquivOfQuotient f).symm (f.mk' x y) = mk x y", "start": [1720, 1], "end": [1722, 71], "kind": "commanddeclaration"}, {"full_name": "Localization.mulEquivOfQuotient_symm_monoidOf", "code": "@[to_additive (attr := simp)]\ntheorem mulEquivOfQuotient_symm_monoidOf (x) :\n    (mulEquivOfQuotient f).symm (f.toMap x) = (monoidOf S).toMap x", "start": [1726, 1], "end": [1729, 37], "kind": "commanddeclaration"}, {"full_name": "Localization.Away", "code": "@[to_additive (attr := reducible)\n    \"Given `x : M`, the Localization of `M` at the Submonoid generated by `x`, as a quotient.\"]\ndef Away :=\n  Localization (Submonoid.powers x)", "start": [1737, 1], "end": [1741, 36], "kind": "commanddeclaration"}, {"full_name": "Localization.Away.invSelf", "code": "@[to_additive\n    \"Given `x : M`, `negSelf` is `-x` in the Localization (as a quotient type) of `M` at the\nSubmonoid generated by `x`.\"]\ndef Away.invSelf : Away x :=\n  mk 1 \u27e8x, Submonoid.mem_powers _\u27e9", "start": [1745, 1], "end": [1751, 35], "kind": "commanddeclaration"}, {"full_name": "Localization.Away.monoidOf", "code": "@[to_additive (attr := reducible)\n    \"Given `x : M`, the natural hom sending `y : M`, `M` an `AddCommMonoid`, to the equivalence\nclass of `(y, 0)` in the Localization of `M` at the Submonoid generated by `x`.\"]\ndef Away.monoidOf : Submonoid.LocalizationMap.AwayMap x (Away x) :=\n  Localization.monoidOf (Submonoid.powers x)", "start": [1755, 1], "end": [1761, 45], "kind": "commanddeclaration"}, {"full_name": "Localization.Away.mk_eq_monoidOf_mk'", "code": "@[to_additive]\ntheorem Away.mk_eq_monoidOf_mk' : mk = (Away.monoidOf x).mk'", "start": [1766, 1], "end": [1767, 72], "kind": "commanddeclaration"}, {"full_name": "Localization.Away.mulEquivOfQuotient", "code": "@[to_additive\n    \"Given `x : M` and a Localization map `f : M \u2192+ N` away from `x`, we get an isomorphism between\nthe Localization of `M` at the Submonoid generated by `x` as a quotient type and `N`.\"]\nnoncomputable def Away.mulEquivOfQuotient (f : Submonoid.LocalizationMap.AwayMap x N) :\n    Away x \u2243* N :=\n  Localization.mulEquivOfQuotient f", "start": [1771, 1], "end": [1778, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationWithZeroMap", "code": "structure LocalizationWithZeroMap extends LocalizationMap S N where\n  map_zero' : toFun 0 = 0", "start": [1795, 1], "end": [1801, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationWithZeroMap.toMonoidWithZeroHom", "code": "def LocalizationWithZeroMap.toMonoidWithZeroHom (f : LocalizationWithZeroMap S N) : M \u2192*\u2080 N :=\n  { f with }", "start": [1810, 1], "end": [1812, 13], "kind": "commanddeclaration"}, {"full_name": "Localization.zero", "code": "protected irreducible_def zero : Localization S :=\n  mk 0 1", "start": [1819, 1], "end": [1823, 9], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.mk_zero", "code": "theorem mk_zero (x : S) : mk 0 (x : S) = 0", "start": [1830, 1], "end": [1833, 62], "kind": "commanddeclaration"}, {"full_name": "Localization.liftOn_zero", "code": "theorem liftOn_zero {p : Type*} (f : \u2200 (_ : M) (_ : S), p) (H) : liftOn 0 f H = f 0 1", "start": [1842, 1], "end": [1843, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationMap.sec_zero_fst", "code": "@[simp]\ntheorem LocalizationMap.sec_zero_fst {f : LocalizationMap S N} : f.toMap (f.sec 0).fst = 0", "start": [1852, 1], "end": [1854, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.LocalizationWithZeroMap.lift", "code": "noncomputable def lift (f : LocalizationWithZeroMap S N) (g : M \u2192*\u2080 P)\n    (hg : \u2200 y : S, IsUnit (g y)) : N \u2192*\u2080 P :=\n  { @LocalizationMap.lift _ _ _ _ _ _ _ f.toLocalizationMap g.toMonoidHom hg with\n    map_zero' := by\n      erw [LocalizationMap.lift_spec f.toLocalizationMap hg 0 0]\n      rw [mul_zero, \u2190 map_zero g, \u2190 g.toMonoidHom_coe]\n      refine f.toLocalizationMap.eq_of_eq hg ?_\n      rw [LocalizationMap.sec_zero_fst]\n      exact f.toMonoidWithZeroHom.map_zero.symm }", "start": [1859, 1], "end": [1871, 50], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_left_injective", "code": "@[to_additive]\ntheorem mk_left_injective (b : s) : Injective fun a => mk a b", "start": [1884, 1], "end": [1888, 66], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_mk_iff'", "code": "@[to_additive]\ntheorem mk_eq_mk_iff' : mk a\u2081 a\u2082 = mk b\u2081 b\u2082 \u2194 \u2191b\u2082 * a\u2081 = a\u2082 * b\u2081", "start": [1892, 1], "end": [1896, 74], "kind": "commanddeclaration"}, {"full_name": "Localization.decidableEq", "code": "@[to_additive]\ninstance decidableEq [DecidableEq \u03b1] : DecidableEq (Localization s) := fun a b =>\n  Localization.recOnSubsingleton\u2082 a b fun _ _ _ _ => decidable_of_iff' _ mk_eq_mk_iff'", "start": [1900, 1], "end": [1902, 87], "kind": "commanddeclaration"}, {"full_name": "Localization.le", "code": "@[to_additive]\ninstance le : LE (Localization s) :=\n  \u27e8fun a b =>\n    Localization.liftOn\u2082 a b (fun a\u2081 a\u2082 b\u2081 b\u2082 => \u2191b\u2082 * a\u2081 \u2264 a\u2082 * b\u2081)\n      @fun a\u2081 b\u2081 a\u2082 b\u2082 c\u2081 d\u2081 c\u2082 d\u2082 hab hcd => propext $ by\n        obtain \u27e8e, he\u27e9 := r_iff_exists.1 hab\n        obtain \u27e8f, hf\u27e9 := r_iff_exists.1 hcd\n        simp only [mul_right_inj] at he hf\n        dsimp\n        rw [\u2190 mul_le_mul_iff_right, mul_right_comm, \u2190 hf, mul_right_comm, mul_right_comm (a\u2082 : \u03b1),\n          mul_le_mul_iff_right, \u2190 mul_le_mul_iff_left, mul_left_comm, he, mul_left_comm,\n          mul_left_comm (b\u2082 : \u03b1), mul_le_mul_iff_left]\u27e9", "start": [1918, 1], "end": [1929, 56], "kind": "commanddeclaration"}, {"full_name": "Localization.lt", "code": "@[to_additive]\ninstance lt : LT (Localization s) :=\n  \u27e8fun a b =>\n    Localization.liftOn\u2082 a b (fun a\u2081 a\u2082 b\u2081 b\u2082 => \u2191b\u2082 * a\u2081 < a\u2082 * b\u2081)\n      @fun a\u2081 b\u2081 a\u2082 b\u2082 c\u2081 d\u2081 c\u2082 d\u2082 hab hcd => propext $ by\n        obtain \u27e8e, he\u27e9 := r_iff_exists.1 hab\n        obtain \u27e8f, hf\u27e9 := r_iff_exists.1 hcd\n        simp only [mul_right_inj] at he hf\n        dsimp\n        rw [\u2190 mul_lt_mul_iff_right, mul_right_comm, \u2190 hf, mul_right_comm, mul_right_comm (a\u2082 : \u03b1),\n          mul_lt_mul_iff_right, \u2190 mul_lt_mul_iff_left, mul_left_comm, he, mul_left_comm,\n          mul_left_comm (b\u2082 : \u03b1), mul_lt_mul_iff_left]\u27e9", "start": [1931, 1], "end": [1942, 56], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_le_mk", "code": "@[to_additive]\ntheorem mk_le_mk : mk a\u2081 a\u2082 \u2264 mk b\u2081 b\u2082 \u2194 \u2191b\u2082 * a\u2081 \u2264 a\u2082 * b\u2081", "start": [1944, 1], "end": [1946, 10], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_lt_mk", "code": "@[to_additive]\ntheorem mk_lt_mk : mk a\u2081 a\u2082 < mk b\u2081 b\u2082 \u2194 \u2191b\u2082 * a\u2081 < a\u2082 * b\u2081", "start": [1950, 1], "end": [1952, 10], "kind": "commanddeclaration"}, {"full_name": "Localization.partialOrder", "code": "@[to_additive]\ninstance partialOrder : PartialOrder (Localization s) where\n  le := (\u00b7 \u2264 \u00b7)\n  lt := (\u00b7 < \u00b7)\n  le_refl a := Localization.induction_on a fun a => le_rfl\n  le_trans a b c :=\n    Localization.induction_on\u2083 a b c fun a b c hab hbc => by\n      simp only [mk_le_mk] at hab hbc \u22a2\n      refine' le_of_mul_le_mul_left' _\n      \u00b7 exact \u2191b.2\n      rw [mul_left_comm]\n      refine' (mul_le_mul_left' hab _).trans _\n      rwa [mul_left_comm, mul_left_comm (b.2 : \u03b1), mul_le_mul_iff_left]\n  le_antisymm a b := by\n    induction' a using Localization.rec with a\u2081 a\u2082\n    induction' b using Localization.rec with b\u2081 b\u2082\n    simp_rw [mk_le_mk, mk_eq_mk_iff, r_iff_exists]\n    exact fun hab hba => \u27e81, by rw [hab.antisymm hba]\u27e9\n    all_goals intros; rfl\n  lt_iff_le_not_le a b := Localization.induction_on\u2082 a b fun a b => lt_iff_le_not_le", "start": [1957, 1], "end": [1976, 85], "kind": "commanddeclaration"}, {"full_name": "Localization.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance orderedCancelCommMonoid : OrderedCancelCommMonoid (Localization s) :=\n  { Localization.commMonoid s,\n    Localization.partialOrder with\n    mul_le_mul_left := fun a b =>\n      Localization.induction_on\u2082 a b fun a b hab c =>\n        Localization.induction_on c fun c => by\n          simp only [mk_mul, mk_le_mk, Submonoid.coe_mul, mul_mul_mul_comm _ _ c.1] at hab \u22a2\n          exact mul_le_mul_left' hab _\n    le_of_mul_le_mul_left := fun a b c =>\n      Localization.induction_on\u2083 a b c fun a b c hab => by\n        simp only [mk_mul, mk_le_mk, Submonoid.coe_mul, mul_mul_mul_comm _ _ a.1] at hab \u22a2\n        exact le_of_mul_le_mul_left' hab }", "start": [1978, 1], "end": [1990, 43], "kind": "commanddeclaration"}, {"full_name": "Localization.decidableLE", "code": "@[to_additive]\ninstance decidableLE [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] :\n    DecidableRel ((\u00b7 \u2264 \u00b7) : Localization s \u2192 Localization s \u2192 Prop) := fun a b =>\n  Localization.recOnSubsingleton\u2082 a b fun _ _ _ _ => decidable_of_iff' _ mk_le_mk", "start": [1992, 1], "end": [1995, 82], "kind": "commanddeclaration"}, {"full_name": "Localization.decidableLT", "code": "@[to_additive]\ninstance decidableLT [DecidableRel ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] :\n    DecidableRel ((\u00b7 < \u00b7) : Localization s \u2192 Localization s \u2192 Prop) := fun a b =>\n  Localization.recOnSubsingleton\u2082 a b fun _ _ _ _ => decidable_of_iff' _ mk_lt_mk", "start": [1999, 1], "end": [2002, 82], "kind": "commanddeclaration"}, {"full_name": "Localization.mkOrderEmbedding", "code": "@[to_additive (attr := simps!) \"An ordered cancellative monoid injects into its localization by\nsending `a` to `a - b`.\"]\ndef mkOrderEmbedding (b : s) : \u03b1 \u21aao Localization s where\n  toFun a := mk a b\n  inj' := mk_left_injective _\n  map_rel_iff' {a b} := by simp [-mk_eq_monoidOf_mk', mk_le_mk]", "start": [2006, 1], "end": [2012, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Reverse.lean", "imports": ["Mathlib/Data/Polynomial/Eval.lean", "Mathlib/Data/Polynomial/EraseLead.lean", "Mathlib/Data/Polynomial/Degree/TrailingDegree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.revAtFun", "code": "def revAtFun (N i : \u2115) : \u2115 :=\n  ite (i \u2264 N) (N - i) i", "start": [33, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAtFun_invol", "code": "theorem revAtFun_invol {N i : \u2115} : revAtFun N (revAtFun N i) = i", "start": [40, 1], "end": [47, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAtFun_inj", "code": "theorem revAtFun_inj {N : \u2115} : Function.Injective (revAtFun N)", "start": [50, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAt", "code": "def revAt (N : \u2115) : Function.Embedding \u2115 \u2115\n    where\n  toFun i := ite (i \u2264 N) (N - i) i\n  inj' := revAtFun_inj", "start": [55, 1], "end": [62, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAtFun_eq", "code": "@[simp]\ntheorem revAtFun_eq (N i : \u2115) : revAtFun N i = revAt N i", "start": [65, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAt_invol", "code": "@[simp]\ntheorem revAt_invol {N i : \u2115} : (revAt N) (revAt N i) = i", "start": [71, 1], "end": [73, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAt_le", "code": "@[simp]\ntheorem revAt_le {N i : \u2115} (H : i \u2264 N) : revAt N i = N - i", "start": [76, 1], "end": [78, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAt_eq_self_of_lt", "code": "lemma revAt_eq_self_of_lt {N i : \u2115} (h : N < i) : revAt N i = i := by simp [revAt, Nat.not_le.mpr h]", "start": [81, 1], "end": [81, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.revAt_add", "code": "theorem revAt_add {N O n o : \u2115} (hn : n \u2264 N) (ho : o \u2264 O) :\n    revAt (N + O) (n + o) = revAt N n + revAt O o", "start": [83, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.revAt_zero", "code": "theorem revAt_zero (N : \u2115) : revAt N 0 = N", "start": [93, 1], "end": [93, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect", "code": "noncomputable def reflect (N : \u2115) : R[X] \u2192 R[X]\n  | \u27e8f\u27e9 => \u27e8Finsupp.embDomain (revAt N) f\u27e9", "start": [96, 1], "end": [103, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_support", "code": "theorem reflect_support (N : \u2115) (f : R[X]) :\n    (reflect N f).support = Finset.image (revAt N) f.support", "start": [106, 1], "end": [110, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_reflect", "code": "@[simp]\ntheorem coeff_reflect (N : \u2115) (f : R[X]) (i : \u2115) : coeff (reflect N f) i = f.coeff (revAt N i)", "start": [113, 1], "end": [120, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_zero", "code": "@[simp]\ntheorem reflect_zero {N : \u2115} : reflect N (0 : R[X]) = 0", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_eq_zero_iff", "code": "@[simp]\ntheorem reflect_eq_zero_iff {N : \u2115} {f : R[X]} : reflect N (f : R[X]) = 0 \u2194 f = 0", "start": [128, 1], "end": [130, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_add", "code": "@[simp]\ntheorem reflect_add (f g : R[X]) (N : \u2115) : reflect N (f + g) = reflect N f + reflect N g", "start": [133, 1], "end": [136, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_C_mul", "code": "@[simp]\ntheorem reflect_C_mul (f : R[X]) (r : R) (N : \u2115) : reflect N (C r * f) = C r * reflect N f", "start": [139, 1], "end": [142, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_C_mul_X_pow", "code": "theorem reflect_C_mul_X_pow (N n : \u2115) {c : R} : reflect N (C c * X ^ n) = C c * X ^ revAt N n", "start": [147, 1], "end": [156, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_C", "code": "@[simp]\ntheorem reflect_C (r : R) (N : \u2115) : reflect N (C r) = C r * X ^ N", "start": [160, 1], "end": [162, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_monomial", "code": "@[simp]\ntheorem reflect_monomial (N n : \u2115) : reflect N ((X : R[X]) ^ n) = X ^ revAt N n", "start": [166, 1], "end": [168, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_one_X", "code": "@[simp] lemma reflect_one_X : reflect 1 (X : R[X]) = 1 := by\n  simpa using reflect_monomial 1 1 (R := R)", "start": [171, 1], "end": [172, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reflect_mul_induction", "code": "theorem reflect_mul_induction (cf cg : \u2115) :\n    \u2200 N O : \u2115,\n      \u2200 f g : R[X],\n        f.support.card \u2264 cf.succ \u2192\n          g.support.card \u2264 cg.succ \u2192\n            f.natDegree \u2264 N \u2192\n              g.natDegree \u2264 O \u2192 reflect (N + O) (f * g) = reflect N f * reflect O g", "start": [174, 1], "end": [209, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_mul", "code": "@[simp]\ntheorem reflect_mul (f g : R[X]) {F G : \u2115} (Ff : f.natDegree \u2264 F) (Gg : g.natDegree \u2264 G) :\n    reflect (F + G) (f * g) = reflect F f * reflect G g", "start": [212, 1], "end": [215, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_reflect_mul_pow", "code": "theorem eval\u2082_reflect_mul_pow (i : R \u2192+* S) (x : S) [Invertible x] (N : \u2115) (f : R[X])\n    (hf : f.natDegree \u2264 N) : eval\u2082 i (\u215f x) (reflect N f) * x ^ N = eval\u2082 i x f", "start": [222, 1], "end": [233, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_reflect_eq_zero_iff", "code": "theorem eval\u2082_reflect_eq_zero_iff (i : R \u2192+* S) (x : S) [Invertible x] (N : \u2115) (f : R[X])\n    (hf : f.natDegree \u2264 N) : eval\u2082 i (\u215f x) (reflect N f) = 0 \u2194 eval\u2082 i x f = 0", "start": [236, 1], "end": [244, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse", "code": "noncomputable def reverse (f : R[X]) : R[X] :=\n  reflect f.natDegree f", "start": [249, 1], "end": [252, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_reverse", "code": "theorem coeff_reverse (f : R[X]) (n : \u2115) : f.reverse.coeff n = f.coeff (revAt f.natDegree n)", "start": [255, 1], "end": [256, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_reverse", "code": "@[simp]\ntheorem coeff_zero_reverse (f : R[X]) : coeff (reverse f) 0 = leadingCoeff f", "start": [259, 1], "end": [261, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_zero", "code": "@[simp]\ntheorem reverse_zero : reverse (0 : R[X]) = 0", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_eq_zero", "code": "@[simp]\ntheorem reverse_eq_zero : f.reverse = 0 \u2194 f = 0", "start": [269, 1], "end": [270, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_natDegree_le", "code": "theorem reverse_natDegree_le (f : R[X]) : f.reverse.natDegree \u2264 f.natDegree", "start": [273, 1], "end": [278, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_reverse_natDegree_add_natTrailingDegree", "code": "theorem natDegree_eq_reverse_natDegree_add_natTrailingDegree (f : R[X]) :\n    f.natDegree = f.reverse.natDegree + f.natTrailingDegree", "start": [281, 1], "end": [293, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_natDegree", "code": "theorem reverse_natDegree (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree", "start": [296, 1], "end": [297, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_leadingCoeff", "code": "theorem reverse_leadingCoeff (f : R[X]) : f.reverse.leadingCoeff = f.trailingCoeff", "start": [300, 1], "end": [302, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_natTrailingDegree", "code": "theorem reverse_natTrailingDegree (f : R[X]) : f.reverse.natTrailingDegree = 0", "start": [305, 1], "end": [311, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_trailingCoeff", "code": "theorem reverse_trailingCoeff (f : R[X]) : f.reverse.trailingCoeff = f.leadingCoeff", "start": [314, 1], "end": [315, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_mul", "code": "theorem reverse_mul {f g : R[X]} (fg : f.leadingCoeff * g.leadingCoeff \u2260 0) :\n    reverse (f * g) = reverse f * reverse g", "start": [318, 1], "end": [321, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_mul_of_domain", "code": "@[simp]\ntheorem reverse_mul_of_domain {R : Type*} [Ring R] [NoZeroDivisors R] (f g : R[X]) :\n    reverse (f * g) = reverse f * reverse g", "start": [324, 1], "end": [331, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingCoeff_mul", "code": "theorem trailingCoeff_mul {R : Type*} [Ring R] [NoZeroDivisors R] (p q : R[X]) :\n    (p * q).trailingCoeff = p.trailingCoeff * q.trailingCoeff", "start": [334, 1], "end": [337, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_one_reverse", "code": "@[simp]\ntheorem coeff_one_reverse (f : R[X]) : coeff (reverse f) 1 = nextCoeff f", "start": [340, 1], "end": [347, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_C", "code": "@[simp] lemma reverse_C (t : R) :\n    reverse (C t) = C t := by\n  simp [reverse]", "start": [350, 1], "end": [352, 17], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_mul_X", "code": "@[simp] lemma reverse_mul_X (p : R[X]) : reverse (p * X) = reverse p := by\n  nontriviality R\n  rcases eq_or_ne p 0 with rfl | hp\n  \u00b7 simp\n  \u00b7 simp [reverse, hp]", "start": [354, 1], "end": [358, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_X_mul", "code": "@[simp] lemma reverse_X_mul (p : R[X]) : reverse (X * p) = reverse p := by\n  rw [commute_X p, reverse_mul_X]", "start": [360, 1], "end": [361, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_mul_X_pow", "code": "@[simp] lemma reverse_mul_X_pow (p : R[X]) (n : \u2115) : reverse (p * X ^ n) = reverse p := by\n  induction' n with n ih; simp\n  rw [pow_succ', \u2190 mul_assoc, reverse_mul_X, ih]", "start": [363, 1], "end": [365, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_X_pow_mul", "code": "@[simp] lemma reverse_X_pow_mul (p : R[X]) (n : \u2115) : reverse (X ^ n * p) = reverse p := by\n  rw [commute_X_pow p, reverse_mul_X_pow]", "start": [367, 1], "end": [368, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_add_C", "code": "@[simp] lemma reverse_add_C (p : R[X]) (t : R) :\n    reverse (p + C t) = reverse p + C t * X ^ p.natDegree := by\n  simp [reverse]", "start": [370, 1], "end": [372, 17], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.reverse_C_add", "code": "@[simp] lemma reverse_C_add (p : R[X]) (t : R) :\n    reverse (C t + p) = C t * X ^ p.natDegree + reverse p := by\n  rw [add_comm, reverse_add_C, add_comm]", "start": [374, 1], "end": [376, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.eval\u2082_reverse_mul_pow", "code": "theorem eval\u2082_reverse_mul_pow (i : R \u2192+* S) (x : S) [Invertible x] (f : R[X]) :\n    eval\u2082 i (\u215f x) (reverse f) * x ^ f.natDegree = eval\u2082 i x f", "start": [382, 1], "end": [384, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_reverse_eq_zero_iff", "code": "@[simp]\ntheorem eval\u2082_reverse_eq_zero_iff (i : R \u2192+* S) (x : S) [Invertible x] (f : R[X]) :\n    eval\u2082 i (\u215f x) (reverse f) = 0 \u2194 eval\u2082 i x f = 0", "start": [387, 1], "end": [390, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_neg", "code": "@[simp]\ntheorem reflect_neg (f : R[X]) (N : \u2115) : reflect N (-f) = -reflect N f", "start": [401, 1], "end": [403, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reflect_sub", "code": "@[simp]\ntheorem reflect_sub (f g : R[X]) (N : \u2115) : reflect N (f - g) = reflect N f - reflect N g", "start": [406, 1], "end": [408, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.reverse_neg", "code": "@[simp]\ntheorem reverse_neg (f : R[X]) : reverse (-f) = -reverse f", "start": [411, 1], "end": [413, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Division.lean", "imports": ["Mathlib/Data/Finsupp/Order.lean", "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddMonoidAlgebra.divOf", "code": "noncomputable def divOf (x : k[G]) (g : G) : k[G] :=\n  @Finsupp.comapDomain.addMonoidHom _ _ _ _ ((\u00b7 + \u00b7) g) (add_right_injective g) x", "start": [49, 1], "end": [55, 82], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.divOf_apply", "code": "@[simp]\ntheorem divOf_apply (g : G) (x : k[G]) (g' : G) : (x /\u1d52\u1da0 g) g' = x (g + g')", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_divOf", "code": "@[simp]\ntheorem support_divOf (g : G) (x : k[G]) :\n    (x /\u1d52\u1da0 g).support =\n      x.support.preimage ((\u00b7 + \u00b7) g) (Function.Injective.injOn (add_right_injective g) _)", "start": [65, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.zero_divOf", "code": "@[simp]\ntheorem zero_divOf (g : G) : (0 : k[G]) /\u1d52\u1da0 g = 0", "start": [72, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.divOf_zero", "code": "@[simp]\ntheorem divOf_zero (x : k[G]) : x /\u1d52\u1da0 0 = x", "start": [77, 1], "end": [80, 53], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.add_divOf", "code": "theorem add_divOf (x y : k[G]) (g : G) : (x + y) /\u1d52\u1da0 g = x /\u1d52\u1da0 g + y /\u1d52\u1da0 g", "start": [83, 1], "end": [84, 16], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.divOf_add", "code": "theorem divOf_add (x : k[G]) (a b : G) : x /\u1d52\u1da0 (a + b) = x /\u1d52\u1da0 a /\u1d52\u1da0 b", "start": [87, 1], "end": [89, 54], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.divOfHom", "code": "@[simps]\nnoncomputable def divOfHom : Multiplicative G \u2192* AddMonoid.End k[G] where\n  toFun g :=\n    { toFun := fun x => divOf x (Multiplicative.toAdd g)\n      map_zero' := zero_divOf _\n      map_add' := fun x y => add_divOf x y (Multiplicative.toAdd g) }\n  map_one' := AddMonoidHom.ext divOf_zero\n  map_mul' g\u2081 g\u2082 :=\n    AddMonoidHom.ext fun _x =>\n      (congr_arg _ (add_comm (Multiplicative.toAdd g\u2081) (Multiplicative.toAdd g\u2082))).trans\n        (divOf_add _ _ _)", "start": [92, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_mul_divOf", "code": "theorem of'_mul_divOf (a : G) (x : k[G]) : of' k G a * x /\u1d52\u1da0 a = x", "start": [106, 1], "end": [110, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_of'_divOf", "code": "theorem mul_of'_divOf (x : k[G]) (a : G) : x * of' k G a /\u1d52\u1da0 a = x", "start": [113, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_divOf", "code": "theorem of'_divOf (a : G) : of' k G a /\u1d52\u1da0 a = 1", "start": [121, 1], "end": [122, 56], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf", "code": "noncomputable def modOf (x : k[G]) (g : G) : k[G] :=\n  x.filter fun g\u2081 => \u00ac\u2203 g\u2082, g\u2081 = g + g\u2082", "start": [125, 1], "end": [127, 40], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf_apply_of_not_exists_add", "code": "@[simp]\ntheorem modOf_apply_of_not_exists_add (x : k[G]) (g : G) (g' : G)\n    (h : \u00ac\u2203 d, g' = g + d) : (x %\u1d52\u1da0 g) g' = x g'", "start": [132, 1], "end": [135, 33], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf_apply_of_exists_add", "code": "@[simp]\ntheorem modOf_apply_of_exists_add (x : k[G]) (g : G) (g' : G)\n    (h : \u2203 d, g' = g + d) : (x %\u1d52\u1da0 g) g' = 0", "start": [138, 1], "end": [141, 61], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf_apply_add_self", "code": "@[simp]\ntheorem modOf_apply_add_self (x : k[G]) (g : G) (d : G) : (x %\u1d52\u1da0 g) (d + g) = 0", "start": [144, 1], "end": [146, 52], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf_apply_self_add", "code": "theorem modOf_apply_self_add (x : k[G]) (g : G) (d : G) : (x %\u1d52\u1da0 g) (g + d) = 0", "start": [150, 1], "end": [151, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_mul_modOf", "code": "theorem of'_mul_modOf (g : G) (x : k[G]) : of' k G g * x %\u1d52\u1da0 g = 0", "start": [154, 1], "end": [159, 100], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_of'_modOf", "code": "theorem mul_of'_modOf (x : k[G]) (g : G) : x * of' k G g %\u1d52\u1da0 g = 0", "start": [162, 1], "end": [168, 34], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_modOf", "code": "theorem of'_modOf (g : G) : of' k G g %\u1d52\u1da0 g = 0", "start": [171, 1], "end": [172, 56], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.divOf_add_modOf", "code": "theorem divOf_add_modOf (x : k[G]) (g : G) :\n    of' k G g * (x /\u1d52\u1da0 g) + x %\u1d52\u1da0 g = x", "start": [175, 1], "end": [186, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.modOf_add_divOf", "code": "theorem modOf_add_divOf (x : k[G]) (g : G) : x %\u1d52\u1da0 g + of' k G g * (x /\u1d52\u1da0 g) = x", "start": [189, 1], "end": [190, 36], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_dvd_iff_modOf_eq_zero", "code": "theorem of'_dvd_iff_modOf_eq_zero {x : k[G]} {g : G} :\n    of' k G g \u2223 x \u2194 x %\u1d52\u1da0 g = 0", "start": [193, 1], "end": [200, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/PiSystem.lean", "imports": ["Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "Mathlib/Logic/Encodable/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPiSystem", "code": "def IsPiSystem {\u03b1} (C : Set (Set \u03b1)) : Prop :=\n  \u2200\u1d49 (s \u2208 C) (t \u2208 C), (s \u2229 t : Set \u03b1).Nonempty \u2192 s \u2229 t \u2208 C", "start": [63, 1], "end": [67, 59], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.isPiSystem_measurableSet", "code": "theorem isPiSystem_measurableSet {\u03b1 : Type*} [MeasurableSpace \u03b1] :\n    IsPiSystem { s : Set \u03b1 | MeasurableSet s }", "start": [72, 1], "end": [73, 81], "kind": "commanddeclaration"}, {"full_name": "IsPiSystem.singleton", "code": "theorem IsPiSystem.singleton {\u03b1} (S : Set \u03b1) : IsPiSystem ({S} : Set (Set \u03b1))", "start": [78, 1], "end": [81, 27], "kind": "commanddeclaration"}, {"full_name": "IsPiSystem.insert_empty", "code": "theorem IsPiSystem.insert_empty {\u03b1} {S : Set (Set \u03b1)} (h_pi : IsPiSystem S) :\n    IsPiSystem (insert \u2205 S)", "start": [84, 1], "end": [91, 57], "kind": "commanddeclaration"}, {"full_name": "IsPiSystem.insert_univ", "code": "theorem IsPiSystem.insert_univ {\u03b1} {S : Set (Set \u03b1)} (h_pi : IsPiSystem S) :\n    IsPiSystem (insert Set.univ S)", "start": [94, 1], "end": [101, 57], "kind": "commanddeclaration"}, {"full_name": "IsPiSystem.comap", "code": "theorem IsPiSystem.comap {\u03b1 \u03b2} {S : Set (Set \u03b2)} (h_pi : IsPiSystem S) (f : \u03b1 \u2192 \u03b2) :\n    IsPiSystem { s : Set \u03b1 | \u2203 t \u2208 S, f \u207b\u00b9' t = s }", "start": [104, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_iUnion_of_directed_le", "code": "theorem isPiSystem_iUnion_of_directed_le {\u03b1 \u03b9} (p : \u03b9 \u2192 Set (Set \u03b1))\n    (hp_pi : \u2200 n, IsPiSystem (p n)) (hp_directed : Directed (\u00b7 \u2264 \u00b7) p) :\n    IsPiSystem (\u22c3 n, p n)", "start": [115, 1], "end": [123, 51], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_iUnion_of_monotone", "code": "theorem isPiSystem_iUnion_of_monotone {\u03b1 \u03b9} [SemilatticeSup \u03b9] (p : \u03b9 \u2192 Set (Set \u03b1))\n    (hp_pi : \u2200 n, IsPiSystem (p n)) (hp_mono : Monotone p) : IsPiSystem (\u22c3 n, p n)", "start": [126, 1], "end": [128, 74], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_image_Iio", "code": "theorem isPiSystem_image_Iio (s : Set \u03b1) : IsPiSystem (Iio '' s)", "start": [135, 1], "end": [137, 55], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Iio", "code": "theorem isPiSystem_Iio : IsPiSystem (range Iio : Set (Set \u03b1))", "start": [140, 1], "end": [141, 50], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_image_Ioi", "code": "theorem isPiSystem_image_Ioi (s : Set \u03b1) : IsPiSystem (Ioi '' s)", "start": [144, 1], "end": [145, 32], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ioi", "code": "theorem isPiSystem_Ioi : IsPiSystem (range Ioi : Set (Set \u03b1))", "start": [148, 1], "end": [149, 50], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_image_Iic", "code": "theorem isPiSystem_image_Iic (s : Set \u03b1) : IsPiSystem (Iic '' s)", "start": [152, 1], "end": [154, 55], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Iic", "code": "theorem isPiSystem_Iic : IsPiSystem (range Iic : Set (Set \u03b1))", "start": [156, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_image_Ici", "code": "theorem isPiSystem_image_Ici (s : Set \u03b1) : IsPiSystem (Ici '' s)", "start": [160, 1], "end": [161, 32], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ici", "code": "theorem isPiSystem_Ici : IsPiSystem (range Ici : Set (Set \u03b1))", "start": [163, 1], "end": [164, 50], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ixx_mem", "code": "theorem isPiSystem_Ixx_mem {Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1} {p : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (Hne : \u2200 {a b}, (Ixx a b).Nonempty \u2192 p a b)\n    (Hi : \u2200 {a\u2081 b\u2081 a\u2082 b\u2082}, Ixx a\u2081 b\u2081 \u2229 Ixx a\u2082 b\u2082 = Ixx (max a\u2081 a\u2082) (min b\u2081 b\u2082)) (s t : Set \u03b1) :\n    IsPiSystem { S | \u2203\u1d49 (l \u2208 s) (u \u2208 t), p l u \u2227 Ixx l u = S }", "start": [168, 1], "end": [174, 98], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ixx", "code": "theorem isPiSystem_Ixx {Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1} {p : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (Hne : \u2200 {a b}, (Ixx a b).Nonempty \u2192 p a b)\n    (Hi : \u2200 {a\u2081 b\u2081 a\u2082 b\u2082}, Ixx a\u2081 b\u2081 \u2229 Ixx a\u2082 b\u2082 = Ixx (max a\u2081 a\u2082) (min b\u2081 b\u2082)) (f : \u03b9 \u2192 \u03b1)\n    (g : \u03b9' \u2192 \u03b1) : @IsPiSystem \u03b1 { S | \u2203 i j, p (f i) (g j) \u2227 Ixx (f i) (g j) = S }", "start": [178, 1], "end": [182, 90], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ioo_mem", "code": "theorem isPiSystem_Ioo_mem (s t : Set \u03b1) :\n    IsPiSystem { S | \u2203\u1d49 (l \u2208 s) (u \u2208 t), l < u \u2227 Ioo l u = S }", "start": [186, 1], "end": [188, 89], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ioo", "code": "theorem isPiSystem_Ioo (f : \u03b9 \u2192 \u03b1) (g : \u03b9' \u2192 \u03b1) :\n    @IsPiSystem \u03b1 { S | \u2203 l u, f l < g u \u2227 Ioo (f l) (g u) = S }", "start": [192, 1], "end": [194, 85], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ioc_mem", "code": "theorem isPiSystem_Ioc_mem (s t : Set \u03b1) :\n    IsPiSystem { S | \u2203\u1d49 (l \u2208 s) (u \u2208 t), l < u \u2227 Ioc l u = S }", "start": [198, 1], "end": [200, 92], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ioc", "code": "theorem isPiSystem_Ioc (f : \u03b9 \u2192 \u03b1) (g : \u03b9' \u2192 \u03b1) :\n    @IsPiSystem \u03b1 { S | \u2203 i j, f i < g j \u2227 Ioc (f i) (g j) = S }", "start": [204, 1], "end": [206, 88], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ico_mem", "code": "theorem isPiSystem_Ico_mem (s t : Set \u03b1) :\n    IsPiSystem { S | \u2203\u1d49 (l \u2208 s) (u \u2208 t), l < u \u2227 Ico l u = S }", "start": [210, 1], "end": [212, 92], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Ico", "code": "theorem isPiSystem_Ico (f : \u03b9 \u2192 \u03b1) (g : \u03b9' \u2192 \u03b1) :\n    @IsPiSystem \u03b1 { S | \u2203 i j, f i < g j \u2227 Ico (f i) (g j) = S }", "start": [216, 1], "end": [218, 88], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Icc_mem", "code": "theorem isPiSystem_Icc_mem (s t : Set \u03b1) :\n    IsPiSystem { S | \u2203\u1d49 (l \u2208 s) (u \u2208 t), l \u2264 u \u2227 Icc l u = S }", "start": [222, 1], "end": [224, 78], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_Icc", "code": "theorem isPiSystem_Icc (f : \u03b9 \u2192 \u03b1) (g : \u03b9' \u2192 \u03b1) :\n    @IsPiSystem \u03b1 { S | \u2203 i j, f i \u2264 g j \u2227 Icc (f i) (g j) = S }", "start": [228, 1], "end": [230, 74], "kind": "commanddeclaration"}, {"full_name": "generatePiSystem", "code": "inductive generatePiSystem {\u03b1} (S : Set (Set \u03b1)) : Set (Set \u03b1)\n  | base {s : Set \u03b1} (h_s : s \u2208 S) : generatePiSystem S s\n  | inter {s t : Set \u03b1} (h_s : generatePiSystem S s) (h_t : generatePiSystem S t)\n    (h_nonempty : (s \u2229 t).Nonempty) : generatePiSystem S (s \u2229 t)", "start": [235, 1], "end": [240, 65], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_generatePiSystem", "code": "theorem isPiSystem_generatePiSystem {\u03b1} (S : Set (Set \u03b1)) : IsPiSystem (generatePiSystem S)", "start": [243, 1], "end": [244, 74], "kind": "commanddeclaration"}, {"full_name": "subset_generatePiSystem_self", "code": "theorem subset_generatePiSystem_self {\u03b1} (S : Set (Set \u03b1)) : S \u2286 generatePiSystem S", "start": [247, 1], "end": [248, 24], "kind": "commanddeclaration"}, {"full_name": "generatePiSystem_subset_self", "code": "theorem generatePiSystem_subset_self {\u03b1} {S : Set (Set \u03b1)} (h_S : IsPiSystem S) :\n    generatePiSystem S \u2286 S", "start": [251, 1], "end": [255, 37], "kind": "commanddeclaration"}, {"full_name": "generatePiSystem_eq", "code": "theorem generatePiSystem_eq {\u03b1} {S : Set (Set \u03b1)} (h_pi : IsPiSystem S) : generatePiSystem S = S", "start": [258, 1], "end": [259, 91], "kind": "commanddeclaration"}, {"full_name": "generatePiSystem_mono", "code": "theorem generatePiSystem_mono {\u03b1} {S T : Set (Set \u03b1)} (hST : S \u2286 T) :\n    generatePiSystem S \u2286 generatePiSystem T", "start": [262, 1], "end": [266, 63], "kind": "commanddeclaration"}, {"full_name": "generatePiSystem_measurableSet", "code": "theorem generatePiSystem_measurableSet {\u03b1} [M : MeasurableSpace \u03b1] {S : Set (Set \u03b1)}\n    (h_meas_S : \u2200 s \u2208 S, MeasurableSet s) (t : Set \u03b1) (h_in_pi : t \u2208 generatePiSystem S) :\n    MeasurableSet t", "start": [269, 1], "end": [274, 38], "kind": "commanddeclaration"}, {"full_name": "generateFrom_measurableSet_of_generatePiSystem", "code": "theorem generateFrom_measurableSet_of_generatePiSystem {\u03b1} {g : Set (Set \u03b1)} (t : Set \u03b1)\n    (ht : t \u2208 generatePiSystem g) : MeasurableSet[generateFrom g] t", "start": [277, 1], "end": [280, 65], "kind": "commanddeclaration"}, {"full_name": "generateFrom_generatePiSystem_eq", "code": "theorem generateFrom_generatePiSystem_eq {\u03b1} {g : Set (Set \u03b1)} :\n    generateFrom (generatePiSystem g) = generateFrom g", "start": [283, 1], "end": [287, 78], "kind": "commanddeclaration"}, {"full_name": "mem_generatePiSystem_iUnion_elim", "code": "theorem mem_generatePiSystem_iUnion_elim {\u03b1 \u03b2} {g : \u03b2 \u2192 Set (Set \u03b1)} (h_pi : \u2200 b, IsPiSystem (g b))\n    (t : Set \u03b1) (h_t : t \u2208 generatePiSystem (\u22c3 b, g b)) :\n    \u2203 (T : Finset \u03b2) (f : \u03b2 \u2192 Set \u03b1), (t = \u22c2 b \u2208 T, f b) \u2227 \u2200 b \u2208 T, f b \u2208 g b", "start": [293, 1], "end": [321, 42], "kind": "commanddeclaration"}, {"full_name": "mem_generatePiSystem_iUnion_elim'", "code": "theorem mem_generatePiSystem_iUnion_elim' {\u03b1 \u03b2} {g : \u03b2 \u2192 Set (Set \u03b1)} {s : Set \u03b2}\n    (h_pi : \u2200 b \u2208 s, IsPiSystem (g b)) (t : Set \u03b1) (h_t : t \u2208 generatePiSystem (\u22c3 b \u2208 s, g b)) :\n    \u2203 (T : Finset \u03b2) (f : \u03b2 \u2192 Set \u03b1), \u2191T \u2286 s \u2227 (t = \u22c2 b \u2208 T, f b) \u2227 \u2200 b \u2208 T, f b \u2208 g b", "start": [327, 1], "end": [358, 16], "kind": "commanddeclaration"}, {"full_name": "piiUnionInter", "code": "def piiUnionInter (\u03c0 : \u03b9 \u2192 Set (Set \u03b1)) (S : Set \u03b9) : Set (Set \u03b1) :=\n  { s : Set \u03b1 |\n    \u2203 (t : Finset \u03b9) (_ : \u2191t \u2286 S) (f : \u03b9 \u2192 Set \u03b1) (_ : \u2200 x, x \u2208 t \u2192 f x \u2208 \u03c0 x), s = \u22c2 x \u2208 t, f x }", "start": [368, 1], "end": [373, 99], "kind": "commanddeclaration"}, {"full_name": "piiUnionInter_singleton", "code": "theorem piiUnionInter_singleton (\u03c0 : \u03b9 \u2192 Set (Set \u03b1)) (i : \u03b9) :\n    piiUnionInter \u03c0 {i} = \u03c0 i \u222a {univ}", "start": [376, 1], "end": [406, 31], "kind": "commanddeclaration"}, {"full_name": "piiUnionInter_singleton_left", "code": "theorem piiUnionInter_singleton_left (s : \u03b9 \u2192 Set \u03b1) (S : Set \u03b9) :\n    piiUnionInter (fun i => ({s i} : Set (Set \u03b1))) S =\n      { s' : Set \u03b1 | \u2203 (t : Finset \u03b9) (_ : \u2191t \u2286 S), s' = \u22c2 i \u2208 t, s i }", "start": [409, 1], "end": [419, 13], "kind": "commanddeclaration"}, {"full_name": "generateFrom_piiUnionInter_singleton_left", "code": "theorem generateFrom_piiUnionInter_singleton_left (s : \u03b9 \u2192 Set \u03b1) (S : Set \u03b9) :\n    generateFrom (piiUnionInter (fun k => {s k}) S) = generateFrom { t | \u2203 k \u2208 S, s k = t }", "start": [422, 1], "end": [433, 66], "kind": "commanddeclaration"}, {"full_name": "isPiSystem_piiUnionInter", "code": "theorem isPiSystem_piiUnionInter (\u03c0 : \u03b9 \u2192 Set (Set \u03b1)) (hpi : \u2200 x, IsPiSystem (\u03c0 x)) (S : Set \u03b9) :\n    IsPiSystem (piiUnionInter \u03c0 S)", "start": [436, 1], "end": [473, 39], "kind": "commanddeclaration"}, {"full_name": "piiUnionInter_mono_left", "code": "theorem piiUnionInter_mono_left {\u03c0 \u03c0' : \u03b9 \u2192 Set (Set \u03b1)} (h_le : \u2200 i, \u03c0 i \u2286 \u03c0' i) (S : Set \u03b9) :\n    piiUnionInter \u03c0 S \u2286 piiUnionInter \u03c0' S", "start": [476, 1], "end": [478, 64], "kind": "commanddeclaration"}, {"full_name": "piiUnionInter_mono_right", "code": "theorem piiUnionInter_mono_right {\u03c0 : \u03b9 \u2192 Set (Set \u03b1)} {S T : Set \u03b9} (hST : S \u2286 T) :\n    piiUnionInter \u03c0 S \u2286 piiUnionInter \u03c0 T", "start": [481, 1], "end": [483, 46], "kind": "commanddeclaration"}, {"full_name": "generateFrom_piiUnionInter_le", "code": "theorem generateFrom_piiUnionInter_le {m : MeasurableSpace \u03b1} (\u03c0 : \u03b9 \u2192 Set (Set \u03b1))\n    (h : \u2200 n, generateFrom (\u03c0 n) \u2264 m) (S : Set \u03b9) : generateFrom (piiUnionInter \u03c0 S) \u2264 m", "start": [486, 1], "end": [491, 57], "kind": "commanddeclaration"}, {"full_name": "subset_piiUnionInter", "code": "theorem subset_piiUnionInter {\u03c0 : \u03b9 \u2192 Set (Set \u03b1)} {S : Set \u03b9} {i : \u03b9} (his : i \u2208 S) :\n    \u03c0 i \u2286 piiUnionInter \u03c0 S", "start": [494, 1], "end": [502, 30], "kind": "commanddeclaration"}, {"full_name": "mem_piiUnionInter_of_measurableSet", "code": "theorem mem_piiUnionInter_of_measurableSet (m : \u03b9 \u2192 MeasurableSpace \u03b1) {S : Set \u03b9} {i : \u03b9}\n    (hiS : i \u2208 S) (s : Set \u03b1) (hs : MeasurableSet[m i] s) :\n    s \u2208 piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S", "start": [505, 1], "end": [508, 30], "kind": "commanddeclaration"}, {"full_name": "le_generateFrom_piiUnionInter", "code": "theorem le_generateFrom_piiUnionInter {\u03c0 : \u03b9 \u2192 Set (Set \u03b1)} (S : Set \u03b9) {x : \u03b9} (hxS : x \u2208 S) :\n    generateFrom (\u03c0 x) \u2264 generateFrom (piiUnionInter \u03c0 S)", "start": [511, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "measurableSet_iSup_of_mem_piiUnionInter", "code": "theorem measurableSet_iSup_of_mem_piiUnionInter (m : \u03b9 \u2192 MeasurableSpace \u03b1) (S : Set \u03b9) (t : Set \u03b1)\n    (ht : t \u2208 piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) :\n    MeasurableSet[\u2a06 i \u2208 S, m i] t", "start": [516, 1], "end": [523, 55], "kind": "commanddeclaration"}, {"full_name": "generateFrom_piiUnionInter_measurableSet", "code": "theorem generateFrom_piiUnionInter_measurableSet (m : \u03b9 \u2192 MeasurableSpace \u03b1) (S : Set \u03b9) :\n    generateFrom (piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) = \u2a06 i \u2208 S, m i", "start": [526, 1], "end": [533, 70], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem", "code": "structure DynkinSystem (\u03b1 : Type*) where\n  \n  Has : Set \u03b1 \u2192 Prop\n  \n  has_empty : Has \u2205\n  \n  has_compl : \u2200 {a}, Has a \u2192 Has a\u1d9c\n  \n  has_iUnion_nat : \u2200 {f : \u2115 \u2192 Set \u03b1}, Pairwise (Disjoint on f) \u2192 (\u2200 i, Has (f i)) \u2192 Has (\u22c3 i, f i)", "start": [545, 1], "end": [563, 99], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.ext", "code": "@[ext]\ntheorem ext : \u2200 {d\u2081 d\u2082 : DynkinSystem \u03b1}, (\u2200 s : Set \u03b1, d\u2081.Has s \u2194 d\u2082.Has s) \u2192 d\u2081 = d\u2082", "start": [568, 1], "end": [573, 8], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.has_compl_iff", "code": "theorem has_compl_iff {a} : d.Has a\u1d9c \u2194 d.Has a", "start": [578, 1], "end": [579, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.has_univ", "code": "theorem has_univ : d.Has univ", "start": [582, 1], "end": [582, 72], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.has_iUnion", "code": "theorem has_iUnion {\u03b2} [Countable \u03b2] {f : \u03b2 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on f))\n    (h : \u2200 i, d.Has (f i)) : d.Has (\u22c3 i, f i)", "start": [585, 1], "end": [591, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.has_union", "code": "theorem has_union {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : d.Has s\u2081) (h\u2082 : d.Has s\u2082) (h : Disjoint s\u2081 s\u2082) :\n    d.Has (s\u2081 \u222a s\u2082)", "start": [594, 1], "end": [597, 83], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.has_diff", "code": "theorem has_diff {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : d.Has s\u2081) (h\u2082 : d.Has s\u2082) (h : s\u2082 \u2286 s\u2081) :\n    d.Has (s\u2081 \\ s\u2082)", "start": [600, 1], "end": [604, 75], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.instLEDynkinSystem", "code": "instance instLEDynkinSystem : LE (DynkinSystem \u03b1) where le m\u2081 m\u2082 := m\u2081.Has \u2264 m\u2082.Has", "start": [607, 1], "end": [607, 84], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.le_def", "code": "theorem le_def {\u03b1} {a b : DynkinSystem \u03b1} : a \u2264 b \u2194 a.Has \u2264 b.Has", "start": [609, 1], "end": [610, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.ofMeasurableSpace", "code": "def ofMeasurableSpace (m : MeasurableSpace \u03b1) : DynkinSystem \u03b1\n    where\n  Has := m.MeasurableSet'\n  has_empty := m.measurableSet_empty\n  has_compl {a} := m.measurableSet_compl a\n  has_iUnion_nat {f} _ hf := m.measurableSet_iUnion f hf", "start": [619, 1], "end": [625, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.ofMeasurableSpace_le_ofMeasurableSpace_iff", "code": "theorem ofMeasurableSpace_le_ofMeasurableSpace_iff {m\u2081 m\u2082 : MeasurableSpace \u03b1} :\n    ofMeasurableSpace m\u2081 \u2264 ofMeasurableSpace m\u2082 \u2194 m\u2081 \u2264 m\u2082", "start": [628, 1], "end": [630, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.GenerateHas", "code": "inductive GenerateHas (s : Set (Set \u03b1)) : Set \u03b1 \u2192 Prop\n  | basic : \u2200 t \u2208 s, GenerateHas s t\n  | empty : GenerateHas s \u2205\n  | compl : \u2200 {a}, GenerateHas s a \u2192 GenerateHas s a\u1d9c\n  | iUnion : \u2200 {f : \u2115 \u2192 Set \u03b1},\n    Pairwise (Disjoint on f) \u2192 (\u2200 i, GenerateHas s (f i)) \u2192 GenerateHas s (\u22c3 i, f i)", "start": [633, 1], "end": [640, 85], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generateHas_compl", "code": "theorem generateHas_compl {C : Set (Set \u03b1)} {s : Set \u03b1} : GenerateHas C s\u1d9c \u2194 GenerateHas C s", "start": [643, 1], "end": [647, 7], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generate", "code": "def generate (s : Set (Set \u03b1)) : DynkinSystem \u03b1\n    where\n  Has := GenerateHas s\n  has_empty := GenerateHas.empty\n  has_compl {_} := GenerateHas.compl\n  has_iUnion_nat {_} := GenerateHas.iUnion", "start": [650, 1], "end": [656, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generateHas_def", "code": "theorem generateHas_def {C : Set (Set \u03b1)} : (generate C).Has = GenerateHas C", "start": [659, 1], "end": [660, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.toMeasurableSpace", "code": "def toMeasurableSpace (h_inter : \u2200 s\u2081 s\u2082, d.Has s\u2081 \u2192 d.Has s\u2082 \u2192 d.Has (s\u2081 \u2229 s\u2082)) :\n    MeasurableSpace \u03b1 where\n  MeasurableSet' := d.Has\n  measurableSet_empty := d.has_empty\n  measurableSet_compl s h := d.has_compl h\n  measurableSet_iUnion f hf := by\n    rw [\u2190 iUnion_disjointed]\n    exact\n      d.has_iUnion (disjoint_disjointed _) fun n =>\n        disjointedRec (fun (t : Set \u03b1) i h => h_inter _ _ h <| d.has_compl <| hf i) (hf n)", "start": [666, 1], "end": [676, 91], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.ofMeasurableSpace_toMeasurableSpace", "code": "theorem ofMeasurableSpace_toMeasurableSpace\n    (h_inter : \u2200 s\u2081 s\u2082, d.Has s\u2081 \u2192 d.Has s\u2082 \u2192 d.Has (s\u2081 \u2229 s\u2082)) :\n    ofMeasurableSpace (d.toMeasurableSpace h_inter) = d", "start": [679, 1], "end": [682, 23], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.restrictOn", "code": "def restrictOn {s : Set \u03b1} (h : d.Has s) : DynkinSystem \u03b1 where\n  Has t := d.Has (t \u2229 s)\n  has_empty := by simp [d.has_empty]\n  has_compl {t} hts := by\n    simp only []\n    have : t\u1d9c \u2229 s = (t \u2229 s)\u1d9c \\ s\u1d9c := Set.ext fun x => by by_cases h : x \u2208 s <;> simp [h]\n    rw [this]\n    exact\n      d.has_diff (d.has_compl hts) (d.has_compl h)\n        (compl_subset_compl.mpr <| inter_subset_right _ _)\n  has_iUnion_nat {f} hd hf := by\n    simp only []\n    rw [iUnion_inter]\n    refine' d.has_iUnion_nat _ hf\n    exact hd.mono fun i j => Disjoint.mono (inter_subset_left _ _) (inter_subset_left _ _)", "start": [685, 1], "end": [701, 91], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generate_le", "code": "theorem generate_le {s : Set (Set \u03b1)} (h : \u2200 t \u2208 s, d.Has t) : generate s \u2264 d", "start": [704, 1], "end": [705, 94], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generate_has_subset_generate_measurable", "code": "theorem generate_has_subset_generate_measurable {C : Set (Set \u03b1)} {s : Set \u03b1}\n    (hs : (generate C).Has s) : MeasurableSet[generateFrom C] s", "start": [708, 1], "end": [710, 94], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generate_inter", "code": "theorem generate_inter {s : Set (Set \u03b1)} (hs : IsPiSystem s) {t\u2081 t\u2082 : Set \u03b1}\n    (ht\u2081 : (generate s).Has t\u2081) (ht\u2082 : (generate s).Has t\u2082) : (generate s).Has (t\u2081 \u2229 t\u2082)", "start": [713, 1], "end": [725, 13], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.DynkinSystem.generateFrom_eq", "code": "theorem generateFrom_eq {s : Set (Set \u03b1)} (hs : IsPiSystem s) :\n    generateFrom s = (generate s).toMeasurableSpace fun t\u2081 t\u2082 => generate_inter hs", "start": [728, 1], "end": [740, 69], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.induction_on_inter", "code": "theorem induction_on_inter {C : Set \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} [m : MeasurableSpace \u03b1]\n    (h_eq : m = generateFrom s) (h_inter : IsPiSystem s) (h_empty : C \u2205) (h_basic : \u2200 t \u2208 s, C t)\n    (h_compl : \u2200 t, MeasurableSet t \u2192 C t \u2192 C t\u1d9c)\n    (h_union :\n      \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C (f i)) \u2192 C (\u22c3 i, f i)) :\n    \u2200 \u2983t\u2984, MeasurableSet t \u2192 C t", "start": [745, 1], "end": [765, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "vectorSpan", "code": "def vectorSpan (s : Set P) : Submodule k V :=\n  Submodule.span k (s -\u1d65 s)", "start": [60, 1], "end": [62, 28], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_def", "code": "theorem vectorSpan_def (s : Set P) : vectorSpan k s = Submodule.span k (s -\u1d65 s)", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_mono", "code": "theorem vectorSpan_mono {s\u2081 s\u2082 : Set P} (h : s\u2081 \u2286 s\u2082) : vectorSpan k s\u2081 \u2264 vectorSpan k s\u2082", "start": [70, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_empty", "code": "@[simp]\ntheorem vectorSpan_empty : vectorSpan k (\u2205 : Set P) = (\u22a5 : Submodule k V)", "start": [77, 1], "end": [80, 56], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_singleton", "code": "@[simp]\ntheorem vectorSpan_singleton (p : P) : vectorSpan k ({p} : Set P) = \u22a5", "start": [85, 1], "end": [87, 98], "kind": "commanddeclaration"}, {"full_name": "vsub_set_subset_vectorSpan", "code": "theorem vsub_set_subset_vectorSpan (s : Set P) : s -\u1d65 s \u2286 \u2191(vectorSpan k s)", "start": [90, 1], "end": [92, 24], "kind": "commanddeclaration"}, {"full_name": "vsub_mem_vectorSpan", "code": "theorem vsub_mem_vectorSpan {s : Set P} {p1 p2 : P} (hp1 : p1 \u2208 s) (hp2 : p2 \u2208 s) :\n    p1 -\u1d65 p2 \u2208 vectorSpan k s", "start": [95, 1], "end": [98, 57], "kind": "commanddeclaration"}, {"full_name": "spanPoints", "code": "def spanPoints (s : Set P) : Set P :=\n  { p | \u2203 p1 \u2208 s, \u2203 v \u2208 vectorSpan k s, p = v +\u1d65 p1 }", "start": [101, 1], "end": [104, 54], "kind": "commanddeclaration"}, {"full_name": "mem_spanPoints", "code": "theorem mem_spanPoints (p : P) (s : Set P) : p \u2208 s \u2192 p \u2208 spanPoints k s", "start": [107, 1], "end": [109, 65], "kind": "commanddeclaration"}, {"full_name": "subset_spanPoints", "code": "theorem subset_spanPoints (s : Set P) : s \u2286 spanPoints k s", "start": [112, 1], "end": [113, 92], "kind": "commanddeclaration"}, {"full_name": "spanPoints_nonempty", "code": "@[simp]\ntheorem spanPoints_nonempty (s : Set P) : (spanPoints k s).Nonempty \u2194 s.Nonempty", "start": [116, 1], "end": [124, 50], "kind": "commanddeclaration"}, {"full_name": "vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan", "code": "theorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan {s : Set P} {p : P} {v : V}\n    (hp : p \u2208 spanPoints k s) (hv : v \u2208 vectorSpan k s) : v +\u1d65 p \u2208 spanPoints k s", "start": [127, 1], "end": [133, 64], "kind": "commanddeclaration"}, {"full_name": "vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints", "code": "theorem vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints {s : Set P} {p1 p2 : P}\n    (hp1 : p1 \u2208 spanPoints k s) (hp2 : p2 \u2208 spanPoints k s) : p1 -\u1d65 p2 \u2208 vectorSpan k s", "start": [136, 1], "end": [148, 40], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace", "code": "structure AffineSubspace (k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V]\n  [Module k V] [AffineSpace V P] where\n  carrier : Set P\n  smul_vsub_vadd_mem :\n    \u2200 (c : k) {p1 p2 p3 : P},\n      p1 \u2208 carrier \u2192 p2 \u2208 carrier \u2192 p3 \u2208 carrier \u2192 c \u2022 (p1 -\u1d65 p2 : V) +\u1d65 p3 \u2208 carrier", "start": [153, 1], "end": [160, 86], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAffineSubspace", "code": "def toAffineSubspace (p : Submodule k V) : AffineSubspace k V where\n  carrier := p\n  smul_vsub_vadd_mem _ _ _ _ h\u2081 h\u2082 h\u2083 := p.add_mem (p.smul_mem _ (p.sub_mem h\u2081 h\u2082)) h\u2083", "start": [167, 1], "end": [170, 87], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_coe", "code": "theorem mem_coe (p : P) (s : AffineSubspace k P) : p \u2208 (s : Set P) \u2194 p \u2208 s", "start": [184, 1], "end": [188, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction", "code": "def direction (s : AffineSubspace k P) : Submodule k V :=\n  vectorSpan k (s : Set P)", "start": [193, 1], "end": [199, 27], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_eq_vectorSpan", "code": "theorem direction_eq_vectorSpan (s : AffineSubspace k P) : s.direction = vectorSpan k (s : Set P)", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.directionOfNonempty", "code": "def directionOfNonempty {s : AffineSubspace k P} (h : (s : Set P).Nonempty) : Submodule k V where\n  carrier := (s : Set P) -\u1d65 s\n  zero_mem' := by\n    cases' h with p hp\n    exact vsub_self p \u25b8 vsub_mem_vsub hp hp\n  add_mem' := by\n    intro a b ha hb\n    rcases ha with \u27e8p1, p2, hp1, hp2, rfl\u27e9\n    rcases hb with \u27e8p3, p4, hp3, hp4, rfl\u27e9\n    rw [\u2190 vadd_vsub_assoc]\n    refine' vsub_mem_vsub _ hp4\n    convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp3\n    rw [one_smul]\n  smul_mem' := by\n    intro c v hv\n    rcases hv with \u27e8p1, p2, hp1, hp2, rfl\u27e9\n    rw [\u2190 vadd_vsub (c \u2022 (p1 -\u1d65 p2)) p2]\n    refine' vsub_mem_vsub _ hp2\n    exact s.smul_vsub_vadd_mem c hp1 hp2 hp2", "start": [207, 1], "end": [228, 45], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.directionOfNonempty_eq_direction", "code": "theorem directionOfNonempty_eq_direction {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    directionOfNonempty h = s.direction", "start": [231, 1], "end": [237, 41], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_direction_eq_vsub_set", "code": "theorem coe_direction_eq_vsub_set {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    (s.direction : Set V) = (s : Set P) -\u1d65 s", "start": [240, 1], "end": [243, 43], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_direction_iff_eq_vsub", "code": "theorem mem_direction_iff_eq_vsub {s : AffineSubspace k P} (h : (s : Set P).Nonempty) (v : V) :\n    v \u2208 s.direction \u2194 \u2203 p1 \u2208 s, \u2203 p2 \u2208 s, v = p1 -\u1d65 p2", "start": [246, 1], "end": [253, 35], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vadd_mem_of_mem_direction", "code": "theorem vadd_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v \u2208 s.direction) {p : P}\n    (hp : p \u2208 s) : v +\u1d65 p \u2208 s", "start": [256, 1], "end": [265, 24], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vsub_mem_direction", "code": "theorem vsub_mem_direction {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 \u2208 s) (hp2 : p2 \u2208 s) :\n    p1 -\u1d65 p2 \u2208 s.direction", "start": [268, 1], "end": [271, 32], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vadd_mem_iff_mem_direction", "code": "theorem vadd_mem_iff_mem_direction {s : AffineSubspace k P} (v : V) {p : P} (hp : p \u2208 s) :\n    v +\u1d65 p \u2208 s \u2194 v \u2208 s.direction", "start": [274, 1], "end": [278, 93], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vadd_mem_iff_mem_of_mem_direction", "code": "theorem vadd_mem_iff_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v \u2208 s.direction)\n    {p : P} : v +\u1d65 p \u2208 s \u2194 p \u2208 s", "start": [281, 1], "end": [287, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_direction_eq_vsub_set_right", "code": "theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) :\n    (s.direction : Set V) = (\u00b7 -\u1d65 p) '' s", "start": [290, 1], "end": [299, 32], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_direction_eq_vsub_set_left", "code": "theorem coe_direction_eq_vsub_set_left {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) :\n    (s.direction : Set V) = (\u00b7 -\u1d65 \u00b7) p '' s", "start": [302, 1], "end": [312, 41], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_direction_iff_eq_vsub_right", "code": "theorem mem_direction_iff_eq_vsub_right {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) (v : V) :\n    v \u2208 s.direction \u2194 \u2203 p2 \u2208 s, v = p2 -\u1d65 p", "start": [315, 1], "end": [320, 91], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_direction_iff_eq_vsub_left", "code": "theorem mem_direction_iff_eq_vsub_left {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) (v : V) :\n    v \u2208 s.direction \u2194 \u2203 p2 \u2208 s, v = p -\u1d65 p2", "start": [323, 1], "end": [328, 91], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vsub_right_mem_direction_iff_mem", "code": "theorem vsub_right_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) (p2 : P) :\n    p2 -\u1d65 p \u2208 s.direction \u2194 p2 \u2208 s", "start": [331, 1], "end": [336, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vsub_left_mem_direction_iff_mem", "code": "theorem vsub_left_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) (p2 : P) :\n    p -\u1d65 p2 \u2208 s.direction \u2194 p2 \u2208 s", "start": [339, 1], "end": [344, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_injective", "code": "theorem coe_injective : Function.Injective ((\u2191) : AffineSubspace k P \u2192 Set P)", "start": [347, 1], "end": [349, 24], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.ext", "code": "@[ext]\ntheorem ext {p q : AffineSubspace k P} (h : \u2200 x, x \u2208 p \u2194 x \u2208 q) : p = q", "start": [352, 1], "end": [354, 16], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.ext_iff", "code": "theorem ext_iff (s\u2081 s\u2082 : AffineSubspace k P) : (s\u2081 : Set P) = s\u2082 \u2194 s\u2081 = s\u2082", "start": [358, 1], "end": [359, 24], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.ext_of_direction_eq", "code": "theorem ext_of_direction_eq {s1 s2 : AffineSubspace k P} (hd : s1.direction = s2.direction)\n    (hn : ((s1 : Set P) \u2229 s2).Nonempty) : s1 = s2", "start": [362, 1], "end": [378, 36], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.toAddTorsor", "code": "@[reducible]\ndef toAddTorsor (s : AffineSubspace k P) [Nonempty s] : AddTorsor s.direction s where\n  vadd a b := \u27e8(a : V) +\u1d65 (b : P), vadd_mem_of_mem_direction a.2 b.2\u27e9\n  zero_vadd := fun a => by\n    ext\n    exact zero_vadd _ _\n  add_vadd a b c := by\n    ext\n    apply add_vadd\n  vsub a b := \u27e8(a : P) -\u1d65 (b : P), (vsub_left_mem_direction_iff_mem a.2 _).mpr b.2\u27e9\n  Nonempty := by infer_instance\n  vsub_vadd' a b := by\n    ext\n    apply AddTorsor.vsub_vadd'\n  vadd_vsub' a b := by\n    ext\n    apply AddTorsor.vadd_vsub'", "start": [382, 1], "end": [399, 31], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_vsub", "code": "@[simp, norm_cast]\ntheorem coe_vsub (s : AffineSubspace k P) [Nonempty s] (a b : s) : \u2191(a -\u1d65 b) = (a : P) -\u1d65 (b : P)", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_vadd", "code": "@[simp, norm_cast]\ntheorem coe_vadd (s : AffineSubspace k P) [Nonempty s] (a : s.direction) (b : s) :\n    \u2191(a +\u1d65 b) = (a : V) +\u1d65 (b : P)", "start": [409, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype", "code": "protected def subtype (s : AffineSubspace k P) [Nonempty s] : s \u2192\u1d43[k] P where\n  toFun := (\u2191)\n  linear := s.direction.subtype\n  map_vadd' _ _ := rfl", "start": [415, 1], "end": [419, 23], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype_linear", "code": "@[simp]\ntheorem subtype_linear (s : AffineSubspace k P) [Nonempty s] :\n    s.subtype.linear = s.direction.subtype", "start": [422, 1], "end": [424, 50], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subtype_apply", "code": "theorem subtype_apply (s : AffineSubspace k P) [Nonempty s] (p : s) : s.subtype p = p", "start": [427, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coeSubtype", "code": "@[simp]\ntheorem coeSubtype (s : AffineSubspace k P) [Nonempty s] : (s.subtype : s \u2192 P) = ((\u2191) : s \u2192 P)", "start": [431, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.injective_subtype", "code": "theorem injective_subtype (s : AffineSubspace k P) [Nonempty s] : Function.Injective s.subtype", "start": [436, 1], "end": [437, 24], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.eq_iff_direction_eq_of_mem", "code": "theorem eq_iff_direction_eq_of_mem {s\u2081 s\u2082 : AffineSubspace k P} {p : P} (h\u2081 : p \u2208 s\u2081)\n    (h\u2082 : p \u2208 s\u2082) : s\u2081 = s\u2082 \u2194 s\u2081.direction = s\u2082.direction", "start": [440, 1], "end": [444, 65], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mk'", "code": "def mk' (p : P) (direction : Submodule k V) : AffineSubspace k P where\n  carrier := { q | \u2203 v \u2208 direction, q = v +\u1d65 p }\n  smul_vsub_vadd_mem c p1 p2 p3 hp1 hp2 hp3 := by\n    rcases hp1 with \u27e8v1, hv1, hp1\u27e9\n    rcases hp2 with \u27e8v2, hv2, hp2\u27e9\n    rcases hp3 with \u27e8v3, hv3, hp3\u27e9\n    use c \u2022 (v1 - v2) + v3, direction.add_mem (direction.smul_mem c (direction.sub_mem hv1 hv2)) hv3\n    simp [hp1, hp2, hp3, vadd_vadd]", "start": [447, 1], "end": [455, 36], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.self_mem_mk'", "code": "theorem self_mem_mk' (p : P) (direction : Submodule k V) : p \u2208 mk' p direction", "start": [458, 1], "end": [460, 50], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vadd_mem_mk'", "code": "theorem vadd_mem_mk' {v : V} (p : P) {direction : Submodule k V} (hv : v \u2208 direction) :\n    v +\u1d65 p \u2208 mk' p direction", "start": [463, 1], "end": [467, 15], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mk'_nonempty", "code": "theorem mk'_nonempty (p : P) (direction : Submodule k V) : (mk' p direction : Set P).Nonempty", "start": [470, 1], "end": [472, 32], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_mk'", "code": "@[simp]\ntheorem direction_mk' (p : P) (direction : Submodule k V) :\n    (mk' p direction).direction = direction", "start": [475, 1], "end": [485, 91], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_mk'_iff_vsub_mem", "code": "theorem mem_mk'_iff_vsub_mem {p\u2081 p\u2082 : P} {direction : Submodule k V} :\n    p\u2082 \u2208 mk' p\u2081 direction \u2194 p\u2082 -\u1d65 p\u2081 \u2208 direction", "start": [488, 1], "end": [496, 28], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mk'_eq", "code": "@[simp]\ntheorem mk'_eq {s : AffineSubspace k P} {p : P} (hp : p \u2208 s) : mk' p s.direction = s", "start": [499, 1], "end": [503, 93], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.spanPoints_subset_coe_of_subset_coe", "code": "theorem spanPoints_subset_coe_of_subset_coe {s : Set P} {s1 : AffineSubspace k P} (h : s \u2286 s1) :\n    spanPoints k s \u2286 s1", "start": [506, 1], "end": [516, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_toAffineSubspace", "code": "@[simp]\ntheorem mem_toAffineSubspace {p : Submodule k V} {x : V} :\n    x \u2208 p.toAffineSubspace \u2194 x \u2208 p", "start": [525, 1], "end": [528, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAffineSubspace_direction", "code": "@[simp]\ntheorem toAffineSubspace_direction (s : Submodule k V) : s.toAffineSubspace.direction = s", "start": [530, 1], "end": [532, 77], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_mem", "code": "theorem AffineMap.lineMap_mem {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {Q : AffineSubspace k P} {p\u2080 p\u2081 : P} (c : k) (h\u2080 : p\u2080 \u2208 Q) (h\u2081 : p\u2081 \u2208 Q) :\n    AffineMap.lineMap p\u2080 p\u2081 c \u2208 Q", "start": [536, 1], "end": [540, 40], "kind": "commanddeclaration"}, {"full_name": "affineSpan", "code": "def affineSpan (s : Set P) : AffineSubspace k P where\n  carrier := spanPoints k s\n  smul_vsub_vadd_mem c _ _ _ hp1 hp2 hp3 :=\n    vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan k hp3\n      ((vectorSpan k s).smul_mem c\n        (vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints k hp1 hp2))", "start": [548, 1], "end": [555, 77], "kind": "commanddeclaration"}, {"full_name": "coe_affineSpan", "code": "@[simp]\ntheorem coe_affineSpan (s : Set P) : (affineSpan k s : Set P) = spanPoints k s", "start": [558, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "subset_affineSpan", "code": "theorem subset_affineSpan (s : Set P) : s \u2286 affineSpan k s", "start": [564, 1], "end": [566, 24], "kind": "commanddeclaration"}, {"full_name": "direction_affineSpan", "code": "theorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s", "start": [569, 1], "end": [578, 52], "kind": "commanddeclaration"}, {"full_name": "mem_affineSpan", "code": "theorem mem_affineSpan {p : P} {s : Set P} (hp : p \u2208 s) : p \u2208 affineSpan k s", "start": [581, 1], "end": [583, 26], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.le_def", "code": "theorem le_def (s1 s2 : AffineSubspace k P) : s1 \u2264 s2 \u2194 (s1 : Set P) \u2286 s2", "start": [635, 1], "end": [637, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.le_def'", "code": "theorem le_def' (s1 s2 : AffineSubspace k P) : s1 \u2264 s2 \u2194 \u2200 p \u2208 s1, p \u2208 s2", "start": [640, 1], "end": [643, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.lt_def", "code": "theorem lt_def (s1 s2 : AffineSubspace k P) : s1 < s2 \u2194 (s1 : Set P) \u2282 s2", "start": [646, 1], "end": [648, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.not_le_iff_exists", "code": "theorem not_le_iff_exists (s1 s2 : AffineSubspace k P) : \u00acs1 \u2264 s2 \u2194 \u2203 p \u2208 s1, p \u2209 s2", "start": [651, 1], "end": [654, 17], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.exists_of_lt", "code": "theorem exists_of_lt {s1 s2 : AffineSubspace k P} (h : s1 < s2) : \u2203 p \u2208 s2, p \u2209 s1", "start": [657, 1], "end": [659, 26], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.lt_iff_le_and_exists", "code": "theorem lt_iff_le_and_exists (s1 s2 : AffineSubspace k P) : s1 < s2 \u2194 s1 \u2264 s2 \u2227 \u2203 p \u2208 s2, p \u2209 s1", "start": [662, 1], "end": [665, 46], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.eq_of_direction_eq_of_nonempty_of_le", "code": "theorem eq_of_direction_eq_of_nonempty_of_le {s\u2081 s\u2082 : AffineSubspace k P}\n    (hd : s\u2081.direction = s\u2082.direction) (hn : (s\u2081 : Set P).Nonempty) (hle : s\u2081 \u2264 s\u2082) : s\u2081 = s\u2082", "start": [668, 1], "end": [673, 41], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_eq_sInf", "code": "theorem affineSpan_eq_sInf (s : Set P) :\n    affineSpan k s = sInf { s' : AffineSubspace k P | s \u2286 s' }", "start": [678, 1], "end": [682, 38], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.gi", "code": "protected def gi : GaloisInsertion (affineSpan k) ((\u2191) : AffineSubspace k P \u2192 Set P) where\n  choice s _ := affineSpan k s\n  gc s1 _s2 :=\n    \u27e8fun h => Set.Subset.trans (subset_spanPoints k s1) h, spanPoints_subset_coe_of_subset_coe\u27e9\n  le_l_u _ := subset_spanPoints k _\n  choice_eq _ _ := rfl", "start": [687, 1], "end": [693, 23], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.span_empty", "code": "@[simp]\ntheorem span_empty : affineSpan k (\u2205 : Set P) = \u22a5", "start": [696, 1], "end": [699, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.span_univ", "code": "@[simp]\ntheorem span_univ : affineSpan k (Set.univ : Set P) = \u22a4", "start": [702, 1], "end": [705, 40], "kind": "commanddeclaration"}, {"full_name": "affineSpan_le", "code": "theorem _root_.affineSpan_le {s : Set P} {Q : AffineSubspace k P} :\n    affineSpan k s \u2264 Q \u2194 s \u2286 (Q : Set P)", "start": [710, 1], "end": [712, 35], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_affineSpan_singleton", "code": "@[simp 1001] theorem coe_affineSpan_singleton (p : P) : (affineSpan k ({p} : Set P) : Set P) = {p}", "start": [717, 1], "end": [723, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_affineSpan_singleton", "code": "@[simp]\ntheorem mem_affineSpan_singleton : p\u2081 \u2208 affineSpan k ({p\u2082} : Set P) \u2194 p\u2081 = p\u2082", "start": [726, 1], "end": [729, 19], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.preimage_coe_affineSpan_singleton", "code": "@[simp]\ntheorem preimage_coe_affineSpan_singleton (x : P) :\n    ((\u2191) : affineSpan k ({x} : Set P) \u2192 P) \u207b\u00b9' {x} = univ", "start": [732, 1], "end": [735, 81], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.span_union", "code": "theorem span_union (s t : Set P) : affineSpan k (s \u222a t) = affineSpan k s \u2294 affineSpan k t", "start": [738, 1], "end": [740, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.span_iUnion", "code": "theorem span_iUnion {\u03b9 : Type*} (s : \u03b9 \u2192 Set P) :\n    affineSpan k (\u22c3 i, s i) = \u2a06 i, affineSpan k (s i)", "start": [743, 1], "end": [746, 38], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.top_coe", "code": "@[simp]\ntheorem top_coe : ((\u22a4 : AffineSubspace k P) : Set P) = Set.univ", "start": [751, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_top", "code": "@[simp]\ntheorem mem_top (p : P) : p \u2208 (\u22a4 : AffineSubspace k P)", "start": [759, 1], "end": [762, 17], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_top", "code": "@[simp]\ntheorem direction_top : (\u22a4 : AffineSubspace k P).direction = \u22a4", "start": [767, 1], "end": [775, 25], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.bot_coe", "code": "@[simp]\ntheorem bot_coe : ((\u22a5 : AffineSubspace k P) : Set P) = \u2205", "start": [778, 1], "end": [781, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.bot_ne_top", "code": "theorem bot_ne_top : (\u22a5 : AffineSubspace k P) \u2260 \u22a4", "start": [784, 1], "end": [787, 33], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.nonempty_of_affineSpan_eq_top", "code": "theorem nonempty_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = \u22a4) : s.Nonempty", "start": [793, 1], "end": [797, 27], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top", "code": "theorem vectorSpan_eq_top_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = \u22a4) :\n    vectorSpan k s = \u22a4", "start": [800, 1], "end": [802, 75], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty", "code": "theorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty {s : Set P} (hs : s.Nonempty) :\n    affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4", "start": [805, 1], "end": [814, 35], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial", "code": "theorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial {s : Set P} [Nontrivial P] :\n    affineSpan k s = \u22a4 \u2194 vectorSpan k s = \u22a4", "start": [817, 1], "end": [822, 70], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.card_pos_of_affineSpan_eq_top", "code": "theorem card_pos_of_affineSpan_eq_top {\u03b9 : Type*} [Fintype \u03b9] {p : \u03b9 \u2192 P}\n    (h : affineSpan k (range p) = \u22a4) : 0 < Fintype.card \u03b9", "start": [825, 1], "end": [828, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.not_mem_bot", "code": "theorem not_mem_bot (p : P) : p \u2209 (\u22a5 : AffineSubspace k P)", "start": [833, 1], "end": [835, 22], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_bot", "code": "@[simp]\ntheorem direction_bot : (\u22a5 : AffineSubspace k P).direction = \u22a5", "start": [840, 1], "end": [843, 90], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_eq_bot_iff", "code": "@[simp]\ntheorem coe_eq_bot_iff (Q : AffineSubspace k P) : (Q : Set P) = \u2205 \u2194 Q = \u22a5", "start": [848, 1], "end": [850, 40], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_eq_univ_iff", "code": "@[simp]\ntheorem coe_eq_univ_iff (Q : AffineSubspace k P) : (Q : Set P) = univ \u2194 Q = \u22a4", "start": [853, 1], "end": [855, 40], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.nonempty_iff_ne_bot", "code": "theorem nonempty_iff_ne_bot (Q : AffineSubspace k P) : (Q : Set P).Nonempty \u2194 Q \u2260 \u22a5", "start": [858, 1], "end": [860, 35], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.eq_bot_or_nonempty", "code": "theorem eq_bot_or_nonempty (Q : AffineSubspace k P) : Q = \u22a5 \u2228 (Q : Set P).Nonempty", "start": [863, 1], "end": [865, 17], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.subsingleton_of_subsingleton_span_eq_top", "code": "theorem subsingleton_of_subsingleton_span_eq_top {s : Set P} (h\u2081 : s.Subsingleton)\n    (h\u2082 : affineSpan k s = \u22a4) : Subsingleton P", "start": [868, 1], "end": [874, 45], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.eq_univ_of_subsingleton_span_eq_top", "code": "theorem eq_univ_of_subsingleton_span_eq_top {s : Set P} (h\u2081 : s.Subsingleton)\n    (h\u2082 : affineSpan k s = \u22a4) : s = (univ : Set P)", "start": [877, 1], "end": [882, 55], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_eq_top_iff_of_nonempty", "code": "@[simp]\ntheorem direction_eq_top_iff_of_nonempty {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    s.direction = \u22a4 \u2194 s = \u22a4", "start": [885, 1], "end": [895, 9], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.inf_coe", "code": "@[simp]\ntheorem inf_coe (s1 s2 : AffineSubspace k P) : (s1 \u2293 s2 : Set P) = (s1 : Set P) \u2229 s2", "start": [898, 1], "end": [902, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_inf_iff", "code": "theorem mem_inf_iff (p : P) (s1 s2 : AffineSubspace k P) : p \u2208 s1 \u2293 s2 \u2194 p \u2208 s1 \u2227 p \u2208 s2", "start": [905, 1], "end": [907, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_inf", "code": "theorem direction_inf (s1 s2 : AffineSubspace k P) :\n    (s1 \u2293 s2).direction \u2264 s1.direction \u2293 s2.direction", "start": [910, 1], "end": [917, 84], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_inf_of_mem", "code": "theorem direction_inf_of_mem {s\u2081 s\u2082 : AffineSubspace k P} {p : P} (h\u2081 : p \u2208 s\u2081) (h\u2082 : p \u2208 s\u2082) :\n    (s\u2081 \u2293 s\u2082).direction = s\u2081.direction \u2293 s\u2082.direction", "start": [920, 1], "end": [926, 82], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_inf_of_mem_inf", "code": "theorem direction_inf_of_mem_inf {s\u2081 s\u2082 : AffineSubspace k P} {p : P} (h : p \u2208 s\u2081 \u2293 s\u2082) :\n    (s\u2081 \u2293 s\u2082).direction = s\u2081.direction \u2293 s\u2082.direction", "start": [929, 1], "end": [933, 83], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_le", "code": "theorem direction_le {s1 s2 : AffineSubspace k P} (h : s1 \u2264 s2) : s1.direction \u2264 s2.direction", "start": [936, 1], "end": [940, 28], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_lt_of_nonempty", "code": "theorem direction_lt_of_nonempty {s1 s2 : AffineSubspace k P} (h : s1 < s2)\n    (hn : (s1 : Set P).Nonempty) : s1.direction < s2.direction", "start": [943, 1], "end": [953, 17], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.sup_direction_le", "code": "theorem sup_direction_le (s1 s2 : AffineSubspace k P) :\n    s1.direction \u2294 s2.direction \u2264 (s1 \u2294 s2).direction", "start": [956, 1], "end": [964, 100], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty", "code": "theorem sup_direction_lt_of_nonempty_of_inter_empty {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty) (he : (s1 \u2229 s2 : Set P) = \u2205) :\n    s1.direction \u2294 s2.direction < (s1 \u2294 s2).direction", "start": [967, 1], "end": [986, 64], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top", "code": "theorem inter_nonempty_of_nonempty_of_sup_direction_eq_top {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)\n    (hd : s1.direction \u2294 s2.direction = \u22a4) : ((s1 : Set P) \u2229 s2).Nonempty", "start": [989, 1], "end": [998, 23], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl", "code": "theorem inter_eq_singleton_of_nonempty_of_isCompl {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)\n    (hd : IsCompl s1.direction s2.direction) : \u2203 p, (s1 : Set P) \u2229 s2 = {p}", "start": [1001, 1], "end": [1015, 31], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_coe", "code": "@[simp]\ntheorem affineSpan_coe (s : AffineSubspace k P) : affineSpan k (s : Set P) = s", "start": [1018, 1], "end": [1023, 41], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_eq_span_vsub_set_left", "code": "theorem vectorSpan_eq_span_vsub_set_left {s : Set P} {p : P} (hp : p \u2208 s) :\n    vectorSpan k s = Submodule.span k ((\u00b7 -\u1d65 \u00b7) p '' s)", "start": [1037, 1], "end": [1048, 31], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_eq_span_vsub_set_right", "code": "theorem vectorSpan_eq_span_vsub_set_right {s : Set P} {p : P} (hp : p \u2208 s) :\n    vectorSpan k s = Submodule.span k ((\u00b7 -\u1d65 p) '' s)", "start": [1051, 1], "end": [1062, 31], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_eq_span_vsub_set_left_ne", "code": "theorem vectorSpan_eq_span_vsub_set_left_ne {s : Set P} {p : P} (hp : p \u2208 s) :\n    vectorSpan k s = Submodule.span k ((\u00b7 -\u1d65 \u00b7) p '' (s \\ {p}))", "start": [1065, 1], "end": [1072, 39], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_eq_span_vsub_set_right_ne", "code": "theorem vectorSpan_eq_span_vsub_set_right_ne {s : Set P} {p : P} (hp : p \u2208 s) :\n    vectorSpan k s = Submodule.span k ((\u00b7 -\u1d65 p) '' (s \\ {p}))", "start": [1075, 1], "end": [1082, 39], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_eq_span_vsub_finset_right_ne", "code": "theorem vectorSpan_eq_span_vsub_finset_right_ne [DecidableEq P] [DecidableEq V] {s : Finset P}\n    {p : P} (hp : p \u2208 s) :\n    vectorSpan k (s : Set P) = Submodule.span k ((s.erase p).image (\u00b7 -\u1d65 p))", "start": [1085, 1], "end": [1090, 72], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_image_eq_span_vsub_set_left_ne", "code": "theorem vectorSpan_image_eq_span_vsub_set_left_ne (p : \u03b9 \u2192 P) {s : Set \u03b9} {i : \u03b9} (hi : i \u2208 s) :\n    vectorSpan k (p '' s) = Submodule.span k ((\u00b7 -\u1d65 \u00b7) (p i) '' (p '' (s \\ {i})))", "start": [1093, 1], "end": [1100, 39], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_image_eq_span_vsub_set_right_ne", "code": "theorem vectorSpan_image_eq_span_vsub_set_right_ne (p : \u03b9 \u2192 P) {s : Set \u03b9} {i : \u03b9} (hi : i \u2208 s) :\n    vectorSpan k (p '' s) = Submodule.span k ((\u00b7 -\u1d65 p i) '' (p '' (s \\ {i})))", "start": [1103, 1], "end": [1110, 39], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_range_eq_span_range_vsub_left", "code": "theorem vectorSpan_range_eq_span_range_vsub_left (p : \u03b9 \u2192 P) (i0 : \u03b9) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : \u03b9 => p i0 -\u1d65 p i)", "start": [1113, 1], "end": [1118, 8], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_range_eq_span_range_vsub_right", "code": "theorem vectorSpan_range_eq_span_range_vsub_right (p : \u03b9 \u2192 P) (i0 : \u03b9) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : \u03b9 => p i -\u1d65 p i0)", "start": [1121, 1], "end": [1126, 8], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_range_eq_span_range_vsub_left_ne", "code": "theorem vectorSpan_range_eq_span_range_vsub_left_ne (p : \u03b9 \u2192 P) (i\u2080 : \u03b9) :\n    vectorSpan k (Set.range p) =\n      Submodule.span k (Set.range fun i : { x // x \u2260 i\u2080 } => p i\u2080 -\u1d65 p i)", "start": [1129, 1], "end": [1141, 76], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_range_eq_span_range_vsub_right_ne", "code": "theorem vectorSpan_range_eq_span_range_vsub_right_ne (p : \u03b9 \u2192 P) (i\u2080 : \u03b9) :\n    vectorSpan k (Set.range p) =\n      Submodule.span k (Set.range fun i : { x // x \u2260 i\u2080 } => p i -\u1d65 p i\u2080)", "start": [1144, 1], "end": [1156, 76], "kind": "commanddeclaration"}, {"full_name": "affineSpan_nonempty", "code": "theorem affineSpan_nonempty : (affineSpan k s : Set P).Nonempty \u2194 s.Nonempty", "start": [1163, 1], "end": [1165, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.affineSpan", "code": "alias \u27e8_, _root_.Set.Nonempty.affineSpan\u27e9 := affineSpan_nonempty", "start": [1168, 1], "end": [1168, 65], "kind": "stdtacticaliasaliaslr"}, {"full_name": "affineSpan_eq_bot", "code": "@[simp]\ntheorem affineSpan_eq_bot : affineSpan k s = \u22a5 \u2194 s = \u2205", "start": [1175, 1], "end": [1179, 27], "kind": "commanddeclaration"}, {"full_name": "bot_lt_affineSpan", "code": "@[simp]\ntheorem bot_lt_affineSpan : \u22a5 < affineSpan k s \u2194 s.Nonempty", "start": [1182, 1], "end": [1185, 34], "kind": "commanddeclaration"}, {"full_name": "affineSpan_induction", "code": "theorem affineSpan_induction {x : P} {s : Set P} {p : P \u2192 Prop} (h : x \u2208 affineSpan k s)\n    (Hs : \u2200 x : P, x \u2208 s \u2192 p x)\n    (Hc : \u2200 (c : k) (u v w : P), p u \u2192 p v \u2192 p w \u2192 p (c \u2022 (u -\u1d65 v) +\u1d65 w)) : p x", "start": [1192, 1], "end": [1197, 52], "kind": "commanddeclaration"}, {"full_name": "affineSpan_induction'", "code": "theorem affineSpan_induction' {s : Set P} {p : \u2200 x, x \u2208 affineSpan k s \u2192 Prop}\n    (Hs : \u2200 (y) (hys : y \u2208 s), p y (subset_affineSpan k _ hys))\n    (Hc :\n      \u2200 (c : k) (u hu v hv w hw),\n        p u hu \u2192\n          p v hv \u2192 p w hw \u2192 p (c \u2022 (u -\u1d65 v) +\u1d65 w) (AffineSubspace.smul_vsub_vadd_mem _ _ hu hv hw))\n    {x : P} (h : x \u2208 affineSpan k s) : p x h", "start": [1200, 1], "end": [1216, 91], "kind": "commanddeclaration"}, {"full_name": "affineSpan_coe_preimage_eq_top", "code": "@[simp]\ntheorem affineSpan_coe_preimage_eq_top (A : Set P) [Nonempty A] :\n    affineSpan k (((\u2191) : affineSpan k A \u2192 P) \u207b\u00b9' A) = \u22a4", "start": [1223, 1], "end": [1233, 48], "kind": "commanddeclaration"}, {"full_name": "affineSpan_singleton_union_vadd_eq_top_of_span_eq_top", "code": "theorem affineSpan_singleton_union_vadd_eq_top_of_span_eq_top {s : Set V} (p : P)\n    (h : Submodule.span k (Set.range ((\u2191) : s \u2192 V)) = \u22a4) :\n    affineSpan k ({p} \u222a (fun v => v +\u1d65 p) '' s) = \u22a4", "start": [1238, 1], "end": [1251, 7], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_pair", "code": "theorem vectorSpan_pair (p\u2081 p\u2082 : P) : vectorSpan k ({p\u2081, p\u2082} : Set P) = k \u2219 p\u2081 -\u1d65 p\u2082", "start": [1256, 1], "end": [1259, 32], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_pair_rev", "code": "theorem vectorSpan_pair_rev (p\u2081 p\u2082 : P) : vectorSpan k ({p\u2081, p\u2082} : Set P) = k \u2219 p\u2082 -\u1d65 p\u2081", "start": [1262, 1], "end": [1264, 34], "kind": "commanddeclaration"}, {"full_name": "vsub_mem_vectorSpan_pair", "code": "theorem vsub_mem_vectorSpan_pair (p\u2081 p\u2082 : P) : p\u2081 -\u1d65 p\u2082 \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P)", "start": [1267, 1], "end": [1269, 93], "kind": "commanddeclaration"}, {"full_name": "vsub_rev_mem_vectorSpan_pair", "code": "theorem vsub_rev_mem_vectorSpan_pair (p\u2081 p\u2082 : P) : p\u2082 -\u1d65 p\u2081 \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P)", "start": [1272, 1], "end": [1274, 93], "kind": "commanddeclaration"}, {"full_name": "smul_vsub_mem_vectorSpan_pair", "code": "theorem smul_vsub_mem_vectorSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    r \u2022 (p\u2081 -\u1d65 p\u2082) \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P)", "start": [1279, 1], "end": [1282, 60], "kind": "commanddeclaration"}, {"full_name": "smul_vsub_rev_mem_vectorSpan_pair", "code": "theorem smul_vsub_rev_mem_vectorSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    r \u2022 (p\u2082 -\u1d65 p\u2081) \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P)", "start": [1285, 1], "end": [1288, 64], "kind": "commanddeclaration"}, {"full_name": "mem_vectorSpan_pair", "code": "theorem mem_vectorSpan_pair {p\u2081 p\u2082 : P} {v : V} :\n    v \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P) \u2194 \u2203 r : k, r \u2022 (p\u2081 -\u1d65 p\u2082) = v", "start": [1291, 1], "end": [1295, 53], "kind": "commanddeclaration"}, {"full_name": "mem_vectorSpan_pair_rev", "code": "theorem mem_vectorSpan_pair_rev {p\u2081 p\u2082 : P} {v : V} :\n    v \u2208 vectorSpan k ({p\u2081, p\u2082} : Set P) \u2194 \u2203 r : k, r \u2022 (p\u2082 -\u1d65 p\u2081) = v", "start": [1298, 1], "end": [1302, 57], "kind": "commanddeclaration"}, {"full_name": "left_mem_affineSpan_pair", "code": "theorem left_mem_affineSpan_pair (p\u2081 p\u2082 : P) : p\u2081 \u2208 line[k, p\u2081, p\u2082]", "start": [1310, 1], "end": [1312, 40], "kind": "commanddeclaration"}, {"full_name": "right_mem_affineSpan_pair", "code": "theorem right_mem_affineSpan_pair (p\u2081 p\u2082 : P) : p\u2082 \u2208 line[k, p\u2081, p\u2082]", "start": [1315, 1], "end": [1317, 67], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_mem_affineSpan_pair", "code": "theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    AffineMap.lineMap p\u2081 p\u2082 r \u2208 line[k, p\u2081, p\u2082]", "start": [1322, 1], "end": [1325, 93], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_rev_mem_affineSpan_pair", "code": "theorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    AffineMap.lineMap p\u2082 p\u2081 r \u2208 line[k, p\u2081, p\u2082]", "start": [1328, 1], "end": [1332, 93], "kind": "commanddeclaration"}, {"full_name": "smul_vsub_vadd_mem_affineSpan_pair", "code": "theorem smul_vsub_vadd_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    r \u2022 (p\u2082 -\u1d65 p\u2081) +\u1d65 p\u2081 \u2208 line[k, p\u2081, p\u2082]", "start": [1335, 1], "end": [1339, 46], "kind": "commanddeclaration"}, {"full_name": "smul_vsub_rev_vadd_mem_affineSpan_pair", "code": "theorem smul_vsub_rev_vadd_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\n    r \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2082 \u2208 line[k, p\u2081, p\u2082]", "start": [1342, 1], "end": [1346, 50], "kind": "commanddeclaration"}, {"full_name": "vadd_left_mem_affineSpan_pair", "code": "theorem vadd_left_mem_affineSpan_pair {p\u2081 p\u2082 : P} {v : V} :\n    v +\u1d65 p\u2081 \u2208 line[k, p\u2081, p\u2082] \u2194 \u2203 r : k, r \u2022 (p\u2082 -\u1d65 p\u2081) = v", "start": [1349, 1], "end": [1354, 29], "kind": "commanddeclaration"}, {"full_name": "vadd_right_mem_affineSpan_pair", "code": "theorem vadd_right_mem_affineSpan_pair {p\u2081 p\u2082 : P} {v : V} :\n    v +\u1d65 p\u2082 \u2208 line[k, p\u2081, p\u2082] \u2194 \u2203 r : k, r \u2022 (p\u2081 -\u1d65 p\u2082) = v", "start": [1357, 1], "end": [1362, 25], "kind": "commanddeclaration"}, {"full_name": "affineSpan_pair_le_of_mem_of_mem", "code": "theorem affineSpan_pair_le_of_mem_of_mem {p\u2081 p\u2082 : P} {s : AffineSubspace k P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) : line[k, p\u2081, p\u2082] \u2264 s", "start": [1365, 1], "end": [1369, 19], "kind": "commanddeclaration"}, {"full_name": "affineSpan_pair_le_of_left_mem", "code": "theorem affineSpan_pair_le_of_left_mem {p\u2081 p\u2082 p\u2083 : P} (h : p\u2081 \u2208 line[k, p\u2082, p\u2083]) :\n    line[k, p\u2081, p\u2083] \u2264 line[k, p\u2082, p\u2083]", "start": [1372, 1], "end": [1376, 71], "kind": "commanddeclaration"}, {"full_name": "affineSpan_pair_le_of_right_mem", "code": "theorem affineSpan_pair_le_of_right_mem {p\u2081 p\u2082 p\u2083 : P} (h : p\u2081 \u2208 line[k, p\u2082, p\u2083]) :\n    line[k, p\u2082, p\u2081] \u2264 line[k, p\u2082, p\u2083]", "start": [1379, 1], "end": [1383, 70], "kind": "commanddeclaration"}, {"full_name": "affineSpan_mono", "code": "@[mono]\ntheorem affineSpan_mono {s\u2081 s\u2082 : Set P} (h : s\u2081 \u2286 s\u2082) : affineSpan k s\u2081 \u2264 affineSpan k s\u2082", "start": [1388, 1], "end": [1391, 83], "kind": "commanddeclaration"}, {"full_name": "affineSpan_insert_affineSpan", "code": "theorem affineSpan_insert_affineSpan (p : P) (ps : Set P) :\n    affineSpan k (insert p (affineSpan k ps : Set P)) = affineSpan k (insert p ps)", "start": [1394, 1], "end": [1398, 76], "kind": "commanddeclaration"}, {"full_name": "affineSpan_insert_eq_affineSpan", "code": "theorem affineSpan_insert_eq_affineSpan {p : P} {ps : Set P} (h : p \u2208 affineSpan k ps) :\n    affineSpan k (insert p ps) = affineSpan k ps", "start": [1401, 1], "end": [1406, 78], "kind": "commanddeclaration"}, {"full_name": "vectorSpan_insert_eq_vectorSpan", "code": "theorem vectorSpan_insert_eq_vectorSpan {p : P} {ps : Set P} (h : p \u2208 affineSpan k ps) :\n    vectorSpan k (insert p ps) = vectorSpan k ps", "start": [1411, 1], "end": [1415, 72], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_sup", "code": "theorem direction_sup {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 \u2208 s1) (hp2 : p2 \u2208 s2) :\n    (s1 \u2294 s2).direction = s1.direction \u2294 s2.direction \u2294 k \u2219 p2 -\u1d65 p1", "start": [1425, 1], "end": [1453, 13], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.direction_affineSpan_insert", "code": "theorem direction_affineSpan_insert {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 \u2208 s) :\n    (affineSpan k (insert p2 (s : Set P))).direction =\n    Submodule.span k {p2 -\u1d65 p1} \u2294 s.direction", "start": [1456, 1], "end": [1465, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_affineSpan_insert_iff", "code": "theorem mem_affineSpan_insert_iff {s : AffineSubspace k P} {p1 : P} (hp1 : p1 \u2208 s) (p2 p : P) :\n    p \u2208 affineSpan k (insert p2 (s : Set P)) \u2194\n      \u2203 (r : k) (p0 : P) (_hp0 : p0 \u2208 s), p = r \u2022 (p2 -\u1d65 p1 : V) +\u1d65 p0", "start": [1468, 1], "end": [1487, 35], "kind": "commanddeclaration"}, {"full_name": "AffineMap.vectorSpan_image_eq_submodule_map", "code": "@[simp]\ntheorem AffineMap.vectorSpan_image_eq_submodule_map {s : Set P\u2081} :\n    Submodule.map f.linear (vectorSpan k s) = vectorSpan k (f '' s)", "start": [1506, 1], "end": [1509, 80], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map", "code": "def map (s : AffineSubspace k P\u2081) : AffineSubspace k P\u2082 where\n  carrier := f '' s\n  smul_vsub_vadd_mem := by\n    rintro t - - - \u27e8p\u2081, h\u2081, rfl\u27e9 \u27e8p\u2082, h\u2082, rfl\u27e9 \u27e8p\u2083, h\u2083, rfl\u27e9\n    use t \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2083\n    suffices t \u2022 (p\u2081 -\u1d65 p\u2082) +\u1d65 p\u2083 \u2208 s by\n    { simp only [SetLike.mem_coe, true_and, this]\n      rw [AffineMap.map_vadd, map_smul, AffineMap.linearMap_vsub] }\n    exact s.smul_vsub_vadd_mem t h\u2081 h\u2082 h\u2083", "start": [1515, 1], "end": [1524, 42], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_map", "code": "@[simp]\ntheorem coe_map (s : AffineSubspace k P\u2081) : (s.map f : Set P\u2082) = f '' s", "start": [1527, 1], "end": [1529, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_map", "code": "@[simp]\ntheorem mem_map {f : P\u2081 \u2192\u1d43[k] P\u2082} {x : P\u2082} {s : AffineSubspace k P\u2081} :\n    x \u2208 s.map f \u2194 \u2203 y \u2208 s, f y = x", "start": [1532, 1], "end": [1535, 47], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_map_of_mem", "code": "theorem mem_map_of_mem {x : P\u2081} {s : AffineSubspace k P\u2081} (h : x \u2208 s) : f x \u2208 s.map f", "start": [1538, 1], "end": [1539, 27], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_map_iff_mem_of_injective", "code": "@[simp 1100, nolint simpNF]\ntheorem mem_map_iff_mem_of_injective {f : P\u2081 \u2192\u1d43[k] P\u2082} {x : P\u2081} {s : AffineSubspace k P\u2081}\n    (hf : Function.Injective f) : f x \u2208 s.map f \u2194 x \u2208 s", "start": [1545, 1], "end": [1548, 19], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_bot", "code": "@[simp]\ntheorem map_bot : (\u22a5 : AffineSubspace k P\u2081).map f = \u22a5", "start": [1551, 1], "end": [1553, 33], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_eq_bot_iff", "code": "@[simp]\ntheorem map_eq_bot_iff {s : AffineSubspace k P\u2081} : s.map f = \u22a5 \u2194 s = \u22a5", "start": [1556, 1], "end": [1560, 20], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_id", "code": "@[simp]\ntheorem map_id (s : AffineSubspace k P\u2081) : s.map (AffineMap.id k P\u2081) = s", "start": [1563, 1], "end": [1565, 30], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_map", "code": "theorem map_map (s : AffineSubspace k P\u2081) (f : P\u2081 \u2192\u1d43[k] P\u2082) (g : P\u2082 \u2192\u1d43[k] P\u2083) :\n    (s.map f).map g = s.map (g.comp f)", "start": [1568, 1], "end": [1570, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_direction", "code": "@[simp]\ntheorem map_direction (s : AffineSubspace k P\u2081) : (s.map f).direction = s.direction.map f.linear", "start": [1573, 1], "end": [1576, 49], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_span", "code": "theorem map_span (s : Set P\u2081) : (affineSpan k s).map f = affineSpan k (f '' s)", "start": [1580, 1], "end": [1588, 55], "kind": "commanddeclaration"}, {"full_name": "AffineMap.map_top_of_surjective", "code": "@[simp]\ntheorem map_top_of_surjective (hf : Function.Surjective f) : AffineSubspace.map f \u22a4 = \u22a4", "start": [1595, 1], "end": [1598, 36], "kind": "commanddeclaration"}, {"full_name": "AffineMap.span_eq_top_of_surjective", "code": "theorem span_eq_top_of_surjective {s : Set P\u2081} (hf : Function.Surjective f)\n    (h : affineSpan k s = \u22a4) : affineSpan k (f '' s) = \u22a4", "start": [1601, 1], "end": [1603, 64], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.span_eq_top_iff", "code": "theorem span_eq_top_iff {s : Set P\u2081} (e : P\u2081 \u2243\u1d43[k] P\u2082) :\n    affineSpan k s = \u22a4 \u2194 affineSpan k (e '' s) = \u22a4", "start": [1610, 1], "end": [1616, 77], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap", "code": "def comap (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : AffineSubspace k P\u2082) : AffineSubspace k P\u2081 where\n  carrier := f \u207b\u00b9' s\n  smul_vsub_vadd_mem t p\u2081 p\u2082 p\u2083 (hp\u2081 : f p\u2081 \u2208 s) (hp\u2082 : f p\u2082 \u2208 s) (hp\u2083 : f p\u2083 \u2208 s) :=\n    show f _ \u2208 s by\n      rw [AffineMap.map_vadd, LinearMap.map_smul, AffineMap.linearMap_vsub]\n      apply s.smul_vsub_vadd_mem _ hp\u2081 hp\u2082 hp\u2083", "start": [1625, 1], "end": [1631, 47], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.coe_comap", "code": "@[simp]\ntheorem coe_comap (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : AffineSubspace k P\u2082) : (s.comap f : Set P\u2081) = f \u207b\u00b9' \u2191s", "start": [1634, 1], "end": [1636, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.mem_comap", "code": "@[simp]\ntheorem mem_comap {f : P\u2081 \u2192\u1d43[k] P\u2082} {x : P\u2081} {s : AffineSubspace k P\u2082} : x \u2208 s.comap f \u2194 f x \u2208 s", "start": [1639, 1], "end": [1641, 10], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_mono", "code": "theorem comap_mono {f : P\u2081 \u2192\u1d43[k] P\u2082} {s t : AffineSubspace k P\u2082} : s \u2264 t \u2192 s.comap f \u2264 t.comap f", "start": [1644, 1], "end": [1645, 16], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_top", "code": "@[simp]\ntheorem comap_top {f : P\u2081 \u2192\u1d43[k] P\u2082} : (\u22a4 : AffineSubspace k P\u2082).comap f = \u22a4", "start": [1648, 1], "end": [1651, 31], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_bot", "code": "@[simp] theorem comap_bot (f : P\u2081 \u2192\u1d43[k] P\u2082) : comap f \u22a5 = \u22a5", "start": [1654, 1], "end": [1654, 67], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_id", "code": "@[simp]\ntheorem comap_id (s : AffineSubspace k P\u2081) : s.comap (AffineMap.id k P\u2081) = s", "start": [1656, 1], "end": [1658, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_comap", "code": "theorem comap_comap (s : AffineSubspace k P\u2083) (f : P\u2081 \u2192\u1d43[k] P\u2082) (g : P\u2082 \u2192\u1d43[k] P\u2083) :\n    (s.comap g).comap f = s.comap (g.comp f)", "start": [1661, 1], "end": [1663, 6], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : P\u2081 \u2192\u1d43[k] P\u2082} {s : AffineSubspace k P\u2081} {t : AffineSubspace k P\u2082} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f", "start": [1667, 1], "end": [1669, 19], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.gc_map_comap", "code": "theorem gc_map_comap (f : P\u2081 \u2192\u1d43[k] P\u2082) : GaloisConnection (map f) (comap f)", "start": [1672, 1], "end": [1673, 22], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_comap_le", "code": "theorem map_comap_le (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : AffineSubspace k P\u2082) : (s.comap f).map f \u2264 s", "start": [1676, 1], "end": [1677, 28], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.le_comap_map", "code": "theorem le_comap_map (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : AffineSubspace k P\u2081) : s \u2264 (s.map f).comap f", "start": [1680, 1], "end": [1681, 28], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_sup", "code": "theorem map_sup (s t : AffineSubspace k P\u2081) (f : P\u2081 \u2192\u1d43[k] P\u2082) : (s \u2294 t).map f = s.map f \u2294 t.map f", "start": [1684, 1], "end": [1685, 25], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_iSup", "code": "theorem map_iSup {\u03b9 : Sort*} (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : \u03b9 \u2192 AffineSubspace k P\u2081) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [1688, 1], "end": [1690, 26], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_inf", "code": "theorem comap_inf (s t : AffineSubspace k P\u2082) (f : P\u2081 \u2192\u1d43[k] P\u2082) :\n    (s \u2293 t).comap f = s.comap f \u2293 t.comap f", "start": [1693, 1], "end": [1695, 25], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_supr", "code": "theorem comap_supr {\u03b9 : Sort*} (f : P\u2081 \u2192\u1d43[k] P\u2082) (s : \u03b9 \u2192 AffineSubspace k P\u2082) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [1698, 1], "end": [1700, 26], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_symm", "code": "@[simp]\ntheorem comap_symm (e : P\u2081 \u2243\u1d43[k] P\u2082) (s : AffineSubspace k P\u2081) :\n    s.comap (e.symm : P\u2082 \u2192\u1d43[k] P\u2081) = s.map e", "start": [1703, 1], "end": [1706, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.map_symm", "code": "@[simp]\ntheorem map_symm (e : P\u2081 \u2243\u1d43[k] P\u2082) (s : AffineSubspace k P\u2082) :\n    s.map (e.symm : P\u2082 \u2192\u1d43[k] P\u2081) = s.comap e", "start": [1709, 1], "end": [1712, 34], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.comap_span", "code": "theorem comap_span (f : P\u2081 \u2243\u1d43[k] P\u2082) (s : Set P\u2082) :\n    (affineSpan k s).comap (f : P\u2081 \u2192\u1d43[k] P\u2082) = affineSpan k (f \u207b\u00b9' s)", "start": [1715, 1], "end": [1717, 63], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel", "code": "def Parallel (s\u2081 s\u2082 : AffineSubspace k P) : Prop :=\n  \u2203 v : V, s\u2082 = s\u2081.map (constVAdd k P v)", "start": [1732, 1], "end": [1735, 41], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel.symm", "code": "@[symm]\ntheorem Parallel.symm {s\u2081 s\u2082 : AffineSubspace k P} (h : s\u2081 \u2225 s\u2082) : s\u2082 \u2225 s\u2081", "start": [1740, 1], "end": [1745, 35], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.parallel_comm", "code": "theorem parallel_comm {s\u2081 s\u2082 : AffineSubspace k P} : s\u2081 \u2225 s\u2082 \u2194 s\u2082 \u2225 s\u2081", "start": [1748, 1], "end": [1749, 33], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel.refl", "code": "@[refl]\ntheorem Parallel.refl (s : AffineSubspace k P) : s \u2225 s", "start": [1752, 1], "end": [1754, 15], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel.trans", "code": "@[trans]\ntheorem Parallel.trans {s\u2081 s\u2082 s\u2083 : AffineSubspace k P} (h\u2081\u2082 : s\u2081 \u2225 s\u2082) (h\u2082\u2083 : s\u2082 \u2225 s\u2083) :\n    s\u2081 \u2225 s\u2083", "start": [1757, 1], "end": [1763, 58], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel.direction_eq", "code": "theorem Parallel.direction_eq {s\u2081 s\u2082 : AffineSubspace k P} (h : s\u2081 \u2225 s\u2082) :\n    s\u2081.direction = s\u2082.direction", "start": [1766, 1], "end": [1769, 7], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.parallel_bot_iff_eq_bot", "code": "@[simp]\ntheorem parallel_bot_iff_eq_bot {s : AffineSubspace k P} : s \u2225 \u22a5 \u2194 s = \u22a5", "start": [1772, 1], "end": [1776, 37], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.bot_parallel_iff_eq_bot", "code": "@[simp]\ntheorem bot_parallel_iff_eq_bot {s : AffineSubspace k P} : \u22a5 \u2225 s \u2194 s = \u22a5", "start": [1779, 1], "end": [1781, 46], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot", "code": "theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s\u2081 s\u2082 : AffineSubspace k P} :\n    s\u2081 \u2225 s\u2082 \u2194 s\u2081.direction = s\u2082.direction \u2227 (s\u2081 = \u22a5 \u2194 s\u2082 = \u22a5)", "start": [1784, 1], "end": [1802, 28], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.Parallel.vectorSpan_eq", "code": "theorem Parallel.vectorSpan_eq {s\u2081 s\u2082 : Set P} (h : affineSpan k s\u2081 \u2225 affineSpan k s\u2082) :\n    vectorSpan k s\u2081 = vectorSpan k s\u2082", "start": [1805, 1], "end": [1808, 23], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty", "code": "theorem affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty {s\u2081 s\u2082 : Set P} :\n    affineSpan k s\u2081 \u2225 affineSpan k s\u2082 \u2194 vectorSpan k s\u2081 = vectorSpan k s\u2082 \u2227 (s\u2081 = \u2205 \u2194 s\u2082 = \u2205)", "start": [1811, 1], "end": [1815, 56], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eq", "code": "theorem affineSpan_pair_parallel_iff_vectorSpan_eq {p\u2081 p\u2082 p\u2083 p\u2084 : P} :\n    line[k, p\u2081, p\u2082] \u2225 line[k, p\u2083, p\u2084] \u2194\n      vectorSpan k ({p\u2081, p\u2082} : Set P) = vectorSpan k ({p\u2083, p\u2084} : Set P)", "start": [1818, 1], "end": [1822, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Star.lean", "imports": ["Mathlib/Analysis/Convex/Segment.lean", "Mathlib/Tactic/GCongr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StarConvex", "code": "def StarConvex : Prop :=\n  \u2200 \u2983y : E\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [66, 1], "end": [69, 80], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_segment_subset", "code": "theorem starConvex_iff_segment_subset : StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192 [x -[\ud835\udd5c] y] \u2286 s", "start": [74, 1], "end": [79, 40], "kind": "commanddeclaration"}, {"full_name": "StarConvex.segment_subset", "code": "theorem StarConvex.segment_subset (h : StarConvex \ud835\udd5c x s) {y : E} (hy : y \u2208 s) : [x -[\ud835\udd5c] y] \u2286 s", "start": [82, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "StarConvex.openSegment_subset", "code": "theorem StarConvex.openSegment_subset (h : StarConvex \ud835\udd5c x s) {y : E} (hy : y \u2208 s) :\n    openSegment \ud835\udd5c x y \u2286 s", "start": [86, 1], "end": [88, 65], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_pointwise_add_subset", "code": "theorem starConvex_iff_pointwise_add_subset :\n    StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 {x} + b \u2022 s \u2286 s", "start": [91, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "starConvex_empty", "code": "theorem starConvex_empty (x : E) : StarConvex \ud835\udd5c x \u2205", "start": [101, 1], "end": [101, 75], "kind": "commanddeclaration"}, {"full_name": "starConvex_univ", "code": "theorem starConvex_univ (x : E) : StarConvex \ud835\udd5c x univ", "start": [104, 1], "end": [104, 86], "kind": "commanddeclaration"}, {"full_name": "StarConvex.inter", "code": "theorem StarConvex.inter (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c x t) : StarConvex \ud835\udd5c x (s \u2229 t)", "start": [107, 1], "end": [108, 74], "kind": "commanddeclaration"}, {"full_name": "starConvex_sInter", "code": "theorem starConvex_sInter {S : Set (Set E)} (h : \u2200 s \u2208 S, StarConvex \ud835\udd5c x s) :\n    StarConvex \ud835\udd5c x (\u22c2\u2080 S)", "start": [111, 1], "end": [112, 87], "kind": "commanddeclaration"}, {"full_name": "starConvex_iInter", "code": "theorem starConvex_iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (h : \u2200 i, StarConvex \ud835\udd5c x (s i)) :\n    StarConvex \ud835\udd5c x (\u22c2 i, s i)", "start": [115, 1], "end": [117, 61], "kind": "commanddeclaration"}, {"full_name": "StarConvex.union", "code": "theorem StarConvex.union (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c x t) :\n    StarConvex \ud835\udd5c x (s \u222a t)", "start": [120, 1], "end": [124, 35], "kind": "commanddeclaration"}, {"full_name": "starConvex_iUnion", "code": "theorem starConvex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hs : \u2200 i, StarConvex \ud835\udd5c x (s i)) :\n    StarConvex \ud835\udd5c x (\u22c3 i, s i)", "start": [127, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "starConvex_sUnion", "code": "theorem starConvex_sUnion {S : Set (Set E)} (hS : \u2200 s \u2208 S, StarConvex \ud835\udd5c x s) :\n    StarConvex \ud835\udd5c x (\u22c3\u2080 S)", "start": [135, 1], "end": [138, 44], "kind": "commanddeclaration"}, {"full_name": "StarConvex.prod", "code": "theorem StarConvex.prod {y : F} {s : Set E} {t : Set F} (hs : StarConvex \ud835\udd5c x s)\n    (ht : StarConvex \ud835\udd5c y t) : StarConvex \ud835\udd5c (x, y) (s \u00d7\u02e2 t)", "start": [141, 1], "end": [143, 41], "kind": "commanddeclaration"}, {"full_name": "starConvex_pi", "code": "theorem starConvex_pi {\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (E i)] [\u2200 i, SMul \ud835\udd5c (E i)]\n    {x : \u2200 i, E i} {s : Set \u03b9} {t : \u2200 i, Set (E i)} (ht : \u2200 \u2983i\u2984, i \u2208 s \u2192 StarConvex \ud835\udd5c (x i) (t i)) :\n    StarConvex \ud835\udd5c x (s.pi t)", "start": [146, 1], "end": [148, 88], "kind": "commanddeclaration"}, {"full_name": "StarConvex.mem", "code": "theorem StarConvex.mem (hs : StarConvex \ud835\udd5c x s) (h : s.Nonempty) : x \u2208 s", "start": [157, 1], "end": [160, 37], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_forall_pos", "code": "theorem starConvex_iff_forall_pos (hx : x \u2208 s) : StarConvex \ud835\udd5c x s \u2194\n    \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [163, 1], "end": [173, 23], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_forall_ne_pos", "code": "theorem starConvex_iff_forall_ne_pos (hx : x \u2208 s) :\n    StarConvex \ud835\udd5c x s \u2194\n      \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [176, 1], "end": [189, 29], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_openSegment_subset", "code": "theorem starConvex_iff_openSegment_subset (hx : x \u2208 s) :\n    StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192 openSegment \ud835\udd5c x y \u2286 s", "start": [192, 1], "end": [195, 81], "kind": "commanddeclaration"}, {"full_name": "starConvex_singleton", "code": "theorem starConvex_singleton (x : E) : StarConvex \ud835\udd5c x {x}", "start": [198, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "StarConvex.linear_image", "code": "theorem StarConvex.linear_image (hs : StarConvex \ud835\udd5c x s) (f : E \u2192\u2097[\ud835\udd5c] F) :\n    StarConvex \ud835\udd5c (f x) (s.image f)", "start": [203, 1], "end": [207, 86], "kind": "commanddeclaration"}, {"full_name": "StarConvex.is_linear_image", "code": "theorem StarConvex.is_linear_image (hs : StarConvex \ud835\udd5c x s) {f : E \u2192 F} (hf : IsLinearMap \ud835\udd5c f) :\n    StarConvex \ud835\udd5c (f x) (f '' s)", "start": [210, 1], "end": [212, 30], "kind": "commanddeclaration"}, {"full_name": "StarConvex.linear_preimage", "code": "theorem StarConvex.linear_preimage {s : Set F} (f : E \u2192\u2097[\ud835\udd5c] F) (hs : StarConvex \ud835\udd5c (f x) s) :\n    StarConvex \ud835\udd5c x (s.preimage f)", "start": [215, 1], "end": [219, 24], "kind": "commanddeclaration"}, {"full_name": "StarConvex.is_linear_preimage", "code": "theorem StarConvex.is_linear_preimage {s : Set F} {f : E \u2192 F} (hs : StarConvex \ud835\udd5c (f x) s)\n    (hf : IsLinearMap \ud835\udd5c f) : StarConvex \ud835\udd5c x (preimage f s)", "start": [222, 1], "end": [224, 33], "kind": "commanddeclaration"}, {"full_name": "StarConvex.add", "code": "theorem StarConvex.add {t : Set E} (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c y t) :\n    StarConvex \ud835\udd5c (x + y) (s + t)", "start": [227, 1], "end": [230, 65], "kind": "commanddeclaration"}, {"full_name": "StarConvex.add_left", "code": "theorem StarConvex.add_left (hs : StarConvex \ud835\udd5c x s) (z : E) :\n    StarConvex \ud835\udd5c (z + x) ((fun x => z + x) '' s)", "start": [233, 1], "end": [238, 71], "kind": "commanddeclaration"}, {"full_name": "StarConvex.add_right", "code": "theorem StarConvex.add_right (hs : StarConvex \ud835\udd5c x s) (z : E) :\n    StarConvex \ud835\udd5c (x + z) ((fun x => x + z) '' s)", "start": [241, 1], "end": [246, 71], "kind": "commanddeclaration"}, {"full_name": "StarConvex.preimage_add_right", "code": "theorem StarConvex.preimage_add_right (hs : StarConvex \ud835\udd5c (z + x) s) :\n    StarConvex \ud835\udd5c x ((fun x => z + x) \u207b\u00b9' s)", "start": [249, 1], "end": [254, 77], "kind": "commanddeclaration"}, {"full_name": "StarConvex.preimage_add_left", "code": "theorem StarConvex.preimage_add_left (hs : StarConvex \ud835\udd5c (x + z) s) :\n    StarConvex \ud835\udd5c x ((fun x => x + z) \u207b\u00b9' s)", "start": [257, 1], "end": [261, 52], "kind": "commanddeclaration"}, {"full_name": "StarConvex.sub'", "code": "theorem StarConvex.sub' {s : Set (E \u00d7 E)} (hs : StarConvex \ud835\udd5c (x, y) s) :\n    StarConvex \ud835\udd5c (x - y) ((fun x : E \u00d7 E => x.1 - x.2) '' s)", "start": [272, 1], "end": [274, 49], "kind": "commanddeclaration"}, {"full_name": "StarConvex.smul", "code": "theorem StarConvex.smul (hs : StarConvex \ud835\udd5c x s) (c : \ud835\udd5c) : StarConvex \ud835\udd5c (c \u2022 x) (c \u2022 s)", "start": [289, 1], "end": [290, 43], "kind": "commanddeclaration"}, {"full_name": "StarConvex.preimage_smul", "code": "theorem StarConvex.preimage_smul {c : \ud835\udd5c} (hs : StarConvex \ud835\udd5c (c \u2022 x) s) :\n    StarConvex \ud835\udd5c x ((fun z => c \u2022 z) \u207b\u00b9' s)", "start": [293, 1], "end": [295, 45], "kind": "commanddeclaration"}, {"full_name": "StarConvex.affinity", "code": "theorem StarConvex.affinity (hs : StarConvex \ud835\udd5c x s) (z : E) (c : \ud835\udd5c) :\n    StarConvex \ud835\udd5c (z + c \u2022 x) ((fun x => z + c \u2022 x) '' s)", "start": [298, 1], "end": [301, 39], "kind": "commanddeclaration"}, {"full_name": "starConvex_zero_iff", "code": "theorem starConvex_zero_iff :\n    StarConvex \ud835\udd5c 0 s \u2194 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 \u2200 \u2983a : \ud835\udd5c\u2984, 0 \u2264 a \u2192 a \u2264 1 \u2192 a \u2022 x \u2208 s", "start": [316, 1], "end": [323, 63], "kind": "commanddeclaration"}, {"full_name": "StarConvex.add_smul_mem", "code": "theorem StarConvex.add_smul_mem (hs : StarConvex \ud835\udd5c x s) (hy : x + y \u2208 s) {t : \ud835\udd5c} (ht\u2080 : 0 \u2264 t)\n    (ht\u2081 : t \u2264 1) : x + t \u2022 y \u2208 s", "start": [332, 1], "end": [337, 62], "kind": "commanddeclaration"}, {"full_name": "StarConvex.smul_mem", "code": "theorem StarConvex.smul_mem (hs : StarConvex \ud835\udd5c 0 s) (hx : x \u2208 s) {t : \ud835\udd5c} (ht\u2080 : 0 \u2264 t)\n    (ht\u2081 : t \u2264 1) : t \u2022 x \u2208 s", "start": [340, 1], "end": [341, 92], "kind": "commanddeclaration"}, {"full_name": "StarConvex.add_smul_sub_mem", "code": "theorem StarConvex.add_smul_sub_mem (hs : StarConvex \ud835\udd5c x s) (hy : y \u2208 s) {t : \ud835\udd5c} (ht\u2080 : 0 \u2264 t)\n    (ht\u2081 : t \u2264 1) : x + t \u2022 (y - x) \u2208 s", "start": [344, 1], "end": [348, 38], "kind": "commanddeclaration"}, {"full_name": "StarConvex.affine_preimage", "code": "theorem StarConvex.affine_preimage (f : E \u2192\u1d43[\ud835\udd5c] F) {s : Set F} (hs : StarConvex \ud835\udd5c (f x) s) :\n    StarConvex \ud835\udd5c x (f \u207b\u00b9' s)", "start": [351, 1], "end": [356, 24], "kind": "commanddeclaration"}, {"full_name": "StarConvex.affine_image", "code": "theorem StarConvex.affine_image (f : E \u2192\u1d43[\ud835\udd5c] F) {s : Set E} (hs : StarConvex \ud835\udd5c x s) :\n    StarConvex \ud835\udd5c (f x) (f '' s)", "start": [359, 1], "end": [364, 43], "kind": "commanddeclaration"}, {"full_name": "StarConvex.neg", "code": "theorem StarConvex.neg (hs : StarConvex \ud835\udd5c x s) : StarConvex \ud835\udd5c (-x) (-s)", "start": [367, 1], "end": [369, 55], "kind": "commanddeclaration"}, {"full_name": "StarConvex.sub", "code": "theorem StarConvex.sub (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c y t) :\n    StarConvex \ud835\udd5c (x - y) (s - t)", "start": [372, 1], "end": [375, 22], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_div", "code": "theorem starConvex_iff_div : StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192\n    \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192 (a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y \u2208 s", "start": [390, 1], "end": [402, 26], "kind": "commanddeclaration"}, {"full_name": "StarConvex.mem_smul", "code": "theorem StarConvex.mem_smul (hs : StarConvex \ud835\udd5c 0 s) (hx : x \u2208 s) {t : \ud835\udd5c} (ht : 1 \u2264 t) :\n    x \u2208 t \u2022 s", "start": [405, 1], "end": [408, 55], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.starConvex", "code": "theorem Set.OrdConnected.starConvex [OrderedSemiring \ud835\udd5c] [OrderedAddCommMonoid E] [Module \ud835\udd5c E]\n    [OrderedSMul \ud835\udd5c E] {x : E} {s : Set E} (hs : s.OrdConnected) (hx : x \u2208 s)\n    (h : \u2200 y \u2208 s, x \u2264 y \u2228 y \u2264 x) : StarConvex \ud835\udd5c x s", "start": [424, 1], "end": [442, 39], "kind": "commanddeclaration"}, {"full_name": "starConvex_iff_ordConnected", "code": "theorem starConvex_iff_ordConnected [LinearOrderedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c} (hx : x \u2208 s) :\n    StarConvex \ud835\udd5c x s \u2194 s.OrdConnected", "start": [445, 1], "end": [447, 97], "kind": "commanddeclaration"}, {"full_name": "StarConvex.ordConnected", "code": "alias \u27e8StarConvex.ordConnected, _\u27e9 := starConvex_iff_ordConnected", "start": [450, 1], "end": [450, 66], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Order/Copy.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoundedOrder.copy", "code": "def BoundedOrder.copy {h : LE \u03b1} {h' : LE \u03b1} (c : @BoundedOrder \u03b1 h')\n    (top : \u03b1) (eq_top : top = (by infer_instance : Top \u03b1).top)\n    (bot : \u03b1) (eq_bot : bot = (by infer_instance : Bot \u03b1).bot)\n    (le_eq : \u2200 x y : \u03b1, (@LE.le \u03b1 h) x y \u2194 x \u2264 y) : @BoundedOrder \u03b1 h :=\n  @BoundedOrder.mk \u03b1 h (@OrderTop.mk \u03b1 h { top := top } (fun _ \u21a6 by simp [eq_top, le_eq]))\n    (@OrderBot.mk \u03b1 h { bot := bot } (fun _ \u21a6 by simp [eq_bot, le_eq]))", "start": [27, 1], "end": [34, 72], "kind": "commanddeclaration"}, {"full_name": "Lattice.copy", "code": "def Lattice.copy (c : Lattice \u03b1)\n    (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf) : Lattice \u03b1 := by\n  refine' { le := le, sup := sup, inf := inf, lt := fun a b \u21a6 le a b \u2227 \u00ac le b a.. }\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ _ hab hbc; rw [eq_le] at hab hbc \u22a2; exact le_trans hab hbc\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ hab hba; simp_rw [eq_le] at hab hba; exact le_antisymm hab hba\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_sup, hac, hbc]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_inf, hac, hbc]", "start": [39, 1], "end": [55, 79], "kind": "commanddeclaration"}, {"full_name": "DistribLattice.copy", "code": "def DistribLattice.copy (c : DistribLattice \u03b1)\n    (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf) : DistribLattice \u03b1 := by\n  refine' { le := le, sup := sup, inf := inf, lt := fun a b \u21a6 le a b \u2227 \u00ac le b a.. }\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ _ hab hbc; rw [eq_le] at hab hbc \u22a2; exact le_trans hab hbc\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ hab hba; simp_rw [eq_le] at hab hba; exact le_antisymm hab hba\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_sup, hac, hbc]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_inf, hac, hbc]\n  \u00b7 intros; simp [eq_le, eq_inf, eq_sup, le_sup_inf]", "start": [60, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.copy", "code": "def CompleteLattice.copy (c : CompleteLattice \u03b1)\n    (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (top : \u03b1) (eq_top : top = (by infer_instance : Top \u03b1).top)\n    (bot : \u03b1) (eq_bot : bot = (by infer_instance : Bot \u03b1).bot)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf)\n    (sSup : Set \u03b1 \u2192 \u03b1) (eq_sSup : sSup = (by infer_instance : SupSet \u03b1).sSup)\n    (sInf : Set \u03b1 \u2192 \u03b1) (eq_sInf : sInf = (by infer_instance : InfSet \u03b1).sInf) :\n    CompleteLattice \u03b1 := by\n  refine' { Lattice.copy (@CompleteLattice.toLattice \u03b1 c) le eq_le sup eq_sup inf eq_inf with\n    le := le, top := top, bot := bot, sup := sup, inf := inf, sSup := sSup, sInf := sInf.. }\n  \u00b7 intro _ _ h; simp [eq_le, eq_sSup, le_sSup _ _ h]\n  \u00b7 intro _ _ h; simpa [eq_le, eq_sSup] using h\n  \u00b7 intro _ _ h; simp [eq_le, eq_sInf, sInf_le _ _ h]\n  \u00b7 intro _ _ h; simpa [eq_le, eq_sInf] using h\n  \u00b7 intros; simp [eq_le, eq_top]\n  \u00b7 intros; simp [eq_le, eq_bot]", "start": [82, 1], "end": [100, 33], "kind": "commanddeclaration"}, {"full_name": "Frame.copy", "code": "def Frame.copy (c : Frame \u03b1) (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (top : \u03b1) (eq_top : top = (by infer_instance : Top \u03b1).top)\n    (bot : \u03b1) (eq_bot : bot = (by infer_instance : Bot \u03b1).bot)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf)\n    (sSup : Set \u03b1 \u2192 \u03b1) (eq_sSup : sSup = (by infer_instance : SupSet \u03b1).sSup)\n    (sInf : Set \u03b1 \u2192 \u03b1) (eq_sInf : sInf = (by infer_instance : InfSet \u03b1).sInf) : Frame \u03b1 :=\n  { CompleteLattice.copy (@Frame.toCompleteLattice \u03b1 c) le eq_le top eq_top bot eq_bot\n      sup eq_sup inf eq_inf sSup eq_sSup sInf eq_sInf with\n    inf_sSup_le_iSup_inf := fun a s => by\n      simp [eq_le, eq_sup, eq_inf, eq_sSup, @Order.Frame.inf_sSup_le_iSup_inf \u03b1 _ a s] }", "start": [105, 1], "end": [117, 89], "kind": "commanddeclaration"}, {"full_name": "Coframe.copy", "code": "def Coframe.copy (c : Coframe \u03b1) (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (top : \u03b1) (eq_top : top = (by infer_instance : Top \u03b1).top)\n    (bot : \u03b1) (eq_bot : bot = (by infer_instance : Bot \u03b1).bot)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf)\n    (sSup : Set \u03b1 \u2192 \u03b1) (eq_sSup : sSup = (by infer_instance : SupSet \u03b1).sSup)\n    (sInf : Set \u03b1 \u2192 \u03b1) (eq_sInf : sInf = (by infer_instance : InfSet \u03b1).sInf) : Coframe \u03b1 :=\n  { CompleteLattice.copy (@Coframe.toCompleteLattice \u03b1 c) le eq_le top eq_top bot eq_bot sup\n        eq_sup inf eq_inf sSup eq_sSup sInf eq_sInf with\n    iInf_sup_le_sup_sInf := fun a s => by\n      simp [eq_le, eq_sup, eq_inf, eq_sInf, @Order.Coframe.iInf_sup_le_sup_sInf \u03b1 _ a s] }", "start": [122, 1], "end": [134, 91], "kind": "commanddeclaration"}, {"full_name": "CompleteDistribLattice.copy", "code": "def CompleteDistribLattice.copy (c : CompleteDistribLattice \u03b1)\n    (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (top : \u03b1) (eq_top : top = (by infer_instance : Top \u03b1).top)\n    (bot : \u03b1) (eq_bot : bot = (by infer_instance : Bot \u03b1).bot)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf)\n    (sSup : Set \u03b1 \u2192 \u03b1) (eq_sSup : sSup = (by infer_instance : SupSet \u03b1).sSup)\n    (sInf : Set \u03b1 \u2192 \u03b1) (eq_sInf : sInf = (by infer_instance : InfSet \u03b1).sInf) :\n    CompleteDistribLattice \u03b1 :=\n  { Frame.copy (@CompleteDistribLattice.toFrame \u03b1 c) le eq_le top eq_top bot eq_bot sup eq_sup inf\n      eq_inf sSup eq_sSup sInf eq_sInf,\n    Coframe.copy (@CompleteDistribLattice.toCoframe \u03b1 c) le eq_le top eq_top bot eq_bot sup eq_sup\n      inf eq_inf sSup eq_sSup sInf eq_sInf with }", "start": [137, 1], "end": [151, 50], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLattice.copy", "code": "def ConditionallyCompleteLattice.copy (c : ConditionallyCompleteLattice \u03b1)\n    (le : \u03b1 \u2192 \u03b1 \u2192 Prop) (eq_le : le = (by infer_instance : LE \u03b1).le)\n    (sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_sup : sup = (by infer_instance : Sup \u03b1).sup)\n    (inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (eq_inf : inf = (by infer_instance : Inf \u03b1).inf)\n    (sSup : Set \u03b1 \u2192 \u03b1) (eq_sSup : sSup = (by infer_instance : SupSet \u03b1).sSup)\n    (sInf : Set \u03b1 \u2192 \u03b1) (eq_sInf : sInf = (by infer_instance : InfSet \u03b1).sInf) :\n    ConditionallyCompleteLattice \u03b1 := by\n  refine' { le := le, sup := sup, inf := inf, sSup := sSup, sInf := sInf.. }\n  \u00b7 intro a b; exact le a b \u2227 \u00ac le b a\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ _ hab hbc; rw [eq_le] at hab hbc \u22a2; exact le_trans hab hbc\n  \u00b7 intros; simp [eq_le]\n  \u00b7 intro _ _ hab hba; simp_rw [eq_le] at hab hba; exact le_antisymm hab hba\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intros; simp [eq_le, eq_sup]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_sup, hac, hbc]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intros; simp [eq_le, eq_inf]\n  \u00b7 intro _ _ _ hac hbc; simp_rw [eq_le] at hac hbc \u22a2; simp [eq_inf, hac, hbc]\n  \u00b7 intro _ _ hb h; subst_vars; exact le_csSup _ _ hb h\n  \u00b7 intro _ _ hb h; subst_vars; exact csSup_le _ _ hb h\n  \u00b7 intro _ _ hb h; subst_vars; exact csInf_le _ _ hb h\n  \u00b7 intro _ _ hb h; subst_vars; exact le_csInf _ _ hb h", "start": [156, 1], "end": [180, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/Finrank.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.Free.linearMap", "code": "instance Module.Free.linearMap [Module.Finite R M] [Module.Finite R N] :\n    Module.Free R (M \u2192\u2097[R] N) := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 apply Module.Free.of_subsingleton'\n  classical exact\n      Module.Free.of_equiv (LinearMap.toMatrix (chooseBasis R M) (chooseBasis R N)).symm", "start": [40, 1], "end": [45, 89], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.linearMap", "code": "instance Module.Finite.linearMap [Module.Finite R M] [Module.Finite R N] :\n    Module.Finite R (M \u2192\u2097[R] N) := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 infer_instance\n  classical\n    have f := (LinearMap.toMatrix (chooseBasis R M) (chooseBasis R N)).symm\n    exact Module.Finite.of_surjective f.toLinearMap (LinearEquiv.surjective f)", "start": [50, 1], "end": [56, 79], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.addMonoidHom", "code": "instance Module.Finite.addMonoidHom : Module.Finite \u2124 (M \u2192+ N) :=\n  Module.Finite.equiv (addMonoidHomLequivInt \u2124).symm", "start": [67, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "Module.Free.addMonoidHom", "code": "instance Module.Free.addMonoidHom : Module.Free \u2124 (M \u2192+ N) :=\n  letI : Module.Free \u2124 (M \u2192\u2097[\u2124] N) := Module.Free.linearMap _ _ _\n  Module.Free.of_equiv (addMonoidHomLequivInt \u2124).symm", "start": [71, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_linearMap", "code": "theorem FiniteDimensional.finrank_linearMap :\n    finrank R (M \u2192\u2097[R] N) = finrank R M * finrank R N", "start": [86, 1], "end": [93, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_vecMulVec", "code": "theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [StrongRankCondition K] [Fintype n]\n    [DecidableEq n] (w : m \u2192 K) (v : n \u2192 K) : (Matrix.vecMulVec w v).toLin'.rank \u2264 1", "start": [98, 1], "end": [103, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FiniteDimensional.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/FieldTheory/Finiteness.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyCongr.lean"], "premises": [{"full_name": "FiniteDimensional", "code": "@[reducible]\ndef FiniteDimensional (K V : Type*) [DivisionRing K] [AddCommGroup V] [Module K V] :=\n  Module.Finite K V", "start": [84, 1], "end": [88, 20], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.of_injective", "code": "theorem of_injective (f : V \u2192\u2097[K] V\u2082) (w : Function.Injective f) [FiniteDimensional K V\u2082] :\n    FiniteDimensional K V", "start": [102, 1], "end": [106, 33], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.of_surjective", "code": "theorem of_surjective (f : V \u2192\u2097[K] V\u2082) (w : Function.Surjective f) [FiniteDimensional K V] :\n    FiniteDimensional K V\u2082", "start": [109, 1], "end": [112, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_pi", "code": "instance finiteDimensional_pi {\u03b9 : Type*} [Finite \u03b9] : FiniteDimensional K (\u03b9 \u2192 K) :=\n  iff_fg.1 isNoetherian_pi", "start": [117, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_pi'", "code": "instance finiteDimensional_pi' {\u03b9 : Type*} [Finite \u03b9] (M : \u03b9 \u2192 Type*) [\u2200 i, AddCommGroup (M i)]\n    [\u2200 i, Module K (M i)] [I : \u2200 i, FiniteDimensional K (M i)] : FiniteDimensional K (\u2200 i, M i) :=\n  haveI : \u2200 i : \u03b9, IsNoetherian K (M i) := fun i => iff_fg.2 (I i)\n  iff_fg.1 isNoetherian_pi", "start": [121, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.fintypeOfFintype", "code": "noncomputable def fintypeOfFintype [Fintype K] [FiniteDimensional K V] : Fintype V :=\n  Module.fintypeOfFintype (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance))", "start": [127, 1], "end": [129, 76], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finite_of_finite", "code": "theorem finite_of_finite [Finite K] [FiniteDimensional K V] : Finite V", "start": [132, 1], "end": [135, 17], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.of_fintype_basis", "code": "theorem of_fintype_basis {\u03b9 : Type w} [Finite \u03b9] (h : Basis \u03b9 K V) : FiniteDimensional K V", "start": [140, 1], "end": [146, 11], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.fintypeBasisIndex", "code": "noncomputable def fintypeBasisIndex {\u03b9 : Type*} [FiniteDimensional K V] (b : Basis \u03b9 K V) :\n    Fintype \u03b9 :=\n  letI : IsNoetherian K V := IsNoetherian.iff_fg.2 inferInstance\n  IsNoetherian.fintypeBasisIndex b", "start": [149, 1], "end": [153, 35], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.of_finite_basis", "code": "theorem of_finite_basis {\u03b9 : Type w} {s : Set \u03b9} (h : Basis s K V) (hs : Set.Finite s) :\n    FiniteDimensional K V", "start": [162, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_submodule", "code": "instance finiteDimensional_submodule [FiniteDimensional K V] (S : Submodule K V) :\n    FiniteDimensional K S := by\n  letI : IsNoetherian K V := iff_fg.2 ?_\n  exact\n    iff_fg.1\n      (IsNoetherian.iff_rank_lt_aleph0.2\n        (lt_of_le_of_lt (rank_submodule_le _) (rank_lt_aleph0 K V)))\n  infer_instance", "start": [170, 1], "end": [178, 17], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_quotient", "code": "instance finiteDimensional_quotient [FiniteDimensional K V] (S : Submodule K V) :\n    FiniteDimensional K (V \u29f8 S) :=\n  Module.Finite.of_surjective (Submodule.mkQ S) <| surjective_quot_mk _", "start": [181, 1], "end": [184, 72], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_rank'", "code": "theorem finrank_eq_rank' [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V", "start": [189, 1], "end": [192, 22], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_of_infinite_dimensional", "code": "theorem finrank_of_infinite_dimensional (h : \u00acFiniteDimensional K V) : finrank K V = 0", "start": [197, 1], "end": [198, 80], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_of_finrank", "code": "theorem finiteDimensional_of_finrank (h : 0 < finrank K V) : FiniteDimensional K V", "start": [201, 1], "end": [203, 43], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_of_finrank_eq_succ", "code": "theorem finiteDimensional_of_finrank_eq_succ {n : \u2115} (hn : finrank K V = n.succ) :\n    FiniteDimensional K V", "start": [206, 1], "end": [208, 63], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.fact_finiteDimensional_of_finrank_eq_succ", "code": "theorem fact_finiteDimensional_of_finrank_eq_succ (n : \u2115) [Fact (finrank K V = n + 1)] :\n    FiniteDimensional K V", "start": [211, 1], "end": [215, 76], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_iff_of_rank_eq_nsmul", "code": "theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : \u2115}\n    (hn : n \u2260 0) (hVW : Module.rank K V = n \u2022 Module.rank K W) :\n    FiniteDimensional K V \u2194 FiniteDimensional K W", "start": [218, 1], "end": [222, 48], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_eq_card_basis'", "code": "theorem finrank_eq_card_basis' [FiniteDimensional K V] {\u03b9 : Type w} (h : Basis \u03b9 K V) :\n    (finrank K V : Cardinal.{w}) = #\u03b9", "start": [225, 1], "end": [231, 52], "kind": "commanddeclaration"}, {"full_name": "Basis.unique", "code": "noncomputable def _root_.Basis.unique {\u03b9 : Type*} (b : Basis \u03b9 K K) : Unique \u03b9 := by\n  have A : Cardinal.mk \u03b9 = \u2191(FiniteDimensional.finrank K K) :=\n    (FiniteDimensional.finrank_eq_card_basis' b).symm\n  simp only [Cardinal.eq_one_iff_unique, FiniteDimensional.finrank_self, Nat.cast_one] at A\n  exact Nonempty.some ((unique_iff_subsingleton_and_nonempty _).2 A)", "start": [234, 1], "end": [240, 69], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finBasis", "code": "noncomputable def finBasis [FiniteDimensional K V] : Basis (Fin (finrank K V)) K V :=\n  have h : Fintype.card (@finsetBasisIndex K V _ _ _ (iff_fg.2 inferInstance)) = finrank K V :=\n    (finrank_eq_card_basis (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance))).symm\n  (@finsetBasis K V _ _ _ (iff_fg.2 inferInstance)).reindex (Fintype.equivFinOfCardEq h)", "start": [245, 1], "end": [249, 89], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finBasisOfFinrankEq", "code": "noncomputable def finBasisOfFinrankEq [FiniteDimensional K V] {n : \u2115} (hn : finrank K V = n) :\n    Basis (Fin n) K V :=\n  (finBasis K V).reindex (Fin.castIso hn).toEquiv", "start": [252, 1], "end": [255, 50], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.basisUnique", "code": "noncomputable def basisUnique (\u03b9 : Type*) [Unique \u03b9] (h : finrank K V = 1) : Basis \u03b9 K V :=\n  haveI : FiniteDimensional _ _ :=\n    finiteDimensional_of_finrank (_root_.zero_lt_one.trans_le h.symm.le)\n  (finBasisOfFinrankEq K V h).reindex (Equiv.equivOfUnique _ _)", "start": [260, 1], "end": [264, 64], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.basisUnique.repr_eq_zero_iff", "code": "@[simp]\ntheorem basisUnique.repr_eq_zero_iff {\u03b9 : Type*} [Unique \u03b9] {h : finrank K V = 1} {v : V} {i : \u03b9} :\n    (basisUnique \u03b9 h).repr v i = 0 \u2194 v = 0", "start": [267, 1], "end": [272, 68], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.cardinal_mk_le_finrank_of_linearIndependent", "code": "theorem cardinal_mk_le_finrank_of_linearIndependent [FiniteDimensional K V] {\u03b9 : Type w} {b : \u03b9 \u2192 V}\n    (h : LinearIndependent K b) : #\u03b9 \u2264 finrank K V", "start": [275, 1], "end": [279, 49], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.fintype_card_le_finrank_of_linearIndependent", "code": "theorem fintype_card_le_finrank_of_linearIndependent [FiniteDimensional K V] {\u03b9 : Type*}\n    [Fintype \u03b9] {b : \u03b9 \u2192 V} (h : LinearIndependent K b) : Fintype.card \u03b9 \u2264 finrank K V", "start": [282, 1], "end": [284, 60], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finset_card_le_finrank_of_linearIndependent", "code": "theorem finset_card_le_finrank_of_linearIndependent [FiniteDimensional K V] {b : Finset V}\n    (h : LinearIndependent K (fun x => x : b \u2192 V)) : b.card \u2264 finrank K V", "start": [287, 1], "end": [290, 55], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.lt_aleph0_of_linearIndependent", "code": "theorem lt_aleph0_of_linearIndependent {\u03b9 : Type w} [FiniteDimensional K V] {v : \u03b9 \u2192 V}\n    (h : LinearIndependent K v) : #\u03b9 < \u2135\u2080", "start": [293, 1], "end": [299, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.finite", "code": "theorem _root_.LinearIndependent.finite [FiniteDimensional K V] {b : Set V}\n    (h : LinearIndependent K fun x : b => (x : V)) : b.Finite", "start": [302, 1], "end": [304, 92], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.not_linearIndependent_of_infinite", "code": "theorem not_linearIndependent_of_infinite {\u03b9 : Type w} [inf : Infinite \u03b9] [FiniteDimensional K V]\n    (v : \u03b9 \u2192 V) : \u00acLinearIndependent K v", "start": [307, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_pos_iff_exists_ne_zero", "code": "theorem finrank_pos_iff_exists_ne_zero [FiniteDimensional K V] : 0 < finrank K V \u2194 \u2203 x : V, x \u2260 0", "start": [315, 1], "end": [321, 49], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_pos_iff", "code": "theorem finrank_pos_iff [FiniteDimensional K V] : 0 < finrank K V \u2194 Nontrivial V", "start": [324, 1], "end": [330, 45], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_pos", "code": "theorem finrank_pos [FiniteDimensional K V] [h : Nontrivial V] : 0 < finrank K V", "start": [333, 1], "end": [335, 24], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_zero_iff", "code": "theorem finrank_zero_iff [FiniteDimensional K V] : finrank K V = 0 \u2194 Subsingleton V", "start": [338, 1], "end": [345, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_top_of_finrank_eq", "code": "theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}\n    (h : finrank K S = finrank K V) : S = \u22a4", "start": [348, 1], "end": [374, 58], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finiteDimensional_self", "code": "instance finiteDimensional_self : FiniteDimensional K K := by infer_instance", "start": [380, 1], "end": [380, 77], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.span_of_finite", "code": "theorem span_of_finite {A : Set V} (hA : Set.Finite A) : FiniteDimensional K (Submodule.span K A)", "start": [383, 1], "end": [385, 47], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.span_singleton", "code": "instance span_singleton (x : V) : FiniteDimensional K (K \u2219 x) :=\n  span_of_finite K <| Set.finite_singleton _", "start": [388, 1], "end": [390, 45], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.span_finset", "code": "instance span_finset (s : Finset V) : FiniteDimensional K (span K (s : Set V)) :=\n  span_of_finite K <| s.finite_toSet", "start": [393, 1], "end": [395, 37], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux", "code": "theorem _root_.CompleteLattice.Independent.subtype_ne_bot_le_finrank_aux [FiniteDimensional K V]\n    {\u03b9 : Type w} {p : \u03b9 \u2192 Submodule K V} (hp : CompleteLattice.Independent p) :\n    #{ i // p i \u2260 \u22a5 } \u2264 (finrank K V : Cardinal.{w})", "start": [405, 1], "end": [414, 66], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional", "code": "noncomputable def _root_.CompleteLattice.Independent.fintypeNeBotOfFiniteDimensional\n    [FiniteDimensional K V] {\u03b9 : Type w} {p : \u03b9 \u2192 Submodule K V}\n    (hp : CompleteLattice.Independent p) : Fintype { i : \u03b9 // p i \u2260 \u22a5 } := by\n  suffices #{ i // p i \u2260 \u22a5 } < (\u2135\u2080 : Cardinal.{w}) by\n    rw [Cardinal.lt_aleph0_iff_fintype] at this\n    exact this.some\n  refine' lt_of_le_of_lt hp.subtype_ne_bot_le_finrank_aux _\n  simp [Cardinal.nat_lt_aleph0]", "start": [417, 1], "end": [426, 32], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.subtype_ne_bot_le_finrank", "code": "theorem _root_.CompleteLattice.Independent.subtype_ne_bot_le_finrank [FiniteDimensional K V]\n    {\u03b9 : Type w} {p : \u03b9 \u2192 Submodule K V} (hp : CompleteLattice.Independent p)\n    [Fintype { i // p i \u2260 \u22a5 }] :\n    Fintype.card { i // p i \u2260 \u22a5 } \u2264 finrank K V", "start": [429, 1], "end": [437, 99], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.exists_nontrivial_relation_of_rank_lt_card", "code": "theorem exists_nontrivial_relation_of_rank_lt_card [FiniteDimensional K V] {t : Finset V}\n    (h : finrank K V < t.card) : \u2203 f : V \u2192 K, \u2211 e in t, f e \u2022 e = 0 \u2227 \u2203 x \u2208 t, f x \u2260 0", "start": [446, 1], "end": [482, 56], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card", "code": "theorem exists_nontrivial_relation_sum_zero_of_rank_succ_lt_card [FiniteDimensional K V]\n    {t : Finset V} (h : finrank K V + 1 < t.card) :\n    \u2203 f : V \u2192 K, \u2211 e in t, f e \u2022 e = 0 \u2227 \u2211 e in t, f e = 0 \u2227 \u2203 x \u2208 t, f x \u2260 0", "start": [485, 1], "end": [568, 79], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card", "code": "theorem exists_relation_sum_zero_pos_coefficient_of_rank_succ_lt_card [FiniteDimensional L W]\n    {t : Finset W} (h : finrank L W + 1 < t.card) :\n    \u2203 f : W \u2192 L, \u2211 e in t, f e \u2022 e = 0 \u2227 \u2211 e in t, f e = 0 \u2227 \u2203 x \u2208 t, 0 < f x", "start": [577, 1], "end": [585, 82], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.basisSingleton", "code": "@[simps repr_apply]\nnoncomputable def basisSingleton (\u03b9 : Type*) [Unique \u03b9] (h : finrank K V = 1) (v : V)\n    (hv : v \u2260 0) : Basis \u03b9 K V :=\n  let b := basisUnique \u03b9 h\n  let h : b.repr v default \u2260 0 := mt basisUnique.repr_eq_zero_iff.mp hv\n  Basis.ofRepr\n    { toFun := fun w => Finsupp.single default (b.repr w default / b.repr v default)\n      invFun := fun f => f default \u2022 v\n      map_add' := by simp [add_div]\n      map_smul' := by simp [mul_div]\n      left_inv := fun w => by\n        apply_fun b.repr using b.repr.toEquiv.injective\n        apply_fun Equiv.finsuppUnique\n        simp only [LinearEquiv.map_smul\u209b\u2097, Finsupp.coe_smul, Finsupp.single_eq_same,\n          RingHom.id_apply, smul_eq_mul, Pi.smul_apply, Equiv.finsuppUnique_apply]\n        exact div_mul_cancel _ h\n      right_inv := fun f => by\n        ext\n        simp only [LinearEquiv.map_smul\u209b\u2097, Finsupp.coe_smul, Finsupp.single_eq_same,\n          RingHom.id_apply, smul_eq_mul, Pi.smul_apply]\n        exact mul_div_cancel _ h }", "start": [592, 1], "end": [613, 35], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.basisSingleton_apply", "code": "@[simp]\ntheorem basisSingleton_apply (\u03b9 : Type*) [Unique \u03b9] (h : finrank K V = 1) (v : V) (hv : v \u2260 0)\n    (i : \u03b9) : basisSingleton \u03b9 h v hv i = v", "start": [616, 1], "end": [620, 24], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.range_basisSingleton", "code": "@[simp]\ntheorem range_basisSingleton (\u03b9 : Type*) [Unique \u03b9] (h : finrank K V = 1) (v : V) (hv : v \u2260 0) :\n    Set.range (basisSingleton \u03b9 h v hv) = {v}", "start": [623, 1], "end": [625, 96], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_rank_eq_nat", "code": "theorem finiteDimensional_of_rank_eq_nat {n : \u2115} (h : Module.rank K V = n) :\n    FiniteDimensional K V", "start": [638, 1], "end": [641, 24], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_rank_eq_zero", "code": "theorem finiteDimensional_of_rank_eq_zero (h : Module.rank K V = 0) : FiniteDimensional K V", "start": [645, 1], "end": [646, 65], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_of_rank_eq_one", "code": "theorem finiteDimensional_of_rank_eq_one (h : Module.rank K V = 1) : FiniteDimensional K V", "start": [649, 1], "end": [650, 64], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero_of_rank_eq_zero", "code": "theorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) :\n    finrank K V = 0", "start": [653, 1], "end": [656, 20], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_bot", "code": "instance finiteDimensional_bot : FiniteDimensional K (\u22a5 : Submodule K V) :=\n  finiteDimensional_of_rank_eq_zero <| by simp", "start": [661, 1], "end": [662, 47], "kind": "commanddeclaration"}, {"full_name": "bot_eq_top_of_rank_eq_zero", "code": "theorem bot_eq_top_of_rank_eq_zero (h : Module.rank K V = 0) : (\u22a5 : Submodule K V) = \u22a4", "start": [667, 1], "end": [670, 54], "kind": "commanddeclaration"}, {"full_name": "rank_eq_zero", "code": "@[simp]\ntheorem rank_eq_zero {S : Submodule K V} : Module.rank K S = 0 \u2194 S = \u22a5", "start": [673, 1], "end": [680, 34], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_zero", "code": "@[simp]\ntheorem finrank_eq_zero {S : Submodule K V} [FiniteDimensional K S] : finrank K S = 0 \u2194 S = \u22a5", "start": [683, 1], "end": [685, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iff_finiteDimensional", "code": "theorem fg_iff_finiteDimensional (s : Submodule K V) : s.FG \u2194 FiniteDimensional K s", "start": [698, 1], "end": [700, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_of_le", "code": "theorem finiteDimensional_of_le {S\u2081 S\u2082 : Submodule K V} [FiniteDimensional K S\u2082] (h : S\u2081 \u2264 S\u2082) :\n    FiniteDimensional K S\u2081", "start": [703, 1], "end": [710, 93], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_inf_left", "code": "instance finiteDimensional_inf_left (S\u2081 S\u2082 : Submodule K V) [FiniteDimensional K S\u2081] :\n    FiniteDimensional K (S\u2081 \u2293 S\u2082 : Submodule K V) :=\n  finiteDimensional_of_le inf_le_left", "start": [713, 1], "end": [717, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_inf_right", "code": "instance finiteDimensional_inf_right (S\u2081 S\u2082 : Submodule K V) [FiniteDimensional K S\u2082] :\n    FiniteDimensional K (S\u2081 \u2293 S\u2082 : Submodule K V) :=\n  finiteDimensional_of_le inf_le_right", "start": [720, 1], "end": [724, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_sup", "code": "instance finiteDimensional_sup (S\u2081 S\u2082 : Submodule K V) [h\u2081 : FiniteDimensional K S\u2081]\n    [h\u2082 : FiniteDimensional K S\u2082] : FiniteDimensional K (S\u2081 \u2294 S\u2082 : Submodule K V) := by\n  unfold FiniteDimensional at *\n  rw [finite_def] at *\n  exact (fg_top _).2 (((fg_top S\u2081).1 h\u2081).sup ((fg_top S\u2082).1 h\u2082))", "start": [727, 1], "end": [733, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_finset_sup", "code": "instance finiteDimensional_finset_sup {\u03b9 : Type*} (s : Finset \u03b9) (S : \u03b9 \u2192 Submodule K V)\n    [\u2200 i, FiniteDimensional K (S i)] : FiniteDimensional K (s.sup S : Submodule K V) := by\n  refine'\n    @Finset.sup_induction _ _ _ _ s S (fun i => FiniteDimensional K \u2191i) (finiteDimensional_bot K V)\n      _ fun i _ => by infer_instance\n  \u00b7 intro S\u2081 hS\u2081 S\u2082 hS\u2082\n    exact Submodule.finiteDimensional_sup S\u2081 S\u2082", "start": [736, 1], "end": [747, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.finiteDimensional_iSup", "code": "instance finiteDimensional_iSup {\u03b9 : Sort*} [Finite \u03b9] (S : \u03b9 \u2192 Submodule K V)\n    [\u2200 i, FiniteDimensional K (S i)] : FiniteDimensional K \u2191(\u2a06 i, S i) := by\n  cases nonempty_fintype (PLift \u03b9)\n  rw [\u2190 iSup_plift_down, \u2190 Finset.sup_univ_eq_iSup]\n  exact Submodule.finiteDimensional_finset_sup _ _", "start": [750, 1], "end": [756, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_quotient_add_finrank", "code": "theorem finrank_quotient_add_finrank [FiniteDimensional K V] (s : Submodule K V) :\n    finrank K (V \u29f8 s) + finrank K s = finrank K V", "start": [759, 1], "end": [765, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_lt", "code": "theorem finrank_lt [FiniteDimensional K V] {s : Submodule K V} (h : s < \u22a4) :\n    finrank K s < finrank K V", "start": [768, 1], "end": [773, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_sup_add_finrank_inf_eq", "code": "theorem finrank_sup_add_finrank_inf_eq (s t : Submodule K V) [FiniteDimensional K s]\n    [FiniteDimensional K t] :\n    finrank K \u2191(s \u2294 t) + finrank K \u2191(s \u2293 t) = finrank K \u2191s + finrank K \u2191t", "start": [776, 1], "end": [783, 19], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_add_le_finrank_add_finrank", "code": "theorem finrank_add_le_finrank_add_finrank (s t : Submodule K V) [FiniteDimensional K s]\n    [FiniteDimensional K t] : finrank K (s \u2294 t : Submodule K V) \u2264 finrank K s + finrank K t", "start": [786, 1], "end": [789, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_top_of_disjoint", "code": "theorem eq_top_of_disjoint [FiniteDimensional K V] (s t : Submodule K V)\n    (hdim : finrank K s + finrank K t = finrank K V) (hdisjoint : Disjoint s t) : s \u2294 t = \u22a4", "start": [792, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.finiteDimensional", "code": "protected theorem finiteDimensional (f : V \u2243\u2097[K] V\u2082) [FiniteDimensional K V] :\n    FiniteDimensional K V\u2082", "start": [815, 1], "end": [818, 24], "kind": "commanddeclaration"}, {"full_name": "finiteDimensional_finsupp", "code": "instance finiteDimensional_finsupp {\u03b9 : Type*} [Finite \u03b9] [FiniteDimensional K V] :\n    FiniteDimensional K (\u03b9 \u2192\u2080 V) :=\n  (Finsupp.linearEquivFunOnFinite K V \u03b9).symm.finiteDimensional", "start": [831, 1], "end": [833, 64], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.eq_of_le_of_finrank_le", "code": "theorem eq_of_le_of_finrank_le {S\u2081 S\u2082 : Submodule K V} [FiniteDimensional K S\u2082] (hle : S\u2081 \u2264 S\u2082)\n    (hd : finrank K S\u2082 \u2264 finrank K S\u2081) : S\u2081 = S\u2082", "start": [845, 1], "end": [849, 90], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.eq_of_le_of_finrank_eq", "code": "theorem eq_of_le_of_finrank_eq {S\u2081 S\u2082 : Submodule K V} [FiniteDimensional K S\u2082] (hle : S\u2081 \u2264 S\u2082)\n    (hd : finrank K S\u2081 = finrank K S\u2082) : S\u2081 = S\u2082", "start": [852, 1], "end": [856, 35], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.LinearEquiv.quotEquivOfEquiv", "code": "noncomputable def LinearEquiv.quotEquivOfEquiv {p : Subspace K V} {q : Subspace K V\u2082}\n    (f\u2081 : p \u2243\u2097[K] q) (f\u2082 : V \u2243\u2097[K] V\u2082) : (V \u29f8 p) \u2243\u2097[K] V\u2082 \u29f8 q :=\n  LinearEquiv.ofFinrankEq _ _\n    (by\n      rw [\u2190 @add_right_cancel_iff _ _ _ (finrank K p), Submodule.finrank_quotient_add_finrank,\n        LinearEquiv.finrank_eq f\u2081, Submodule.finrank_quotient_add_finrank,\n        LinearEquiv.finrank_eq f\u2082])", "start": [861, 1], "end": [869, 36], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.LinearEquiv.quotEquivOfQuotEquiv", "code": "noncomputable def LinearEquiv.quotEquivOfQuotEquiv {p q : Subspace K V} (f : (V \u29f8 p) \u2243\u2097[K] q) :\n    (V \u29f8 q) \u2243\u2097[K] p :=\n  LinearEquiv.ofFinrankEq _ _ <|\n    add_right_cancel <| by\n      rw [Submodule.finrank_quotient_add_finrank, \u2190 LinearEquiv.finrank_eq f, add_comm,\n        Submodule.finrank_quotient_add_finrank]", "start": [873, 1], "end": [879, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.surjective_of_injective", "code": "theorem surjective_of_injective [FiniteDimensional K V] {f : V \u2192\u2097[K] V} (hinj : Injective f) :\n    Surjective f", "start": [895, 1], "end": [900, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finiteDimensional_of_surjective", "code": "theorem finiteDimensional_of_surjective [FiniteDimensional K V] (f : V \u2192\u2097[K] V\u2082)\n    (hf : LinearMap.range f = \u22a4) : FiniteDimensional K V\u2082", "start": [903, 1], "end": [906, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finiteDimensional_range", "code": "instance finiteDimensional_range [FiniteDimensional K V] (f : V \u2192\u2097[K] V\u2082) :\n    FiniteDimensional K (LinearMap.range f) :=\n  Module.Finite.range f", "start": [909, 1], "end": [912, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_iff_surjective", "code": "theorem injective_iff_surjective [FiniteDimensional K V] {f : V \u2192\u2097[K] V} :\n    Injective f \u2194 Surjective f", "start": [915, 1], "end": [922, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot_iff_range_eq_top", "code": "theorem ker_eq_bot_iff_range_eq_top [FiniteDimensional K V] {f : V \u2192\u2097[K] V} :\n    LinearMap.ker f = \u22a5 \u2194 LinearMap.range f = \u22a4", "start": [925, 1], "end": [927, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_eq_one_of_mul_eq_one", "code": "theorem mul_eq_one_of_mul_eq_one [FiniteDimensional K V] {f g : V \u2192\u2097[K] V} (hfg : f * g = 1) :\n    g * f = 1", "start": [930, 1], "end": [939, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_eq_one_comm", "code": "theorem mul_eq_one_comm [FiniteDimensional K V] {f g : V \u2192\u2097[K] V} : f * g = 1 \u2194 g * f = 1", "start": [942, 1], "end": [945, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_eq_id_comm", "code": "theorem comp_eq_id_comm [FiniteDimensional K V] {f g : V \u2192\u2097[K] V} : f.comp g = id \u2194 g.comp f = id", "start": [948, 1], "end": [951, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finrank_range_add_finrank_ker", "code": "theorem finrank_range_add_finrank_ker [FiniteDimensional K V] (f : V \u2192\u2097[K] V\u2082) :\n    finrank K (LinearMap.range f) + finrank K (LinearMap.ker f) = finrank K V", "start": [954, 1], "end": [959, 49], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInjectiveEndo", "code": "noncomputable def ofInjectiveEndo (f : V \u2192\u2097[K] V) (h_inj : Injective f) : V \u2243\u2097[K] V :=\n  LinearEquiv.ofBijective f \u27e8h_inj, LinearMap.injective_iff_surjective.mp h_inj\u27e9", "start": [974, 1], "end": [976, 81], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_ofInjectiveEndo", "code": "@[simp]\ntheorem coe_ofInjectiveEndo (f : V \u2192\u2097[K] V) (h_inj : Injective f) :\n    \u21d1(ofInjectiveEndo f h_inj) = f", "start": [979, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInjectiveEndo_right_inv", "code": "@[simp]\ntheorem ofInjectiveEndo_right_inv (f : V \u2192\u2097[K] V) (h_inj : Injective f) :\n    f * (ofInjectiveEndo f h_inj).symm = 1", "start": [985, 1], "end": [988, 62], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInjectiveEndo_left_inv", "code": "@[simp]\ntheorem ofInjectiveEndo_left_inv (f : V \u2192\u2097[K] V) (h_inj : Injective f) :\n    ((ofInjectiveEndo f h_inj).symm : V \u2192\u2097[K] V) * f = 1", "start": [991, 1], "end": [994, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isUnit_iff_ker_eq_bot", "code": "theorem isUnit_iff_ker_eq_bot [FiniteDimensional K V] (f : V \u2192\u2097[K] V) :\n    IsUnit f \u2194 (LinearMap.ker f) = \u22a5", "start": [1003, 1], "end": [1012, 11], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isUnit_iff_range_eq_top", "code": "theorem isUnit_iff_range_eq_top [FiniteDimensional K V] (f : V \u2192\u2097[K] V) :\n    IsUnit f \u2194 (LinearMap.range f) = \u22a4", "start": [1015, 1], "end": [1017, 61], "kind": "commanddeclaration"}, {"full_name": "finrank_zero_iff_forall_zero", "code": "theorem finrank_zero_iff_forall_zero [FiniteDimensional K V] : finrank K V = 0 \u2194 \u2200 x : V, x = 0", "start": [1028, 1], "end": [1029, 56], "kind": "commanddeclaration"}, {"full_name": "basisOfFinrankZero", "code": "noncomputable def basisOfFinrankZero [FiniteDimensional K V] {\u03b9 : Type*} [IsEmpty \u03b9]\n    (hV : finrank K V = 0) : Basis \u03b9 K V :=\n  haveI : Subsingleton V := finrank_zero_iff.1 hV\n  Basis.empty _", "start": [1032, 1], "end": [1036, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_iff_surjective_of_finrank_eq_finrank", "code": "theorem injective_iff_surjective_of_finrank_eq_finrank [FiniteDimensional K V]\n    [FiniteDimensional K V\u2082] (H : finrank K V = finrank K V\u2082) {f : V \u2192\u2097[K] V\u2082} :\n    Function.Injective f \u2194 Function.Surjective f", "start": [1046, 1], "end": [1054, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank", "code": "theorem ker_eq_bot_iff_range_eq_top_of_finrank_eq_finrank [FiniteDimensional K V]\n    [FiniteDimensional K V\u2082] (H : finrank K V = finrank K V\u2082) {f : V \u2192\u2097[K] V\u2082} :\n    LinearMap.ker f = \u22a5 \u2194 LinearMap.range f = \u22a4", "start": [1057, 1], "end": [1060, 82], "kind": "commanddeclaration"}, {"full_name": "LinearMap.linearEquivOfInjective", "code": "noncomputable def linearEquivOfInjective [FiniteDimensional K V] [FiniteDimensional K V\u2082]\n    (f : V \u2192\u2097[K] V\u2082) (hf : Injective f) (hdim : finrank K V = finrank K V\u2082) : V \u2243\u2097[K] V\u2082 :=\n  LinearEquiv.ofBijective f\n    \u27e8hf, (LinearMap.injective_iff_surjective_of_finrank_eq_finrank hdim).mp hf\u27e9", "start": [1063, 1], "end": [1069, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.linearEquivOfInjective_apply", "code": "@[simp]\ntheorem linearEquivOfInjective_apply [FiniteDimensional K V] [FiniteDimensional K V\u2082]\n    {f : V \u2192\u2097[K] V\u2082} (hf : Injective f) (hdim : finrank K V = finrank K V\u2082) (x : V) :\n    f.linearEquivOfInjective hf hdim x = f x", "start": [1072, 1], "end": [1076, 6], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.exists_mul_eq_one", "code": "lemma FiniteDimensional.exists_mul_eq_one (F : Type*) {K : Type*} [Field F] [Ring K] [IsDomain K]\n    [Algebra F K] [FiniteDimensional F K] {x : K} (H : x \u2260 0) : \u2203 y, x * y = 1 := by\n  have : Function.Surjective (LinearMap.mulLeft F x) :=\n    LinearMap.injective_iff_surjective.1 fun y z => ((mul_right_inj' H).1 : x * y = x * z \u2192 y = z)\n  exact this 1", "start": [1083, 1], "end": [1087, 15], "kind": "mathlibtacticlemma"}, {"full_name": "divisionRingOfFiniteDimensional", "code": "noncomputable def divisionRingOfFiniteDimensional (F K : Type*) [Field F] [h : Ring K] [IsDomain K]\n    [Algebra F K] [FiniteDimensional F K] : DivisionRing K :=\n  { \u2039IsDomain K\u203a with\n    toRing := h\n    inv := fun x =>\n      letI := Classical.decEq K\n      if H : x = 0 then 0 else Classical.choose <| FiniteDimensional.exists_mul_eq_one F H\n    mul_inv_cancel := fun x hx =>\n      show x * dite _ (h := _) _ = _ by\n        rw [dif_neg hx]\n        exact (Classical.choose_spec (FiniteDimensional.exists_mul_eq_one F hx) :)\n    inv_zero := dif_pos rfl }", "start": [1089, 1], "end": [1101, 30], "kind": "commanddeclaration"}, {"full_name": "fieldOfFiniteDimensional", "code": "noncomputable def fieldOfFiniteDimensional (F K : Type*) [Field F] [h : CommRing K] [IsDomain K]\n    [Algebra F K] [FiniteDimensional F K] : Field K :=\n  { divisionRingOfFiniteDimensional F K with\n    toCommRing := h }", "start": [1104, 1], "end": [1108, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_mono", "code": "theorem finrank_mono [FiniteDimensional K V] : Monotone fun s : Submodule K V => finrank K s", "start": [1119, 1], "end": [1120, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_lt_finrank_of_lt", "code": "theorem finrank_lt_finrank_of_lt {s t : Submodule K V} [FiniteDimensional K t] (hst : s < t) :\n    finrank K s < finrank K t", "start": [1123, 1], "end": [1126, 72], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_strictMono", "code": "theorem finrank_strictMono [FiniteDimensional K V] :\n    StrictMono fun s : Submodule K V => finrank K s", "start": [1129, 1], "end": [1130, 91], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_add_eq_of_isCompl", "code": "theorem finrank_add_eq_of_isCompl [FiniteDimensional K V] {U W : Submodule K V} (h : IsCompl U W) :\n    finrank K U + finrank K W = finrank K V", "start": [1133, 1], "end": [1137, 24], "kind": "commanddeclaration"}, {"full_name": "finrank_span_singleton", "code": "theorem finrank_span_singleton {v : V} (hv : v \u2260 0) : finrank K (K \u2219 v) = 1", "start": [1152, 1], "end": [1157, 14], "kind": "commanddeclaration"}, {"full_name": "exists_smul_eq_of_finrank_eq_one", "code": "lemma exists_smul_eq_of_finrank_eq_one\n    (h : finrank K V = 1) {x : V} (hx : x \u2260 0) (y : V) :\n    \u2203 (c : K), c \u2022 x = y := by\n  have : Submodule.span K {x} = \u22a4 := by\n    have : FiniteDimensional K V := finiteDimensional_of_finrank (zero_lt_one.trans_le h.symm.le)\n    apply eq_top_of_finrank_eq\n    rw [h]\n    exact finrank_span_singleton hx\n  have : y \u2208 Submodule.span K {x} := by rw [this]; exact mem_top\n  exact mem_span_singleton.1 this", "start": [1160, 1], "end": [1170, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Set.finrank_mono", "code": "theorem Set.finrank_mono [FiniteDimensional K V] {s t : Set V} (h : s \u2286 t) :\n    s.finrank K \u2264 t.finrank K", "start": [1172, 1], "end": [1174, 39], "kind": "commanddeclaration"}, {"full_name": "span_eq_top_of_linearIndependent_of_card_eq_finrank", "code": "theorem span_eq_top_of_linearIndependent_of_card_eq_finrank {\u03b9 : Type*} [h\u03b9 : Nonempty \u03b9]\n    [Fintype \u03b9] {b : \u03b9 \u2192 V} (lin_ind : LinearIndependent K b)\n    (card_eq : Fintype.card \u03b9 = finrank K V) : span K (Set.range b) = \u22a4", "start": [1181, 1], "end": [1195, 68], "kind": "commanddeclaration"}, {"full_name": "basisOfLinearIndependentOfCardEqFinrank", "code": "@[simps! repr_apply]\nnoncomputable def basisOfLinearIndependentOfCardEqFinrank {\u03b9 : Type*} [Nonempty \u03b9] [Fintype \u03b9]\n    {b : \u03b9 \u2192 V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card \u03b9 = finrank K V) :\n    Basis \u03b9 K V :=\n  Basis.mk lin_ind <| (span_eq_top_of_linearIndependent_of_card_eq_finrank lin_ind card_eq).ge", "start": [1198, 1], "end": [1203, 95], "kind": "commanddeclaration"}, {"full_name": "coe_basisOfLinearIndependentOfCardEqFinrank", "code": "@[simp]\ntheorem coe_basisOfLinearIndependentOfCardEqFinrank {\u03b9 : Type*} [Nonempty \u03b9] [Fintype \u03b9]\n    {b : \u03b9 \u2192 V} (lin_ind : LinearIndependent K b) (card_eq : Fintype.card \u03b9 = finrank K V) :\n    \u21d1(basisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = b", "start": [1206, 1], "end": [1210, 19], "kind": "commanddeclaration"}, {"full_name": "finsetBasisOfLinearIndependentOfCardEqFinrank", "code": "@[simps! repr_apply]\nnoncomputable def finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.card = finrank K V) : Basis s K V :=\n  @basisOfLinearIndependentOfCardEqFinrank _ _ _ _ _ _\n    \u27e8(\u27e8hs.choose, hs.choose_spec\u27e9 : s)\u27e9 _ _ lin_ind (_root_.trans (Fintype.card_coe _) card_eq)", "start": [1213, 1], "end": [1218, 96], "kind": "commanddeclaration"}, {"full_name": "coe_finsetBasisOfLinearIndependentOfCardEqFinrank", "code": "@[simp]\ntheorem coe_finsetBasisOfLinearIndependentOfCardEqFinrank {s : Finset V} (hs : s.Nonempty)\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.card = finrank K V) :\n    \u21d1(finsetBasisOfLinearIndependentOfCardEqFinrank hs lin_ind card_eq) = ((\u2191) : s \u2192 V)", "start": [1221, 1], "end": [1227, 25], "kind": "commanddeclaration"}, {"full_name": "setBasisOfLinearIndependentOfCardEqFinrank", "code": "@[simps! repr_apply]\nnoncomputable def setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.toFinset.card = finrank K V) :\n    Basis s K V :=\n  basisOfLinearIndependentOfCardEqFinrank lin_ind (_root_.trans s.toFinset_card.symm card_eq)", "start": [1230, 1], "end": [1235, 94], "kind": "commanddeclaration"}, {"full_name": "coe_setBasisOfLinearIndependentOfCardEqFinrank", "code": "@[simp]\ntheorem coe_setBasisOfLinearIndependentOfCardEqFinrank {s : Set V} [Nonempty s] [Fintype s]\n    (lin_ind : LinearIndependent K ((\u2191) : s \u2192 V)) (card_eq : s.toFinset.card = finrank K V) :\n    \u21d1(setBasisOfLinearIndependentOfCardEqFinrank lin_ind card_eq) = ((\u2191) : s \u2192 V)", "start": [1238, 1], "end": [1244, 25], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_one_iff_of_nonzero", "code": "theorem finrank_eq_one_iff_of_nonzero (v : V) (nz : v \u2260 0) :\n    finrank K V = 1 \u2194 span K ({v} : Set V) = \u22a4", "start": [1256, 1], "end": [1266, 18], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_one_iff_of_nonzero'", "code": "theorem finrank_eq_one_iff_of_nonzero' (v : V) (nz : v \u2260 0) :\n    finrank K V = 1 \u2194 \u2200 w : V, \u2203 c : K, c \u2022 v = w", "start": [1269, 1], "end": [1274, 34], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_one_iff", "code": "theorem finrank_eq_one_iff (\u03b9 : Type*) [Unique \u03b9] : finrank K V = 1 \u2194 Nonempty (Basis \u03b9 K V)", "start": [1277, 1], "end": [1285, 40], "kind": "commanddeclaration"}, {"full_name": "finrank_eq_one_iff'", "code": "theorem finrank_eq_one_iff' : finrank K V = 1 \u2194 \u2203 (v : V) (_n : v \u2260 0),\n    \u2200 w : V, \u2203 c : K, c \u2022 v = w", "start": [1288, 1], "end": [1293, 71], "kind": "commanddeclaration"}, {"full_name": "finrank_le_one_iff", "code": "theorem finrank_le_one_iff [FiniteDimensional K V] :\n    finrank K V \u2264 1 \u2194 \u2203 v : V, \u2200 w : V, \u2203 c : K, c \u2022 v = w", "start": [1297, 1], "end": [1315, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.finrank_le_one_iff_isPrincipal", "code": "theorem Submodule.finrank_le_one_iff_isPrincipal (W : Submodule K V) [FiniteDimensional K W] :\n    finrank K W \u2264 1 \u2194 W.IsPrincipal", "start": [1318, 1], "end": [1320, 95], "kind": "commanddeclaration"}, {"full_name": "Module.finrank_le_one_iff_top_isPrincipal", "code": "theorem Module.finrank_le_one_iff_top_isPrincipal [FiniteDimensional K V] :\n    finrank K V \u2264 1 \u2194 (\u22a4 : Submodule K V).IsPrincipal", "start": [1323, 1], "end": [1326, 18], "kind": "commanddeclaration"}, {"full_name": "surjective_of_nonzero_of_finrank_eq_one", "code": "theorem surjective_of_nonzero_of_finrank_eq_one {W A : Type*} [Semiring A] [Module A V]\n    [AddCommGroup W] [Module K W] [Module A W] [LinearMap.CompatibleSMul V W K A]\n    (h : finrank K W = 1) {f : V \u2192\u2097[A] W} (w : f \u2260 0) : Surjective f", "start": [1332, 1], "end": [1339, 25], "kind": "commanddeclaration"}, {"full_name": "is_simple_module_of_finrank_eq_one", "code": "theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]\n    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V)", "start": [1342, 1], "end": [1350, 80], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finiteDimensional_toSubmodule", "code": "theorem Subalgebra.finiteDimensional_toSubmodule {S : Subalgebra F E} :\n    FiniteDimensional F (Subalgebra.toSubmodule S) \u2194 FiniteDimensional F S", "start": [1374, 1], "end": [1377, 10], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.of_subalgebra_toSubmodule", "code": "alias \u27e8FiniteDimensional.of_subalgebra_toSubmodule, FiniteDimensional.subalgebra_toSubmodule\u27e9 :=\n  Subalgebra.finiteDimensional_toSubmodule", "start": [1380, 1], "end": [1381, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "FiniteDimensional.subalgebra_toSubmodule", "code": "alias \u27e8FiniteDimensional.of_subalgebra_toSubmodule, FiniteDimensional.subalgebra_toSubmodule\u27e9 :=\n  Subalgebra.finiteDimensional_toSubmodule", "start": [1380, 1], "end": [1381, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "FiniteDimensional.finiteDimensional_subalgebra", "code": "instance FiniteDimensional.finiteDimensional_subalgebra [FiniteDimensional F E]\n    (S : Subalgebra F E) : FiniteDimensional F S :=\n  FiniteDimensional.of_subalgebra_toSubmodule inferInstance", "start": [1385, 1], "end": [1387, 60], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finiteDimensional_bot", "code": "instance Subalgebra.finiteDimensional_bot : FiniteDimensional F (\u22a5 : Subalgebra F E) := by\n  nontriviality E\n  exact finiteDimensional_of_rank_eq_one Subalgebra.rank_bot", "start": [1390, 1], "end": [1392, 61], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.eq_bot_of_rank_le_one", "code": "theorem Subalgebra.eq_bot_of_rank_le_one {S : Subalgebra F E} (h : Module.rank F S \u2264 1) :\n    S = \u22a5", "start": [1395, 1], "end": [1407, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.eq_bot_of_finrank_one", "code": "theorem Subalgebra.eq_bot_of_finrank_one {S : Subalgebra F E} (h : finrank F S = 1) : S = \u22a5", "start": [1410, 1], "end": [1414, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rank_eq_one_iff", "code": "@[simp]\ntheorem Subalgebra.rank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} :\n    Module.rank F S = 1 \u2194 S = \u22a5", "start": [1417, 1], "end": [1420, 90], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.finrank_eq_one_iff", "code": "@[simp]\ntheorem Subalgebra.finrank_eq_one_iff [Nontrivial E] {S : Subalgebra F E} :\n    finrank F S = 1 \u2194 S = \u22a5", "start": [1423, 1], "end": [1426, 79], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.bot_eq_top_iff_rank_eq_one", "code": "theorem Subalgebra.bot_eq_top_iff_rank_eq_one [Nontrivial E] :\n    (\u22a5 : Subalgebra F E) = \u22a4 \u2194 Module.rank F E = 1", "start": [1429, 1], "end": [1432, 55], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.bot_eq_top_iff_finrank_eq_one", "code": "theorem Subalgebra.bot_eq_top_iff_finrank_eq_one [Nontrivial E] :\n    (\u22a5 : Subalgebra F E) = \u22a4 \u2194 finrank F E = 1", "start": [1435, 1], "end": [1438, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.bot_eq_top_of_rank_eq_one", "code": "alias \u27e8_, Subalgebra.bot_eq_top_of_rank_eq_one\u27e9 := Subalgebra.bot_eq_top_iff_rank_eq_one", "start": [1441, 1], "end": [1441, 89], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Subalgebra.bot_eq_top_of_finrank_eq_one", "code": "alias \u27e8_, Subalgebra.bot_eq_top_of_finrank_eq_one\u27e9 := Subalgebra.bot_eq_top_iff_finrank_eq_one", "start": [1444, 1], "end": [1444, 95], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Subalgebra.isSimpleOrder_of_finrank", "code": "theorem Subalgebra.isSimpleOrder_of_finrank (hr : finrank F E = 2) :\n    IsSimpleOrder (Subalgebra F E)", "start": [1449, 1], "end": [1467, 39], "kind": "commanddeclaration"}, {"full_name": "Module.End.exists_ker_pow_eq_ker_pow_succ", "code": "theorem exists_ker_pow_eq_ker_pow_succ [FiniteDimensional K V] (f : End K V) :\n    \u2203 k : \u2115, k \u2264 finrank K V \u2227 LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ)", "start": [1478, 1], "end": [1502, 92], "kind": "commanddeclaration"}, {"full_name": "Module.End.ker_pow_constant", "code": "theorem ker_pow_constant {f : End K V} {k : \u2115}\n    (h : LinearMap.ker (f ^ k) = LinearMap.ker (f ^ k.succ)) :\n    \u2200 m, LinearMap.ker (f ^ k) = LinearMap.ker (f ^ (k + m))", "start": [1505, 1], "end": [1515, 21], "kind": "commanddeclaration"}, {"full_name": "Module.End.ker_pow_eq_ker_pow_finrank_of_le", "code": "theorem ker_pow_eq_ker_pow_finrank_of_le [FiniteDimensional K V] {f : End K V} {m : \u2115}\n    (hm : finrank K V \u2264 m) : LinearMap.ker (f ^ m) = LinearMap.ker (f ^ finrank K V)", "start": [1518, 1], "end": [1528, 80], "kind": "commanddeclaration"}, {"full_name": "Module.End.ker_pow_le_ker_pow_finrank", "code": "theorem ker_pow_le_ker_pow_finrank [FiniteDimensional K V] (f : End K V) (m : \u2115) :\n    LinearMap.ker (f ^ m) \u2264 LinearMap.ker (f ^ finrank K V)", "start": [1531, 1], "end": [1536, 65], "kind": "commanddeclaration"}, {"full_name": "cardinal_mk_eq_cardinal_mk_field_pow_rank", "code": "theorem cardinal_mk_eq_cardinal_mk_field_pow_rank (K V : Type u) [DivisionRing K] [AddCommGroup V]\n    [Module K V] [FiniteDimensional K V] : #V = #K ^ Module.rank K V", "start": [1549, 1], "end": [1556, 77], "kind": "commanddeclaration"}, {"full_name": "cardinal_lt_aleph0_of_finiteDimensional", "code": "theorem cardinal_lt_aleph0_of_finiteDimensional (K V : Type u) [DivisionRing K] [AddCommGroup V]\n    [Module K V] [Finite K] [FiniteDimensional K V] : #V < \u2135\u2080", "start": [1559, 1], "end": [1563, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Basic.lean", "imports": ["Mathlib/GroupTheory/OrderOfElement.lean", "Mathlib/RingTheory/Nilpotent.lean", "Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Multiplicity.lean"], "premises": [{"full_name": "Commute.add_pow_prime_pow_eq", "code": "protected theorem add_pow_prime_pow_eq (hp : p.Prime) (h : Commute x y) (n : \u2115) :\n    (x + y) ^ p ^ n =\n      x ^ p ^ n + y ^ p ^ n +\n        p * \u2211 k in Ioo 0 (p ^ n), x ^ k * y ^ (p ^ n - k) * \u2191((p ^ n).choose k / p)", "start": [30, 1], "end": [42, 65], "kind": "commanddeclaration"}, {"full_name": "Commute.add_pow_prime_eq", "code": "protected theorem add_pow_prime_eq (hp : p.Prime) (h : Commute x y) :\n    (x + y) ^ p =\n      x ^ p + y ^ p + p * \u2211 k in Finset.Ioo 0 p, x ^ k * y ^ (p - k) * \u2191(p.choose k / p)", "start": [45, 1], "end": [48, 45], "kind": "commanddeclaration"}, {"full_name": "Commute.exists_add_pow_prime_pow_eq", "code": "protected theorem exists_add_pow_prime_pow_eq (hp : p.Prime) (h : Commute x y) (n : \u2115) :\n    \u2203 r, (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n + p * r", "start": [51, 1], "end": [53, 35], "kind": "commanddeclaration"}, {"full_name": "Commute.exists_add_pow_prime_eq", "code": "protected theorem exists_add_pow_prime_eq (hp : p.Prime) (h : Commute x y) :\n    \u2203 r, (x + y) ^ p = x ^ p + y ^ p + p * r", "start": [56, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "add_pow_prime_pow_eq", "code": "theorem add_pow_prime_pow_eq (hp : p.Prime) (x y : R) (n : \u2115) :\n    (x + y) ^ p ^ n =\n      x ^ p ^ n + y ^ p ^ n +\n        p * \u2211 k in Finset.Ioo 0 (p ^ n), x ^ k * y ^ (p ^ n - k) * \u2191((p ^ n).choose k / p)", "start": [67, 1], "end": [71, 46], "kind": "commanddeclaration"}, {"full_name": "add_pow_prime_eq", "code": "theorem add_pow_prime_eq (hp : p.Prime) (x y : R) :\n    (x + y) ^ p =\n      x ^ p + y ^ p + p * \u2211 k in Finset.Ioo 0 p, x ^ k * y ^ (p - k) * \u2191(p.choose k / p)", "start": [74, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "exists_add_pow_prime_pow_eq", "code": "theorem exists_add_pow_prime_pow_eq (hp : p.Prime) (x y : R) (n : \u2115) :\n    \u2203 r, (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n + p * r", "start": [80, 1], "end": [82, 53], "kind": "commanddeclaration"}, {"full_name": "exists_add_pow_prime_eq", "code": "theorem exists_add_pow_prime_eq (hp : p.Prime) (x y : R) :\n    \u2203 r, (x + y) ^ p = x ^ p + y ^ p + p * r", "start": [85, 1], "end": [87, 47], "kind": "commanddeclaration"}, {"full_name": "CharP", "code": "@[mk_iff charP_iff]\nclass CharP [AddMonoidWithOne R] (p : \u2115) : Prop where\n  cast_eq_zero_iff' : \u2200 x : \u2115, (x : R) = 0 \u2194 p \u2223 x", "start": [94, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "CharP.cast_eq_zero_iff", "code": "theorem CharP.cast_eq_zero_iff (R : Type u) [AddMonoidWithOne R] (p : \u2115) [CharP R p] (x : \u2115) :\n    (x : R) = 0 \u2194 p \u2223 x", "start": [112, 1], "end": [114, 44], "kind": "commanddeclaration"}, {"full_name": "CharP.cast_eq_zero", "code": "@[simp]\ntheorem CharP.cast_eq_zero [AddMonoidWithOne R] (p : \u2115) [CharP R p] : (p : R) = 0", "start": [116, 1], "end": [118, 48], "kind": "commanddeclaration"}, {"full_name": "CharP.cast_card_eq_zero", "code": "@[simp]\ntheorem CharP.cast_card_eq_zero [AddGroupWithOne R] [Fintype R] : (Fintype.card R : R) = 0", "start": [121, 1], "end": [123, 39], "kind": "commanddeclaration"}, {"full_name": "CharP.addOrderOf_one", "code": "theorem CharP.addOrderOf_one (R) [Semiring R] : CharP R (addOrderOf (1 : R))", "start": [126, 1], "end": [127, 77], "kind": "commanddeclaration"}, {"full_name": "CharP.int_cast_eq_zero_iff", "code": "theorem CharP.int_cast_eq_zero_iff [AddGroupWithOne R] (p : \u2115) [CharP R p] (a : \u2124) :\n    (a : R) = 0 \u2194 (p : \u2124) \u2223 a", "start": [130, 1], "end": [138, 69], "kind": "commanddeclaration"}, {"full_name": "CharP.intCast_eq_intCast", "code": "theorem CharP.intCast_eq_intCast [AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124} :\n    (a : R) = b \u2194 a \u2261 b [ZMOD p]", "start": [141, 1], "end": [143, 97], "kind": "commanddeclaration"}, {"full_name": "CharP.natCast_eq_natCast", "code": "theorem CharP.natCast_eq_natCast [AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2115} :\n    (a : R) = b \u2194 a \u2261 b [MOD p]", "start": [146, 1], "end": [149, 67], "kind": "commanddeclaration"}, {"full_name": "CharP.eq", "code": "theorem CharP.eq [AddMonoidWithOne R] {p q : \u2115} (_c1 : CharP R p) (_c2 : CharP R q) : p = q", "start": [152, 1], "end": [154, 64], "kind": "commanddeclaration"}, {"full_name": "CharP.ofCharZero", "code": "instance CharP.ofCharZero [AddMonoidWithOne R] [CharZero R] : CharP R 0 :=\n  \u27e8fun x => by rw [zero_dvd_iff, \u2190 Nat.cast_zero, Nat.cast_inj]\u27e9", "start": [157, 1], "end": [158, 65], "kind": "commanddeclaration"}, {"full_name": "CharP.exists", "code": "theorem CharP.exists [NonAssocSemiring R] : \u2203 p, CharP R p", "start": [161, 1], "end": [185, 25], "kind": "commanddeclaration"}, {"full_name": "CharP.exists_unique", "code": "theorem CharP.exists_unique [NonAssocSemiring R] : \u2203! p, CharP R p", "start": [188, 1], "end": [190, 39], "kind": "commanddeclaration"}, {"full_name": "CharP.congr", "code": "theorem CharP.congr {R : Type u} [AddMonoidWithOne R] {p : \u2115} (q : \u2115) [hq : CharP R q] (h : q = p) :\n    CharP R p", "start": [193, 1], "end": [195, 9], "kind": "commanddeclaration"}, {"full_name": "ringChar", "code": "noncomputable def ringChar [NonAssocSemiring R] : \u2115 :=\n  Classical.choose (CharP.exists_unique R)", "start": [198, 1], "end": [200, 43], "kind": "commanddeclaration"}, {"full_name": "ringChar.spec", "code": "theorem spec : \u2200 x : \u2115, (x : R) = 0 \u2194 ringChar R \u2223 x", "start": [207, 1], "end": [209, 46], "kind": "commanddeclaration"}, {"full_name": "ringChar.eq", "code": "theorem eq (p : \u2115) [C : CharP R p] : ringChar R = p", "start": [212, 1], "end": [213, 63], "kind": "commanddeclaration"}, {"full_name": "ringChar.charP", "code": "instance charP : CharP R (ringChar R) :=\n  \u27e8spec R\u27e9", "start": [216, 1], "end": [217, 11], "kind": "commanddeclaration"}, {"full_name": "ringChar.of_eq", "code": "theorem of_eq {p : \u2115} (h : ringChar R = p) : CharP R p", "start": [222, 1], "end": [223, 29], "kind": "commanddeclaration"}, {"full_name": "ringChar.eq_iff", "code": "theorem eq_iff {p : \u2115} : ringChar R = p \u2194 CharP R p", "start": [226, 1], "end": [227, 21], "kind": "commanddeclaration"}, {"full_name": "ringChar.dvd", "code": "theorem dvd {x : \u2115} (hx : (x : R) = 0) : ringChar R \u2223 x", "start": [230, 1], "end": [231, 18], "kind": "commanddeclaration"}, {"full_name": "ringChar.eq_zero", "code": "@[simp]\ntheorem eq_zero [CharZero R] : ringChar R = 0", "start": [234, 1], "end": [236, 9], "kind": "commanddeclaration"}, {"full_name": "ringChar.Nat.cast_ringChar", "code": "theorem Nat.cast_ringChar : (ringChar R : R) = 0", "start": [240, 1], "end": [240, 74], "kind": "commanddeclaration"}, {"full_name": "add_pow_char_of_commute", "code": "theorem add_pow_char_of_commute [Semiring R] {p : \u2115} [hp : Fact p.Prime] [CharP R p] (x y : R)\n    (h : Commute x y) : (x + y) ^ p = x ^ p + y ^ p", "start": [245, 1], "end": [248, 12], "kind": "commanddeclaration"}, {"full_name": "add_pow_char_pow_of_commute", "code": "theorem add_pow_char_pow_of_commute [Semiring R] {p n : \u2115} [hp : Fact p.Prime] [CharP R p]\n    (x y : R) (h : Commute x y) : (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n", "start": [251, 1], "end": [254, 12], "kind": "commanddeclaration"}, {"full_name": "sub_pow_char_of_commute", "code": "theorem sub_pow_char_of_commute [Ring R] {p : \u2115} [Fact p.Prime] [CharP R p] (x y : R)\n    (h : Commute x y) : (x - y) ^ p = x ^ p - y ^ p", "start": [257, 1], "end": [260, 7], "kind": "commanddeclaration"}, {"full_name": "sub_pow_char_pow_of_commute", "code": "theorem sub_pow_char_pow_of_commute [Ring R] {p : \u2115} [Fact p.Prime] [CharP R p] {n : \u2115} (x y : R)\n    (h : Commute x y) : (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n", "start": [263, 1], "end": [269, 61], "kind": "commanddeclaration"}, {"full_name": "add_pow_char", "code": "theorem add_pow_char [CommSemiring R] {p : \u2115} [Fact p.Prime] [CharP R p] (x y : R) :\n    (x + y) ^ p = x ^ p + y ^ p", "start": [272, 1], "end": [274, 50], "kind": "commanddeclaration"}, {"full_name": "add_pow_char_pow", "code": "theorem add_pow_char_pow [CommSemiring R] {p : \u2115} [Fact p.Prime] [CharP R p] {n : \u2115} (x y : R) :\n    (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n", "start": [277, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "sub_pow_char", "code": "theorem sub_pow_char [CommRing R] {p : \u2115} [Fact p.Prime] [CharP R p] (x y : R) :\n    (x - y) ^ p = x ^ p - y ^ p", "start": [282, 1], "end": [284, 50], "kind": "commanddeclaration"}, {"full_name": "sub_pow_char_pow", "code": "theorem sub_pow_char_pow [CommRing R] {p : \u2115} [Fact p.Prime] [CharP R p] {n : \u2115} (x y : R) :\n    (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n", "start": [287, 1], "end": [289, 54], "kind": "commanddeclaration"}, {"full_name": "CharP.neg_one_ne_one", "code": "theorem CharP.neg_one_ne_one [Ring R] (p : \u2115) [CharP R p] [Fact (2 < p)] : (-1 : R) \u2260 (1 : R)", "start": [292, 1], "end": [305, 11], "kind": "commanddeclaration"}, {"full_name": "CharP.neg_one_pow_char", "code": "theorem CharP.neg_one_pow_char [CommRing R] (p : \u2115) [CharP R p] [Fact p.Prime] :\n    (-1 : R) ^ p = -1", "start": [308, 1], "end": [312, 80], "kind": "commanddeclaration"}, {"full_name": "CharP.neg_one_pow_char_pow", "code": "theorem CharP.neg_one_pow_char_pow [CommRing R] (p n : \u2115) [CharP R p] [Fact p.Prime] :\n    (-1 : R) ^ p ^ n = -1", "start": [315, 1], "end": [319, 96], "kind": "commanddeclaration"}, {"full_name": "RingHom.charP_iff_charP", "code": "theorem RingHom.charP_iff_charP {K L : Type*} [DivisionRing K] [Semiring L] [Nontrivial L]\n    (f : K \u2192+* L) (p : \u2115) : CharP K p \u2194 CharP L p", "start": [322, 1], "end": [324, 73], "kind": "commanddeclaration"}, {"full_name": "frobenius", "code": "def frobenius : R \u2192+* R where\n  toFun x := x ^ p\n  map_one' := one_pow p\n  map_mul' x y := mul_pow x y p\n  map_zero' := zero_pow (Fact.out (p := Nat.Prime p)).pos\n  map_add' := add_pow_char R", "start": [334, 1], "end": [340, 29], "kind": "commanddeclaration"}, {"full_name": "frobenius_def", "code": "theorem frobenius_def : frobenius R p x = x ^ p", "start": [345, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "iterate_frobenius", "code": "theorem iterate_frobenius (n : \u2115) : (frobenius R p)^[n] x = x ^ p ^ n", "start": [349, 1], "end": [353, 96], "kind": "commanddeclaration"}, {"full_name": "frobenius_mul", "code": "theorem frobenius_mul : frobenius R p (x * y) = frobenius R p x * frobenius R p y", "start": [356, 1], "end": [357, 30], "kind": "commanddeclaration"}, {"full_name": "frobenius_one", "code": "theorem frobenius_one : frobenius R p 1 = 1", "start": [360, 1], "end": [361, 12], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_frobenius", "code": "theorem MonoidHom.map_frobenius : f (frobenius R p x) = frobenius S p (f x)", "start": [364, 1], "end": [365, 16], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_frobenius", "code": "theorem RingHom.map_frobenius : g (frobenius R p x) = frobenius S p (g x)", "start": [368, 1], "end": [369, 16], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_iterate_frobenius", "code": "theorem MonoidHom.map_iterate_frobenius (n : \u2115) :\n    f ((frobenius R p)^[n] x) = (frobenius S p)^[n] (f x)", "start": [372, 1], "end": [374, 58], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_iterate_frobenius", "code": "theorem RingHom.map_iterate_frobenius (n : \u2115) :\n    g ((frobenius R p)^[n] x) = (frobenius S p)^[n] (g x)", "start": [377, 1], "end": [379, 44], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_frobenius", "code": "theorem MonoidHom.iterate_map_frobenius (f : R \u2192* R) (p : \u2115) [Fact p.Prime] [CharP R p] (n : \u2115) :\n    f^[n] (frobenius R p x) = frobenius R p (f^[n] x)", "start": [382, 1], "end": [384, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_frobenius", "code": "theorem RingHom.iterate_map_frobenius (f : R \u2192+* R) (p : \u2115) [Fact p.Prime] [CharP R p] (n : \u2115) :\n    f^[n] (frobenius R p x) = frobenius R p (f^[n] x)", "start": [387, 1], "end": [389, 26], "kind": "commanddeclaration"}, {"full_name": "frobenius_zero", "code": "theorem frobenius_zero : frobenius R p 0 = 0", "start": [394, 1], "end": [395, 27], "kind": "commanddeclaration"}, {"full_name": "frobenius_add", "code": "theorem frobenius_add : frobenius R p (x + y) = frobenius R p x + frobenius R p y", "start": [398, 1], "end": [399, 30], "kind": "commanddeclaration"}, {"full_name": "frobenius_nat_cast", "code": "theorem frobenius_nat_cast (n : \u2115) : frobenius R p n = n", "start": [402, 1], "end": [403, 32], "kind": "commanddeclaration"}, {"full_name": "list_sum_pow_char", "code": "theorem list_sum_pow_char (l : List R) : l.sum ^ p = (l.map (\u00b7 ^ p : R \u2192 R)).sum", "start": [410, 1], "end": [411, 33], "kind": "commanddeclaration"}, {"full_name": "multiset_sum_pow_char", "code": "theorem multiset_sum_pow_char (s : Multiset R) : s.sum ^ p = (s.map (\u00b7 ^ p : R \u2192 R)).sum", "start": [414, 1], "end": [415, 37], "kind": "commanddeclaration"}, {"full_name": "sum_pow_char", "code": "theorem sum_pow_char {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R) :\n    (\u2211 i in s, f i) ^ p = \u2211 i in s, f i ^ p", "start": [418, 1], "end": [420, 30], "kind": "commanddeclaration"}, {"full_name": "frobenius_neg", "code": "theorem frobenius_neg : frobenius R p (-x) = -frobenius R p x", "start": [430, 1], "end": [431, 28], "kind": "commanddeclaration"}, {"full_name": "frobenius_sub", "code": "theorem frobenius_sub : frobenius R p (x - y) = frobenius R p x - frobenius R p y", "start": [434, 1], "end": [435, 30], "kind": "commanddeclaration"}, {"full_name": "frobenius_inj", "code": "theorem frobenius_inj [CommRing R] [IsReduced R] (p : \u2115) [Fact p.Prime] [CharP R p] :\n    Function.Injective (frobenius R p)", "start": [442, 1], "end": [446, 35], "kind": "commanddeclaration"}, {"full_name": "isSquare_of_charTwo'", "code": "theorem isSquare_of_charTwo' {R : Type*} [Finite R] [CommRing R] [IsReduced R] [CharP R 2]\n    (a : R) : IsSquare a", "start": [449, 1], "end": [456, 97], "kind": "commanddeclaration"}, {"full_name": "CharP.charP_to_charZero", "code": "theorem charP_to_charZero (R : Type*) [AddGroupWithOne R] [CharP R 0] : CharZero R", "start": [465, 1], "end": [466, 88], "kind": "commanddeclaration"}, {"full_name": "CharP.charP_zero_iff_charZero", "code": "theorem charP_zero_iff_charZero (R : Type*) [AddGroupWithOne R] : CharP R 0 \u2194 CharZero R", "start": [469, 1], "end": [470, 54], "kind": "commanddeclaration"}, {"full_name": "CharP.cast_eq_mod", "code": "theorem cast_eq_mod (p : \u2115) [CharP R p] (k : \u2115) : (k : R) = (k % p : \u2115)", "start": [472, 1], "end": [475, 43], "kind": "commanddeclaration"}, {"full_name": "CharP.char_ne_zero_of_finite", "code": "theorem char_ne_zero_of_finite (p : \u2115) [CharP R p] [Finite R] : p \u2260 0", "start": [478, 1], "end": [483, 80], "kind": "commanddeclaration"}, {"full_name": "CharP.ringChar_ne_zero_of_finite", "code": "theorem ringChar_ne_zero_of_finite [Finite R] : ringChar R \u2260 0", "start": [486, 1], "end": [487, 40], "kind": "commanddeclaration"}, {"full_name": "CharP.ringChar_zero_iff_CharZero", "code": "theorem ringChar_zero_iff_CharZero [NonAssocRing R] : ringChar R = 0 \u2194 CharZero R", "start": [490, 1], "end": [491, 48], "kind": "commanddeclaration"}, {"full_name": "CharP.pow_prime_pow_mul_eq_one_iff", "code": "@[simp]\ntheorem pow_prime_pow_mul_eq_one_iff (p k m : \u2115) [Fact p.Prime] [CharP R p] (x : R) :\n    x ^ (p ^ k * m) = 1 \u2194 x ^ m = 1", "start": [499, 1], "end": [507, 32], "kind": "commanddeclaration"}, {"full_name": "CharP.char_ne_one", "code": "theorem char_ne_one [Nontrivial R] (p : \u2115) [hc : CharP R p] : p \u2260 1", "start": [518, 1], "end": [520, 26], "kind": "commanddeclaration"}, {"full_name": "CharP.char_is_prime_of_two_le", "code": "theorem char_is_prime_of_two_le (p : \u2115) [hc : CharP R p] (hp : 2 \u2264 p) : Nat.Prime p", "start": [527, 1], "end": [543, 67], "kind": "commanddeclaration"}, {"full_name": "CharP.char_is_prime_or_zero", "code": "theorem char_is_prime_or_zero (p : \u2115) [hc : CharP R p] : Nat.Prime p \u2228 p = 0", "start": [550, 1], "end": [554, 90], "kind": "commanddeclaration"}, {"full_name": "CharP.char_is_prime_of_pos", "code": "theorem char_is_prime_of_pos (p : \u2115) [NeZero p] [CharP R p] : Fact p.Prime", "start": [557, 1], "end": [558, 67], "kind": "commanddeclaration"}, {"full_name": "CharP.char_is_prime", "code": "theorem char_is_prime (p : \u2115) [CharP R p] : p.Prime", "start": [572, 1], "end": [573, 76], "kind": "commanddeclaration"}, {"full_name": "CharP.CharOne.subsingleton", "code": "instance (priority := 100) CharOne.subsingleton [CharP R 1] : Subsingleton R :=\n  Subsingleton.intro <|\n    suffices \u2200 r : R, r = 0 from fun a b => show a = b by rw [this a, this b]\n    fun r =>\n    calc\n      r = 1 * r := by rw [one_mul]\n      _ = (1 : \u2115) * r := by rw [Nat.cast_one]\n      _ = 0 * r := by rw [CharP.cast_eq_zero]\n      _ = 0 := by rw [zero_mul]", "start": [583, 1], "end": [591, 32], "kind": "commanddeclaration"}, {"full_name": "CharP.false_of_nontrivial_of_char_one", "code": "theorem false_of_nontrivial_of_char_one [Nontrivial R] [CharP R 1] : False", "start": [593, 1], "end": [594, 40], "kind": "commanddeclaration"}, {"full_name": "CharP.ringChar_ne_one", "code": "theorem ringChar_ne_one [Nontrivial R] : ringChar R \u2260 1", "start": [597, 1], "end": [601, 40], "kind": "commanddeclaration"}, {"full_name": "CharP.nontrivial_of_char_ne_one", "code": "theorem nontrivial_of_char_ne_one {v : \u2115} (hv : v \u2260 1) [hr : CharP R v] : Nontrivial R", "start": [604, 1], "end": [606, 68], "kind": "commanddeclaration"}, {"full_name": "CharP.ringChar_of_prime_eq_zero", "code": "theorem ringChar_of_prime_eq_zero [Nontrivial R] {p : \u2115} (hprime : Nat.Prime p)\n    (hp0 : (p : R) = 0) : ringChar R = p", "start": [609, 1], "end": [611, 80], "kind": "commanddeclaration"}, {"full_name": "CharP.charP_iff_prime_eq_zero", "code": "theorem charP_iff_prime_eq_zero [Nontrivial R] {p : \u2115} (hp : p.Prime) :\n    CharP R p \u2194 (p : R) = 0", "start": [614, 1], "end": [617, 66], "kind": "commanddeclaration"}, {"full_name": "Ring.two_ne_zero", "code": "protected theorem Ring.two_ne_zero {R : Type*} [NonAssocSemiring R] [Nontrivial R]\n    (hR : ringChar R \u2260 2) : (2 : R) \u2260 0", "start": [625, 1], "end": [629, 53], "kind": "commanddeclaration"}, {"full_name": "Ring.neg_one_ne_one_of_char_ne_two", "code": "theorem Ring.neg_one_ne_one_of_char_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    (hR : ringChar R \u2260 2) : (-1 : R) \u2260 1", "start": [634, 1], "end": [637, 82], "kind": "commanddeclaration"}, {"full_name": "Ring.eq_self_iff_eq_zero_of_char_ne_two", "code": "theorem Ring.eq_self_iff_eq_zero_of_char_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    [NoZeroDivisors R] (hR : ringChar R \u2260 2) {a : R} : -a = a \u2194 a = 0", "start": [640, 1], "end": [646, 72], "kind": "commanddeclaration"}, {"full_name": "charP_of_ne_zero", "code": "theorem charP_of_ne_zero (hn : Fintype.card R = n) (hR : \u2200 i < n, (i : R) = 0 \u2192 i = 0) :\n    CharP R n", "start": [656, 1], "end": [670, 41], "kind": "commanddeclaration"}, {"full_name": "charP_of_prime_pow_injective", "code": "theorem charP_of_prime_pow_injective (R) [Ring R] [Fintype R] (p : \u2115) [hp : Fact p.Prime] (n : \u2115)\n    (hn : Fintype.card R = p ^ n) (hR : \u2200 i \u2264 n, (p : R) ^ i = 0 \u2192 i = n) : CharP R (p ^ n)", "start": [673, 1], "end": [681, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm.charP", "code": "instance Nat.lcm.charP [CharP S q] : CharP (R \u00d7 S) (Nat.lcm p q) where\n  cast_eq_zero_iff' := by\n    simp [Prod.ext_iff, CharP.cast_eq_zero_iff R p, CharP.cast_eq_zero_iff S q, Nat.lcm_dvd_iff]", "start": [690, 1], "end": [694, 97], "kind": "commanddeclaration"}, {"full_name": "Prod.charP", "code": "instance Prod.charP [CharP S p] : CharP (R \u00d7 S) p := by\n  convert Nat.lcm.charP R S p p; simp", "start": [696, 1], "end": [699, 38], "kind": "commanddeclaration"}, {"full_name": "ULift.charP", "code": "instance ULift.charP [AddMonoidWithOne R] (p : \u2115) [CharP R p] : CharP (ULift.{v} R) p where\n  cast_eq_zero_iff' n := Iff.trans (ULift.ext_iff _ _) <| CharP.cast_eq_zero_iff R p n", "start": [704, 1], "end": [705, 87], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.charP", "code": "instance MulOpposite.charP [AddMonoidWithOne R] (p : \u2115) [CharP R p] : CharP R\u1d50\u1d52\u1d56 p where\n  cast_eq_zero_iff' n := MulOpposite.unop_inj.symm.trans <| CharP.cast_eq_zero_iff R p n", "start": [708, 1], "end": [709, 89], "kind": "commanddeclaration"}, {"full_name": "Int.cast_injOn_of_ringChar_ne_two", "code": "theorem Int.cast_injOn_of_ringChar_ne_two {R : Type*} [NonAssocRing R] [Nontrivial R]\n    (hR : ringChar R \u2260 2) : ({0, 1, -1} : Set \u2124).InjOn ((\u2191) : \u2124 \u2192 R)", "start": [714, 1], "end": [722, 52], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_not_dvd", "code": "theorem of_not_dvd [CharP R p] (h : \u00acp \u2223 n) : NeZero (n : R)", "start": [732, 1], "end": [733, 45], "kind": "commanddeclaration"}, {"full_name": "NeZero.not_char_dvd", "code": "theorem not_char_dvd (p : \u2115) [CharP R p] (k : \u2115) [h : NeZero (k : R)] : \u00acp \u2223 k", "start": [736, 1], "end": [737, 63], "kind": "commanddeclaration"}, {"full_name": "CharZero.charZero_iff_forall_prime_ne_zero", "code": "theorem charZero_iff_forall_prime_ne_zero\n    [NonAssocRing R] [NoZeroDivisors R] [Nontrivial R] :\n    CharZero R \u2194 \u2200 p : \u2115, p.Prime \u2192 (p : R) \u2260 0", "start": [744, 1], "end": [753, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Cardinality.lean", "imports": ["Mathlib/SetTheory/Cardinal/Continuum.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Data/Set/Pointwise/Interval.lean", "Mathlib/Data/Rat/Denumerable.lean"], "premises": [{"full_name": "Cardinal.cantorFunctionAux", "code": "def cantorFunctionAux (c : \u211d) (f : \u2115 \u2192 Bool) (n : \u2115) : \u211d :=\n  cond (f n) (c ^ n) 0", "start": [56, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_true", "code": "@[simp]\ntheorem cantorFunctionAux_true (h : f n = true) : cantorFunctionAux c f n = c ^ n", "start": [63, 1], "end": [65, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_false", "code": "@[simp]\ntheorem cantorFunctionAux_false (h : f n = false) : cantorFunctionAux c f n = 0", "start": [68, 1], "end": [70, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_nonneg", "code": "theorem cantorFunctionAux_nonneg (h : 0 \u2264 c) : 0 \u2264 cantorFunctionAux c f n", "start": [73, 1], "end": [75, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_eq", "code": "theorem cantorFunctionAux_eq (h : f n = g n) : cantorFunctionAux c f n = cantorFunctionAux c g n", "start": [78, 1], "end": [79, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_zero", "code": "theorem cantorFunctionAux_zero (f : \u2115 \u2192 Bool) : cantorFunctionAux c f 0 = cond (f 0) 1 0", "start": [82, 1], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunctionAux_succ", "code": "theorem cantorFunctionAux_succ (f : \u2115 \u2192 Bool) :\n    (fun n => cantorFunctionAux c f (n + 1)) = fun n =>\n      c * cantorFunctionAux c (fun n => f (n + 1)) n", "start": [86, 1], "end": [90, 52], "kind": "commanddeclaration"}, {"full_name": "Cardinal.summable_cantor_function", "code": "theorem summable_cantor_function (f : \u2115 \u2192 Bool) (h1 : 0 \u2264 c) (h2 : c < 1) :\n    Summable (cantorFunctionAux c f)", "start": [93, 1], "end": [96, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunction", "code": "def cantorFunction (c : \u211d) (f : \u2115 \u2192 Bool) : \u211d :=\n  \u2211' n, cantorFunctionAux c f n", "start": [99, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunction_le", "code": "theorem cantorFunction_le (h1 : 0 \u2264 c) (h2 : c < 1) (h3 : \u2200 n, f n \u2192 g n) :\n    cantorFunction c f \u2264 cantorFunction c g", "start": [105, 1], "end": [109, 50], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunction_succ", "code": "theorem cantorFunction_succ (f : \u2115 \u2192 Bool) (h1 : 0 \u2264 c) (h2 : c < 1) :\n    cantorFunction c f = cond (f 0) 1 0 + c * cantorFunction c fun n => f (n + 1)", "start": [112, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.increasing_cantorFunction", "code": "theorem increasing_cantorFunction (h1 : 0 < c) (h2 : c < 1 / 2) {n : \u2115} {f g : \u2115 \u2192 Bool}\n    (hn : \u2200 k < n, f k = g k) (fn : f n = false) (gn : g n = true) :\n    cantorFunction c f < cantorFunction c g", "start": [119, 1], "end": [163, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantorFunction_injective", "code": "theorem cantorFunction_injective (h1 : 0 < c) (h2 : c < 1 / 2) :\n    Function.Injective (cantorFunction c)", "start": [166, 1], "end": [196, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_real", "code": "theorem mk_real : #\u211d = \ud835\udd20", "start": [199, 1], "end": [210, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ_real", "code": "theorem mk_univ_real : #(Set.univ : Set \u211d) = \ud835\udd20", "start": [213, 1], "end": [214, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.not_countable_real", "code": "theorem not_countable_real : \u00ac(Set.univ : Set \u211d).Countable", "start": [217, 1], "end": [220, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Ioi_real", "code": "theorem mk_Ioi_real (a : \u211d) : #(Ioi a) = \ud835\udd20", "start": [223, 1], "end": [242, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Ici_real", "code": "theorem mk_Ici_real (a : \u211d) : #(Ici a) = \ud835\udd20", "start": [245, 1], "end": [247, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Iio_real", "code": "theorem mk_Iio_real (a : \u211d) : #(Iio a) = \ud835\udd20", "start": [250, 1], "end": [255, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Iic_real", "code": "theorem mk_Iic_real (a : \u211d) : #(Iic a) = \ud835\udd20", "start": [258, 1], "end": [260, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Ioo_real", "code": "theorem mk_Ioo_real {a b : \u211d} (h : a < b) : #(Ioo a b) = \ud835\udd20", "start": [263, 1], "end": [272, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Ico_real", "code": "theorem mk_Ico_real {a b : \u211d} (h : a < b) : #(Ico a b) = \ud835\udd20", "start": [275, 1], "end": [277, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Icc_real", "code": "theorem mk_Icc_real {a b : \u211d} (h : a < b) : #(Icc a b) = \ud835\udd20", "start": [280, 1], "end": [282, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Ioc_real", "code": "theorem mk_Ioc_real {a b : \u211d} (h : a < b) : #(Ioc a b) = \ud835\udd20", "start": [285, 1], "end": [287, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Basic.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Bitwise.lean", "Mathlib/Data/Real/Sqrt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex", "code": "structure Complex : Type where\n  re : \u211d\n  im : \u211d", "start": [27, 1], "end": [30, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProd", "code": "@[simps apply]\ndef equivRealProd : \u2102 \u2243 \u211d \u00d7 \u211d where\n  toFun z := \u27e8z.re, z.im\u27e9\n  invFun p := \u27e8p.1, p.2\u27e9\n  left_inv := fun \u27e8_, _\u27e9 => rfl\n  right_inv := fun \u27e8_, _\u27e9 => rfl", "start": [43, 1], "end": [49, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.eta", "code": "@[simp]\ntheorem eta : \u2200 z : \u2102, Complex.mk z.re z.im = z", "start": [52, 1], "end": [54, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.ext", "code": "@[ext]\ntheorem ext : \u2200 {z w : \u2102}, z.re = w.re \u2192 z.im = w.im \u2192 z = w", "start": [57, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.ext_iff", "code": "theorem ext_iff {z w : \u2102} : z = w \u2194 z.re = w.re \u2227 z.im = w.im", "start": [62, 1], "end": [63, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.re_surjective", "code": "theorem re_surjective : Surjective re", "start": [66, 1], "end": [66, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.im_surjective", "code": "theorem im_surjective : Surjective im", "start": [69, 1], "end": [69, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.range_re", "code": "@[simp]\ntheorem range_re : range re = univ", "start": [72, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.range_im", "code": "@[simp]\ntheorem range_im : range im = univ", "start": [77, 1], "end": [79, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal'", "code": "@[coe]\ndef ofReal' (r : \u211d) : \u2102 :=\n  \u27e8r, 0\u27e9", "start": [83, 1], "end": [87, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_re", "code": "@[simp, norm_cast]\ntheorem ofReal_re (r : \u211d) : Complex.re (r : \u2102) = r", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_im", "code": "@[simp, norm_cast]\ntheorem ofReal_im (r : \u211d) : (r : \u2102).im = 0", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_def", "code": "theorem ofReal_def (r : \u211d) : (r : \u2102) = \u27e8r, 0\u27e9", "start": [101, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_inj", "code": "@[simp, norm_cast]\ntheorem ofReal_inj {z w : \u211d} : (z : \u2102) = w \u2194 z = w", "start": [105, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_injective", "code": "theorem ofReal_injective : Function.Injective ((\u2191) : \u211d \u2192 \u2102)", "start": [111, 1], "end": [111, 86], "kind": "commanddeclaration"}, {"full_name": "Complex.canLift", "code": "instance canLift : CanLift \u2102 \u211d (\u2191) fun z => z.im = 0 where\n  prf z hz := \u27e8z.re, ext rfl hz.symm\u27e9", "start": [115, 1], "end": [116, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.Set.reProdIm", "code": "def Set.reProdIm (s t : Set \u211d) : Set \u2102 :=\n  re \u207b\u00b9' s \u2229 im \u207b\u00b9' t", "start": [119, 1], "end": [122, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.mem_reProdIm", "code": "theorem mem_reProdIm {z : \u2102} {s t : Set \u211d} : z \u2208 s \u00d7\u2102 t \u2194 z.re \u2208 s \u2227 z.im \u2208 t", "start": [127, 1], "end": [128, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_re", "code": "@[simp]\ntheorem zero_re : (0 : \u2102).re = 0", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_im", "code": "@[simp]\ntheorem zero_im : (0 : \u2102).im = 0", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_zero", "code": "@[simp, norm_cast]\ntheorem ofReal_zero : ((0 : \u211d) : \u2102) = 0", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_eq_zero", "code": "@[simp]\ntheorem ofReal_eq_zero {z : \u211d} : (z : \u2102) = 0 \u2194 z = 0", "start": [152, 1], "end": [154, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_ne_zero", "code": "theorem ofReal_ne_zero {z : \u211d} : (z : \u2102) \u2260 0 \u2194 z \u2260 0", "start": [157, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.one_re", "code": "@[simp]\ntheorem one_re : (1 : \u2102).re = 1", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.one_im", "code": "@[simp]\ntheorem one_im : (1 : \u2102).im = 0", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_one", "code": "@[simp, norm_cast]\ntheorem ofReal_one : ((1 : \u211d) : \u2102) = 1", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_eq_one", "code": "@[simp]\ntheorem ofReal_eq_one {z : \u211d} : (z : \u2102) = 1 \u2194 z = 1", "start": [179, 1], "end": [181, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_ne_one", "code": "theorem ofReal_ne_one {z : \u211d} : (z : \u2102) \u2260 1 \u2194 z \u2260 1", "start": [184, 1], "end": [185, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.add_re", "code": "@[simp]\ntheorem add_re (z w : \u2102) : (z + w).re = z.re + w.re", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.add_im", "code": "@[simp]\ntheorem add_im (z w : \u2102) : (z + w).im = z.im + w.im", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.bit0_re", "code": "@[simp]\ntheorem bit0_re (z : \u2102) : (bit0 z).re = bit0 z.re", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.bit1_re", "code": "@[simp]\ntheorem bit1_re (z : \u2102) : (bit1 z).re = bit1 z.re", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.bit0_im", "code": "@[simp]\ntheorem bit0_im (z : \u2102) : (bit0 z).im = bit0 z.im", "start": [213, 1], "end": [215, 12], "kind": "commanddeclaration"}, {"full_name": "Complex.bit1_im", "code": "@[simp]\ntheorem bit1_im (z : \u2102) : (bit1 z).im = bit0 z.im", "start": [218, 1], "end": [220, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_add", "code": "@[simp, norm_cast]\ntheorem ofReal_add (r s : \u211d) : ((r + s : \u211d) : \u2102) = r + s", "start": [223, 1], "end": [225, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_bit0", "code": "@[simp, norm_cast]\ntheorem ofReal_bit0 (r : \u211d) : ((bit0 r : \u211d) : \u2102) = bit0 (r : \u2102)", "start": [228, 1], "end": [230, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_bit1", "code": "@[simp, norm_cast]\ntheorem ofReal_bit1 (r : \u211d) : ((bit1 r : \u211d) : \u2102) = bit1 (r : \u2102)", "start": [233, 1], "end": [235, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.neg_re", "code": "@[simp]\ntheorem neg_re (z : \u2102) : (-z).re = -z.re", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.neg_im", "code": "@[simp]\ntheorem neg_im (z : \u2102) : (-z).im = -z.im", "start": [248, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_neg", "code": "@[simp, norm_cast]\ntheorem ofReal_neg (r : \u211d) : ((-r : \u211d) : \u2102) = -r", "start": [253, 1], "end": [255, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_re", "code": "@[simp]\ntheorem mul_re (z w : \u2102) : (z * w).re = z.re * w.re - z.im * w.im", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_im", "code": "@[simp]\ntheorem mul_im (z w : \u2102) : (z * w).im = z.re * w.im + z.im * w.re", "start": [269, 1], "end": [271, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_mul", "code": "@[simp, norm_cast]\ntheorem ofReal_mul (r s : \u211d) : ((r * s : \u211d) : \u2102) = r * s", "start": [274, 1], "end": [276, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_mul_re", "code": "theorem ofReal_mul_re (r : \u211d) (z : \u2102) : (\u2191r * z).re = r * z.re", "start": [279, 1], "end": [279, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_mul_im", "code": "theorem ofReal_mul_im (r : \u211d) (z : \u2102) : (\u2191r * z).im = r * z.im", "start": [282, 1], "end": [282, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_mul'", "code": "theorem ofReal_mul' (r : \u211d) (z : \u2102) : \u2191r * z = \u27e8r * z.re, r * z.im\u27e9", "start": [285, 1], "end": [286, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.I", "code": "def I : \u2102 :=\n  \u27e80, 1\u27e9", "start": [292, 1], "end": [294, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.I_re", "code": "@[simp]\ntheorem I_re : I.re = 0", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.I_im", "code": "@[simp]\ntheorem I_im : I.im = 1", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.I_mul_I", "code": "@[simp]\ntheorem I_mul_I : I * I = -1", "start": [310, 1], "end": [312, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.I_mul", "code": "theorem I_mul (z : \u2102) : I * z = \u27e8-z.im, z.re\u27e9", "start": [316, 1], "end": [317, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.I_ne_zero", "code": "theorem I_ne_zero : (I : \u2102) \u2260 0", "start": [321, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.mk_eq_add_mul_I", "code": "theorem mk_eq_add_mul_I (a b : \u211d) : Complex.mk a b = a + b * I", "start": [326, 1], "end": [327, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.re_add_im", "code": "@[simp]\ntheorem re_add_im (z : \u2102) : (z.re : \u2102) + z.im * I = z", "start": [331, 1], "end": [333, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_I_re", "code": "theorem mul_I_re (z : \u2102) : (z * I).re = -z.im", "start": [336, 1], "end": [336, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_I_im", "code": "theorem mul_I_im (z : \u2102) : (z * I).im = z.re", "start": [340, 1], "end": [340, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.I_mul_re", "code": "theorem I_mul_re (z : \u2102) : (I * z).re = -z.im", "start": [344, 1], "end": [344, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.I_mul_im", "code": "theorem I_mul_im (z : \u2102) : (I * z).im = z.re", "start": [348, 1], "end": [348, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProd_symm_apply", "code": "@[simp]\ntheorem equivRealProd_symm_apply (p : \u211d \u00d7 \u211d) : equivRealProd.symm p = p.1 + p.2 * I", "start": [352, 1], "end": [354, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.instSMulRealComplex", "code": "instance instSMulRealComplex : SMul R \u2102 where\n  smul r x := \u27e8r \u2022 x.re - 0 * x.im, r \u2022 x.im + 0 * x.re\u27e9", "start": [373, 1], "end": [374, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.smul_re", "code": "theorem smul_re (r : R) (z : \u2102) : (r \u2022 z).re = r \u2022 z.re", "start": [376, 1], "end": [376, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.smul_im", "code": "theorem smul_im (r : R) (z : \u2102) : (r \u2022 z).im = r \u2022 z.im", "start": [379, 1], "end": [379, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.real_smul", "code": "@[simp]\ntheorem real_smul {x : \u211d} {z : \u2102} : x \u2022 z = x * z", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.addCommGroup", "code": "instance addCommGroup : AddCommGroup \u2102 :=\n  { zero := (0 : \u2102)\n    add := (\u00b7 + \u00b7)\n    neg := Neg.neg\n    sub := Sub.sub\n    nsmul := fun n z => n \u2022 z\n    zsmul := fun n z => n \u2022 z\n    zsmul_zero' := by intros; ext <;> simp [smul_re, smul_im]\n    nsmul_zero := by intros; ext <;> simp [smul_re, smul_im]\n    nsmul_succ := by\n      intros; ext <;> simp [AddMonoid.nsmul_succ, add_mul, add_comm,\n        smul_re, smul_im]\n    zsmul_succ' := by\n      intros; ext <;> simp [SubNegMonoid.zsmul_succ', add_mul, add_comm,\n        smul_re, smul_im]\n    zsmul_neg' := by\n      intros; ext <;> simp [zsmul_neg', add_mul, smul_re, smul_im]\n    add_assoc := by intros; ext <;> simp [add_assoc]\n    zero_add := by intros; ext <;> simp\n    add_zero := by intros; ext <;> simp\n    add_comm := by intros; ext <;> simp [add_comm]\n    add_left_neg := by intros; ext <;> simp }", "start": [390, 1], "end": [411, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.Complex.addGroupWithOne", "code": "instance Complex.addGroupWithOne : AddGroupWithOne \u2102 :=\n  { Complex.addCommGroup with\n    natCast := fun n => \u27e8n, 0\u27e9\n    natCast_zero := by\n      ext <;> simp [Nat.cast, AddMonoidWithOne.natCast_zero]\n    natCast_succ := fun _ => by ext <;> simp [Nat.cast, AddMonoidWithOne.natCast_succ]\n    intCast := fun n => \u27e8n, 0\u27e9\n    intCast_ofNat := fun _ => by ext <;> rfl\n    intCast_negSucc := fun n => by\n      ext\n      \u00b7 simp [AddGroupWithOne.intCast_negSucc]\n        show -(1: \u211d) + (-n) = -(\u2191(n + 1))\n        simp [Nat.cast_add, add_comm]\n      \u00b7 simp [AddGroupWithOne.intCast_negSucc]\n        show im \u27e8n, 0\u27e9 = 0\n        rfl\n    one := 1 }", "start": [414, 1], "end": [430, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.commRing", "code": "instance commRing : CommRing \u2102 :=\n  { Complex.addGroupWithOne with\n    mul := (\u00b7 * \u00b7)\n    npow := @npowRec _ \u27e8(1 : \u2102)\u27e9 \u27e8(\u00b7 * \u00b7)\u27e9\n    add_comm := by intros; ext <;> simp [add_comm]\n    left_distrib := by\n      intros; ext <;> simp [mul_re, mul_im] <;> ring\n    right_distrib := by\n      intros; ext <;> simp [mul_re, mul_im] <;> ring\n    zero_mul := by intros; ext <;> simp [zero_mul]\n    mul_zero := by intros; ext <;> simp [mul_zero]\n    mul_assoc := by intros; ext <;> simp [mul_assoc] <;> ring\n    one_mul := by intros; ext <;> simp [one_mul]\n    mul_one := by intros; ext <;> simp [mul_one]\n    mul_comm := by intros; ext <;> simp [mul_comm]; ring }", "start": [433, 1], "end": [447, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.reAddGroupHom", "code": "def reAddGroupHom : \u2102 \u2192+ \u211d where\n  toFun := re\n  map_zero' := zero_re\n  map_add' := add_re", "start": [464, 1], "end": [468, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_reAddGroupHom", "code": "@[simp]\ntheorem coe_reAddGroupHom : (reAddGroupHom : \u2102 \u2192 \u211d) = re", "start": [471, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.imAddGroupHom", "code": "def imAddGroupHom : \u2102 \u2192+ \u211d where\n  toFun := im\n  map_zero' := zero_im\n  map_add' := add_im", "start": [476, 1], "end": [480, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_imAddGroupHom", "code": "@[simp]\ntheorem coe_imAddGroupHom : (imAddGroupHom : \u2102 \u2192 \u211d) = im", "start": [483, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.I_pow_bit0", "code": "@[simp]\ntheorem I_pow_bit0 (n : \u2115) : I ^ bit0 n = (-1) ^ n", "start": [490, 1], "end": [491, 89], "kind": "commanddeclaration"}, {"full_name": "Complex.I_pow_bit1", "code": "@[simp]\ntheorem I_pow_bit1 (n : \u2115) : I ^ bit1 n = (-1) ^ n * I", "start": [495, 1], "end": [496, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_ofNat", "code": "@[simp, norm_cast]\ntheorem ofReal_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ((no_index (OfNat.ofNat n) : \u211d) : \u2102) = OfNat.ofNat n", "start": [501, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.re_ofNat", "code": "@[simp]\ntheorem re_ofNat (n : \u2115) [n.AtLeastTwo] : (no_index (OfNat.ofNat n) : \u2102).re = OfNat.ofNat n", "start": [506, 1], "end": [508, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.im_ofNat", "code": "@[simp]\ntheorem im_ofNat (n : \u2115) [n.AtLeastTwo] : (no_index (OfNat.ofNat n) : \u2102).im = 0", "start": [510, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_re", "code": "@[simp]\ntheorem conj_re (z : \u2102) : (conj z).re = z.re", "start": [527, 1], "end": [529, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_im", "code": "@[simp]\ntheorem conj_im (z : \u2102) : (conj z).im = -z.im", "start": [532, 1], "end": [534, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_ofReal", "code": "theorem conj_ofReal (r : \u211d) : conj (r : \u2102) = r", "start": [537, 1], "end": [538, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_I", "code": "@[simp]\ntheorem conj_I : conj I = -I", "start": [541, 1], "end": [543, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_bit0", "code": "theorem conj_bit0 (z : \u2102) : conj (bit0 z) = bit0 (conj z)", "start": [550, 1], "end": [551, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_bit1", "code": "theorem conj_bit1 (z : \u2102) : conj (bit1 z) = bit1 (conj z)", "start": [554, 1], "end": [555, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_neg_I", "code": "theorem conj_neg_I : conj (-I) = I", "start": [562, 1], "end": [563, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_eq_iff_real", "code": "theorem conj_eq_iff_real {z : \u2102} : conj z = z \u2194 \u2203 r : \u211d, z = r", "start": [567, 1], "end": [569, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_eq_iff_re", "code": "theorem conj_eq_iff_re {z : \u2102} : conj z = z \u2194 (z.re : \u2102) = z", "start": [572, 1], "end": [573, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_eq_iff_im", "code": "theorem conj_eq_iff_im {z : \u2102} : conj z = z \u2194 z.im = 0", "start": [576, 1], "end": [578, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.star_def", "code": "@[simp]\ntheorem star_def : (Star.star : \u2102 \u2192 \u2102) = conj", "start": [584, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq", "code": "def normSq : \u2102 \u2192*\u2080 \u211d where\n  toFun z := z.re * z.re + z.im * z.im\n  map_zero' := by simp\n  map_one' := by simp\n  map_mul' z w := by\n    dsimp\n    ring", "start": [592, 1], "end": [601, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_apply", "code": "theorem normSq_apply (z : \u2102) : normSq z = z.re * z.re + z.im * z.im", "start": [604, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_ofReal", "code": "@[simp]\ntheorem normSq_ofReal (r : \u211d) : normSq r = r * r", "start": [608, 1], "end": [610, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_mk", "code": "@[simp]\ntheorem normSq_mk (x y : \u211d) : normSq \u27e8x, y\u27e9 = x * x + y * y", "start": [613, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_add_mul_I", "code": "theorem normSq_add_mul_I (x y : \u211d) : normSq (x + y * I) = x ^ 2 + y ^ 2", "start": [618, 1], "end": [619, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_eq_conj_mul_self", "code": "theorem normSq_eq_conj_mul_self {z : \u2102} : (normSq z : \u2102) = conj z * z", "start": [623, 1], "end": [624, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_zero", "code": "theorem normSq_zero : normSq 0 = 0", "start": [630, 1], "end": [631, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_one", "code": "theorem normSq_one : normSq 1 = 1", "start": [637, 1], "end": [638, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_I", "code": "@[simp]\ntheorem normSq_I : normSq I = 1", "start": [641, 1], "end": [642, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_nonneg", "code": "theorem normSq_nonneg (z : \u2102) : 0 \u2264 normSq z", "start": [646, 1], "end": [647, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.range_normSq", "code": "@[simp]\ntheorem range_normSq : range normSq = Ici 0", "start": [650, 1], "end": [653, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_eq_zero", "code": "theorem normSq_eq_zero {z : \u2102} : normSq z = 0 \u2194 z = 0", "start": [656, 1], "end": [660, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_pos", "code": "@[simp]\ntheorem normSq_pos {z : \u2102} : 0 < normSq z \u2194 z \u2260 0", "start": [663, 1], "end": [665, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_neg", "code": "@[simp]\ntheorem normSq_neg (z : \u2102) : normSq (-z) = normSq z", "start": [668, 1], "end": [669, 72], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_conj", "code": "@[simp]\ntheorem normSq_conj (z : \u2102) : normSq (conj z) = normSq z", "start": [672, 1], "end": [673, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_mul", "code": "theorem normSq_mul (z w : \u2102) : normSq (z * w) = normSq z * normSq w", "start": [676, 1], "end": [677, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_add", "code": "theorem normSq_add (z w : \u2102) : normSq (z + w) = normSq z + normSq w + 2 * (z * conj w).re", "start": [680, 1], "end": [681, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.re_sq_le_normSq", "code": "theorem re_sq_le_normSq (z : \u2102) : z.re * z.re \u2264 normSq z", "start": [684, 1], "end": [685, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.im_sq_le_normSq", "code": "theorem im_sq_le_normSq (z : \u2102) : z.im * z.im \u2264 normSq z", "start": [688, 1], "end": [689, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_conj", "code": "theorem mul_conj (z : \u2102) : z * conj z = normSq z", "start": [692, 1], "end": [693, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.add_conj", "code": "theorem add_conj (z : \u2102) : z + conj z = (2 * z.re : \u211d)", "start": [696, 1], "end": [697, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal", "code": "def ofReal : \u211d \u2192+* \u2102 where\n  toFun x := (x : \u2102)\n  map_one' := ofReal_one\n  map_zero' := ofReal_zero\n  map_mul' := ofReal_mul\n  map_add' := ofReal_add", "start": [700, 1], "end": [706, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_eq_coe", "code": "@[simp]\ntheorem ofReal_eq_coe (r : \u211d) : ofReal r = r", "start": [709, 1], "end": [711, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.I_sq", "code": "@[simp]\ntheorem I_sq : I ^ 2 = -1", "start": [714, 1], "end": [715, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.sub_re", "code": "@[simp]\ntheorem sub_re (z w : \u2102) : (z - w).re = z.re - w.re", "start": [719, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.sub_im", "code": "@[simp]\ntheorem sub_im (z w : \u2102) : (z - w).im = z.im - w.im", "start": [724, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sub", "code": "@[simp, norm_cast]\ntheorem ofReal_sub (r s : \u211d) : ((r - s : \u211d) : \u2102) = r - s", "start": [729, 1], "end": [731, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_pow", "code": "@[simp, norm_cast]\ntheorem ofReal_pow (r : \u211d) (n : \u2115) : ((r ^ n : \u211d) : \u2102) = (r : \u2102) ^ n", "start": [734, 1], "end": [736, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.sub_conj", "code": "theorem sub_conj (z : \u2102) : z - conj z = (2 * z.im : \u211d) * I", "start": [739, 1], "end": [740, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_sub", "code": "theorem normSq_sub (z w : \u2102) : normSq (z - w) = normSq z + normSq w - 2 * (z * conj w).re", "start": [743, 1], "end": [746, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_def", "code": "theorem inv_def (z : \u2102) : z\u207b\u00b9 = conj z * ((normSq z)\u207b\u00b9 : \u211d)", "start": [755, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_re", "code": "@[simp]\ntheorem inv_re (z : \u2102) : z\u207b\u00b9.re = z.re / normSq z", "start": [759, 1], "end": [760, 94], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_im", "code": "@[simp]\ntheorem inv_im (z : \u2102) : z\u207b\u00b9.im = -z.im / normSq z", "start": [763, 1], "end": [764, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_inv", "code": "@[simp, norm_cast]\ntheorem ofReal_inv (r : \u211d) : ((r\u207b\u00b9 : \u211d) : \u2102) = (r : \u2102)\u207b\u00b9", "start": [767, 1], "end": [769, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_zero", "code": "protected theorem inv_zero : (0\u207b\u00b9 : \u2102) = 0", "start": [772, 1], "end": [773, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_inv_cancel", "code": "protected theorem mul_inv_cancel {z : \u2102} (h : z \u2260 0) : z * z\u207b\u00b9 = 1", "start": [776, 1], "end": [778, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_nat_cast", "code": "@[simp, norm_cast]\ntheorem ofReal_nat_cast (n : \u2115) : ((n : \u211d) : \u2102) = n", "start": [786, 1], "end": [788, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.nat_cast_re", "code": "@[simp, norm_cast]\ntheorem nat_cast_re (n : \u2115) : (n : \u2102).re = n", "start": [791, 1], "end": [792, 85], "kind": "commanddeclaration"}, {"full_name": "Complex.nat_cast_im", "code": "@[simp, norm_cast]\ntheorem nat_cast_im (n : \u2115) : (n : \u2102).im = 0", "start": [795, 1], "end": [796, 85], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_int_cast", "code": "@[simp, norm_cast]\ntheorem ofReal_int_cast (n : \u2124) : ((n : \u211d) : \u2102) = n", "start": [799, 1], "end": [801, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.int_cast_re", "code": "@[simp, norm_cast]\ntheorem int_cast_re (n : \u2124) : (n : \u2102).re = n", "start": [804, 1], "end": [805, 85], "kind": "commanddeclaration"}, {"full_name": "Complex.int_cast_im", "code": "@[simp, norm_cast]\ntheorem int_cast_im (n : \u2124) : (n : \u2102).im = 0", "start": [808, 1], "end": [809, 85], "kind": "commanddeclaration"}, {"full_name": "Complex.rat_cast_im", "code": "@[simp, norm_cast]\ntheorem rat_cast_im (q : \u211a) : (q : \u2102).im = 0", "start": [812, 1], "end": [816, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.rat_cast_re", "code": "@[simp, norm_cast]\ntheorem rat_cast_re (q : \u211a) : (q : \u2102).re = (q : \u211d)", "start": [819, 1], "end": [823, 84], "kind": "commanddeclaration"}, {"full_name": "Complex.instField", "code": "noncomputable instance instField : Field \u2102 :=\n{ qsmul := fun n z => n \u2022 z\n  qsmul_eq_mul' := fun n z => ext_iff.2 <| by simp [Rat.smul_def, smul_re, smul_im]\n  inv := Inv.inv\n  mul_inv_cancel := @Complex.mul_inv_cancel\n  inv_zero := Complex.inv_zero }", "start": [828, 1], "end": [833, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.I_zpow_bit0", "code": "@[simp]\ntheorem I_zpow_bit0 (n : \u2124) : I ^ bit0 n = (-1) ^ n", "start": [838, 1], "end": [839, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.I_zpow_bit1", "code": "@[simp]\ntheorem I_zpow_bit1 (n : \u2124) : I ^ bit1 n = (-1) ^ n * I", "start": [843, 1], "end": [844, 87], "kind": "commanddeclaration"}, {"full_name": "Complex.div_re", "code": "theorem div_re (z w : \u2102) : (z / w).re = z.re * w.re / normSq w + z.im * w.im / normSq w", "start": [850, 1], "end": [851, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.div_im", "code": "theorem div_im (z w : \u2102) : (z / w).im = z.im * w.re / normSq w - z.re * w.im / normSq w", "start": [854, 1], "end": [855, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_inv", "code": "theorem conj_inv (x : \u2102) : conj x\u207b\u00b9 = (conj x)\u207b\u00b9", "start": [858, 1], "end": [859, 14], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_div", "code": "@[simp, norm_cast]\ntheorem ofReal_div (r s : \u211d) : ((r / s : \u211d) : \u2102) = r / s", "start": [862, 1], "end": [864, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_zpow", "code": "@[simp, norm_cast]\ntheorem ofReal_zpow (r : \u211d) (n : \u2124) : ((r ^ n : \u211d) : \u2102) = (r : \u2102) ^ n", "start": [867, 1], "end": [869, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.div_I", "code": "@[simp]\ntheorem div_I (z : \u2102) : z / I = -(z * I)", "start": [872, 1], "end": [874, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_I", "code": "@[simp]\ntheorem inv_I : I\u207b\u00b9 = -I", "start": [878, 1], "end": [880, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_inv", "code": "theorem normSq_inv (z : \u2102) : normSq z\u207b\u00b9 = (normSq z)\u207b\u00b9", "start": [887, 1], "end": [888, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_div", "code": "theorem normSq_div (z w : \u2102) : normSq (z / w) = normSq z / normSq w", "start": [894, 1], "end": [895, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_rat_cast", "code": "@[simp, norm_cast]\ntheorem ofReal_rat_cast (n : \u211a) : ((n : \u211d) : \u2102) = (n : \u2102)", "start": [898, 1], "end": [900, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.charZero", "code": "instance charZero : CharZero \u2102 :=\n  charZero_of_inj_zero fun n h => by\n    rwa [\u2190 ofReal_nat_cast, ofReal_eq_zero, Nat.cast_eq_zero] at h", "start": [907, 1], "end": [909, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.re_eq_add_conj", "code": "theorem re_eq_add_conj (z : \u2102) : (z.re : \u2102) = (z + conj z) / 2", "start": [915, 1], "end": [919, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.im_eq_sub_conj", "code": "theorem im_eq_sub_conj (z : \u2102) : (z.im : \u2102) = (z - conj z) / (2 * I)", "start": [922, 1], "end": [926, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.mul_self_abs", "code": "private theorem mul_self_abs (z : \u2102) : ((abs z) * abs z) = normSq z", "start": [938, 1], "end": [939, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.abs_nonneg'", "code": "private theorem abs_nonneg' (z : \u2102) : 0 \u2264 abs z", "start": [941, 1], "end": [942, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.abs_conj", "code": "theorem abs_conj (z : \u2102) : (abs conj z) = abs z", "start": [944, 1], "end": [944, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.abs_re_le_abs", "code": "private theorem abs_re_le_abs (z : \u2102) : |z.re| \u2264 abs z", "start": [947, 1], "end": [949, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.re_le_abs", "code": "private theorem re_le_abs (z : \u2102) : z.re \u2264 abs z", "start": [951, 1], "end": [952, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.abs_mul", "code": "private theorem abs_mul (z w : \u2102) : (abs z * w) = (abs z) * abs w", "start": [954, 1], "end": [955, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.AbsTheory.abs_add", "code": "private theorem abs_add (z w : \u2102) : (abs z + w) \u2264 (abs z) + abs w", "start": [957, 1], "end": [963, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.abs", "code": "noncomputable def _root_.Complex.abs : AbsoluteValue \u2102 \u211d where\n  toFun x := abs x\n  map_mul' := abs_mul\n  nonneg' := abs_nonneg'\n  eq_zero' _ := (Real.sqrt_eq_zero <| normSq_nonneg _).trans normSq_eq_zero\n  add_le' := abs_add", "start": [965, 1], "end": [971, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_def", "code": "theorem abs_def : (Complex.abs : \u2102 \u2192 \u211d) = fun z => (normSq z).sqrt", "start": [976, 1], "end": [977, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_apply", "code": "theorem abs_apply {z : \u2102} : Complex.abs z = (normSq z).sqrt", "start": [980, 1], "end": [981, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_ofReal", "code": "@[simp, norm_cast]\ntheorem abs_ofReal (r : \u211d) : Complex.abs r = |r|", "start": [984, 1], "end": [986, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_of_nonneg", "code": "nonrec theorem abs_of_nonneg {r : \u211d} (h : 0 \u2264 r) : Complex.abs r = r", "start": [989, 1], "end": [990, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_of_nat", "code": "theorem abs_of_nat (n : \u2115) : Complex.abs n = n", "start": [993, 1], "end": [996, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.mul_self_abs", "code": "theorem mul_self_abs (z : \u2102) : Complex.abs z * Complex.abs z = normSq z", "start": [999, 1], "end": [1000, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.sq_abs", "code": "theorem sq_abs (z : \u2102) : Complex.abs z ^ 2 = normSq z", "start": [1003, 1], "end": [1004, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.sq_abs_sub_sq_re", "code": "@[simp]\ntheorem sq_abs_sub_sq_re (z : \u2102) : Complex.abs z ^ 2 - z.re ^ 2 = z.im ^ 2", "start": [1007, 1], "end": [1009, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.sq_abs_sub_sq_im", "code": "@[simp]\ntheorem sq_abs_sub_sq_im (z : \u2102) : Complex.abs z ^ 2 - z.im ^ 2 = z.re ^ 2", "start": [1012, 1], "end": [1014, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_I", "code": "@[simp]\ntheorem abs_I : Complex.abs I = 1", "start": [1017, 1], "end": [1018, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_two", "code": "@[simp]\ntheorem abs_two : Complex.abs 2 = 2", "start": [1022, 1], "end": [1026, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.range_abs", "code": "@[simp]\ntheorem range_abs : range Complex.abs = Ici 0", "start": [1029, 1], "end": [1033, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_conj", "code": "@[simp]\ntheorem abs_conj (z : \u2102) : Complex.abs (conj z) = Complex.abs z", "start": [1036, 1], "end": [1038, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_prod", "code": "theorem abs_prod {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \u2102) :\n    Complex.abs (s.prod f) = s.prod fun I => Complex.abs (f I)", "start": [1042, 1], "end": [1044, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_pow", "code": "theorem abs_pow (z : \u2102) (n : \u2115) : Complex.abs (z ^ n) = Complex.abs z ^ n", "start": [1050, 1], "end": [1051, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_zpow", "code": "theorem abs_zpow (z : \u2102) (n : \u2124) : Complex.abs (z ^ n) = Complex.abs z ^ n", "start": [1057, 1], "end": [1058, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_re_le_abs", "code": "theorem abs_re_le_abs (z : \u2102) : |z.re| \u2264 Complex.abs z", "start": [1061, 1], "end": [1064, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_im_le_abs", "code": "theorem abs_im_le_abs (z : \u2102) : |z.im| \u2264 Complex.abs z", "start": [1067, 1], "end": [1070, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.re_le_abs", "code": "theorem re_le_abs (z : \u2102) : z.re \u2264 Complex.abs z", "start": [1073, 1], "end": [1074, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.im_le_abs", "code": "theorem im_le_abs (z : \u2102) : z.im \u2264 Complex.abs z", "start": [1077, 1], "end": [1078, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_re_lt_abs", "code": "@[simp]\ntheorem abs_re_lt_abs {z : \u2102} : |z.re| < Complex.abs z \u2194 z.im \u2260 0", "start": [1081, 1], "end": [1084, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_im_lt_abs", "code": "@[simp]\ntheorem abs_im_lt_abs {z : \u2102} : |z.im| < Complex.abs z \u2194 z.re \u2260 0", "start": [1087, 1], "end": [1089, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_abs", "code": "@[simp]\ntheorem abs_abs (z : \u2102) : |Complex.abs z| = Complex.abs z", "start": [1092, 1], "end": [1094, 50], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_le_abs_re_add_abs_im", "code": "theorem abs_le_abs_re_add_abs_im (z : \u2102) : Complex.abs z \u2264 |z.re| + |z.im|", "start": [1098, 1], "end": [1099, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_le_sqrt_two_mul_max", "code": "theorem abs_le_sqrt_two_mul_max (z : \u2102) : Complex.abs z \u2264 Real.sqrt 2 * max |z.re| |z.im|", "start": [1107, 1], "end": [1122, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_re_div_abs_le_one", "code": "theorem abs_re_div_abs_le_one (z : \u2102) : |z.re / Complex.abs z| \u2264 1", "start": [1125, 1], "end": [1128, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_im_div_abs_le_one", "code": "theorem abs_im_div_abs_le_one (z : \u2102) : |z.im / Complex.abs z| \u2264 1", "start": [1131, 1], "end": [1134, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cast_nat", "code": "@[simp]\ntheorem abs_cast_nat (n : \u2115) : Complex.abs (n : \u2102) = n", "start": [1138, 1], "end": [1140, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.int_cast_abs", "code": "@[simp, norm_cast]\ntheorem int_cast_abs (n : \u2124) : |\u2191n| = Complex.abs n", "start": [1143, 1], "end": [1145, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.normSq_eq_abs", "code": "theorem normSq_eq_abs (x : \u2102) : normSq x = (Complex.abs x) ^ 2", "start": [1148, 1], "end": [1149, 64], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_re", "code": "theorem isCauSeq_re (f : CauSeq \u2102 Complex.abs) : IsCauSeq abs' fun n => (f n).re", "start": [1156, 1], "end": [1158, 71], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_im", "code": "theorem isCauSeq_im (f : CauSeq \u2102 Complex.abs) : IsCauSeq abs' fun n => (f n).im", "start": [1161, 1], "end": [1163, 71], "kind": "commanddeclaration"}, {"full_name": "Complex.cauSeqRe", "code": "noncomputable def cauSeqRe (f : CauSeq \u2102 Complex.abs) : CauSeq \u211d abs' :=\n  \u27e8_, isCauSeq_re f\u27e9", "start": [1166, 1], "end": [1168, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.cauSeqIm", "code": "noncomputable def cauSeqIm (f : CauSeq \u2102 Complex.abs) : CauSeq \u211d abs' :=\n  \u27e8_, isCauSeq_im f\u27e9", "start": [1171, 1], "end": [1173, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_abs", "code": "theorem isCauSeq_abs {f : \u2115 \u2192 \u2102} (hf : IsCauSeq Complex.abs f) :\n    IsCauSeq abs' (Complex.abs \u2218 f)", "start": [1176, 1], "end": [1180, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.limAux", "code": "noncomputable def limAux (f : CauSeq \u2102 Complex.abs) : \u2102 :=\n  \u27e8CauSeq.lim (cauSeqRe f), CauSeq.lim (cauSeqIm f)\u27e9", "start": [1183, 1], "end": [1185, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.equiv_limAux", "code": "theorem equiv_limAux (f : CauSeq \u2102 Complex.abs) :\n    f \u2248 CauSeq.const Complex.abs (limAux f)", "start": [1188, 1], "end": [1198, 29], "kind": "commanddeclaration"}, {"full_name": "Complex.instIsComplete", "code": "instance instIsComplete : CauSeq.IsComplete \u2102 Complex.abs :=\n  \u27e8fun f => \u27e8limAux f, equiv_limAux f\u27e9\u27e9", "start": [1201, 1], "end": [1202, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.lim_eq_lim_im_add_lim_re", "code": "theorem lim_eq_lim_im_add_lim_re (f : CauSeq \u2102 Complex.abs) :\n    lim f = \u2191(lim (cauSeqRe f)) + \u2191(lim (cauSeqIm f)) * I", "start": [1206, 1], "end": [1213, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.lim_re", "code": "theorem lim_re (f : CauSeq \u2102 Complex.abs) : lim (cauSeqRe f) = (lim f).re", "start": [1216, 1], "end": [1217, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.lim_im", "code": "theorem lim_im (f : CauSeq \u2102 Complex.abs) : lim (cauSeqIm f) = (lim f).im", "start": [1220, 1], "end": [1221, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_conj", "code": "theorem isCauSeq_conj (f : CauSeq \u2102 Complex.abs) :\n    IsCauSeq Complex.abs fun n => conj (f n)", "start": [1224, 1], "end": [1228, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.cauSeqConj", "code": "noncomputable def cauSeqConj (f : CauSeq \u2102 Complex.abs) : CauSeq \u2102 Complex.abs :=\n  \u27e8_, isCauSeq_conj f\u27e9", "start": [1231, 1], "end": [1233, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.lim_conj", "code": "theorem lim_conj (f : CauSeq \u2102 Complex.abs) : lim (cauSeqConj f) = conj (lim f)", "start": [1236, 1], "end": [1238, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.cauSeqAbs", "code": "noncomputable def cauSeqAbs (f : CauSeq \u2102 Complex.abs) : CauSeq \u211d abs' :=\n  \u27e8_, isCauSeq_abs f.2\u27e9", "start": [1241, 1], "end": [1243, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.lim_abs", "code": "theorem lim_abs (f : CauSeq \u2102 Complex.abs) : lim (cauSeqAbs f) = Complex.abs (lim f)", "start": [1246, 1], "end": [1249, 87], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_prod", "code": "@[simp, norm_cast]\ntheorem ofReal_prod (f : \u03b1 \u2192 \u211d) : ((\u220f i in s, f i : \u211d) : \u2102) = \u220f i in s, (f i : \u2102)", "start": [1254, 1], "end": [1256, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sum", "code": "@[simp, norm_cast]\ntheorem ofReal_sum (f : \u03b1 \u2192 \u211d) : ((\u2211 i in s, f i : \u211d) : \u2102) = \u2211 i in s, (f i : \u2102)", "start": [1259, 1], "end": [1261, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.re_sum", "code": "@[simp]\ntheorem re_sum (f : \u03b1 \u2192 \u2102) : (\u2211 i in s, f i).re = \u2211 i in s, (f i).re", "start": [1264, 1], "end": [1266, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.im_sum", "code": "@[simp]\ntheorem im_sum (f : \u03b1 \u2192 \u2102) : (\u2211 i in s, f i).im = \u2211 i in s, (f i).im", "start": [1269, 1], "end": [1271, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/MulAction.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "Mathlib/Topology/MetricSpace/Algebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "norm_smul_le", "code": "theorem norm_smul_le (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016 \u2264 \u2016r\u2016 * \u2016x\u2016", "start": [30, 1], "end": [31, 47], "kind": "commanddeclaration"}, {"full_name": "nnnorm_smul_le", "code": "theorem nnnorm_smul_le (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016\u208a \u2264 \u2016r\u2016\u208a * \u2016x\u2016\u208a", "start": [34, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "dist_smul_le", "code": "theorem dist_smul_le (s : \u03b1) (x y : \u03b2) : dist (s \u2022 x) (s \u2022 y) \u2264 \u2016s\u2016 * dist x y", "start": [38, 1], "end": [39, 65], "kind": "commanddeclaration"}, {"full_name": "nndist_smul_le", "code": "theorem nndist_smul_le (s : \u03b1) (x y : \u03b2) : nndist (s \u2022 x) (s \u2022 y) \u2264 \u2016s\u2016\u208a * nndist x y", "start": [42, 1], "end": [43, 21], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_smul", "code": "theorem lipschitzWith_smul (s : \u03b1) : LipschitzWith \u2016s\u2016\u208a ((\u00b7 \u2022 \u00b7) s : \u03b2 \u2192 \u03b2)", "start": [46, 1], "end": [47, 52], "kind": "commanddeclaration"}, {"full_name": "edist_smul_le", "code": "theorem edist_smul_le (s : \u03b1) (x y : \u03b2) : edist (s \u2022 x) (s \u2022 y) \u2264 \u2016s\u2016\u208a \u2022 edist x y", "start": [50, 1], "end": [51, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSeminormedRing.to_boundedSMul", "code": "instance NonUnitalSeminormedRing.to_boundedSMul [NonUnitalSeminormedRing \u03b1] : BoundedSMul \u03b1 \u03b1 where\n  dist_smul_pair' x y\u2081 y\u2082 := by simpa [mul_sub, dist_eq_norm] using norm_mul_le x (y\u2081 - y\u2082)\n  dist_pair_smul' x\u2081 x\u2082 y := by simpa [sub_mul, dist_eq_norm] using norm_mul_le (x\u2081 - x\u2082) y", "start": [56, 1], "end": [59, 92], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSeminormedRing.to_has_bounded_op_smul", "code": "instance NonUnitalSeminormedRing.to_has_bounded_op_smul [NonUnitalSeminormedRing \u03b1] :\n    BoundedSMul \u03b1\u1d50\u1d52\u1d56 \u03b1 where\n  dist_smul_pair' x y\u2081 y\u2082 := by\n    simpa [sub_mul, dist_eq_norm, mul_comm] using norm_mul_le (y\u2081 - y\u2082) x.unop\n  dist_pair_smul' x\u2081 x\u2082 y := by\n    simpa [mul_sub, dist_eq_norm, mul_comm] using norm_mul_le y (x\u2081 - x\u2082).unop", "start": [62, 1], "end": [68, 79], "kind": "commanddeclaration"}, {"full_name": "BoundedSMul.of_norm_smul_le", "code": "theorem BoundedSMul.of_norm_smul_le (h : \u2200 (r : \u03b1) (x : \u03b2), \u2016r \u2022 x\u2016 \u2264 \u2016r\u2016 * \u2016x\u2016) :\n    BoundedSMul \u03b1 \u03b2", "start": [75, 1], "end": [78, 94], "kind": "commanddeclaration"}, {"full_name": "norm_smul", "code": "theorem norm_smul (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016 = \u2016r\u2016 * \u2016x\u2016", "start": [89, 1], "end": [96, 98], "kind": "commanddeclaration"}, {"full_name": "nnnorm_smul", "code": "theorem nnnorm_smul (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016\u208a = \u2016r\u2016\u208a * \u2016x\u2016\u208a", "start": [99, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "dist_smul\u2080", "code": "theorem dist_smul\u2080 (s : \u03b1) (x y : \u03b2) : dist (s \u2022 x) (s \u2022 y) = \u2016s\u2016 * dist x y", "start": [111, 1], "end": [112, 63], "kind": "commanddeclaration"}, {"full_name": "nndist_smul\u2080", "code": "theorem nndist_smul\u2080 (s : \u03b1) (x y : \u03b2) : nndist (s \u2022 x) (s \u2022 y) = \u2016s\u2016\u208a * nndist x y", "start": [115, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "edist_smul\u2080", "code": "theorem edist_smul\u2080 (s : \u03b1) (x y : \u03b2) : edist (s \u2022 x) (s \u2022 y) = \u2016s\u2016\u208a \u2022 edist x y", "start": [119, 1], "end": [120, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Subalgebra.lean", "imports": ["Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Algebra/Star/Center.lean", "Mathlib/Algebra/Star/Pointwise.lean", "Mathlib/Algebra/Star/Module.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StarSubalgebra", "code": "structure StarSubalgebra (R : Type u) (A : Type v) [CommSemiring R] [StarRing R] [Semiring A]\n  [StarRing A] [Algebra R A] [StarModule R A] extends Subalgebra R A : Type v where\n  \n  star_mem' {a} : a \u2208 carrier \u2192 star a \u2208 carrier", "start": [26, 1], "end": [30, 49], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.setLike", "code": "instance setLike : SetLike (StarSubalgebra R A) A where\n  coe S := S.carrier\n  coe_injective' p q h := by obtain \u27e8\u27e8\u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9, _\u27e9, _\u27e9 := p; cases q; congr", "start": [47, 1], "end": [49, 84], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.starMemClass", "code": "instance starMemClass : StarMemClass (StarSubalgebra R A) A where\n  star_mem {s} := s.star_mem'", "start": [51, 1], "end": [52, 30], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subsemiringClass", "code": "instance subsemiringClass : SubsemiringClass (StarSubalgebra R A) A where\n  add_mem {s} := s.add_mem'\n  mul_mem {s} := s.mul_mem'\n  one_mem {s} := s.one_mem'\n  zero_mem {s} := s.zero_mem'", "start": [55, 1], "end": [59, 30], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.smulMemClass", "code": "instance smulMemClass : SMulMemClass (StarSubalgebra R A) R A where\n  smul_mem {s} r a (ha : a \u2208 s.toSubalgebra) :=\n    (SMulMemClass.smul_mem r ha : r \u2022 a \u2208 s.toSubalgebra)", "start": [61, 1], "end": [63, 58], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subringClass", "code": "instance subringClass {R A} [CommRing R] [StarRing R] [Ring A] [StarRing A] [Algebra R A]\n    [StarModule R A] : SubringClass (StarSubalgebra R A) A where\n  neg_mem {s a} ha := show -a \u2208 s.toSubalgebra from neg_mem ha", "start": [65, 1], "end": [67, 63], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.starRing", "code": "instance starRing (s : StarSubalgebra R A) : StarRing s :=\n  { StarMemClass.instStar s with\n    star_involutive := fun r => Subtype.ext (star_star (r : A))\n    star_mul := fun r\u2081 r\u2082 => Subtype.ext (star_mul (r\u2081 : A) (r\u2082 : A))\n    star_add := fun r\u2081 r\u2082 => Subtype.ext (star_add (r\u2081 : A) (r\u2082 : A)) }", "start": [70, 1], "end": [74, 72], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.algebra", "code": "instance algebra (s : StarSubalgebra R A) : Algebra R s :=\n  s.toSubalgebra.algebra'", "start": [76, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.starModule", "code": "instance starModule (s : StarSubalgebra R A) : StarModule R s where\n  star_smul r a := Subtype.ext (star_smul r (a : A))", "start": [79, 1], "end": [80, 53], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_carrier", "code": "@[simp, nolint simpNF] theorem mem_carrier {s : StarSubalgebra R A} {x : A} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [82, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.ext", "code": "@[ext]\ntheorem ext {S T : StarSubalgebra R A} (h : \u2200 x : A, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [87, 1], "end": [89, 16], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_mk", "code": "@[simp]\nlemma coe_mk (S : Subalgebra R A) (h) : ((\u27e8S, h\u27e9 : StarSubalgebra R A) : Set A) = S := rfl", "start": [92, 1], "end": [93, 91], "kind": "mathlibtacticlemma"}, {"full_name": "StarSubalgebra.mem_toSubalgebra", "code": "@[simp]\ntheorem mem_toSubalgebra {S : StarSubalgebra R A} {x} : x \u2208 S.toSubalgebra \u2194 x \u2208 S", "start": [95, 1], "end": [97, 10], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_toSubalgebra", "code": "@[simp]\ntheorem coe_toSubalgebra (S : StarSubalgebra R A) : (S.toSubalgebra : Set A) = S", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toSubalgebra_injective", "code": "theorem toSubalgebra_injective :\n    Function.Injective (toSubalgebra : StarSubalgebra R A \u2192 Subalgebra R A)", "start": [105, 1], "end": [107, 65], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toSubalgebra_inj", "code": "theorem toSubalgebra_inj {S U : StarSubalgebra R A} : S.toSubalgebra = U.toSubalgebra \u2194 S = U", "start": [110, 1], "end": [111, 32], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toSubalgebra_le_iff", "code": "theorem toSubalgebra_le_iff {S\u2081 S\u2082 : StarSubalgebra R A} :\n    S\u2081.toSubalgebra \u2264 S\u2082.toSubalgebra \u2194 S\u2081 \u2264 S\u2082", "start": [114, 1], "end": [116, 10], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.copy", "code": "protected def copy (S : StarSubalgebra R A) (s : Set A) (hs : s = \u2191S) : StarSubalgebra R A where\n  toSubalgebra := Subalgebra.copy S.toSubalgebra s hs\n  star_mem' := @fun a ha => hs \u25b8 (S.star_mem' (by simpa [hs] using ha) : star a \u2208 (S : Set A))", "start": [119, 1], "end": [123, 95], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : StarSubalgebra R A) (s : Set A) (hs : s = \u2191S) : (S.copy s hs : Set A) = s", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.copy_eq", "code": "theorem copy_eq (S : StarSubalgebra R A) (s : Set A) (hs : s = \u2191S) : S.copy s hs = S", "start": [132, 1], "end": [133, 27], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.algebraMap_mem", "code": "theorem algebraMap_mem (r : R) : algebraMap R A r \u2208 S", "start": [138, 1], "end": [139, 22], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.rangeS_le", "code": "theorem rangeS_le : (algebraMap R A).rangeS \u2264 S.toSubalgebra.toSubsemiring", "start": [142, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.range_subset", "code": "theorem range_subset : Set.range (algebraMap R A) \u2286 S", "start": [146, 1], "end": [146, 99], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.range_le", "code": "theorem range_le : Set.range (algebraMap R A) \u2264 S", "start": [149, 1], "end": [150, 17], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.smul_mem", "code": "protected theorem smul_mem {x : A} (hx : x \u2208 S) (r : R) : r \u2022 x \u2208 S", "start": [153, 1], "end": [154, 64], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subtype", "code": "def subtype : S \u2192\u22c6\u2090[R] A := by refine' { toFun := ((\u2191) : S \u2192 A), .. } <;> intros <;> rfl", "start": [157, 1], "end": [158, 89], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_subtype", "code": "@[simp]\ntheorem coe_subtype : (S.subtype : S \u2192 A) = Subtype.val", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subtype_apply", "code": "theorem subtype_apply (x : S) : S.subtype x = (x : A)", "start": [166, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toSubalgebra_subtype", "code": "@[simp]\ntheorem toSubalgebra_subtype : S.toSubalgebra.val = S.subtype.toAlgHom", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.inclusion", "code": "@[simps]\ndef inclusion {S\u2081 S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082) : S\u2081 \u2192\u22c6\u2090[R] S\u2082 where\n  toFun := Subtype.map id h\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  commutes' _ := rfl\n  map_star' _ := rfl", "start": [175, 1], "end": [184, 21], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.inclusion_injective", "code": "theorem inclusion_injective {S\u2081 S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082) :\n    Function.Injective <| inclusion h", "start": [187, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subtype_comp_inclusion", "code": "@[simp]\ntheorem subtype_comp_inclusion {S\u2081 S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082) :\n    S\u2082.subtype.comp (inclusion h) = S\u2081.subtype", "start": [192, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map", "code": "def map (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R A) : StarSubalgebra R B :=\n  { S.toSubalgebra.map f.toAlgHom with\n    star_mem' := by\n      rintro _ \u27e8a, ha, rfl\u27e9\n      exact map_star f a \u25b8 Set.mem_image_of_mem _ (S.star_mem' ha) }", "start": [200, 1], "end": [205, 69], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_mono", "code": "theorem map_mono {S\u2081 S\u2082 : StarSubalgebra R A} {f : A \u2192\u22c6\u2090[R] B} : S\u2081 \u2264 S\u2082 \u2192 S\u2081.map f \u2264 S\u2082.map f", "start": [208, 1], "end": [209, 21], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_injective", "code": "theorem map_injective {f : A \u2192\u22c6\u2090[R] B} (hf : Function.Injective f) : Function.Injective (map f)", "start": [212, 1], "end": [214, 87], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_id", "code": "@[simp]\ntheorem map_id (S : StarSubalgebra R A) : S.map (StarAlgHom.id R A) = S", "start": [217, 1], "end": [219, 42], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_map", "code": "theorem map_map (S : StarSubalgebra R A) (g : B \u2192\u22c6\u2090[R] C) (f : A \u2192\u22c6\u2090[R] B) :\n    (S.map f).map g = S.map (g.comp f)", "start": [222, 1], "end": [224, 49], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_map", "code": "@[simp]\ntheorem mem_map {S : StarSubalgebra R A} {f : A \u2192\u22c6\u2090[R] B} {y : B} :\n    y \u2208 map f S \u2194 \u2203 x \u2208 S, f x = y", "start": [227, 1], "end": [230, 22], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_toSubalgebra", "code": "theorem map_toSubalgebra {S : StarSubalgebra R A} {f : A \u2192\u22c6\u2090[R] B} :\n    (S.map f).toSubalgebra = S.toSubalgebra.map f.toAlgHom", "start": [233, 1], "end": [235, 28], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_map", "code": "@[simp]\ntheorem coe_map (S : StarSubalgebra R A) (f : A \u2192\u22c6\u2090[R] B) : (S.map f : Set B) = f '' S", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.comap", "code": "def comap (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R B) : StarSubalgebra R A :=\n  { S.toSubalgebra.comap f.toAlgHom with\n    star_mem' := @fun a ha => show f (star a) \u2208 S from (map_star f a).symm \u25b8 star_mem ha }", "start": [243, 1], "end": [246, 91], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {S : StarSubalgebra R A} {f : A \u2192\u22c6\u2090[R] B} {U : StarSubalgebra R B} :\n    map f S \u2264 U \u2194 S \u2264 comap f U", "start": [249, 1], "end": [251, 23], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.gc_map_comap", "code": "theorem gc_map_comap (f : A \u2192\u22c6\u2090[R] B) : GaloisConnection (map f) (comap f)", "start": [254, 1], "end": [255, 22], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.comap_mono", "code": "theorem comap_mono {S\u2081 S\u2082 : StarSubalgebra R B} {f : A \u2192\u22c6\u2090[R] B} :\n    S\u2081 \u2264 S\u2082 \u2192 S\u2081.comap f \u2264 S\u2082.comap f", "start": [258, 1], "end": [260, 20], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.comap_injective", "code": "theorem comap_injective {f : A \u2192\u22c6\u2090[R] B} (hf : Function.Surjective f) :\n    Function.Injective (comap f)", "start": [263, 1], "end": [268, 14], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.comap_id", "code": "@[simp]\ntheorem comap_id (S : StarSubalgebra R A) : S.comap (StarAlgHom.id R A) = S", "start": [271, 1], "end": [273, 43], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.comap_comap", "code": "theorem comap_comap (S : StarSubalgebra R C) (g : B \u2192\u22c6\u2090[R] C) (f : A \u2192\u22c6\u2090[R] B) :\n    (S.comap g).comap f = S.comap (g.comp f)", "start": [276, 1], "end": [278, 58], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_comap", "code": "@[simp]\ntheorem mem_comap (S : StarSubalgebra R B) (f : A \u2192\u22c6\u2090[R] B) (x : A) : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [282, 1], "end": [284, 10], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap (S : StarSubalgebra R B) (f : A \u2192\u22c6\u2090[R] B) :\n    (S.comap f : Set A) = f \u207b\u00b9' (S : Set B)", "start": [287, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.centralizer", "code": "def centralizer (s : Set A) : StarSubalgebra R A where\n  toSubalgebra := Subalgebra.centralizer R (s \u222a star s)\n  star_mem' := Set.star_mem_centralizer", "start": [299, 1], "end": [302, 40], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set A) : (centralizer R s : Set A) = (s \u222a star s).centralizer", "start": [305, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {s : Set A} {z : A} :\n    z \u2208 centralizer R s \u2194 \u2200 g \u2208 s, g * z = z * g \u2227 star g * z = z * star g", "start": [310, 1], "end": [315, 91], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.centralizer_le", "code": "theorem centralizer_le (s t : Set A) (h : s \u2286 t) : centralizer R t \u2264 centralizer R s", "start": [318, 1], "end": [319, 75], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.involutiveStar", "code": "instance involutiveStar : InvolutiveStar (Subalgebra R A) where\n  star S :=\n    { carrier := star S.carrier\n      mul_mem' := fun {x y} hx hy => by\n        simp only [Set.mem_star, Subalgebra.mem_carrier] at *\n        exact (star_mul x y).symm \u25b8 mul_mem hy hx\n      one_mem' := Set.mem_star.mp ((star_one A).symm \u25b8 one_mem S : star (1 : A) \u2208 S)\n      add_mem' := fun {x y} hx hy => by\n        simp only [Set.mem_star, Subalgebra.mem_carrier] at *\n        exact (star_add x y).symm \u25b8 add_mem hx hy\n      zero_mem' := Set.mem_star.mp ((star_zero A).symm \u25b8 zero_mem S : star (0 : A) \u2208 S)\n      algebraMap_mem' := fun r => by\n        simpa only [Set.mem_star, Subalgebra.mem_carrier, \u2190 algebraMap_star_comm] using\n          S.algebraMap_mem (star r) }\n  star_involutive S :=\n    Subalgebra.ext fun x =>\n      \u27e8fun hx => star_star x \u25b8 hx, fun hx => ((star_star x).symm \u25b8 hx : star (star x) \u2208 S)\u27e9", "start": [339, 1], "end": [356, 92], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_star_iff", "code": "@[simp]\ntheorem mem_star_iff (S : Subalgebra R A) (x : A) : x \u2208 star S \u2194 star x \u2208 S", "start": [358, 1], "end": [360, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.star_mem_star_iff", "code": "theorem star_mem_star_iff (S : Subalgebra R A) (x : A) : star x \u2208 star S \u2194 x \u2208 S", "start": [364, 1], "end": [365, 38], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_star", "code": "@[simp]\ntheorem coe_star (S : Subalgebra R A) : ((star S : Subalgebra R A) : Set A) = star (S : Set A)", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.star_mono", "code": "theorem star_mono : Monotone (star : Subalgebra R A \u2192 Subalgebra R A)", "start": [373, 1], "end": [373, 96], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.star_adjoin_comm", "code": "theorem star_adjoin_comm (s : Set A) : star (Algebra.adjoin R s) = Algebra.adjoin R (star s)", "start": [378, 1], "end": [382, 94], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.starClosure", "code": "@[simps!]\ndef starClosure (S : Subalgebra R A) : StarSubalgebra R A where\n  toSubalgebra := S \u2294 star S\n  star_mem' := fun {a} ha => by\n    simp only [Subalgebra.mem_carrier, \u2190 (@Algebra.gi R A _ _ _).l_sup_u _ _] at *\n    rw [\u2190 mem_star_iff _ a, star_adjoin_comm, sup_comm]\n    simpa using ha", "start": [387, 1], "end": [395, 19], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.starClosure_toSubalgebra", "code": "theorem starClosure_toSubalgebra (S : Subalgebra R A) : S.starClosure.toSubalgebra = S \u2294 star S", "start": [398, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.starClosure_le", "code": "theorem starClosure_le {S\u2081 : Subalgebra R A} {S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082.toSubalgebra) :\n    S\u2081.starClosure \u2264 S\u2082", "start": [401, 1], "end": [405, 94], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.starClosure_le_iff", "code": "theorem starClosure_le_iff {S\u2081 : Subalgebra R A} {S\u2082 : StarSubalgebra R A} :\n    S\u2081.starClosure \u2264 S\u2082 \u2194 S\u2081 \u2264 S\u2082.toSubalgebra", "start": [408, 1], "end": [410, 49], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin", "code": "@[simps!]\ndef adjoin (s : Set A) : StarSubalgebra R A :=\n  { Algebra.adjoin R (s \u222a star s) with\n    star_mem' := fun hx => by\n      rwa [Subalgebra.mem_carrier, \u2190 Subalgebra.mem_star_iff, Subalgebra.star_adjoin_comm,\n        Set.union_star, star_star, Set.union_comm] }", "start": [428, 1], "end": [434, 53], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_eq_starClosure_adjoin", "code": "theorem adjoin_eq_starClosure_adjoin (s : Set A) : adjoin R s = (Algebra.adjoin R s).starClosure", "start": [437, 1], "end": [440, 79], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_toSubalgebra", "code": "theorem adjoin_toSubalgebra (s : Set A) :\n    (adjoin R s).toSubalgebra = Algebra.adjoin R (s \u222a star s)", "start": [443, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.subset_adjoin", "code": "@[aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_adjoin (s : Set A) : s \u2286 adjoin R s", "start": [448, 1], "end": [450, 65], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.star_subset_adjoin", "code": "theorem star_subset_adjoin (s : Set A) : star s \u2286 adjoin R s", "start": [453, 1], "end": [454, 66], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.self_mem_adjoin_singleton", "code": "theorem self_mem_adjoin_singleton (x : A) : x \u2208 adjoin R ({x} : Set A)", "start": [457, 1], "end": [458, 70], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.star_self_mem_adjoin_singleton", "code": "theorem star_self_mem_adjoin_singleton (x : A) : star x \u2208 adjoin R ({x} : Set A)", "start": [461, 1], "end": [462, 44], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.gc", "code": "protected theorem gc : GaloisConnection (adjoin R : Set A \u2192 StarSubalgebra R A) (\u2191)", "start": [467, 1], "end": [472, 89], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.gi", "code": "protected def gi : GaloisInsertion (adjoin R : Set A \u2192 StarSubalgebra R A) (\u2191) where\n  choice s hs := (adjoin R s).copy s <| le_antisymm (StarSubalgebra.gc.le_u_l s) hs\n  gc := StarSubalgebra.gc\n  le_l_u S := (StarSubalgebra.gc (S : Set A) (adjoin R S)).1 <| le_rfl\n  choice_eq _ _ := StarSubalgebra.copy_eq _ _ _", "start": [475, 1], "end": [480, 48], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_le", "code": "theorem adjoin_le {S : StarSubalgebra R A} {s : Set A} (hs : s \u2286 S) : adjoin R s \u2264 S", "start": [483, 1], "end": [484, 28], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_le_iff", "code": "theorem adjoin_le_iff {S : StarSubalgebra R A} {s : Set A} : adjoin R s \u2264 S \u2194 s \u2286 S", "start": [487, 1], "end": [488, 24], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.starClosure_eq_adjoin", "code": "theorem _root_.Subalgebra.starClosure_eq_adjoin (S : Subalgebra R A) :\n    S.starClosure = adjoin R (S : Set A)", "start": [491, 1], "end": [494, 47], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_induction", "code": "theorem adjoin_induction {s : Set A} {p : A \u2192 Prop} {a : A} (h : a \u2208 adjoin R s)\n    (Hs : \u2200 x : A, x \u2208 s \u2192 p x) (Halg : \u2200 r : R, p (algebraMap R A r))\n    (Hadd : \u2200 x y : A, p x \u2192 p y \u2192 p (x + y)) (Hmul : \u2200 x y : A, p x \u2192 p y \u2192 p (x * y))\n    (Hstar : \u2200 x : A, p x \u2192 p (star x)) : p a", "start": [497, 1], "end": [505, 9], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_induction\u2082", "code": "theorem adjoin_induction\u2082 {s : Set A} {p : A \u2192 A \u2192 Prop} {a b : A} (ha : a \u2208 adjoin R s)\n    (hb : b \u2208 adjoin R s) (Hs : \u2200 x : A, x \u2208 s \u2192 \u2200 y : A, y \u2208 s \u2192 p x y)\n    (Halg : \u2200 r\u2081 r\u2082 : R, p (algebraMap R A r\u2081) (algebraMap R A r\u2082))\n    (Halg_left : \u2200 (r : R) (x : A), x \u2208 s \u2192 p (algebraMap R A r) x)\n    (Halg_right : \u2200 (r : R) (x : A), x \u2208 s \u2192 p x (algebraMap R A r))\n    (Hadd_left : \u2200 x\u2081 x\u2082 y : A, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082 : A, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y : A, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082 : A, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082))\n    (Hstar : \u2200 x y : A, p x y \u2192 p (star x) (star y)) (Hstar_left : \u2200 x y : A, p x y \u2192 p (star x) y)\n    (Hstar_right : \u2200 x y : A, p x y \u2192 p x (star y)) : p a b", "start": [508, 1], "end": [532, 61], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoin_induction'", "code": "theorem adjoin_induction' {s : Set A} {p : adjoin R s \u2192 Prop} (a : adjoin R s)\n    (Hs : \u2200 (x) (h : x \u2208 s), p \u27e8x, subset_adjoin R s h\u27e9) (Halg : \u2200 r, p (algebraMap R _ r))\n    (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y))\n    (Hstar : \u2200 x, p x \u2192 p (star x)) : p a", "start": [535, 1], "end": [548, 75], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoinCommSemiringOfComm", "code": "@[reducible]\ndef adjoinCommSemiringOfComm {s : Set A} (hcomm : \u2200 a : A, a \u2208 s \u2192 \u2200 b : A, b \u2208 s \u2192 a * b = b * a)\n    (hcomm_star : \u2200 a : A, a \u2208 s \u2192 \u2200 b : A, b \u2208 s \u2192 a * star b = star b * a) :\n    CommSemiring (adjoin R s) :=\n  { (adjoin R s).toSubalgebra.toSemiring with\n    mul_comm := by\n      rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9\n      ext\n      simp only [MulMemClass.mk_mul_mk]\n      rw [\u2190 mem_toSubalgebra, adjoin_toSubalgebra] at hx hy\n      letI : CommSemiring (Algebra.adjoin R (s \u222a star s)) :=\n        Algebra.adjoinCommSemiringOfComm R\n          (by\n            intro a ha b hb\n            cases' ha with ha ha <;> cases' hb with hb hb\n            \u00b7 exact hcomm _ ha _ hb\n            \u00b7 exact star_star b \u25b8 hcomm_star _ ha _ hb\n            \u00b7 exact star_star a \u25b8 (hcomm_star _ hb _ ha).symm\n            \u00b7 simpa only [star_mul, star_star] using congr_arg star (hcomm _ hb _ ha))\n      exact congr_arg Subtype.val (mul_comm (\u27e8x, hx\u27e9 : Algebra.adjoin R (s \u222a star s)) \u27e8y, hy\u27e9) }", "start": [553, 1], "end": [574, 97], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoinCommRingOfComm", "code": "@[reducible]\ndef adjoinCommRingOfComm (R : Type u) {A : Type v} [CommRing R] [StarRing R] [Ring A] [Algebra R A]\n    [StarRing A] [StarModule R A] {s : Set A}\n    (hcomm : \u2200 a : A, a \u2208 s \u2192 \u2200 b : A, b \u2208 s \u2192 a * b = b * a)\n    (hcomm_star : \u2200 a : A, a \u2208 s \u2192 \u2200 b : A, b \u2208 s \u2192 a * star b = star b * a) :\n    CommRing (adjoin R s) :=\n  { StarSubalgebra.adjoinCommSemiringOfComm R hcomm hcomm_star,\n    (adjoin R s).toSubalgebra.toRing with }", "start": [577, 1], "end": [586, 44], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoinCommSemiringOfIsStarNormal", "code": "instance adjoinCommSemiringOfIsStarNormal (x : A) [IsStarNormal x] :\n    CommSemiring (adjoin R ({x} : Set A)) :=\n  adjoinCommSemiringOfComm R\n    (fun a ha b hb => by\n      rw [Set.mem_singleton_iff] at ha hb\n      rw [ha, hb])\n    fun a ha b hb => by\n    rw [Set.mem_singleton_iff] at ha hb\n    simpa only [ha, hb] using (star_comm_self' x).symm", "start": [589, 1], "end": [599, 55], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.adjoinCommRingOfIsStarNormal", "code": "instance adjoinCommRingOfIsStarNormal (R : Type u) {A : Type v} [CommRing R] [StarRing R] [Ring A]\n    [Algebra R A] [StarRing A] [StarModule R A] (x : A) [IsStarNormal x] :\n    CommRing (adjoin R ({x} : Set A)) :=\n  { (adjoin R ({x} : Set A)).toSubalgebra.toRing with mul_comm := mul_comm }", "start": [602, 1], "end": [607, 77], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.completeLattice", "code": "instance completeLattice : CompleteLattice (StarSubalgebra R A) :=\n  GaloisInsertion.liftCompleteLattice StarSubalgebra.gi", "start": [615, 1], "end": [616, 56], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.inhabited", "code": "instance inhabited : Inhabited (StarSubalgebra R A) :=\n  \u27e8\u22a4\u27e9", "start": [618, 1], "end": [619, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_top", "code": "@[simp]\ntheorem coe_top : (\u2191(\u22a4 : StarSubalgebra R A) : Set A) = Set.univ", "start": [621, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_top", "code": "@[simp]\ntheorem mem_top {x : A} : x \u2208 (\u22a4 : StarSubalgebra R A)", "start": [626, 1], "end": [628, 17], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.top_toSubalgebra", "code": "@[simp]\ntheorem top_toSubalgebra : (\u22a4 : StarSubalgebra R A).toSubalgebra = \u22a4", "start": [631, 1], "end": [632, 85], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toSubalgebra_eq_top", "code": "@[simp]\ntheorem toSubalgebra_eq_top {S : StarSubalgebra R A} : S.toSubalgebra = \u22a4 \u2194 S = \u22a4", "start": [636, 1], "end": [638, 65], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_sup_left", "code": "theorem mem_sup_left {S T : StarSubalgebra R A} : \u2200 {x : A}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [641, 1], "end": [642, 44], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_sup_right", "code": "theorem mem_sup_right {S T : StarSubalgebra R A} : \u2200 {x : A}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [645, 1], "end": [646, 45], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mul_mem_sup", "code": "theorem mul_mem_sup {S T : StarSubalgebra R A} {x y : A} (hx : x \u2208 S) (hy : y \u2208 T) :\n    x * y \u2208 S \u2294 T", "start": [649, 1], "end": [651, 47], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_sup", "code": "theorem map_sup (f : A \u2192\u22c6\u2090[R] B) (S T : StarSubalgebra R A) : map f (S \u2294 T) = map f S \u2294 map f T", "start": [654, 1], "end": [655, 40], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (S T : StarSubalgebra R A) : (\u2191(S \u2293 T) : Set A) = (S : Set A) \u2229 T", "start": [658, 1], "end": [660, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_inf", "code": "@[simp]\ntheorem mem_inf {S T : StarSubalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T", "start": [663, 1], "end": [665, 10], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.inf_toSubalgebra", "code": "@[simp]\ntheorem inf_toSubalgebra (S T : StarSubalgebra R A) :\n    (S \u2293 T).toSubalgebra = S.toSubalgebra \u2293 T.toSubalgebra", "start": [668, 1], "end": [671, 12], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (StarSubalgebra R A)) : (\u2191(sInf S) : Set A) = \u22c2 s \u2208 S, \u2191s", "start": [675, 1], "end": [677, 13], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_sInf", "code": "theorem mem_sInf {S : Set (StarSubalgebra R A)} {x : A} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [680, 1], "end": [681, 59], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.sInf_toSubalgebra", "code": "@[simp]\ntheorem sInf_toSubalgebra (S : Set (StarSubalgebra R A)) :\n    (sInf S).toSubalgebra = sInf (StarSubalgebra.toSubalgebra '' S)", "start": [684, 1], "end": [687, 35], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 StarSubalgebra R A} : (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i", "start": [690, 1], "end": [692, 14], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 StarSubalgebra R A} {x : A} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [695, 1], "end": [696, 89], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.iInf_toSubalgebra", "code": "@[simp]\ntheorem iInf_toSubalgebra {\u03b9 : Sort*} (S : \u03b9 \u2192 StarSubalgebra R A) :\n    (\u2a05 i, S i).toSubalgebra = \u2a05 i, (S i).toSubalgebra", "start": [699, 1], "end": [702, 35], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.bot_toSubalgebra", "code": "theorem bot_toSubalgebra : (\u22a5 : StarSubalgebra R A).toSubalgebra = \u22a5", "start": [705, 1], "end": [707, 7], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.mem_bot", "code": "theorem mem_bot {x : A} : x \u2208 (\u22a5 : StarSubalgebra R A) \u2194 x \u2208 Set.range (algebraMap R A)", "start": [710, 1], "end": [711, 61], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.coe_bot", "code": "@[simp]\ntheorem coe_bot : ((\u22a5 : StarSubalgebra R A) : Set A) = Set.range (algebraMap R A)", "start": [714, 1], "end": [716, 30], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.eq_top_iff", "code": "theorem eq_top_iff {S : StarSubalgebra R A} : S = \u22a4 \u2194 \u2200 x : A, x \u2208 S", "start": [719, 1], "end": [721, 61], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.equalizer", "code": "def equalizer : StarSubalgebra R A :=\n  { toSubalgebra := AlgHom.equalizer (f : A \u2192\u2090[R] B) g\n    star_mem' := @fun a (ha : f a = g a) => by simpa only [\u2190map_star] using congrArg star ha }", "start": [738, 1], "end": [741, 95], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.mem_equalizer", "code": "@[simp]\ntheorem mem_equalizer (x : A) : x \u2208 StarAlgHom.equalizer f g \u2194 f x = g x", "start": [745, 1], "end": [747, 10], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.adjoin_le_equalizer", "code": "theorem adjoin_le_equalizer {s : Set A} (h : s.EqOn f g) : adjoin R s \u2264 StarAlgHom.equalizer f g", "start": [750, 1], "end": [751, 14], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.ext_of_adjoin_eq_top", "code": "theorem ext_of_adjoin_eq_top {s : Set A} (h : adjoin R s = \u22a4) \u2983f g : F\u2984 (hs : s.EqOn f g) : f = g", "start": [754, 1], "end": [755, 86], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.map_adjoin", "code": "theorem map_adjoin [StarModule R B] (f : A \u2192\u22c6\u2090[R] B) (s : Set A) :\n    map f (adjoin R s) = adjoin R (f '' s)", "start": [758, 1], "end": [761, 35], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.ext_adjoin", "code": "theorem ext_adjoin {s : Set A} [StarAlgHomClass F R (adjoin R s) B] {f g : F}\n    (h : \u2200 x : adjoin R s, (x : A) \u2208 s \u2192 f x = g x) : f = g", "start": [764, 1], "end": [773, 29], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.ext_adjoin_singleton", "code": "theorem ext_adjoin_singleton {a : A} [StarAlgHomClass F R (adjoin R ({a} : Set A)) B] {f g : F}\n    (h : f \u27e8a, self_mem_adjoin_singleton R a\u27e9 = g \u27e8a, self_mem_adjoin_singleton R a\u27e9) : f = g", "start": [776, 1], "end": [781, 8], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.range", "code": "protected def range\n    (\u03c6 : A \u2192\u22c6\u2090[R] B) : StarSubalgebra R B where\n  toSubalgebra := \u03c6.toAlgHom.range\n  star_mem' := by rintro _ \u27e8b, rfl\u27e9; exact \u27e8star b, map_star \u03c6 b\u27e9", "start": [784, 1], "end": [788, 66], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.range_eq_map_top", "code": "theorem range_eq_map_top (\u03c6 : A \u2192\u22c6\u2090[R] B) : \u03c6.range = (\u22a4 : StarSubalgebra R A).map \u03c6", "start": [790, 1], "end": [792, 85], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.codRestrict", "code": "protected def codRestrict (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R B) (hf : \u2200 x, f x \u2208 S) :\n    A \u2192\u22c6\u2090[R] S where\n  toAlgHom := AlgHom.codRestrict f.toAlgHom S.toSubalgebra hf\n  map_star' := fun x => Subtype.ext (map_star f x)", "start": [794, 1], "end": [798, 51], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.coe_codRestrict", "code": "@[simp]\ntheorem coe_codRestrict (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R B) (hf : \u2200 x, f x \u2208 S) (x : A) :\n    \u2191(f.codRestrict S hf x) = f x", "start": [800, 1], "end": [803, 6], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.subtype_comp_codRestrict", "code": "@[simp]\ntheorem subtype_comp_codRestrict (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R B)\n    (hf : \u2200 x : A, f x \u2208 S) : S.subtype.comp (f.codRestrict S hf) = f", "start": [805, 1], "end": [808, 43], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.injective_codRestrict", "code": "theorem injective_codRestrict (f : A \u2192\u22c6\u2090[R] B) (S : StarSubalgebra R B) (hf : \u2200 x : A, f x \u2208 S) :\n    Function.Injective (StarAlgHom.codRestrict f S hf) \u2194 Function.Injective f", "start": [810, 1], "end": [812, 97], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.rangeRestrict", "code": "def rangeRestrict (f : A \u2192\u22c6\u2090[R] B) : A \u2192\u22c6\u2090[R] f.range :=\n  StarAlgHom.codRestrict f _ fun x => \u27e8x, rfl\u27e9", "start": [814, 1], "end": [816, 47], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.ofInjective", "code": "@[simps]\nnoncomputable def _root_.StarAlgEquiv.ofInjective (f : A \u2192\u22c6\u2090[R] B)\n    (hf : Function.Injective f) : A \u2243\u22c6\u2090[R] f.range :=\n  { AlgEquiv.ofInjective (f : A \u2192\u2090[R] B) hf with\n    toFun := f.rangeRestrict\n    map_star' := fun a => Subtype.ext (map_star f a)\n    map_smul' := fun r a => Subtype.ext (map_smul f r a) }", "start": [818, 1], "end": [825, 59], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.restrictScalars", "code": "@[simps!]\ndef StarAlgHom.restrictScalars (f : A \u2192\u22c6\u2090[S] B) : A \u2192\u22c6\u2090[R] B where\n  toAlgHom := f.toAlgHom.restrictScalars R\n  map_star' := map_star f", "start": [835, 1], "end": [838, 26], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.restrictScalars_injective", "code": "theorem StarAlgHom.restrictScalars_injective :\n    Function.Injective (StarAlgHom.restrictScalars R : (A \u2192\u22c6\u2090[S] B) \u2192 A \u2192\u22c6\u2090[R] B)", "start": [840, 1], "end": [843, 82], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.restrictScalars", "code": "@[simps]\ndef StarAlgEquiv.restrictScalars (f : A \u2243\u22c6\u2090[S] B) : A \u2243\u22c6\u2090[R] B :=\n  { (f : A \u2192\u22c6\u2090[S] B).restrictScalars R, f with\n    toFun := f\n    map_smul' := map_smul ((f : A \u2192\u22c6\u2090[S] B).restrictScalars R) }", "start": [845, 1], "end": [849, 65], "kind": "commanddeclaration"}, {"full_name": "StarAlgEquiv.restrictScalars_injective", "code": "theorem StarAlgEquiv.restrictScalars_injective :\n    Function.Injective (StarAlgEquiv.restrictScalars R : (A \u2243\u22c6\u2090[S] B) \u2192 A \u2243\u22c6\u2090[R] B)", "start": [851, 1], "end": [854, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Factors.lean", "imports": ["Mathlib/Data/List/Prime.lean", "Mathlib/Data/Nat/Prime.lean", "Mathlib/Data/List/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.factors", "code": "def factors : \u2115 \u2192 List \u2115\n  | 0 => []\n  | 1 => []\n  | k + 2 =>\n    let m := minFac (k + 2)\n    have : (k + 2) / m < (k + 2) := factors_lemma\n    m :: factors ((k + 2) / m)", "start": [32, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_zero", "code": "@[simp]\ntheorem factors_zero : factors 0 = []", "start": [42, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_one", "code": "@[simp]\ntheorem factors_one : factors 1 = []", "start": [46, 1], "end": [47, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_of_mem_factors", "code": "theorem prime_of_mem_factors {n : \u2115} : \u2200 {p : \u2115}, (h : p \u2208 factors n) \u2192 Prime p", "start": [50, 1], "end": [60, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_mem_factors", "code": "theorem pos_of_mem_factors {n p : \u2115} (h : p \u2208 factors n) : 0 < p", "start": [63, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_factors", "code": "theorem prod_factors : \u2200 {n}, n \u2260 0 \u2192 List.prod (factors n) = n", "start": [67, 1], "end": [77, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_prime", "code": "theorem factors_prime {p : \u2115} (hp : Nat.Prime p) : p.factors = [p]", "start": [80, 1], "end": [85, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_chain", "code": "theorem factors_chain {n : \u2115} :\n    \u2200 {a}, (\u2200 p, Prime p \u2192 p \u2223 n \u2192 a \u2264 p) \u2192 List.Chain (\u00b7 \u2264 \u00b7) a (factors n)", "start": [88, 1], "end": [99, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_chain_2", "code": "theorem factors_chain_2 (n) : List.Chain (\u00b7 \u2264 \u00b7) 2 (factors n)", "start": [102, 1], "end": [103, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_chain'", "code": "theorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n)", "start": [106, 1], "end": [107, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_sorted", "code": "theorem factors_sorted (n : \u2115) : List.Sorted (\u00b7 \u2264 \u00b7) (factors n)", "start": [110, 1], "end": [111, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_add_two", "code": "theorem factors_add_two (n : \u2115) :\n    factors (n + 2) = minFac (n + 2) :: factors ((n + 2) / minFac (n + 2))", "start": [114, 1], "end": [116, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_eq_nil", "code": "@[simp]\ntheorem factors_eq_nil (n : \u2115) : n.factors = [] \u2194 n = 0 \u2228 n = 1", "start": [119, 1], "end": [129, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_perm_factors", "code": "theorem eq_of_perm_factors {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) (h : a.factors ~ b.factors) :\n    a = b", "start": [132, 1], "end": [133, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors_iff_dvd", "code": "theorem mem_factors_iff_dvd {n p : \u2115} (hn : n \u2260 0) (hp : Prime p) : p \u2208 factors n \u2194 p \u2223 n", "start": [140, 1], "end": [143, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mem_factors", "code": "theorem dvd_of_mem_factors {n p : \u2115} (h : p \u2208 n.factors) : p \u2223 n", "start": [146, 1], "end": [149, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors", "code": "theorem mem_factors {n p} (hn : n \u2260 0) : p \u2208 factors n \u2194 Prime p \u2227 p \u2223 n", "start": [152, 1], "end": [154, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_mem_factors", "code": "theorem le_of_mem_factors {n p : \u2115} (h : p \u2208 n.factors) : p \u2264 n", "start": [157, 1], "end": [161, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_unique", "code": "theorem factors_unique {n : \u2115} {l : List \u2115} (h\u2081 : prod l = n) (h\u2082 : \u2200 p \u2208 l, Prime p) :\n    l ~ factors n", "start": [164, 1], "end": [176, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.factors_pow", "code": "theorem Prime.factors_pow {p : \u2115} (hp : p.Prime) (n : \u2115) :\n    (p ^ n).factors = List.replicate n p", "start": [179, 1], "end": [185, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_prime_pow_of_unique_prime_dvd", "code": "theorem eq_prime_pow_of_unique_prime_dvd {n p : \u2115} (hpos : n \u2260 0)\n    (h : \u2200 {d}, Nat.Prime d \u2192 d \u2223 n \u2192 d = p) : n = p ^ n.factors.length", "start": [188, 1], "end": [192, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.perm_factors_mul", "code": "theorem perm_factors_mul {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a * b).factors ~ a.factors ++ b.factors", "start": [195, 1], "end": [202, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.perm_factors_mul_of_coprime", "code": "theorem perm_factors_mul_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    (a * b).factors ~ a.factors ++ b.factors", "start": [205, 1], "end": [212, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_sublist_right", "code": "theorem factors_sublist_right {n k : \u2115} (h : k \u2260 0) : n.factors <+ (n * k).factors", "start": [215, 1], "end": [220, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_sublist_of_dvd", "code": "theorem factors_sublist_of_dvd {n k : \u2115} (h : n \u2223 k) (h' : k \u2260 0) : n.factors <+ k.factors", "start": [223, 1], "end": [225, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_subset_right", "code": "theorem factors_subset_right {n k : \u2115} (h : k \u2260 0) : n.factors \u2286 (n * k).factors", "start": [228, 1], "end": [229, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_subset_of_dvd", "code": "theorem factors_subset_of_dvd {n k : \u2115} (h : n \u2223 k) (h' : k \u2260 0) : n.factors \u2286 k.factors", "start": [232, 1], "end": [233, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_factors_subperm", "code": "theorem dvd_of_factors_subperm {a b : \u2115} (ha : a \u2260 0) (h : a.factors <+~ b.factors) : a \u2223 b", "start": [236, 1], "end": [248, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors_mul", "code": "theorem mem_factors_mul {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) {p : \u2115} :\n    p \u2208 (a * b).factors \u2194 p \u2208 a.factors \u2228 p \u2208 b.factors", "start": [253, 1], "end": [256, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_factors_disjoint", "code": "theorem coprime_factors_disjoint {a b : \u2115} (hab : a.Coprime b) :\n    List.Disjoint a.factors b.factors", "start": [259, 1], "end": [265, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors_mul_of_coprime", "code": "theorem mem_factors_mul_of_coprime {a b : \u2115} (hab : Coprime a b) (p : \u2115) :\n    p \u2208 (a * b).factors \u2194 p \u2208 a.factors \u222a b.factors", "start": [268, 1], "end": [274, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors_mul_left", "code": "theorem mem_factors_mul_left {p a b : \u2115} (hpa : p \u2208 a.factors) (hb : b \u2260 0) :\n    p \u2208 (a * b).factors", "start": [279, 1], "end": [284, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_factors_mul_right", "code": "theorem mem_factors_mul_right {p a b : \u2115} (hpb : p \u2208 b.factors) (ha : a \u2260 0) :\n    p \u2208 (a * b).factors", "start": [287, 1], "end": [291, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_two_pow_or_exists_odd_prime_and_dvd", "code": "theorem eq_two_pow_or_exists_odd_prime_and_dvd (n : \u2115) :\n    (\u2203 k : \u2115, n = 2 ^ k) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p", "start": [294, 1], "end": [300, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/EuclideanDomain/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Algebra/EuclideanDomain/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean"], "premises": [{"full_name": "EuclideanDomain.mul_div_cancel_left", "code": "theorem mul_div_cancel_left {a : R} (b) (a0 : a \u2260 0) : a * b / a = b", "start": [35, 1], "end": [41, 33], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_div_cancel", "code": "theorem mul_div_cancel (a) {b : R} (b0 : b \u2260 0) : a * b / b = a", "start": [44, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_eq_zero", "code": "@[simp]\ntheorem mod_eq_zero {a b : R} : a % b = 0 \u2194 b \u2223 a", "start": [49, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_self", "code": "@[simp]\ntheorem mod_self (a : R) : a % a = 0", "start": [61, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_mod_iff", "code": "theorem dvd_mod_iff {a b c : R} (h : c \u2223 b) : c \u2223 a % b \u2194 c \u2223 a", "start": [66, 1], "end": [67, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_one", "code": "@[simp]\ntheorem mod_one (a : R) : a % 1 = 0", "start": [70, 1], "end": [72, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.zero_mod", "code": "@[simp]\ntheorem zero_mod (b : R) : 0 % b = 0", "start": [75, 1], "end": [77, 29], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.zero_div", "code": "@[simp]\ntheorem zero_div {a : R} : 0 / a = 0", "start": [80, 1], "end": [83, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_self", "code": "@[simp]\ntheorem div_self {a : R} (a0 : a \u2260 0) : a / a = 1", "start": [86, 1], "end": [88, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.eq_div_of_mul_eq_left", "code": "theorem eq_div_of_mul_eq_left {a b c : R} (hb : b \u2260 0) (h : a * b = c) : a = c / b", "start": [91, 1], "end": [92, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.eq_div_of_mul_eq_right", "code": "theorem eq_div_of_mul_eq_right {a b c : R} (ha : a \u2260 0) (h : a * b = c) : b = c / a", "start": [95, 1], "end": [96, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_div_assoc", "code": "theorem mul_div_assoc (x : R) {y z : R} (h : z \u2223 y) : x * y / z = x * (y / z)", "start": [99, 1], "end": [104, 73], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_div_cancel'", "code": "protected theorem mul_div_cancel' {a b : R} (hb : b \u2260 0) (hab : b \u2223 a) : b * (a / b) = a", "start": [107, 1], "end": [108, 55], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_one", "code": "@[simp]\ntheorem div_one (p : R) : p / 1 = p", "start": [112, 1], "end": [114, 76], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_dvd_of_dvd", "code": "theorem div_dvd_of_dvd {p q : R} (hpq : q \u2223 p) : p / q \u2223 p", "start": [117, 1], "end": [124, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_div_of_mul_dvd", "code": "theorem dvd_div_of_mul_dvd {a b c : R} (h : a * b \u2223 c) : b \u2223 c / a", "start": [127, 1], "end": [132, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_zero_right", "code": "@[simp]\ntheorem gcd_zero_right (a : R) : gcd a 0 = a", "start": [139, 1], "end": [142, 62], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_val", "code": "theorem gcd_val (a b : R) : gcd a b = gcd (b % a) a", "start": [145, 1], "end": [147, 70], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_dvd", "code": "theorem gcd_dvd (a b : R) : gcd a b \u2223 a \u2227 gcd a b \u2223 b", "start": [150, 1], "end": [157, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_dvd_left", "code": "theorem gcd_dvd_left (a b : R) : gcd a b \u2223 a", "start": [160, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_dvd_right", "code": "theorem gcd_dvd_right (a b : R) : gcd a b \u2223 b", "start": [164, 1], "end": [165, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_eq_zero_iff", "code": "protected theorem gcd_eq_zero_iff {a b : R} : gcd a b = 0 \u2194 a = 0 \u2227 b = 0", "start": [168, 1], "end": [171, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_gcd", "code": "theorem dvd_gcd {a b c : R} : c \u2223 a \u2192 c \u2223 b \u2192 c \u2223 gcd a b", "start": [174, 1], "end": [177, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_eq_left", "code": "theorem gcd_eq_left {a b : R} : gcd a b = a \u2194 a \u2223 b", "start": [180, 1], "end": [183, 83], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_one_left", "code": "@[simp]\ntheorem gcd_one_left (a : R) : gcd 1 a = 1", "start": [186, 1], "end": [188, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_self", "code": "@[simp]\ntheorem gcd_self (a : R) : gcd a a = a", "start": [191, 1], "end": [193, 24], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcdAux_fst", "code": "@[simp]\ntheorem xgcdAux_fst (x y : R) : \u2200 s t s' t', (xgcdAux x s t y s' t').1 = gcd x y", "start": [196, 1], "end": [204, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcdAux_val", "code": "theorem xgcdAux_val (x y : R) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)", "start": [207, 1], "end": [208, 39], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.P", "code": "private def P (a b : R) : R \u00d7 R \u00d7 R \u2192 Prop\n  | (r, s, t) => (r : R) = a * s + b * t", "start": [211, 1], "end": [212, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcdAux_P", "code": "theorem xgcdAux_P (a b : R) {r r' : R} {s t s' t'} (p : P a b (r, s, t))\n    (p' : P a b (r', s', t')) : P a b (xgcdAux r s t r' s' t')", "start": [214, 1], "end": [224, 69], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_eq_gcd_ab", "code": "theorem gcd_eq_gcd_ab (a b : R) : (gcd a b : R) = a * gcdA a b + b * gcdB a b", "start": [228, 1], "end": [233, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_lcm_left", "code": "theorem dvd_lcm_left (x y : R) : x \u2223 lcm x y", "start": [252, 1], "end": [259, 89], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_lcm_right", "code": "theorem dvd_lcm_right (x y : R) : y \u2223 lcm x y", "start": [262, 1], "end": [269, 92], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm_dvd", "code": "theorem lcm_dvd {x y z : R} (hxz : x \u2223 z) (hyz : y \u2223 z) : lcm x y \u2223 z", "start": [272, 1], "end": [292, 47], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm_dvd_iff", "code": "@[simp]\ntheorem lcm_dvd_iff {x y z : R} : lcm x y \u2223 z \u2194 x \u2223 z \u2227 y \u2223 z", "start": [295, 1], "end": [298, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm_zero_left", "code": "@[simp]\ntheorem lcm_zero_left (x : R) : lcm 0 x = 0", "start": [301, 1], "end": [302, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm_zero_right", "code": "@[simp]\ntheorem lcm_zero_right (x : R) : lcm x 0 = 0", "start": [305, 1], "end": [306, 80], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm_eq_zero_iff", "code": "@[simp]\ntheorem lcm_eq_zero_iff {x y : R} : lcm x y = 0 \u2194 x = 0 \u2228 y = 0", "start": [309, 1], "end": [326, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_mul_lcm", "code": "@[simp]\ntheorem gcd_mul_lcm (x y : R) : gcd x y * lcm x y = x * y", "start": [329, 1], "end": [337, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_div_mul_cancel", "code": "theorem mul_div_mul_cancel {a b c : R} (ha : a \u2260 0) (hcb : c \u2223 b) : a * b / (a * c) = b / c", "start": [344, 1], "end": [348, 47], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_div_mul_comm_of_dvd_dvd", "code": "theorem mul_div_mul_comm_of_dvd_dvd {a b c d : R} (hac : c \u2223 a) (hbd : d \u2223 b) :\n    a * b / (c * d) = a / c * (b / d)", "start": [351, 1], "end": [358, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Types.lean", "imports": ["Mathlib/CategoryTheory/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Logic/Equiv/Basic.lean"], "premises": [{"full_name": "CategoryTheory.types", "code": "@[to_additive existing CategoryTheory.types]\ninstance types : LargeCategory (Type u)\n    where\n  Hom a b := a \u2192 b\n  id a := id\n  comp f g := g \u2218 f", "start": [44, 1], "end": [49, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_hom", "code": "theorem types_hom {\u03b1 \u03b2 : Type u} : (\u03b1 \u27f6 \u03b2) = (\u03b1 \u2192 \u03b2)", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_ext", "code": "@[ext] theorem types_ext {\u03b1 \u03b2 : Type u} (f g : \u03b1 \u27f6 \u03b2) (h : \u2200 a : \u03b1, f a = g a) : f = g", "start": [59, 1], "end": [61, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_id", "code": "theorem types_id (X : Type u) : \ud835\udfd9 X = id", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_comp", "code": "theorem types_comp {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z) : f \u226b g = g \u2218 f", "start": [67, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_id_apply", "code": "@[simp]\ntheorem types_id_apply (X : Type u) (x : X) : (\ud835\udfd9 X : X \u2192 X) x = x", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.types_comp_apply", "code": "@[simp]\ntheorem types_comp_apply {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z) (x : X) : (f \u226b g) x = g (f x)", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hom_inv_id_apply", "code": "@[simp]\ntheorem hom_inv_id_apply {X Y : Type u} (f : X \u2245 Y) (x : X) : f.inv (f.hom x) = x", "start": [81, 1], "end": [83, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv_hom_id_apply", "code": "@[simp]\ntheorem inv_hom_id_apply {X Y : Type u} (f : X \u2245 Y) (y : Y) : f.hom (f.inv y) = y", "start": [86, 1], "end": [88, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.asHom", "code": "abbrev asHom {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) : \u03b1 \u27f6 \u03b2 :=\n  f", "start": [92, 1], "end": [94, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sections", "code": "def sections (F : J \u2964 Type w) : Set (\u2200 j, F.obj j) :=\n  { u | \u2200 {j j'} (f : j \u27f6 j'), F.map f (u j) = u j' }", "start": [118, 1], "end": [125, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sections_property", "code": "@[simp]\nlemma sections_property {F : J \u2964 Type w} (s : (F.sections : Type _))\n    {j j' : J} (f : j \u27f6 j') : F.map f (s.val j) = s.val j' :=\n  s.property f", "start": [129, 1], "end": [132, 15], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.FunctorToTypes.map_comp_apply", "code": "@[simp]\ntheorem map_comp_apply (f : X \u27f6 Y) (g : Y \u27f6 Z) (a : F.obj X) :\n    (F.map (f \u226b g)) a = (F.map g) ((F.map f) a)", "start": [142, 1], "end": [144, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.map_id_apply", "code": "@[simp]\ntheorem map_id_apply (a : F.obj X) : (F.map (\ud835\udfd9 X)) a = a", "start": [147, 1], "end": [148, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.naturality", "code": "theorem naturality (f : X \u27f6 Y) (x : F.obj X) : \u03c3.app Y ((F.map f) x) = (G.map f) (\u03c3.app X x)", "start": [151, 1], "end": [152, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.comp", "code": "@[simp]\ntheorem comp (x : F.obj X) : (\u03c3 \u226b \u03c4).app X x = \u03c4.app X (\u03c3.app X x)", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.hcomp", "code": "@[simp]\ntheorem hcomp (x : (I \u22d9 F).obj W) : (\u03c1 \u25eb \u03c3).app W x = (G.map (\u03c1.app W)) (\u03c3.app (I.obj W) x)", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.map_inv_map_hom_apply", "code": "@[simp]\ntheorem map_inv_map_hom_apply (f : X \u2245 Y) (x : F.obj X) : F.map f.inv (F.map f.hom x) = x", "start": [167, 1], "end": [169, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.map_hom_map_inv_apply", "code": "@[simp]\ntheorem map_hom_map_inv_apply (f : X \u2245 Y) (y : F.obj Y) : F.map f.hom (F.map f.inv y) = y", "start": [172, 1], "end": [174, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.hom_inv_id_app_apply", "code": "@[simp]\ntheorem hom_inv_id_app_apply (\u03b1 : F \u2245 G) (X) (x) : \u03b1.inv.app X (\u03b1.hom.app X x) = x", "start": [177, 1], "end": [179, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FunctorToTypes.inv_hom_id_app_apply", "code": "@[simp]\ntheorem inv_hom_id_app_apply (\u03b1 : F \u2245 G) (X) (x) : \u03b1.hom.app X (\u03b1.inv.app X x) = x", "start": [182, 1], "end": [184, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftTrivial", "code": "def uliftTrivial (V : Type u) : ULift.{u} V \u2245 V where\n  hom a := a.1\n  inv a := .up a", "start": [189, 1], "end": [194, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftFunctor", "code": "@[pp_with_univ]\ndef uliftFunctor : Type u \u2964 Type max u v\n    where\n  obj X := ULift.{v} X\n  map {X} {Y} f := fun x : ULift.{v} X => ULift.up (f x.down)", "start": [197, 1], "end": [204, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftFunctor_map", "code": "@[simp]\ntheorem uliftFunctor_map {X Y : Type u} (f : X \u27f6 Y) (x : ULift.{v} X) :\n    uliftFunctor.map f x = ULift.up (f x.down)", "start": [207, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftFunctorFull", "code": "instance uliftFunctorFull : Full.{u} uliftFunctor where preimage f x := (f (ULift.up x)).down", "start": [213, 1], "end": [213, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftFunctor_faithful", "code": "instance uliftFunctor_faithful : Faithful uliftFunctor where\n  map_injective {_X} {_Y} f g p :=\n    funext fun x =>\n      congr_arg ULift.down (congr_fun p (ULift.up x) : ULift.up (f x) = ULift.up (g x))", "start": [216, 1], "end": [219, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftFunctorTrivial", "code": "def uliftFunctorTrivial : uliftFunctor.{u, u} \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents uliftTrivial", "start": [222, 1], "end": [225, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.homOfElement", "code": "def homOfElement {X : Type u} (x : X) : PUnit \u27f6 X := fun _ => x", "start": [230, 1], "end": [231, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.homOfElement_eq_iff", "code": "theorem homOfElement_eq_iff {X : Type u} (x y : X) : homOfElement x = homOfElement y \u2194 x = y", "start": [234, 1], "end": [235, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_iff_injective", "code": "theorem mono_iff_injective {X Y : Type u} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f", "start": [238, 1], "end": [248, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.injective_of_mono", "code": "theorem injective_of_mono {X Y : Type u} (f : X \u27f6 Y) [hf : Mono f] : Function.Injective f", "start": [251, 1], "end": [252, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.epi_iff_surjective", "code": "theorem epi_iff_surjective {X Y : Type u} (f : X \u27f6 Y) : Epi f \u2194 Function.Surjective f", "start": [255, 1], "end": [267, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.surjective_of_epi", "code": "theorem surjective_of_epi {X Y : Type u} (f : X \u27f6 Y) [hf : Epi f] : Function.Surjective f", "start": [270, 1], "end": [271, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ofTypeFunctor", "code": "def ofTypeFunctor (m : Type u \u2192 Type v) [_root_.Functor m] [LawfulFunctor m] : Type u \u2964 Type v\n    where\n  obj := m\n  map f := Functor.map f\n  map_id := fun \u03b1 => by funext X; apply id_map  \n  map_comp f g := funext fun a => LawfulFunctor.comp_map f g _", "start": [276, 1], "end": [285, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ofTypeFunctor_obj", "code": "@[simp]\ntheorem ofTypeFunctor_obj : (ofTypeFunctor m).obj = m", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ofTypeFunctor_map", "code": "@[simp]\ntheorem ofTypeFunctor_map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) :\n    (ofTypeFunctor m).map f = (Functor.map f : m \u03b1 \u2192 m \u03b2)", "start": [295, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toIso", "code": "def toIso (e : X \u2243 Y) : X \u2245 Y where\n  hom := e.toFun\n  inv := e.invFun\n  hom_inv_id := funext e.left_inv\n  inv_hom_id := funext e.right_inv", "start": [312, 1], "end": [319, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.toIso_hom", "code": "@[simp]\ntheorem toIso_hom {e : X \u2243 Y} : e.toIso.hom = e", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toIso_inv", "code": "@[simp]\ntheorem toIso_inv {e : X \u2243 Y} : e.toIso.inv = e.symm", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toEquiv", "code": "@[pp_dot]\ndef toEquiv (i : X \u2245 Y) : X \u2243 Y where\n  toFun := i.hom\n  invFun := i.inv\n  left_inv x := congr_fun i.hom_inv_id x\n  right_inv y := congr_fun i.inv_hom_id y", "start": [342, 1], "end": [348, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toEquiv_fun", "code": "@[simp]\ntheorem toEquiv_fun (i : X \u2245 Y) : (i.toEquiv : X \u2192 Y) = i.hom", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toEquiv_symm_fun", "code": "@[simp]\ntheorem toEquiv_symm_fun (i : X \u2245 Y) : (i.toEquiv.symm : Y \u2192 X) = i.inv", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toEquiv_id", "code": "@[simp]\ntheorem toEquiv_id (X : Type u) : (Iso.refl X).toEquiv = Equiv.refl X", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toEquiv_comp", "code": "@[simp]\ntheorem toEquiv_comp {X Y Z : Type u} (f : X \u2245 Y) (g : Y \u2245 Z) :\n    (f \u226a\u226b g).toEquiv = f.toEquiv.trans g.toEquiv", "start": [366, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_iff_bijective", "code": "theorem isIso_iff_bijective {X Y : Type u} (f : X \u27f6 Y) : IsIso f \u2194 Function.Bijective f", "start": [376, 1], "end": [379, 47], "kind": "commanddeclaration"}, {"full_name": "equivIsoIso", "code": "@[simps]\ndef equivIsoIso {X Y : Type u} : X \u2243 Y \u2245 X \u2245 Y\n    where\n  hom e := e.toIso\n  inv i := i.toEquiv", "start": [392, 1], "end": [398, 21], "kind": "commanddeclaration"}, {"full_name": "equivEquivIso", "code": "def equivEquivIso {X Y : Type u} : X \u2243 Y \u2243 (X \u2245 Y) :=\n  equivIsoIso.toEquiv", "start": [401, 1], "end": [404, 22], "kind": "commanddeclaration"}, {"full_name": "equivEquivIso_hom", "code": "@[simp]\ntheorem equivEquivIso_hom {X Y : Type u} (e : X \u2243 Y) : equivEquivIso e = e.toIso", "start": [407, 1], "end": [409, 6], "kind": "commanddeclaration"}, {"full_name": "equivEquivIso_inv", "code": "@[simp]\ntheorem equivEquivIso_inv {X Y : Type u} (e : X \u2245 Y) : equivEquivIso.symm e = e.toEquiv", "start": [412, 1], "end": [414, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Products/Bifunctor.lean", "imports": ["Mathlib/CategoryTheory/Products/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bifunctor.map_id", "code": "@[simp]\ntheorem map_id (F : C \u00d7 D \u2964 E) (X : C) (Y : D) :\n    F.map ((\ud835\udfd9 X, \ud835\udfd9 Y) : (X, Y) \u27f6 (X, Y)) = \ud835\udfd9 (F.obj (X, Y))", "start": [25, 1], "end": [28, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bifunctor.map_id_comp", "code": "@[simp]\ntheorem map_id_comp (F : C \u00d7 D \u2964 E) (W : C) {X Y Z : D} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    F.map ((\ud835\udfd9 W, f \u226b g) : (W, X) \u27f6 (W, Z)) =\n      F.map ((\ud835\udfd9 W, f) : (W, X) \u27f6 (W, Y)) \u226b F.map ((\ud835\udfd9 W, g) : (W, Y) \u27f6 (W, Z))", "start": [31, 1], "end": [35, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bifunctor.map_comp_id", "code": "@[simp]\ntheorem map_comp_id (F : C \u00d7 D \u2964 E) (X Y Z : C) (W : D) (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    F.map ((f \u226b g, \ud835\udfd9 W) : (X, W) \u27f6 (Z, W)) =\n      F.map ((f, \ud835\udfd9 W) : (X, W) \u27f6 (Y, W)) \u226b F.map ((g, \ud835\udfd9 W) : (Y, W) \u27f6 (Z, W))", "start": [38, 1], "end": [42, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bifunctor.diagonal", "code": "@[simp]\ntheorem diagonal (F : C \u00d7 D \u2964 E) (X X' : C) (f : X \u27f6 X') (Y Y' : D) (g : Y \u27f6 Y') :\n    F.map ((\ud835\udfd9 X, g) : (X, Y) \u27f6 (X, Y')) \u226b F.map ((f, \ud835\udfd9 Y') : (X, Y') \u27f6 (X', Y')) =\n      F.map ((f, g) : (X, Y) \u27f6 (X', Y'))", "start": [45, 1], "end": [49, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bifunctor.diagonal'", "code": "@[simp]\ntheorem diagonal' (F : C \u00d7 D \u2964 E) (X X' : C) (f : X \u27f6 X') (Y Y' : D) (g : Y \u27f6 Y') :\n    F.map ((f, \ud835\udfd9 Y) : (X, Y) \u27f6 (X', Y)) \u226b F.map ((\ud835\udfd9 X', g) : (X', Y) \u27f6 (X', Y')) =\n      F.map ((f, g) : (X, Y) \u27f6 (X', Y'))", "start": [52, 1], "end": [56, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "imports": ["Mathlib/CategoryTheory/Balanced.lean", "Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.StrongEpi", "code": "class StrongEpi (f : P \u27f6 Q) : Prop where\n  \n  epi : Epi f\n  \n  llp : \u2200 \u2983X Y : C\u2984 (z : X \u27f6 Y) [Mono z], HasLiftingProperty f z", "start": [47, 1], "end": [53, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongEpi.mk'", "code": "theorem StrongEpi.mk' {f : P \u27f6 Q} [Epi f]\n    (hf : \u2200 (X Y : C) (z : X \u27f6 Y)\n      (_ : Mono z) (u : P \u27f6 X) (v : Q \u27f6 Y) (sq : CommSq u f z v), sq.HasLift) :\n    StrongEpi f", "start": [58, 1], "end": [63, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongMono", "code": "class StrongMono (f : P \u27f6 Q) : Prop where\n  \n  mono : Mono f\n  \n  rlp : \u2200 \u2983X Y : C\u2984 (z : X \u27f6 Y) [Epi z], HasLiftingProperty z f", "start": [66, 1], "end": [72, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongMono.mk'", "code": "theorem StrongMono.mk' {f : P \u27f6 Q} [Mono f]\n    (hf : \u2200 (X Y : C) (z : X \u27f6 Y) (_ : Epi z) (u : X \u27f6 P)\n      (v : Y \u27f6 Q) (sq : CommSq u z f v), sq.HasLift) : StrongMono f where", "start": [75, 1], "end": [79, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.epi_of_strongEpi", "code": "instance (priority := 100) epi_of_strongEpi (f : P \u27f6 Q) [StrongEpi f] : Epi f :=\n  StrongEpi.epi", "start": [86, 1], "end": [87, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_of_strongMono", "code": "instance (priority := 100) mono_of_strongMono (f : P \u27f6 Q) [StrongMono f] : Mono f :=\n  StrongMono.mono", "start": [90, 1], "end": [91, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpi_comp", "code": "theorem strongEpi_comp [StrongEpi f] [StrongEpi g] : StrongEpi (f \u226b g)", "start": [98, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMono_comp", "code": "theorem strongMono_comp [StrongMono f] [StrongMono g] : StrongMono (f \u226b g)", "start": [106, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpi_of_strongEpi", "code": "theorem strongEpi_of_strongEpi [StrongEpi (f \u226b g)] : StrongEpi g", "start": [114, 1], "end": [124, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMono_of_strongMono", "code": "theorem strongMono_of_strongMono [StrongMono (f \u226b g)] : StrongMono f", "start": [127, 1], "end": [136, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpi_of_isIso", "code": "instance (priority := 100) strongEpi_of_isIso [IsIso f] : StrongEpi f where\n  epi := by infer_instance\n  llp {X Y} z := HasLiftingProperty.of_left_iso _ _", "start": [139, 1], "end": [142, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMono_of_isIso", "code": "instance (priority := 100) strongMono_of_isIso [IsIso f] : StrongMono f where\n  mono := by infer_instance\n  rlp {X Y} z := HasLiftingProperty.of_right_iso _ _", "start": [145, 1], "end": [148, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongEpi.of_arrow_iso", "code": "theorem StrongEpi.of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) [h : StrongEpi f] : StrongEpi g", "start": [151, 1], "end": [159, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongMono.of_arrow_iso", "code": "theorem StrongMono.of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) [h : StrongMono f] : StrongMono g", "start": [162, 1], "end": [170, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongEpi.iff_of_arrow_iso", "code": "theorem StrongEpi.iff_of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) : StrongEpi f \u2194 StrongEpi g", "start": [173, 1], "end": [176, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongMono.iff_of_arrow_iso", "code": "theorem StrongMono.iff_of_arrow_iso {A B A' B' : C} {f : A \u27f6 B} {g : A' \u27f6 B'}\n    (e : Arrow.mk f \u2245 Arrow.mk g) : StrongMono f \u2194 StrongMono g", "start": [179, 1], "end": [182, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_mono_of_strongEpi", "code": "theorem isIso_of_mono_of_strongEpi (f : P \u27f6 Q) [Mono f] [StrongEpi f] : IsIso f", "start": [187, 1], "end": [189, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_epi_of_strongMono", "code": "theorem isIso_of_epi_of_strongMono (f : P \u27f6 Q) [Epi f] [StrongMono f] : IsIso f", "start": [192, 1], "end": [194, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongEpiCategory", "code": "class StrongEpiCategory : Prop where\n  \n  strongEpi_of_epi : \u2200 {X Y : C} (f : X \u27f6 Y) [Epi f], StrongEpi f", "start": [201, 1], "end": [204, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrongMonoCategory", "code": "class StrongMonoCategory : Prop where\n  \n  strongMono_of_mono : \u2200 {X Y : C} (f : X \u27f6 Y) [Mono f], StrongMono f", "start": [208, 1], "end": [211, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongEpi_of_epi", "code": "theorem strongEpi_of_epi [StrongEpiCategory C] (f : P \u27f6 Q) [Epi f] : StrongEpi f", "start": [217, 1], "end": [218, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strongMono_of_mono", "code": "theorem strongMono_of_mono [StrongMonoCategory C] (f : P \u27f6 Q) [Mono f] : StrongMono f", "start": [221, 1], "end": [222, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.balanced_of_strongEpiCategory", "code": "instance (priority := 100) balanced_of_strongEpiCategory [StrongEpiCategory C] : Balanced C where\n  isIso_of_mono_of_epi _ _ _ := isIso_of_mono_of_strongEpi _", "start": [229, 1], "end": [230, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.balanced_of_strongMonoCategory", "code": "instance (priority := 100) balanced_of_strongMonoCategory [StrongMonoCategory C] : Balanced C where\n  isIso_of_mono_of_epi _ _ _ := isIso_of_epi_of_strongMono _", "start": [239, 1], "end": [240, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/LiftingProperties/Adjunction.lean", "imports": ["Mathlib/CategoryTheory/LiftingProperties/Basic.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.CommSq.right_adjoint", "code": "theorem right_adjoint : CommSq (adj.homEquiv _ _ u) i (F.map p) (adj.homEquiv _ _ v)", "start": [37, 1], "end": [43, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.rightAdjointLiftStructEquiv", "code": "def rightAdjointLiftStructEquiv : sq.LiftStruct \u2243 (sq.right_adjoint adj).LiftStruct\n    where\n  toFun l :=\n    { l := adj.homEquiv _ _ l.l\n      fac_left := by rw [\u2190 adj.homEquiv_naturality_left, l.fac_left]\n      fac_right := by rw [\u2190 Adjunction.homEquiv_naturality_right, l.fac_right] }\n  invFun l :=\n    { l := (adj.homEquiv _ _).symm l.l\n      fac_left := by\n        rw [\u2190 Adjunction.homEquiv_naturality_left_symm, l.fac_left]\n        apply (adj.homEquiv _ _).left_inv\n      fac_right := by\n        rw [\u2190 Adjunction.homEquiv_naturality_right_symm, l.fac_right]\n        apply (adj.homEquiv _ _).left_inv }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [46, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.right_adjoint_hasLift_iff", "code": "theorem right_adjoint_hasLift_iff : HasLift (sq.right_adjoint adj) \u2194 HasLift sq", "start": [66, 1], "end": [69, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.left_adjoint", "code": "theorem left_adjoint : CommSq ((adj.homEquiv _ _).symm u) (G.map i) p ((adj.homEquiv _ _).symm v)", "start": [83, 1], "end": [89, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.leftAdjointLiftStructEquiv", "code": "def leftAdjointLiftStructEquiv : sq.LiftStruct \u2243 (sq.left_adjoint adj).LiftStruct\n    where\n  toFun l :=\n    { l := (adj.homEquiv _ _).symm l.l\n      fac_left := by rw [\u2190 adj.homEquiv_naturality_left_symm, l.fac_left]\n      fac_right := by rw [\u2190 adj.homEquiv_naturality_right_symm, l.fac_right] }\n  invFun l :=\n    { l := (adj.homEquiv _ _) l.l\n      fac_left := by\n        rw [\u2190 adj.homEquiv_naturality_left, l.fac_left]\n        apply (adj.homEquiv _ _).right_inv\n      fac_right := by\n        rw [\u2190 adj.homEquiv_naturality_right, l.fac_right]\n        apply (adj.homEquiv _ _).right_inv }\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [92, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CommSq.left_adjoint_hasLift_iff", "code": "theorem left_adjoint_hasLift_iff : HasLift (sq.left_adjoint adj) \u2194 HasLift sq", "start": [112, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.hasLiftingProperty_iff", "code": "theorem hasLiftingProperty_iff (adj : G \u22a3 F) {A B : C} {X Y : D} (i : A \u27f6 B) (p : X \u27f6 Y) :\n    HasLiftingProperty (G.map i) p \u2194 HasLiftingProperty i (F.map p)", "start": [128, 1], "end": [134, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Composition.lean", "imports": ["Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Composition", "code": "@[ext]\nstructure Composition (n : \u2115) where\n  \n  blocks : List \u2115\n  \n  blocks_pos : \u2200 {i}, i \u2208 blocks \u2192 0 < i\n  \n  blocks_sum : blocks.sum = n", "start": [98, 1], "end": [106, 30], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet", "code": "@[ext]\nstructure CompositionAsSet (n : \u2115) where\n  \n  boundaries : Finset (Fin n.succ)\n  \n  zero_mem : (0 : Fin n.succ) \u2208 boundaries\n  \n  getLast_mem : Fin.last n \u2208 boundaries", "start": [109, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "Composition.length", "code": "@[reducible]\ndef length : \u2115 :=\n  c.blocks.length", "start": [142, 1], "end": [145, 18], "kind": "commanddeclaration"}, {"full_name": "Composition.blocks_length", "code": "theorem blocks_length : c.blocks.length = c.length", "start": [148, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.blocksFun", "code": "def blocksFun : Fin c.length \u2192 \u2115 := fun i => nthLe c.blocks i i.2", "start": [154, 1], "end": [156, 66], "kind": "commanddeclaration"}, {"full_name": "Composition.ofFn_blocksFun", "code": "theorem ofFn_blocksFun : ofFn c.blocksFun = c.blocks", "start": [161, 1], "end": [162, 15], "kind": "commanddeclaration"}, {"full_name": "Composition.sum_blocksFun", "code": "theorem sum_blocksFun : \u2211 i, c.blocksFun i = n", "start": [165, 1], "end": [166, 62], "kind": "commanddeclaration"}, {"full_name": "Composition.blocksFun_mem_blocks", "code": "theorem blocksFun_mem_blocks (i : Fin c.length) : c.blocksFun i \u2208 c.blocks", "start": [171, 1], "end": [172, 18], "kind": "commanddeclaration"}, {"full_name": "Composition.one_le_blocks", "code": "@[simp]\ntheorem one_le_blocks {i : \u2115} (h : i \u2208 c.blocks) : 1 \u2264 i", "start": [175, 1], "end": [177, 17], "kind": "commanddeclaration"}, {"full_name": "Composition.one_le_blocks'", "code": "@[simp]\ntheorem one_le_blocks' {i : \u2115} (h : i < c.length) : 1 \u2264 nthLe c.blocks i h", "start": [182, 1], "end": [184, 45], "kind": "commanddeclaration"}, {"full_name": "Composition.blocks_pos'", "code": "@[simp]\ntheorem blocks_pos' (i : \u2115) (h : i < c.length) : 0 < nthLe c.blocks i h", "start": [189, 1], "end": [191, 21], "kind": "commanddeclaration"}, {"full_name": "Composition.one_le_blocksFun", "code": "theorem one_le_blocksFun (i : Fin c.length) : 1 \u2264 c.blocksFun i", "start": [194, 1], "end": [195, 45], "kind": "commanddeclaration"}, {"full_name": "Composition.length_le", "code": "theorem length_le : c.length \u2264 n", "start": [198, 1], "end": [200, 65], "kind": "commanddeclaration"}, {"full_name": "Composition.length_pos_of_pos", "code": "theorem length_pos_of_pos (h : 0 < n) : 0 < c.length", "start": [203, 1], "end": [206, 21], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo", "code": "def sizeUpTo (i : \u2115) : \u2115 :=\n  (c.blocks.take i).sum", "start": [209, 1], "end": [211, 24], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_zero", "code": "@[simp]\ntheorem sizeUpTo_zero : c.sizeUpTo 0 = 0", "start": [214, 1], "end": [215, 63], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_ofLength_le", "code": "theorem sizeUpTo_ofLength_le (i : \u2115) (h : c.length \u2264 i) : c.sizeUpTo i = n", "start": [218, 1], "end": [221, 25], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_length", "code": "@[simp]\ntheorem sizeUpTo_length : c.sizeUpTo c.length = n", "start": [224, 1], "end": [226, 41], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_le", "code": "theorem sizeUpTo_le (i : \u2115) : c.sizeUpTo i \u2264 n", "start": [229, 1], "end": [231, 29], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_succ", "code": "theorem sizeUpTo_succ {i : \u2115} (h : i < c.length) :\n    c.sizeUpTo (i + 1) = c.sizeUpTo i + c.blocks.nthLe i h", "start": [234, 1], "end": [237, 27], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_succ'", "code": "theorem sizeUpTo_succ' (i : Fin c.length) :\n    c.sizeUpTo ((i : \u2115) + 1) = c.sizeUpTo i + c.blocksFun i", "start": [240, 1], "end": [242, 22], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_strict_mono", "code": "theorem sizeUpTo_strict_mono {i : \u2115} (h : i < c.length) : c.sizeUpTo i < c.sizeUpTo (i + 1)", "start": [245, 1], "end": [247, 7], "kind": "commanddeclaration"}, {"full_name": "Composition.monotone_sizeUpTo", "code": "theorem monotone_sizeUpTo : Monotone c.sizeUpTo", "start": [250, 1], "end": [251, 22], "kind": "commanddeclaration"}, {"full_name": "Composition.boundary", "code": "def boundary : Fin (c.length + 1) \u21aao Fin (n + 1) :=\n  (OrderEmbedding.ofStrictMono fun i => \u27e8c.sizeUpTo i, Nat.lt_succ_of_le (c.sizeUpTo_le i)\u27e9) <|\n    Fin.strictMono_iff_lt_succ.2 fun \u27e8_, hi\u27e9 => c.sizeUpTo_strict_mono hi", "start": [254, 1], "end": [259, 74], "kind": "commanddeclaration"}, {"full_name": "Composition.boundary_zero", "code": "@[simp]\ntheorem boundary_zero : c.boundary 0 = 0", "start": [262, 1], "end": [263, 76], "kind": "commanddeclaration"}, {"full_name": "Composition.boundary_last", "code": "@[simp]\ntheorem boundary_last : c.boundary (Fin.last c.length) = Fin.last n", "start": [266, 1], "end": [268, 31], "kind": "commanddeclaration"}, {"full_name": "Composition.boundaries", "code": "def boundaries : Finset (Fin (n + 1)) :=\n  Finset.univ.map c.boundary.toEmbedding", "start": [271, 1], "end": [275, 41], "kind": "commanddeclaration"}, {"full_name": "Composition.card_boundaries_eq_succ_length", "code": "theorem card_boundaries_eq_succ_length : c.boundaries.card = c.length + 1", "start": [278, 1], "end": [278, 98], "kind": "commanddeclaration"}, {"full_name": "Composition.toCompositionAsSet", "code": "def toCompositionAsSet : CompositionAsSet n\n    where\n  boundaries := c.boundaries\n  zero_mem := by\n    simp only [boundaries, Finset.mem_univ, exists_prop_of_true, Finset.mem_map]\n    exact \u27e80, And.intro True.intro rfl\u27e9\n  getLast_mem := by\n    simp only [boundaries, Finset.mem_univ, exists_prop_of_true, Finset.mem_map]\n    exact \u27e8Fin.last c.length, And.intro True.intro c.boundary_last\u27e9", "start": [281, 1], "end": [291, 68], "kind": "commanddeclaration"}, {"full_name": "Composition.orderEmbOfFin_boundaries", "code": "theorem orderEmbOfFin_boundaries :\n    c.boundaries.orderEmbOfFin c.card_boundaries_eq_succ_length = c.boundary", "start": [294, 1], "end": [299, 59], "kind": "commanddeclaration"}, {"full_name": "Composition.embedding", "code": "def embedding (i : Fin c.length) : Fin (c.blocksFun i) \u21aao Fin n :=\n  (Fin.natAddEmb <| c.sizeUpTo i).trans <|\n    Fin.castLEEmb <|\n      calc\n        c.sizeUpTo i + c.blocksFun i = c.sizeUpTo (i + 1) := (c.sizeUpTo_succ _).symm\n        _ \u2264 c.sizeUpTo c.length := monotone_sum_take _ i.2\n        _ = n := c.sizeUpTo_length", "start": [302, 1], "end": [310, 35], "kind": "commanddeclaration"}, {"full_name": "Composition.coe_embedding", "code": "@[simp]\ntheorem coe_embedding (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    (c.embedding i j : \u2115) = c.sizeUpTo i + j", "start": [313, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.index_exists", "code": "theorem index_exists {j : \u2115} (h : j < n) : \u2203 i : \u2115, j < c.sizeUpTo i.succ \u2227 i < c.length", "start": [319, 1], "end": [328, 17], "kind": "commanddeclaration"}, {"full_name": "Composition.index", "code": "def index (j : Fin n) : Fin c.length :=\n  \u27e8Nat.find (c.index_exists j.2), (Nat.find_spec (c.index_exists j.2)).2\u27e9", "start": [331, 1], "end": [333, 74], "kind": "commanddeclaration"}, {"full_name": "Composition.lt_sizeUpTo_index_succ", "code": "theorem lt_sizeUpTo_index_succ (j : Fin n) : (j : \u2115) < c.sizeUpTo (c.index j).succ", "start": [336, 1], "end": [337, 41], "kind": "commanddeclaration"}, {"full_name": "Composition.sizeUpTo_index_le", "code": "theorem sizeUpTo_index_le (j : Fin n) : c.sizeUpTo (c.index j) \u2264 j", "start": [340, 1], "end": [353, 34], "kind": "commanddeclaration"}, {"full_name": "Composition.invEmbedding", "code": "def invEmbedding (j : Fin n) : Fin (c.blocksFun (c.index j)) :=\n  \u27e8j - c.sizeUpTo (c.index j), by\n    rw [tsub_lt_iff_right, add_comm, \u2190 sizeUpTo_succ']\n    \u00b7 exact lt_sizeUpTo_index_succ _ _\n    \u00b7 exact sizeUpTo_index_le _ _\u27e9", "start": [356, 1], "end": [362, 35], "kind": "commanddeclaration"}, {"full_name": "Composition.coe_invEmbedding", "code": "@[simp]\ntheorem coe_invEmbedding (j : Fin n) : (c.invEmbedding j : \u2115) = j - c.sizeUpTo (c.index j)", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.embedding_comp_inv", "code": "theorem embedding_comp_inv (j : Fin n) : c.embedding (c.index j) (c.invEmbedding j) = j", "start": [370, 1], "end": [372, 54], "kind": "commanddeclaration"}, {"full_name": "Composition.mem_range_embedding_iff", "code": "theorem mem_range_embedding_iff {j : Fin n} {i : Fin c.length} :\n    j \u2208 Set.range (c.embedding i) \u2194 c.sizeUpTo i \u2264 j \u2227 (j : \u2115) < c.sizeUpTo (i : \u2115).succ", "start": [375, 1], "end": [391, 38], "kind": "commanddeclaration"}, {"full_name": "Composition.disjoint_range", "code": "theorem disjoint_range {i\u2081 i\u2082 : Fin c.length} (h : i\u2081 \u2260 i\u2082) :\n    Disjoint (Set.range (c.embedding i\u2081)) (Set.range (c.embedding i\u2082))", "start": [394, 1], "end": [409, 51], "kind": "commanddeclaration"}, {"full_name": "Composition.mem_range_embedding", "code": "theorem mem_range_embedding (j : Fin n) : j \u2208 Set.range (c.embedding (c.index j))", "start": [412, 1], "end": [417, 13], "kind": "commanddeclaration"}, {"full_name": "Composition.mem_range_embedding_iff'", "code": "theorem mem_range_embedding_iff' {j : Fin n} {i : Fin c.length} :\n    j \u2208 Set.range (c.embedding i) \u2194 i = c.index j", "start": [420, 1], "end": [428, 34], "kind": "commanddeclaration"}, {"full_name": "Composition.index_embedding", "code": "theorem index_embedding (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    c.index (c.embedding i j) = i", "start": [431, 1], "end": [435, 27], "kind": "commanddeclaration"}, {"full_name": "Composition.invEmbedding_comp", "code": "theorem invEmbedding_comp (i : Fin c.length) (j : Fin (c.blocksFun i)) :\n    (c.invEmbedding (c.embedding i j) : \u2115) = j", "start": [438, 1], "end": [440, 83], "kind": "commanddeclaration"}, {"full_name": "Composition.blocksFinEquiv", "code": "def blocksFinEquiv : (\u03a3i : Fin c.length, Fin (c.blocksFun i)) \u2243 Fin n\n    where\n  toFun x := c.embedding x.1 x.2\n  invFun j := \u27e8c.index j, c.invEmbedding j\u27e9\n  left_inv x := by\n    rcases x with \u27e8i, y\u27e9\n    dsimp\n    congr; \u00b7 exact c.index_embedding _ _\n    rw [Fin.heq_ext_iff]\n    \u00b7 exact c.invEmbedding_comp _ _\n    \u00b7 rw [c.index_embedding]\n  right_inv j := c.embedding_comp_inv j", "start": [443, 1], "end": [456, 40], "kind": "commanddeclaration"}, {"full_name": "Composition.blocksFun_congr", "code": "theorem blocksFun_congr {n\u2081 n\u2082 : \u2115} (c\u2081 : Composition n\u2081) (c\u2082 : Composition n\u2082) (i\u2081 : Fin c\u2081.length)\n    (i\u2082 : Fin c\u2082.length) (hn : n\u2081 = n\u2082) (hc : c\u2081.blocks = c\u2082.blocks) (hi : (i\u2081 : \u2115) = i\u2082) :\n    c\u2081.blocksFun i\u2081 = c\u2082.blocksFun i\u2082", "start": [459, 1], "end": [466, 20], "kind": "commanddeclaration"}, {"full_name": "Composition.sigma_eq_iff_blocks_eq", "code": "theorem sigma_eq_iff_blocks_eq {c : \u03a3n, Composition n} {c' : \u03a3n, Composition n} :\n    c = c' \u2194 c.2.blocks = c'.2.blocks", "start": [469, 1], "end": [480, 10], "kind": "commanddeclaration"}, {"full_name": "Composition.ones", "code": "def ones (n : \u2115) : Composition n :=\n  \u27e8replicate n (1 : \u2115), fun {i} hi => by simp [List.eq_of_mem_replicate hi], by simp\u27e9", "start": [486, 1], "end": [488, 86], "kind": "commanddeclaration"}, {"full_name": "Composition.ones_length", "code": "@[simp]\ntheorem ones_length (n : \u2115) : (ones n).length = n", "start": [494, 1], "end": [496, 28], "kind": "commanddeclaration"}, {"full_name": "Composition.ones_blocks", "code": "@[simp]\ntheorem ones_blocks (n : \u2115) : (ones n).blocks = replicate n (1 : \u2115)", "start": [499, 1], "end": [501, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.ones_blocksFun", "code": "@[simp]\ntheorem ones_blocksFun (n : \u2115) (i : Fin (ones n).length) : (ones n).blocksFun i = 1", "start": [506, 1], "end": [508, 65], "kind": "commanddeclaration"}, {"full_name": "Composition.ones_sizeUpTo", "code": "@[simp]\ntheorem ones_sizeUpTo (n : \u2115) (i : \u2115) : (ones n).sizeUpTo i = min i n", "start": [511, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "Composition.ones_embedding", "code": "@[simp]\ntheorem ones_embedding (i : Fin (ones n).length) (h : 0 < (ones n).blocksFun i) :\n    (ones n).embedding i \u27e80, h\u27e9 = \u27e8i, lt_of_lt_of_le i.2 (ones n).length_le\u27e9", "start": [516, 1], "end": [520, 21], "kind": "commanddeclaration"}, {"full_name": "Composition.eq_ones_iff", "code": "theorem eq_ones_iff {c : Composition n} : c = ones n \u2194 \u2200 i \u2208 c.blocks, i = 1", "start": [523, 1], "end": [533, 30], "kind": "commanddeclaration"}, {"full_name": "Composition.ne_ones_iff", "code": "theorem ne_ones_iff {c : Composition n} : c \u2260 ones n \u2194 \u2203 i \u2208 c.blocks, 1 < i", "start": [536, 1], "end": [539, 49], "kind": "commanddeclaration"}, {"full_name": "Composition.eq_ones_iff_length", "code": "theorem eq_ones_iff_length {c : Composition n} : c = ones n \u2194 c.length = n", "start": [542, 1], "end": [559, 31], "kind": "commanddeclaration"}, {"full_name": "Composition.eq_ones_iff_le_length", "code": "theorem eq_ones_iff_le_length {c : Composition n} : c = ones n \u2194 n \u2264 c.length", "start": [562, 1], "end": [563, 58], "kind": "commanddeclaration"}, {"full_name": "Composition.single", "code": "def single (n : \u2115) (h : 0 < n) : Composition n :=\n  \u27e8[n], by simp [h], by simp\u27e9", "start": [568, 1], "end": [570, 30], "kind": "commanddeclaration"}, {"full_name": "Composition.single_length", "code": "@[simp]\ntheorem single_length {n : \u2115} (h : 0 < n) : (single n h).length = 1", "start": [573, 1], "end": [575, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.single_blocks", "code": "@[simp]\ntheorem single_blocks {n : \u2115} (h : 0 < n) : (single n h).blocks = [n]", "start": [578, 1], "end": [580, 6], "kind": "commanddeclaration"}, {"full_name": "Composition.single_blocksFun", "code": "@[simp]\ntheorem single_blocksFun {n : \u2115} (h : 0 < n) (i : Fin (single n h).length) :\n    (single n h).blocksFun i = n", "start": [583, 1], "end": [585, 77], "kind": "commanddeclaration"}, {"full_name": "Composition.single_embedding", "code": "@[simp]\ntheorem single_embedding {n : \u2115} (h : 0 < n) (i : Fin n) :\n    ((single n h).embedding (0 : Fin 1)) i = i", "start": [588, 1], "end": [592, 7], "kind": "commanddeclaration"}, {"full_name": "Composition.eq_single_iff_length", "code": "theorem eq_single_iff_length {n : \u2115} (h : 0 < n) {c : Composition n} :\n    c = single n h \u2194 c.length = 1", "start": [595, 1], "end": [606, 34], "kind": "commanddeclaration"}, {"full_name": "Composition.ne_single_iff", "code": "theorem ne_single_iff {n : \u2115} (hn : 0 < n) {c : Composition n} :\n    c \u2260 single n hn \u2194 \u2200 i, c.blocksFun i < n", "start": [609, 1], "end": [628, 54], "kind": "commanddeclaration"}, {"full_name": "List.splitWrtCompositionAux", "code": "def splitWrtCompositionAux : List \u03b1 \u2192 List \u2115 \u2192 List (List \u03b1)\n  | _, [] => []\n  | l, n::ns =>\n    let (l\u2081, l\u2082) := l.splitAt n\n    l\u2081::splitWrtCompositionAux l\u2082 ns", "start": [648, 1], "end": [653, 37], "kind": "commanddeclaration"}, {"full_name": "List.splitWrtComposition", "code": "def splitWrtComposition (l : List \u03b1) (c : Composition n) : List (List \u03b1) :=\n  splitWrtCompositionAux l c.blocks", "start": [656, 1], "end": [660, 36], "kind": "commanddeclaration"}, {"full_name": "List.splitWrtCompositionAux_cons", "code": "@[local simp]\ntheorem splitWrtCompositionAux_cons (l : List \u03b1) (n ns) :\n    l.splitWrtCompositionAux (n::ns) = take n l::(drop n l).splitWrtCompositionAux ns", "start": [668, 1], "end": [671, 32], "kind": "commanddeclaration"}, {"full_name": "List.length_splitWrtCompositionAux", "code": "theorem length_splitWrtCompositionAux (l : List \u03b1) (ns) :\n    length (l.splitWrtCompositionAux ns) = ns.length", "start": [674, 1], "end": [678, 15], "kind": "commanddeclaration"}, {"full_name": "List.length_splitWrtComposition", "code": "@[simp]\ntheorem length_splitWrtComposition (l : List \u03b1) (c : Composition n) :\n    length (l.splitWrtComposition c) = c.length", "start": [681, 1], "end": [686, 36], "kind": "commanddeclaration"}, {"full_name": "List.map_length_splitWrtCompositionAux", "code": "theorem map_length_splitWrtCompositionAux {ns : List \u2115} :\n    \u2200 {l : List \u03b1}, ns.sum \u2264 l.length \u2192 map length (l.splitWrtCompositionAux ns) = ns", "start": [690, 1], "end": [698, 35], "kind": "commanddeclaration"}, {"full_name": "List.map_length_splitWrtComposition", "code": "theorem map_length_splitWrtComposition (l : List \u03b1) (c : Composition l.length) :\n    map length (l.splitWrtComposition c) = c.blocks", "start": [701, 1], "end": [705, 60], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_of_mem_splitWrtComposition", "code": "theorem length_pos_of_mem_splitWrtComposition {l l' : List \u03b1} {c : Composition l.length}\n    (h : l' \u2208 l.splitWrtComposition c) : 0 < length l'", "start": [708, 1], "end": [713, 26], "kind": "commanddeclaration"}, {"full_name": "List.sum_take_map_length_splitWrtComposition", "code": "theorem sum_take_map_length_splitWrtComposition (l : List \u03b1) (c : Composition l.length) (i : \u2115) :\n    (((l.splitWrtComposition c).map length).take i).sum = c.sizeUpTo i", "start": [716, 1], "end": [719, 43], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_splitWrtCompositionAux", "code": "theorem nthLe_splitWrtCompositionAux (l : List \u03b1) (ns : List \u2115) {i : \u2115} (hi) :\n    nthLe (l.splitWrtCompositionAux ns) i hi =\n      (l.take (ns.take (i + 1)).sum).drop (ns.take i).sum", "start": [724, 1], "end": [736, 18], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_splitWrtComposition", "code": "theorem nthLe_splitWrtComposition (l : List \u03b1) (c : Composition n) {i : \u2115}\n    (hi : i < (l.splitWrtComposition c).length) :\n    nthLe (l.splitWrtComposition c) i hi = (l.take (c.sizeUpTo (i + 1))).drop (c.sizeUpTo i)", "start": [741, 1], "end": [747, 37], "kind": "commanddeclaration"}, {"full_name": "List.get_splitWrtComposition", "code": "theorem get_splitWrtComposition (l : List \u03b1) (c : Composition n)\n    (i : Fin (l.splitWrtComposition c).length) :\n    get (l.splitWrtComposition c) i = (l.take (c.sizeUpTo (i + 1))).drop (c.sizeUpTo i)", "start": [751, 1], "end": [754, 34], "kind": "commanddeclaration"}, {"full_name": "List.join_splitWrtCompositionAux", "code": "theorem join_splitWrtCompositionAux {ns : List \u2115} :\n    \u2200 {l : List \u03b1}, ns.sum = l.length \u2192 (l.splitWrtCompositionAux ns).join = l", "start": [756, 1], "end": [763, 48], "kind": "commanddeclaration"}, {"full_name": "List.join_splitWrtComposition", "code": "@[simp]\ntheorem join_splitWrtComposition (l : List \u03b1) (c : Composition l.length) :\n    (l.splitWrtComposition c).join = l", "start": [766, 1], "end": [771, 43], "kind": "commanddeclaration"}, {"full_name": "List.splitWrtComposition_join", "code": "@[simp]\ntheorem splitWrtComposition_join (L : List (List \u03b1)) (c : Composition L.join.length)\n    (h : map length L = c.blocks) : splitWrtComposition (join L) c = L", "start": [774, 1], "end": [780, 39], "kind": "commanddeclaration"}, {"full_name": "compositionAsSetEquiv", "code": "def compositionAsSetEquiv (n : \u2115) : CompositionAsSet n \u2243 Finset (Fin (n - 1))\n    where\n  toFun c :=\n    { i : Fin (n - 1) |\n        (\u27e81 + (i : \u2115), by\n              apply (add_lt_add_left i.is_lt 1).trans_le\n              rw [Nat.succ_eq_add_one, add_comm]\n              exact add_le_add (Nat.sub_le n 1) (le_refl 1)\u27e9 :\n            Fin n.succ) \u2208\n          c.boundaries }.toFinset\n  invFun s :=\n    { boundaries :=\n        { i : Fin n.succ |\n            i = 0 \u2228 i = Fin.last n \u2228 \u2203 (j : Fin (n - 1)) (_hj : j \u2208 s), (i : \u2115) = j + 1 }.toFinset\n      zero_mem := by simp\n      getLast_mem := by simp }\n  left_inv := by\n    intro c\n    ext i\n    simp only [add_comm, Set.toFinset_setOf, Finset.mem_univ,\n     forall_true_left, Finset.mem_filter, true_and, exists_prop]\n    constructor\n    \u00b7 rintro (rfl | rfl | \u27e8j, hj1, hj2\u27e9)\n      \u00b7 exact c.zero_mem\n      \u00b7 exact c.getLast_mem\n      \u00b7 convert hj1\n    \u00b7 simp only [or_iff_not_imp_left]\n      intro i_mem i_ne_zero i_ne_last\n      simp [Fin.ext_iff] at i_ne_zero i_ne_last\n      have A : (1 + (i - 1) : \u2115) = (i : \u2115) := by\n        rw [add_comm]\n        exact Nat.succ_pred_eq_of_pos (pos_iff_ne_zero.mpr i_ne_zero)\n      refine' \u27e8\u27e8i - 1, _\u27e9, _, _\u27e9\n      \u00b7 have : (i : \u2115) < n + 1 := i.2\n        simp [Nat.lt_succ_iff_lt_or_eq, i_ne_last] at this\n        exact Nat.pred_lt_pred i_ne_zero this\n      \u00b7 convert i_mem\n        simp only [ge_iff_le]\n        rwa [add_comm]\n      \u00b7 simp only [ge_iff_le]\n        symm\n        rwa [add_comm]\n  right_inv := by\n    intro s\n    ext i\n    have : 1 + (i : \u2115) \u2260 n := by\n      apply ne_of_lt\n      convert add_lt_add_left i.is_lt 1\n      rw [add_comm]\n      apply (Nat.succ_pred_eq_of_pos _).symm\n      exact (zero_le i.val).trans_lt (i.2.trans_le (Nat.sub_le n 1))\n    simp only [add_comm, Fin.ext_iff, Fin.val_zero, Fin.val_last, exists_prop, Set.toFinset_setOf,\n      Finset.mem_univ, forall_true_left, Finset.mem_filter, add_eq_zero_iff, and_false,\n      add_left_inj, false_or, true_and]\n    erw [Set.mem_setOf_eq]\n    simp [this, false_or_iff, add_right_inj, add_eq_zero_iff, one_ne_zero, false_and_iff,\n      Fin.val_mk]\n    constructor\n    \u00b7 intro h\n      cases' h with n h\n      \u00b7 rw [add_comm] at this\n        contradiction\n      \u00b7 cases' h with w h; cases' h with h\u2081 h\u2082\n        rw [\u2190Fin.ext_iff] at h\u2082\n        rwa [h\u2082]\n    \u00b7 intro h\n      apply Or.inr\n      use i, h", "start": [793, 1], "end": [862, 15], "kind": "commanddeclaration"}, {"full_name": "compositionAsSetFintype", "code": "instance compositionAsSetFintype (n : \u2115) : Fintype (CompositionAsSet n) :=\n  Fintype.ofEquiv _ (compositionAsSetEquiv n).symm", "start": [865, 1], "end": [866, 51], "kind": "commanddeclaration"}, {"full_name": "compositionAsSet_card", "code": "theorem compositionAsSet_card (n : \u2115) : Fintype.card (CompositionAsSet n) = 2 ^ (n - 1)", "start": [869, 1], "end": [872, 53], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.boundaries_nonempty", "code": "theorem boundaries_nonempty : c.boundaries.Nonempty", "start": [879, 1], "end": [880, 18], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.card_boundaries_pos", "code": "theorem card_boundaries_pos : 0 < Finset.card c.boundaries", "start": [883, 1], "end": [884, 44], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.length", "code": "def length : \u2115 :=\n  Finset.card c.boundaries - 1", "start": [887, 1], "end": [889, 31], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.card_boundaries_eq_succ_length", "code": "theorem card_boundaries_eq_succ_length : c.boundaries.card = c.length + 1", "start": [892, 1], "end": [893, 78], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.length_lt_card_boundaries", "code": "theorem length_lt_card_boundaries : c.length < c.boundaries.card", "start": [896, 1], "end": [898, 21], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.lt_length", "code": "theorem lt_length (i : Fin c.length) : (i : \u2115) + 1 < c.boundaries.card", "start": [901, 1], "end": [902, 27], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.lt_length'", "code": "theorem lt_length' (i : Fin c.length) : (i : \u2115) < c.boundaries.card", "start": [905, 1], "end": [906, 49], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.boundary", "code": "def boundary : Fin c.boundaries.card \u21aao Fin (n + 1) :=\n  c.boundaries.orderEmbOfFin rfl", "start": [909, 1], "end": [911, 33], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.boundary_zero", "code": "@[simp]\ntheorem boundary_zero : (c.boundary \u27e80, c.card_boundaries_pos\u27e9 : Fin (n + 1)) = 0", "start": [914, 1], "end": [917, 68], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.boundary_length", "code": "@[simp]\ntheorem boundary_length : c.boundary \u27e8c.length, c.length_lt_card_boundaries\u27e9 = Fin.last n", "start": [920, 1], "end": [923, 71], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocksFun", "code": "def blocksFun (i : Fin c.length) : \u2115 :=\n  c.boundary \u27e8(i : \u2115) + 1, c.lt_length i\u27e9 - c.boundary \u27e8i, c.lt_length' i\u27e9", "start": [926, 1], "end": [928, 75], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocksFun_pos", "code": "theorem blocksFun_pos (i : Fin c.length) : 0 < c.blocksFun i", "start": [931, 1], "end": [934, 74], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocks", "code": "def blocks (c : CompositionAsSet n) : List \u2115 :=\n  ofFn c.blocksFun", "start": [937, 1], "end": [939, 19], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocks_length", "code": "@[simp]\ntheorem blocks_length : c.blocks.length = c.length", "start": [942, 1], "end": [944, 16], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocks_partial_sum", "code": "theorem blocks_partial_sum {i : \u2115} (h : i < c.boundaries.card) :\n    (c.blocks.take i).sum = c.boundary \u27e8i, h\u27e9", "start": [949, 1], "end": [960, 7], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.mem_boundaries_iff_exists_blocks_sum_take_eq", "code": "theorem mem_boundaries_iff_exists_blocks_sum_take_eq {j : Fin (n + 1)} :\n    j \u2208 c.boundaries \u2194 \u2203 i < c.boundaries.card, (c.blocks.take i).sum = j", "start": [963, 1], "end": [976, 20], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.blocks_sum", "code": "theorem blocks_sum : c.blocks.sum = n", "start": [979, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.toComposition", "code": "def toComposition : Composition n where\n  blocks := c.blocks\n  blocks_pos := by simp only [blocks, forall_mem_ofFn_iff, blocksFun_pos c, forall_true_iff]\n  blocks_sum := c.blocks_sum", "start": [985, 1], "end": [990, 29], "kind": "commanddeclaration"}, {"full_name": "Composition.toCompositionAsSet_length", "code": "@[simp]\ntheorem Composition.toCompositionAsSet_length (c : Composition n) :\n    c.toCompositionAsSet.length = c.length", "start": [1004, 1], "end": [1007, 99], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.toComposition_length", "code": "@[simp]\ntheorem CompositionAsSet.toComposition_length (c : CompositionAsSet n) :\n    c.toComposition.length = c.length", "start": [1010, 1], "end": [1013, 80], "kind": "commanddeclaration"}, {"full_name": "Composition.toCompositionAsSet_blocks", "code": "@[simp]\ntheorem Composition.toCompositionAsSet_blocks (c : Composition n) :\n    c.toCompositionAsSet.blocks = c.blocks", "start": [1016, 1], "end": [1039, 32], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.toComposition_blocks", "code": "@[simp]\ntheorem CompositionAsSet.toComposition_blocks (c : CompositionAsSet n) :\n    c.toComposition.blocks = c.blocks", "start": [1042, 1], "end": [1045, 6], "kind": "commanddeclaration"}, {"full_name": "CompositionAsSet.toComposition_boundaries", "code": "@[simp]\ntheorem CompositionAsSet.toComposition_boundaries (c : CompositionAsSet n) :\n    c.toComposition.boundaries = c.boundaries", "start": [1048, 1], "end": [1061, 81], "kind": "commanddeclaration"}, {"full_name": "Composition.toCompositionAsSet_boundaries", "code": "@[simp]\ntheorem Composition.toCompositionAsSet_boundaries (c : Composition n) :\n    c.toCompositionAsSet.boundaries = c.boundaries", "start": [1064, 1], "end": [1067, 6], "kind": "commanddeclaration"}, {"full_name": "compositionEquiv", "code": "def compositionEquiv (n : \u2115) : Composition n \u2243 CompositionAsSet n\n    where\n  toFun c := c.toCompositionAsSet\n  invFun c := c.toComposition\n  left_inv c := by\n    ext1\n    exact c.toCompositionAsSet_blocks\n  right_inv c := by\n    ext1\n    exact c.toComposition_boundaries", "start": [1070, 1], "end": [1080, 37], "kind": "commanddeclaration"}, {"full_name": "compositionFintype", "code": "instance compositionFintype (n : \u2115) : Fintype (Composition n) :=\n  Fintype.ofEquiv _ (compositionEquiv n).symm", "start": [1083, 1], "end": [1084, 46], "kind": "commanddeclaration"}, {"full_name": "composition_card", "code": "theorem composition_card (n : \u2115) : Fintype.card (Composition n) = 2 ^ (n - 1)", "start": [1087, 1], "end": [1089, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/List.lean", "imports": ["Mathlib/GroupTheory/Perm/Support.lean", "Mathlib/Data/List/Rotate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.formPerm", "code": "def formPerm : Equiv.Perm \u03b1 :=\n  (zipWith Equiv.swap l l.tail).prod", "start": [42, 1], "end": [48, 37], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_nil", "code": "@[simp]\ntheorem formPerm_nil : formPerm ([] : List \u03b1) = 1", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_singleton", "code": "@[simp]\ntheorem formPerm_singleton (x : \u03b1) : formPerm [x] = 1", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_cons_cons", "code": "@[simp]\ntheorem formPerm_cons_cons (x y : \u03b1) (l : List \u03b1) :\n    formPerm (x :: y :: l) = swap x y * formPerm (y :: l)", "start": [61, 1], "end": [64, 12], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_pair", "code": "theorem formPerm_pair (x y : \u03b1) : formPerm [x, y] = swap x y", "start": [67, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_of_not_mem", "code": "theorem formPerm_apply_of_not_mem (x : \u03b1) (l : List \u03b1) (h : x \u2209 l) : formPerm l x = x", "start": [73, 1], "end": [80, 41], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_formPerm_apply_ne", "code": "theorem mem_of_formPerm_apply_ne (x : \u03b1) (l : List \u03b1) : l.formPerm x \u2260 x \u2192 x \u2208 l", "start": [83, 1], "end": [84, 55], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_mem_of_mem", "code": "theorem formPerm_apply_mem_of_mem (x : \u03b1) (l : List \u03b1) (h : x \u2208 l) : formPerm l x \u2208 l", "start": [87, 1], "end": [99, 51], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_formPerm_apply_mem", "code": "theorem mem_of_formPerm_apply_mem (x : \u03b1) (l : List \u03b1) (h : l.formPerm x \u2208 l) : x \u2208 l", "start": [102, 1], "end": [117, 17], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_mem_iff_mem", "code": "theorem formPerm_mem_iff_mem : l.formPerm x \u2208 l \u2194 x \u2208 l", "start": [120, 1], "end": [121, 65], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_cons_concat_apply_last", "code": "@[simp]\ntheorem formPerm_cons_concat_apply_last (x y : \u03b1) (xs : List \u03b1) :\n    formPerm (x :: (xs ++ [y])) y = x", "start": [124, 1], "end": [129, 14], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_getLast", "code": "@[simp]\ntheorem formPerm_apply_getLast (x : \u03b1) (xs : List \u03b1) :\n    formPerm (x :: xs) ((x :: xs).getLast (cons_ne_nil x xs)) = x", "start": [132, 1], "end": [135, 76], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_nthLe_length", "code": "@[simp]\ntheorem formPerm_apply_nthLe_length (x : \u03b1) (xs : List \u03b1) :\n    formPerm (x :: xs) ((x :: xs).nthLe xs.length (by simp)) = x", "start": [139, 1], "end": [142, 54], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_head", "code": "theorem formPerm_apply_head (x y : \u03b1) (xs : List \u03b1) (h : Nodup (x :: y :: xs)) :\n    formPerm (x :: y :: xs) x = y", "start": [145, 1], "end": [146, 87], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_nthLe_zero", "code": "theorem formPerm_apply_nthLe_zero (l : List \u03b1) (h : Nodup l) (hl : 1 < l.length) :\n    formPerm l (l.nthLe 0 (zero_lt_one.trans hl)) = l.nthLe 1 hl", "start": [150, 1], "end": [155, 44], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_eq_head_iff_eq_getLast", "code": "theorem formPerm_eq_head_iff_eq_getLast (x y : \u03b1) :\n    formPerm (y :: l) x = y \u2194 x = getLast (y :: l) (cons_ne_nil _ _)", "start": [160, 1], "end": [162, 82], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_swap_prod_support'", "code": "theorem zipWith_swap_prod_support' (l l' : List \u03b1) :\n    { x | (zipWith swap l l').prod x \u2260 x } \u2264 l.toFinset \u2294 l'.toFinset", "start": [165, 1], "end": [187, 49], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_swap_prod_support", "code": "theorem zipWith_swap_prod_support [Fintype \u03b1] (l l' : List \u03b1) :\n    (zipWith swap l l').prod.support \u2264 l.toFinset \u2294 l'.toFinset", "start": [190, 1], "end": [194, 49], "kind": "commanddeclaration"}, {"full_name": "List.support_formPerm_le'", "code": "theorem support_formPerm_le' : { x | formPerm l x \u2260 x } \u2264 l.toFinset", "start": [197, 1], "end": [199, 48], "kind": "commanddeclaration"}, {"full_name": "List.support_formPerm_le", "code": "theorem support_formPerm_le [Fintype \u03b1] : support (formPerm l) \u2264 l.toFinset", "start": [202, 1], "end": [205, 41], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_lt", "code": "theorem formPerm_apply_lt (xs : List \u03b1) (h : Nodup xs) (n : \u2115) (hn : n + 1 < xs.length) :\n    formPerm xs (xs.nthLe n ((Nat.lt_succ_self n).trans hn)) = xs.nthLe (n + 1) hn", "start": [209, 1], "end": [223, 28], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_nthLe", "code": "theorem formPerm_apply_nthLe (xs : List \u03b1) (h : Nodup xs) (n : \u2115) (hn : n < xs.length) :\n    formPerm xs (xs.nthLe n hn) =\n      xs.nthLe ((n + 1) % xs.length) (Nat.mod_lt _ (n.zero_le.trans_lt hn))", "start": [227, 1], "end": [239, 57], "kind": "commanddeclaration"}, {"full_name": "List.support_formPerm_of_nodup'", "code": "theorem support_formPerm_of_nodup' (l : List \u03b1) (h : Nodup l) (h' : \u2200 x : \u03b1, l \u2260 [x]) :\n    { x | formPerm l x \u2260 x } = l.toFinset", "start": [243, 1], "end": [259, 39], "kind": "commanddeclaration"}, {"full_name": "List.support_formPerm_of_nodup", "code": "theorem support_formPerm_of_nodup [Fintype \u03b1] (l : List \u03b1) (h : Nodup l) (h' : \u2200 x : \u03b1, l \u2260 [x]) :\n    support (formPerm l) = l.toFinset", "start": [262, 1], "end": [266, 21], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_rotate_one", "code": "theorem formPerm_rotate_one (l : List \u03b1) (h : Nodup l) : formPerm (l.rotate 1) = formPerm l", "start": [270, 1], "end": [278, 19], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_rotate", "code": "theorem formPerm_rotate (l : List \u03b1) (h : Nodup l) (n : \u2115) :\n    formPerm (l.rotate n) = formPerm l", "start": [281, 1], "end": [287, 31], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_eq_of_isRotated", "code": "theorem formPerm_eq_of_isRotated {l l' : List \u03b1} (hd : Nodup l) (h : l ~r l') :\n    formPerm l = formPerm l'", "start": [290, 1], "end": [293, 38], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_reverse", "code": "theorem formPerm_reverse (l : List \u03b1) (h : Nodup l) : formPerm l.reverse = (formPerm l)\u207b\u00b9", "start": [297, 1], "end": [322, 19], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_pow_apply_nthLe", "code": "theorem formPerm_pow_apply_nthLe (l : List \u03b1) (h : Nodup l) (n k : \u2115) (hk : k < l.length) :\n    (formPerm l ^ n) (l.nthLe k hk) =\n      l.nthLe ((k + n) % l.length) (Nat.mod_lt _ (k.zero_le.trans_lt hk))", "start": [325, 1], "end": [330, 99], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_pow_apply_head", "code": "theorem formPerm_pow_apply_head (x : \u03b1) (l : List \u03b1) (h : Nodup (x :: l)) (n : \u2115) :\n    (formPerm (x :: l) ^ n) x =\n      (x :: l).nthLe (n % (x :: l).length) (Nat.mod_lt _ (Nat.zero_lt_succ _))", "start": [333, 1], "end": [337, 7], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_ext_iff", "code": "theorem formPerm_ext_iff {x y x' y' : \u03b1} {l l' : List \u03b1} (hd : Nodup (x :: y :: l))\n    (hd' : Nodup (x' :: y' :: l')) :\n    formPerm (x :: y :: l) = formPerm (x' :: y' :: l') \u2194 (x :: y :: l) ~r (x' :: y' :: l')", "start": [341, 1], "end": [376, 90], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_mem_eq_self_iff", "code": "theorem formPerm_apply_mem_eq_self_iff (hl : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    formPerm l x = x \u2194 length l \u2264 1", "start": [380, 1], "end": [390, 31], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_apply_mem_ne_self_iff", "code": "theorem formPerm_apply_mem_ne_self_iff (hl : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    formPerm l x \u2260 x \u2194 2 \u2264 l.length", "start": [393, 1], "end": [396, 47], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_formPerm_ne_self", "code": "theorem mem_of_formPerm_ne_self (l : List \u03b1) (x : \u03b1) (h : formPerm l x \u2260 x) : x \u2208 l", "start": [399, 1], "end": [403, 16], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_eq_self_of_not_mem", "code": "theorem formPerm_eq_self_of_not_mem (l : List \u03b1) (x : \u03b1) (h : x \u2209 l) : formPerm l x = x", "start": [406, 1], "end": [407, 56], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_eq_one_iff", "code": "theorem formPerm_eq_one_iff (hl : Nodup l) : formPerm l = 1 \u2194 l.length \u2264 1", "start": [410, 1], "end": [419, 15], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_eq_formPerm_iff", "code": "theorem formPerm_eq_formPerm_iff {l l' : List \u03b1} (hl : l.Nodup) (hl' : l'.Nodup) :\n    l.formPerm = l'.formPerm \u2194 l ~r l' \u2228 l.length \u2264 1 \u2227 l'.length \u2264 1", "start": [422, 1], "end": [440, 80], "kind": "commanddeclaration"}, {"full_name": "List.form_perm_zpow_apply_mem_imp_mem", "code": "theorem form_perm_zpow_apply_mem_imp_mem (l : List \u03b1) (x : \u03b1) (hx : x \u2208 l) (n : \u2124) :\n    (formPerm l ^ n) x \u2208 l", "start": [443, 1], "end": [450, 41], "kind": "commanddeclaration"}, {"full_name": "List.formPerm_pow_length_eq_one_of_nodup", "code": "theorem formPerm_pow_length_eq_one_of_nodup (hl : Nodup l) : formPerm l ^ length l = 1", "start": [454, 1], "end": [464, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Fintype.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Embedding.toEquivRange", "code": "def Function.Embedding.toEquivRange : \u03b1 \u2243 Set.range f :=\n  \u27e8fun a => \u27e8f a, Set.mem_range_self a\u27e9, f.invOfMemRange, fun _ => by simp, fun _ => by simp\u27e9", "start": [33, 1], "end": [39, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.toEquivRange_apply", "code": "@[simp]\ntheorem Function.Embedding.toEquivRange_apply (a : \u03b1) :\n    f.toEquivRange a = \u27e8f a, Set.mem_range_self a\u27e9", "start": [42, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.toEquivRange_symm_apply_self", "code": "@[simp]\ntheorem Function.Embedding.toEquivRange_symm_apply_self (a : \u03b1) :\n    f.toEquivRange.symm \u27e8f a, Set.mem_range_self a\u27e9 = a", "start": [48, 1], "end": [50, 89], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.toEquivRange_eq_ofInjective", "code": "theorem Function.Embedding.toEquivRange_eq_ofInjective :\n    f.toEquivRange = Equiv.ofInjective f f.injective", "start": [53, 1], "end": [56, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.viaFintypeEmbedding", "code": "def Equiv.Perm.viaFintypeEmbedding : Equiv.Perm \u03b2 :=\n  e.extendDomain f.toEquivRange", "start": [59, 1], "end": [67, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.viaFintypeEmbedding_apply_image", "code": "@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_apply_image (a : \u03b1) :\n    e.viaFintypeEmbedding f (f a) = f (e a)", "start": [70, 1], "end": [74, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.viaFintypeEmbedding_apply_mem_range", "code": "theorem Equiv.Perm.viaFintypeEmbedding_apply_mem_range {b : \u03b2} (h : b \u2208 Set.range f) :\n    e.viaFintypeEmbedding f b = f (e (f.invOfMemRange \u27e8b, h\u27e9))", "start": [77, 1], "end": [81, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range", "code": "theorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range {b : \u03b2} (h : b \u2209 Set.range f) :\n    e.viaFintypeEmbedding f b = b", "start": [84, 1], "end": [86, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.viaFintypeEmbedding_sign", "code": "@[simp]\ntheorem Equiv.Perm.viaFintypeEmbedding_sign [DecidableEq \u03b1] [Fintype \u03b2] :\n    Equiv.Perm.sign (e.viaFintypeEmbedding f) = Equiv.Perm.sign e", "start": [89, 1], "end": [92, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.toCompl", "code": "noncomputable def toCompl (e : { x // p x } \u2243 { x // q x }) : { x // \u00acp x } \u2243 { x // \u00acq x } :=\n  Classical.choice\n    (Fintype.card_eq.mp (Fintype.card_compl_eq_card_compl _ _ (Fintype.card_congr e)))", "start": [99, 1], "end": [106, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.extendSubtype", "code": "noncomputable abbrev extendSubtype (e : { x // p x } \u2243 { x // q x }) : Perm \u03b1 :=\n  subtypeCongr e e.toCompl", "start": [109, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.extendSubtype_apply_of_mem", "code": "theorem extendSubtype_apply_of_mem (e : { x // p x } \u2243 { x // q x }) (x) (hx : p x) :\n    e.extendSubtype x = e \u27e8x, hx\u27e9", "start": [117, 1], "end": [121, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.extendSubtype_mem", "code": "theorem extendSubtype_mem (e : { x // p x } \u2243 { x // q x }) (x) (hx : p x) :\n    q (e.extendSubtype x)", "start": [124, 1], "end": [127, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.extendSubtype_apply_of_not_mem", "code": "theorem extendSubtype_apply_of_not_mem (e : { x // p x } \u2243 { x // q x }) (x) (hx : \u00acp x) :\n    e.extendSubtype x = e.toCompl \u27e8x, hx\u27e9", "start": [130, 1], "end": [134, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.extendSubtype_not_mem", "code": "theorem extendSubtype_not_mem (e : { x // p x } \u2243 { x // q x }) (x) (hx : \u00acp x) :\n    \u00acq (e.extendSubtype x)", "start": [137, 1], "end": [140, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Perm.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Data/Fintype/Card.lean", "Mathlib/GroupTheory/Perm/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "permsOfList", "code": "def permsOfList : List \u03b1 \u2192 List (Perm \u03b1)\n  | [] => [1]\n  | a :: l => permsOfList l ++ l.bind fun b => (permsOfList l).map fun f => Equiv.swap a b * f", "start": [32, 1], "end": [35, 95], "kind": "commanddeclaration"}, {"full_name": "length_permsOfList", "code": "theorem length_permsOfList : \u2200 l : List \u03b1, length (permsOfList l) = l.length !", "start": [38, 1], "end": [44, 9], "kind": "commanddeclaration"}, {"full_name": "mem_permsOfList_of_mem", "code": "theorem mem_permsOfList_of_mem {l : List \u03b1} {f : Perm \u03b1} (h : \u2200 x, f x \u2260 x \u2192 x \u2208 l) :\n    f \u2208 permsOfList l", "start": [47, 1], "end": [74, 96], "kind": "commanddeclaration"}, {"full_name": "mem_of_mem_permsOfList", "code": "theorem mem_of_mem_permsOfList :\n    \u2200 {l : List \u03b1} {f : Perm \u03b1}, f \u2208 permsOfList l \u2192 (x :\u03b1 ) \u2192 f x \u2260 x \u2192 x \u2208 l", "start": [77, 1], "end": [94, 77], "kind": "commanddeclaration"}, {"full_name": "mem_permsOfList_iff", "code": "theorem mem_permsOfList_iff {l : List \u03b1} {f : Perm \u03b1} :\n    f \u2208 permsOfList l \u2194 \u2200 {x}, f x \u2260 x \u2192 x \u2208 l", "start": [97, 1], "end": [99, 51], "kind": "commanddeclaration"}, {"full_name": "nodup_permsOfList", "code": "theorem nodup_permsOfList : \u2200 {l : List \u03b1} (_ : l.Nodup), (permsOfList l).Nodup", "start": [102, 1], "end": [128, 79], "kind": "commanddeclaration"}, {"full_name": "permsOfFinset", "code": "def permsOfFinset (s : Finset \u03b1) : Finset (Perm \u03b1) :=\n  Quotient.hrecOn s.1 (fun l hl => \u27e8permsOfList l, nodup_permsOfList hl\u27e9)\n    (fun a b hab =>\n      hfunext (congr_arg _ (Quotient.sound hab)) fun ha hb _ =>\n        heq_of_eq <| Finset.ext <| by simp [mem_permsOfList_iff, hab.mem_iff])\n    s.2", "start": [131, 1], "end": [137, 8], "kind": "commanddeclaration"}, {"full_name": "mem_perms_of_finset_iff", "code": "theorem mem_perms_of_finset_iff :\n    \u2200 {s : Finset \u03b1} {f : Perm \u03b1}, f \u2208 permsOfFinset s \u2194 \u2200 {x}, f x \u2260 x \u2192 x \u2208 s", "start": [140, 1], "end": [142, 48], "kind": "commanddeclaration"}, {"full_name": "card_perms_of_finset", "code": "theorem card_perms_of_finset : \u2200 s : Finset \u03b1, (permsOfFinset s).card = s.card !", "start": [145, 1], "end": [146, 47], "kind": "commanddeclaration"}, {"full_name": "fintypePerm", "code": "def fintypePerm [Fintype \u03b1] : Fintype (Perm \u03b1) :=\n  \u27e8permsOfFinset (@Finset.univ \u03b1 _), by simp [mem_perms_of_finset_iff]\u27e9", "start": [149, 1], "end": [151, 72], "kind": "commanddeclaration"}, {"full_name": "equivFintype", "code": "instance equivFintype [Fintype \u03b1] [Fintype \u03b2] : Fintype (\u03b1 \u2243 \u03b2) :=\n  if h : Fintype.card \u03b2 = Fintype.card \u03b1 then\n    Trunc.recOnSubsingleton (Fintype.truncEquivFin \u03b1) fun e\u03b1 =>\n      Trunc.recOnSubsingleton (Fintype.truncEquivFin \u03b2) fun e\u03b2 =>\n        @Fintype.ofEquiv _ (Perm \u03b1) fintypePerm\n          (equivCongr (Equiv.refl \u03b1) (e\u03b1.trans (Eq.recOn h e\u03b2.symm)) : \u03b1 \u2243 \u03b1 \u2243 (\u03b1 \u2243 \u03b2))\n  else \u27e8\u2205, fun x => False.elim (h (Fintype.card_eq.2 \u27e8x.symm\u27e9))\u27e9", "start": [154, 1], "end": [160, 65], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_perm", "code": "theorem Fintype.card_perm [Fintype \u03b1] : Fintype.card (Perm \u03b1) = (Fintype.card \u03b1)!", "start": [162, 1], "end": [163, 94], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_equiv", "code": "theorem Fintype.card_equiv [Fintype \u03b1] [Fintype \u03b2] (e : \u03b1 \u2243 \u03b2) :\n    Fintype.card (\u03b1 \u2243 \u03b2) = (Fintype.card \u03b1)!", "start": [166, 1], "end": [168, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Sort.lean", "imports": ["Mathlib/Data/Fintype/Basic.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "monoEquivOfFin", "code": "def monoEquivOfFin (\u03b1 : Type*) [Fintype \u03b1] [LinearOrder \u03b1] {k : \u2115} (h : Fintype.card \u03b1 = k) :\n    Fin k \u2243o \u03b1 :=\n  (univ.orderIsoOfFin h).trans <| (OrderIso.setCongr _ _ coe_univ).trans OrderIso.Set.univ", "start": [23, 1], "end": [29, 91], "kind": "commanddeclaration"}, {"full_name": "finSumEquivOfFinset", "code": "def finSumEquivOfFinset (hm : s.card = m) (hn : s\u1d9c.card = n) : Sum (Fin m) (Fin n) \u2243 \u03b1 :=\n  calc\n    Sum (Fin m) (Fin n) \u2243 Sum (s : Set \u03b1) (s\u1d9c : Set \u03b1) :=\n      Equiv.sumCongr (s.orderIsoOfFin hm).toEquiv <|\n        (s\u1d9c.orderIsoOfFin hn).toEquiv.trans <| Equiv.Set.ofEq s.coe_compl\n    _ \u2243 \u03b1 := Equiv.Set.sumCompl _", "start": [34, 1], "end": [43, 34], "kind": "commanddeclaration"}, {"full_name": "finSumEquivOfFinset_inl", "code": "@[simp]\ntheorem finSumEquivOfFinset_inl (hm : s.card = m) (hn : s\u1d9c.card = n) (i : Fin m) :\n    finSumEquivOfFinset hm hn (Sum.inl i) = s.orderEmbOfFin hm i", "start": [46, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "finSumEquivOfFinset_inr", "code": "@[simp]\ntheorem finSumEquivOfFinset_inr (hm : s.card = m) (hn : s\u1d9c.card = n) (i : Fin n) :\n    finSumEquivOfFinset hm hn (Sum.inr i) = s\u1d9c.orderEmbOfFin hn i", "start": [52, 1], "end": [55, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Antidiagonal.lean", "imports": ["Mathlib/Data/Multiset/Antidiagonal.lean", "Mathlib/Data/Finset/NatAntidiagonal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finsupp/Multiset.lean", "Mathlib/Init/IteSimp.lean"], "premises": [{"full_name": "Finsupp.antidiagonal'", "code": "def antidiagonal' (f : \u03b1 \u2192\u2080 \u2115) : (\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115) \u2192\u2080 \u2115 :=\n  Multiset.toFinsupp\n    ((Finsupp.toMultiset f).antidiagonal.map (Prod.map Multiset.toFinsupp Multiset.toFinsupp))", "start": [32, 1], "end": [37, 95], "kind": "commanddeclaration"}, {"full_name": "Finsupp.antidiagonal", "code": "def antidiagonal (f : \u03b1 \u2192\u2080 \u2115) : Finset ((\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115)) := f.antidiagonal'.support", "start": [40, 1], "end": [42, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_antidiagonal", "code": "@[simp]\ntheorem mem_antidiagonal {f : \u03b1 \u2192\u2080 \u2115} {p : (\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115)} :\n    p \u2208 antidiagonal f \u2194 p.1 + p.2 = f", "start": [45, 1], "end": [50, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.swap_mem_antidiagonal", "code": "theorem swap_mem_antidiagonal {n : \u03b1 \u2192\u2080 \u2115} {f : (\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115)} :\n    f.swap \u2208 antidiagonal n \u2194 f \u2208 antidiagonal n", "start": [53, 1], "end": [55, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.antidiagonal_filter_fst_eq", "code": "theorem antidiagonal_filter_fst_eq (f g : \u03b1 \u2192\u2080 \u2115)\n    [D : \u2200 p : (\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115), Decidable (p.1 = g)] :\n    ((antidiagonal f).filter fun p \u21a6 p.1 = g) = if g \u2264 f then {(g, f - g)} else \u2205", "start": [58, 1], "end": [70, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.antidiagonal_filter_snd_eq", "code": "theorem antidiagonal_filter_snd_eq (f g : \u03b1 \u2192\u2080 \u2115)\n    [D : \u2200 p : (\u03b1 \u2192\u2080 \u2115) \u00d7 (\u03b1 \u2192\u2080 \u2115), Decidable (p.2 = g)] :\n    ((antidiagonal f).filter fun p \u21a6 p.2 = g) = if g \u2264 f then {(f - g, g)} else \u2205", "start": [73, 1], "end": [85, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.antidiagonal_zero", "code": "@[simp]\ntheorem antidiagonal_zero : antidiagonal (0 : \u03b1 \u2192\u2080 \u2115) = singleton (0, 0)", "start": [88, 1], "end": [89, 80], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_antidiagonal_swap", "code": "@[to_additive]\ntheorem prod_antidiagonal_swap {M : Type*} [CommMonoid M] (n : \u03b1 \u2192\u2080 \u2115)\n    (f : (\u03b1 \u2192\u2080 \u2115) \u2192 (\u03b1 \u2192\u2080 \u2115) \u2192 M) :\n    \u220f p in antidiagonal n, f p.1 p.2 = \u220f p in antidiagonal n, f p.2 p.1", "start": [92, 1], "end": [98, 59], "kind": "commanddeclaration"}, {"full_name": "Finsupp.antidiagonal_single", "code": "@[simp]\ntheorem antidiagonal_single (a : \u03b1) (n : \u2115) :\n    antidiagonal (single a n) = (Finset.Nat.antidiagonal n).map\n      (Function.Embedding.prodMap \u27e8_, single_injective a\u27e9 \u27e8_, single_injective a\u27e9)", "start": [102, 1], "end": [121, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/Basic.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/GroupTheory/MonoidLocalization.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/RingTheory/NonZeroDivisors.lean"], "premises": [{"full_name": "IsLocalization", "code": "class IsLocalization : Prop where\n  \n  map_units' : \u2200 y : M, IsUnit (algebraMap R S y)\n  \n  surj' : \u2200 z : S, \u2203 x : R \u00d7 M, z * algebraMap R S x.2 = algebraMap R S x.1\n  \n  eq_iff_exists' : \u2200 {x y}, algebraMap R S x = algebraMap R S y \u2194 \u2203 c : M, \u2191c * x = \u2191c * y", "start": [97, 1], "end": [106, 91], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_units", "code": "@[inherit_doc IsLocalization.map_units']\ntheorem map_units : \u2200 y : M, IsUnit (algebraMap R S y)", "start": [119, 1], "end": [121, 28], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.surj", "code": "@[inherit_doc IsLocalization.surj']\ntheorem surj : \u2200 z : S, \u2203 x : R \u00d7 M, z * algebraMap R S x.2 = algebraMap R S x.1", "start": [124, 1], "end": [126, 23], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq_iff_exists", "code": "@[inherit_doc IsLocalization.eq_iff_exists']\ntheorem eq_iff_exists {x y} : algebraMap R S x = algebraMap R S y \u2194 \u2203 c : M, \u2191c * x = \u2191c * y", "start": [129, 1], "end": [131, 32], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.of_le", "code": "theorem of_le (N : Submonoid R) (h\u2081 : M \u2264 N) (h\u2082 : \u2200 r \u2208 N, IsUnit (algebraMap R S r)) :\n    IsLocalization N S", "start": [134, 1], "end": [147, 41], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.toLocalizationWithZeroMap", "code": "@[simps]\ndef toLocalizationWithZeroMap : Submonoid.LocalizationWithZeroMap M S :=\n  { algebraMap R S with\n    toFun := algebraMap R S\n    map_units' := IsLocalization.map_units _\n    surj' := IsLocalization.surj _\n    eq_iff_exists' := fun _ _ => IsLocalization.eq_iff_exists _ _ }", "start": [152, 1], "end": [160, 68], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.toLocalizationMap", "code": "abbrev toLocalizationMap : Submonoid.LocalizationMap M S :=\n  (toLocalizationWithZeroMap M S).toLocalizationMap", "start": [163, 1], "end": [165, 52], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.toLocalizationMap_toMap", "code": "@[simp]\ntheorem toLocalizationMap_toMap : (toLocalizationMap M S).toMap = (algebraMap R S : R \u2192*\u2080 S)", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.toLocalizationMap_toMap_apply", "code": "theorem toLocalizationMap_toMap_apply (x) : (toLocalizationMap M S).toMap x = algebraMap R S x", "start": [173, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.sec", "code": "noncomputable def sec (z : S) : R \u00d7 M :=\n  Classical.choose <| IsLocalization.surj _ z", "start": [181, 1], "end": [184, 46], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.toLocalizationMap_sec", "code": "@[simp]\ntheorem toLocalizationMap_sec : (toLocalizationMap M S).sec = sec M", "start": [187, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.sec_spec", "code": "theorem sec_spec (z : S) :\n    z * algebraMap R S (IsLocalization.sec M z).2 = algebraMap R S (IsLocalization.sec M z).1", "start": [192, 1], "end": [196, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.sec_spec'", "code": "theorem sec_spec' (z : S) :\n    algebraMap R S (IsLocalization.sec M z).1 = algebraMap R S (IsLocalization.sec M z).2 * z", "start": [199, 1], "end": [203, 26], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_right_cancel", "code": "theorem map_right_cancel {x y} {c : M} (h : algebraMap R S (c * x) = algebraMap R S (c * y)) :\n    algebraMap R S x = algebraMap R S y", "start": [208, 1], "end": [210, 45], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_left_cancel", "code": "theorem map_left_cancel {x y} {c : M} (h : algebraMap R S (x * c) = algebraMap R S (y * c)) :\n    algebraMap R S x = algebraMap R S y", "start": [213, 1], "end": [215, 44], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq_zero_of_fst_eq_zero", "code": "theorem eq_zero_of_fst_eq_zero {z x} {y : M} (h : z * algebraMap R S y = algebraMap R S x)\n    (hx : x = 0) : z = 0", "start": [218, 1], "end": [221, 69], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_eq_zero_iff", "code": "theorem map_eq_zero_iff (r : R) : algebraMap R S r = 0 \u2194 \u2203 m : M, \u2191m * r = 0", "start": [226, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'", "code": "noncomputable def mk' (x : R) (y : M) : S :=\n  (toLocalizationMap M S).mk' x y", "start": [238, 1], "end": [241, 34], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_sec", "code": "@[simp]\ntheorem mk'_sec (z : S) : mk' S (IsLocalization.sec M z).1 (IsLocalization.sec M z).2 = z", "start": [244, 1], "end": [246, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mul", "code": "theorem mk'_mul (x\u2081 x\u2082 : R) (y\u2081 y\u2082 : M) : mk' S (x\u2081 * x\u2082) (y\u2081 * y\u2082) = mk' S x\u2081 y\u2081 * mk' S x\u2082 y\u2082", "start": [249, 1], "end": [250, 42], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_one", "code": "theorem mk'_one (x) : mk' S x (1 : M) = algebraMap R S x", "start": [253, 1], "end": [254, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_spec", "code": "@[simp]\ntheorem mk'_spec (x) (y : M) : mk' S x y * algebraMap R S y = algebraMap R S x", "start": [257, 1], "end": [259, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_spec'", "code": "@[simp]\ntheorem mk'_spec' (x) (y : M) : algebraMap R S y * mk' S x y = algebraMap R S x", "start": [262, 1], "end": [264, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_spec_mk", "code": "@[simp]\ntheorem mk'_spec_mk (x) (y : R) (hy : y \u2208 M) :\n    mk' S x \u27e8y, hy\u27e9 * algebraMap R S y = algebraMap R S x", "start": [267, 1], "end": [270, 23], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_spec'_mk", "code": "@[simp]\ntheorem mk'_spec'_mk (x) (y : R) (hy : y \u2208 M) :\n    algebraMap R S y * mk' S x \u27e8y, hy\u27e9 = algebraMap R S x", "start": [273, 1], "end": [276, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq_mk'_iff_mul_eq", "code": "theorem eq_mk'_iff_mul_eq {x} {y : M} {z} :\n    z = mk' S x y \u2194 z * algebraMap R S y = algebraMap R S x", "start": [281, 1], "end": [283, 44], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_iff_eq_mul", "code": "theorem mk'_eq_iff_eq_mul {x} {y : M} {z} :\n    mk' S x y = z \u2194 algebraMap R S x = z * algebraMap R S y", "start": [286, 1], "end": [288, 44], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_add_eq_iff_add_mul_eq_mul", "code": "theorem mk'_add_eq_iff_add_mul_eq_mul {x} {y : M} {z\u2081 z\u2082} :\n    mk' S x y + z\u2081 = z\u2082 \u2194 algebraMap R S x + z\u2081 * algebraMap R S y = z\u2082 * algebraMap R S y", "start": [291, 1], "end": [293, 93], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_surjective", "code": "theorem mk'_surjective (z : S) : \u2203 (x : _) (y : M), mk' S x y = z", "start": [298, 1], "end": [300, 44], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.fintype'", "code": "noncomputable def fintype' [Fintype R] : Fintype S :=\n  have := Classical.propDecidable\n  Fintype.ofSurjective (Function.uncurry <| IsLocalization.mk' S) fun a =>\n    Prod.exists'.mpr <| IsLocalization.mk'_surjective M a", "start": [305, 1], "end": [309, 58], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.uniqueOfZeroMem", "code": "def uniqueOfZeroMem (h : (0 : R) \u2208 M) : Unique S :=\n  uniqueOfZeroEqOne <| by simpa using IsLocalization.map_units S \u27e80, h\u27e9", "start": [314, 1], "end": [316, 72], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_iff_eq", "code": "theorem mk'_eq_iff_eq {x\u2081 x\u2082} {y\u2081 y\u2082 : M} :\n    mk' S x\u2081 y\u2081 = mk' S x\u2082 y\u2082 \u2194 algebraMap R S (y\u2082 * x\u2081) = algebraMap R S (y\u2081 * x\u2082)", "start": [319, 1], "end": [321, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_iff_eq'", "code": "theorem mk'_eq_iff_eq' {x\u2081 x\u2082} {y\u2081 y\u2082 : M} :\n    mk' S x\u2081 y\u2081 = mk' S x\u2082 y\u2082 \u2194 algebraMap R S (x\u2081 * y\u2082) = algebraMap R S (x\u2082 * y\u2081)", "start": [324, 1], "end": [326, 41], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mem_iff", "code": "theorem mk'_mem_iff {x} {y : M} {I : Ideal S} : mk' S x y \u2208 I \u2194 algebraMap R S x \u2208 I", "start": [329, 1], "end": [336, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq", "code": "protected theorem eq {a\u2081 b\u2081} {a\u2082 b\u2082 : M} :\n    mk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082 \u2194 \u2203 c : M, \u2191c * (\u2191b\u2082 * a\u2081) = c * (a\u2082 * b\u2081)", "start": [339, 1], "end": [341, 29], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_zero_iff", "code": "theorem mk'_eq_zero_iff (x : R) (s : M) : mk' S x s = 0 \u2194 \u2203 m : M, \u2191m * x = 0", "start": [344, 1], "end": [345, 77], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_zero", "code": "@[simp]\ntheorem mk'_zero (s : M) : IsLocalization.mk' S 0 s = 0", "start": [348, 1], "end": [350, 69], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ne_zero_of_mk'_ne_zero", "code": "theorem ne_zero_of_mk'_ne_zero {x : R} {y : M} (hxy : IsLocalization.mk' S x y \u2260 0) : x \u2260 0", "start": [353, 1], "end": [355, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq_iff_eq", "code": "theorem eq_iff_eq {x y} :\n    algebraMap R S x = algebraMap R S y \u2194 algebraMap R P x = algebraMap R P y", "start": [362, 1], "end": [364, 60], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_iff_mk'_eq", "code": "theorem mk'_eq_iff_mk'_eq {x\u2081 x\u2082} {y\u2081 y\u2082 : M} :\n    mk' S x\u2081 y\u2081 = mk' S x\u2082 y\u2082 \u2194 mk' P x\u2081 y\u2081 = mk' P x\u2082 y\u2082", "start": [367, 1], "end": [369, 68], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_of_eq", "code": "theorem mk'_eq_of_eq {a\u2081 b\u2081 : R} {a\u2082 b\u2082 : M} (H : \u2191a\u2082 * b\u2081 = \u2191b\u2082 * a\u2081) :\n    mk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082", "start": [372, 1], "end": [374, 41], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_of_eq'", "code": "theorem mk'_eq_of_eq' {a\u2081 b\u2081 : R} {a\u2082 b\u2082 : M} (H : b\u2081 * \u2191a\u2082 = a\u2081 * \u2191b\u2082) :\n    mk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082", "start": [377, 1], "end": [379, 42], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_self", "code": "@[simp]\ntheorem mk'_self {x : R} (hx : x \u2208 M) : mk' S x \u27e8x, hx\u27e9 = 1", "start": [384, 1], "end": [386, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_self'", "code": "@[simp]\ntheorem mk'_self' {x : M} : mk' S (x : R) x = 1", "start": [389, 1], "end": [391, 38], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_self''", "code": "theorem mk'_self'' {x : M} : mk' S x.1 x = 1", "start": [394, 1], "end": [395, 14], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mul_mk'_eq_mk'_of_mul", "code": "theorem mul_mk'_eq_mk'_of_mul (x y : R) (z : M) :\n    (algebraMap R S) x * mk' S y z = mk' S (x * y) z", "start": [400, 1], "end": [402, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_eq_mul_mk'_one", "code": "theorem mk'_eq_mul_mk'_one (x : R) (y : M) : mk' S x y = (algebraMap R S) x * mk' S 1 y", "start": [405, 1], "end": [406, 56], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mul_cancel_left", "code": "@[simp]\ntheorem mk'_mul_cancel_left (x : R) (y : M) : mk' S (y * x : R) y = (algebraMap R S) x", "start": [409, 1], "end": [411, 50], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mul_cancel_right", "code": "theorem mk'_mul_cancel_right (x : R) (y : M) : mk' S (x * y) y = (algebraMap R S) x", "start": [414, 1], "end": [415, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mul_mk'_eq_one", "code": "@[simp]\ntheorem mk'_mul_mk'_eq_one (x y : M) : mk' S (x : R) y * mk' S (y : R) x = 1", "start": [418, 1], "end": [420, 47], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_mul_mk'_eq_one'", "code": "theorem mk'_mul_mk'_eq_one' (x : R) (y : M) (h : x \u2208 M) : mk' S x y * mk' S (y : R) \u27e8x, h\u27e9 = 1", "start": [423, 1], "end": [424, 30], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.smul_mk'", "code": "theorem smul_mk' (x y : R) (m : M) : x \u2022 mk' S y m = mk' S (x * y) m", "start": [427, 1], "end": [429, 42], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.smul_mk'_one", "code": "@[simp] theorem smul_mk'_one (x : R) (m : M) : x \u2022 mk' S 1 m = mk' S x m", "start": [431, 1], "end": [432, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.smul_mk'_self", "code": "@[simp] lemma smul_mk'_self {m : M} {r : R} :\n    (m : R) \u2022 mk' S r m = algebraMap R S r := by\n  rw [smul_mk', mk'_mul_cancel_left]", "start": [434, 1], "end": [436, 37], "kind": "mathlibtacticlemma"}, {"full_name": "IsLocalization.isUnit_comp", "code": "theorem isUnit_comp (j : S \u2192+* P) (y : M) : IsUnit (j.comp (algebraMap R S) y)", "start": [442, 1], "end": [443, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.eq_of_eq", "code": "theorem eq_of_eq {g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y)) {x y}\n    (h : (algebraMap R S) x = (algebraMap R S) y) : g x = g y", "start": [448, 1], "end": [452, 99], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mk'_add", "code": "theorem mk'_add (x\u2081 x\u2082 : R) (y\u2081 y\u2082 : M) :\n    mk' S (x\u2081 * y\u2082 + x\u2082 * y\u2081) (y\u2081 * y\u2082) = mk' S x\u2081 y\u2081 + mk' S x\u2082 y\u2082", "start": [455, 1], "end": [464, 14], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.mul_add_inv_left", "code": "theorem mul_add_inv_left {g : R \u2192+* P} (h : \u2200 y : M, IsUnit (g y)) (y : M) (w z\u2081 z\u2082 : P) :\n    w * \u2191(IsUnit.liftRight (g.toMonoidHom.restrict M) h y)\u207b\u00b9 + z\u2081 =\n    z\u2082 \u2194 w + g y * z\u2081 = g y * z\u2082", "start": [467, 1], "end": [473, 62], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_spec_mul_add", "code": "theorem lift_spec_mul_add {g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y)) (z w w' v) :\n    ((toLocalizationWithZeroMap M S).lift g.toMonoidWithZeroHom hg) z * w + w' = v \u2194\n      g ((toLocalizationMap M S).sec z).1 * w + g ((toLocalizationMap M S).sec z).2 * w' =\n        g ((toLocalizationMap M S).sec z).2 * v", "start": [476, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift", "code": "noncomputable def lift {g : R \u2192+* P} (hg : \u2200 y : M, IsUnit (g y)) : S \u2192+* P :=\n  { Submonoid.LocalizationWithZeroMap.lift (toLocalizationWithZeroMap M S)\n      g.toMonoidWithZeroHom hg with\n    map_add' := by\n      intro x y\n      erw [(toLocalizationMap M S).lift_spec, mul_add, mul_comm, eq_comm, lift_spec_mul_add,\n        add_comm, mul_comm, mul_assoc, mul_comm, mul_assoc, lift_spec_mul_add]\n      simp_rw [\u2190 mul_assoc]\n      show g _ * g _ * g _ + g _ * g _ * g _ = g _ * g _ * g _\n      simp_rw [\u2190 map_mul g, \u2190 map_add g]\n      apply eq_of_eq (S := S) hg\n      simp only [sec_spec', toLocalizationMap_sec, map_add, map_mul]\n      ring }", "start": [484, 1], "end": [500, 13], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_mk'", "code": "theorem lift_mk' (x y) :\n    lift hg (mk' S x y) = g x * \u2191(IsUnit.liftRight (g.toMonoidHom.restrict M) hg y)\u207b\u00b9", "start": [505, 1], "end": [510, 41], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_mk'_spec", "code": "theorem lift_mk'_spec (x v) (y : M) : lift hg (mk' S x y) = v \u2194 g x = g y * v", "start": [513, 1], "end": [514, 48], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_eq", "code": "@[simp]\ntheorem lift_eq (x : R) : lift hg ((algebraMap R S) x) = g x", "start": [517, 1], "end": [519, 38], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_eq_iff", "code": "theorem lift_eq_iff {x y : R \u00d7 M} :\n    lift hg (mk' S x.1 x.2) = lift hg (mk' S y.1 y.2) \u2194 g (x.1 * y.2) = g (y.1 * x.2)", "start": [522, 1], "end": [524, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_comp", "code": "@[simp]\ntheorem lift_comp : (lift hg).comp (algebraMap R S) = g", "start": [527, 1], "end": [529, 97], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_of_comp", "code": "@[simp]\ntheorem lift_of_comp (j : S \u2192+* P) : lift (isUnit_comp M j) = j", "start": [532, 1], "end": [535, 55], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.monoidHom_ext", "code": "theorem monoidHom_ext \u2983j k : S \u2192* P\u2984\n    (h : j.comp (algebraMap R S : R \u2192* S) = k.comp (algebraMap R S)) : j = k", "start": [540, 1], "end": [543, 99], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ringHom_ext", "code": "theorem ringHom_ext \u2983j k : S \u2192+* P\u2984 (h : j.comp (algebraMap R S) = k.comp (algebraMap R S)) :\n    j = k", "start": [546, 1], "end": [549, 93], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algHom_subsingleton", "code": "theorem algHom_subsingleton [Algebra R P] : Subsingleton (S \u2192\u2090[R] P)", "start": [554, 1], "end": [557, 84], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ext", "code": "protected theorem ext (j k : S \u2192 P) (hj1 : j 1 = 1) (hk1 : k 1 = 1)\n    (hjm : \u2200 a b, j (a * b) = j a * j b) (hkm : \u2200 a b, k (a * b) = k a * k b)\n    (h : \u2200 a, j (algebraMap R S a) = k (algebraMap R S a)) : j = k", "start": [560, 1], "end": [570, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_unique", "code": "theorem lift_unique {j : S \u2192+* P} (hj : \u2200 x, j ((algebraMap R S) x) = g x) : lift hg = j", "start": [575, 1], "end": [579, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_id", "code": "@[simp]\ntheorem lift_id (x) : lift (map_units S : \u2200 _ : M, IsUnit _) x = x", "start": [582, 1], "end": [584, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_surjective_iff", "code": "theorem lift_surjective_iff :\n    Surjective (lift hg : S \u2192 P) \u2194 \u2200 v : P, \u2203 x : R \u00d7 M, v * g x.2 = g x.1", "start": [587, 1], "end": [589, 49], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_injective_iff", "code": "theorem lift_injective_iff :\n    Injective (lift hg : S \u2192 P) \u2194 \u2200 x y, algebraMap R S x = algebraMap R S y \u2194 g x = g y", "start": [592, 1], "end": [594, 48], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map", "code": "noncomputable def map (g : R \u2192+* P) (hy : M \u2264 T.comap g) : S \u2192+* Q :=\n  @lift R _ M _ _ _ _ _ _ ((algebraMap P Q).comp g) fun y => map_units _ \u27e8g y, hy y.2\u27e9", "start": [607, 1], "end": [614, 87], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_eq", "code": "@[simp]\ntheorem map_eq (x) : map Q g hy ((algebraMap R S) x) = algebraMap P Q (g x)", "start": [620, 1], "end": [622, 49], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_comp", "code": "@[simp]\ntheorem map_comp : (map Q g hy).comp (algebraMap R S) = (algebraMap P Q).comp g", "start": [625, 1], "end": [627, 47], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_mk'", "code": "theorem map_mk' (x) (y : M) : map Q g hy (mk' S x y) = mk' Q (g x) \u27e8g y, hy y.2\u27e9", "start": [630, 1], "end": [632, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_id_mk'", "code": "@[simp]\ntheorem map_id_mk' {Q : Type*} [CommSemiring Q] [Algebra R Q] [IsLocalization M Q] (x) (y : M) :\n    map Q (RingHom.id R) (le_refl M) (mk' S x y) = mk' Q x y", "start": [636, 1], "end": [639, 16], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_id", "code": "@[simp]\ntheorem map_id (z : S) (h : M \u2264 M.comap (RingHom.id R) := le_refl M) :\n    map S (RingHom.id _) h z = z", "start": [641, 1], "end": [644, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_unique", "code": "theorem map_unique (j : S \u2192+* Q) (hj : \u2200 x : R, j (algebraMap R S x) = algebraMap P Q (g x)) :\n    map Q g hy = j", "start": [647, 1], "end": [649, 54], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_comp_map", "code": "theorem map_comp_map {A : Type*} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W]\n    [Algebra A W] [IsLocalization U W] {l : P \u2192+* A} (hl : T \u2264 U.comap l) :\n    (map W l hl).comp (map Q g hy : S \u2192+* _) = map W (l.comp g) fun _ hx => hl (hy hx)", "start": [652, 1], "end": [659, 68], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_map", "code": "theorem map_map {A : Type*} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [Algebra A W]\n    [IsLocalization U W] {l : P \u2192+* A} (hl : T \u2264 U.comap l) (x : S) :\n    map W l hl (map Q g hy x) = map W (l.comp g) (fun x hx => hl (hy hx)) x", "start": [662, 1], "end": [667, 42], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_smul", "code": "theorem map_smul (x : S) (z : R) : map Q g hy (z \u2022 x : S) = g z \u2022 map Q g hy x", "start": [670, 1], "end": [671, 67], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ringEquivOfRingEquiv", "code": "@[simps]\nnoncomputable def ringEquivOfRingEquiv (h : R \u2243+* P) (H : M.map h.toMonoidHom = T) : S \u2243+* Q :=\n  have H' : T.map h.symm.toMonoidHom = M := by\n    rw [\u2190 M.map_id, \u2190 H, Submonoid.map_map]\n    congr\n    ext\n    apply h.symm_apply_apply\n  { map Q (h : R \u2192+* P) (M.le_comap_of_map_le (le_of_eq H)) with\n    toFun := map Q (h : R \u2192+* P) (M.le_comap_of_map_le (le_of_eq H))\n    invFun := map S (h.symm : P \u2192+* R) (T.le_comap_of_map_le (le_of_eq H'))\n    left_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp\n    right_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp }", "start": [678, 1], "end": [696, 13], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ringEquivOfRingEquiv_eq_map", "code": "theorem ringEquivOfRingEquiv_eq_map {j : R \u2243+* P} (H : M.map j.toMonoidHom = T) :\n    (ringEquivOfRingEquiv S Q j H : S \u2192+* Q) =\n      map Q (j : R \u2192+* P) (M.le_comap_of_map_le (le_of_eq H))", "start": [701, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ringEquivOfRingEquiv_eq", "code": "theorem ringEquivOfRingEquiv_eq {j : R \u2243+* P} (H : M.map j.toMonoidHom = T) (x) :\n    ringEquivOfRingEquiv S Q j H ((algebraMap R S) x) = algebraMap P Q (j x)", "start": [708, 1], "end": [710, 7], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.ringEquivOfRingEquiv_mk'", "code": "theorem ringEquivOfRingEquiv_mk' {j : R \u2243+* P} (H : M.map j.toMonoidHom = T) (x : R) (y : M) :\n    ringEquivOfRingEquiv S Q j H (mk' S x y) =\n      mk' Q (j x) \u27e8j y, show j y \u2208 T from H \u25b8 Set.mem_image_of_mem j y.2\u27e9", "start": [713, 1], "end": [716, 17], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algEquiv", "code": "@[simps!]\nnoncomputable def algEquiv : S \u2243\u2090[R] Q :=\n  { ringEquivOfRingEquiv S Q (RingEquiv.refl R) M.map_id with\n    commutes' := ringEquivOfRingEquiv_eq _ }", "start": [729, 1], "end": [734, 45], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algEquiv_mk'", "code": "theorem algEquiv_mk' (x : R) (y : M) : algEquiv M S Q (mk' S x y) = mk' Q x y", "start": [740, 1], "end": [741, 10], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algEquiv_symm_mk'", "code": "theorem algEquiv_symm_mk' (x : R) (y : M) : (algEquiv M S Q).symm (mk' Q x y) = mk' S x y", "start": [745, 1], "end": [745, 101], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_of_algEquiv", "code": "theorem isLocalization_of_algEquiv [Algebra R P] [IsLocalization M S] (h : S \u2243\u2090[R] P) :\n    IsLocalization M P", "start": [756, 1], "end": [770, 8], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_iff_of_algEquiv", "code": "theorem isLocalization_iff_of_algEquiv [Algebra R P] (h : S \u2243\u2090[R] P) :\n    IsLocalization M S \u2194 IsLocalization M P", "start": [773, 1], "end": [775, 90], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_iff_of_ringEquiv", "code": "theorem isLocalization_iff_of_ringEquiv (h : S \u2243+* P) :\n    IsLocalization M S \u2194 @IsLocalization _ _ M P _ (h.toRingHom.comp <| algebraMap R S).toAlgebra", "start": [778, 1], "end": [781, 72], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_of_base_ringEquiv", "code": "theorem isLocalization_of_base_ringEquiv [IsLocalization M S] (h : R \u2243+* P) :\n    @IsLocalization _ _ (M.map h.toMonoidHom) S _\n      ((algebraMap R S).comp h.symm.toRingHom).toAlgebra", "start": [786, 1], "end": [807, 98], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isLocalization_iff_of_base_ringEquiv", "code": "theorem isLocalization_iff_of_base_ringEquiv (h : R \u2243+* P) :\n    IsLocalization M S \u2194\n      @IsLocalization _ _ (M.map h.toMonoidHom) S _\n        ((algebraMap R S).comp h.symm.toRingHom).toAlgebra", "start": [810, 1], "end": [824, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.nonZeroDivisors_le_comap", "code": "theorem nonZeroDivisors_le_comap [IsLocalization M S] :\n    nonZeroDivisors R \u2264 (nonZeroDivisors S).comap (algebraMap R S)", "start": [831, 1], "end": [840, 20], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_nonZeroDivisors_le", "code": "theorem map_nonZeroDivisors_le [IsLocalization M S] :\n    (nonZeroDivisors R).map (algebraMap R S) \u2264 nonZeroDivisors S", "start": [843, 1], "end": [845, 67], "kind": "commanddeclaration"}, {"full_name": "Localization.instUniqueLocalization", "code": "instance instUniqueLocalization [Subsingleton R] : Unique (Localization M) where\n  uniq a := show a = mk 1 1 from\n    Localization.induction_on a fun _ => by\n      congr <;> apply Subsingleton.elim", "start": [858, 1], "end": [861, 40], "kind": "commanddeclaration"}, {"full_name": "Localization.add", "code": "protected irreducible_def add (z w : Localization M) : Localization M :=\n  Localization.liftOn\u2082 z w (fun a b c d => mk ((b : R) * c + d * a) (b * d))\n    fun {a a' b b' c c' d d'} h1 h2 =>\n    mk_eq_mk_iff.2\n      (by\n        rw [r_eq_r'] at h1 h2 \u22a2\n        cases' h1 with t\u2085 ht\u2085\n        cases' h2 with t\u2086 ht\u2086\n        use t\u2085 * t\u2086\n        dsimp only\n        calc\n          \u2191t\u2085 * \u2191t\u2086 * (\u2191b' * \u2191d' * ((b : R) * c + d * a)) =\n              t\u2086 * (d' * c) * (t\u2085 * (b' * b)) + t\u2085 * (b' * a) * (t\u2086 * (d' * d)) :=\n            by ring\n          _ = t\u2085 * t\u2086 * (b * d * (b' * c' + d' * a')) := by rw [ht\u2086, ht\u2085]; ring\n          )", "start": [863, 1], "end": [883, 12], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.add_mk", "code": "theorem add_mk (a b c d) : (mk a b : Localization M) + mk c d =\n    mk ((b : R) * c + (d : R) * a) (b * d)", "start": [889, 1], "end": [892, 30], "kind": "commanddeclaration"}, {"full_name": "Localization.add_mk_self", "code": "theorem add_mk_self (a b c) : (mk a b : Localization M) + mk c b = mk (a + c) b", "start": [895, 1], "end": [899, 7], "kind": "commanddeclaration"}, {"full_name": "Localization.mkAddMonoidHom", "code": "@[simps]\ndef mkAddMonoidHom (b : M) : R \u2192+ Localization M where\n  toFun a := mk a b\n  map_zero' := mk_zero _\n  map_add' _ _ := (add_mk_self _ _ _).symm", "start": [937, 1], "end": [943, 43], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_sum", "code": "theorem mk_sum {\u03b9 : Type*} (f : \u03b9 \u2192 R) (s : Finset \u03b9) (b : M) :\n    mk (\u2211 i in s, f i) b = \u2211 i in s, mk (f i) b", "start": [946, 1], "end": [948, 33], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_list_sum", "code": "theorem mk_list_sum (l : List R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum", "start": [951, 1], "end": [952, 36], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_multiset_sum", "code": "theorem mk_multiset_sum (l : Multiset R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum", "start": [955, 1], "end": [956, 40], "kind": "commanddeclaration"}, {"full_name": "Localization.algebra", "code": "instance algebra {S : Type*} [CommSemiring S] [Algebra S R] : Algebra S (Localization M) where\n  toRingHom :=\n    RingHom.comp\n      { Localization.monoidOf M with\n        toFun := (monoidOf M).toMap\n        map_zero' := by rw [\u2190 mk_zero (1 : M), mk_one_eq_monoidOf_mk]\n        map_add' := fun x y => by\n          simp only [\u2190 mk_one_eq_monoidOf_mk, add_mk, Submonoid.coe_one, one_mul, add_comm] }\n      (algebraMap S R)\n  smul_def' s :=\n    Localization.ind <|\n      Prod.rec <| by\n        intro r x\n        dsimp\n        simp only [\u2190 mk_one_eq_monoidOf_mk, mk_mul, Localization.smul_mk, one_mul,\n          Algebra.smul_def]\n  commutes' s :=\n    Localization.ind <|\n      Prod.rec <| by\n        intro r x\n        dsimp\n        simp only [\u2190 mk_one_eq_monoidOf_mk, mk_mul, Localization.smul_mk, one_mul, mul_one,\n          Algebra.commutes]", "start": [987, 1], "end": [1009, 28], "kind": "commanddeclaration"}, {"full_name": "Localization.isLocalization", "code": "instance isLocalization : IsLocalization M (Localization M) where\n  map_units' := (Localization.monoidOf M).map_units\n  surj' := (Localization.monoidOf M).surj\n  eq_iff_exists' := (Localization.monoidOf M).eq_iff_exists", "start": [1011, 1], "end": [1014, 60], "kind": "commanddeclaration"}, {"full_name": "Localization.toLocalizationMap_eq_monoidOf", "code": "@[simp]\ntheorem toLocalizationMap_eq_monoidOf : toLocalizationMap M (Localization M) = monoidOf M", "start": [1018, 1], "end": [1020, 6], "kind": "commanddeclaration"}, {"full_name": "Localization.monoidOf_eq_algebraMap", "code": "theorem monoidOf_eq_algebraMap (x) : (monoidOf M).toMap x = algebraMap R (Localization M) x", "start": [1023, 1], "end": [1024, 6], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_one_eq_algebraMap", "code": "theorem mk_one_eq_algebraMap (x) : mk x 1 = algebraMap R (Localization M) x", "start": [1027, 1], "end": [1028, 6], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_mk'_apply", "code": "theorem mk_eq_mk'_apply (x y) : mk x y = IsLocalization.mk' (Localization M) x y", "start": [1031, 1], "end": [1032, 68], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_eq_mk'", "code": "theorem mk_eq_mk' : (mk : R \u2192 M \u2192 Localization M) = IsLocalization.mk' (Localization M)", "start": [1037, 1], "end": [1038, 21], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_algebraMap", "code": "theorem mk_algebraMap {A : Type*} [CommSemiring A] [Algebra A R] (m : A) :\n    mk (algebraMap A R m) 1 = algebraMap A (Localization M) m", "start": [1041, 1], "end": [1043, 78], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_nat_cast", "code": "theorem mk_nat_cast (m : \u2115) : (mk m 1 : Localization M) = m", "start": [1046, 1], "end": [1047, 43], "kind": "commanddeclaration"}, {"full_name": "Localization.algEquiv", "code": "@[simps!]\nnoncomputable def algEquiv : Localization M \u2243\u2090[R] S :=\n  IsLocalization.algEquiv M _ _", "start": [1056, 1], "end": [1059, 32], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.unique", "code": "noncomputable def _root_.IsLocalization.unique (R R\u2098) [CommSemiring R] [CommSemiring R\u2098]\n    (M : Submonoid R) [Subsingleton R] [Algebra R R\u2098] [IsLocalization M R\u2098] : Unique R\u2098 :=\n  have : Inhabited R\u2098 := \u27e81\u27e9\n  (algEquiv M R\u2098).symm.injective.unique", "start": [1062, 1], "end": [1066, 40], "kind": "commanddeclaration"}, {"full_name": "Localization.algEquiv_mk'", "code": "nonrec theorem algEquiv_mk' (x : R) (y : M) : algEquiv M S (mk' (Localization M) x y) = mk' S x y", "start": [1072, 1], "end": [1073, 19], "kind": "commanddeclaration"}, {"full_name": "Localization.algEquiv_symm_mk'", "code": "nonrec theorem algEquiv_symm_mk' (x : R) (y : M) :\n    (algEquiv M S).symm (mk' S x y) = mk' (Localization M) x y", "start": [1077, 1], "end": [1079, 24], "kind": "commanddeclaration"}, {"full_name": "Localization.algEquiv_mk", "code": "theorem algEquiv_mk (x y) : algEquiv M S (mk x y) = mk' S x y", "start": [1082, 1], "end": [1082, 97], "kind": "commanddeclaration"}, {"full_name": "Localization.algEquiv_symm_mk", "code": "theorem algEquiv_symm_mk (x : R) (y : M) : (algEquiv M S).symm (mk' S x y) = mk x y", "start": [1085, 1], "end": [1086, 36], "kind": "commanddeclaration"}, {"full_name": "Localization.neg", "code": "protected irreducible_def neg (z : Localization M) : Localization M :=\n  Localization.liftOn z (fun a b => mk (-a) b) fun {a b c d} h =>\n    mk_eq_mk_iff.2\n      (by\n        rw [r_eq_r'] at h \u22a2\n        cases' h with t ht\n        use t\n        rw [mul_neg, mul_neg, ht]\n        ring_nf)", "start": [1101, 1], "end": [1110, 17], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Localization.neg_mk", "code": "theorem neg_mk (a b) : -(mk a b : Localization M) = mk (-a) b", "start": [1116, 1], "end": [1119, 18], "kind": "commanddeclaration"}, {"full_name": "Localization.sub_mk", "code": "theorem sub_mk (a c) (b d) : (mk a b : Localization M) - mk c d =\n    mk ((d : R) * a - b * c) (b * d)", "start": [1147, 1], "end": [1153, 53], "kind": "commanddeclaration"}, {"full_name": "Localization.mk_int_cast", "code": "theorem mk_int_cast (m : \u2124) : (mk m 1 : Localization M) = m", "start": [1156, 1], "end": [1157, 43], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.to_map_eq_zero_iff", "code": "theorem to_map_eq_zero_iff {x : R} (hM : M \u2264 nonZeroDivisors R) : algebraMap R S x = 0 \u2194 x = 0", "start": [1166, 1], "end": [1172, 11], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.injective", "code": "protected theorem injective (hM : M \u2264 nonZeroDivisors R) : Injective (algebraMap R S)", "start": [1175, 1], "end": [1178, 38], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors", "code": "protected theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] (hM : M \u2264 nonZeroDivisors R)\n    {x : R} (hx : x \u2208 nonZeroDivisors R) : algebraMap R S x \u2260 0", "start": [1181, 1], "end": [1184, 91], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.sec_snd_ne_zero", "code": "theorem sec_snd_ne_zero [Nontrivial R] (hM : M \u2264 nonZeroDivisors R) (x : S) :\n    ((sec M x).snd : R) \u2260 0", "start": [1189, 1], "end": [1191, 77], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.sec_fst_ne_zero", "code": "theorem sec_fst_ne_zero [Nontrivial R] [NoZeroDivisors S] (hM : M \u2264 nonZeroDivisors R) {x : S}\n    (hx : x \u2260 0) : (sec M x).fst \u2260 0", "start": [1194, 1], "end": [1200, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_injective_of_injective", "code": "theorem map_injective_of_injective (hg : Function.Injective g)\n    [i : IsLocalization (M.map g : Submonoid P) Q] :\n    Function.Injective (@map _ _ _ _ _ _ _ _ _ _ Q _ _ i g (Submonoid.le_comap_map M) : S \u2192 Q)", "start": [1205, 1], "end": [1219, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.noZeroDivisors_of_le_nonZeroDivisors", "code": "@[reducible]\ntheorem noZeroDivisors_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M \u2264 nonZeroDivisors A) : NoZeroDivisors S", "start": [1226, 1], "end": [1242, 53], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isDomain_of_le_nonZeroDivisors", "code": "@[reducible]\ntheorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M \u2264 nonZeroDivisors A) : IsDomain S", "start": [1245, 1], "end": [1255, 52], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.isDomain_localization", "code": "@[reducible]\ntheorem isDomain_localization {M : Submonoid A} (hM : M \u2264 nonZeroDivisors A) :\n    IsDomain (Localization M)", "start": [1260, 1], "end": [1265, 38], "kind": "commanddeclaration"}, {"full_name": "IsField.localization_map_bijective", "code": "theorem IsField.localization_map_bijective {R R\u2098 : Type*} [CommRing R] [CommRing R\u2098]\n    {M : Submonoid R} (hM : (0 : R) \u2209 M) (hR : IsField R) [Algebra R R\u2098] [IsLocalization M R\u2098] :\n    Function.Bijective (algebraMap R R\u2098)", "start": [1272, 1], "end": [1281, 98], "kind": "commanddeclaration"}, {"full_name": "Field.localization_map_bijective", "code": "theorem Field.localization_map_bijective {K K\u2098 : Type*} [Field K] [CommRing K\u2098] {M : Submonoid K}\n    (hM : (0 : K) \u2209 M) [Algebra K K\u2098] [IsLocalization M K\u2098] :\n    Function.Bijective (algebraMap K K\u2098)", "start": [1284, 1], "end": [1288, 52], "kind": "commanddeclaration"}, {"full_name": "localizationAlgebra", "code": "noncomputable def localizationAlgebra : Algebra R\u2098 S\u2098 :=\n  (map S\u2098 (algebraMap R S)\n        (show _ \u2264 (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) :\n      R\u2098 \u2192+* S\u2098).toAlgebra", "start": [1305, 1], "end": [1318, 27], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.map_units_map_submonoid", "code": "theorem IsLocalization.map_units_map_submonoid (y : M) : IsUnit (algebraMap R S\u2098 y)", "start": [1329, 1], "end": [1331, 97], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algebraMap_mk'", "code": "@[simp]\ntheorem IsLocalization.algebraMap_mk' (x : R) (y : M) :\n    algebraMap R\u2098 S\u2098 (IsLocalization.mk' R\u2098 x y) =\n      IsLocalization.mk' S\u2098 (algebraMap R S x)\n        \u27e8algebraMap R S y, Algebra.mem_algebraMapSubmonoid_of_mem y\u27e9", "start": [1334, 1], "end": [1343, 78], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algebraMap_eq_map_map_submonoid", "code": "theorem IsLocalization.algebraMap_eq_map_map_submonoid :\n    algebraMap R\u2098 S\u2098 =\n      map S\u2098 (algebraMap R S)\n        (show _ \u2264 (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map)", "start": [1348, 1], "end": [1361, 93], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.algebraMap_apply_eq_map_map_submonoid", "code": "theorem IsLocalization.algebraMap_apply_eq_map_map_submonoid (x) :\n    algebraMap R\u2098 S\u2098 x =\n      map S\u2098 (algebraMap R S)\n        (show _ \u2264 (Algebra.algebraMapSubmonoid S M).comap _ from M.le_comap_map) x", "start": [1364, 1], "end": [1375, 79], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_algebraMap_eq_algebraMap", "code": "theorem IsLocalization.lift_algebraMap_eq_algebraMap :\n    @IsLocalization.lift R _ M R\u2098 _ _ S\u2098 _ _ (algebraMap R S\u2098)\n        (IsLocalization.map_units_map_submonoid S S\u2098) =\n      algebraMap R\u2098 S\u2098", "start": [1378, 1], "end": [1382, 86], "kind": "commanddeclaration"}, {"full_name": "localizationAlgebra_injective", "code": "theorem localizationAlgebra_injective (hRS : Function.Injective (algebraMap R S)) :\n    Function.Injective (@algebraMap R\u2098 S\u2098 _ _ (localizationAlgebra M S))", "start": [1389, 1], "end": [1394, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Monic.lean", "imports": ["Mathlib/Algebra/Regular/SMul.lean", "Mathlib/Data/Polynomial/Reverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.monic_zero_iff_subsingleton", "code": "theorem monic_zero_iff_subsingleton : Monic (0 : R[X]) \u2194 Subsingleton R", "start": [35, 1], "end": [36, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_monic_zero_iff", "code": "theorem not_monic_zero_iff : \u00acMonic (0 : R[X]) \u2194 (0 : R) \u2260 1", "start": [39, 1], "end": [40, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_zero_iff_subsingleton'", "code": "theorem monic_zero_iff_subsingleton' :\n    Monic (0 : R[X]) \u2194 (\u2200 f g : R[X], f = g) \u2227 \u2200 a b : R, a = b", "start": [43, 1], "end": [48, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.as_sum", "code": "theorem Monic.as_sum (hp : p.Monic) :\n    p = X ^ p.natDegree + \u2211 i in range p.natDegree, C (p.coeff i) * X ^ i", "start": [51, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_ne_zero_of_monic", "code": "theorem ne_zero_of_ne_zero_of_monic (hp : p \u2260 0) (hq : Monic q) : q \u2260 0", "start": [58, 1], "end": [62, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.map", "code": "theorem Monic.map [Semiring S] (f : R \u2192+* S) (hp : Monic p) : Monic (p.map f)", "start": [65, 1], "end": [73, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_C_mul_of_mul_leadingCoeff_eq_one", "code": "theorem monic_C_mul_of_mul_leadingCoeff_eq_one {b : R} (hp : b * p.leadingCoeff = 1) :\n    Monic (C b * p)", "start": [76, 1], "end": [80, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_mul_C_of_leadingCoeff_mul_eq_one", "code": "theorem monic_mul_C_of_leadingCoeff_mul_eq_one {b : R} (hp : p.leadingCoeff * b = 1) :\n    Monic (p * C b)", "start": [84, 1], "end": [88, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_degree_le", "code": "theorem monic_of_degree_le (n : \u2115) (H1 : degree p \u2264 n) (H2 : coeff p n = 1) : Monic p", "start": [92, 1], "end": [96, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_pow_add", "code": "theorem monic_X_pow_add {n : \u2115} (H : degree p \u2264 n) : Monic (X ^ (n + 1) + p)", "start": [99, 1], "end": [103, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_add_C", "code": "theorem monic_X_add_C (x : R) : Monic (X + C x)", "start": [107, 1], "end": [108, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul", "code": "theorem Monic.mul (hp : Monic p) (hq : Monic q) : Monic (p * q)", "start": [112, 1], "end": [120, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.pow", "code": "theorem Monic.pow (hp : Monic p) : \u2200 n : \u2115, Monic (p ^ n)", "start": [123, 1], "end": [127, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.add_of_left", "code": "theorem Monic.add_of_left (hp : Monic p) (hpq : degree q < degree p) : Monic (p + q)", "start": [130, 1], "end": [131, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.add_of_right", "code": "theorem Monic.add_of_right (hq : Monic q) (hpq : degree p < degree q) : Monic (p + q)", "start": [134, 1], "end": [135, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.of_mul_monic_left", "code": "theorem Monic.of_mul_monic_left (hp : p.Monic) (hpq : (p * q).Monic) : q.Monic", "start": [138, 1], "end": [141, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.of_mul_monic_right", "code": "theorem Monic.of_mul_monic_right (hq : q.Monic) (hpq : (p * q).Monic) : p.Monic", "start": [144, 1], "end": [147, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_eq_zero_iff_eq_one", "code": "@[simp]\ntheorem natDegree_eq_zero_iff_eq_one (hp : p.Monic) : p.natDegree = 0 \u2194 p = 1", "start": [152, 1], "end": [162, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.degree_le_zero_iff_eq_one", "code": "@[simp]\ntheorem degree_le_zero_iff_eq_one (hp : p.Monic) : p.degree \u2264 0 \u2194 p = 1", "start": [165, 1], "end": [167, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_mul", "code": "theorem natDegree_mul (hp : p.Monic) (hq : q.Monic) :\n    (p * q).natDegree = p.natDegree + q.natDegree", "start": [170, 1], "end": [174, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.degree_mul_comm", "code": "theorem degree_mul_comm (hp : p.Monic) (q : R[X]) : (p * q).degree = (q * p).degree", "start": [177, 1], "end": [182, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_mul'", "code": "nonrec theorem natDegree_mul' (hp : p.Monic) (hq : q \u2260 0) :\n    (p * q).natDegree = p.natDegree + q.natDegree", "start": [185, 1], "end": [188, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_mul_comm", "code": "theorem natDegree_mul_comm (hp : p.Monic) (q : R[X]) : (p * q).natDegree = (q * p).natDegree", "start": [191, 1], "end": [195, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.not_dvd_of_natDegree_lt", "code": "theorem not_dvd_of_natDegree_lt (hp : Monic p) (h0 : q \u2260 0) (hl : natDegree q < natDegree p) :\n    \u00acp \u2223 q", "start": [198, 1], "end": [202, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.not_dvd_of_degree_lt", "code": "theorem not_dvd_of_degree_lt (hp : Monic p) (h0 : q \u2260 0) (hl : degree q < degree p) : \u00acp \u2223 q", "start": [205, 1], "end": [206, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.nextCoeff_mul", "code": "theorem nextCoeff_mul (hp : Monic p) (hq : Monic q) :\n    nextCoeff (p * q) = nextCoeff p + nextCoeff q", "start": [209, 1], "end": [215, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.eq_one_of_map_eq_one", "code": "theorem eq_one_of_map_eq_one {S : Type*} [Semiring S] [Nontrivial S] (f : R \u2192+* S) (hp : p.Monic)\n    (map_eq : p.map f = 1) : p = 1", "start": [218, 1], "end": [228, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_pow", "code": "theorem natDegree_pow (hp : p.Monic) (n : \u2115) : (p ^ n).natDegree = n * p.natDegree", "start": [231, 1], "end": [234, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pow_X_add_C", "code": "@[simp]\ntheorem natDegree_pow_X_add_C [Nontrivial R] (n : \u2115) (r : R) : ((X + C r) ^ n).natDegree = n", "start": [239, 1], "end": [241, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.eq_one_of_isUnit", "code": "theorem Monic.eq_one_of_isUnit (hm : Monic p) (hpu : IsUnit p) : p = 1", "start": [245, 1], "end": [250, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.isUnit_iff", "code": "theorem Monic.isUnit_iff (hm : p.Monic) : IsUnit p \u2194 p = 1", "start": [253, 1], "end": [254, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_multiset_prod_of_monic", "code": "theorem monic_multiset_prod_of_monic (t : Multiset \u03b9) (f : \u03b9 \u2192 R[X]) (ht : \u2200 i \u2208 t, Monic (f i)) :\n    Monic (t.map f).prod", "start": [263, 1], "end": [269, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_prod_of_monic", "code": "theorem monic_prod_of_monic (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) (hs : \u2200 i \u2208 s, Monic (f i)) :\n    Monic (\u220f i in s, f i)", "start": [272, 1], "end": [274, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.nextCoeff_multiset_prod", "code": "theorem Monic.nextCoeff_multiset_prod (t : Multiset \u03b9) (f : \u03b9 \u2192 R[X]) (h : \u2200 i \u2208 t, Monic (f i)) :\n    nextCoeff (t.map f).prod = (t.map fun i => nextCoeff (f i)).sum", "start": [277, 1], "end": [288, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.nextCoeff_prod", "code": "theorem Monic.nextCoeff_prod (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) (h : \u2200 i \u2208 s, Monic (f i)) :\n    nextCoeff (\u220f i in s, f i) = \u2211 i in s, nextCoeff (f i)", "start": [291, 1], "end": [293, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.natDegree_map", "code": "@[simp]\ntheorem Monic.natDegree_map [Semiring S] [Nontrivial S] {P : R[X]} (hmo : P.Monic) (f : R \u2192+* S) :\n    (P.map f).natDegree = P.natDegree", "start": [302, 1], "end": [307, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.degree_map", "code": "@[simp]\ntheorem Monic.degree_map [Semiring S] [Nontrivial S] {P : R[X]} (hmo : P.Monic) (f : R \u2192+* S) :\n    (P.map f).degree = P.degree", "start": [310, 1], "end": [319, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_map_eq_of_injective", "code": "theorem degree_map_eq_of_injective (p : R[X]) : degree (p.map f) = degree p", "start": [328, 1], "end": [333, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_map_eq_of_injective", "code": "theorem natDegree_map_eq_of_injective (p : R[X]) : natDegree (p.map f) = natDegree p", "start": [336, 1], "end": [337, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_map'", "code": "theorem leadingCoeff_map' (p : R[X]) : leadingCoeff (p.map f) = f (leadingCoeff p)", "start": [340, 1], "end": [342, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nextCoeff_map", "code": "theorem nextCoeff_map (p : R[X]) : (p.map f).nextCoeff = f p.nextCoeff", "start": [345, 1], "end": [348, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_of_injective", "code": "theorem leadingCoeff_of_injective (p : R[X]) : leadingCoeff (p.map f) = f (leadingCoeff p)", "start": [351, 1], "end": [353, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_injective", "code": "theorem monic_of_injective {p : R[X]} (hp : (p.map f).Monic) : p.Monic", "start": [356, 1], "end": [358, 66], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.monic_map_iff", "code": "theorem _root_.Function.Injective.monic_map_iff {p : R[X]} : p.Monic \u2194 (p.map f).Monic", "start": [361, 1], "end": [362, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_sub_C", "code": "theorem monic_X_sub_C (x : R) : Monic (X - C x)", "start": [373, 1], "end": [374, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_pow_sub", "code": "theorem monic_X_pow_sub {n : \u2115} (H : degree p \u2264 n) : Monic (X ^ (n + 1) - p)", "start": [378, 1], "end": [379, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_X_pow_sub_C", "code": "theorem monic_X_pow_sub_C {R : Type u} [Ring R] (a : R) {n : \u2115} (h : n \u2260 0) :\n    (X ^ n - C a).Monic", "start": [383, 1], "end": [388, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_isUnit_X_pow_sub_one", "code": "theorem not_isUnit_X_pow_sub_one (R : Type*) [CommRing R] [Nontrivial R] (n : \u2115) :\n    \u00acIsUnit (X ^ n - 1 : R[X])", "start": [392, 1], "end": [398, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.sub_of_left", "code": "theorem Monic.sub_of_left {p q : R[X]} (hp : Monic p) (hpq : degree q < degree p) :\n    Monic (p - q)", "start": [402, 1], "end": [406, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.sub_of_right", "code": "theorem Monic.sub_of_right {p q : R[X]} (hq : q.leadingCoeff = -1) (hpq : degree p < degree q) :\n    Monic (p - q)", "start": [409, 1], "end": [415, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_monic_zero", "code": "@[simp]\ntheorem not_monic_zero : \u00acMonic (0 : R[X])", "start": [424, 1], "end": [426, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul_left_ne_zero", "code": "theorem Monic.mul_left_ne_zero (hp : Monic p) {q : R[X]} (hq : q \u2260 0) : q * p \u2260 0", "start": [436, 1], "end": [443, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul_right_ne_zero", "code": "theorem Monic.mul_right_ne_zero (hp : Monic p) {q : R[X]} (hq : q \u2260 0) : p * q \u2260 0", "start": [446, 1], "end": [454, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul_natDegree_lt_iff", "code": "theorem Monic.mul_natDegree_lt_iff (h : Monic p) {q : R[X]} :\n    (p * q).natDegree < p.natDegree \u2194 p \u2260 1 \u2227 q = 0", "start": [457, 1], "end": [462, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul_right_eq_zero_iff", "code": "theorem Monic.mul_right_eq_zero_iff (h : Monic p) {q : R[X]} : p * q = 0 \u2194 q = 0", "start": [465, 1], "end": [466, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.mul_left_eq_zero_iff", "code": "theorem Monic.mul_left_eq_zero_iff (h : Monic p) {q : R[X]} : q * p = 0 \u2194 q = 0", "start": [469, 1], "end": [470, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.isRegular", "code": "theorem Monic.isRegular {R : Type*} [Ring R] {p : R[X]} (hp : Monic p) : IsRegular p", "start": [473, 1], "end": [480, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_smul_of_smul_regular", "code": "theorem degree_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k \u2022 p).degree = p.degree", "start": [483, 1], "end": [494, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_smul_of_smul_regular", "code": "theorem natDegree_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k \u2022 p).natDegree = p.natDegree", "start": [497, 1], "end": [505, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_smul_of_smul_regular", "code": "theorem leadingCoeff_smul_of_smul_regular {S : Type*} [Monoid S] [DistribMulAction S R] {k : S}\n    (p : R[X]) (h : IsSMulRegular R k) : (k \u2022 p).leadingCoeff = k \u2022 p.leadingCoeff", "start": [508, 1], "end": [511, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_of_isUnit_leadingCoeff_inv_smul", "code": "theorem monic_of_isUnit_leadingCoeff_inv_smul (h : IsUnit p.leadingCoeff) :\n    Monic (h.unit\u207b\u00b9 \u2022 p)", "start": [514, 1], "end": [519, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_leadingCoeff_mul_right_eq_zero_iff", "code": "theorem isUnit_leadingCoeff_mul_right_eq_zero_iff (h : IsUnit p.leadingCoeff) {q : R[X]} :\n    p * q = 0 \u2194 q = 0", "start": [522, 1], "end": [535, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_leadingCoeff_mul_left_eq_zero_iff", "code": "theorem isUnit_leadingCoeff_mul_left_eq_zero_iff (h : IsUnit p.leadingCoeff) {q : R[X]} :\n    q * p = 0 \u2194 q = 0", "start": [538, 1], "end": [548, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Inductions.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "Mathlib/Algebra/MonoidAlgebra/Division.lean", "Mathlib/Data/Polynomial/EraseLead.lean", "Mathlib/Data/Nat/Interval.lean", "Mathlib/Data/Polynomial/Induction.lean"], "premises": [{"full_name": "Polynomial.divX", "code": "def divX (p : R[X]) : R[X] :=\n  \u27e8AddMonoidAlgebra.divOf p.toFinsupp 1\u27e9", "start": [37, 1], "end": [40, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_divX", "code": "@[simp]\ntheorem coeff_divX : (divX p).coeff n = p.coeff (n + 1)", "start": [44, 1], "end": [46, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_mul_X_add", "code": "theorem divX_mul_X_add (p : R[X]) : divX p * X + C (p.coeff 0) = p", "start": [50, 1], "end": [51, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_mul_divX_add", "code": "@[simp]\ntheorem X_mul_divX_add (p : R[X]) : X * divX p + C (p.coeff 0) = p", "start": [55, 1], "end": [57, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_C", "code": "@[simp]\ntheorem divX_C (a : R) : divX (C a) = 0", "start": [59, 1], "end": [61, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_eq_zero_iff", "code": "theorem divX_eq_zero_iff : divX p = 0 \u2194 p = C (p.coeff 0)", "start": [65, 1], "end": [66, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_add", "code": "theorem divX_add : divX (p + q) = divX p + divX q", "start": [70, 1], "end": [71, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_zero", "code": "@[simp]\ntheorem divX_zero : divX (0 : R[X]) = 0", "start": [75, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_one", "code": "@[simp]\ntheorem divX_one : divX (1 : R[X]) = 0", "start": [78, 1], "end": [81, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_C_mul", "code": "@[simp]\ntheorem divX_C_mul : divX (C a * p) = C a * divX p", "start": [83, 1], "end": [86, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_X_pow", "code": "theorem divX_X_pow : divX (X ^ n : R[X]) = if (n = 0) then 0 else X ^ (n - 1)", "start": [88, 1], "end": [92, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_hom", "code": "noncomputable\ndef divX_hom : R[X] \u2192+ R[X] :=\n{ toFun := divX\n  map_zero' := divX_zero\n  map_add' := fun _ _ => divX_add }", "start": [94, 1], "end": [99, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_hom_toFun", "code": "@[simp] theorem divX_hom_toFun : divX_hom p = divX p", "start": [101, 1], "end": [101, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_divX_eq_natDegree_tsub_one", "code": "theorem natDegree_divX_eq_natDegree_tsub_one : p.divX.natDegree = p.natDegree - 1", "start": [103, 1], "end": [111, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_divX_le", "code": "theorem natDegree_divX_le : p.divX.natDegree \u2264 p.natDegree", "start": [113, 1], "end": [114, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divX_C_mul_X_pow", "code": "theorem divX_C_mul_X_pow : divX (C a * X ^ n) = if n = 0 then 0 else C a * X ^ (n - 1)", "start": [116, 1], "end": [117, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_divX_lt", "code": "theorem degree_divX_lt (hp0 : p \u2260 0) : (divX p).degree < p.degree", "start": [119, 1], "end": [143, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.recOnHorner", "code": "@[elab_as_elim]\nnoncomputable def recOnHorner {M : R[X] \u2192 Sort*} (p : R[X]) (M0 : M 0)\n    (MC : \u2200 p a, coeff p 0 = 0 \u2192 a \u2260 0 \u2192 M p \u2192 M (p + C a))\n    (MX : \u2200 p, p \u2260 0 \u2192 M p \u2192 M (p * X)) : M p :=\n  letI := Classical.decEq R\n  if hp : p = 0 then hp \u25b8 M0\n  else by\n    have wf : degree (divX p) < degree p := degree_divX_lt hp\n    rw [\u2190 divX_mul_X_add p] at *\n    exact\n      if hcp0 : coeff p 0 = 0 then by\n        rw [hcp0, C_0, add_zero]\n        exact\n          MX _ (fun h : divX p = 0 => by simp [h, hcp0] at hp) (recOnHorner (divX p) M0 MC MX)\n      else\n        MC _ _ (coeff_mul_X_zero _) hcp0\n          (if hpX0 : divX p = 0 then show M (divX p * X) by rw [hpX0, zero_mul]; exact M0\n          else MX (divX p) hpX0 (recOnHorner _ M0 MC MX))\ntermination_by _ => p.degree", "start": [147, 1], "end": [166, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_induction_on", "code": "@[elab_as_elim]\ntheorem degree_pos_induction_on {P : R[X] \u2192 Prop} (p : R[X]) (h0 : 0 < degree p)\n    (hC : \u2200 {a}, a \u2260 0 \u2192 P (C a * X)) (hX : \u2200 {p}, 0 < degree p \u2192 P p \u2192 P (p * X))\n    (hadd : \u2200 {p} {a}, 0 < degree p \u2192 P p \u2192 P (p + C a)) : P p", "start": [169, 1], "end": [193, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_ne_zero_induction_on", "code": "@[elab_as_elim]\ntheorem natDegree_ne_zero_induction_on {M : R[X] \u2192 Prop} {f : R[X]} (f0 : f.natDegree \u2260 0)\n    (h_C_add : \u2200 {a p}, M p \u2192 M (C a + p)) (h_add : \u2200 {p q}, M p \u2192 M q \u2192 M (p + q))\n    (h_monomial : \u2200 {n : \u2115} {a : R}, a \u2260 0 \u2192 n \u2260 0 \u2192 M (monomial n a)) : M f", "start": [196, 1], "end": [228, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/AlgebraMap.lean", "imports": ["Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/Data/Polynomial/Eval.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.algebraOfAlgebra", "code": "instance algebraOfAlgebra : Algebra R A[X]\n    where\n  smul_def' r p :=\n    toFinsupp_injective <| by\n      dsimp only [RingHom.toFun_eq_coe, RingHom.comp_apply]\n      rw [toFinsupp_smul, toFinsupp_mul, toFinsupp_C]\n      exact Algebra.smul_def' _ _\n  commutes' r p :=\n    toFinsupp_injective <| by\n      dsimp only [RingHom.toFun_eq_coe, RingHom.comp_apply]\n      simp_rw [toFinsupp_mul, toFinsupp_C]\n      convert Algebra.commutes' r p.toFinsupp\n  toRingHom := C.comp (algebraMap R A)", "start": [40, 1], "end": [53, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algebraMap_apply", "code": "theorem algebraMap_apply (r : R) : algebraMap R A[X] r = C (algebraMap R A r)", "start": [56, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_algebraMap", "code": "@[simp]\ntheorem toFinsupp_algebraMap (r : R) : (algebraMap R A[X] r).toFinsupp = algebraMap R _ r", "start": [60, 1], "end": [64, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_algebraMap", "code": "theorem ofFinsupp_algebraMap (r : R) : (\u27e8algebraMap R _ r\u27e9 : A[X]) = algebraMap R A[X] r", "start": [67, 1], "end": [68, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_eq_algebraMap", "code": "theorem C_eq_algebraMap (r : R) : C r = algebraMap R R[X] r", "start": [71, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algHom_ext'", "code": "@[ext 1100]\ntheorem algHom_ext' [Algebra R A'] [Algebra R B'] {f g : A'[X] \u2192\u2090[R] B'}\n    (h\u2081 : f.comp (IsScalarTower.toAlgHom R A' A'[X]) = g.comp (IsScalarTower.toAlgHom R A' A'[X]))\n    (h\u2082 : f X = g X) : f = g", "start": [83, 1], "end": [89, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsuppIsoAlg", "code": "@[simps!]\ndef toFinsuppIsoAlg : R[X] \u2243\u2090[R] R[\u2115] :=\n  { toFinsuppIso R with\n    commutes' := fun r => by\n      dsimp\n      exact toFinsupp_algebraMap _ }", "start": [95, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.subalgebraNontrivial", "code": "instance subalgebraNontrivial [Nontrivial A] : Nontrivial (Subalgebra R A[X]) :=\n  \u27e8\u27e8\u22a5, \u22a4, by\n      rw [Ne.def, SetLike.ext_iff, not_forall]\n      refine' \u27e8X, _\u27e9\n      simp only [Algebra.mem_bot, not_exists, Set.mem_range, iff_true_iff, Algebra.mem_top,\n        algebraMap_apply, not_forall]\n      intro x\n      rw [ext_iff, not_forall]\n      refine' \u27e81, _\u27e9\n      simp [coeff_C]\u27e9\u27e9", "start": [107, 1], "end": [116, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algHom_eval\u2082_algebraMap", "code": "@[simp]\ntheorem algHom_eval\u2082_algebraMap {R A B : Type*} [CommSemiring R] [Semiring A] [Semiring B]\n    [Algebra R A] [Algebra R B] (p : R[X]) (f : A \u2192\u2090[R] B) (a : A) :\n    f (eval\u2082 (algebraMap R A) a p) = eval\u2082 (algebraMap R B) (f a) p", "start": [118, 1], "end": [123, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_algebraMap_X", "code": "@[simp]\ntheorem eval\u2082_algebraMap_X {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] (p : R[X])\n    (f : R[X] \u2192\u2090[R] A) : eval\u2082 (algebraMap R A) (f X) p = f p", "start": [126, 1], "end": [132, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ringHom_eval\u2082_cast_int_ringHom", "code": "@[simp]\ntheorem ringHom_eval\u2082_cast_int_ringHom {R S : Type*} [Ring R] [Ring S] (p : \u2124[X]) (f : R \u2192+* S)\n    (r : R) : f (eval\u2082 (Int.castRingHom R) r p) = eval\u2082 (Int.castRingHom S) (f r) p", "start": [137, 1], "end": [140, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_int_castRingHom_X", "code": "@[simp]\ntheorem eval\u2082_int_castRingHom_X {R : Type*} [Ring R] (p : \u2124[X]) (f : \u2124[X] \u2192+* R) :\n    eval\u2082 (Int.castRingHom R) (f X) p = f p", "start": [143, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval", "code": "def aeval : R[X] \u2192\u2090[R] A :=\n  { eval\u2082RingHom' (algebraMap R A) x fun _a => Algebra.commutes _ _ with\n    commutes' := fun _r => eval\u2082_C _ _ }", "start": [162, 1], "end": [168, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.adjoin_X", "code": "@[simp]\ntheorem adjoin_X : Algebra.adjoin R ({X} : Set R[X]) = \u22a4", "start": [173, 1], "end": [178, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.algHom_ext", "code": "@[ext 1200]\ntheorem algHom_ext {f g : R[X] \u2192\u2090[R] A} (h : f X = g X) : f = g", "start": [182, 1], "end": [184, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_def", "code": "theorem aeval_def (p : R[X]) : aeval x p = eval\u2082 (algebraMap R A) x p", "start": [187, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_zero", "code": "theorem aeval_zero : aeval x (0 : R[X]) = 0", "start": [192, 1], "end": [193, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_X", "code": "@[simp]\ntheorem aeval_X : aeval x (X : R[X]) = x", "start": [196, 1], "end": [198, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_C", "code": "@[simp]\ntheorem aeval_C (r : R) : aeval x (C r) = algebraMap R A r", "start": [202, 1], "end": [204, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_monomial", "code": "@[simp]\ntheorem aeval_monomial {n : \u2115} {r : R} : aeval x (monomial n r) = algebraMap _ _ r * x ^ n", "start": [208, 1], "end": [210, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_X_pow", "code": "theorem aeval_X_pow {n : \u2115} : aeval x ((X : R[X]) ^ n) = x ^ n", "start": [214, 1], "end": [215, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_add", "code": "theorem aeval_add : aeval x (p + q) = aeval x p + aeval x q", "start": [220, 1], "end": [221, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_one", "code": "theorem aeval_one : aeval x (1 : R[X]) = 1", "start": [225, 1], "end": [226, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_bit0", "code": "@[deprecated]\ntheorem aeval_bit0 : aeval x (bit0 p) = bit0 (aeval x p)", "start": [233, 1], "end": [235, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_bit1", "code": "@[deprecated]\ntheorem aeval_bit1 : aeval x (bit1 p) = bit1 (aeval x p)", "start": [239, 1], "end": [241, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_nat_cast", "code": "theorem aeval_nat_cast (n : \u2115) : aeval x (n : R[X]) = n", "start": [247, 1], "end": [248, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_mul", "code": "theorem aeval_mul : aeval x (p * q) = aeval x p * aeval x q", "start": [251, 1], "end": [252, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_comp", "code": "theorem aeval_comp {A : Type*} [CommSemiring A] [Algebra R A] (x : A) :\n    aeval x (p.comp q) = aeval (aeval x q) p", "start": [255, 1], "end": [257, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algHom", "code": "theorem aeval_algHom (f : A \u2192\u2090[R] B) (x : A) : aeval (f x) = f.comp (aeval x)", "start": [260, 1], "end": [261, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_X_left", "code": "@[simp]\ntheorem aeval_X_left : aeval (X : R[X]) = AlgHom.id R R[X]", "start": [264, 1], "end": [266, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_X_left_apply", "code": "theorem aeval_X_left_apply (p : R[X]) : aeval X p = p", "start": [270, 1], "end": [271, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_unique", "code": "theorem eval_unique (\u03c6 : R[X] \u2192\u2090[R] A) (p) : \u03c6 p = eval\u2082 (algebraMap R A) (\u03c6 X) p", "start": [275, 1], "end": [276, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algHom_apply", "code": "theorem aeval_algHom_apply {F : Type*} [AlgHomClass F R A B] (f : F) (x : A) (p : R[X]) :\n    aeval (f x) p = f (aeval x p)", "start": [279, 1], "end": [283, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algEquiv", "code": "theorem aeval_algEquiv (f : A \u2243\u2090[R] B) (x : A) : aeval (f x) = (f : A \u2192\u2090[R] B).comp (aeval x)", "start": [286, 1], "end": [287, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_algebraMap_apply_eq_algebraMap_eval", "code": "theorem aeval_algebraMap_apply_eq_algebraMap_eval (x : R) (p : R[X]) :\n    aeval (algebraMap R A x) p = algebraMap R A (p.eval x)", "start": [290, 1], "end": [292, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_aeval_eq_eval", "code": "@[simp]\ntheorem coe_aeval_eq_eval (r : R) : (aeval r : R[X] \u2192 R) = eval r", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_aeval_eq_evalRingHom", "code": "@[simp]\ntheorem coe_aeval_eq_evalRingHom (x : R) :\n    ((aeval x : R[X] \u2192\u2090[R] R) : R[X] \u2192+* R) = evalRingHom x", "start": [300, 1], "end": [303, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_fn_apply", "code": "@[simp]\ntheorem aeval_fn_apply {X : Type*} (g : R[X]) (f : X \u2192 R) (x : X) :\n    ((aeval f) g) x = aeval (f x) g", "start": [306, 1], "end": [309, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_subalgebra_coe", "code": "@[norm_cast]\ntheorem aeval_subalgebra_coe (g : R[X]) {A : Type*} [Semiring A] [Algebra R A] (s : Subalgebra R A)\n    (f : s) : (aeval f g : A) = aeval (f : A) g", "start": [312, 1], "end": [315, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_eq_aeval_zero", "code": "theorem coeff_zero_eq_aeval_zero (p : R[X]) : p.coeff 0 = aeval 0 p", "start": [318, 1], "end": [319, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_eq_aeval_zero'", "code": "theorem coeff_zero_eq_aeval_zero' (p : R[X]) : algebraMap R A (p.coeff 0) = aeval (0 : A) p", "start": [322, 1], "end": [323, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_aeval_eq_aeval_map", "code": "theorem map_aeval_eq_aeval_map {S T U : Type*} [CommSemiring S] [CommSemiring T] [Semiring U]\n    [Algebra R S] [Algebra T U] {\u03c6 : R \u2192+* T} {\u03c8 : S \u2192+* U}\n    (h : (algebraMap T U).comp \u03c6 = \u03c8.comp (algebraMap R S)) (p : R[X]) (a : S) :\n    \u03c8 (aeval a p) = aeval (\u03c8 a) (p.map \u03c6)", "start": [326, 1], "end": [331, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_eq_zero_of_dvd_aeval_eq_zero", "code": "theorem aeval_eq_zero_of_dvd_aeval_eq_zero [CommSemiring S] [CommSemiring T] [Algebra S T]\n    {p q : S[X]} (h\u2081 : p \u2223 q) {a : T} (h\u2082 : aeval a p = 0) : aeval a q = 0", "start": [334, 1], "end": [337, 88], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_singleton_eq_range_aeval", "code": "theorem _root_.Algebra.adjoin_singleton_eq_range_aeval (x : A) :\n    Algebra.adjoin R {x} = (Polynomial.aeval x).range", "start": [342, 1], "end": [344, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_eq_sum_range", "code": "theorem aeval_eq_sum_range [Algebra R S] {p : R[X]} (x : S) :\n    aeval x p = \u2211 i in Finset.range (p.natDegree + 1), p.coeff i \u2022 x ^ i", "start": [353, 1], "end": [356, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_eq_sum_range'", "code": "theorem aeval_eq_sum_range' [Algebra R S] {p : R[X]} {n : \u2115} (hn : p.natDegree < n) (x : S) :\n    aeval x p = \u2211 i in Finset.range n, p.coeff i \u2022 x ^ i", "start": [359, 1], "end": [362, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_of_eval\u2082_map_eq_zero", "code": "theorem isRoot_of_eval\u2082_map_eq_zero (hf : Function.Injective f) {r : R} :\n    eval\u2082 f (f r) p = 0 \u2192 p.IsRoot r", "start": [365, 1], "end": [369, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_of_aeval_algebraMap_eq_zero", "code": "theorem isRoot_of_aeval_algebraMap_eq_zero [Algebra R S] {p : R[X]}\n    (inj : Function.Injective (algebraMap R S)) {r : R} (hr : aeval (algebraMap R S r) p = 0) :\n    p.IsRoot r", "start": [372, 1], "end": [375, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower", "code": "def aevalTower (f : R \u2192\u2090[S] A') (x : A') : R[X] \u2192\u2090[S] A' :=\n  { eval\u2082RingHom (\u2191f) x with commutes' := fun r => by simp [algebraMap_apply] }", "start": [386, 1], "end": [389, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_X", "code": "@[simp]\ntheorem aevalTower_X : aevalTower g y X = y", "start": [394, 1], "end": [396, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_C", "code": "@[simp]\ntheorem aevalTower_C (x : R) : aevalTower g y (C x) = g x", "start": [400, 1], "end": [402, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_comp_C", "code": "@[simp]\ntheorem aevalTower_comp_C : (aevalTower g y : R[X] \u2192+* A').comp C = g", "start": [406, 1], "end": [408, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_algebraMap", "code": "@[simp]\ntheorem aevalTower_algebraMap (x : R) : aevalTower g y (algebraMap R R[X] x) = g x", "start": [412, 1], "end": [414, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_comp_algebraMap", "code": "@[simp]\ntheorem aevalTower_comp_algebraMap : (aevalTower g y : R[X] \u2192+* A').comp (algebraMap R R[X]) = g", "start": [417, 1], "end": [419, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_toAlgHom", "code": "theorem aevalTower_toAlgHom (x : R) : aevalTower g y (IsScalarTower.toAlgHom S R R[X] x) = g x", "start": [422, 1], "end": [423, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_comp_toAlgHom", "code": "@[simp]\ntheorem aevalTower_comp_toAlgHom : (aevalTower g y).comp (IsScalarTower.toAlgHom S R R[X]) = g", "start": [426, 1], "end": [428, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_id", "code": "@[simp]\ntheorem aevalTower_id : aevalTower (AlgHom.id S S) = aeval", "start": [431, 1], "end": [434, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aevalTower_ofId", "code": "@[simp]\ntheorem aevalTower_ofId : aevalTower (Algebra.ofId S A') = aeval", "start": [437, 1], "end": [440, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_term_of_dvd_eval_of_dvd_terms", "code": "theorem dvd_term_of_dvd_eval_of_dvd_terms {z p : S} {f : S[X]} (i : \u2115) (dvd_eval : p \u2223 f.eval z)\n    (dvd_terms : \u2200 (j) (_ : j \u2260 i), p \u2223 f.coeff j * z ^ j) : p \u2223 f.coeff i * z ^ i", "start": [451, 1], "end": [462, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_term_of_isRoot_of_dvd_terms", "code": "theorem dvd_term_of_isRoot_of_dvd_terms {r p : S} {f : S[X]} (i : \u2115) (hr : f.IsRoot r)\n    (h : \u2200 (j) (_ : j \u2260 i), p \u2223 f.coeff j * r ^ j) : p \u2223 f.coeff i * r ^ i", "start": [465, 1], "end": [467, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_mul_X_sub_C", "code": "theorem eval_mul_X_sub_C {p : R[X]} (r : R) : (p * (X - C r)).eval r = 0", "start": [478, 1], "end": [500, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_isUnit_X_sub_C", "code": "theorem not_isUnit_X_sub_C [Nontrivial R] (r : R) : \u00acIsUnit (X - C r)", "start": [504, 1], "end": [505, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_endomorphism", "code": "theorem aeval_endomorphism {M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (f : M \u2192\u2097[R] M)\n    (v : M) (p : R[X]) : aeval f p v = p.sum fun n b => b \u2022 (f ^ n) v", "start": [511, 1], "end": [514, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/OuterMeasure.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/PiSystem.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Data/Countable/Basic.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "MeasureTheory.OuterMeasure", "code": "structure OuterMeasure (\u03b1 : Type*) where\n  measureOf : Set \u03b1 \u2192 \u211d\u22650\u221e\n  empty : measureOf \u2205 = 0\n  mono : \u2200 {s\u2081 s\u2082}, s\u2081 \u2286 s\u2082 \u2192 measureOf s\u2081 \u2264 measureOf s\u2082\n  iUnion_nat : \u2200 s : \u2115 \u2192 Set \u03b1, measureOf (\u22c3 i, s i) \u2264 \u2211' i, measureOf (s i)", "start": [66, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instCoeFun", "code": "instance instCoeFun : CoeFun (OuterMeasure \u03b1) (fun _ => Set \u03b1 \u2192 \u211d\u22650\u221e) where\n  coe m := m.measureOf", "start": [84, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.empty'", "code": "@[simp]\ntheorem empty' (m : OuterMeasure \u03b1) : m \u2205 = 0", "start": [92, 1], "end": [94, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mono'", "code": "theorem mono' (m : OuterMeasure \u03b1) {s\u2081 s\u2082} (h : s\u2081 \u2286 s\u2082) : m s\u2081 \u2264 m s\u2082", "start": [97, 1], "end": [98, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mono_null", "code": "theorem mono_null (m : OuterMeasure \u03b1) {s t} (h : s \u2286 t) (ht : m t = 0) : m s = 0", "start": [101, 1], "end": [102, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.pos_of_subset_ne_zero", "code": "theorem pos_of_subset_ne_zero (m : OuterMeasure \u03b1) {a b : Set \u03b1} (hs : a \u2286 b) (hnz : m a \u2260 0) :\n    0 < m b", "start": [105, 1], "end": [107, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion", "code": "protected theorem iUnion (m : OuterMeasure \u03b1) {\u03b2} [Countable \u03b2] (s : \u03b2 \u2192 Set \u03b1) :\n    m (\u22c3 i, s i) \u2264 \u2211' i, m (s i)", "start": [110, 1], "end": [112, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_null", "code": "theorem iUnion_null [Countable \u03b2] (m : OuterMeasure \u03b1) {s : \u03b2 \u2192 Set \u03b1} (h : \u2200 i, m (s i) = 0) :\n    m (\u22c3 i, s i) = 0", "start": [115, 1], "end": [116, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_null_iff", "code": "@[simp]\ntheorem iUnion_null_iff [Countable \u03b2] (m : OuterMeasure \u03b1) {s : \u03b2 \u2192 Set \u03b1} :\n    m (\u22c3 i, s i) = 0 \u2194 \u2200 i, m (s i) = 0", "start": [119, 1], "end": [122, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_null_iff'", "code": "@[simp]\ntheorem iUnion_null_iff' (m : OuterMeasure \u03b1) {\u03b9 : Prop} {s : \u03b9 \u2192 Set \u03b1} :\n    m (\u22c3 i, s i) = 0 \u2194 \u2200 i, m (s i) = 0", "start": [125, 1], "end": [132, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.biUnion_null_iff", "code": "theorem biUnion_null_iff (m : OuterMeasure \u03b1) {s : Set \u03b2} (hs : s.Countable) {t : \u03b2 \u2192 Set \u03b1} :\n    m (\u22c3 i \u2208 s, t i) = 0 \u2194 \u2200 i \u2208 s, m (t i) = 0", "start": [135, 1], "end": [138, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sUnion_null_iff", "code": "theorem sUnion_null_iff (m : OuterMeasure \u03b1) {S : Set (Set \u03b1)} (hS : S.Countable) :\n    m (\u22c3\u2080 S) = 0 \u2194 \u2200 s \u2208 S, m s = 0", "start": [141, 1], "end": [142, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_finset", "code": "protected theorem iUnion_finset (m : OuterMeasure \u03b1) (s : \u03b2 \u2192 Set \u03b1) (t : Finset \u03b2) :\n    m (\u22c3 i \u2208 t, s i) \u2264 \u2211 i in t, m (s i)", "start": [145, 1], "end": [147, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.union", "code": "protected theorem union (m : OuterMeasure \u03b1) (s\u2081 s\u2082 : Set \u03b1) : m (s\u2081 \u222a s\u2082) \u2264 m s\u2081 + m s\u2082", "start": [150, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.null_of_locally_null", "code": "theorem null_of_locally_null [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] (m : OuterMeasure \u03b1)\n    (s : Set \u03b1) (hs : \u2200 x \u2208 s, \u2203 u \u2208 \ud835\udcdd[s] x, m u = 0) : m s = 0", "start": [154, 1], "end": [162, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.exists_mem_forall_mem_nhds_within_pos", "code": "theorem exists_mem_forall_mem_nhds_within_pos [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    (m : OuterMeasure \u03b1) {s : Set \u03b1} (hs : m s \u2260 0) : \u2203 x \u2208 s, \u2200 t \u2208 \ud835\udcdd[s] x, 0 < m t", "start": [165, 1], "end": [170, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_of_tendsto_zero", "code": "theorem iUnion_of_tendsto_zero {\u03b9} (m : OuterMeasure \u03b1) {s : \u03b9 \u2192 Set \u03b1} (l : Filter \u03b9) [NeBot l]\n    (h0 : Tendsto (fun k => m ((\u22c3 n, s n) \\ s k)) l (\ud835\udcdd 0)) : m (\u22c3 n, s n) = \u2a06 n, m (s n)", "start": [173, 1], "end": [188, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_nat_of_monotone_of_tsum_ne_top", "code": "theorem iUnion_nat_of_monotone_of_tsum_ne_top (m : OuterMeasure \u03b1) {s : \u2115 \u2192 Set \u03b1}\n    (h_mono : \u2200 n, s n \u2286 s (n + 1)) (h0 : (\u2211' k, m (s (k + 1) \\ s k)) \u2260 \u221e)\n    [\u2200 i:\u2115, DecidablePred (\u00b7 \u2208 s i)] : m (\u22c3 n, s n) = \u2a06 n, m (s n)", "start": [191, 1], "end": [211, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_inter_add_diff", "code": "theorem le_inter_add_diff {m : OuterMeasure \u03b1} {t : Set \u03b1} (s : Set \u03b1) :\n    m t \u2264 m (t \u2229 s) + m (t \\ s)", "start": [214, 1], "end": [217, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.diff_null", "code": "theorem diff_null (m : OuterMeasure \u03b1) (s : Set \u03b1) {t : Set \u03b1} (ht : m t = 0) :\n    m (s \\ t) = m s", "start": [220, 1], "end": [226, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.union_null", "code": "theorem union_null (m : OuterMeasure \u03b1) {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : m s\u2081 = 0) (h\u2082 : m s\u2082 = 0) :\n    m (s\u2081 \u222a s\u2082) = 0", "start": [229, 1], "end": [230, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_fn_injective", "code": "theorem coe_fn_injective : Injective fun (\u03bc : OuterMeasure \u03b1) (s : Set \u03b1) => \u03bc s", "start": [233, 1], "end": [234, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ext", "code": "@[ext]\ntheorem ext {\u03bc\u2081 \u03bc\u2082 : OuterMeasure \u03b1} (h : \u2200 s, \u03bc\u2081 s = \u03bc\u2082 s) : \u03bc\u2081 = \u03bc\u2082", "start": [237, 1], "end": [239, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ext_nonempty", "code": "theorem ext_nonempty {\u03bc\u2081 \u03bc\u2082 : OuterMeasure \u03b1} (h : \u2200 s : Set \u03b1, s.Nonempty \u2192 \u03bc\u2081 s = \u03bc\u2082 s) :\n    \u03bc\u2081 = \u03bc\u2082", "start": [242, 1], "end": [246, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instZero", "code": "instance instZero : Zero (OuterMeasure \u03b1) :=\n  \u27e8{  measureOf := fun _ => 0\n      empty := rfl\n      mono := by intro _ _ _; exact le_refl 0\n      iUnion_nat := fun s => zero_le _ }\u27e9", "start": [249, 1], "end": [253, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : OuterMeasure \u03b1) = 0", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instInhabited", "code": "instance instInhabited : Inhabited (OuterMeasure \u03b1) :=\n  \u27e80\u27e9", "start": [261, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instAdd", "code": "instance instAdd : Add (OuterMeasure \u03b1) :=\n  \u27e8fun m\u2081 m\u2082 =>\n    { measureOf := fun s => m\u2081 s + m\u2082 s\n      empty := show m\u2081 \u2205 + m\u2082 \u2205 = 0 by simp [OuterMeasure.empty]\n      mono := fun {s\u2081 s\u2082} h => add_le_add (m\u2081.mono h) (m\u2082.mono h)\n      iUnion_nat := fun s =>\n        calc\n          m\u2081 (\u22c3 i, s i) + m\u2082 (\u22c3 i, s i) \u2264 (\u2211' i, m\u2081 (s i)) + \u2211' i, m\u2082 (s i) :=\n            add_le_add (m\u2081.iUnion_nat s) (m\u2082.iUnion_nat s)\n          _ = _ := ENNReal.tsum_add.symm\n           }\u27e9", "start": [265, 1], "end": [275, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_add", "code": "@[simp]\ntheorem coe_add (m\u2081 m\u2082 : OuterMeasure \u03b1) : \u21d1(m\u2081 + m\u2082) = m\u2081 + m\u2082", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.add_apply", "code": "theorem add_apply (m\u2081 m\u2082 : OuterMeasure \u03b1) (s : Set \u03b1) : (m\u2081 + m\u2082) s = m\u2081 s + m\u2082 s", "start": [283, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instSMul", "code": "instance instSMul : SMul R (OuterMeasure \u03b1) :=\n  \u27e8fun c m =>\n    { measureOf := fun s => c \u2022 m s\n      empty := by simp; rw [\u2190 smul_one_mul c]; simp\n      mono := fun {s t} h => by\n        simp only\n        rw [\u2190 smul_one_mul c, \u2190 smul_one_mul c (m t)]\n        exact ENNReal.mul_left_mono (m.mono h)\n      iUnion_nat := fun s => by\n        simp_rw [\u2190 smul_one_mul c (m _), ENNReal.tsum_mul_left]\n        exact ENNReal.mul_left_mono (m.iUnion_nat _) }\u27e9", "start": [293, 1], "end": [303, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_smul", "code": "@[simp]\ntheorem coe_smul (c : R) (m : OuterMeasure \u03b1) : \u21d1(c \u2022 m) = c \u2022 \u21d1m", "start": [305, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.smul_apply", "code": "theorem smul_apply (c : R) (m : OuterMeasure \u03b1) (s : Set \u03b1) : (c \u2022 m) s = c \u2022 m s", "start": [310, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass R R' \u211d\u22650\u221e] : SMulCommClass R R' (OuterMeasure \u03b1) :=\n  \u27e8fun _ _ _ => ext fun _ => smul_comm _ _ _\u27e9", "start": [314, 1], "end": [315, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instIsScalarTower", "code": "instance instIsScalarTower [SMul R R'] [IsScalarTower R R' \u211d\u22650\u221e] :\n    IsScalarTower R R' (OuterMeasure \u03b1) :=\n  \u27e8fun _ _ _ => ext fun _ => smul_assoc _ _ _\u27e9", "start": [318, 1], "end": [320, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instIsCentralScalar", "code": "instance instIsCentralScalar [SMul R\u1d50\u1d52\u1d56 \u211d\u22650\u221e] [IsCentralScalar R \u211d\u22650\u221e] :\n    IsCentralScalar R (OuterMeasure \u03b1) :=\n  \u27e8fun _ _ => ext fun _ => op_smul_eq_smul _ _\u27e9", "start": [323, 1], "end": [325, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instMulAction", "code": "instance instMulAction [Monoid R] [MulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] :\n    MulAction R (OuterMeasure \u03b1) :=\n  Injective.mulAction _ coe_fn_injective coe_smul", "start": [330, 1], "end": [332, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (OuterMeasure \u03b1) :=\n  Injective.addCommMonoid (show OuterMeasure \u03b1 \u2192 Set \u03b1 \u2192 \u211d\u22650\u221e from _) coe_fn_injective rfl\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [335, 1], "end": [337, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coeFnAddMonoidHom", "code": "@[simps]\ndef coeFnAddMonoidHom : OuterMeasure \u03b1 \u2192+ Set \u03b1 \u2192 \u211d\u22650\u221e where\n  toFun := (\u21d1)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [340, 1], "end": [345, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instDistribMulAction", "code": "instance instDistribMulAction [Monoid R] [DistribMulAction R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] :\n    DistribMulAction R (OuterMeasure \u03b1) :=\n  Injective.distribMulAction coeFnAddMonoidHom coe_fn_injective coe_smul", "start": [348, 1], "end": [350, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instModule", "code": "instance instModule [Semiring R] [Module R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] :\n    Module R (OuterMeasure \u03b1) :=\n  Injective.module R coeFnAddMonoidHom coe_fn_injective coe_smul", "start": [353, 1], "end": [355, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instBot", "code": "instance instBot : Bot (OuterMeasure \u03b1) :=\n  \u27e80\u27e9", "start": [358, 1], "end": [359, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_bot", "code": "@[simp]\ntheorem coe_bot : (\u22a5 : OuterMeasure \u03b1) = 0", "start": [362, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instPartialOrder", "code": "instance instPartialOrder : PartialOrder (OuterMeasure \u03b1) where\n  le m\u2081 m\u2082 := \u2200 s, m\u2081 s \u2264 m\u2082 s\n  le_refl a s := le_rfl\n  le_trans a b c hab hbc s := le_trans (hab s) (hbc s)\n  le_antisymm a b hab hba := ext fun s => le_antisymm (hab s) (hba s)", "start": [367, 1], "end": [371, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.OuterMeasure.orderBot", "code": "instance OuterMeasure.orderBot : OrderBot (OuterMeasure \u03b1) :=\n  { bot := 0,\n    bot_le := fun a s => by simp only [coe_zero, Pi.zero_apply, coe_bot, zero_le] }", "start": [374, 1], "end": [376, 84], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.univ_eq_zero_iff", "code": "theorem univ_eq_zero_iff (m : OuterMeasure \u03b1) : m univ = 0 \u2194 m = 0", "start": [379, 1], "end": [380, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instSupSet", "code": "instance instSupSet : SupSet (OuterMeasure \u03b1) :=\n  \u27e8fun ms =>\n    { measureOf := fun s => \u2a06 m \u2208 ms, (m : OuterMeasure \u03b1) s\n      empty := nonpos_iff_eq_zero.1 <| iSup\u2082_le fun m _ => le_of_eq m.empty\n      mono := fun {s\u2081 s\u2082} hs => iSup\u2082_mono fun m _ => m.mono hs\n      iUnion_nat := fun f =>\n        iSup\u2082_le fun m hm =>\n          calc\n            m (\u22c3 i, f i) \u2264 \u2211' i : \u2115, m (f i) := m.iUnion_nat _\n            _ \u2264 \u2211' i, \u2a06 m \u2208 ms, (m : OuterMeasure \u03b1) (f i) :=\n               ENNReal.tsum_le_tsum fun i => by apply le_iSup\u2082 m hm\n             }\u27e9", "start": [385, 1], "end": [396, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instCompleteLattice", "code": "instance instCompleteLattice : CompleteLattice (OuterMeasure \u03b1) :=\n  { OuterMeasure.orderBot,\n    completeLatticeOfSup (OuterMeasure \u03b1) fun ms =>\n      \u27e8fun m hm s => by apply le_iSup\u2082 m hm, fun m hm s => iSup\u2082_le fun m' hm' => hm hm' s\u27e9 with }", "start": [399, 1], "end": [402, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sSup_apply", "code": "@[simp]\ntheorem sSup_apply (ms : Set (OuterMeasure \u03b1)) (s : Set \u03b1) :\n    (sSup ms) s = \u2a06 m \u2208 ms, (m : OuterMeasure \u03b1) s", "start": [405, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iSup_apply", "code": "@[simp]\ntheorem iSup_apply {\u03b9} (f : \u03b9 \u2192 OuterMeasure \u03b1) (s : Set \u03b1) : (\u2a06 i : \u03b9, f i) s = \u2a06 i, f i s", "start": [411, 1], "end": [413, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.coe_iSup", "code": "@[norm_cast]\ntheorem coe_iSup {\u03b9} (f : \u03b9 \u2192 OuterMeasure \u03b1) : \u21d1(\u2a06 i, f i) = \u2a06 i, \u21d1(f i)", "start": [416, 1], "end": [418, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sup_apply", "code": "@[simp]\ntheorem sup_apply (m\u2081 m\u2082 : OuterMeasure \u03b1) (s : Set \u03b1) : (m\u2081 \u2294 m\u2082) s = m\u2081 s \u2294 m\u2082 s", "start": [421, 1], "end": [423, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.smul_iSup", "code": "theorem smul_iSup [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] {\u03b9} (f : \u03b9 \u2192 OuterMeasure \u03b1) (c : R) :\n    (c \u2022 \u2a06 i, f i) = \u2a06 i, c \u2022 f i", "start": [426, 1], "end": [428, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.mono''", "code": "@[mono]\ntheorem mono'' {m\u2081 m\u2082 : OuterMeasure \u03b1} {s\u2081 s\u2082 : Set \u03b1} (hm : m\u2081 \u2264 m\u2082) (hs : s\u2081 \u2286 s\u2082) :\n    m\u2081 s\u2081 \u2264 m\u2082 s\u2082", "start": [433, 1], "end": [436, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map", "code": "def map {\u03b2} (f : \u03b1 \u2192 \u03b2) : OuterMeasure \u03b1 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b2 where\n  toFun m :=\n    { measureOf := fun s => m (f \u207b\u00b9' s)\n      empty := m.empty\n      mono := fun {s t} h => m.mono (preimage_mono h)\n      iUnion_nat := fun s => by simp; apply m.iUnion_nat fun i => f \u207b\u00b9' s i }\n  map_add' m\u2081 m\u2082 := coe_fn_injective rfl\n  map_smul' c m := coe_fn_injective rfl", "start": [439, 1], "end": [447, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_apply", "code": "@[simp]\ntheorem map_apply {\u03b2} (f : \u03b1 \u2192 \u03b2) (m : OuterMeasure \u03b1) (s : Set \u03b2) : map f m s = m (f \u207b\u00b9' s)", "start": [450, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_id", "code": "@[simp]\ntheorem map_id (m : OuterMeasure \u03b1) : map id m = m", "start": [455, 1], "end": [457, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_map", "code": "@[simp]\ntheorem map_map {\u03b2 \u03b3} (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (m : OuterMeasure \u03b1) :\n    map g (map f m) = map (g \u2218 f) m", "start": [460, 1], "end": [463, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_mono", "code": "@[mono]\ntheorem map_mono {\u03b2} (f : \u03b1 \u2192 \u03b2) : Monotone (map f)", "start": [466, 1], "end": [467, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_sup", "code": "@[simp]\ntheorem map_sup {\u03b2} (f : \u03b1 \u2192 \u03b2) (m m' : OuterMeasure \u03b1) : map f (m \u2294 m') = map f m \u2294 map f m'", "start": [470, 1], "end": [472, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_iSup", "code": "@[simp]\ntheorem map_iSup {\u03b2 \u03b9} (f : \u03b1 \u2192 \u03b2) (m : \u03b9 \u2192 OuterMeasure \u03b1) : map f (\u2a06 i, m i) = \u2a06 i, map f (m i)", "start": [475, 1], "end": [477, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instFunctor", "code": "instance instFunctor : Functor OuterMeasure where map {_ _} f := map f", "start": [480, 1], "end": [480, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.instLawfulFunctor", "code": "instance instLawfulFunctor : LawfulFunctor OuterMeasure := by constructor <;> intros <;> rfl", "start": [483, 1], "end": [483, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.dirac", "code": "def dirac (a : \u03b1) : OuterMeasure \u03b1 where\n  measureOf s := indicator s (fun _ => 1) a\n  empty := by simp\n  mono {s t} h := indicator_le_indicator_of_subset h (fun _ => zero_le _) a\n  iUnion_nat s :=\n    if hs : a \u2208 \u22c3 n, s n then\n      let \u27e8i, hi\u27e9 := mem_iUnion.1 hs\n      calc\n        indicator (\u22c3 n, s n) (fun _ => (1 : \u211d\u22650\u221e)) a = 1 := indicator_of_mem hs _\n        _ = indicator (s i) (fun _ => 1) a := Eq.symm (indicator_of_mem hi _)\n        _ \u2264 \u2211' n, indicator (s n) (fun _ => 1) a := ENNReal.le_tsum _\n\n    else by simp only [indicator_of_not_mem hs, zero_le]", "start": [486, 1], "end": [499, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.dirac_apply", "code": "@[simp]\ntheorem dirac_apply (a : \u03b1) (s : Set \u03b1) : dirac a s = indicator s (fun _ => 1) a", "start": [502, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sum", "code": "def sum {\u03b9} (f : \u03b9 \u2192 OuterMeasure \u03b1) : OuterMeasure \u03b1 where\n  measureOf s := \u2211' i, f i s\n  empty := by simp\n  mono {s t} h := ENNReal.tsum_le_tsum fun i => (f i).mono' h\n  iUnion_nat s := by\n    rw [ENNReal.tsum_comm]; exact ENNReal.tsum_le_tsum fun i => (f i).iUnion_nat _", "start": [507, 1], "end": [513, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sum_apply", "code": "@[simp]\ntheorem sum_apply {\u03b9} (f : \u03b9 \u2192 OuterMeasure \u03b1) (s : Set \u03b1) : sum f s = \u2211' i, f i s", "start": [516, 1], "end": [518, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.smul_dirac_apply", "code": "theorem smul_dirac_apply (a : \u211d\u22650\u221e) (b : \u03b1) (s : Set \u03b1) :\n    (a \u2022 dirac b) s = indicator s (fun _ => a) b", "start": [521, 1], "end": [523, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap", "code": "def comap {\u03b2} (f : \u03b1 \u2192 \u03b2) : OuterMeasure \u03b2 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b1 where\n  toFun m :=\n    { measureOf := fun s => m (f '' s)\n      empty := by simp\n      mono := fun {s t} h => m.mono <| image_subset f h\n      iUnion_nat := fun s => by\n        simp only\n        rw [image_iUnion]\n        apply m.iUnion_nat }\n  map_add' m\u2081 m\u2082 := rfl\n  map_smul' c m := rfl", "start": [526, 1], "end": [537, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_apply", "code": "@[simp]\ntheorem comap_apply {\u03b2} (f : \u03b1 \u2192 \u03b2) (m : OuterMeasure \u03b2) (s : Set \u03b1) : comap f m s = m (f '' s)", "start": [540, 1], "end": [542, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_mono", "code": "@[mono]\ntheorem comap_mono {\u03b2} (f : \u03b1 \u2192 \u03b2) : Monotone (comap f)", "start": [545, 1], "end": [546, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_iSup", "code": "@[simp]\ntheorem comap_iSup {\u03b2 \u03b9} (f : \u03b1 \u2192 \u03b2) (m : \u03b9 \u2192 OuterMeasure \u03b2) :\n    comap f (\u2a06 i, m i) = \u2a06 i, comap f (m i)", "start": [549, 1], "end": [552, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict", "code": "def restrict (s : Set \u03b1) : OuterMeasure \u03b1 \u2192\u2097[\u211d\u22650\u221e] OuterMeasure \u03b1 :=\n  (map (\u2191)).comp (comap ((\u2191) : s \u2192 \u03b1))", "start": [555, 1], "end": [557, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (s t : Set \u03b1) (m : OuterMeasure \u03b1) : restrict s m t = m (t \u2229 s)", "start": [560, 1], "end": [562, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_mono", "code": "@[mono]\ntheorem restrict_mono {s t : Set \u03b1} (h : s \u2286 t) {m m' : OuterMeasure \u03b1} (hm : m \u2264 m') :\n    restrict s m \u2264 restrict t m'", "start": [565, 1], "end": [569, 63], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_univ", "code": "@[simp]\ntheorem restrict_univ (m : OuterMeasure \u03b1) : restrict univ m = m", "start": [572, 1], "end": [574, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_empty", "code": "@[simp]\ntheorem restrict_empty (m : OuterMeasure \u03b1) : restrict \u2205 m = 0", "start": [577, 1], "end": [579, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_iSup", "code": "@[simp]\ntheorem restrict_iSup {\u03b9} (s : Set \u03b1) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    restrict s (\u2a06 i, m i) = \u2a06 i, restrict s (m i)", "start": [582, 1], "end": [584, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_comap", "code": "theorem map_comap {\u03b2} (f : \u03b1 \u2192 \u03b2) (m : OuterMeasure \u03b2) : map f (comap f m) = restrict (range f) m", "start": [587, 1], "end": [588, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_comap_le", "code": "theorem map_comap_le {\u03b2} (f : \u03b1 \u2192 \u03b2) (m : OuterMeasure \u03b2) : map f (comap f m) \u2264 m", "start": [591, 1], "end": [592, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_le_self", "code": "theorem restrict_le_self (m : OuterMeasure \u03b1) (s : Set \u03b1) : restrict s m \u2264 m", "start": [595, 1], "end": [596, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_le_restrict_range", "code": "@[simp]\ntheorem map_le_restrict_range {\u03b2} {ma : OuterMeasure \u03b1} {mb : OuterMeasure \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    map f ma \u2264 restrict (range f) mb \u2194 map f ma \u2264 mb", "start": [599, 1], "end": [602, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_comap_of_surjective", "code": "theorem map_comap_of_surjective {\u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) (m : OuterMeasure \u03b2) :\n    map f (comap f m) = m", "start": [605, 1], "end": [607, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_comap_map", "code": "theorem le_comap_map {\u03b2} (f : \u03b1 \u2192 \u03b2) (m : OuterMeasure \u03b1) : m \u2264 comap f (map f m)", "start": [610, 1], "end": [611, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_map", "code": "theorem comap_map {\u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (m : OuterMeasure \u03b1) : comap f (map f m) = m", "start": [614, 1], "end": [615, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.top_apply", "code": "@[simp]\ntheorem top_apply {s : Set \u03b1} (h : s.Nonempty) : (\u22a4 : OuterMeasure \u03b1) s = \u221e", "start": [618, 1], "end": [621, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.top_apply'", "code": "theorem top_apply' (s : Set \u03b1) : (\u22a4 : OuterMeasure \u03b1) s = \u2a05 h : s = \u2205, 0", "start": [624, 1], "end": [625, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_top", "code": "@[simp]\ntheorem comap_top (f : \u03b1 \u2192 \u03b2) : comap f \u22a4 = \u22a4", "start": [628, 1], "end": [630, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_top", "code": "theorem map_top (f : \u03b1 \u2192 \u03b2) : map f \u22a4 = restrict (range f) \u22a4", "start": [633, 1], "end": [636, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_top_of_surjective", "code": "@[simp]\ntheorem map_top_of_surjective (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) : map f \u22a4 = \u22a4", "start": [639, 1], "end": [641, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction", "code": "protected def ofFunction : OuterMeasure \u03b1 :=\n  let \u03bc s := \u2a05 (f : \u2115 \u2192 Set \u03b1) (_ : s \u2286 \u22c3 i, f i), \u2211' i, m (f i)\n  { measureOf := \u03bc\n    empty :=\n      le_antisymm\n        ((iInf_le_of_le fun _ => \u2205) <| iInf_le_of_le (empty_subset _) <| by simp [m_empty])\n        (zero_le _)\n    mono := fun {s\u2081 s\u2082} hs => iInf_mono fun f => iInf_mono' fun hb => \u27e8hs.trans hb, le_rfl\u27e9\n    iUnion_nat := fun s =>\n      ENNReal.le_of_forall_pos_le_add <| by\n        intro \u03b5 h\u03b5 (hb : (\u2211' i, \u03bc (s i)) < \u221e)\n        rcases ENNReal.exists_pos_sum_of_countable (ENNReal.coe_pos.2 h\u03b5).ne' \u2115 with \u27e8\u03b5', h\u03b5', hl\u27e9\n        refine' le_trans _ (add_le_add_left (le_of_lt hl) _)\n        rw [\u2190 ENNReal.tsum_add]\n        choose f hf using\n          show \u2200 i, \u2203 f : \u2115 \u2192 Set \u03b1, (s i \u2286 \u22c3 i, f i) \u2227 (\u2211' i, m (f i)) < \u03bc (s i) + \u03b5' i by\n            intro i\n            have : \u03bc (s i) < \u03bc (s i) + \u03b5' i :=\n              ENNReal.lt_add_right (ne_top_of_le_ne_top hb.ne <| ENNReal.le_tsum _)\n                (by simpa using (h\u03b5' i).ne')\n            rcases iInf_lt_iff.mp this with \u27e8t, ht\u27e9\n            exists t\n            contrapose! ht\n            exact le_iInf ht\n        refine' le_trans _ (ENNReal.tsum_le_tsum fun i => le_of_lt (hf i).2)\n        rw [\u2190 ENNReal.tsum_prod, \u2190 Nat.pairEquiv.symm.tsum_eq]\n        refine' iInf_le_of_le _ (iInf_le _ _)\n        apply iUnion_subset\n        intro i\n        apply Subset.trans (hf i).1\n        apply iUnion_subset\n        simp only [Nat.pairEquiv_symm_apply]\n        rw [iUnion_unpair]\n        intro j\n        apply subset_iUnion\u2082 i }", "start": [652, 1], "end": [688, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_apply", "code": "theorem ofFunction_apply (s : Set \u03b1) :\n    OuterMeasure.ofFunction m m_empty s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, m (t n)", "start": [691, 1], "end": [693, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_le", "code": "theorem ofFunction_le (s : Set \u03b1) : OuterMeasure.ofFunction m m_empty s \u2264 m s", "start": [698, 1], "end": [702, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_eq", "code": "theorem ofFunction_eq (s : Set \u03b1) (m_mono : \u2200 \u2983t : Set \u03b1\u2984, s \u2286 t \u2192 m s \u2264 m t)\n    (m_subadd : \u2200 s : \u2115 \u2192 Set \u03b1, m (\u22c3 i, s i) \u2264 \u2211' i, m (s i)) :\n    OuterMeasure.ofFunction m m_empty s = m s", "start": [705, 1], "end": [709, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_ofFunction", "code": "theorem le_ofFunction {\u03bc : OuterMeasure \u03b1} :\n    \u03bc \u2264 OuterMeasure.ofFunction m m_empty \u2194 \u2200 s, \u03bc s \u2264 m s", "start": [712, 1], "end": [717, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isGreatest_ofFunction", "code": "theorem isGreatest_ofFunction :\n    IsGreatest { \u03bc : OuterMeasure \u03b1 | \u2200 s, \u03bc s \u2264 m s } (OuterMeasure.ofFunction m m_empty)", "start": [720, 1], "end": [722, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_eq_sSup", "code": "theorem ofFunction_eq_sSup : OuterMeasure.ofFunction m m_empty = sSup { \u03bc | \u2200 s, \u03bc s \u2264 m s }", "start": [725, 1], "end": [726, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_union_of_top_of_nonempty_inter", "code": "theorem ofFunction_union_of_top_of_nonempty_inter {s t : Set \u03b1}\n    (h : \u2200 u, (s \u2229 u).Nonempty \u2192 (t \u2229 u).Nonempty \u2192 m u = \u221e) :\n    OuterMeasure.ofFunction m m_empty (s \u222a t) =\n      OuterMeasure.ofFunction m m_empty s + OuterMeasure.ofFunction m m_empty t", "start": [729, 1], "end": [765, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_ofFunction", "code": "theorem comap_ofFunction {\u03b2} (f : \u03b2 \u2192 \u03b1) (h : Monotone m \u2228 Surjective f) :\n    comap f (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun s => m (f '' s)) (by simp; simp [m_empty])", "start": [769, 1], "end": [781, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_ofFunction_le", "code": "theorem map_ofFunction_le {\u03b2} (f : \u03b1 \u2192 \u03b2) :\n    map f (OuterMeasure.ofFunction m m_empty) \u2264\n      OuterMeasure.ofFunction (fun s => m (f \u207b\u00b9' s)) m_empty", "start": [784, 1], "end": [789, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_ofFunction", "code": "theorem map_ofFunction {\u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    map f (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun s => m (f \u207b\u00b9' s)) m_empty", "start": [792, 1], "end": [802, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_ofFunction", "code": "theorem restrict_ofFunction (s : Set \u03b1) (hm : Monotone m) :\n    restrict s (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun t => m (t \u2229 s)) (by simp; simp [m_empty])", "start": [805, 1], "end": [811, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.smul_ofFunction", "code": "theorem smul_ofFunction {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) : c \u2022 OuterMeasure.ofFunction m m_empty =\n    OuterMeasure.ofFunction (c \u2022 m) (by simp [m_empty])", "start": [814, 1], "end": [820, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy", "code": "def boundedBy : OuterMeasure \u03b1 :=\n  OuterMeasure.ofFunction (fun s => \u2a06 _ : s.Nonempty, m s) (by simp [Set.not_nonempty_empty])", "start": [829, 1], "end": [833, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_le", "code": "theorem boundedBy_le (s : Set \u03b1) : boundedBy m s \u2264 m s", "start": [838, 1], "end": [839, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_eq_ofFunction", "code": "theorem boundedBy_eq_ofFunction (m_empty : m \u2205 = 0) (s : Set \u03b1) :\n    boundedBy m s = OuterMeasure.ofFunction m m_empty s", "start": [842, 1], "end": [847, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_apply", "code": "theorem boundedBy_apply (s : Set \u03b1) :\n    boundedBy m s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t),\n                      \u2211' n, \u2a06 _ : (t n).Nonempty, m (t n)", "start": [850, 1], "end": [853, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_eq", "code": "theorem boundedBy_eq (s : Set \u03b1) (m_empty : m \u2205 = 0) (m_mono : \u2200 \u2983t : Set \u03b1\u2984, s \u2286 t \u2192 m s \u2264 m t)\n    (m_subadd : \u2200 s : \u2115 \u2192 Set \u03b1, m (\u22c3 i, s i) \u2264 \u2211' i, m (s i)) : boundedBy m s = m s", "start": [856, 1], "end": [858, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_eq_self", "code": "@[simp]\ntheorem boundedBy_eq_self (m : OuterMeasure \u03b1) : boundedBy m = m", "start": [861, 1], "end": [863, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_boundedBy", "code": "theorem le_boundedBy {\u03bc : OuterMeasure \u03b1} : \u03bc \u2264 boundedBy m \u2194 \u2200 s, \u03bc s \u2264 m s", "start": [866, 1], "end": [868, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_boundedBy'", "code": "theorem le_boundedBy' {\u03bc : OuterMeasure \u03b1} :\n    \u03bc \u2264 boundedBy m \u2194 \u2200 s : Set \u03b1, s.Nonempty \u2192 \u03bc s \u2264 m s", "start": [871, 1], "end": [875, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_top", "code": "@[simp]\ntheorem boundedBy_top : boundedBy (\u22a4 : Set \u03b1 \u2192 \u211d\u22650\u221e) = \u22a4", "start": [878, 1], "end": [883, 15], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_zero", "code": "@[simp]\ntheorem boundedBy_zero : boundedBy (0 : Set \u03b1 \u2192 \u211d\u22650\u221e) = 0", "start": [886, 1], "end": [889, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.smul_boundedBy", "code": "theorem smul_boundedBy {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) : c \u2022 boundedBy m = boundedBy (c \u2022 m)", "start": [892, 1], "end": [895, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_boundedBy", "code": "theorem comap_boundedBy {\u03b2} (f : \u03b2 \u2192 \u03b1)\n    (h : (Monotone fun s : { s : Set \u03b1 // s.Nonempty } => m s) \u2228 Surjective f) :\n    comap f (boundedBy m) = boundedBy fun s => m (f '' s)", "start": [898, 1], "end": [907, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_union_of_top_of_nonempty_inter", "code": "theorem boundedBy_union_of_top_of_nonempty_inter {s t : Set \u03b1}\n    (h : \u2200 u, (s \u2229 u).Nonempty \u2192 (t \u2229 u).Nonempty \u2192 m u = \u221e) :\n    boundedBy m (s \u222a t) = boundedBy m s + boundedBy m t", "start": [910, 1], "end": [920, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.IsCaratheodory", "code": "def IsCaratheodory (s : Set \u03b1) : Prop :=\n  \u2200 t, m t = m (t \u2229 s) + m (t \\ s)", "start": [935, 1], "end": [938, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_iff_le'", "code": "theorem isCaratheodory_iff_le' {s : Set \u03b1} :\n    IsCaratheodory m s \u2194 \u2200 t, m (t \u2229 s) + m (t \\ s) \u2264 m t", "start": [941, 1], "end": [943, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_empty", "code": "@[simp]\ntheorem isCaratheodory_empty : IsCaratheodory m \u2205", "start": [946, 1], "end": [947, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_compl", "code": "theorem isCaratheodory_compl : IsCaratheodory m s\u2081 \u2192 IsCaratheodory m s\u2081\u1d9c", "start": [950, 1], "end": [951, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_compl_iff", "code": "@[simp]\ntheorem isCaratheodory_compl_iff : IsCaratheodory m s\u1d9c \u2194 IsCaratheodory m s", "start": [954, 1], "end": [956, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_union", "code": "theorem isCaratheodory_union (h\u2081 : IsCaratheodory m s\u2081) (h\u2082 : IsCaratheodory m s\u2082) :\n    IsCaratheodory m (s\u2081 \u222a s\u2082)", "start": [959, 1], "end": [964, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.measure_inter_union", "code": "theorem measure_inter_union (h : s\u2081 \u2229 s\u2082 \u2286 \u2205) (h\u2081 : IsCaratheodory m s\u2081) {t : Set \u03b1} :\n    m (t \u2229 (s\u2081 \u222a s\u2082)) = m (t \u2229 s\u2081) + m (t \u2229 s\u2082)", "start": [967, 1], "end": [969, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_iUnion_lt", "code": "theorem isCaratheodory_iUnion_lt {s : \u2115 \u2192 Set \u03b1} :\n    \u2200 {n : \u2115}, (\u2200 i < n, IsCaratheodory m (s i)) \u2192 IsCaratheodory m (\u22c3 i < n, s i)", "start": [972, 1], "end": [979, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_inter", "code": "theorem isCaratheodory_inter (h\u2081 : IsCaratheodory m s\u2081) (h\u2082 : IsCaratheodory m s\u2082) :\n    IsCaratheodory m (s\u2081 \u2229 s\u2082)", "start": [982, 1], "end": [985, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_sum", "code": "theorem isCaratheodory_sum {s : \u2115 \u2192 Set \u03b1} (h : \u2200 i, IsCaratheodory m (s i))\n    (hd : Pairwise (Disjoint on s)) {t : Set \u03b1} :\n    \u2200 {n}, (\u2211 i in Finset.range n, m (t \u2229 s i)) = m (t \u2229 \u22c3 i < n, s i)", "start": [988, 1], "end": [996, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_iUnion_nat", "code": "theorem isCaratheodory_iUnion_nat {s : \u2115 \u2192 Set \u03b1} (h : \u2200 i, IsCaratheodory m (s i))\n    (hd : Pairwise (Disjoint on s)) : IsCaratheodory m (\u22c3 i, s i)", "start": [999, 1], "end": [1013, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.f_iUnion", "code": "theorem f_iUnion {s : \u2115 \u2192 Set \u03b1} (h : \u2200 i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :\n    m (\u22c3 i, s i) = \u2211' i, m (s i)", "start": [1016, 1], "end": [1023, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.caratheodoryDynkin", "code": "def caratheodoryDynkin : MeasurableSpace.DynkinSystem \u03b1 where\n  Has := IsCaratheodory m\n  has_empty := isCaratheodory_empty m\n  has_compl s := isCaratheodory_compl m s\n  has_iUnion_nat f hf hn := by apply isCaratheodory_iUnion_nat m hf f", "start": [1026, 1], "end": [1031, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.caratheodory", "code": "protected def caratheodory : MeasurableSpace \u03b1 := by\n  apply MeasurableSpace.DynkinSystem.toMeasurableSpace (caratheodoryDynkin m)\n  intro s\u2081 s\u2082\n  apply isCaratheodory_inter", "start": [1034, 1], "end": [1039, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_iff", "code": "theorem isCaratheodory_iff {s : Set \u03b1} :\n    MeasurableSet[OuterMeasure.caratheodory m] s \u2194 \u2200 t, m t = m (t \u2229 s) + m (t \\ s)", "start": [1042, 1], "end": [1044, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.isCaratheodory_iff_le", "code": "theorem isCaratheodory_iff_le {s : Set \u03b1} :\n    MeasurableSet[OuterMeasure.caratheodory m] s \u2194 \u2200 t, m (t \u2229 s) + m (t \\ s) \u2264 m t", "start": [1047, 1], "end": [1049, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iUnion_eq_of_caratheodory", "code": "protected theorem iUnion_eq_of_caratheodory {s : \u2115 \u2192 Set \u03b1}\n    (h : \u2200 i, MeasurableSet[OuterMeasure.caratheodory m] (s i)) (hd : Pairwise (Disjoint on s)) :\n    m (\u22c3 i, s i) = \u2211' i, m (s i)", "start": [1052, 1], "end": [1055, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.ofFunction_caratheodory", "code": "theorem ofFunction_caratheodory {m : Set \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1} {h\u2080 : m \u2205 = 0}\n    (hs : \u2200 t, m (t \u2229 s) + m (t \\ s) \u2264 m t) :\n    MeasurableSet[(OuterMeasure.ofFunction m h\u2080).caratheodory] s", "start": [1062, 1], "end": [1077, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.boundedBy_caratheodory", "code": "theorem boundedBy_caratheodory {m : Set \u03b1 \u2192 \u211d\u22650\u221e} {s : Set \u03b1}\n    (hs : \u2200 t, m (t \u2229 s) + m (t \\ s) \u2264 m t) : MeasurableSet[(boundedBy m).caratheodory] s", "start": [1080, 1], "end": [1087, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.zero_caratheodory", "code": "@[simp]\ntheorem zero_caratheodory : (0 : OuterMeasure \u03b1).caratheodory = \u22a4", "start": [1090, 1], "end": [1092, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.top_caratheodory", "code": "theorem top_caratheodory : (\u22a4 : OuterMeasure \u03b1).caratheodory = \u22a4", "start": [1095, 1], "end": [1099, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_add_caratheodory", "code": "theorem le_add_caratheodory (m\u2081 m\u2082 : OuterMeasure \u03b1) :\n    m\u2081.caratheodory \u2293 m\u2082.caratheodory \u2264 (m\u2081 + m\u2082 : OuterMeasure \u03b1).caratheodory", "start": [1102, 1], "end": [1104, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_sum_caratheodory", "code": "theorem le_sum_caratheodory {\u03b9} (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    \u2a05 i, (m i).caratheodory \u2264 (sum m).caratheodory", "start": [1107, 1], "end": [1109, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_smul_caratheodory", "code": "theorem le_smul_caratheodory (a : \u211d\u22650\u221e) (m : OuterMeasure \u03b1) :\n    m.caratheodory \u2264 (a \u2022 m).caratheodory", "start": [1112, 1], "end": [1116, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.dirac_caratheodory", "code": "@[simp]\ntheorem dirac_caratheodory (a : \u03b1) : (dirac a).caratheodory = \u22a4", "start": [1119, 1], "end": [1123, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sInfGen", "code": "def sInfGen (m : Set (OuterMeasure \u03b1)) (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 (\u03bc : OuterMeasure \u03b1) (_ : \u03bc \u2208 m), \u03bc s", "start": [1128, 1], "end": [1133, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sInfGen_def", "code": "theorem sInfGen_def (m : Set (OuterMeasure \u03b1)) (t : Set \u03b1) :\n    sInfGen m t = \u2a05 (\u03bc : OuterMeasure \u03b1) (_ : \u03bc \u2208 m), \u03bc t", "start": [1136, 1], "end": [1138, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sInf_eq_boundedBy_sInfGen", "code": "theorem sInf_eq_boundedBy_sInfGen (m : Set (OuterMeasure \u03b1)) :\n    sInf m = OuterMeasure.boundedBy (sInfGen m)", "start": [1141, 1], "end": [1148, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iSup_sInfGen_nonempty", "code": "theorem iSup_sInfGen_nonempty {m : Set (OuterMeasure \u03b1)} (h : m.Nonempty) (t : Set \u03b1) :\n    \u2a06 _ : t.Nonempty, sInfGen m t = \u2a05 (\u03bc : OuterMeasure \u03b1) (_ : \u03bc \u2208 m), \u03bc t", "start": [1151, 1], "end": [1159, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sInf_apply", "code": "theorem sInf_apply {m : Set (OuterMeasure \u03b1)} {s : Set \u03b1} (h : m.Nonempty) :\n    sInf m s =\n      \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 (\u03bc : OuterMeasure \u03b1) (_ : \u03bc \u2208 m), \u03bc (t n)", "start": [1162, 1], "end": [1168, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.sInf_apply'", "code": "theorem sInf_apply' {m : Set (OuterMeasure \u03b1)} {s : Set \u03b1} (h : s.Nonempty) :\n    sInf m s =\n      \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 (\u03bc : OuterMeasure \u03b1) (_ : \u03bc \u2208 m), \u03bc (t n)", "start": [1171, 1], "end": [1177, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iInf_apply", "code": "theorem iInf_apply {\u03b9} [Nonempty \u03b9] (m : \u03b9 \u2192 OuterMeasure \u03b1) (s : Set \u03b1) :\n    (\u2a05 i, m i) s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 i, m i (t n)", "start": [1180, 1], "end": [1186, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.iInf_apply'", "code": "theorem iInf_apply' {\u03b9} (m : \u03b9 \u2192 OuterMeasure \u03b1) {s : Set \u03b1} (hs : s.Nonempty) :\n    (\u2a05 i, m i) s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 i, m i (t n)", "start": [1189, 1], "end": [1195, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.biInf_apply", "code": "theorem biInf_apply {\u03b9} {I : Set \u03b9} (hI : I.Nonempty) (m : \u03b9 \u2192 OuterMeasure \u03b1) (s : Set \u03b1) :\n    (\u2a05 i \u2208 I, m i) s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 i \u2208 I, m i (t n)", "start": [1198, 1], "end": [1204, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.biInf_apply'", "code": "theorem biInf_apply' {\u03b9} (I : Set \u03b9) (m : \u03b9 \u2192 OuterMeasure \u03b1) {s : Set \u03b1} (hs : s.Nonempty) :\n    (\u2a05 i \u2208 I, m i) s = \u2a05 (t : \u2115 \u2192 Set \u03b1) (_ : s \u2286 iUnion t), \u2211' n, \u2a05 i \u2208 I, m i (t n)", "start": [1207, 1], "end": [1212, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_iInf_le", "code": "theorem map_iInf_le {\u03b9 \u03b2} (f : \u03b1 \u2192 \u03b2) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    map f (\u2a05 i, m i) \u2264 \u2a05 i, map f (m i)", "start": [1215, 1], "end": [1217, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.comap_iInf", "code": "theorem comap_iInf {\u03b9 \u03b2} (f : \u03b1 \u2192 \u03b2) (m : \u03b9 \u2192 OuterMeasure \u03b2) :\n    comap f (\u2a05 i, m i) = \u2a05 i, comap f (m i)", "start": [1220, 1], "end": [1227, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_iInf", "code": "theorem map_iInf {\u03b9 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    map f (\u2a05 i, m i) = restrict (range f) (\u2a05 i, map f (m i))", "start": [1230, 1], "end": [1233, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_iInf_comap", "code": "theorem map_iInf_comap {\u03b9 \u03b2} [Nonempty \u03b9] {f : \u03b1 \u2192 \u03b2} (m : \u03b9 \u2192 OuterMeasure \u03b2) :\n    map f (\u2a05 i, comap f (m i)) = \u2a05 i, map f (comap f (m i))", "start": [1236, 1], "end": [1247, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.map_biInf_comap", "code": "theorem map_biInf_comap {\u03b9 \u03b2} {I : Set \u03b9} (hI : I.Nonempty) {f : \u03b1 \u2192 \u03b2} (m : \u03b9 \u2192 OuterMeasure \u03b2) :\n    map f (\u2a05 i \u2208 I, comap f (m i)) = \u2a05 i \u2208 I, map f (comap f (m i))", "start": [1250, 1], "end": [1254, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_iInf_restrict", "code": "theorem restrict_iInf_restrict {\u03b9} (s : Set \u03b1) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    restrict s (\u2a05 i, restrict s (m i)) = restrict s (\u2a05 i, m i)", "start": [1257, 1], "end": [1263, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_iInf", "code": "theorem restrict_iInf {\u03b9} [Nonempty \u03b9] (s : Set \u03b1) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    restrict s (\u2a05 i, m i) = \u2a05 i, restrict s (m i)", "start": [1267, 1], "end": [1269, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_biInf", "code": "theorem restrict_biInf {\u03b9} {I : Set \u03b9} (hI : I.Nonempty) (s : Set \u03b1) (m : \u03b9 \u2192 OuterMeasure \u03b1) :\n    restrict s (\u2a05 i \u2208 I, m i) = \u2a05 i \u2208 I, restrict s (m i)", "start": [1272, 1], "end": [1276, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_sInf_eq_sInf_restrict", "code": "theorem restrict_sInf_eq_sInf_restrict (m : Set (OuterMeasure \u03b1)) {s : Set \u03b1} (hm : m.Nonempty) :\n    restrict s (sInf m) = sInf (restrict s '' m)", "start": [1279, 1], "end": [1283, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend", "code": "def extend (s : \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 h : P s, m s h", "start": [1310, 1], "end": [1313, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_eq", "code": "theorem extend_eq {s : \u03b1} (h : P s) : extend m s = m s h", "start": [1316, 1], "end": [1316, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_eq_top", "code": "theorem extend_eq_top {s : \u03b1} (h : \u00acP s) : extend m s = \u221e", "start": [1319, 1], "end": [1319, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.smul_extend", "code": "theorem smul_extend {R} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    [NoZeroSMulDivisors R \u211d\u22650\u221e] {c : R} (hc : c \u2260 0) :\n    c \u2022 extend m = extend fun s h => c \u2022 m s h", "start": [1322, 1], "end": [1329, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_extend", "code": "theorem le_extend {s : \u03b1} (h : P s) : m s h \u2264 extend m s", "start": [1332, 1], "end": [1335, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_congr", "code": "theorem extend_congr {\u03b2 : Type*} {Pb : \u03b2 \u2192 Prop} {mb : \u2200 s : \u03b2, Pb s \u2192 \u211d\u22650\u221e} {sa : \u03b1} {sb : \u03b2}\n    (hP : P sa \u2194 Pb sb) (hm : \u2200 (ha : P sa) (hb : Pb sb), m sa ha = mb sb hb) :\n    extend m sa = extend mb sb", "start": [1339, 1], "end": [1342, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_top", "code": "@[simp]\ntheorem extend_top {\u03b1 : Type*} {P : \u03b1 \u2192 Prop} : extend (fun _ _ => \u221e : \u2200 s : \u03b1, P s \u2192 \u211d\u22650\u221e) = \u22a4", "start": [1345, 1], "end": [1347, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_empty", "code": "theorem extend_empty : extend m \u2205 = 0", "start": [1371, 1], "end": [1372, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_iUnion_nat", "code": "theorem extend_iUnion_nat {f : \u2115 \u2192 Set \u03b1} (hm : \u2200 i, P (f i))\n    (mU : m (\u22c3 i, f i) (PU hm) = \u2211' i, m (f i) (hm i)) :\n    extend m (\u22c3 i, f i) = \u2211' i, extend m (f i)", "start": [1375, 1], "end": [1381, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_iUnion_le_tsum_nat'", "code": "theorem extend_iUnion_le_tsum_nat' (s : \u2115 \u2192 Set \u03b1) :\n    extend m (\u22c3 i, s i) \u2264 \u2211' i, extend m (s i)", "start": [1386, 1], "end": [1394, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_mono'", "code": "theorem extend_mono' \u2983s\u2081 s\u2082 : Set \u03b1\u2984 (h\u2081 : P s\u2081) (hs : s\u2081 \u2286 s\u2082) : extend m s\u2081 \u2264 extend m s\u2082", "start": [1401, 1], "end": [1405, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_iUnion", "code": "theorem extend_iUnion {\u03b2} [Countable \u03b2] {f : \u03b2 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on f))\n    (hm : \u2200 i, P (f i)) : extend m (\u22c3 i, f i) = \u2211' i, extend m (f i)", "start": [1412, 1], "end": [1419, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_union", "code": "theorem extend_union {s\u2081 s\u2082 : Set \u03b1} (hd : Disjoint s\u2081 s\u2082) (h\u2081 : P s\u2081) (h\u2082 : P s\u2082) :\n    extend m (s\u2081 \u222a s\u2082) = extend m s\u2081 + extend m s\u2082", "start": [1422, 1], "end": [1427, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure", "code": "def inducedOuterMeasure : OuterMeasure \u03b1 :=\n  OuterMeasure.ofFunction (extend m) (extend_empty P0 m0)", "start": [1434, 1], "end": [1437, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_inducedOuterMeasure", "code": "theorem le_inducedOuterMeasure {\u03bc : OuterMeasure \u03b1} :\n    \u03bc \u2264 inducedOuterMeasure m P0 m0 \u2194 \u2200 (s) (hs : P s), \u03bc s \u2264 m s hs", "start": [1442, 1], "end": [1444, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_union_of_false_of_nonempty_inter", "code": "theorem inducedOuterMeasure_union_of_false_of_nonempty_inter {s t : Set \u03b1}\n    (h : \u2200 u, (s \u2229 u).Nonempty \u2192 (t \u2229 u).Nonempty \u2192 \u00acP u) :\n    inducedOuterMeasure m P0 m0 (s \u222a t) =\n      inducedOuterMeasure m P0 m0 s + inducedOuterMeasure m P0 m0 t", "start": [1447, 1], "end": [1456, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq_extend'", "code": "theorem inducedOuterMeasure_eq_extend' {s : Set \u03b1} (hs : P s) :\n    inducedOuterMeasure m P0 m0 s = extend m s", "start": [1459, 1], "end": [1461, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq'", "code": "theorem inducedOuterMeasure_eq' {s : Set \u03b1} (hs : P s) : inducedOuterMeasure m P0 m0 s = m s hs", "start": [1464, 1], "end": [1465, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq_iInf", "code": "theorem inducedOuterMeasure_eq_iInf (s : Set \u03b1) :\n    inducedOuterMeasure m P0 m0 s = \u2a05 (t : Set \u03b1) (ht : P t) (_ : s \u2286 t), m t ht", "start": [1468, 1], "end": [1482, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_preimage", "code": "theorem inducedOuterMeasure_preimage (f : \u03b1 \u2243 \u03b1) (Pm : \u2200 s : Set \u03b1, P (f \u207b\u00b9' s) \u2194 P s)\n    (mm : \u2200 (s : Set \u03b1) (hs : P s), m (f \u207b\u00b9' s) ((Pm _).mpr hs) = m s hs) {A : Set \u03b1} :\n    inducedOuterMeasure m P0 m0 (f \u207b\u00b9' A) = inducedOuterMeasure m P0 m0 A", "start": [1485, 1], "end": [1492, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_exists_set", "code": "theorem inducedOuterMeasure_exists_set {s : Set \u03b1} (hs : inducedOuterMeasure m P0 m0 s \u2260 \u221e)\n    {\u03b5 : \u211d\u22650\u221e} (h\u03b5 : \u03b5 \u2260 0) :\n    \u2203 (t : Set \u03b1) (_ht : P t),\n      s \u2286 t \u2227 inducedOuterMeasure m P0 m0 t \u2264 inducedOuterMeasure m P0 m0 s + \u03b5", "start": [1495, 1], "end": [1506, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_caratheodory", "code": "theorem inducedOuterMeasure_caratheodory (s : Set \u03b1) :\n    MeasurableSet[(inducedOuterMeasure m P0 m0).caratheodory] s \u2194\n      \u2200 t : Set \u03b1,\n        P t \u2192\n          inducedOuterMeasure m P0 m0 (t \u2229 s) + inducedOuterMeasure m P0 m0 (t \\ s) \u2264\n            inducedOuterMeasure m P0 m0 t", "start": [1509, 1], "end": [1534, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_mono", "code": "theorem extend_mono {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : MeasurableSet s\u2081) (hs : s\u2081 \u2286 s\u2082) :\n    extend m s\u2081 \u2264 extend m s\u2082", "start": [1556, 1], "end": [1564, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.extend_iUnion_le_tsum_nat", "code": "theorem extend_iUnion_le_tsum_nat : \u2200 s : \u2115 \u2192 Set \u03b1,\n    extend m (\u22c3 i, s i) \u2264 \u2211' i, extend m (s i)", "start": [1567, 1], "end": [1574, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq_extend", "code": "theorem inducedOuterMeasure_eq_extend {s : Set \u03b1} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = extend m s", "start": [1577, 1], "end": [1579, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inducedOuterMeasure_eq", "code": "theorem inducedOuterMeasure_eq {s : Set \u03b1} (hs : MeasurableSet s) :\n    inducedOuterMeasure m MeasurableSet.empty m0 s = m s hs", "start": [1582, 1], "end": [1584, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim", "code": "def trim : OuterMeasure \u03b1 :=\n  inducedOuterMeasure (fun s _ => m s) MeasurableSet.empty m.empty", "start": [1593, 1], "end": [1596, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_trim", "code": "theorem le_trim : m \u2264 m.trim", "start": [1599, 1], "end": [1604, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_eq", "code": "@[simp] theorem trim_eq {s : Set \u03b1} (hs : MeasurableSet s) : m.trim s = m s", "start": [1607, 1], "end": [1610, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_congr", "code": "theorem trim_congr {m\u2081 m\u2082 : OuterMeasure \u03b1} (H : \u2200 {s : Set \u03b1}, MeasurableSet s \u2192 m\u2081 s = m\u2082 s) :\n    m\u2081.trim = m\u2082.trim", "start": [1613, 1], "end": [1618, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_mono", "code": "@[mono]\ntheorem trim_mono : Monotone (trim : OuterMeasure \u03b1 \u2192 OuterMeasure \u03b1)", "start": [1621, 1], "end": [1623, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.le_trim_iff", "code": "theorem le_trim_iff {m\u2081 m\u2082 : OuterMeasure \u03b1} :\n    m\u2081 \u2264 m\u2082.trim \u2194 \u2200 s, MeasurableSet s \u2192 m\u2081 s \u2264 m\u2082 s", "start": [1626, 1], "end": [1635, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_le_trim_iff", "code": "theorem trim_le_trim_iff {m\u2081 m\u2082 : OuterMeasure \u03b1} :\n    m\u2081.trim \u2264 m\u2082.trim \u2194 \u2200 s, MeasurableSet s \u2192 m\u2081 s \u2264 m\u2082 s", "start": [1638, 1], "end": [1640, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_eq_trim_iff", "code": "theorem trim_eq_trim_iff {m\u2081 m\u2082 : OuterMeasure \u03b1} :\n    m\u2081.trim = m\u2082.trim \u2194 \u2200 s, MeasurableSet s \u2192 m\u2081 s = m\u2082 s", "start": [1643, 1], "end": [1645, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_eq_iInf", "code": "theorem trim_eq_iInf (s : Set \u03b1) : m.trim s = \u2a05 (t) (_ : s \u2286 t) (_ : MeasurableSet t), m t", "start": [1648, 1], "end": [1652, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_eq_iInf'", "code": "theorem trim_eq_iInf' (s : Set \u03b1) : m.trim s = \u2a05 t : { t // s \u2286 t \u2227 MeasurableSet t }, m t", "start": [1655, 1], "end": [1656, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_trim", "code": "theorem trim_trim (m : OuterMeasure \u03b1) : m.trim.trim = m.trim", "start": [1659, 1], "end": [1660, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_top", "code": "@[simp]\ntheorem trim_top : (\u22a4 : OuterMeasure \u03b1).trim = \u22a4", "start": [1663, 1], "end": [1665, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_zero", "code": "@[simp]\ntheorem trim_zero : (0 : OuterMeasure \u03b1).trim = 0", "start": [1668, 1], "end": [1673, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_sum_ge", "code": "theorem trim_sum_ge {\u03b9} (m : \u03b9 \u2192 OuterMeasure \u03b1) : (sum fun i => (m i).trim) \u2264 (sum m).trim", "start": [1676, 1], "end": [1680, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_eq_trim", "code": "theorem exists_measurable_superset_eq_trim (m : OuterMeasure \u03b1) (s : Set \u03b1) :\n    \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 m t = m.trim s", "start": [1683, 1], "end": [1708, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_of_trim_eq_zero", "code": "theorem exists_measurable_superset_of_trim_eq_zero {m : OuterMeasure \u03b1} {s : Set \u03b1}\n    (h : m.trim s = 0) : \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 m t = 0", "start": [1711, 1], "end": [1714, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.exists_measurable_superset_forall_eq_trim", "code": "theorem exists_measurable_superset_forall_eq_trim {\u03b9} [Countable \u03b9] (\u03bc : \u03b9 \u2192 OuterMeasure \u03b1)\n    (s : Set \u03b1) : \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 i, \u03bc i t = (\u03bc i).trim s", "start": [1717, 1], "end": [1725, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_binop", "code": "theorem trim_binop {m\u2081 m\u2082 m\u2083 : OuterMeasure \u03b1} {op : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e \u2192 \u211d\u22650\u221e}\n    (h : \u2200 s, m\u2081 s = op (m\u2082 s) (m\u2083 s)) (s : Set \u03b1) : m\u2081.trim s = op (m\u2082.trim s) (m\u2083.trim s)", "start": [1728, 1], "end": [1734, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_op", "code": "theorem trim_op {m\u2081 m\u2082 : OuterMeasure \u03b1} {op : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e} (h : \u2200 s, m\u2081 s = op (m\u2082 s))\n    (s : Set \u03b1) : m\u2081.trim s = op (m\u2082.trim s)", "start": [1737, 1], "end": [1740, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_add", "code": "theorem trim_add (m\u2081 m\u2082 : OuterMeasure \u03b1) : (m\u2081 + m\u2082).trim = m\u2081.trim + m\u2082.trim", "start": [1743, 1], "end": [1745, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_smul", "code": "theorem trim_smul {R : Type*} [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e] (c : R)\n    (m : OuterMeasure \u03b1) : (c \u2022 m).trim = c \u2022 m.trim", "start": [1748, 1], "end": [1751, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_sup", "code": "theorem trim_sup (m\u2081 m\u2082 : OuterMeasure \u03b1) : (m\u2081 \u2294 m\u2082).trim = m\u2081.trim \u2294 m\u2082.trim", "start": [1754, 1], "end": [1756, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.trim_iSup", "code": "theorem trim_iSup {\u03b9} [Countable \u03b9] (\u03bc : \u03b9 \u2192 OuterMeasure \u03b1) :\n    trim (\u2a06 i, \u03bc i) = \u2a06 i, trim (\u03bc i)", "start": [1759, 1], "end": [1770, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.OuterMeasure.restrict_trim", "code": "theorem restrict_trim {\u03bc : OuterMeasure \u03b1} {s : Set \u03b1} (hs : MeasurableSet s) :\n    (restrict s \u03bc).trim = restrict s \u03bc.trim", "start": [1773, 1], "end": [1786, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Basic.lean", "imports": ["Mathlib/Analysis/Convex/Star.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "Mathlib/Algebra/Order/Module.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Convex", "code": "def Convex : Prop :=\n  \u2200 \u2983x : E\u2984, x \u2208 s \u2192 StarConvex \ud835\udd5c x s", "start": [50, 1], "end": [52, 38], "kind": "commanddeclaration"}, {"full_name": "Convex.starConvex", "code": "theorem Convex.starConvex (hs : Convex \ud835\udd5c s) (hx : x \u2208 s) : StarConvex \ud835\udd5c x s", "start": [57, 1], "end": [58, 8], "kind": "commanddeclaration"}, {"full_name": "convex_iff_segment_subset", "code": "theorem convex_iff_segment_subset : Convex \ud835\udd5c s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 [x -[\ud835\udd5c] y] \u2286 s", "start": [61, 1], "end": [62, 57], "kind": "commanddeclaration"}, {"full_name": "Convex.segment_subset", "code": "theorem Convex.segment_subset (h : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) :\n    [x -[\ud835\udd5c] y] \u2286 s", "start": [65, 1], "end": [67, 38], "kind": "commanddeclaration"}, {"full_name": "Convex.openSegment_subset", "code": "theorem Convex.openSegment_subset (h : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) :\n    openSegment \ud835\udd5c x y \u2286 s", "start": [70, 1], "end": [72, 68], "kind": "commanddeclaration"}, {"full_name": "convex_iff_pointwise_add_subset", "code": "theorem convex_iff_pointwise_add_subset :\n    Convex \ud835\udd5c s \u2194 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 s + b \u2022 s \u2286 s", "start": [75, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "Convex.set_combo_subset", "code": "alias \u27e8Convex.set_combo_subset, _\u27e9 := convex_iff_pointwise_add_subset", "start": [85, 1], "end": [85, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "convex_empty", "code": "theorem convex_empty : Convex \ud835\udd5c (\u2205 : Set E)", "start": [88, 1], "end": [88, 67], "kind": "commanddeclaration"}, {"full_name": "convex_univ", "code": "theorem convex_univ : Convex \ud835\udd5c (Set.univ : Set E)", "start": [91, 1], "end": [91, 82], "kind": "commanddeclaration"}, {"full_name": "Convex.inter", "code": "theorem Convex.inter {t : Set E} (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) : Convex \ud835\udd5c (s \u2229 t)", "start": [94, 1], "end": [95, 40], "kind": "commanddeclaration"}, {"full_name": "convex_sInter", "code": "theorem convex_sInter {S : Set (Set E)} (h : \u2200 s \u2208 S, Convex \ud835\udd5c s) : Convex \ud835\udd5c (\u22c2\u2080 S)", "start": [98, 1], "end": [99, 50], "kind": "commanddeclaration"}, {"full_name": "convex_iInter", "code": "theorem convex_iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (h : \u2200 i, Convex \ud835\udd5c (s i)) :\n    Convex \ud835\udd5c (\u22c2 i, s i)", "start": [102, 1], "end": [104, 57], "kind": "commanddeclaration"}, {"full_name": "convex_iInter\u2082", "code": "theorem convex_iInter\u2082 {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*} {s : \u2200 i, \u03ba i \u2192 Set E}\n    (h : \u2200 i j, Convex \ud835\udd5c (s i j)) : Convex \ud835\udd5c (\u22c2 (i) (j), s i j)", "start": [107, 1], "end": [109, 46], "kind": "commanddeclaration"}, {"full_name": "Convex.prod", "code": "theorem Convex.prod {s : Set E} {t : Set F} (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) :\n    Convex \ud835\udd5c (s \u00d7\u02e2 t)", "start": [112, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "convex_pi", "code": "theorem convex_pi {\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, AddCommMonoid (E i)] [\u2200 i, SMul \ud835\udd5c (E i)]\n    {s : Set \u03b9} {t : \u2200 i, Set (E i)} (ht : \u2200 \u2983i\u2984, i \u2208 s \u2192 Convex \ud835\udd5c (t i)) : Convex \ud835\udd5c (s.pi t)", "start": [116, 1], "end": [118, 57], "kind": "commanddeclaration"}, {"full_name": "Directed.convex_iUnion", "code": "theorem Directed.convex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n    (hc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)) : Convex \ud835\udd5c (\u22c3 i, s i)", "start": [121, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.convex_sUnion", "code": "theorem DirectedOn.convex_sUnion {c : Set (Set E)} (hdir : DirectedOn (\u00b7 \u2286 \u00b7) c)\n    (hc : \u2200 \u2983A : Set E\u2984, A \u2208 c \u2192 Convex \ud835\udd5c A) : Convex \ud835\udd5c (\u22c3\u2080 c)", "start": [131, 1], "end": [134, 71], "kind": "commanddeclaration"}, {"full_name": "convex_iff_openSegment_subset", "code": "theorem convex_iff_openSegment_subset :\n    Convex \ud835\udd5c s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 openSegment \ud835\udd5c x y \u2286 s", "start": [143, 1], "end": [145, 59], "kind": "commanddeclaration"}, {"full_name": "convex_iff_forall_pos", "code": "theorem convex_iff_forall_pos :\n    Convex \ud835\udd5c s \u2194\n      \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [148, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "convex_iff_pairwise_pos", "code": "theorem convex_iff_pairwise_pos : Convex \ud835\udd5c s \u2194\n    s.Pairwise fun x y => \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s", "start": [154, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Convex.starConvex_iff", "code": "theorem Convex.starConvex_iff (hs : Convex \ud835\udd5c s) (h : s.Nonempty) : StarConvex \ud835\udd5c x s \u2194 x \u2208 s", "start": [163, 1], "end": [164, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.convex", "code": "protected theorem Set.Subsingleton.convex {s : Set E} (h : s.Subsingleton) : Convex \ud835\udd5c s", "start": [167, 1], "end": [168, 45], "kind": "commanddeclaration"}, {"full_name": "convex_singleton", "code": "theorem convex_singleton (c : E) : Convex \ud835\udd5c ({c} : Set E)", "start": [171, 1], "end": [172, 32], "kind": "commanddeclaration"}, {"full_name": "convex_zero", "code": "theorem convex_zero : Convex \ud835\udd5c (0 : Set E)", "start": [175, 1], "end": [176, 21], "kind": "commanddeclaration"}, {"full_name": "convex_segment", "code": "theorem convex_segment (x y : E) : Convex \ud835\udd5c [x -[\ud835\udd5c] y]", "start": [179, 1], "end": [186, 35], "kind": "commanddeclaration"}, {"full_name": "Convex.linear_image", "code": "theorem Convex.linear_image (hs : Convex \ud835\udd5c s) (f : E \u2192\u2097[\ud835\udd5c] F) : Convex \ud835\udd5c (f '' s)", "start": [189, 1], "end": [193, 91], "kind": "commanddeclaration"}, {"full_name": "Convex.is_linear_image", "code": "theorem Convex.is_linear_image (hs : Convex \ud835\udd5c s) {f : E \u2192 F} (hf : IsLinearMap \ud835\udd5c f) :\n    Convex \ud835\udd5c (f '' s)", "start": [196, 1], "end": [198, 30], "kind": "commanddeclaration"}, {"full_name": "Convex.linear_preimage", "code": "theorem Convex.linear_preimage {s : Set F} (hs : Convex \ud835\udd5c s) (f : E \u2192\u2097[\ud835\udd5c] F) :\n    Convex \ud835\udd5c (f \u207b\u00b9' s)", "start": [201, 1], "end": [205, 27], "kind": "commanddeclaration"}, {"full_name": "Convex.is_linear_preimage", "code": "theorem Convex.is_linear_preimage {s : Set F} (hs : Convex \ud835\udd5c s) {f : E \u2192 F} (hf : IsLinearMap \ud835\udd5c f) :\n    Convex \ud835\udd5c (f \u207b\u00b9' s)", "start": [208, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "Convex.add", "code": "theorem Convex.add {t : Set E} (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) : Convex \ud835\udd5c (s + t)", "start": [213, 1], "end": [215, 65], "kind": "commanddeclaration"}, {"full_name": "convexAddSubmonoid", "code": "def convexAddSubmonoid : AddSubmonoid (Set E) where\n  carrier := {s : Set E | Convex \ud835\udd5c s}\n  zero_mem' := convex_zero\n  add_mem' := Convex.add", "start": [220, 1], "end": [224, 25], "kind": "commanddeclaration"}, {"full_name": "coe_convexAddSubmonoid", "code": "@[simp, norm_cast]\ntheorem coe_convexAddSubmonoid : \u2191(convexAddSubmonoid \ud835\udd5c E) = {s : Set E | Convex \ud835\udd5c s}", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "mem_convexAddSubmonoid", "code": "@[simp]\ntheorem mem_convexAddSubmonoid {s : Set E} : s \u2208 convexAddSubmonoid \ud835\udd5c E \u2194 Convex \ud835\udd5c s", "start": [234, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "convex_list_sum", "code": "theorem convex_list_sum {l : List (Set E)} (h : \u2200 i \u2208 l, Convex \ud835\udd5c i) : Convex \ud835\udd5c l.sum", "start": [239, 1], "end": [240, 42], "kind": "commanddeclaration"}, {"full_name": "convex_multiset_sum", "code": "theorem convex_multiset_sum {s : Multiset (Set E)} (h : \u2200 i \u2208 s, Convex \ud835\udd5c i) : Convex \ud835\udd5c s.sum", "start": [243, 1], "end": [244, 48], "kind": "commanddeclaration"}, {"full_name": "convex_sum", "code": "theorem convex_sum {\u03b9} {s : Finset \u03b9} (t : \u03b9 \u2192 Set E) (h : \u2200 i \u2208 s, Convex \ud835\udd5c (t i)) :\n    Convex \ud835\udd5c (\u2211 i in s, t i)", "start": [247, 1], "end": [249, 37], "kind": "commanddeclaration"}, {"full_name": "Convex.vadd", "code": "theorem Convex.vadd (hs : Convex \ud835\udd5c s) (z : E) : Convex \ud835\udd5c (z +\u1d65 s)", "start": [252, 1], "end": [254, 36], "kind": "commanddeclaration"}, {"full_name": "Convex.translate", "code": "theorem Convex.translate (hs : Convex \ud835\udd5c s) (z : E) : Convex \ud835\udd5c ((fun x => z + x) '' s)", "start": [257, 1], "end": [258, 12], "kind": "commanddeclaration"}, {"full_name": "Convex.translate_preimage_right", "code": "theorem Convex.translate_preimage_right (hs : Convex \ud835\udd5c s) (z : E) :\n    Convex \ud835\udd5c ((fun x => z + x) \u207b\u00b9' s)", "start": [261, 1], "end": [266, 77], "kind": "commanddeclaration"}, {"full_name": "Convex.translate_preimage_left", "code": "theorem Convex.translate_preimage_left (hs : Convex \ud835\udd5c s) (z : E) :\n    Convex \ud835\udd5c ((fun x => x + z) \u207b\u00b9' s)", "start": [269, 1], "end": [272, 60], "kind": "commanddeclaration"}, {"full_name": "convex_Iic", "code": "theorem convex_Iic (r : \u03b2) : Convex \ud835\udd5c (Iic r)", "start": [279, 1], "end": [283, 37], "kind": "commanddeclaration"}, {"full_name": "convex_Ici", "code": "theorem convex_Ici (r : \u03b2) : Convex \ud835\udd5c (Ici r)", "start": [286, 1], "end": [287, 30], "kind": "commanddeclaration"}, {"full_name": "convex_Icc", "code": "theorem convex_Icc (r s : \u03b2) : Convex \ud835\udd5c (Icc r s)", "start": [290, 1], "end": [291, 61], "kind": "commanddeclaration"}, {"full_name": "convex_halfspace_le", "code": "theorem convex_halfspace_le {f : E \u2192 \u03b2} (h : IsLinearMap \ud835\udd5c f) (r : \u03b2) : Convex \ud835\udd5c { w | f w \u2264 r }", "start": [294, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "convex_halfspace_ge", "code": "theorem convex_halfspace_ge {f : E \u2192 \u03b2} (h : IsLinearMap \ud835\udd5c f) (r : \u03b2) : Convex \ud835\udd5c { w | r \u2264 f w }", "start": [298, 1], "end": [299, 38], "kind": "commanddeclaration"}, {"full_name": "convex_hyperplane", "code": "theorem convex_hyperplane {f : E \u2192 \u03b2} (h : IsLinearMap \ud835\udd5c f) (r : \u03b2) : Convex \ud835\udd5c { w | f w = r }", "start": [302, 1], "end": [304, 66], "kind": "commanddeclaration"}, {"full_name": "convex_Iio", "code": "theorem convex_Iio (r : \u03b2) : Convex \ud835\udd5c (Iio r)", "start": [313, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "convex_Ioi", "code": "theorem convex_Ioi (r : \u03b2) : Convex \ud835\udd5c (Ioi r)", "start": [325, 1], "end": [326, 30], "kind": "commanddeclaration"}, {"full_name": "convex_Ioo", "code": "theorem convex_Ioo (r s : \u03b2) : Convex \ud835\udd5c (Ioo r s)", "start": [329, 1], "end": [330, 61], "kind": "commanddeclaration"}, {"full_name": "convex_Ico", "code": "theorem convex_Ico (r s : \u03b2) : Convex \ud835\udd5c (Ico r s)", "start": [333, 1], "end": [334, 61], "kind": "commanddeclaration"}, {"full_name": "convex_Ioc", "code": "theorem convex_Ioc (r s : \u03b2) : Convex \ud835\udd5c (Ioc r s)", "start": [337, 1], "end": [338, 61], "kind": "commanddeclaration"}, {"full_name": "convex_halfspace_lt", "code": "theorem convex_halfspace_lt {f : E \u2192 \u03b2} (h : IsLinearMap \ud835\udd5c f) (r : \u03b2) : Convex \ud835\udd5c { w | f w < r }", "start": [341, 1], "end": [342, 38], "kind": "commanddeclaration"}, {"full_name": "convex_halfspace_gt", "code": "theorem convex_halfspace_gt {f : E \u2192 \u03b2} (h : IsLinearMap \ud835\udd5c f) (r : \u03b2) : Convex \ud835\udd5c { w | r < f w }", "start": [345, 1], "end": [346, 38], "kind": "commanddeclaration"}, {"full_name": "convex_uIcc", "code": "theorem convex_uIcc (r s : \u03b2) : Convex \ud835\udd5c (uIcc r s)", "start": [355, 1], "end": [356, 17], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.convex_le", "code": "theorem MonotoneOn.convex_le (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x \u2264 r })", "start": [370, 1], "end": [374, 44], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.convex_lt", "code": "theorem MonotoneOn.convex_lt (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x < r })", "start": [377, 1], "end": [382, 44], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.convex_ge", "code": "theorem MonotoneOn.convex_ge (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r \u2264 f x })", "start": [385, 1], "end": [387, 61], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.convex_gt", "code": "theorem MonotoneOn.convex_gt (hf : MonotoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r < f x })", "start": [390, 1], "end": [392, 61], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.convex_le", "code": "theorem AntitoneOn.convex_le (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x \u2264 r })", "start": [395, 1], "end": [397, 54], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.convex_lt", "code": "theorem AntitoneOn.convex_lt (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x < r })", "start": [400, 1], "end": [402, 54], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.convex_ge", "code": "theorem AntitoneOn.convex_ge (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r \u2264 f x })", "start": [405, 1], "end": [407, 54], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.convex_gt", "code": "theorem AntitoneOn.convex_gt (hf : AntitoneOn f s) (hs : Convex \ud835\udd5c s) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r < f x })", "start": [410, 1], "end": [412, 54], "kind": "commanddeclaration"}, {"full_name": "Monotone.convex_le", "code": "theorem Monotone.convex_le (hf : Monotone f) (r : \u03b2) : Convex \ud835\udd5c { x | f x \u2264 r }", "start": [415, 1], "end": [416, 68], "kind": "commanddeclaration"}, {"full_name": "Monotone.convex_lt", "code": "theorem Monotone.convex_lt (hf : Monotone f) (r : \u03b2) : Convex \ud835\udd5c { x | f x \u2264 r }", "start": [419, 1], "end": [420, 68], "kind": "commanddeclaration"}, {"full_name": "Monotone.convex_ge", "code": "theorem Monotone.convex_ge (hf : Monotone f) (r : \u03b2) : Convex \ud835\udd5c { x | r \u2264 f x }", "start": [423, 1], "end": [424, 68], "kind": "commanddeclaration"}, {"full_name": "Monotone.convex_gt", "code": "theorem Monotone.convex_gt (hf : Monotone f) (r : \u03b2) : Convex \ud835\udd5c { x | f x \u2264 r }", "start": [427, 1], "end": [428, 68], "kind": "commanddeclaration"}, {"full_name": "Antitone.convex_le", "code": "theorem Antitone.convex_le (hf : Antitone f) (r : \u03b2) : Convex \ud835\udd5c { x | f x \u2264 r }", "start": [431, 1], "end": [432, 68], "kind": "commanddeclaration"}, {"full_name": "Antitone.convex_lt", "code": "theorem Antitone.convex_lt (hf : Antitone f) (r : \u03b2) : Convex \ud835\udd5c { x | f x < r }", "start": [435, 1], "end": [436, 68], "kind": "commanddeclaration"}, {"full_name": "Antitone.convex_ge", "code": "theorem Antitone.convex_ge (hf : Antitone f) (r : \u03b2) : Convex \ud835\udd5c { x | r \u2264 f x }", "start": [439, 1], "end": [440, 68], "kind": "commanddeclaration"}, {"full_name": "Antitone.convex_gt", "code": "theorem Antitone.convex_gt (hf : Antitone f) (r : \u03b2) : Convex \ud835\udd5c { x | r < f x }", "start": [443, 1], "end": [444, 68], "kind": "commanddeclaration"}, {"full_name": "Convex.smul", "code": "theorem Convex.smul (hs : Convex \ud835\udd5c s) (c : \ud835\udd5c) : Convex \ud835\udd5c (c \u2022 s)", "start": [459, 1], "end": [460, 42], "kind": "commanddeclaration"}, {"full_name": "Convex.smul_preimage", "code": "theorem Convex.smul_preimage (hs : Convex \ud835\udd5c s) (c : \ud835\udd5c) : Convex \ud835\udd5c ((fun z => c \u2022 z) \u207b\u00b9' s)", "start": [463, 1], "end": [464, 45], "kind": "commanddeclaration"}, {"full_name": "Convex.affinity", "code": "theorem Convex.affinity (hs : Convex \ud835\udd5c s) (z : E) (c : \ud835\udd5c) : Convex \ud835\udd5c ((fun x => z + c \u2022 x) '' s)", "start": [467, 1], "end": [468, 83], "kind": "commanddeclaration"}, {"full_name": "convex_openSegment", "code": "theorem convex_openSegment (a b : E) : Convex \ud835\udd5c (openSegment \ud835\udd5c a b)", "start": [479, 1], "end": [484, 61], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_mem", "code": "theorem Convex.add_smul_mem (hs : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : x + y \u2208 s) {t : \ud835\udd5c}\n    (ht : t \u2208 Icc (0 : \ud835\udd5c) 1) : x + t \u2022 y \u2208 s", "start": [497, 1], "end": [502, 67], "kind": "commanddeclaration"}, {"full_name": "Convex.smul_mem_of_zero_mem", "code": "theorem Convex.smul_mem_of_zero_mem (hs : Convex \ud835\udd5c s) {x : E} (zero_mem : (0 : E) \u2208 s) (hx : x \u2208 s)\n    {t : \ud835\udd5c} (ht : t \u2208 Icc (0 : \ud835\udd5c) 1) : t \u2022 x \u2208 s", "start": [505, 1], "end": [507, 62], "kind": "commanddeclaration"}, {"full_name": "Convex.mapsTo_lineMap", "code": "theorem Convex.mapsTo_lineMap (h : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) :\n    MapsTo (AffineMap.lineMap x y) (Icc (0 : \ud835\udd5c) 1) s", "start": [510, 1], "end": [512, 78], "kind": "commanddeclaration"}, {"full_name": "Convex.lineMap_mem", "code": "theorem Convex.lineMap_mem (h : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) {t : \ud835\udd5c}\n    (ht : t \u2208 Icc 0 1) : AffineMap.lineMap x y t \u2208 s", "start": [514, 1], "end": [516, 28], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul_sub_mem", "code": "theorem Convex.add_smul_sub_mem (h : Convex \ud835\udd5c s) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) {t : \ud835\udd5c}\n    (ht : t \u2208 Icc (0 : \ud835\udd5c) 1) : x + t \u2022 (y - x) \u2208 s", "start": [518, 1], "end": [521, 31], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.convex", "code": "theorem AffineSubspace.convex (Q : AffineSubspace \ud835\udd5c E) : Convex \ud835\udd5c (Q : Set E)", "start": [524, 1], "end": [528, 38], "kind": "commanddeclaration"}, {"full_name": "Convex.affine_preimage", "code": "theorem Convex.affine_preimage (f : E \u2192\u1d43[\ud835\udd5c] F) {s : Set F} (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (f \u207b\u00b9' s)", "start": [531, 1], "end": [533, 40], "kind": "commanddeclaration"}, {"full_name": "Convex.affine_image", "code": "theorem Convex.affine_image (f : E \u2192\u1d43[\ud835\udd5c] F) (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (f '' s)", "start": [536, 1], "end": [539, 31], "kind": "commanddeclaration"}, {"full_name": "Convex.neg", "code": "theorem Convex.neg (hs : Convex \ud835\udd5c s) : Convex \ud835\udd5c (-s)", "start": [542, 1], "end": [543, 52], "kind": "commanddeclaration"}, {"full_name": "Convex.sub", "code": "theorem Convex.sub (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) : Convex \ud835\udd5c (s - t)", "start": [546, 1], "end": [548, 22], "kind": "commanddeclaration"}, {"full_name": "convex_iff_div", "code": "theorem convex_iff_div :\n    Convex \ud835\udd5c s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192\n      \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192 (a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y \u2208 s", "start": [563, 1], "end": [567, 46], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_smul_of_zero_mem", "code": "theorem Convex.mem_smul_of_zero_mem (h : Convex \ud835\udd5c s) {x : E} (zero_mem : (0 : E) \u2208 s) (hx : x \u2208 s)\n    {t : \ud835\udd5c} (ht : 1 \u2264 t) : x \u2208 t \u2022 s", "start": [570, 1], "end": [573, 96], "kind": "commanddeclaration"}, {"full_name": "Convex.exists_mem_add_smul_eq", "code": "theorem Convex.exists_mem_add_smul_eq (h : Convex \ud835\udd5c s) {x y : E} {p q : \ud835\udd5c} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hp : 0 \u2264 p) (hq : 0 \u2264 q) : \u2203 z \u2208 s, (p + q) \u2022 z = p \u2022 x + q \u2022 y", "start": [576, 1], "end": [583, 63], "kind": "commanddeclaration"}, {"full_name": "Convex.add_smul", "code": "theorem Convex.add_smul (h_conv : Convex \ud835\udd5c s) {p q : \ud835\udd5c} (hp : 0 \u2264 p) (hq : 0 \u2264 q) :\n    (p + q) \u2022 s = p \u2022 s + q \u2022 s", "start": [585, 1], "end": [588, 50], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.convex_of_chain", "code": "theorem Set.OrdConnected.convex_of_chain [OrderedSemiring \ud835\udd5c] [OrderedAddCommMonoid E] [Module \ud835\udd5c E]\n    [OrderedSMul \ud835\udd5c E] {s : Set E} (hs : s.OrdConnected) (h : IsChain (\u00b7 \u2264 \u00b7) s) : Convex \ud835\udd5c s", "start": [603, 1], "end": [609, 56], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.convex", "code": "theorem Set.OrdConnected.convex [OrderedSemiring \ud835\udd5c] [LinearOrderedAddCommMonoid E] [Module \ud835\udd5c E]\n    [OrderedSMul \ud835\udd5c E] {s : Set E} (hs : s.OrdConnected) : Convex \ud835\udd5c s", "start": [612, 1], "end": [614, 50], "kind": "commanddeclaration"}, {"full_name": "convex_iff_ordConnected", "code": "theorem convex_iff_ordConnected [LinearOrderedField \ud835\udd5c] {s : Set \ud835\udd5c} : Convex \ud835\udd5c s \u2194 s.OrdConnected", "start": [617, 1], "end": [618, 88], "kind": "commanddeclaration"}, {"full_name": "Convex.ordConnected", "code": "alias \u27e8Convex.ordConnected, _\u27e9 := convex_iff_ordConnected", "start": [621, 1], "end": [621, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Submodule.convex", "code": "protected theorem convex (K : Submodule \ud835\udd5c E) : Convex \ud835\udd5c (\u2191K : Set E)", "start": [633, 1], "end": [635, 67], "kind": "commanddeclaration"}, {"full_name": "Submodule.starConvex", "code": "protected theorem starConvex (K : Submodule \ud835\udd5c E) : StarConvex \ud835\udd5c (0 : E) K", "start": [638, 1], "end": [639, 22], "kind": "commanddeclaration"}, {"full_name": "stdSimplex", "code": "def stdSimplex : Set (\u03b9 \u2192 \ud835\udd5c) :=\n  { f | (\u2200 x, 0 \u2264 f x) \u2227 \u2211 x, f x = 1 }", "start": [651, 1], "end": [654, 40], "kind": "commanddeclaration"}, {"full_name": "stdSimplex_eq_inter", "code": "theorem stdSimplex_eq_inter : stdSimplex \ud835\udd5c \u03b9 = (\u22c2 x, { f | 0 \u2264 f x }) \u2229 { f | \u2211 x, f x = 1 }", "start": [657, 1], "end": [659, 78], "kind": "commanddeclaration"}, {"full_name": "convex_stdSimplex", "code": "theorem convex_stdSimplex : Convex \ud835\udd5c (stdSimplex \ud835\udd5c \u03b9)", "start": [662, 1], "end": [669, 14], "kind": "commanddeclaration"}, {"full_name": "ite_eq_mem_stdSimplex", "code": "theorem ite_eq_mem_stdSimplex (i : \u03b9) : (fun j => ite (i = j) (1 : \ud835\udd5c) 0) \u2208 stdSimplex \ud835\udd5c \u03b9", "start": [674, 1], "end": [676, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sets/Opens.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Homeomorph.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Copy.lean", "Mathlib/Order/CompactlyGenerated.lean", "Mathlib/Order/Hom/CompleteLattice.lean"], "premises": [{"full_name": "TopologicalSpace.Opens", "code": "structure Opens where\n  \n  carrier : Set \u03b1\n  \n  is_open' : IsOpen carrier", "start": [62, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.forall", "code": "theorem \u00abforall\u00bb {p : Opens \u03b1 \u2192 Prop} : (\u2200 U, p U) \u2194 \u2200 (U : Set \u03b1) (hU : IsOpen U), p \u27e8U, hU\u27e9", "start": [81, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.carrier_eq_coe", "code": "@[simp] theorem carrier_eq_coe (U : Opens \u03b1) : U.1 = \u2191U", "start": [85, 1], "end": [85, 63], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_mk", "code": "@[simp]\ntheorem coe_mk {U : Set \u03b1} {hU : IsOpen U} : \u2191(\u27e8U, hU\u27e9 : Opens \u03b1) = U", "start": [88, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mem_mk", "code": "@[simp]\ntheorem mem_mk {x : \u03b1} {U : Set \u03b1} {h : IsOpen U} : x \u2208 mk U h \u2194 x \u2208 U", "start": [94, 1], "end": [95, 82], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.nonempty_coeSort", "code": "protected theorem nonempty_coeSort {U : Opens \u03b1} : Nonempty U \u2194 (U : Set \u03b1).Nonempty", "start": [99, 1], "end": [100, 24], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.nonempty_coe", "code": "protected theorem nonempty_coe {U : Opens \u03b1} : (U : Set \u03b1).Nonempty \u2194 \u2203 x, x \u2208 U", "start": [104, 1], "end": [105, 10], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.ext", "code": "@[ext] theorem ext {U V : Opens \u03b1} (h : (U : Set \u03b1) = V) : U = V", "start": [107, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_inj", "code": "theorem coe_inj {U V : Opens \u03b1} : (U : Set \u03b1) = V \u2194 U = V", "start": [113, 1], "end": [114, 24], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.isOpen", "code": "protected theorem isOpen (U : Opens \u03b1) : IsOpen (U : Set \u03b1)", "start": [117, 1], "end": [118, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mk_coe", "code": "@[simp] theorem mk_coe (U : Opens \u03b1) : mk (\u2191U) U.isOpen = U", "start": [121, 1], "end": [121, 67], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.Simps.coe", "code": "def Simps.coe (U : Opens \u03b1) : Set \u03b1 := U", "start": [124, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.interior", "code": "nonrec def interior (s : Set \u03b1) : Opens \u03b1 :=\n  \u27e8interior s, isOpen_interior\u27e9", "start": [130, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.gc", "code": "theorem gc : GaloisConnection ((\u2191) : Opens \u03b1 \u2192 Set \u03b1) interior", "start": [135, 1], "end": [136, 78], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.gi", "code": "def gi : GaloisCoinsertion (\u2191) (@interior \u03b1 _) where\n  choice s hs := \u27e8s, interior_eq_iff_isOpen.mp <| le_antisymm interior_subset hs\u27e9\n  gc := gc\n  u_l_le _ := interior_subset\n  choice_eq _s hs := le_antisymm hs interior_subset", "start": [139, 1], "end": [144, 52], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mk_inf_mk", "code": "@[simp]\ntheorem mk_inf_mk {U V : Set \u03b1} {hU : IsOpen U} {hV : IsOpen V} :\n    (\u27e8U, hU\u27e9 \u2293 \u27e8V, hV\u27e9 : Opens \u03b1) = \u27e8U \u2293 V, IsOpen.inter hU hV\u27e9", "start": [166, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : Opens \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (s t : Opens \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = \u2191s \u222a \u2191t", "start": [177, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : Opens \u03b1) : Set \u03b1) = \u2205", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mk_empty", "code": "@[simp] theorem mk_empty : (\u27e8\u2205, isOpen_empty\u27e9 : Opens \u03b1) = \u22a5", "start": [187, 1], "end": [187, 68], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_eq_empty", "code": "@[simp, norm_cast]\ntheorem coe_eq_empty {U : Opens \u03b1} : (U : Set \u03b1) = \u2205 \u2194 U = \u22a5", "start": [190, 1], "end": [192, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : Opens \u03b1) : Set \u03b1) = Set.univ", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mk_univ", "code": "@[simp] theorem mk_univ : (\u27e8univ, isOpen_univ\u27e9 : Opens \u03b1) = \u22a4", "start": [199, 1], "end": [199, 69], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_eq_univ", "code": "@[simp, norm_cast]\ntheorem coe_eq_univ {U : Opens \u03b1} : (U : Set \u03b1) = univ \u2194 U = \u22a4", "start": [202, 1], "end": [204, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_sSup", "code": "@[simp, norm_cast]\ntheorem coe_sSup {S : Set (Opens \u03b1)} : (\u2191(sSup S) : Set \u03b1) = \u22c3 i \u2208 S, \u2191i", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_finset_sup", "code": "@[simp, norm_cast]\ntheorem coe_finset_sup (f : \u03b9 \u2192 Opens \u03b1) (s : Finset \u03b9) : (\u2191(s.sup f) : Set \u03b1) = s.sup ((\u2191) \u2218 f)", "start": [211, 1], "end": [213, 79], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_finset_inf", "code": "@[simp, norm_cast]\ntheorem coe_finset_inf (f : \u03b9 \u2192 Opens \u03b1) (s : Finset \u03b9) : (\u2191(s.inf f) : Set \u03b1) = s.inf ((\u2191) \u2218 f)", "start": [216, 1], "end": [218, 79], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_iSup", "code": "@[simp, norm_cast]\ntheorem coe_iSup {\u03b9} (s : \u03b9 \u2192 Opens \u03b1) : ((\u2a06 i, s i : Opens \u03b1) : Set \u03b1) = \u22c3 i, s i", "start": [231, 1], "end": [233, 14], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.iSup_def", "code": "theorem iSup_def {\u03b9} (s : \u03b9 \u2192 Opens \u03b1) : \u2a06 i, s i = \u27e8\u22c3 i, s i, isOpen_iUnion fun i => (s i).2\u27e9", "start": [236, 1], "end": [237, 20], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.iSup_mk", "code": "@[simp]\ntheorem iSup_mk {\u03b9} (s : \u03b9 \u2192 Set \u03b1) (h : \u2200 i, IsOpen (s i)) :\n    (\u2a06 i, \u27e8s i, h i\u27e9 : Opens \u03b1) = \u27e8\u22c3 i, s i, isOpen_iUnion h\u27e9", "start": [240, 1], "end": [243, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mem_iSup", "code": "@[simp]\ntheorem mem_iSup {\u03b9} {x : \u03b1} {s : \u03b9 \u2192 Opens \u03b1} : x \u2208 iSup s \u2194 \u2203 i, x \u2208 s i", "start": [246, 1], "end": [249, 7], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.mem_sSup", "code": "@[simp]\ntheorem mem_sSup {Us : Set (Opens \u03b1)} {x : \u03b1} : x \u2208 sSup Us \u2194 \u2203 u \u2208 Us, x \u2208 u", "start": [252, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.openEmbedding_of_le", "code": "theorem openEmbedding_of_le {U V : Opens \u03b1} (i : U \u2264 V) :\n    OpenEmbedding (Set.inclusion $ SetLike.coe_subset_coe.2 i)", "start": [263, 1], "end": [268, 55], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.not_nonempty_iff_eq_bot", "code": "theorem not_nonempty_iff_eq_bot (U : Opens \u03b1) : \u00acSet.Nonempty (U : Set \u03b1) \u2194 U = \u22a5", "start": [271, 1], "end": [272, 59], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.ne_bot_iff_nonempty", "code": "theorem ne_bot_iff_nonempty (U : Opens \u03b1) : U \u2260 \u22a5 \u2194 Set.Nonempty (U : Set \u03b1)", "start": [275, 1], "end": [276, 50], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.eq_bot_or_top", "code": "theorem eq_bot_or_top {\u03b1} [t : TopologicalSpace \u03b1] (h : t = \u22a4) (U : Opens \u03b1) : U = \u22a5 \u2228 U = \u22a4", "start": [279, 1], "end": [283, 12], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.IsBasis", "code": "def IsBasis (B : Set (Opens \u03b1)) : Prop :=\n  IsTopologicalBasis (((\u2191) : _ \u2192 Set \u03b1) '' B)", "start": [290, 1], "end": [292, 46], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.isBasis_iff_nbhd", "code": "theorem isBasis_iff_nbhd {B : Set (Opens \u03b1)} :\n    IsBasis B \u2194 \u2200 {U : Opens \u03b1} {x}, x \u2208 U \u2192 \u2203 U' \u2208 B, x \u2208 U' \u2227 U' \u2264 U", "start": [295, 1], "end": [310, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.isBasis_iff_cover", "code": "theorem isBasis_iff_cover {B : Set (Opens \u03b1)} :\n    IsBasis B \u2194 \u2200 U : Opens \u03b1, \u2203 Us, Us \u2286 B \u2227 U = sSup Us", "start": [313, 1], "end": [326, 38], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.IsBasis.isCompact_open_iff_eq_finite_iUnion", "code": "theorem IsBasis.isCompact_open_iff_eq_finite_iUnion {\u03b9 : Type*} (b : \u03b9 \u2192 Opens \u03b1)\n    (hb : IsBasis (Set.range b)) (hb' : \u2200 i, IsCompact (b i : Set \u03b1)) (U : Set \u03b1) :\n    IsCompact U \u2227 IsOpen U \u2194 \u2203 s : Set \u03b9, s.Finite \u2227 U = \u22c3 i \u2208 s, b i", "start": [329, 1], "end": [338, 14], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.isCompactElement_iff", "code": "@[simp]\ntheorem isCompactElement_iff (s : Opens \u03b1) :\n    CompleteLattice.IsCompactElement s \u2194 IsCompact (s : Set \u03b1)", "start": [341, 1], "end": [356, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap", "code": "def comap (f : C(\u03b1, \u03b2)) : FrameHom (Opens \u03b2) (Opens \u03b1) where\n  toFun s := \u27e8f \u207b\u00b9' s, s.2.preimage f.continuous\u27e9\n  map_sSup' s := ext <| by simp only [coe_sSup, preimage_iUnion, biUnion_image, coe_mk]\n  map_inf' a b := rfl\n  map_top' := rfl", "start": [359, 1], "end": [364, 18], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap_id", "code": "@[simp]\ntheorem comap_id : comap (ContinuousMap.id \u03b1) = FrameHom.id _", "start": [367, 1], "end": [369, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap_mono", "code": "theorem comap_mono (f : C(\u03b1, \u03b2)) {s t : Opens \u03b2} (h : s \u2264 t) : comap f s \u2264 comap f t", "start": [372, 1], "end": [373, 33], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.coe_comap", "code": "@[simp]\ntheorem coe_comap (f : C(\u03b1, \u03b2)) (U : Opens \u03b2) : \u2191(comap f U) = f \u207b\u00b9' U", "start": [376, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap_comp", "code": "protected theorem comap_comp (g : C(\u03b2, \u03b3)) (f : C(\u03b1, \u03b2)) :\n    comap (g.comp f) = (comap f).comp (comap g)", "start": [381, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap_comap", "code": "protected theorem comap_comap (g : C(\u03b2, \u03b3)) (f : C(\u03b1, \u03b2)) (U : Opens \u03b3) :\n    comap f (comap g U) = comap (g.comp f) U", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.comap_injective", "code": "theorem comap_injective [T0Space \u03b2] : Injective (comap : C(\u03b1, \u03b2) \u2192 FrameHom (Opens \u03b2) (Opens \u03b1))", "start": [391, 1], "end": [397, 77], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.opensCongr", "code": "@[simps (config := { fullyApplied := false }) apply]\ndef _root_.Homeomorph.opensCongr (f : \u03b1 \u2243\u209c \u03b2) : Opens \u03b1 \u2243o Opens \u03b2 where\n  toFun := Opens.comap f.symm.toContinuousMap\n  invFun := Opens.comap f.toContinuousMap\n  left_inv := fun U => ext <| f.toEquiv.preimage_symm_preimage _\n  right_inv := fun U => ext <| f.toEquiv.symm_preimage_preimage _\n  map_rel_iff' := by\n    simp only [\u2190 SetLike.coe_subset_coe]; exact f.symm.surjective.preimage_subset_preimage_iff", "start": [400, 1], "end": [408, 95], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.opensCongr_symm", "code": "@[simp]\ntheorem _root_.Homeomorph.opensCongr_symm (f : \u03b1 \u2243\u209c \u03b2) : f.opensCongr.symm = f.symm.opensCongr", "start": [411, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf", "code": "structure OpenNhdsOf (x : \u03b1) extends Opens \u03b1 where\n  \n  mem' : x \u2208 carrier", "start": [421, 1], "end": [424, 21], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.toOpens_injective", "code": "theorem toOpens_injective : Injective (toOpens : OpenNhdsOf x \u2192 Opens \u03b1)", "start": [431, 1], "end": [432, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.canLiftSet", "code": "instance canLiftSet : CanLift (Set \u03b1) (OpenNhdsOf x) (\u2191) fun s => IsOpen s \u2227 x \u2208 s :=\n  \u27e8fun s hs => \u27e8\u27e8\u27e8s, hs.1\u27e9, hs.2\u27e9, rfl\u27e9\u27e9", "start": [439, 1], "end": [440, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.mem", "code": "protected theorem mem (U : OpenNhdsOf x) : x \u2208 U", "start": [443, 1], "end": [444, 9], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.isOpen", "code": "protected theorem isOpen (U : OpenNhdsOf x) : IsOpen (U : Set \u03b1)", "start": [447, 1], "end": [448, 13], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.basis_nhds", "code": "theorem basis_nhds : (\ud835\udcdd x).HasBasis (fun _ : OpenNhdsOf x => True) (\u2191)", "start": [466, 1], "end": [468, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.OpenNhdsOf.comap", "code": "def comap (f : C(\u03b1, \u03b2)) (x : \u03b1) : LatticeHom (OpenNhdsOf (f x)) (OpenNhdsOf x) where\n  toFun U := \u27e8Opens.comap f U.1, U.mem\u27e9\n  map_sup' _ _ := rfl\n  map_inf' _ _ := rfl", "start": [471, 1], "end": [475, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/LocalEquiv.lean", "imports": ["Mathlib/Tactic/Core.lean", "Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Attr/Core.lean"], "premises": [{"full_name": "mfld_cfg", "code": "def mfld_cfg : Simps.Config where\n  attrs := [`mfld_simps]\n  fullyApplied := false", "start": [80, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv", "code": "structure LocalEquiv (\u03b1 : Type*) (\u03b2 : Type*) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  invFun : \u03b2 \u2192 \u03b1\n  \n  source : Set \u03b1\n  \n  target : Set \u03b2\n  \n  map_source' : \u2200 \u2983x\u2984, x \u2208 source \u2192 toFun x \u2208 target\n  \n  map_target' : \u2200 \u2983x\u2984, x \u2208 target \u2192 invFun x \u2208 source\n  \n  left_inv' : \u2200 \u2983x\u2984, x \u2208 source \u2192 invFun (toFun x) = x\n  \n  right_inv' : \u2200 \u2983x\u2984, x \u2208 target \u2192 toFun (invFun x) = x", "start": [116, 1], "end": [137, 56], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm", "code": "protected def symm : LocalEquiv \u03b2 \u03b1 where\n  toFun := e.invFun\n  invFun := e.toFun\n  source := e.target\n  target := e.source\n  map_source' := e.map_target'\n  map_target' := e.map_source'\n  left_inv' := e.right_inv'\n  right_inv' := e.left_inv'", "start": [150, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : LocalEquiv \u03b1 \u03b2) : \u03b2 \u2192 \u03b1 :=\n  e.symm", "start": [165, 1], "end": [167, 9], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.coe_symm_mk", "code": "@[simp, mfld_simps]\ntheorem coe_symm_mk (f : \u03b1 \u2192 \u03b2) (g s t ml mr il ir) :\n    ((LocalEquiv.mk f g s t ml mr il ir).symm : \u03b2 \u2192 \u03b1) = g", "start": [179, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.invFun_as_coe", "code": "@[simp, mfld_simps]\ntheorem invFun_as_coe : e.invFun = e.symm", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.map_source", "code": "@[simp, mfld_simps]\ntheorem map_source {x : \u03b1} (h : x \u2208 e.source) : e x \u2208 e.target", "start": [196, 1], "end": [198, 18], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.map_target", "code": "@[simp, mfld_simps]\ntheorem map_target {x : \u03b2} (h : x \u2208 e.target) : e.symm x \u2208 e.source", "start": [201, 1], "end": [203, 18], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.left_inv", "code": "@[simp, mfld_simps]\ntheorem left_inv {x : \u03b1} (h : x \u2208 e.source) : e.symm (e x) = x", "start": [206, 1], "end": [208, 16], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.right_inv", "code": "@[simp, mfld_simps]\ntheorem right_inv {x : \u03b2} (h : x \u2208 e.target) : e (e.symm x) = x", "start": [211, 1], "end": [213, 17], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.eq_symm_apply", "code": "theorem eq_symm_apply {x : \u03b1} {y : \u03b2} (hx : x \u2208 e.source) (hy : y \u2208 e.target) :\n    x = e.symm y \u2194 e x = y", "start": [216, 1], "end": [218, 78], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.mapsTo", "code": "protected theorem mapsTo : MapsTo e e.source e.target", "start": [221, 1], "end": [221, 79], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_mapsTo", "code": "theorem symm_mapsTo : MapsTo e.symm e.target e.source", "start": [224, 1], "end": [225, 16], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.leftInvOn", "code": "protected theorem leftInvOn : LeftInvOn e.symm e e.source", "start": [228, 1], "end": [228, 81], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.rightInvOn", "code": "protected theorem rightInvOn : RightInvOn e.symm e e.target", "start": [231, 1], "end": [231, 84], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.invOn", "code": "protected theorem invOn : InvOn e.symm e e.source e.target", "start": [234, 1], "end": [235, 30], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.injOn", "code": "protected theorem injOn : InjOn e e.source", "start": [238, 1], "end": [239, 20], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.bijOn", "code": "protected theorem bijOn : BijOn e e.source e.target", "start": [242, 1], "end": [243, 39], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.surjOn", "code": "protected theorem surjOn : SurjOn e e.source e.target", "start": [246, 1], "end": [247, 17], "kind": "commanddeclaration"}, {"full_name": "Equiv.toLocalEquivOfImageEq", "code": "@[simps (config := .asFn)]\ndef _root_.Equiv.toLocalEquivOfImageEq (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) (t : Set \u03b2) (h : e '' s = t) :\n    LocalEquiv \u03b1 \u03b2 where\n  toFun := e\n  invFun := e.symm\n  source := s\n  target := t\n  map_source' x hx := h \u25b8 mem_image_of_mem _ hx\n  map_target' x hx := by\n    subst t\n    rcases hx with \u27e8x, hx, rfl\u27e9\n    rwa [e.symm_apply_apply]\n  left_inv' x _ := e.symm_apply_apply x\n  right_inv' x _ := e.apply_symm_apply x", "start": [250, 1], "end": [265, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.toLocalEquiv", "code": "@[simps! (config := mfld_cfg)]\ndef _root_.Equiv.toLocalEquiv (e : \u03b1 \u2243 \u03b2) : LocalEquiv \u03b1 \u03b2 :=\n  e.toLocalEquivOfImageEq univ univ <| by rw [image_univ, e.surjective.range_eq]", "start": [267, 1], "end": [270, 81], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.inhabitedOfEmpty", "code": "instance inhabitedOfEmpty [IsEmpty \u03b1] [IsEmpty \u03b2] : Inhabited (LocalEquiv \u03b1 \u03b2) :=\n  \u27e8((Equiv.equivEmpty \u03b1).trans (Equiv.equivEmpty \u03b2).symm).toLocalEquiv\u27e9", "start": [277, 1], "end": [278, 72], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.copy", "code": "@[simps (config := { fullyApplied := false })]\ndef copy (e : LocalEquiv \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2) (hf : \u21d1e = f) (g : \u03b2 \u2192 \u03b1) (hg : \u21d1e.symm = g) (s : Set \u03b1)\n    (hs : e.source = s) (t : Set \u03b2) (ht : e.target = t) :\n    LocalEquiv \u03b1 \u03b2 where\n  toFun := f\n  invFun := g\n  source := s\n  target := t\n  map_source' _ := ht \u25b8 hs \u25b8 hf \u25b8 e.map_source\n  map_target' _ := hs \u25b8 ht \u25b8 hg \u25b8 e.map_target\n  left_inv' _ := hs \u25b8 hf \u25b8 hg \u25b8 e.left_inv\n  right_inv' _ := ht \u25b8 hf \u25b8 hg \u25b8 e.right_inv", "start": [281, 1], "end": [293, 45], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.copy_eq", "code": "theorem copy_eq (e : LocalEquiv \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2) (hf : \u21d1e = f) (g : \u03b2 \u2192 \u03b1) (hg : \u21d1e.symm = g)\n    (s : Set \u03b1) (hs : e.source = s) (t : Set \u03b2) (ht : e.target = t) :\n    e.copy f hf g hg s hs t ht = e", "start": [300, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.toEquiv", "code": "protected def toEquiv : e.source \u2243 e.target where\n  toFun x := \u27e8e x, e.map_source x.mem\u27e9\n  invFun y := \u27e8e.symm y, e.map_target y.mem\u27e9\n  left_inv := fun \u27e8_, hx\u27e9 => Subtype.eq <| e.left_inv hx\n  right_inv := fun \u27e8_, hy\u27e9 => Subtype.eq <| e.right_inv hy", "start": [308, 1], "end": [313, 59], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_source", "code": "@[simp, mfld_simps]\ntheorem symm_source : e.symm.source = e.target", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_target", "code": "@[simp, mfld_simps]\ntheorem symm_target : e.symm.target = e.source", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_symm", "code": "@[simp, mfld_simps]\ntheorem symm_symm : e.symm.symm = e", "start": [326, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_source_eq_target", "code": "theorem image_source_eq_target : e '' e.source = e.target", "start": [332, 1], "end": [333, 19], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.forall_mem_target", "code": "theorem forall_mem_target {p : \u03b2 \u2192 Prop} : (\u2200 y \u2208 e.target, p y) \u2194 \u2200 x \u2208 e.source, p (e x)", "start": [336, 1], "end": [337, 48], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.exists_mem_target", "code": "theorem exists_mem_target {p : \u03b2 \u2192 Prop} : (\u2203 y \u2208 e.target, p y) \u2194 \u2203 x \u2208 e.source, p (e x)", "start": [340, 1], "end": [341, 47], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage", "code": "def IsImage (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 e.source \u2192 (e x \u2208 t \u2194 x \u2208 s)", "start": [344, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.apply_mem_iff", "code": "theorem apply_mem_iff (h : e.IsImage s t) (hx : x \u2208 e.source) : e x \u2208 t \u2194 x \u2208 s", "start": [359, 1], "end": [360, 7], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_apply_mem_iff", "code": "theorem symm_apply_mem_iff (h : e.IsImage s t) : \u2200 \u2983y\u2984, y \u2208 e.target \u2192 (e.symm y \u2208 s \u2194 y \u2208 t)", "start": [363, 1], "end": [364, 66], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm", "code": "protected theorem symm (h : e.IsImage s t) : e.symm.IsImage t s", "start": [367, 1], "end": [368, 23], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_iff", "code": "@[simp]\ntheorem symm_iff : e.symm.IsImage t s \u2194 e.IsImage s t", "start": [371, 1], "end": [373, 37], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.mapsTo", "code": "protected theorem mapsTo (h : e.IsImage s t) : MapsTo e (e.source \u2229 s) (e.target \u2229 t)", "start": [376, 1], "end": [377, 47], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_mapsTo", "code": "theorem symm_mapsTo (h : e.IsImage s t) : MapsTo e.symm (e.target \u2229 t) (e.source \u2229 s)", "start": [380, 1], "end": [381, 16], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.restr", "code": "@[simps (config := { fullyApplied := false })]\ndef restr (h : e.IsImage s t) : LocalEquiv \u03b1 \u03b2 where\n  toFun := e\n  invFun := e.symm\n  source := e.source \u2229 s\n  target := e.target \u2229 t\n  map_source' := h.mapsTo\n  map_target' := h.symm_mapsTo\n  left_inv' := e.leftInvOn.mono (inter_subset_left _ _)\n  right_inv' := e.rightInvOn.mono (inter_subset_left _ _)", "start": [384, 1], "end": [394, 58], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.image_eq", "code": "theorem image_eq (h : e.IsImage s t) : e '' (e.source \u2229 s) = e.target \u2229 t", "start": [401, 1], "end": [402, 33], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_image_eq", "code": "theorem symm_image_eq (h : e.IsImage s t) : e.symm '' (e.target \u2229 t) = e.source \u2229 s", "start": [405, 1], "end": [406, 18], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.iff_preimage_eq", "code": "theorem iff_preimage_eq : e.IsImage s t \u2194 e.source \u2229 e \u207b\u00b9' t = e.source \u2229 s", "start": [409, 1], "end": [410, 81], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.preimage_eq", "code": "alias \u27e8preimage_eq, of_preimage_eq\u27e9 := iff_preimage_eq", "start": [413, 1], "end": [413, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalEquiv.IsImage.of_preimage_eq", "code": "alias \u27e8preimage_eq, of_preimage_eq\u27e9 := iff_preimage_eq", "start": [413, 1], "end": [413, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalEquiv.IsImage.iff_symm_preimage_eq", "code": "theorem iff_symm_preimage_eq : e.IsImage s t \u2194 e.target \u2229 e.symm \u207b\u00b9' s = e.target \u2229 t", "start": [417, 1], "end": [418, 38], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_preimage_eq", "code": "alias \u27e8symm_preimage_eq, of_symm_preimage_eq\u27e9 := iff_symm_preimage_eq", "start": [421, 1], "end": [421, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalEquiv.IsImage.of_symm_preimage_eq", "code": "alias \u27e8symm_preimage_eq, of_symm_preimage_eq\u27e9 := iff_symm_preimage_eq", "start": [421, 1], "end": [421, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalEquiv.IsImage.of_image_eq", "code": "theorem of_image_eq (h : e '' (e.source \u2229 s) = e.target \u2229 t) : e.IsImage s t", "start": [425, 1], "end": [426, 76], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.of_symm_image_eq", "code": "theorem of_symm_image_eq (h : e.symm '' (e.target \u2229 t) = e.source \u2229 s) : e.IsImage s t", "start": [429, 1], "end": [430, 74], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.compl", "code": "protected theorem compl (h : e.IsImage s t) : e.IsImage s\u1d9c t\u1d9c", "start": [433, 1], "end": [433, 94], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.inter", "code": "protected theorem inter {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \u2229 s') (t \u2229 t')", "start": [436, 1], "end": [437, 72], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.union", "code": "protected theorem union {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \u222a s') (t \u222a t')", "start": [440, 1], "end": [441, 71], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.diff", "code": "protected theorem diff {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \\ s') (t \\ t')", "start": [444, 1], "end": [446, 19], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.leftInvOn_piecewise", "code": "theorem leftInvOn_piecewise {e' : LocalEquiv \u03b1 \u03b2} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : e.IsImage s t) (h' : e'.IsImage s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source)", "start": [449, 1], "end": [455, 22], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.inter_eq_of_inter_eq_of_eqOn", "code": "theorem inter_eq_of_inter_eq_of_eqOn {e' : LocalEquiv \u03b1 \u03b2} (h : e.IsImage s t)\n    (h' : e'.IsImage s t) (hs : e.source \u2229 s = e'.source \u2229 s) (heq : EqOn e e' (e.source \u2229 s)) :\n    e.target \u2229 t = e'.target \u2229 t", "start": [458, 1], "end": [460, 92], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.IsImage.symm_eq_on_of_inter_eq_of_eqOn", "code": "theorem symm_eq_on_of_inter_eq_of_eqOn {e' : LocalEquiv \u03b1 \u03b2} (h : e.IsImage s t)\n    (hs : e.source \u2229 s = e'.source \u2229 s) (heq : EqOn e e' (e.source \u2229 s)) :\n    EqOn e.symm e'.symm (e.target \u2229 t)", "start": [463, 1], "end": [469, 50], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.isImage_source_target", "code": "theorem isImage_source_target : e.IsImage e.source e.target", "start": [474, 1], "end": [474, 88], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.isImage_source_target_of_disjoint", "code": "theorem isImage_source_target_of_disjoint (e' : LocalEquiv \u03b1 \u03b2) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) : e.IsImage e'.source e'.target", "start": [477, 1], "end": [479, 71], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_source_inter_eq'", "code": "theorem image_source_inter_eq' (s : Set \u03b1) : e '' (e.source \u2229 s) = e.target \u2229 e.symm \u207b\u00b9' s", "start": [482, 1], "end": [483, 80], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_source_inter_eq", "code": "theorem image_source_inter_eq (s : Set \u03b1) :\n    e '' (e.source \u2229 s) = e.target \u2229 e.symm \u207b\u00b9' (e.source \u2229 s)", "start": [486, 1], "end": [488, 79], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_eq_target_inter_inv_preimage", "code": "theorem image_eq_target_inter_inv_preimage {s : Set \u03b1} (h : s \u2286 e.source) :\n    e '' s = e.target \u2229 e.symm \u207b\u00b9' s", "start": [491, 1], "end": [493, 67], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_image_eq_source_inter_preimage", "code": "theorem symm_image_eq_source_inter_preimage {s : Set \u03b2} (h : s \u2286 e.target) :\n    e.symm '' s = e.source \u2229 e \u207b\u00b9' s", "start": [496, 1], "end": [498, 46], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_image_target_inter_eq", "code": "theorem symm_image_target_inter_eq (s : Set \u03b2) :\n    e.symm '' (e.target \u2229 s) = e.source \u2229 e \u207b\u00b9' (e.target \u2229 s)", "start": [501, 1], "end": [503, 33], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_image_target_inter_eq'", "code": "theorem symm_image_target_inter_eq' (s : Set \u03b2) : e.symm '' (e.target \u2229 s) = e.source \u2229 e \u207b\u00b9' s", "start": [506, 1], "end": [507, 34], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.source_inter_preimage_inv_preimage", "code": "theorem source_inter_preimage_inv_preimage (s : Set \u03b1) :\n    e.source \u2229 e \u207b\u00b9' (e.symm \u207b\u00b9' s) = e.source \u2229 s", "start": [510, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.source_inter_preimage_target_inter", "code": "theorem source_inter_preimage_target_inter (s : Set \u03b2) :\n    e.source \u2229 e \u207b\u00b9' (e.target \u2229 s) = e.source \u2229 e \u207b\u00b9' s", "start": [516, 1], "end": [518, 85], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.target_inter_inv_preimage_preimage", "code": "theorem target_inter_inv_preimage_preimage (s : Set \u03b2) :\n    e.target \u2229 e.symm \u207b\u00b9' (e \u207b\u00b9' s) = e.target \u2229 s", "start": [521, 1], "end": [523, 46], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_image_image_of_subset_source", "code": "theorem symm_image_image_of_subset_source {s : Set \u03b1} (h : s \u2286 e.source) : e.symm '' (e '' s) = s", "start": [526, 1], "end": [527, 35], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_symm_image_of_subset_target", "code": "theorem image_symm_image_of_subset_target {s : Set \u03b2} (h : s \u2286 e.target) : e '' (e.symm '' s) = s", "start": [530, 1], "end": [531, 45], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.source_subset_preimage_target", "code": "theorem source_subset_preimage_target : e.source \u2286 e \u207b\u00b9' e.target", "start": [534, 1], "end": [535, 11], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_image_target_eq_source", "code": "theorem symm_image_target_eq_source : e.symm '' e.target = e.source", "start": [538, 1], "end": [539, 32], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.target_subset_preimage_source", "code": "theorem target_subset_preimage_source : e.target \u2286 e.symm \u207b\u00b9' e.source", "start": [542, 1], "end": [543, 16], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ext", "code": "@[ext]\nprotected theorem ext {e e' : LocalEquiv \u03b1 \u03b2} (h : \u2200 x, e x = e' x)\n    (hsymm : \u2200 x, e.symm x = e'.symm x) (hs : e.source = e'.source) : e = e'", "start": [546, 1], "end": [561, 11], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr", "code": "protected def restr (s : Set \u03b1) : LocalEquiv \u03b1 \u03b2 :=\n  (@IsImage.of_symm_preimage_eq \u03b1 \u03b2 e s (e.symm \u207b\u00b9' s) rfl).restr", "start": [564, 1], "end": [566, 66], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_coe", "code": "@[simp, mfld_simps]\ntheorem restr_coe (s : Set \u03b1) : (e.restr s : \u03b1 \u2192 \u03b2) = e", "start": [569, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_coe_symm", "code": "@[simp, mfld_simps]\ntheorem restr_coe_symm (s : Set \u03b1) : ((e.restr s).symm : \u03b2 \u2192 \u03b1) = e.symm", "start": [574, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_source", "code": "@[simp, mfld_simps]\ntheorem restr_source (s : Set \u03b1) : (e.restr s).source = e.source \u2229 s", "start": [579, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_target", "code": "@[simp, mfld_simps]\ntheorem restr_target (s : Set \u03b1) : (e.restr s).target = e.target \u2229 e.symm \u207b\u00b9' s", "start": [584, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_eq_of_source_subset", "code": "theorem restr_eq_of_source_subset {e : LocalEquiv \u03b1 \u03b2} {s : Set \u03b1} (h : e.source \u2286 s) :\n    e.restr s = e", "start": [589, 1], "end": [591, 90], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_univ", "code": "@[simp, mfld_simps]\ntheorem restr_univ {e : LocalEquiv \u03b1 \u03b2} : e.restr univ = e", "start": [594, 1], "end": [596, 44], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl", "code": "protected def refl (\u03b1 : Type*) : LocalEquiv \u03b1 \u03b1 :=\n  (Equiv.refl \u03b1).toLocalEquiv", "start": [599, 1], "end": [601, 30], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_source", "code": "@[simp, mfld_simps]\ntheorem refl_source : (LocalEquiv.refl \u03b1).source = univ", "start": [604, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_target", "code": "@[simp, mfld_simps]\ntheorem refl_target : (LocalEquiv.refl \u03b1).target = univ", "start": [609, 1], "end": [611, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_coe", "code": "@[simp, mfld_simps]\ntheorem refl_coe : (LocalEquiv.refl \u03b1 : \u03b1 \u2192 \u03b1) = id", "start": [614, 1], "end": [616, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_symm", "code": "@[simp, mfld_simps]\ntheorem refl_symm : (LocalEquiv.refl \u03b1).symm = LocalEquiv.refl \u03b1", "start": [619, 1], "end": [621, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_restr_source", "code": "@[mfld_simps]\ntheorem refl_restr_source (s : Set \u03b1) : ((LocalEquiv.refl \u03b1).restr s).source = s", "start": [625, 1], "end": [626, 92], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_restr_target", "code": "@[mfld_simps]\ntheorem refl_restr_target (s : Set \u03b1) : ((LocalEquiv.refl \u03b1).restr s).target = s", "start": [630, 1], "end": [633, 7], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ofSet", "code": "def ofSet (s : Set \u03b1) : LocalEquiv \u03b1 \u03b1 where\n  toFun := id\n  invFun := id\n  source := s\n  target := s\n  map_source' _ hx := hx\n  map_target' _ hx := hx\n  left_inv' _ _ := rfl\n  right_inv' _ _ := rfl", "start": [636, 1], "end": [645, 24], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ofSet_source", "code": "@[simp, mfld_simps]\ntheorem ofSet_source (s : Set \u03b1) : (LocalEquiv.ofSet s).source = s", "start": [648, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ofSet_target", "code": "@[simp, mfld_simps]\ntheorem ofSet_target (s : Set \u03b1) : (LocalEquiv.ofSet s).target = s", "start": [653, 1], "end": [655, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ofSet_coe", "code": "@[simp, mfld_simps]\ntheorem ofSet_coe (s : Set \u03b1) : (LocalEquiv.ofSet s : \u03b1 \u2192 \u03b1) = id", "start": [658, 1], "end": [660, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.ofSet_symm", "code": "@[simp, mfld_simps]\ntheorem ofSet_symm (s : Set \u03b1) : (LocalEquiv.ofSet s).symm = LocalEquiv.ofSet s", "start": [663, 1], "end": [665, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans'", "code": "@[simps]\nprotected def trans' (e' : LocalEquiv \u03b2 \u03b3) (h : e.target = e'.source) : LocalEquiv \u03b1 \u03b3 where\n  toFun := e' \u2218 e\n  invFun := e.symm \u2218 e'.symm\n  source := e.source\n  target := e'.target\n  map_source' x hx := by simp [\u2190h, hx]\n  map_target' y hy := by simp [h, hy]\n  left_inv' x hx := by simp [hx, \u2190h]\n  right_inv' y hy := by simp [hy, h]", "start": [668, 1], "end": [679, 37], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans", "code": "protected def trans : LocalEquiv \u03b1 \u03b3 :=\n  LocalEquiv.trans' (e.symm.restr e'.source).symm (e'.restr e.target) (inter_comm _ _)", "start": [682, 1], "end": [685, 87], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.coe_trans", "code": "@[simp, mfld_simps]\ntheorem coe_trans : (e.trans e' : \u03b1 \u2192 \u03b3) = e' \u2218 e", "start": [688, 1], "end": [690, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.coe_trans_symm", "code": "@[simp, mfld_simps]\ntheorem coe_trans_symm : ((e.trans e').symm : \u03b3 \u2192 \u03b1) = e.symm \u2218 e'.symm", "start": [693, 1], "end": [695, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_apply", "code": "theorem trans_apply {x : \u03b1} : (e.trans e') x = e' (e x)", "start": [698, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_symm_eq_symm_trans_symm", "code": "theorem trans_symm_eq_symm_trans_symm : (e.trans e').symm = e'.symm.trans e.symm", "start": [702, 1], "end": [703, 25], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_source", "code": "@[simp, mfld_simps]\ntheorem trans_source : (e.trans e').source = e.source \u2229 e \u207b\u00b9' e'.source", "start": [706, 1], "end": [708, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_source'", "code": "theorem trans_source' : (e.trans e').source = e.source \u2229 e \u207b\u00b9' (e.target \u2229 e'.source)", "start": [711, 1], "end": [712, 15], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_source''", "code": "theorem trans_source'' : (e.trans e').source = e.symm '' (e.target \u2229 e'.source)", "start": [715, 1], "end": [716, 53], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.image_trans_source", "code": "theorem image_trans_source : e '' (e.trans e').source = e.target \u2229 e'.source", "start": [719, 1], "end": [720, 55], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_target", "code": "@[simp, mfld_simps]\ntheorem trans_target : (e.trans e').target = e'.target \u2229 e'.symm \u207b\u00b9' e.target", "start": [723, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_target'", "code": "theorem trans_target' : (e.trans e').target = e'.target \u2229 e'.symm \u207b\u00b9' (e'.source \u2229 e.target)", "start": [728, 1], "end": [729, 31], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_target''", "code": "theorem trans_target'' : (e.trans e').target = e' '' (e'.source \u2229 e.target)", "start": [732, 1], "end": [733, 32], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.inv_image_trans_target", "code": "theorem inv_image_trans_target : e'.symm '' (e.trans e').target = e'.source \u2229 e.target", "start": [736, 1], "end": [737, 36], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_assoc", "code": "theorem trans_assoc (e'' : LocalEquiv \u03b3 \u03b4) : (e.trans e').trans e'' = e.trans (e'.trans e'')", "start": [740, 1], "end": [742, 64], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_refl", "code": "@[simp, mfld_simps]\ntheorem trans_refl : e.trans (LocalEquiv.refl \u03b2) = e", "start": [745, 1], "end": [747, 72], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_trans", "code": "@[simp, mfld_simps]\ntheorem refl_trans : (LocalEquiv.refl \u03b1).trans e = e", "start": [750, 1], "end": [752, 85], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_ofSet", "code": "theorem trans_ofSet (s : Set \u03b2) : e.trans (ofSet s) = e.restr (e \u207b\u00b9' s)", "start": [755, 1], "end": [756, 51], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_refl_restr", "code": "theorem trans_refl_restr (s : Set \u03b2) : e.trans ((LocalEquiv.refl \u03b2).restr s) = e.restr (e \u207b\u00b9' s)", "start": [758, 1], "end": [759, 72], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_refl_restr'", "code": "theorem trans_refl_restr' (s : Set \u03b2) :\n    e.trans ((LocalEquiv.refl \u03b2).restr s) = e.restr (e.source \u2229 e \u207b\u00b9' s)", "start": [762, 1], "end": [766, 35], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.restr_trans", "code": "theorem restr_trans (s : Set \u03b1) : (e.restr s).trans e' = (e.trans e').restr s", "start": [769, 1], "end": [771, 49], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.mem_symm_trans_source", "code": "theorem mem_symm_trans_source {e' : LocalEquiv \u03b1 \u03b3} {x : \u03b1} (he : x \u2208 e.source)\n    (he' : x \u2208 e'.source) : e x \u2208 (e.symm.trans e').source", "start": [774, 1], "end": [777, 76], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.transEquiv", "code": "@[simps!]\ndef transEquiv (e' : \u03b2 \u2243 \u03b3) : LocalEquiv \u03b1 \u03b3 :=\n  (e.trans e'.toLocalEquiv).copy _ rfl _ rfl e.source (inter_univ _) (e'.symm \u207b\u00b9' e.target)\n    (univ_inter _)", "start": [780, 1], "end": [785, 19], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.transEquiv_eq_trans", "code": "theorem transEquiv_eq_trans (e' : \u03b2 \u2243 \u03b3) : e.transEquiv e' = e.trans e'.toLocalEquiv", "start": [792, 1], "end": [793, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.transLocalEquiv", "code": "@[simps!]\ndef _root_.Equiv.transLocalEquiv (e : \u03b1 \u2243 \u03b2) : LocalEquiv \u03b1 \u03b3 :=\n  (e.toLocalEquiv.trans e').copy _ rfl _ rfl (e \u207b\u00b9' e'.source) (univ_inter _) e'.target\n    (inter_univ _)", "start": [796, 1], "end": [801, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.transLocalEquiv_eq_trans", "code": "theorem _root_.Equiv.transLocalEquiv_eq_trans (e : \u03b1 \u2243 \u03b2) :\n    e.transLocalEquiv e' = e.toLocalEquiv.trans e'", "start": [808, 1], "end": [810, 13], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource", "code": "def EqOnSource (e e' : LocalEquiv \u03b1 \u03b2) : Prop :=\n  e.source = e'.source \u2227 e.source.EqOn e e'", "start": [813, 1], "end": [816, 44], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.eqOnSourceSetoid", "code": "instance eqOnSourceSetoid : Setoid (LocalEquiv \u03b1 \u03b2) where\n  r := EqOnSource\n  iseqv := by constructor <;> simp only [Equivalence, EqOnSource, EqOn] <;> aesop", "start": [819, 1], "end": [823, 82], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.eqOnSource_refl", "code": "theorem eqOnSource_refl : e \u2248 e", "start": [826, 1], "end": [827, 16], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.source_eq", "code": "theorem EqOnSource.source_eq {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : e.source = e'.source", "start": [830, 1], "end": [832, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.eqOn", "code": "theorem EqOnSource.eqOn {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : e.source.EqOn e e'", "start": [835, 1], "end": [837, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.target_eq", "code": "theorem EqOnSource.target_eq {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : e.target = e'.target", "start": [842, 1], "end": [844, 68], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.symm'", "code": "theorem EqOnSource.symm' {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : e.symm \u2248 e'.symm", "start": [847, 1], "end": [851, 77], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.symm_eqOn", "code": "theorem EqOnSource.symm_eqOn {e e' : LocalEquiv \u03b1 \u03b2} (h : e \u2248 e') : EqOn e.symm e'.symm e.target", "start": [854, 1], "end": [858, 17], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.trans'", "code": "theorem EqOnSource.trans' {e e' : LocalEquiv \u03b1 \u03b2} {f f' : LocalEquiv \u03b2 \u03b3} (he : e \u2248 e')\n    (hf : f \u2248 f') : e.trans f \u2248 e'.trans f'", "start": [861, 1], "end": [869, 82], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.restr", "code": "theorem EqOnSource.restr {e e' : LocalEquiv \u03b1 \u03b2} (he : e \u2248 e') (s : Set \u03b1) :\n    e.restr s \u2248 e'.restr s", "start": [872, 1], "end": [879, 20], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.EqOnSource.source_inter_preimage_eq", "code": "theorem EqOnSource.source_inter_preimage_eq {e e' : LocalEquiv \u03b1 \u03b2} (he : e \u2248 e') (s : Set \u03b2) :\n    e.source \u2229 e \u207b\u00b9' s = e'.source \u2229 e' \u207b\u00b9' s", "start": [882, 1], "end": [884, 97], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_self_symm", "code": "theorem trans_self_symm : e.trans e.symm \u2248 ofSet e.source", "start": [887, 1], "end": [893, 29], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.trans_symm_self", "code": "theorem trans_symm_self : e.symm.trans e \u2248 LocalEquiv.ofSet e.target", "start": [896, 1], "end": [899, 25], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.eq_of_eq_on_source_univ", "code": "theorem eq_of_eq_on_source_univ (e e' : LocalEquiv \u03b1 \u03b2) (h : e \u2248 e') (s : e.source = univ)\n    (t : e.target = univ) : e = e'", "start": [902, 1], "end": [911, 21], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod", "code": "def prod (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) : LocalEquiv (\u03b1 \u00d7 \u03b3) (\u03b2 \u00d7 \u03b4) where\n  source := e.source \u00d7\u02e2 e'.source\n  target := e.target \u00d7\u02e2 e'.target\n  toFun p := (e p.1, e' p.2)\n  invFun p := (e.symm p.1, e'.symm p.2)\n  map_source' p hp := by\n    simp at hp\n    simp [hp]\n  map_target' p hp := by\n    simp at hp\n    simp [map_target, hp]\n  left_inv' p hp := by\n    simp at hp\n    simp [hp]\n  right_inv' p hp := by\n    simp at hp\n    simp [hp]", "start": [916, 1], "end": [933, 14], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_source", "code": "@[simp, mfld_simps]\ntheorem prod_source (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    (e.prod e').source = e.source \u00d7\u02e2 e'.source", "start": [936, 1], "end": [939, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_target", "code": "@[simp, mfld_simps]\ntheorem prod_target (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    (e.prod e').target = e.target \u00d7\u02e2 e'.target", "start": [942, 1], "end": [945, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_coe", "code": "@[simp, mfld_simps]\ntheorem prod_coe (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    (e.prod e' : \u03b1 \u00d7 \u03b3 \u2192 \u03b2 \u00d7 \u03b4) = fun p => (e p.1, e' p.2)", "start": [948, 1], "end": [951, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_coe_symm", "code": "theorem prod_coe_symm (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    ((e.prod e').symm : \u03b2 \u00d7 \u03b4 \u2192 \u03b1 \u00d7 \u03b3) = fun p => (e.symm p.1, e'.symm p.2)", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_symm", "code": "@[simp, mfld_simps]\ntheorem prod_symm (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n    (e.prod e').symm = e.symm.prod e'.symm", "start": [959, 1], "end": [962, 33], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.refl_prod_refl", "code": "@[simp, mfld_simps]\ntheorem refl_prod_refl :\n    (LocalEquiv.refl \u03b1).prod (LocalEquiv.refl \u03b2) = LocalEquiv.refl (\u03b1 \u00d7 \u03b2)", "start": [965, 1], "end": [969, 22], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.prod_trans", "code": "@[simp, mfld_simps]\ntheorem prod_trans {\u03b7 : Type*} {\u03b5 : Type*} (e : LocalEquiv \u03b1 \u03b2) (f : LocalEquiv \u03b2 \u03b3)\n    (e' : LocalEquiv \u03b4 \u03b7) (f' : LocalEquiv \u03b7 \u03b5) :\n    (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')", "start": [972, 1], "end": [976, 39], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.piecewise", "code": "@[simps (config := { fullyApplied := false })]\ndef piecewise (e e' : LocalEquiv \u03b1 \u03b2) (s : Set \u03b1) (t : Set \u03b2) [\u2200 x, Decidable (x \u2208 s)]\n    [\u2200 y, Decidable (y \u2208 t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    LocalEquiv \u03b1 \u03b2 where\n  toFun := s.piecewise e e'\n  invFun := t.piecewise e.symm e'.symm\n  source := s.ite e.source e'.source\n  target := t.ite e.target e'.target\n  map_source' := H.mapsTo.piecewise_ite H'.compl.mapsTo\n  map_target' := H.symm.mapsTo.piecewise_ite H'.symm.compl.mapsTo\n  left_inv' := H.leftInvOn_piecewise H'\n  right_inv' := H.symm.leftInvOn_piecewise H'.symm", "start": [981, 1], "end": [997, 51], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.symm_piecewise", "code": "theorem symm_piecewise (e e' : LocalEquiv \u03b1 \u03b2) {s : Set \u03b1} {t : Set \u03b2} [\u2200 x, Decidable (x \u2208 s)]\n    [\u2200 y, Decidable (y \u2208 t)] (H : e.IsImage s t) (H' : e'.IsImage s t) :\n    (e.piecewise e' s t H H').symm = e.symm.piecewise e'.symm t s H.symm H'.symm", "start": [1004, 1], "end": [1007, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.disjointUnion", "code": "@[simps! (config := { fullyApplied := false })]\ndef disjointUnion (e e' : LocalEquiv \u03b1 \u03b2) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [\u2200 x, Decidable (x \u2208 e.source)]\n    [\u2200 y, Decidable (y \u2208 e.target)] : LocalEquiv \u03b1 \u03b2 :=\n  (e.piecewise e' e.source e.target e.isImage_source_target <|\n        e'.isImage_source_target_of_disjoint _ hs.symm ht.symm).copy\n    _ rfl _ rfl (e.source \u222a e'.source) (ite_left _ _) (e.target \u222a e'.target) (ite_left _ _)", "start": [1010, 1], "end": [1019, 92], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.disjointUnion_eq_piecewise", "code": "theorem disjointUnion_eq_piecewise (e e' : LocalEquiv \u03b1 \u03b2) (hs : Disjoint e.source e'.source)\n    (ht : Disjoint e.target e'.target) [\u2200 x, Decidable (x \u2208 e.source)]\n    [\u2200 y, Decidable (y \u2208 e.target)] :\n    e.disjointUnion e' hs ht =\n      e.piecewise e' e.source e.target e.isImage_source_target\n        (e'.isImage_source_target_of_disjoint _ hs.symm ht.symm)", "start": [1026, 1], "end": [1032, 13], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.pi", "code": "@[simps (config := mfld_cfg) apply source target]\nprotected def pi (ei : \u2200 i, LocalEquiv (\u03b1i i) (\u03b2i i)) : LocalEquiv (\u2200 i, \u03b1i i) (\u2200 i, \u03b2i i) where\n  toFun f i := ei i (f i)\n  invFun f i := (ei i).symm (f i)\n  source := pi univ fun i => (ei i).source\n  target := pi univ fun i => (ei i).target\n  map_source' _ hf i hi := (ei i).map_source (hf i hi)\n  map_target' _ hf i hi := (ei i).map_target (hf i hi)\n  left_inv' _ hf := funext fun i => (ei i).left_inv (hf i trivial)\n  right_inv' _ hf := funext fun i => (ei i).right_inv (hf i trivial)", "start": [1039, 1], "end": [1049, 69], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.pi_symm", "code": "@[simp, mfld_simps]\ntheorem pi_symm (ei : \u2200 i, LocalEquiv (\u03b1i i) (\u03b2i i)) :\n    (LocalEquiv.pi ei).symm = .pi fun i \u21a6 (ei i).symm", "start": [1055, 1], "end": [1058, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.pi_symm_apply", "code": "theorem pi_symm_apply (ei : \u2200 i, LocalEquiv (\u03b1i i) (\u03b2i i)) :\n    \u21d1(LocalEquiv.pi ei).symm = fun f i \u21a6 (ei i).symm (f i)", "start": [1060, 1], "end": [1062, 6], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.pi_refl", "code": "@[simp, mfld_simps]\ntheorem pi_refl : (LocalEquiv.pi fun i \u21a6 LocalEquiv.refl (\u03b1i i)) = .refl (\u2200 i, \u03b1i i)", "start": [1065, 1], "end": [1067, 15], "kind": "commanddeclaration"}, {"full_name": "LocalEquiv.pi_trans", "code": "@[simp, mfld_simps]\ntheorem pi_trans (ei : \u2200 i, LocalEquiv (\u03b1i i) (\u03b2i i)) (ei' : \u2200 i, LocalEquiv (\u03b2i i) (\u03b3i i)) :\n    (LocalEquiv.pi ei).trans (LocalEquiv.pi ei') = .pi fun i \u21a6 (ei i).trans (ei' i)", "start": [1069, 1], "end": [1072, 28], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.toLocalEquiv", "code": "@[simps (config := { fullyApplied := false })]\nnoncomputable def BijOn.toLocalEquiv [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2)\n    (hf : BijOn f s t) : LocalEquiv \u03b1 \u03b2 where\n  toFun := f\n  invFun := invFunOn f s\n  source := s\n  target := t\n  map_source' := hf.mapsTo\n  map_target' := hf.surjOn.mapsTo_invFunOn\n  left_inv' := hf.invOn_invFunOn.1\n  right_inv' := hf.invOn_invFunOn.2", "start": [1081, 1], "end": [1093, 36], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.toLocalEquiv", "code": "@[simp, mfld_simps]\nnoncomputable def InjOn.toLocalEquiv [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (hf : InjOn f s) :\n    LocalEquiv \u03b1 \u03b2 :=\n  hf.bijOn_image.toLocalEquiv f s (f '' s)", "start": [1100, 1], "end": [1104, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem refl_toLocalEquiv : (Equiv.refl \u03b1).toLocalEquiv = LocalEquiv.refl \u03b1", "start": [1115, 1], "end": [1117, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem symm_toLocalEquiv : e.symm.toLocalEquiv = e.toLocalEquiv.symm", "start": [1120, 1], "end": [1122, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem trans_toLocalEquiv : (e.trans e').toLocalEquiv = e.toLocalEquiv.trans e'.toLocalEquiv", "start": [1125, 1], "end": [1128, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Tower.lean", "imports": ["Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/RingTheory/AlgebraTower.lean", "Mathlib/Data/Nat/Prime.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "lift_rank_mul_lift_rank", "code": "theorem lift_rank_mul_lift_rank :\n    Cardinal.lift.{w} (Module.rank F K) * Cardinal.lift.{v} (Module.rank K A) =\n      Cardinal.lift.{v} (Module.rank F A)", "start": [51, 1], "end": [62, 33], "kind": "commanddeclaration"}, {"full_name": "rank_mul_rank", "code": "theorem rank_mul_rank (F : Type u) (K A : Type v) [CommRing F] [Ring K] [AddCommGroup A]\n    [Algebra F K] [Module K A] [Module F A] [IsScalarTower F K A] [StrongRankCondition F]\n    [StrongRankCondition K] [Module.Free F K] [Module.Free K A] :\n    Module.rank F K * Module.rank K A = Module.rank F A", "start": [65, 1], "end": [73, 57], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_mul_finrank'", "code": "theorem FiniteDimensional.finrank_mul_finrank' [Module.Finite F K]\n    [Module.Finite K A] : finrank F K * finrank K A = finrank F A", "start": [76, 1], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.trans", "code": "theorem trans [FiniteDimensional F K] [FiniteDimensional K A] : FiniteDimensional F A", "start": [99, 1], "end": [100, 26], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.left", "code": "theorem left (K L : Type*) [Field K] [Algebra F K] [Ring L] [Nontrivial L] [Algebra F L]\n    [Algebra K L] [IsScalarTower F K L] [FiniteDimensional F L] : FiniteDimensional F K", "start": [103, 1], "end": [111, 98], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.right", "code": "theorem right [hf : FiniteDimensional F A] : FiniteDimensional K A", "start": [114, 1], "end": [118, 34], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_mul_finrank", "code": "theorem finrank_mul_finrank [FiniteDimensional F K] : finrank F K * finrank K A = finrank F A", "start": [121, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.Subalgebra.isSimpleOrder_of_finrank_prime", "code": "theorem Subalgebra.isSimpleOrder_of_finrank_prime (A) [Ring A] [IsDomain A] [Algebra F A]\n    (hp : (finrank F A).Prime) : IsSimpleOrder (Subalgebra F A)", "start": [133, 1], "end": [144, 97], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finite_dimensional''", "code": "instance _root_.LinearMap.finite_dimensional'' (F : Type u) (K : Type v) (V : Type w) [Field F]\n    [Field K] [Algebra F K] [FiniteDimensional F K] [AddCommGroup V] [Module F V]\n    [FiniteDimensional F V] : FiniteDimensional K (V \u2192\u2097[F] K) :=\n  right F _ _", "start": [151, 1], "end": [154, 14], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.finrank_linear_map'", "code": "theorem finrank_linear_map' (F : Type u) (K : Type v) (V : Type w) [Field F] [Field K] [Algebra F K]\n    [FiniteDimensional F K] [AddCommGroup V] [Module F V] [FiniteDimensional F V] :\n    finrank K (V \u2192\u2097[F] K) = finrank F V", "start": [157, 1], "end": [164, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Invertible.lean", "imports": ["Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "invertibleOfRingCharNotDvd", "code": "def invertibleOfRingCharNotDvd {t : \u2115} (not_dvd : \u00acringChar K \u2223 t) : Invertible (t : K) :=\n  invertibleOfNonzero fun h => not_dvd ((ringChar.spec K t).mp h)", "start": [26, 1], "end": [29, 66], "kind": "commanddeclaration"}, {"full_name": "not_ringChar_dvd_of_invertible", "code": "theorem not_ringChar_dvd_of_invertible {t : \u2115} [Invertible (t : K)] : \u00acringChar K \u2223 t", "start": [32, 1], "end": [34, 38], "kind": "commanddeclaration"}, {"full_name": "invertibleOfCharPNotDvd", "code": "def invertibleOfCharPNotDvd {p : \u2115} [CharP K p] {t : \u2115} (not_dvd : \u00acp \u2223 t) : Invertible (t : K) :=\n  invertibleOfNonzero fun h => not_dvd ((CharP.cast_eq_zero_iff K p t).mp h)", "start": [37, 1], "end": [40, 77], "kind": "commanddeclaration"}, {"full_name": "invertibleOfPos", "code": "instance invertibleOfPos [CharZero K] (n : \u2115) [NeZero n] : Invertible (n : K) :=\n  invertibleOfNonzero <| NeZero.out", "start": [45, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "invertibleSucc", "code": "instance invertibleSucc (n : \u2115) : Invertible (n.succ : K) :=\n  invertibleOfNonzero (Nat.cast_ne_zero.mpr (Nat.succ_ne_zero _))", "start": [55, 1], "end": [56, 66], "kind": "commanddeclaration"}, {"full_name": "invertibleTwo", "code": "instance invertibleTwo : Invertible (2 : K) :=\n  invertibleOfNonzero (by exact_mod_cast (by decide : 2 \u2260 0))", "start": [65, 1], "end": [66, 62], "kind": "commanddeclaration"}, {"full_name": "invertibleThree", "code": "instance invertibleThree : Invertible (3 : K) :=\n  invertibleOfNonzero (by exact_mod_cast (by decide : 3 \u2260 0))", "start": [69, 1], "end": [70, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Cardinality.lean", "imports": ["Mathlib/Data/Complex/Basic.lean", "Mathlib/Data/Real/Cardinality.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mk_complex", "code": "@[simp]\ntheorem mk_complex : #\u2102 = \ud835\udd20", "start": [23, 1], "end": [26, 85], "kind": "commanddeclaration"}, {"full_name": "mk_univ_complex", "code": "theorem mk_univ_complex : #(Set.univ : Set \u2102) = \ud835\udd20", "start": [29, 1], "end": [31, 81], "kind": "commanddeclaration"}, {"full_name": "not_countable_complex", "code": "theorem not_countable_complex : \u00ac(Set.univ : Set \u2102).Countable", "start": [34, 1], "end": [37, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Basic.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Analysis/Normed/MulAction.lean", "Mathlib/Algebra/Algebra/RestrictScalars.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/Data/Real/Sqrt.lean"], "premises": [{"full_name": "NormedSpace", "code": "class NormedSpace (\u03b1 : Type*) (\u03b2 : Type*) [NormedField \u03b1] [SeminormedAddCommGroup \u03b2] extends\n  Module \u03b1 \u03b2 where\n  norm_smul_le : \u2200 (a : \u03b1) (b : \u03b2), \u2016a \u2022 b\u2016 \u2264 \u2016a\u2016 * \u2016b\u2016", "start": [36, 1], "end": [45, 56], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.boundedSMul", "code": "instance (priority := 100) NormedSpace.boundedSMul [NormedSpace \u03b1 \u03b2] : BoundedSMul \u03b1 \u03b2 :=\n  BoundedSMul.of_norm_smul_le NormedSpace.norm_smul_le", "start": [55, 1], "end": [56, 55], "kind": "commanddeclaration"}, {"full_name": "NormedField.toNormedSpace", "code": "instance NormedField.toNormedSpace : NormedSpace \u03b1 \u03b1 where norm_smul_le a b := norm_mul_le a b", "start": [59, 1], "end": [59, 95], "kind": "commanddeclaration"}, {"full_name": "NormedField.to_boundedSMul", "code": "instance NormedField.to_boundedSMul : BoundedSMul \u03b1 \u03b1 :=\n  NormedSpace.boundedSMul", "start": [63, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "norm_zsmul", "code": "theorem norm_zsmul (\u03b1) [NormedField \u03b1] [NormedSpace \u03b1 \u03b2] (n : \u2124) (x : \u03b2) :\n    \u2016n \u2022 x\u2016 = \u2016(n : \u03b1)\u2016 * \u2016x\u2016", "start": [67, 1], "end": [68, 98], "kind": "commanddeclaration"}, {"full_name": "abs_norm", "code": "@[simp]\ntheorem abs_norm (z : \u03b2) : |\u2016z\u2016| = \u2016z\u2016", "start": [71, 1], "end": [72, 73], "kind": "commanddeclaration"}, {"full_name": "inv_norm_smul_mem_closed_unit_ball", "code": "theorem inv_norm_smul_mem_closed_unit_ball [NormedSpace \u211d \u03b2] (x : \u03b2) :\n    \u2016x\u2016\u207b\u00b9 \u2022 x \u2208 closedBall (0 : \u03b2) 1", "start": [75, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "norm_smul_of_nonneg", "code": "theorem norm_smul_of_nonneg [NormedSpace \u211d \u03b2] {t : \u211d} (ht : 0 \u2264 t) (x : \u03b2) : \u2016t \u2022 x\u2016 = t * \u2016x\u2016", "start": [81, 1], "end": [82, 53], "kind": "commanddeclaration"}, {"full_name": "eventually_nhds_norm_smul_sub_lt", "code": "theorem eventually_nhds_norm_smul_sub_lt (c : \u03b1) (x : E) {\u03b5 : \u211d} (h : 0 < \u03b5) :\n    \u2200\u1da0 y in \ud835\udcdd x, \u2016c \u2022 (y - x)\u2016 < \u03b5", "start": [89, 1], "end": [93, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.zero_smul_isBoundedUnder_le", "code": "theorem Filter.Tendsto.zero_smul_isBoundedUnder_le {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 E} {l : Filter \u03b9}\n    (hf : Tendsto f l (\ud835\udcdd 0)) (hg : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (Norm.norm \u2218 g)) :\n    Tendsto (fun x => f x \u2022 g x) l (\ud835\udcdd 0)", "start": [96, 1], "end": [99, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.smul_tendsto_zero", "code": "theorem Filter.IsBoundedUnder.smul_tendsto_zero {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 E} {l : Filter \u03b9}\n    (hf : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f)) (hg : Tendsto g l (\ud835\udcdd 0)) :\n    Tendsto (fun x => f x \u2022 g x) l (\ud835\udcdd 0)", "start": [102, 1], "end": [106, 47], "kind": "commanddeclaration"}, {"full_name": "closure_ball", "code": "theorem closure_ball [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    closure (ball x r) = closedBall x r", "start": [109, 1], "end": [122, 37], "kind": "commanddeclaration"}, {"full_name": "frontier_ball", "code": "theorem frontier_ball [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    frontier (ball x r) = sphere x r", "start": [125, 1], "end": [127, 82], "kind": "commanddeclaration"}, {"full_name": "interior_closedBall", "code": "theorem interior_closedBall [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    interior (closedBall x r) = ball x r", "start": [130, 1], "end": [148, 43], "kind": "commanddeclaration"}, {"full_name": "frontier_closedBall", "code": "theorem frontier_closedBall [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    frontier (closedBall x r) = sphere x r", "start": [151, 1], "end": [153, 84], "kind": "commanddeclaration"}, {"full_name": "interior_sphere", "code": "theorem interior_sphere [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    interior (sphere x r) = \u2205", "start": [156, 1], "end": [158, 67], "kind": "commanddeclaration"}, {"full_name": "frontier_sphere", "code": "theorem frontier_sphere [NormedSpace \u211d E] (x : E) {r : \u211d} (hr : r \u2260 0) :\n    frontier (sphere x r) = sphere x r", "start": [161, 1], "end": [163, 69], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.discreteTopology_zmultiples", "code": "instance NormedSpace.discreteTopology_zmultiples\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211a E] (e : E) :\n    DiscreteTopology <| AddSubgroup.zmultiples e := by\n  rcases eq_or_ne e 0 with (rfl | he)\n  \u00b7 rw [AddSubgroup.zmultiples_zero_eq_bot]\n    refine Subsingleton.discreteTopology (\u03b1 := \u2191(\u22a5 : Subspace \u211a E))\n  \u00b7 rw [discreteTopology_iff_open_singleton_zero, isOpen_induced_iff]\n    refine' \u27e8Metric.ball 0 \u2016e\u2016, Metric.isOpen_ball, _\u27e9\n    ext \u27e8x, hx\u27e9\n    obtain \u27e8k, rfl\u27e9 := AddSubgroup.mem_zmultiples_iff.mp hx\n    rw [mem_preimage, mem_ball_zero_iff, AddSubgroup.coe_mk, mem_singleton_iff, Subtype.ext_iff,\n      AddSubgroup.coe_mk, AddSubgroup.coe_zero, norm_zsmul \u211a k e, Int.norm_cast_rat,\n      Int.norm_eq_abs, mul_lt_iff_lt_one_left (norm_pos_iff.mpr he), \u2190\n      @Int.cast_one \u211d _, Int.cast_lt, Int.abs_lt_one_iff, smul_eq_zero, or_iff_left he]", "start": [166, 1], "end": [179, 88], "kind": "commanddeclaration"}, {"full_name": "ULift.normedSpace", "code": "instance ULift.normedSpace : NormedSpace \u03b1 (ULift E) :=\n  { ULift.seminormedAddCommGroup (E := E), ULift.module' with\n    norm_smul_le := fun s x => (norm_smul_le s x.down : _) }", "start": [183, 1], "end": [185, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.normedSpace", "code": "instance Prod.normedSpace : NormedSpace \u03b1 (E \u00d7 F) :=\n  { Prod.seminormedAddCommGroup (E := E) (F := F), Prod.instModule with\n    norm_smul_le := fun s x => by\n      simp only [norm_smul, Prod.norm_def, Prod.smul_snd, Prod.smul_fst,\n        mul_max_of_nonneg, norm_nonneg, le_rfl] }", "start": [187, 1], "end": [192, 50], "kind": "commanddeclaration"}, {"full_name": "Pi.normedSpace", "code": "instance Pi.normedSpace {E : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, SeminormedAddCommGroup (E i)]\n    [\u2200 i, NormedSpace \u03b1 (E i)] : NormedSpace \u03b1 (\u2200 i, E i) where\n  norm_smul_le a f := by\n    simp_rw [\u2190 coe_nnnorm, \u2190 NNReal.coe_mul, NNReal.coe_le_coe, Pi.nnnorm_def,\n      NNReal.mul_finset_sup]\n    exact Finset.sup_mono_fun fun _ _ => norm_smul_le a _", "start": [195, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normedSpace", "code": "instance MulOpposite.normedSpace : NormedSpace \u03b1 E\u1d50\u1d52\u1d56 :=\n  { MulOpposite.seminormedAddCommGroup (E := E\u1d50\u1d52\u1d56), MulOpposite.module _ with\n    norm_smul_le := fun s x => norm_smul_le s x.unop }", "start": [204, 1], "end": [206, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.normedSpace", "code": "instance Submodule.normedSpace {\ud835\udd5c R : Type*} [SMul \ud835\udd5c R] [NormedField \ud835\udd5c] [Ring R] {E : Type*}\n    [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [Module R E] [IsScalarTower \ud835\udd5c R E]\n    (s : Submodule R E) : NormedSpace \ud835\udd5c s where norm_smul_le c x := norm_smul_le c (x : E)", "start": [209, 1], "end": [212, 91], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.induced", "code": "@[reducible]\ndef NormedSpace.induced {F : Type*} (\u03b1 \u03b2 \u03b3 : Type*) [NormedField \u03b1] [AddCommGroup \u03b2] [Module \u03b1 \u03b2]\n    [SeminormedAddCommGroup \u03b3] [NormedSpace \u03b1 \u03b3] [LinearMapClass F \u03b1 \u03b2 \u03b3] (f : F) :\n    @NormedSpace \u03b1 \u03b2 _ (SeminormedAddCommGroup.induced \u03b2 \u03b3 f) := by\n  refine @NormedSpace.mk (\u03b1 := \u03b1) (\u03b2 := \u03b2) _ ?_ ?_ ?_\n  \u00b7 infer_instance\n  \u00b7 intro a b\n    change \u2016(\u21d1f) (a \u2022 b)\u2016 \u2264 \u2016a\u2016 * \u2016(\u21d1f) b\u2016\n    exact (map_smul f a b).symm \u25b8 norm_smul_le a (f b)", "start": [217, 1], "end": [231, 55], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.toModule'", "code": "instance (priority := 100) NormedSpace.toModule' : Module \u03b1 F :=\n  NormedSpace.toModule", "start": [244, 1], "end": [259, 23], "kind": "commanddeclaration"}, {"full_name": "exists_norm_eq", "code": "theorem exists_norm_eq {c : \u211d} (hc : 0 \u2264 c) : \u2203 x : E, \u2016x\u2016 = c", "start": [268, 1], "end": [272, 80], "kind": "commanddeclaration"}, {"full_name": "range_norm", "code": "@[simp]\ntheorem range_norm : range (norm : E \u2192 \u211d) = Ici 0", "start": [275, 1], "end": [277, 77], "kind": "commanddeclaration"}, {"full_name": "nnnorm_surjective", "code": "theorem nnnorm_surjective : Surjective (nnnorm : E \u2192 \u211d\u22650)", "start": [280, 1], "end": [281, 61], "kind": "commanddeclaration"}, {"full_name": "range_nnnorm", "code": "@[simp]\ntheorem range_nnnorm : range (nnnorm : E \u2192 \u211d\u22650) = univ", "start": [284, 1], "end": [286, 33], "kind": "commanddeclaration"}, {"full_name": "Real.punctured_nhds_module_neBot", "code": "instance Real.punctured_nhds_module_neBot {E : Type*} [AddCommGroup E] [TopologicalSpace E]\n    [ContinuousAdd E] [Nontrivial E] [Module \u211d E] [ContinuousSMul \u211d E] (x : E) : NeBot (\ud835\udcdd[\u2260] x) :=\n  Module.punctured_nhds_neBot \u211d E x", "start": [291, 1], "end": [295, 36], "kind": "commanddeclaration"}, {"full_name": "interior_closedBall'", "code": "theorem interior_closedBall' [NormedSpace \u211d E] [Nontrivial E] (x : E) (r : \u211d) :\n    interior (closedBall x r) = ball x r", "start": [298, 1], "end": [302, 35], "kind": "commanddeclaration"}, {"full_name": "frontier_closedBall'", "code": "theorem frontier_closedBall' [NormedSpace \u211d E] [Nontrivial E] (x : E) (r : \u211d) :\n    frontier (closedBall x r) = sphere x r", "start": [305, 1], "end": [307, 84], "kind": "commanddeclaration"}, {"full_name": "interior_sphere'", "code": "@[simp]\ntheorem interior_sphere' [NormedSpace \u211d E] [Nontrivial E] (x : E) (r : \u211d) :\n    interior (sphere x r) = \u2205", "start": [310, 1], "end": [312, 99], "kind": "commanddeclaration"}, {"full_name": "frontier_sphere'", "code": "@[simp]\ntheorem frontier_sphere' [NormedSpace \u211d E] [Nontrivial E] (x : E) (r : \u211d) :\n    frontier (sphere x r) = sphere x r", "start": [315, 1], "end": [318, 67], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.exists_lt_norm", "code": "theorem NormedSpace.exists_lt_norm (c : \u211d) : \u2203 x : E, c < \u2016x\u2016", "start": [328, 1], "end": [335, 21], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.unbounded_univ", "code": "protected theorem NormedSpace.unbounded_univ : \u00acBornology.IsBounded (univ : Set E)", "start": [338, 1], "end": [341, 27], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.noncompactSpace", "code": "protected theorem NormedSpace.noncompactSpace : NoncompactSpace E", "start": [344, 1], "end": [348, 56], "kind": "commanddeclaration"}, {"full_name": "NontriviallyNormedField.noncompactSpace", "code": "instance (priority := 100) NontriviallyNormedField.noncompactSpace : NoncompactSpace \ud835\udd5c :=\n  NormedSpace.noncompactSpace \ud835\udd5c \ud835\udd5c", "start": [351, 1], "end": [352, 34], "kind": "commanddeclaration"}, {"full_name": "RealNormedSpace.noncompactSpace", "code": "instance (priority := 100) RealNormedSpace.noncompactSpace [NormedSpace \u211d E] : NoncompactSpace E :=\n  NormedSpace.noncompactSpace \u211d E", "start": [355, 1], "end": [356, 34], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra", "code": "class NormedAlgebra (\ud835\udd5c : Type*) (\ud835\udd5c' : Type*) [NormedField \ud835\udd5c] [SeminormedRing \ud835\udd5c'] extends\n  Algebra \ud835\udd5c \ud835\udd5c' where\n  norm_smul_le : \u2200 (r : \ud835\udd5c) (x : \ud835\udd5c'), \u2016r \u2022 x\u2016 \u2264 \u2016r\u2016 * \u2016x\u2016", "start": [363, 1], "end": [374, 57], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra.toNormedSpace", "code": "instance (priority := 100) NormedAlgebra.toNormedSpace : NormedSpace \ud835\udd5c \ud835\udd5c' :=\n  { NormedAlgebra.toAlgebra.toModule with\n  norm_smul_le := NormedAlgebra.norm_smul_le }", "start": [381, 1], "end": [384, 47], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra.toNormedSpace'", "code": "instance (priority := 100) NormedAlgebra.toNormedSpace' {\ud835\udd5c'} [NormedRing \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] :\n    NormedSpace \ud835\udd5c \ud835\udd5c' := by infer_instance", "start": [387, 1], "end": [400, 42], "kind": "commanddeclaration"}, {"full_name": "norm_algebraMap", "code": "theorem norm_algebraMap (x : \ud835\udd5c) : \u2016algebraMap \ud835\udd5c \ud835\udd5c' x\u2016 = \u2016x\u2016 * \u2016(1 : \ud835\udd5c')\u2016", "start": [403, 1], "end": [405, 22], "kind": "commanddeclaration"}, {"full_name": "nnnorm_algebraMap", "code": "theorem nnnorm_algebraMap (x : \ud835\udd5c) : \u2016algebraMap \ud835\udd5c \ud835\udd5c' x\u2016\u208a = \u2016x\u2016\u208a * \u2016(1 : \ud835\udd5c')\u2016\u208a", "start": [408, 1], "end": [409, 38], "kind": "commanddeclaration"}, {"full_name": "norm_algebraMap'", "code": "@[simp]\ntheorem norm_algebraMap' [NormOneClass \ud835\udd5c'] (x : \ud835\udd5c) : \u2016algebraMap \ud835\udd5c \ud835\udd5c' x\u2016 = \u2016x\u2016", "start": [412, 1], "end": [414, 42], "kind": "commanddeclaration"}, {"full_name": "nnnorm_algebraMap'", "code": "@[simp]\ntheorem nnnorm_algebraMap' [NormOneClass \ud835\udd5c'] (x : \ud835\udd5c) : \u2016algebraMap \ud835\udd5c \ud835\udd5c' x\u2016\u208a = \u2016x\u2016\u208a", "start": [417, 1], "end": [419, 38], "kind": "commanddeclaration"}, {"full_name": "norm_algebraMap_nNReal", "code": "@[simp]\ntheorem norm_algebraMap_nNReal (x : \u211d\u22650) : \u2016algebraMap \u211d\u22650 \ud835\udd5c' x\u2016 = x", "start": [426, 1], "end": [428, 66], "kind": "commanddeclaration"}, {"full_name": "nnnorm_algebraMap_nNReal", "code": "@[simp]\ntheorem nnnorm_algebraMap_nNReal (x : \u211d\u22650) : \u2016algebraMap \u211d\u22650 \ud835\udd5c' x\u2016\u208a = x", "start": [431, 1], "end": [433, 45], "kind": "commanddeclaration"}, {"full_name": "algebraMap_isometry", "code": "theorem algebraMap_isometry [NormOneClass \ud835\udd5c'] : Isometry (algebraMap \ud835\udd5c \ud835\udd5c')", "start": [440, 1], "end": [443, 71], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra.id", "code": "instance NormedAlgebra.id : NormedAlgebra \ud835\udd5c \ud835\udd5c :=\n  { NormedField.toNormedSpace, Algebra.id \ud835\udd5c with }", "start": [446, 1], "end": [447, 51], "kind": "commanddeclaration"}, {"full_name": "normedAlgebraRat", "code": "instance normedAlgebraRat {\ud835\udd5c} [NormedDivisionRing \ud835\udd5c] [CharZero \ud835\udd5c] [NormedAlgebra \u211d \ud835\udd5c] :\n    NormedAlgebra \u211a \ud835\udd5c where\n  norm_smul_le q x := by\n    rw [\u2190 smul_one_smul \u211d q x, Rat.smul_one_eq_coe, norm_smul, Rat.norm_cast_real]", "start": [451, 1], "end": [459, 83], "kind": "commanddeclaration"}, {"full_name": "PUnit.normedAlgebra", "code": "instance PUnit.normedAlgebra : NormedAlgebra \ud835\udd5c PUnit where\n  norm_smul_le q _ := by simp only [norm_eq_zero, mul_zero, le_refl]", "start": [462, 1], "end": [463, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.normedAlgebra", "code": "instance Prod.normedAlgebra {E F : Type*} [SeminormedRing E] [SeminormedRing F] [NormedAlgebra \ud835\udd5c E]\n    [NormedAlgebra \ud835\udd5c F] : NormedAlgebra \ud835\udd5c (E \u00d7 F) :=\n  { Prod.normedSpace, Prod.algebra \ud835\udd5c E F with }", "start": [469, 1], "end": [472, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.normedAlgebra", "code": "instance Pi.normedAlgebra {E : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, SeminormedRing (E i)]\n    [\u2200 i, NormedAlgebra \ud835\udd5c (E i)] : NormedAlgebra \ud835\udd5c (\u2200 i, E i) :=\n  { Pi.normedSpace, Pi.algebra _ E with }", "start": [476, 1], "end": [479, 42], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.normedAlgebra", "code": "instance MulOpposite.normedAlgebra {E : Type*} [SeminormedRing E] [NormedAlgebra \ud835\udd5c E] :\n    NormedAlgebra \ud835\udd5c E\u1d50\u1d52\u1d56 :=\n  { MulOpposite.normedSpace, MulOpposite.instAlgebra with }", "start": [484, 1], "end": [486, 60], "kind": "commanddeclaration"}, {"full_name": "NormedAlgebra.induced", "code": "@[reducible]\ndef NormedAlgebra.induced {F : Type*} (\u03b1 \u03b2 \u03b3 : Type*) [NormedField \u03b1] [Ring \u03b2] [Algebra \u03b1 \u03b2]\n    [SeminormedRing \u03b3] [NormedAlgebra \u03b1 \u03b3] [NonUnitalAlgHomClass F \u03b1 \u03b2 \u03b3] (f : F) :\n    @NormedAlgebra \u03b1 \u03b2 _ (SeminormedRing.induced \u03b2 \u03b3 f) := by\n  refine @NormedAlgebra.mk (\ud835\udd5c := \u03b1) (\ud835\udd5c' := \u03b2) _ ?_ ?_ ?_\n  \u00b7 infer_instance\n  \u00b7 intro a b\n    change \u2016(\u21d1f) (a \u2022 b)\u2016 \u2264 \u2016a\u2016 * \u2016(\u21d1f) b\u2016\n    exact (map_smul f a b).symm \u25b8 norm_smul_le a (f b)", "start": [492, 1], "end": [505, 55], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toNormedAlgebra", "code": "instance Subalgebra.toNormedAlgebra {\ud835\udd5c A : Type*} [SeminormedRing A] [NormedField \ud835\udd5c]\n    [NormedAlgebra \ud835\udd5c A] (S : Subalgebra \ud835\udd5c A) : NormedAlgebra \ud835\udd5c S :=\n  @NormedAlgebra.induced _ \ud835\udd5c S A _ (SubringClass.toRing S) _ _ _ _ S.val", "start": [509, 1], "end": [511, 73], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.normedSpace", "code": "instance RestrictScalars.normedSpace : NormedSpace \ud835\udd5c (RestrictScalars \ud835\udd5c \ud835\udd5c' E) :=\n  { RestrictScalars.module \ud835\udd5c \ud835\udd5c' E with\n    norm_smul_le := fun c x =>\n      (norm_smul_le (algebraMap \ud835\udd5c \ud835\udd5c' c) (_ : E)).trans_eq <| by rw [norm_algebraMap'] }", "start": [527, 1], "end": [532, 88], "kind": "commanddeclaration"}, {"full_name": "Module.RestrictScalars.normedSpaceOrig", "code": "def Module.RestrictScalars.normedSpaceOrig {\ud835\udd5c : Type*} {\ud835\udd5c' : Type*} {E : Type*} [NormedField \ud835\udd5c']\n    [SeminormedAddCommGroup E] [I : NormedSpace \ud835\udd5c' E] : NormedSpace \ud835\udd5c' (RestrictScalars \ud835\udd5c \ud835\udd5c' E) :=\n  I", "start": [536, 1], "end": [541, 4], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.restrictScalars", "code": "def NormedSpace.restrictScalars : NormedSpace \ud835\udd5c E :=\n  RestrictScalars.normedSpace _ \ud835\udd5c' _", "start": [544, 1], "end": [552, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/LinearIsometry.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/LinearAlgebra/Basis.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearIsometry", "code": "structure LinearIsometry (\u03c3\u2081\u2082 : R \u2192+* R\u2082) (E E\u2082 : Type*) [SeminormedAddCommGroup E]\n  [SeminormedAddCommGroup E\u2082] [Module R E] [Module R\u2082 E\u2082] extends E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082 where\n  norm_map' : \u2200 x, \u2016toLinearMap x\u2016 = \u2016x\u2016", "start": [44, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass", "code": "class SemilinearIsometryClass (\ud835\udcd5 : Type*) {R R\u2082 : outParam (Type*)} [Semiring R] [Semiring R\u2082]\n  (\u03c3\u2081\u2082 : outParam <| R \u2192+* R\u2082) (E E\u2082 : outParam (Type*)) [SeminormedAddCommGroup E]\n  [SeminormedAddCommGroup E\u2082] [Module R E] [Module R\u2082 E\u2082] extends\n  SemilinearMapClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082 where\n  norm_map : \u2200 (f : \ud835\udcd5) (x : E), \u2016f x\u2016 = \u2016x\u2016", "start": [56, 1], "end": [68, 44], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryClass", "code": "abbrev LinearIsometryClass (\ud835\udcd5 : Type*) (R E E\u2082 : outParam (Type*)) [Semiring R]\n    [SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2082] [Module R E] [Module R E\u2082] :=\n  SemilinearIsometryClass \ud835\udcd5 (RingHom.id R) E E\u2082", "start": [71, 1], "end": [78, 48], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.isometry", "code": "protected theorem isometry [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) : Isometry f", "start": [83, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.continuous", "code": "@[continuity]\nprotected theorem continuous [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) : Continuous f", "start": [87, 1], "end": [89, 50], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.nnnorm_map", "code": "@[simp]\ntheorem nnnorm_map [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) (x : E) : \u2016f x\u2016\u208a = \u2016x\u2016\u208a", "start": [92, 1], "end": [94, 28], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.lipschitz", "code": "protected theorem lipschitz [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) : LipschitzWith 1 f", "start": [97, 1], "end": [98, 49], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.antilipschitz", "code": "protected theorem antilipschitz [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) :\n    AntilipschitzWith 1 f", "start": [101, 1], "end": [103, 53], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.ediam_image", "code": "theorem ediam_image [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) (s : Set E) :\n    EMetric.diam (f '' s) = EMetric.diam s", "start": [106, 1], "end": [108, 53], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.ediam_range", "code": "theorem ediam_range [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) :\n    EMetric.diam (range f) = EMetric.diam (univ : Set E)", "start": [111, 1], "end": [113, 51], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.diam_image", "code": "theorem diam_image [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) (s : Set E) :\n    Metric.diam (f '' s) = Metric.diam s", "start": [116, 1], "end": [118, 52], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryClass.diam_range", "code": "theorem diam_range [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) :\n    Metric.diam (range f) = Metric.diam (univ : Set E)", "start": [121, 1], "end": [123, 50], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toLinearMap_injective", "code": "theorem toLinearMap_injective : Injective (toLinearMap : (E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) \u2192 E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082)", "start": [136, 1], "end": [137, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toLinearMap_inj", "code": "@[simp]\ntheorem toLinearMap_inj {f g : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} : f.toLinearMap = g.toLinearMap \u2194 f = g", "start": [140, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_toLinearMap", "code": "@[simp]\ntheorem coe_toLinearMap : \u21d1f.toLinearMap = f", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (hf) : \u21d1(mk f hf) = f", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_injective", "code": "theorem coe_injective : @Injective (E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (E \u2192 E\u2082) (fun f => f)", "start": [169, 1], "end": [171, 7], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.Simps.apply", "code": "def Simps.apply (\u03c3\u2081\u2082 : R \u2192+* R\u2082) (E E\u2082 : Type*) [SeminormedAddCommGroup E]\n    [SeminormedAddCommGroup E\u2082] [Module R E] [Module R\u2082 E\u2082] (h : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E \u2192 E\u2082 :=\n  h", "start": [175, 1], "end": [179, 4], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.ext", "code": "@[ext]\ntheorem ext {f g : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} (h : \u2200 x, f x = g x) : f = g", "start": [184, 1], "end": [186, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.congr_arg", "code": "protected theorem congr_arg [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] {f : \ud835\udcd5} :\n    \u2200 {x x' : E}, x = x' \u2192 f x = f x'", "start": [189, 1], "end": [191, 21], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.congr_fun", "code": "protected theorem congr_fun [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] {f g : \ud835\udcd5} (h : f = g) (x : E) :\n    f x = g x", "start": [194, 1], "end": [196, 10], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_zero", "code": "protected theorem map_zero : f 0 = 0", "start": [200, 1], "end": [201, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_add", "code": "protected theorem map_add (x y : E) : f (x + y) = f x + f y", "start": [205, 1], "end": [206, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_neg", "code": "protected theorem map_neg (x : E) : f (-x) = -f x", "start": [210, 1], "end": [211, 26], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_sub", "code": "protected theorem map_sub (x y : E) : f (x - y) = f x - f y", "start": [215, 1], "end": [216, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_smul\u209b\u2097", "code": "protected theorem map_smul\u209b\u2097 (c : R) (x : E) : f (c \u2022 x) = \u03c3\u2081\u2082 c \u2022 f x", "start": [220, 1], "end": [221, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_smul", "code": "protected theorem map_smul [Module R E\u2082] (f : E \u2192\u2097\u1d62[R] E\u2082) (c : R) (x : E) : f (c \u2022 x) = c \u2022 f x", "start": [225, 1], "end": [226, 29], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.norm_map", "code": "@[simp]\ntheorem norm_map (x : E) : \u2016f x\u2016 = \u2016x\u2016", "start": [229, 1], "end": [231, 39], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.nnnorm_map", "code": "theorem nnnorm_map (x : E) : \u2016f x\u2016\u208a = \u2016x\u2016\u208a", "start": [235, 1], "end": [236, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.isometry", "code": "protected theorem isometry : Isometry f", "start": [239, 1], "end": [240, 64], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.isComplete_image_iff", "code": "@[simp]\ntheorem isComplete_image_iff [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) {s : Set E} :\n    IsComplete (f '' s) \u2194 IsComplete s", "start": [243, 1], "end": [246, 83], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.isComplete_map_iff", "code": "theorem isComplete_map_iff [RingHomSurjective \u03c3\u2081\u2082] {p : Submodule R E} :\n    IsComplete (p.map f.toLinearMap : Set E\u2082) \u2194 IsComplete (p : Set E)", "start": [249, 1], "end": [251, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.isComplete_map_iff'", "code": "theorem isComplete_map_iff' [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) [RingHomSurjective \u03c3\u2081\u2082]\n    {p : Submodule R E} : IsComplete (p.map f : Set E\u2082) \u2194 IsComplete (p : Set E)", "start": [254, 1], "end": [256, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.completeSpace_map", "code": "instance completeSpace_map [SemilinearIsometryClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082] (f : \ud835\udcd5) [RingHomSurjective \u03c3\u2081\u2082]\n    (p : Submodule R E) [CompleteSpace p] : CompleteSpace (p.map f) :=\n  ((isComplete_map_iff' f).2 <| completeSpace_coe_iff_isComplete.1 \u2039_\u203a).completeSpace_coe", "start": [259, 1], "end": [261, 90], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.completeSpace_map'", "code": "instance completeSpace_map' [RingHomSurjective \u03c3\u2081\u2082] (p : Submodule R E) [CompleteSpace p] :\n    CompleteSpace (p.map f.toLinearMap) :=\n  (f.isComplete_map_iff.2 <| completeSpace_coe_iff_isComplete.1 \u2039_\u203a).completeSpace_coe", "start": [264, 1], "end": [266, 87], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.dist_map", "code": "@[simp]\ntheorem dist_map (x y : E) : dist (f x) (f y) = dist x y", "start": [269, 1], "end": [271, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.edist_map", "code": "@[simp]\ntheorem edist_map (x y : E) : edist (f x) (f y) = edist x y", "start": [274, 1], "end": [276, 26], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.injective", "code": "protected theorem injective : Injective f\u2081", "start": [279, 1], "end": [280, 50], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_eq_iff", "code": "@[simp]\ntheorem map_eq_iff {x y : F} : f\u2081 x = f\u2081 y \u2194 x = y", "start": [283, 1], "end": [285, 22], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.map_ne", "code": "theorem map_ne {x y : F} (h : x \u2260 y) : f\u2081 x \u2260 f\u2081 y", "start": [288, 1], "end": [289, 20], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.lipschitz", "code": "protected theorem lipschitz : LipschitzWith 1 f", "start": [292, 1], "end": [293, 23], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.antilipschitz", "code": "protected theorem antilipschitz : AntilipschitzWith 1 f", "start": [296, 1], "end": [297, 27], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.continuous", "code": "@[continuity]\nprotected theorem continuous : Continuous f", "start": [300, 1], "end": [302, 24], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.preimage_ball", "code": "@[simp]\ntheorem preimage_ball (x : E) (r : \u211d) : f \u207b\u00b9' Metric.ball (f x) r = Metric.ball x r", "start": [305, 1], "end": [307, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.preimage_sphere", "code": "@[simp]\ntheorem preimage_sphere (x : E) (r : \u211d) : f \u207b\u00b9' Metric.sphere (f x) r = Metric.sphere x r", "start": [310, 1], "end": [312, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.preimage_closedBall", "code": "@[simp]\ntheorem preimage_closedBall (x : E) (r : \u211d) :\n    f \u207b\u00b9' Metric.closedBall (f x) r = Metric.closedBall x r", "start": [315, 1], "end": [318, 37], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.ediam_image", "code": "theorem ediam_image (s : Set E) : EMetric.diam (f '' s) = EMetric.diam s", "start": [321, 1], "end": [322, 27], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.ediam_range", "code": "theorem ediam_range : EMetric.diam (range f) = EMetric.diam (univ : Set E)", "start": [325, 1], "end": [326, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.diam_image", "code": "theorem diam_image (s : Set E) : Metric.diam (f '' s) = Metric.diam s", "start": [329, 1], "end": [330, 52], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.diam_range", "code": "theorem diam_range : Metric.diam (range f) = Metric.diam (univ : Set E)", "start": [333, 1], "end": [334, 50], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toContinuousLinearMap", "code": "def toContinuousLinearMap : E \u2192SL[\u03c3\u2081\u2082] E\u2082 :=\n  \u27e8f.toLinearMap, f.continuous\u27e9", "start": [337, 1], "end": [339, 32], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toContinuousLinearMap_injective", "code": "theorem toContinuousLinearMap_injective :\n    Function.Injective (toContinuousLinearMap : _ \u2192 E \u2192SL[\u03c3\u2081\u2082] E\u2082)", "start": [342, 1], "end": [344, 63], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.toContinuousLinearMap_inj", "code": "@[simp]\ntheorem toContinuousLinearMap_inj {f g : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} :\n    f.toContinuousLinearMap = g.toContinuousLinearMap \u2194 f = g", "start": [347, 1], "end": [350, 41], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_toContinuousLinearMap", "code": "@[simp]\ntheorem coe_toContinuousLinearMap : \u21d1f.toContinuousLinearMap = f", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] {g : \u03b1 \u2192 E} :\n    Continuous (f \u2218 g) \u2194 Continuous g", "start": [358, 1], "end": [361, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.id", "code": "def id : E \u2192\u2097\u1d62[R] E :=\n  \u27e8LinearMap.id, fun _ => rfl\u27e9", "start": [364, 1], "end": [366, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_id", "code": "@[simp]\ntheorem coe_id : ((id : E \u2192\u2097\u1d62[R] E) : E \u2192 E) = _root_.id", "start": [369, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.id_apply", "code": "@[simp]\ntheorem id_apply (x : E) : (id : E \u2192\u2097\u1d62[R] E) x = x", "start": [374, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.id_toLinearMap", "code": "@[simp]\ntheorem id_toLinearMap : (id.toLinearMap : E \u2192\u2097[R] E) = LinearMap.id", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.id_toContinuousLinearMap", "code": "@[simp]\ntheorem id_toContinuousLinearMap : id.toContinuousLinearMap = ContinuousLinearMap.id R E", "start": [384, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.comp", "code": "def comp (g : E\u2082 \u2192\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2083] E\u2083 :=\n  \u27e8g.toLinearMap.comp f.toLinearMap, fun _ => (norm_map g _).trans (norm_map f _)\u27e9", "start": [392, 1], "end": [394, 83], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : E\u2082 \u2192\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : \u21d1(g.comp f) = g \u2218 f", "start": [397, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.id_comp", "code": "@[simp]\ntheorem id_comp : (id : E\u2082 \u2192\u2097\u1d62[R\u2082] E\u2082).comp f = f", "start": [402, 1], "end": [404, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.comp_id", "code": "@[simp]\ntheorem comp_id : f.comp id = f", "start": [407, 1], "end": [409, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.comp_assoc", "code": "theorem comp_assoc (f : E\u2083 \u2192\u209b\u2097\u1d62[\u03c3\u2083\u2084] E\u2084) (g : E\u2082 \u2192\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (h : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [412, 1], "end": [414, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : E \u2192\u2097\u1d62[R] E) : E \u2192 E) = _root_.id", "start": [424, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : E \u2192\u2097\u1d62[R] E) : \u21d1(f * g) = f \u2218 g", "start": [429, 1], "end": [431, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.one_def", "code": "theorem one_def : (1 : E \u2192\u2097\u1d62[R] E) = id", "start": [434, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.mul_def", "code": "theorem mul_def (f g : E \u2192\u2097\u1d62[R] E) : (f * g : E \u2192\u2097\u1d62[R] E) = f.comp g", "start": [438, 1], "end": [439, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.coe_pow", "code": "theorem coe_pow (f : E \u2192\u2097\u1d62[R] E) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [442, 1], "end": [443, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toLinearIsometry", "code": "def LinearMap.toLinearIsometry (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (hf : Isometry f) : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082 :=\n  { f with\n    norm_map' := by\n      simp_rw [\u2190 dist_zero_right]\n      simpa using (hf.dist_eq \u00b7 0) }", "start": [447, 1], "end": [452, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype\u2097\u1d62", "code": "def subtype\u2097\u1d62 : p \u2192\u2097\u1d62[R'] E :=\n  \u27e8p.subtype, fun _ => rfl\u27e9", "start": [459, 1], "end": [461, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_subtype\u2097\u1d62", "code": "@[simp]\ntheorem coe_subtype\u2097\u1d62 : \u21d1p.subtype\u2097\u1d62 = p.subtype", "start": [464, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype\u2097\u1d62_toLinearMap", "code": "@[simp]\ntheorem subtype\u2097\u1d62_toLinearMap : p.subtype\u2097\u1d62.toLinearMap = p.subtype", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype\u2097\u1d62_toContinuousLinearMap", "code": "@[simp]\ntheorem subtype\u2097\u1d62_toContinuousLinearMap : p.subtype\u2097\u1d62.toContinuousLinearMap = p.subtypeL", "start": [474, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv", "code": "structure LinearIsometryEquiv (\u03c3\u2081\u2082 : R \u2192+* R\u2082) {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n  [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] (E E\u2082 : Type*) [SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2082]\n  [Module R E] [Module R\u2082 E\u2082] extends E \u2243\u209b\u2097[\u03c3\u2081\u2082] E\u2082 where\n  norm_map' : \u2200 x, \u2016toLinearEquiv x\u2016 = \u2016x\u2016", "start": [481, 1], "end": [485, 43], "kind": "commanddeclaration"}, {"full_name": "SemilinearIsometryEquivClass", "code": "class SemilinearIsometryEquivClass (\ud835\udcd5 : Type*) {R R\u2082 : outParam (Type*)} [Semiring R]\n  [Semiring R\u2082] (\u03c3\u2081\u2082 : outParam <| R \u2192+* R\u2082) {\u03c3\u2082\u2081 : outParam <| R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n  [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] (E E\u2082 : outParam (Type*)) [SeminormedAddCommGroup E]\n  [SeminormedAddCommGroup E\u2082] [Module R E] [Module R\u2082 E\u2082] extends\n  SemilinearEquivClass \ud835\udcd5 \u03c3\u2081\u2082 E E\u2082 where\n  norm_map : \u2200 (f : \ud835\udcd5) (x : E), \u2016f x\u2016 = \u2016x\u2016", "start": [494, 1], "end": [507, 44], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquivClass", "code": "abbrev LinearIsometryEquivClass (\ud835\udcd5 : Type*) (R E E\u2082 : outParam (Type*)) [Semiring R]\n    [SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2082] [Module R E] [Module R E\u2082] :=\n  SemilinearIsometryEquivClass \ud835\udcd5 (RingHom.id R) E E\u2082", "start": [510, 1], "end": [517, 53], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearEquiv_injective", "code": "theorem toLinearEquiv_injective : Injective (toLinearEquiv : (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) \u2192 E \u2243\u209b\u2097[\u03c3\u2081\u2082] E\u2082)", "start": [537, 1], "end": [538, 31], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearEquiv_inj", "code": "@[simp]\ntheorem toLinearEquiv_inj {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} : f.toLinearEquiv = g.toLinearEquiv \u2194 f = g", "start": [541, 1], "end": [543, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_injective", "code": "theorem coe_injective : @Function.Injective (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (E \u2192 E\u2082) (\u2191)", "start": [568, 1], "end": [569, 24], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (e : E \u2243\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (he : \u2200 x, \u2016e x\u2016 = \u2016x\u2016) : \u21d1(mk e he) = e", "start": [572, 1], "end": [574, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toLinearEquiv", "code": "@[simp]\ntheorem coe_toLinearEquiv (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : \u21d1e.toLinearEquiv = e", "start": [577, 1], "end": [579, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ext", "code": "@[ext]\ntheorem ext {e e' : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} (h : \u2200 x, e x = e' x) : e = e'", "start": [582, 1], "end": [584, 47], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.congr_arg", "code": "protected theorem congr_arg {f : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} : \u2200 {x x' : E}, x = x' \u2192 f x = f x'", "start": [587, 1], "end": [588, 21], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.congr_fun", "code": "protected theorem congr_fun {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} (h : f = g) (x : E) : f x = g x", "start": [591, 1], "end": [592, 10], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofBounds", "code": "def ofBounds (e : E \u2243\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (h\u2081 : \u2200 x, \u2016e x\u2016 \u2264 \u2016x\u2016) (h\u2082 : \u2200 y, \u2016e.symm y\u2016 \u2264 \u2016y\u2016) :\n    E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082 :=\n  \u27e8e, fun x => le_antisymm (h\u2081 x) <| by simpa only [e.symm_apply_apply] using h\u2082 (e x)\u27e9", "start": [595, 1], "end": [599, 88], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.norm_map", "code": "@[simp]\ntheorem norm_map (x : E) : \u2016e x\u2016 = \u2016x\u2016", "start": [602, 1], "end": [604, 16], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearIsometry", "code": "def toLinearIsometry : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082 :=\n  \u27e8e.1, e.2\u27e9", "start": [607, 1], "end": [609, 13], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearIsometry_injective", "code": "theorem toLinearIsometry_injective : Function.Injective (toLinearIsometry : _ \u2192 E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082)", "start": [612, 1], "end": [613, 71], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearIsometry_inj", "code": "@[simp]\ntheorem toLinearIsometry_inj {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} :\n    f.toLinearIsometry = g.toLinearIsometry \u2194 f = g", "start": [616, 1], "end": [619, 36], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toLinearIsometry", "code": "@[simp]\ntheorem coe_toLinearIsometry : \u21d1e.toLinearIsometry = e", "start": [622, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.isometry", "code": "protected theorem isometry : Isometry e", "start": [627, 1], "end": [628, 30], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toIsometryEquiv", "code": "def toIsometryEquiv : E \u2243\u1d62 E\u2082 :=\n  \u27e8e.toLinearEquiv.toEquiv, e.isometry\u27e9", "start": [631, 1], "end": [633, 40], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toIsometryEquiv_injective", "code": "theorem toIsometryEquiv_injective :\n    Function.Injective (toIsometryEquiv : (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) \u2192 E \u2243\u1d62 E\u2082)", "start": [636, 1], "end": [638, 57], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toIsometryEquiv_inj", "code": "@[simp]\ntheorem toIsometryEquiv_inj {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} :\n    f.toIsometryEquiv = g.toIsometryEquiv \u2194 f = g", "start": [641, 1], "end": [644, 35], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toIsometryEquiv", "code": "@[simp]\ntheorem coe_toIsometryEquiv : \u21d1e.toIsometryEquiv = e", "start": [647, 1], "end": [649, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.range_eq_univ", "code": "theorem range_eq_univ (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : Set.range e = Set.univ", "start": [652, 1], "end": [654, 38], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toHomeomorph", "code": "def toHomeomorph : E \u2243\u209c E\u2082 :=\n  e.toIsometryEquiv.toHomeomorph", "start": [657, 1], "end": [659, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toHomeomorph_injective", "code": "theorem toHomeomorph_injective : Function.Injective (toHomeomorph : (E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) \u2192 E \u2243\u209c E\u2082)", "start": [662, 1], "end": [663, 67], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toHomeomorph_inj", "code": "@[simp]\ntheorem toHomeomorph_inj {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} : f.toHomeomorph = g.toHomeomorph \u2194 f = g", "start": [666, 1], "end": [668, 32], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toHomeomorph", "code": "@[simp]\ntheorem coe_toHomeomorph : \u21d1e.toHomeomorph = e", "start": [671, 1], "end": [673, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.continuous", "code": "protected theorem continuous : Continuous e", "start": [676, 1], "end": [677, 24], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.continuousAt", "code": "protected theorem continuousAt {x} : ContinuousAt e x", "start": [680, 1], "end": [681, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.continuousOn", "code": "protected theorem continuousOn {s} : ContinuousOn e s", "start": [684, 1], "end": [685, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.continuousWithinAt", "code": "protected theorem continuousWithinAt {s x} : ContinuousWithinAt e s x", "start": [688, 1], "end": [689, 34], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toContinuousLinearEquiv", "code": "def toContinuousLinearEquiv : E \u2243SL[\u03c3\u2081\u2082] E\u2082 :=\n  { e.toLinearIsometry.toContinuousLinearMap, e.toHomeomorph with }", "start": [692, 1], "end": [694, 68], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toContinuousLinearEquiv_injective", "code": "theorem toContinuousLinearEquiv_injective :\n    Function.Injective (toContinuousLinearEquiv : _ \u2192 E \u2243SL[\u03c3\u2081\u2082] E\u2082)", "start": [697, 1], "end": [699, 65], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toContinuousLinearEquiv_inj", "code": "@[simp]\ntheorem toContinuousLinearEquiv_inj {f g : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082} :\n    f.toContinuousLinearEquiv = g.toContinuousLinearEquiv \u2194 f = g", "start": [702, 1], "end": [705, 43], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_toContinuousLinearEquiv", "code": "@[simp]\ntheorem coe_toContinuousLinearEquiv : \u21d1e.toContinuousLinearEquiv = e", "start": [708, 1], "end": [710, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.refl", "code": "def refl : E \u2243\u2097\u1d62[R] E :=\n  \u27e8LinearEquiv.refl R E, fun _ => rfl\u27e9", "start": [715, 1], "end": [717, 39], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ulift", "code": "def ulift : ULift E \u2243\u2097\u1d62[R] E :=\n  { ContinuousLinearEquiv.ulift with norm_map' := fun _ => rfl }", "start": [720, 1], "end": [722, 65], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(refl R E) = id", "start": [730, 1], "end": [732, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm", "code": "def symm : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2081] E :=\n  \u27e8e.toLinearEquiv.symm, fun x =>\n    (e.norm_map _).symm.trans <| congr_arg norm <| e.toLinearEquiv.apply_symm_apply x\u27e9", "start": [735, 1], "end": [738, 87], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (x : E\u2082) : e (e.symm x) = x", "start": [741, 1], "end": [743, 37], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (x : E) : e.symm (e x) = x", "start": [746, 1], "end": [748, 37], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_eq_zero_iff", "code": "theorem map_eq_zero_iff {x : E} : e x = 0 \u2194 x = 0", "start": [752, 1], "end": [753, 34], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm : e.symm.symm = e", "start": [756, 1], "end": [758, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearEquiv_symm", "code": "@[simp]\ntheorem toLinearEquiv_symm : e.toLinearEquiv.symm = e.symm.toLinearEquiv", "start": [761, 1], "end": [763, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toIsometryEquiv_symm", "code": "@[simp]\ntheorem toIsometryEquiv_symm : e.toIsometryEquiv.symm = e.symm.toIsometryEquiv", "start": [766, 1], "end": [768, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toHomeomorph_symm", "code": "@[simp]\ntheorem toHomeomorph_symm : e.toHomeomorph.symm = e.symm.toHomeomorph", "start": [771, 1], "end": [773, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.Simps.apply", "code": "def Simps.apply (\u03c3\u2081\u2082 : R \u2192+* R\u2082) {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n    (E E\u2082 : Type*) [SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2082] [Module R E]\n    [Module R\u2082 E\u2082] (h : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E \u2192 E\u2082 :=\n  h", "start": [776, 1], "end": [781, 4], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (\u03c3\u2081\u2082 : R \u2192+* R\u2082) {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081]\n    [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] (E E\u2082 : Type*) [SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2082]\n    [Module R E] [Module R\u2082 E\u2082] (h : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) : E\u2082 \u2192 E :=\n  h.symm", "start": [784, 1], "end": [788, 9], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.trans", "code": "def trans (e' : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2083] E\u2083 :=\n  \u27e8e.toLinearEquiv.trans e'.toLinearEquiv, fun _ => (e'.norm_map _).trans (e.norm_map _)\u27e9", "start": [794, 1], "end": [796, 90], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e\u2081 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (e\u2082 : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081", "start": [799, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (e\u2082 : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (c : E) :\n    (e\u2081.trans e\u2082 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2083] E\u2083) c = e\u2082 (e\u2081 c)", "start": [804, 1], "end": [807, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.toLinearEquiv_trans", "code": "@[simp]\ntheorem toLinearEquiv_trans (e' : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) :\n    (e.trans e').toLinearEquiv = e.toLinearEquiv.trans e'.toLinearEquiv", "start": [810, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.trans_refl", "code": "@[simp]\ntheorem trans_refl : e.trans (refl R\u2082 E\u2082) = e", "start": [816, 1], "end": [818, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.refl_trans", "code": "@[simp]\ntheorem refl_trans : (refl R E).trans e = e", "start": [821, 1], "end": [823, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm : e.trans e.symm = refl R E", "start": [826, 1], "end": [828, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self : e.symm.trans e = refl R\u2082 E\u2082", "start": [831, 1], "end": [833, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_comp_self", "code": "@[simp]\ntheorem symm_comp_self : e.symm \u2218 e = id", "start": [836, 1], "end": [838, 28], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.self_comp_symm", "code": "@[simp]\ntheorem self_comp_symm : e \u2218 e.symm = id", "start": [841, 1], "end": [843, 24], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_trans", "code": "@[simp]\ntheorem symm_trans (e\u2081 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (e\u2082 : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) :\n    (e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm", "start": [846, 1], "end": [849, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_symm_trans", "code": "theorem coe_symm_trans (e\u2081 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (e\u2082 : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) :\n    \u21d1(e\u2081.trans e\u2082).symm = e\u2081.symm \u2218 e\u2082.symm", "start": [852, 1], "end": [854, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.trans_assoc", "code": "theorem trans_assoc (eEE\u2082 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (eE\u2082E\u2083 : E\u2082 \u2243\u209b\u2097\u1d62[\u03c3\u2082\u2083] E\u2083) (eE\u2083E\u2084 : E\u2083 \u2243\u209b\u2097\u1d62[\u03c3\u2083\u2084] E\u2084) :\n    eEE\u2082.trans (eE\u2082E\u2083.trans eE\u2083E\u2084) = (eEE\u2082.trans eE\u2082E\u2083).trans eE\u2083E\u2084", "start": [857, 1], "end": [859, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : E \u2243\u2097\u1d62[R] E) = id", "start": [871, 1], "end": [873, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_mul", "code": "@[simp]\ntheorem coe_mul (e e' : E \u2243\u2097\u1d62[R] E) : \u21d1(e * e') = e \u2218 e'", "start": [876, 1], "end": [878, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_inv", "code": "@[simp]\ntheorem coe_inv (e : E \u2243\u2097\u1d62[R] E) : \u21d1e\u207b\u00b9 = e.symm", "start": [881, 1], "end": [883, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.one_def", "code": "theorem one_def : (1 : E \u2243\u2097\u1d62[R] E) = refl _ _", "start": [886, 1], "end": [887, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.mul_def", "code": "theorem mul_def (e e' : E \u2243\u2097\u1d62[R] E) : (e * e' : E \u2243\u2097\u1d62[R] E) = e'.trans e", "start": [890, 1], "end": [891, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.inv_def", "code": "theorem inv_def (e : E \u2243\u2097\u1d62[R] E) : (e\u207b\u00b9 : E \u2243\u2097\u1d62[R] E) = e.symm", "start": [894, 1], "end": [895, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.trans_one", "code": "@[simp]\ntheorem trans_one : e.trans (1 : E\u2082 \u2243\u2097\u1d62[R\u2082] E\u2082) = e", "start": [907, 1], "end": [909, 15], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.one_trans", "code": "@[simp]\ntheorem one_trans : (1 : E \u2243\u2097\u1d62[R] E).trans e = e", "start": [912, 1], "end": [914, 15], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.refl_mul", "code": "@[simp]\ntheorem refl_mul (e : E \u2243\u2097\u1d62[R] E) : refl _ _ * e = e", "start": [917, 1], "end": [919, 15], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.mul_refl", "code": "@[simp]\ntheorem mul_refl (e : E \u2243\u2097\u1d62[R] E) : e * refl _ _ = e", "start": [922, 1], "end": [924, 15], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_coe", "code": "@[simp]\ntheorem coe_coe : \u21d1(e : E \u2243SL[\u03c3\u2081\u2082] E\u2082) = e", "start": [934, 1], "end": [936, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_coe''", "code": "@[simp]\ntheorem coe_coe'' : \u21d1(e : E \u2192SL[\u03c3\u2081\u2082] E\u2082) = e", "start": [944, 1], "end": [946, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_zero", "code": "theorem map_zero : e 0 = 0", "start": [950, 1], "end": [951, 15], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_add", "code": "theorem map_add (x y : E) : e (x + y) = e x + e y", "start": [955, 1], "end": [956, 18], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_sub", "code": "theorem map_sub (x y : E) : e (x - y) = e x - e y", "start": [960, 1], "end": [961, 18], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_smul\u209b\u2097", "code": "theorem map_smul\u209b\u2097 (c : R) (x : E) : e (c \u2022 x) = \u03c3\u2081\u2082 c \u2022 e x", "start": [965, 1], "end": [966, 21], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_smul", "code": "theorem map_smul [Module R E\u2082] {e : E \u2243\u2097\u1d62[R] E\u2082} (c : R) (x : E) : e (c \u2022 x) = c \u2022 e x", "start": [970, 1], "end": [971, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.nnnorm_map", "code": "theorem nnnorm_map (x : E) : \u2016e x\u2016\u208a = \u2016x\u2016\u208a", "start": [975, 1], "end": [976, 41], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.dist_map", "code": "@[simp]\ntheorem dist_map (x y : E) : dist (e x) (e y) = dist x y", "start": [979, 1], "end": [981, 34], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.edist_map", "code": "@[simp]\ntheorem edist_map (x y : E) : edist (e x) (e y) = edist x y", "start": [984, 1], "end": [986, 35], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.bijective", "code": "protected theorem bijective : Bijective e", "start": [989, 1], "end": [990, 16], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.injective", "code": "protected theorem injective : Injective e", "start": [993, 1], "end": [994, 16], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.surjective", "code": "protected theorem surjective : Surjective e", "start": [997, 1], "end": [998, 17], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_eq_iff", "code": "theorem map_eq_iff {x y : E} : e x = e y \u2194 x = y", "start": [1002, 1], "end": [1003, 21], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.map_ne", "code": "theorem map_ne {x y : E} (h : x \u2260 y) : e x \u2260 e y", "start": [1006, 1], "end": [1007, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.lipschitz", "code": "protected theorem lipschitz : LipschitzWith 1 e", "start": [1010, 1], "end": [1011, 23], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.antilipschitz", "code": "protected theorem antilipschitz : AntilipschitzWith 1 e", "start": [1014, 1], "end": [1015, 27], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.image_eq_preimage", "code": "theorem image_eq_preimage (s : Set E) : e '' s = e.symm \u207b\u00b9' s", "start": [1018, 1], "end": [1019, 38], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ediam_image", "code": "@[simp]\ntheorem ediam_image (s : Set E) : EMetric.diam (e '' s) = EMetric.diam s", "start": [1022, 1], "end": [1024, 27], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.diam_image", "code": "@[simp]\ntheorem diam_image (s : Set E) : Metric.diam (e '' s) = Metric.diam s", "start": [1027, 1], "end": [1029, 26], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.preimage_ball", "code": "@[simp]\ntheorem preimage_ball (x : E\u2082) (r : \u211d) : e \u207b\u00b9' Metric.ball x r = Metric.ball (e.symm x) r", "start": [1032, 1], "end": [1034, 38], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.preimage_sphere", "code": "@[simp]\ntheorem preimage_sphere (x : E\u2082) (r : \u211d) : e \u207b\u00b9' Metric.sphere x r = Metric.sphere (e.symm x) r", "start": [1037, 1], "end": [1039, 40], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.preimage_closedBall", "code": "@[simp]\ntheorem preimage_closedBall (x : E\u2082) (r : \u211d) :\n    e \u207b\u00b9' Metric.closedBall x r = Metric.closedBall (e.symm x) r", "start": [1042, 1], "end": [1045, 44], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.image_ball", "code": "@[simp]\ntheorem image_ball (x : E) (r : \u211d) : e '' Metric.ball x r = Metric.ball (e x) r", "start": [1048, 1], "end": [1050, 35], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.image_sphere", "code": "@[simp]\ntheorem image_sphere (x : E) (r : \u211d) : e '' Metric.sphere x r = Metric.sphere (e x) r", "start": [1053, 1], "end": [1055, 37], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.image_closedBall", "code": "@[simp]\ntheorem image_closedBall (x : E) (r : \u211d) : e '' Metric.closedBall x r = Metric.closedBall (e x) r", "start": [1058, 1], "end": [1060, 41], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.comp_continuousOn_iff", "code": "@[simp]\ntheorem comp_continuousOn_iff {f : \u03b1 \u2192 E} {s : Set \u03b1} : ContinuousOn (e \u2218 f) s \u2194 ContinuousOn f s", "start": [1065, 1], "end": [1067, 35], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff {f : \u03b1 \u2192 E} : Continuous (e \u2218 f) \u2194 Continuous f", "start": [1070, 1], "end": [1072, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.completeSpace_map", "code": "instance completeSpace_map (p : Submodule R E) [CompleteSpace p] :\n    CompleteSpace (p.map (e.toLinearEquiv : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082)) :=\n  e.toLinearIsometry.completeSpace_map' p", "start": [1075, 1], "end": [1077, 42], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofSurjective", "code": "noncomputable def ofSurjective (f : F \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (hfr : Function.Surjective f) :\n    F \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082 :=\n  { LinearEquiv.ofBijective f.toLinearMap \u27e8f.injective, hfr\u27e9 with norm_map' := f.norm_map }", "start": [1080, 1], "end": [1083, 92], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_ofSurjective", "code": "@[simp]\ntheorem coe_ofSurjective (f : F \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (hfr : Function.Surjective f) :\n    \u21d1(LinearIsometryEquiv.ofSurjective f hfr) = f", "start": [1086, 1], "end": [1090, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofLinearIsometry", "code": "def ofLinearIsometry (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (g : E\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] E)\n    (h\u2081 : f.toLinearMap.comp g = LinearMap.id) (h\u2082 : g.comp f.toLinearMap = LinearMap.id) :\n    E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082 :=\n  { LinearEquiv.ofLinear f.toLinearMap g h\u2081 h\u2082 with norm_map' := fun x => f.norm_map x }", "start": [1093, 1], "end": [1097, 89], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_ofLinearIsometry", "code": "@[simp]\ntheorem coe_ofLinearIsometry (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (g : E\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] E)\n    (h\u2081 : f.toLinearMap.comp g = LinearMap.id) (h\u2082 : g.comp f.toLinearMap = LinearMap.id) :\n    (ofLinearIsometry f g h\u2081 h\u2082 : E \u2192 E\u2082) = (f : E \u2192 E\u2082)", "start": [1100, 1], "end": [1104, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_ofLinearIsometry_symm", "code": "@[simp]\ntheorem coe_ofLinearIsometry_symm (f : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082) (g : E\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] E)\n    (h\u2081 : f.toLinearMap.comp g = LinearMap.id) (h\u2082 : g.comp f.toLinearMap = LinearMap.id) :\n    ((ofLinearIsometry f g h\u2081 h\u2082).symm : E\u2082 \u2192 E) = (g : E\u2082 \u2192 E)", "start": [1107, 1], "end": [1111, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.neg", "code": "def neg : E \u2243\u2097\u1d62[R] E :=\n  { LinearEquiv.neg R with norm_map' := norm_neg }", "start": [1116, 1], "end": [1118, 51], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_neg", "code": "@[simp]\ntheorem coe_neg : (neg R : E \u2192 E) = fun x => -x", "start": [1123, 1], "end": [1125, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.symm_neg", "code": "@[simp]\ntheorem symm_neg : (neg R : E \u2243\u2097\u1d62[R] E).symm = neg R", "start": [1128, 1], "end": [1130, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.prodAssoc", "code": "def prodAssoc [Module R E\u2082] [Module R E\u2083] : (E \u00d7 E\u2082) \u00d7 E\u2083 \u2243\u2097\u1d62[R] E \u00d7 E\u2082 \u00d7 E\u2083 :=\n  { Equiv.prodAssoc E E\u2082 E\u2083 with\n    toFun := Equiv.prodAssoc E E\u2082 E\u2083\n    invFun := (Equiv.prodAssoc E E\u2082 E\u2083).symm\n    map_add' := by simp\n    map_smul' := by simp\n    norm_map' := by\n      rintro \u27e8\u27e8e, f\u27e9, g\u27e9\n      simp only [LinearEquiv.coe_mk, Equiv.prodAssoc_apply, Prod.norm_def, max_assoc] }", "start": [1135, 1], "end": [1144, 88], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_prodAssoc", "code": "@[simp]\ntheorem coe_prodAssoc [Module R E\u2082] [Module R E\u2083] :\n    (prodAssoc R E E\u2082 E\u2083 : (E \u00d7 E\u2082) \u00d7 E\u2083 \u2192 E \u00d7 E\u2082 \u00d7 E\u2083) = Equiv.prodAssoc E E\u2082 E\u2083", "start": [1147, 1], "end": [1150, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_prodAssoc_symm", "code": "@[simp]\ntheorem coe_prodAssoc_symm [Module R E\u2082] [Module R E\u2083] :\n    ((prodAssoc R E E\u2082 E\u2083).symm : E \u00d7 E\u2082 \u00d7 E\u2083 \u2192 (E \u00d7 E\u2082) \u00d7 E\u2083) = (Equiv.prodAssoc E E\u2082 E\u2083).symm", "start": [1153, 1], "end": [1156, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofTop", "code": "@[simps! toLinearEquiv apply symm_apply_coe]\ndef ofTop {R : Type*} [Ring R] [Module R E] (p : Submodule R E) (hp : p = \u22a4) : p \u2243\u2097\u1d62[R] E :=\n  { p.subtype\u2097\u1d62 with toLinearEquiv := LinearEquiv.ofTop p hp }", "start": [1159, 1], "end": [1163, 63], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofEq", "code": "def ofEq (hpq : p = q) : p \u2243\u2097\u1d62[R'] q :=\n  { LinearEquiv.ofEq p q hpq with norm_map' := fun _ => rfl }", "start": [1170, 1], "end": [1172, 62], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.coe_ofEq_apply", "code": "@[simp]\ntheorem coe_ofEq_apply (h : p = q) (x : p) : (ofEq p q h x : E) = x", "start": [1177, 1], "end": [1179, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofEq_symm", "code": "@[simp]\ntheorem ofEq_symm (h : p = q) : (ofEq p q h).symm = ofEq q p h.symm", "start": [1182, 1], "end": [1184, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIsometryEquiv.ofEq_rfl", "code": "@[simp]\ntheorem ofEq_rfl : ofEq p p rfl = LinearIsometryEquiv.refl R' p", "start": [1187, 1], "end": [1188, 82], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_linearIsometry", "code": "theorem Basis.ext_linearIsometry {\u03b9 : Type*} (b : Basis \u03b9 R E) {f\u2081 f\u2082 : E \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082}\n    (h : \u2200 i, f\u2081 (b i) = f\u2082 (b i)) : f\u2081 = f\u2082", "start": [1193, 1], "end": [1196, 50], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_linearIsometryEquiv", "code": "theorem Basis.ext_linearIsometryEquiv {\u03b9 : Type*} (b : Basis \u03b9 R E) {f\u2081 f\u2082 : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082}\n    (h : \u2200 i, f\u2081 (b i) = f\u2082 (b i)) : f\u2081 = f\u2082", "start": [1199, 1], "end": [1202, 58], "kind": "commanddeclaration"}, {"full_name": "LinearIsometry.equivRange", "code": "@[simps! apply_coe] noncomputable def LinearIsometry.equivRange {R S : Type*} [Semiring R] [Ring S] [Module S E]\n    [Module R F] {\u03c3\u2081\u2082 : R \u2192+* S} {\u03c3\u2082\u2081 : S \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n    (f : F \u2192\u209b\u2097\u1d62[\u03c3\u2081\u2082] E) : F \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] (LinearMap.range f.toLinearMap) :=\n  { f with toLinearEquiv := LinearEquiv.ofInjective f.toLinearMap f.injective }", "start": [1205, 1], "end": [1210, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Unitary.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Operations.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "unitary", "code": "def unitary (R : Type*) [Monoid R] [StarMul R] : Submonoid R where\n  carrier := { U | star U * U = 1 \u2227 U * star U = 1 }\n  one_mem' := by simp only [mul_one, and_self_iff, Set.mem_setOf_eq, star_one]\n  mul_mem' := @fun U B \u27e8hA\u2081, hA\u2082\u27e9 \u27e8hB\u2081, hB\u2082\u27e9 => by\n    refine' \u27e8_, _\u27e9\n    \u00b7 calc\n        star (U * B) * (U * B) = star B * star U * U * B := by simp only [mul_assoc, star_mul]\n        _ = star B * (star U * U) * B := by rw [\u2190 mul_assoc]\n        _ = 1 := by rw [hA\u2081, mul_one, hB\u2081]\n    \u00b7 calc\n        U * B * star (U * B) = U * B * (star B * star U) := by rw [star_mul]\n        _ = U * (B * star B) * star U := by simp_rw [\u2190 mul_assoc]\n        _ = 1 := by rw [hB\u2082, mul_one, hA\u2082]", "start": [26, 1], "end": [41, 43], "kind": "commanddeclaration"}, {"full_name": "unitary.mem_iff", "code": "theorem mem_iff {U : R} : U \u2208 unitary R \u2194 star U * U = 1 \u2227 U * star U = 1", "start": [52, 1], "end": [53, 10], "kind": "commanddeclaration"}, {"full_name": "unitary.star_mul_self_of_mem", "code": "@[simp]\ntheorem star_mul_self_of_mem {U : R} (hU : U \u2208 unitary R) : star U * U = 1", "start": [56, 1], "end": [58, 7], "kind": "commanddeclaration"}, {"full_name": "unitary.mul_star_self_of_mem", "code": "@[simp]\ntheorem mul_star_self_of_mem {U : R} (hU : U \u2208 unitary R) : U * star U = 1", "start": [61, 1], "end": [63, 7], "kind": "commanddeclaration"}, {"full_name": "unitary.star_mem", "code": "theorem star_mem {U : R} (hU : U \u2208 unitary R) : star U \u2208 unitary R", "start": [66, 1], "end": [67, 91], "kind": "commanddeclaration"}, {"full_name": "unitary.star_mem_iff", "code": "@[simp]\ntheorem star_mem_iff {U : R} : star U \u2208 unitary R \u2194 U \u2208 unitary R", "start": [70, 1], "end": [72, 48], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_star", "code": "@[simp, norm_cast]\ntheorem coe_star {U : unitary R} : \u2191(star U) = (star U : R)", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_star_mul_self", "code": "theorem coe_star_mul_self (U : unitary R) : (star U : R) * U = 1", "start": [83, 1], "end": [84, 30], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_mul_star_self", "code": "theorem coe_mul_star_self (U : unitary R) : (U : R) * star U = 1", "start": [87, 1], "end": [88, 30], "kind": "commanddeclaration"}, {"full_name": "unitary.star_mul_self", "code": "@[simp]\ntheorem star_mul_self (U : unitary R) : star U * U = 1", "start": [91, 1], "end": [93, 37], "kind": "commanddeclaration"}, {"full_name": "unitary.mul_star_self", "code": "@[simp]\ntheorem mul_star_self (U : unitary R) : U * star U = 1", "start": [96, 1], "end": [98, 37], "kind": "commanddeclaration"}, {"full_name": "unitary.star_eq_inv", "code": "theorem star_eq_inv (U : unitary R) : star U = U\u207b\u00b9", "start": [121, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "unitary.star_eq_inv'", "code": "theorem star_eq_inv' : (star : unitary R \u2192 unitary R) = Inv.inv", "start": [125, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "unitary.toUnits", "code": "@[simps]\ndef toUnits : unitary R \u2192* R\u02e3\n    where\n  toFun x := \u27e8x, \u2191x\u207b\u00b9, coe_mul_star_self x, coe_star_mul_self x\u27e9\n  map_one' := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl", "start": [129, 1], "end": [135, 32], "kind": "commanddeclaration"}, {"full_name": "unitary.to_units_injective", "code": "theorem to_units_injective : Function.Injective (toUnits : unitary R \u2192 R\u02e3)", "start": [138, 1], "end": [139, 36], "kind": "commanddeclaration"}, {"full_name": "unitary.mem_iff_star_mul_self", "code": "theorem mem_iff_star_mul_self {U : R} : U \u2208 unitary R \u2194 star U * U = 1", "start": [151, 1], "end": [152, 72], "kind": "commanddeclaration"}, {"full_name": "unitary.mem_iff_self_mul_star", "code": "theorem mem_iff_self_mul_star {U : R} : U \u2208 unitary R \u2194 U * star U = 1", "start": [155, 1], "end": [156, 73], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_inv", "code": "@[norm_cast]\ntheorem coe_inv (U : unitary R) : \u2191U\u207b\u00b9 = (U\u207b\u00b9 : R)", "start": [165, 1], "end": [167, 52], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_div", "code": "@[norm_cast]\ntheorem coe_div (U\u2081 U\u2082 : unitary R) : \u2191(U\u2081 / U\u2082) = (U\u2081 / U\u2082 : R)", "start": [170, 1], "end": [172, 57], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_zpow", "code": "@[norm_cast]\ntheorem coe_zpow (U : unitary R) (z : \u2124) : \u2191(U ^ z) = (U : R) ^ z", "start": [175, 1], "end": [179, 19], "kind": "commanddeclaration"}, {"full_name": "unitary.coe_neg", "code": "@[norm_cast]\ntheorem coe_neg (U : unitary R) : \u2191(-U) = (-U : R)", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Star.lean", "imports": ["Mathlib/Algebra/Star/Module.lean", "Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Algebra/Star.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "starL", "code": "@[simps!]\ndef starL (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A \u2243L\u22c6[R] A where\n  toLinearEquiv := starLinearEquiv R\n  continuous_toFun := continuous_star\n  continuous_invFun := continuous_star", "start": [19, 1], "end": [27, 39], "kind": "commanddeclaration"}, {"full_name": "starL'", "code": "@[simps!]\ndef starL' (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [TrivialStar R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A \u2243L[R] A :=\n  (starL R : A \u2243L\u22c6[R] A).trans\n    ({ AddEquiv.refl A with\n        map_smul' := fun r a => by simp [starRingEnd_apply]\n        continuous_toFun := continuous_id\n        continuous_invFun := continuous_id } :\n      A \u2243L\u22c6[R] A)", "start": [33, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "continuous_selfAdjointPart", "code": "theorem continuous_selfAdjointPart [ContinuousAdd A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (@selfAdjointPart R A _ _ _ _ _ _ _ _)", "start": [50, 1], "end": [52, 85], "kind": "commanddeclaration"}, {"full_name": "continuous_skewAdjointPart", "code": "theorem continuous_skewAdjointPart [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (@skewAdjointPart R A _ _ _ _ _ _ _ _)", "start": [55, 1], "end": [57, 85], "kind": "commanddeclaration"}, {"full_name": "continuous_decomposeProdAdjoint", "code": "theorem continuous_decomposeProdAdjoint [TopologicalAddGroup A] [ContinuousStar A]\n    [ContinuousConstSMul R A] : Continuous (@StarModule.decomposeProdAdjoint R A _ _ _ _ _ _ _ _)", "start": [60, 1], "end": [62, 76], "kind": "commanddeclaration"}, {"full_name": "continuous_decomposeProdAdjoint_symm", "code": "theorem continuous_decomposeProdAdjoint_symm [TopologicalAddGroup A] :\n    Continuous (@StarModule.decomposeProdAdjoint R A _ _ _ _ _ _ _ _).symm", "start": [65, 1], "end": [67, 96], "kind": "commanddeclaration"}, {"full_name": "selfAdjointPartL", "code": "@[simps!]\ndef selfAdjointPartL [ContinuousAdd A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    A \u2192L[R] selfAdjoint A where\n  toLinearMap := selfAdjointPart R\n  cont := continuous_selfAdjointPart _ _", "start": [70, 1], "end": [75, 41], "kind": "commanddeclaration"}, {"full_name": "skewAdjointPartL", "code": "@[simps!]\ndef skewAdjointPartL [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    A \u2192L[R] skewAdjoint A where\n  toLinearMap := skewAdjointPart R\n  cont := continuous_skewAdjointPart _ _", "start": [81, 1], "end": [86, 41], "kind": "commanddeclaration"}, {"full_name": "StarModule.decomposeProdAdjointL", "code": "@[simps!]\ndef StarModule.decomposeProdAdjointL [TopologicalAddGroup A] [ContinuousStar A]\n    [ContinuousConstSMul R A] : A \u2243L[R] selfAdjoint A \u00d7 skewAdjoint A where\n  toLinearEquiv := StarModule.decomposeProdAdjoint R A\n  continuous_toFun := continuous_decomposeProdAdjoint _ _\n  continuous_invFun := continuous_decomposeProdAdjoint_symm _ _", "start": [89, 1], "end": [96, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/StarSubalgebra.lean", "imports": ["Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Algebra/Star/Subalgebra.lean", "Mathlib/Topology/Algebra/Star.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StarSubalgebra.embedding_inclusion", "code": "theorem embedding_inclusion {S\u2081 S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082) : Embedding (inclusion h)", "start": [46, 1], "end": [49, 59], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.closedEmbedding_inclusion", "code": "theorem closedEmbedding_inclusion {S\u2081 S\u2082 : StarSubalgebra R A} (h : S\u2081 \u2264 S\u2082)\n    (hS\u2081 : IsClosed (S\u2081 : Set A)) : ClosedEmbedding (inclusion h)", "start": [52, 1], "end": [61, 27], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure", "code": "def topologicalClosure (s : StarSubalgebra R A) : StarSubalgebra R A :=\n  {\n    s.toSubalgebra.topologicalClosure with\n    carrier := closure (s : Set A)\n    star_mem' := fun ha =>\n      map_mem_closure continuous_star ha fun x => (star_mem : x \u2208 s \u2192 star x \u2208 s) }", "start": [68, 1], "end": [74, 84], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_toSubalgebra_comm", "code": "theorem topologicalClosure_toSubalgebra_comm (s : StarSubalgebra R A) :\n    s.topologicalClosure.toSubalgebra = s.toSubalgebra.topologicalClosure", "start": [77, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_coe", "code": "@[simp]\ntheorem topologicalClosure_coe (s : StarSubalgebra R A) :\n    (s.topologicalClosure : Set A) = closure (s : Set A)", "start": [81, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.le_topologicalClosure", "code": "theorem le_topologicalClosure (s : StarSubalgebra R A) : s \u2264 s.topologicalClosure", "start": [87, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.isClosed_topologicalClosure", "code": "theorem isClosed_topologicalClosure (s : StarSubalgebra R A) :\n    IsClosed (s.topologicalClosure : Set A)", "start": [91, 1], "end": [93, 19], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_minimal", "code": "theorem topologicalClosure_minimal {s t : StarSubalgebra R A} (h : s \u2264 t)\n    (ht : IsClosed (t : Set A)) : s.topologicalClosure \u2264 t", "start": [101, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_mono", "code": "theorem topologicalClosure_mono : Monotone (topologicalClosure : _ \u2192 StarSubalgebra R A)", "start": [106, 1], "end": [108, 100], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_map_le", "code": "theorem topologicalClosure_map_le [StarModule R B] [TopologicalSemiring B] [ContinuousStar B]\n    (s : StarSubalgebra R A) (\u03c6 : A \u2192\u22c6\u2090[R] B) (h\u03c6 : IsClosedMap \u03c6) :\n    (map \u03c6 s).topologicalClosure \u2264 map \u03c6 s.topologicalClosure", "start": [111, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.map_topologicalClosure_le", "code": "theorem map_topologicalClosure_le [StarModule R B] [TopologicalSemiring B] [ContinuousStar B]\n    (s : StarSubalgebra R A) (\u03c6 : A \u2192\u22c6\u2090[R] B) (h\u03c6 : Continuous \u03c6) :\n    map \u03c6 s.topologicalClosure \u2264 (map \u03c6 s).topologicalClosure", "start": [116, 1], "end": [119, 40], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.topologicalClosure_map", "code": "theorem topologicalClosure_map [StarModule R B] [TopologicalSemiring B] [ContinuousStar B]\n    (s : StarSubalgebra R A) (\u03c6 : A \u2192\u22c6\u2090[R] B) (h\u03c6 : ClosedEmbedding \u03c6) :\n    (map \u03c6 s).topologicalClosure = map \u03c6 s.topologicalClosure", "start": [121, 1], "end": [124, 49], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topologicalClosure_star_comm", "code": "theorem _root_.Subalgebra.topologicalClosure_star_comm (s : Subalgebra R A) :\n    (star s).topologicalClosure = star s.topologicalClosure", "start": [126, 1], "end": [131, 48], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.commSemiringTopologicalClosure", "code": "@[reducible]\ndef commSemiringTopologicalClosure [T2Space A] (s : StarSubalgebra R A)\n    (hs : \u2200 x y : s, x * y = y * x) : CommSemiring s.topologicalClosure :=\n  s.toSubalgebra.commSemiringTopologicalClosure hs", "start": [133, 1], "end": [138, 51], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.commRingTopologicalClosure", "code": "@[reducible]\ndef commRingTopologicalClosure {R A} [CommRing R] [StarRing R] [TopologicalSpace A] [Ring A]\n    [Algebra R A] [StarRing A] [StarModule R A] [TopologicalRing A] [ContinuousStar A] [T2Space A]\n    (s : StarSubalgebra R A) (hs : \u2200 x y : s, x * y = y * x) : CommRing s.topologicalClosure :=\n  s.toSubalgebra.commRingTopologicalClosure hs", "start": [141, 1], "end": [147, 47], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.ext_topologicalClosure", "code": "theorem _root_.StarAlgHom.ext_topologicalClosure [T2Space B] {S : StarSubalgebra R A}\n    {\u03c6 \u03c8 : S.topologicalClosure \u2192\u22c6\u2090[R] B} (h\u03c6 : Continuous \u03c6) (h\u03c8 : Continuous \u03c8)\n    (h :\n      \u03c6.comp (inclusion (le_topologicalClosure S)) = \u03c8.comp (inclusion (le_topologicalClosure S))) :\n    \u03c6 = \u03c8", "start": [150, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "StarAlgHomClass.ext_topologicalClosure", "code": "theorem _root_.StarAlgHomClass.ext_topologicalClosure [T2Space B] {F : Type*}\n    {S : StarSubalgebra R A} [StarAlgHomClass F R S.topologicalClosure B] {\u03c6 \u03c8 : F}\n    (h\u03c6 : Continuous \u03c6) (h\u03c8 : Continuous \u03c8) (h : \u2200 x : S,\n        \u03c6 (inclusion (le_topologicalClosure S) x) = \u03c8 ((inclusion (le_topologicalClosure S)) x)) :\n    \u03c6 = \u03c8", "start": [172, 1], "end": [182, 24], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra", "code": "def elementalStarAlgebra (x : A) : StarSubalgebra R A :=\n  (adjoin R ({x} : Set A)).topologicalClosure", "start": [201, 1], "end": [203, 46], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.self_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem self_mem (x : A) : x \u2208 elementalStarAlgebra R x", "start": [208, 1], "end": [210, 78], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.star_self_mem", "code": "theorem star_self_mem (x : A) : star x \u2208 elementalStarAlgebra R x", "start": [213, 1], "end": [214, 27], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.isClosed", "code": "protected theorem isClosed (x : A) : IsClosed (elementalStarAlgebra R x : Set A)", "start": [227, 1], "end": [228, 19], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.le_of_isClosed_of_mem", "code": "theorem le_of_isClosed_of_mem {S : StarSubalgebra R A} (hS : IsClosed (S : Set A)) {x : A}\n    (hx : x \u2208 S) : elementalStarAlgebra R x \u2264 S", "start": [236, 1], "end": [238, 77], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.closedEmbedding_coe", "code": "theorem closedEmbedding_coe (x : A) : ClosedEmbedding ((\u2191) : elementalStarAlgebra R x \u2192 A)", "start": [241, 1], "end": [251, 54], "kind": "commanddeclaration"}, {"full_name": "elementalStarAlgebra.starAlgHomClass_ext", "code": "theorem starAlgHomClass_ext [T2Space B] {F : Type*} {a : A}\n    [StarAlgHomClass F R (elementalStarAlgebra R a) B] {\u03c6 \u03c8 : F} (h\u03c6 : Continuous \u03c6)\n    (h\u03c8 : Continuous \u03c8) (h : \u03c6 \u27e8a, self_mem R a\u27e9 = \u03c8 \u27e8a, self_mem R a\u27e9) : \u03c6 = \u03c8", "start": [254, 1], "end": [261, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/Hom.lean", "imports": ["Mathlib/Analysis/Normed/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NormedAddGroupHom", "code": "structure NormedAddGroupHom (V W : Type*) [SeminormedAddCommGroup V]\n  [SeminormedAddCommGroup W] where\n  \n  toFun : V \u2192 W\n  \n  map_add' : \u2200 v\u2081 v\u2082, toFun (v\u2081 + v\u2082) = toFun v\u2081 + toFun v\u2082\n  \n  bound' : \u2203 C, \u2200 v, \u2016toFun v\u2016 \u2264 C * \u2016v\u2016", "start": [34, 1], "end": [42, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mkNormedAddGroupHom", "code": "def mkNormedAddGroupHom (f : V \u2192+ W) (C : \u211d) (h : \u2200 v, \u2016f v\u2016 \u2264 C * \u2016v\u2016) : NormedAddGroupHom V W :=\n  { f with bound' := \u27e8C, h\u27e9 }", "start": [50, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mkNormedAddGroupHom'", "code": "def mkNormedAddGroupHom' (f : V \u2192+ W) (C : \u211d\u22650) (hC : \u2200 x, \u2016f x\u2016\u208a \u2264 C * \u2016x\u2016\u208a) :\n    NormedAddGroupHom V W :=\n  { f with bound' := \u27e8C, hC\u27e9 }", "start": [57, 1], "end": [62, 31], "kind": "commanddeclaration"}, {"full_name": "exists_pos_bound_of_bound", "code": "theorem exists_pos_bound_of_bound {V W : Type*} [SeminormedAddCommGroup V]\n    [SeminormedAddCommGroup W] {f : V \u2192 W} (M : \u211d) (h : \u2200 x, \u2016f x\u2016 \u2264 M * \u2016x\u2016) :\n    \u2203 N, 0 < N \u2227 \u2200 x, \u2016f x\u2016 \u2264 N * \u2016x\u2016", "start": [67, 1], "end": [74, 8], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ofLipschitz", "code": "def ofLipschitz (f : V\u2081 \u2192+ V\u2082) {K : \u211d\u22650} (h : LipschitzWith K f) : NormedAddGroupHom V\u2081 V\u2082 :=\n  f.mkNormedAddGroupHom K fun x \u21a6 by simpa only [map_zero, dist_zero_right] using h.dist_le_mul x 0", "start": [84, 1], "end": [86, 100], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toAddMonoidHomClass", "code": "instance toAddMonoidHomClass : AddMonoidHomClass (NormedAddGroupHom V\u2081 V\u2082) V\u2081 V\u2082 where\n  coe := toFun\n  coe_injective' := fun f g h => by cases f; cases g; congr\n  map_add f := f.map_add'\n  map_zero f := (AddMonoidHom.mk' f.toFun f.map_add').map_zero", "start": [89, 1], "end": [93, 63], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coeFun", "code": "instance coeFun : CoeFun (NormedAddGroupHom V\u2081 V\u2082) fun _ => V\u2081 \u2192 V\u2082 :=\n  \u27e8FunLike.coe\u27e9", "start": [95, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_inj", "code": "theorem coe_inj (H : (f : V\u2081 \u2192 V\u2082) = g) : f = g", "start": [101, 1], "end": [102, 26], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_injective", "code": "theorem coe_injective : @Function.Injective (NormedAddGroupHom V\u2081 V\u2082) (V\u2081 \u2192 V\u2082) toFun", "start": [105, 1], "end": [106, 16], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_inj_iff", "code": "theorem coe_inj_iff : f = g \u2194 (f : V\u2081 \u2192 V\u2082) = g", "start": [109, 1], "end": [110, 25], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ext", "code": "@[ext]\ntheorem ext (H : \u2200 x, f x = g x) : f = g", "start": [113, 1], "end": [115, 22], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ext_iff", "code": "theorem ext_iff : f = g \u2194 \u2200 x, f x = g x", "start": [118, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe : f.toFun = f", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_mk", "code": "theorem coe_mk (f) (h\u2081) (h\u2082) (h\u2083) : \u21d1(\u27e8f, h\u2081, h\u2082, h\u2083\u27e9 : NormedAddGroupHom V\u2081 V\u2082) = f", "start": [130, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_mkNormedAddGroupHom", "code": "@[simp]\ntheorem coe_mkNormedAddGroupHom (f : V\u2081 \u2192+ V\u2082) (C) (hC) : \u21d1(f.mkNormedAddGroupHom C hC) = f", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_mkNormedAddGroupHom'", "code": "@[simp]\ntheorem coe_mkNormedAddGroupHom' (f : V\u2081 \u2192+ V\u2082) (C) (hC) : \u21d1(f.mkNormedAddGroupHom' C hC) = f", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toAddMonoidHom", "code": "def toAddMonoidHom (f : NormedAddGroupHom V\u2081 V\u2082) : V\u2081 \u2192+ V\u2082 :=\n  AddMonoidHom.mk' f f.map_add'", "start": [144, 1], "end": [146, 32], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_toAddMonoidHom", "code": "@[simp]\ntheorem coe_toAddMonoidHom : \u21d1f.toAddMonoidHom = f", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toAddMonoidHom_injective", "code": "theorem toAddMonoidHom_injective :\n    Function.Injective (@NormedAddGroupHom.toAddMonoidHom V\u2081 V\u2082 _ _)", "start": [154, 1], "end": [156, 69], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mk_toAddMonoidHom", "code": "@[simp]\ntheorem mk_toAddMonoidHom (f) (h\u2081) (h\u2082) :\n    (\u27e8f, h\u2081, h\u2082\u27e9 : NormedAddGroupHom V\u2081 V\u2082).toAddMonoidHom = AddMonoidHom.mk' f h\u2081", "start": [159, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.bound", "code": "theorem bound : \u2203 C, 0 < C \u2227 \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016", "start": [165, 1], "end": [167, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.antilipschitz_of_norm_ge", "code": "theorem antilipschitz_of_norm_ge {K : \u211d\u22650} (h : \u2200 x, \u2016x\u2016 \u2264 K * \u2016f x\u2016) : AntilipschitzWith K f", "start": [170, 1], "end": [171, 100], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.SurjectiveOnWith", "code": "def SurjectiveOnWith (f : NormedAddGroupHom V\u2081 V\u2082) (K : AddSubgroup V\u2082) (C : \u211d) : Prop :=\n  \u2200 h \u2208 K, \u2203 g, f g = h \u2227 \u2016g\u2016 \u2264 C * \u2016h\u2016", "start": [174, 1], "end": [179, 40], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.SurjectiveOnWith.mono", "code": "theorem SurjectiveOnWith.mono {f : NormedAddGroupHom V\u2081 V\u2082} {K : AddSubgroup V\u2082} {C C' : \u211d}\n    (h : f.SurjectiveOnWith K C) (H : C \u2264 C') : f.SurjectiveOnWith K C'", "start": [182, 1], "end": [189, 31], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.SurjectiveOnWith.exists_pos", "code": "theorem SurjectiveOnWith.exists_pos {f : NormedAddGroupHom V\u2081 V\u2082} {K : AddSubgroup V\u2082} {C : \u211d}\n    (h : f.SurjectiveOnWith K C) : \u2203 C' > 0, f.SurjectiveOnWith K C'", "start": [192, 1], "end": [197, 29], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.SurjectiveOnWith.surjOn", "code": "theorem SurjectiveOnWith.surjOn {f : NormedAddGroupHom V\u2081 V\u2082} {K : AddSubgroup V\u2082} {C : \u211d}\n    (h : f.SurjectiveOnWith K C) : Set.SurjOn f Set.univ K", "start": [200, 1], "end": [202, 54], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm", "code": "def opNorm (f : NormedAddGroupHom V\u2081 V\u2082) :=\n  sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [208, 1], "end": [210, 44], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.hasOpNorm", "code": "instance hasOpNorm : Norm (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e8opNorm\u27e9", "start": [213, 1], "end": [214, 11], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_def", "code": "theorem norm_def : \u2016f\u2016 = sInf { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.bounds_nonempty", "code": "theorem bounds_nonempty {f : NormedAddGroupHom V\u2081 V\u2082} :\n    \u2203 c, c \u2208 { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [223, 1], "end": [226, 25], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.bounds_bddBelow", "code": "theorem bounds_bddBelow {f : NormedAddGroupHom V\u2081 V\u2082} :\n    BddBelow { c | 0 \u2264 c \u2227 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016x\u2016 }", "start": [229, 1], "end": [231, 27], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_nonneg", "code": "theorem opNorm_nonneg : 0 \u2264 \u2016f\u2016", "start": [234, 1], "end": [235, 47], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.le_opNorm", "code": "theorem le_opNorm (x : V\u2081) : \u2016f x\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016", "start": [238, 1], "end": [247, 86], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.le_opNorm_of_le", "code": "theorem le_opNorm_of_le {c : \u211d} {x} (h : \u2016x\u2016 \u2264 c) : \u2016f x\u2016 \u2264 \u2016f\u2016 * c", "start": [250, 1], "end": [251, 62], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.le_of_opNorm_le", "code": "theorem le_of_opNorm_le {c : \u211d} (h : \u2016f\u2016 \u2264 c) (x : V\u2081) : \u2016f x\u2016 \u2264 c * \u2016x\u2016", "start": [254, 1], "end": [255, 36], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.lipschitz", "code": "theorem lipschitz : LipschitzWith \u27e8\u2016f\u2016, opNorm_nonneg f\u27e9 f", "start": [258, 1], "end": [262, 20], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.uniformContinuous", "code": "protected theorem uniformContinuous (f : NormedAddGroupHom V\u2081 V\u2082) : UniformContinuous f", "start": [265, 1], "end": [266, 32], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.continuous", "code": "@[continuity]\nprotected theorem continuous (f : NormedAddGroupHom V\u2081 V\u2082) : Continuous f", "start": [269, 1], "end": [271, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ratio_le_opNorm", "code": "theorem ratio_le_opNorm (x : V\u2081) : \u2016f x\u2016 / \u2016x\u2016 \u2264 \u2016f\u2016", "start": [274, 1], "end": [275, 77], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_le_bound", "code": "theorem opNorm_le_bound {M : \u211d} (hMp : 0 \u2264 M) (hM : \u2200 x, \u2016f x\u2016 \u2264 M * \u2016x\u2016) : \u2016f\u2016 \u2264 M", "start": [278, 1], "end": [280, 37], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_eq_of_bounds", "code": "theorem opNorm_eq_of_bounds {M : \u211d} (M_nonneg : 0 \u2264 M) (h_above : \u2200 x, \u2016f x\u2016 \u2264 M * \u2016x\u2016)\n    (h_below : \u2200 N \u2265 0, (\u2200 x, \u2016f x\u2016 \u2264 N * \u2016x\u2016) \u2192 M \u2264 N) : \u2016f\u2016 = M", "start": [283, 1], "end": [287, 53], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_le_of_lipschitz", "code": "theorem opNorm_le_of_lipschitz {f : NormedAddGroupHom V\u2081 V\u2082} {K : \u211d\u22650} (hf : LipschitzWith K f) :\n    \u2016f\u2016 \u2264 K", "start": [290, 1], "end": [292, 100], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mkNormedAddGroupHom_norm_le", "code": "theorem mkNormedAddGroupHom_norm_le (f : V\u2081 \u2192+ V\u2082) {C : \u211d} (hC : 0 \u2264 C) (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    \u2016f.mkNormedAddGroupHom C h\u2016 \u2264 C", "start": [295, 1], "end": [300, 25], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ofLipschitz_norm_le", "code": "theorem ofLipschitz_norm_le (f : V\u2081 \u2192+ V\u2082) {K : \u211d\u22650} (h : LipschitzWith K f) :\n    \u2016ofLipschitz f h\u2016 \u2264 K", "start": [303, 1], "end": [307, 47], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mkNormedAddGroupHom_norm_le'", "code": "theorem mkNormedAddGroupHom_norm_le' (f : V\u2081 \u2192+ V\u2082) {C : \u211d} (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    \u2016f.mkNormedAddGroupHom C h\u2016 \u2264 max C 0", "start": [309, 1], "end": [315, 48], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mkNormedAddGroupHom_norm_le", "code": "alias _root_.AddMonoidHom.mkNormedAddGroupHom_norm_le := mkNormedAddGroupHom_norm_le", "start": [318, 1], "end": [318, 85], "kind": "stdtacticaliasalias"}, {"full_name": "AddMonoidHom.mkNormedAddGroupHom_norm_le'", "code": "alias _root_.AddMonoidHom.mkNormedAddGroupHom_norm_le' := mkNormedAddGroupHom_norm_le'", "start": [321, 1], "end": [321, 87], "kind": "stdtacticaliasalias"}, {"full_name": "NormedAddGroupHom.add", "code": "instance add : Add (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e8fun f g =>\n    (f.toAddMonoidHom + g.toAddMonoidHom).mkNormedAddGroupHom (\u2016f\u2016 + \u2016g\u2016) fun v =>\n      calc\n        \u2016f v + g v\u2016 \u2264 \u2016f v\u2016 + \u2016g v\u2016 := norm_add_le _ _\n        _ \u2264 \u2016f\u2016 * \u2016v\u2016 + \u2016g\u2016 * \u2016v\u2016 := by gcongr <;> apply le_opNorm\n        _ = (\u2016f\u2016 + \u2016g\u2016) * \u2016v\u2016 := by rw [add_mul]\n        \u27e9", "start": [327, 1], "end": [335, 10], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_add_le", "code": "theorem opNorm_add_le : \u2016f + g\u2016 \u2264 \u2016f\u2016 + \u2016g\u2016", "start": [337, 1], "end": [339, 83], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_add", "code": "@[simp]\ntheorem coe_add (f g : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(f + g) = f + g", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.add_apply", "code": "@[simp]\ntheorem add_apply (f g : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) :\n    (f + g) v = f v + g v", "start": [357, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zero", "code": "instance zero : Zero (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e8(0 : V\u2081 \u2192+ V\u2082).mkNormedAddGroupHom 0 (by simp)\u27e9", "start": [366, 1], "end": [367, 51], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.inhabited", "code": "instance inhabited : Inhabited (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e80\u27e9", "start": [369, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_zero", "code": "theorem opNorm_zero : \u2016(0 : NormedAddGroupHom V\u2081 V\u2082)\u2016 = 0", "start": [372, 1], "end": [381, 22], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_zero_iff", "code": "theorem opNorm_zero_iff {V\u2081 V\u2082 : Type*} [NormedAddCommGroup V\u2081] [NormedAddCommGroup V\u2082]\n    {f : NormedAddGroupHom V\u2081 V\u2082} : \u2016f\u2016 = 0 \u2194 f = 0", "start": [384, 1], "end": [395, 38], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : NormedAddGroupHom V\u2081 V\u2082) = 0", "start": [398, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zero_apply", "code": "@[simp]\ntheorem zero_apply (v : V\u2081) : (0 : NormedAddGroupHom V\u2081 V\u2082) v = 0", "start": [403, 1], "end": [405, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.id", "code": "@[simps!]\ndef id : NormedAddGroupHom V V :=\n  (AddMonoidHom.id V).mkNormedAddGroupHom 1 (by simp [le_refl])", "start": [415, 1], "end": [418, 64], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_id_le", "code": "theorem norm_id_le : \u2016(id V : NormedAddGroupHom V V)\u2016 \u2264 1", "start": [421, 1], "end": [425, 49], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_id_of_nontrivial_seminorm", "code": "theorem norm_id_of_nontrivial_seminorm (h : \u2203 x : V, \u2016x\u2016 \u2260 0) : \u2016id V\u2016 = 1", "start": [428, 1], "end": [434, 40], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_id", "code": "theorem norm_id {V : Type*} [NormedAddCommGroup V] [Nontrivial V] : \u2016id V\u2016 = 1", "start": [437, 1], "end": [441, 42], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_id", "code": "theorem coe_id : (NormedAddGroupHom.id V : V \u2192 V) = _root_.id", "start": [444, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.neg", "code": "instance neg : Neg (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e8fun f => (-f.toAddMonoidHom).mkNormedAddGroupHom \u2016f\u2016 fun v => by simp [le_opNorm f v]\u27e9", "start": [451, 1], "end": [453, 90], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_neg", "code": "@[simp]\ntheorem coe_neg (f : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(-f) = -f", "start": [455, 1], "end": [457, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) :\n    (-f : NormedAddGroupHom V\u2081 V\u2082) v = -f v", "start": [460, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.opNorm_neg", "code": "theorem opNorm_neg (f : NormedAddGroupHom V\u2081 V\u2082) : \u2016-f\u2016 = \u2016f\u2016", "start": [466, 1], "end": [467, 56], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.sub", "code": "instance sub : Sub (NormedAddGroupHom V\u2081 V\u2082) :=\n  \u27e8fun f g =>\n    { f.toAddMonoidHom - g.toAddMonoidHom with\n      bound' := by\n        simp only [AddMonoidHom.sub_apply, AddMonoidHom.toFun_eq_coe, sub_eq_add_neg]\n        exact (f + -g).bound' }\u27e9", "start": [473, 1], "end": [479, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_sub", "code": "@[simp]\ntheorem coe_sub (f g : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(f - g) = f - g", "start": [481, 1], "end": [483, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) :\n    (f - g : NormedAddGroupHom V\u2081 V\u2082) v = f v - g v", "start": [486, 1], "end": [489, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.smul", "code": "instance smul : SMul R (NormedAddGroupHom V\u2081 V\u2082) where\n  smul r f :=\n    { toFun := r \u2022 \u21d1f\n      map_add' := (r \u2022 f.toAddMonoidHom).map_add'\n      bound' :=\n        let \u27e8b, hb\u27e9 := f.bound'\n        \u27e8dist r 0 * b, fun x => by\n          have := dist_smul_pair r (f x) (f 0)\n          rw [map_zero, smul_zero, dist_zero_right, dist_zero_right] at this\n          rw [mul_assoc]\n          refine' this.trans _\n          gcongr\n          exact hb x\u27e9 }", "start": [501, 1], "end": [513, 24], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_smul", "code": "@[simp]\ntheorem coe_smul (r : R) (f : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [515, 1], "end": [517, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.smul_apply", "code": "@[simp]\ntheorem smul_apply (r : R) (f : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) : (r \u2022 f) v = r \u2022 f v", "start": [520, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.smulCommClass", "code": "instance smulCommClass [SMulCommClass R R' V\u2082] :\n    SMulCommClass R R' (NormedAddGroupHom V\u2081 V\u2082) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _", "start": [525, 1], "end": [527, 50], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isScalarTower", "code": "instance isScalarTower [SMul R R'] [IsScalarTower R R' V\u2082] :\n    IsScalarTower R R' (NormedAddGroupHom V\u2081 V\u2082) where\n  smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _", "start": [529, 1], "end": [531, 52], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isCentralScalar", "code": "instance isCentralScalar [DistribMulAction R\u1d50\u1d52\u1d56 V\u2082] [IsCentralScalar R V\u2082] :\n    IsCentralScalar R (NormedAddGroupHom V\u2081 V\u2082) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _", "start": [533, 1], "end": [535, 58], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.nsmul", "code": "instance nsmul : SMul \u2115 (NormedAddGroupHom V\u2081 V\u2082) where\n  smul n f :=\n    { toFun := n \u2022 \u21d1f\n      map_add' := (n \u2022 f.toAddMonoidHom).map_add'\n      bound' :=\n        let \u27e8b, hb\u27e9 := f.bound'\n        \u27e8n \u2022 b, fun v => by\n          rw [Pi.smul_apply, nsmul_eq_mul, mul_assoc]\n          exact (norm_nsmul_le _ _).trans (by gcongr; apply hb)\u27e9 }", "start": [539, 1], "end": [547, 67], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_nsmul", "code": "@[simp]\ntheorem coe_nsmul (r : \u2115) (f : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.nsmul_apply", "code": "@[simp]\ntheorem nsmul_apply (r : \u2115) (f : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) : (r \u2022 f) v = r \u2022 f v", "start": [555, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zsmul", "code": "instance zsmul : SMul \u2124 (NormedAddGroupHom V\u2081 V\u2082) where\n  smul z f :=\n    { toFun := z \u2022 \u21d1f\n      map_add' := (z \u2022 f.toAddMonoidHom).map_add'\n      bound' :=\n        let \u27e8b, hb\u27e9 := f.bound'\n        \u27e8\u2016z\u2016 \u2022 b, fun v => by\n          rw [Pi.smul_apply, smul_eq_mul, mul_assoc]\n          exact (norm_zsmul_le _ _).trans (by gcongr; apply hb)\u27e9 }", "start": [560, 1], "end": [568, 67], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_zsmul", "code": "@[simp]\ntheorem coe_zsmul (r : \u2124) (f : NormedAddGroupHom V\u2081 V\u2082) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [571, 1], "end": [573, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zsmul_apply", "code": "@[simp]\ntheorem zsmul_apply (r : \u2124) (f : NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) : (r \u2022 f) v = r \u2022 f v", "start": [576, 1], "end": [578, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toAddCommGroup", "code": "instance toAddCommGroup : AddCommGroup (NormedAddGroupHom V\u2081 V\u2082) :=\n  coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    fun _ _ => rfl", "start": [584, 1], "end": [587, 19], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toSeminormedAddCommGroup", "code": "instance toSeminormedAddCommGroup : SeminormedAddCommGroup (NormedAddGroupHom V\u2081 V\u2082) :=\n  AddGroupSeminorm.toSeminormedAddCommGroup\n    { toFun := opNorm\n      map_zero' := opNorm_zero\n      neg' := opNorm_neg\n      add_le' := opNorm_add_le }", "start": [589, 1], "end": [596, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.toNormedAddCommGroup", "code": "instance toNormedAddCommGroup {V\u2081 V\u2082 : Type*} [NormedAddCommGroup V\u2081] [NormedAddCommGroup V\u2082] :\n    NormedAddCommGroup (NormedAddGroupHom V\u2081 V\u2082) :=\n  AddGroupNorm.toNormedAddCommGroup\n    { toFun := opNorm\n      map_zero' := opNorm_zero\n      neg' := opNorm_neg\n      add_le' := opNorm_add_le\n      eq_zero_of_map_eq_zero' := fun _f => opNorm_zero_iff.1 }", "start": [599, 1], "end": [608, 63], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coeAddHom", "code": "@[simps]\ndef coeAddHom : NormedAddGroupHom V\u2081 V\u2082 \u2192+ V\u2081 \u2192 V\u2082 where\n  toFun := FunLike.coe\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [611, 1], "end": [616, 22], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_sum", "code": "@[simp]\ntheorem coe_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 NormedAddGroupHom V\u2081 V\u2082) :\n    \u21d1(\u2211 i in s, f i) = \u2211 i in s, (f i : V\u2081 \u2192 V\u2082)", "start": [619, 1], "end": [622, 41], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.sum_apply", "code": "theorem sum_apply {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 NormedAddGroupHom V\u2081 V\u2082) (v : V\u2081) :\n    (\u2211 i in s, f i) v = \u2211 i in s, f i v", "start": [625, 1], "end": [626, 84], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.distribMulAction", "code": "instance distribMulAction {R : Type*} [MonoidWithZero R] [DistribMulAction R V\u2082]\n    [PseudoMetricSpace R] [BoundedSMul R V\u2082] : DistribMulAction R (NormedAddGroupHom V\u2081 V\u2082) :=\n  Function.Injective.distribMulAction coeAddHom coe_injective coe_smul", "start": [632, 1], "end": [634, 71], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.module", "code": "instance module {R : Type*} [Semiring R] [Module R V\u2082] [PseudoMetricSpace R] [BoundedSMul R V\u2082] :\n    Module R (NormedAddGroupHom V\u2081 V\u2082) :=\n  Function.Injective.module _ coeAddHom coe_injective coe_smul", "start": [636, 1], "end": [638, 63], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.comp", "code": "@[simps!]\nprotected def comp (g : NormedAddGroupHom V\u2082 V\u2083) (f : NormedAddGroupHom V\u2081 V\u2082) :\n    NormedAddGroupHom V\u2081 V\u2083 :=\n  (g.toAddMonoidHom.comp f.toAddMonoidHom).mkNormedAddGroupHom (\u2016g\u2016 * \u2016f\u2016) fun v =>\n    calc\n      \u2016g (f v)\u2016 \u2264 \u2016g\u2016 * \u2016f v\u2016 := le_opNorm _ _\n      _ \u2264 \u2016g\u2016 * (\u2016f\u2016 * \u2016v\u2016) := by gcongr; apply le_opNorm\n      _ = \u2016g\u2016 * \u2016f\u2016 * \u2016v\u2016 := by rw [mul_assoc]", "start": [643, 1], "end": [651, 47], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_comp_le", "code": "theorem norm_comp_le (g : NormedAddGroupHom V\u2082 V\u2083) (f : NormedAddGroupHom V\u2081 V\u2082) :\n    \u2016g.comp f\u2016 \u2264 \u2016g\u2016 * \u2016f\u2016", "start": [654, 1], "end": [656, 83], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_comp_le_of_le", "code": "theorem norm_comp_le_of_le {g : NormedAddGroupHom V\u2082 V\u2083} {C\u2081 C\u2082 : \u211d} (hg : \u2016g\u2016 \u2264 C\u2082)\n    (hf : \u2016f\u2016 \u2264 C\u2081) : \u2016g.comp f\u2016 \u2264 C\u2082 * C\u2081", "start": [659, 1], "end": [661, 78], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_comp_le_of_le'", "code": "theorem norm_comp_le_of_le' {g : NormedAddGroupHom V\u2082 V\u2083} (C\u2081 C\u2082 C\u2083 : \u211d) (h : C\u2083 = C\u2082 * C\u2081)\n    (hg : \u2016g\u2016 \u2264 C\u2082) (hf : \u2016f\u2016 \u2264 C\u2081) : \u2016g.comp f\u2016 \u2264 C\u2083", "start": [664, 1], "end": [667, 33], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.compHom", "code": "def compHom : NormedAddGroupHom V\u2082 V\u2083 \u2192+ NormedAddGroupHom V\u2081 V\u2082 \u2192+ NormedAddGroupHom V\u2081 V\u2083 :=\n  AddMonoidHom.mk'\n    (fun g =>\n      AddMonoidHom.mk' (fun f => g.comp f)\n        (by\n          intros\n          ext\n          exact map_add g _ _))\n    (by\n      intros\n      ext\n      simp only [comp_apply, Pi.add_apply, Function.comp_apply, AddMonoidHom.add_apply,\n        AddMonoidHom.mk'_apply, coe_add])", "start": [670, 1], "end": [683, 42], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.comp_zero", "code": "@[simp]\ntheorem comp_zero (f : NormedAddGroupHom V\u2082 V\u2083) : f.comp (0 : NormedAddGroupHom V\u2081 V\u2082) = 0", "start": [686, 1], "end": [689, 19], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zero_comp", "code": "@[simp]\ntheorem zero_comp (f : NormedAddGroupHom V\u2081 V\u2082) : (0 : NormedAddGroupHom V\u2082 V\u2083).comp f = 0", "start": [692, 1], "end": [695, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.comp_assoc", "code": "theorem comp_assoc {V\u2084 : Type*} [SeminormedAddCommGroup V\u2084] (h : NormedAddGroupHom V\u2083 V\u2084)\n    (g : NormedAddGroupHom V\u2082 V\u2083) (f : NormedAddGroupHom V\u2081 V\u2082) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [698, 1], "end": [702, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_comp", "code": "theorem coe_comp (f : NormedAddGroupHom V\u2081 V\u2082) (g : NormedAddGroupHom V\u2082 V\u2083) :\n    (g.comp f : V\u2081 \u2192 V\u2083) = (g : V\u2082 \u2192 V\u2083) \u2218 (f : V\u2081 \u2192 V\u2082)", "start": [705, 1], "end": [707, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.incl", "code": "@[simps!]\ndef incl (s : AddSubgroup V) : NormedAddGroupHom s V where\n  toFun := (Subtype.val : s \u2192 V)\n  map_add' v w := AddSubgroup.coe_add _ _ _\n  bound' := \u27e81, fun v => by rw [one_mul, AddSubgroup.coe_norm]\u27e9", "start": [717, 1], "end": [722, 64], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_incl", "code": "theorem norm_incl {V' : AddSubgroup V} (x : V') : \u2016incl _ x\u2016 = \u2016x\u2016", "start": [725, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker", "code": "def ker : AddSubgroup V\u2081 :=\n  f.toAddMonoidHom.ker", "start": [736, 1], "end": [739, 23], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mem_ker", "code": "theorem mem_ker (v : V\u2081) : v \u2208 f.ker \u2194 f v = 0", "start": [742, 1], "end": [743, 53], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker.lift", "code": "@[simps]\ndef ker.lift (h : g.comp f = 0) : NormedAddGroupHom V\u2081 g.ker where\n  toFun v := \u27e8f v, by rw [g.mem_ker, \u2190comp_apply g f, h, zero_apply]\u27e9\n  map_add' v w := by simp only [map_add, AddSubmonoid.mk_add_mk]\n  bound' := f.bound'", "start": [746, 1], "end": [752, 21], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker.incl_comp_lift", "code": "@[simp]\ntheorem ker.incl_comp_lift (h : g.comp f = 0) : (incl g.ker).comp (ker.lift f g h) = f", "start": [755, 1], "end": [758, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker_zero", "code": "@[simp]\ntheorem ker_zero : (0 : NormedAddGroupHom V\u2081 V\u2082).ker = \u22a4", "start": [761, 1], "end": [764, 17], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.coe_ker", "code": "theorem coe_ker : (f.ker : Set V\u2081) = (f : V\u2081 \u2192 V\u2082) \u207b\u00b9' {0}", "start": [767, 1], "end": [768, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isClosed_ker", "code": "theorem isClosed_ker {V\u2082 : Type*} [NormedAddCommGroup V\u2082] (f : NormedAddGroupHom V\u2081 V\u2082) :\n    IsClosed (f.ker : Set V\u2081)", "start": [771, 1], "end": [773, 60], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.range", "code": "def range : AddSubgroup V\u2082 :=\n  f.toAddMonoidHom.range", "start": [785, 1], "end": [788, 25], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mem_range", "code": "theorem mem_range (v : V\u2082) : v \u2208 f.range \u2194 \u2203 w, f w = v", "start": [791, 1], "end": [791, 67], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.mem_range_self", "code": "@[simp]\ntheorem mem_range_self (v : V\u2081) : f v \u2208 f.range", "start": [794, 1], "end": [796, 11], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.comp_range", "code": "theorem comp_range : (g.comp f).range = AddSubgroup.map g.toAddMonoidHom f.range", "start": [799, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.incl_range", "code": "theorem incl_range (s : AddSubgroup V\u2081) : (incl s).range = s", "start": [804, 1], "end": [806, 74], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.range_comp_incl_top", "code": "@[simp]\ntheorem range_comp_incl_top : (f.comp (incl (\u22a4 : AddSubgroup V\u2081))).range = f.range", "start": [809, 1], "end": [811, 66], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc", "code": "def NormNoninc (f : NormedAddGroupHom V W) : Prop :=\n  \u2200 v, \u2016f v\u2016 \u2264 \u2016v\u2016", "start": [818, 1], "end": [820, 19], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one", "code": "theorem normNoninc_iff_norm_le_one : f.NormNoninc \u2194 \u2016f\u2016 \u2264 1", "start": [825, 1], "end": [829, 38], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc.zero", "code": "theorem zero : (0 : NormedAddGroupHom V\u2081 V\u2082).NormNoninc", "start": [832, 1], "end": [832, 76], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc.id", "code": "theorem id : (id V).NormNoninc", "start": [835, 1], "end": [835, 51], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc.comp", "code": "theorem comp {g : NormedAddGroupHom V\u2082 V\u2083} {f : NormedAddGroupHom V\u2081 V\u2082} (hg : g.NormNoninc)\n    (hf : f.NormNoninc) : (g.comp f).NormNoninc", "start": [838, 1], "end": [839, 84], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.NormNoninc.neg_iff", "code": "@[simp]\ntheorem neg_iff {f : NormedAddGroupHom V\u2081 V\u2082} : (-f).NormNoninc \u2194 f.NormNoninc", "start": [842, 1], "end": [844, 78], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_eq_of_isometry", "code": "theorem norm_eq_of_isometry {f : NormedAddGroupHom V W} (hf : Isometry f) (v : V) : \u2016f v\u2016 = \u2016v\u2016", "start": [851, 1], "end": [852, 50], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isometry_id", "code": "theorem isometry_id : @Isometry V V _ _ (id V)", "start": [855, 1], "end": [856, 21], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.isometry_comp", "code": "theorem isometry_comp {g : NormedAddGroupHom V\u2082 V\u2083} {f : NormedAddGroupHom V\u2081 V\u2082} (hg : Isometry g)\n    (hf : Isometry f) : Isometry (g.comp f)", "start": [859, 1], "end": [861, 13], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.normNoninc_of_isometry", "code": "theorem normNoninc_of_isometry (hf : Isometry f) : f.NormNoninc", "start": [864, 1], "end": [865, 39], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.equalizer", "code": "def equalizer :=\n  (f - g).ker", "start": [881, 1], "end": [883, 14], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.\u03b9", "code": "def \u03b9 : NormedAddGroupHom (f.equalizer g) V :=\n  incl _", "start": [888, 1], "end": [890, 9], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.comp_\u03b9_eq", "code": "theorem comp_\u03b9_eq : f.comp (\u03b9 f g) = g.comp (\u03b9 f g)", "start": [893, 1], "end": [896, 12], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.lift", "code": "@[simps]\ndef lift (\u03c6 : NormedAddGroupHom V\u2081 V) (h : f.comp \u03c6 = g.comp \u03c6) :\n    NormedAddGroupHom V\u2081 (f.equalizer g)\n    where\n  toFun v :=\n    \u27e8\u03c6 v,\n      show (f - g) (\u03c6 v) = 0 by\n        rw [NormedAddGroupHom.sub_apply, sub_eq_zero, \u2190 comp_apply, h, comp_apply]\u27e9\n  map_add' v\u2081 v\u2082 := by\n    ext\n    simp only [map_add, AddSubgroup.coe_add, Subtype.coe_mk]\n  bound' := by\n    obtain \u27e8C, _C_pos, hC\u27e9 := \u03c6.bound\n    exact \u27e8C, hC\u27e9", "start": [901, 1], "end": [916, 18], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.\u03b9_comp_lift", "code": "@[simp]\ntheorem \u03b9_comp_lift (\u03c6 : NormedAddGroupHom V\u2081 V) (h : f.comp \u03c6 = g.comp \u03c6) :\n    (\u03b9 _ _).comp (lift \u03c6 h) = \u03c6", "start": [919, 1], "end": [923, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.liftEquiv", "code": "@[simps]\ndef liftEquiv :\n    { \u03c6 : NormedAddGroupHom V\u2081 V // f.comp \u03c6 = g.comp \u03c6 } \u2243 NormedAddGroupHom V\u2081 (f.equalizer g)\n    where\n  toFun \u03c6 := lift \u03c6 \u03c6.prop\n  invFun \u03c8 := \u27e8(\u03b9 f g).comp \u03c8, by rw [\u2190 comp_assoc, \u2190 comp_assoc, comp_\u03b9_eq]\u27e9\n  left_inv \u03c6 := by simp\n  right_inv \u03c8 := by\n    ext\n    rfl", "start": [926, 1], "end": [936, 8], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.map", "code": "def map (\u03c6 : NormedAddGroupHom V\u2081 V\u2082) (\u03c8 : NormedAddGroupHom W\u2081 W\u2082) (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6)\n    (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6) : NormedAddGroupHom (f\u2081.equalizer g\u2081) (f\u2082.equalizer g\u2082) :=\n  lift (\u03c6.comp <| \u03b9 _ _) <| by\n    simp only [\u2190 comp_assoc, \u2190 hf, \u2190 hg]\n    simp only [comp_assoc, comp_\u03b9_eq f\u2081 g\u2081]", "start": [939, 1], "end": [946, 44], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.\u03b9_comp_map", "code": "@[simp]\ntheorem \u03b9_comp_map (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6) :\n    (\u03b9 f\u2082 g\u2082).comp (map \u03c6 \u03c8 hf hg) = \u03c6.comp (\u03b9 f\u2081 g\u2081)", "start": [953, 1], "end": [956, 18], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.map_id", "code": "@[simp]\ntheorem map_id : map (f\u2082 := f\u2081) (g\u2082 := g\u2081) (id V\u2081) (id W\u2081) rfl rfl = id (f\u2081.equalizer g\u2081)", "start": [959, 1], "end": [962, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.comm_sq\u2082", "code": "theorem comm_sq\u2082 (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hf' : \u03c8'.comp f\u2082 = f\u2083.comp \u03c6') :\n    (\u03c8'.comp \u03c8).comp f\u2081 = f\u2083.comp (\u03c6'.comp \u03c6)", "start": [965, 1], "end": [967, 53], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.map_comp_map", "code": "theorem map_comp_map (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6)\n    (hf' : \u03c8'.comp f\u2082 = f\u2083.comp \u03c6') (hg' : \u03c8'.comp g\u2082 = g\u2083.comp \u03c6') :\n    (map \u03c6' \u03c8' hf' hg').comp (map \u03c6 \u03c8 hf hg) =\n      map (\u03c6'.comp \u03c6) (\u03c8'.comp \u03c8) (comm_sq\u2082 hf hf') (comm_sq\u2082 hg hg')", "start": [970, 1], "end": [975, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.\u03b9_normNoninc", "code": "theorem \u03b9_normNoninc : (\u03b9 f g).NormNoninc", "start": [978, 1], "end": [978, 62], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.lift_normNoninc", "code": "theorem lift_normNoninc (\u03c6 : NormedAddGroupHom V\u2081 V) (h : f.comp \u03c6 = g.comp \u03c6) (h\u03c6 : \u03c6.NormNoninc) :\n    (lift \u03c6 h).NormNoninc", "start": [981, 1], "end": [984, 5], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.norm_lift_le", "code": "theorem norm_lift_le (\u03c6 : NormedAddGroupHom V\u2081 V) (h : f.comp \u03c6 = g.comp \u03c6) (C : \u211d) (h\u03c6 : \u2016\u03c6\u2016 \u2264 C) :\n    \u2016lift \u03c6 h\u2016 \u2264 C", "start": [987, 1], "end": [990, 5], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.map_normNoninc", "code": "theorem map_normNoninc (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6)\n    (h\u03c6 : \u03c6.NormNoninc) : (map \u03c6 \u03c8 hf hg).NormNoninc", "start": [993, 1], "end": [995, 46], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.Equalizer.norm_map_le", "code": "theorem norm_map_le (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6) (C : \u211d)\n    (h\u03c6 : \u2016\u03c6.comp (\u03b9 f\u2081 g\u2081)\u2016 \u2264 C) : \u2016map \u03c6 \u03c8 hf hg\u2016 \u2264 C", "start": [998, 1], "end": [1000, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Int/Basic.lean", "imports": ["Mathlib/RingTheory/PrincipalIdealDomain.lean", "Mathlib/RingTheory/Coprime/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/EuclideanDomain/Basic.lean", "Mathlib/Data/Nat/Factors.lean"], "premises": [{"full_name": "gcd_eq_nat_gcd", "code": "theorem gcd_eq_nat_gcd (m n : \u2115) : gcd m n = Nat.gcd m n", "start": [76, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_nat_lcm", "code": "theorem lcm_eq_nat_lcm (m n : \u2115) : lcm m n = Nat.lcm m n", "start": [80, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "Int.normalizationMonoid", "code": "instance normalizationMonoid : NormalizationMonoid \u2124 where\n  normUnit a := if 0 \u2264 a then 1 else -1\n  normUnit_zero := if_pos le_rfl\n  normUnit_mul {a b} hna hnb := by\n    cases' hna.lt_or_lt with ha ha <;> cases' hnb.lt_or_lt with hb hb <;>\n      simp [mul_nonneg_iff, ha.le, ha.not_le, hb.le, hb.not_le]\n  normUnit_coe_units u :=\n    (units_eq_one_or u).elim (fun eq => eq.symm \u25b8 if_pos zero_le_one) fun eq =>\n      eq.symm \u25b8 if_neg (not_le_of_gt <| show (-1 : \u2124) < 0 by decide)", "start": [88, 1], "end": [96, 69], "kind": "commanddeclaration"}, {"full_name": "Int.normUnit_eq", "code": "theorem normUnit_eq (z : \u2124) : normUnit z = if 0 \u2264 z then 1 else -1", "start": [99, 1], "end": [99, 74], "kind": "commanddeclaration"}, {"full_name": "Int.normalize_of_nonneg", "code": "theorem normalize_of_nonneg {z : \u2124} (h : 0 \u2264 z) : normalize z = z", "start": [101, 1], "end": [102, 70], "kind": "commanddeclaration"}, {"full_name": "Int.normalize_of_nonpos", "code": "theorem normalize_of_nonpos {z : \u2124} (h : z \u2264 0) : normalize z = -z", "start": [105, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "Int.normalize_coe_nat", "code": "theorem normalize_coe_nat (n : \u2115) : normalize (n : \u2124) = n", "start": [112, 1], "end": [113, 62], "kind": "commanddeclaration"}, {"full_name": "Int.abs_eq_normalize", "code": "theorem abs_eq_normalize (z : \u2124) : |z| = normalize z", "start": [116, 1], "end": [117, 94], "kind": "commanddeclaration"}, {"full_name": "Int.nonneg_of_normalize_eq_self", "code": "theorem nonneg_of_normalize_eq_self {z : \u2124} (hz : normalize z = z) : 0 \u2264 z", "start": [120, 1], "end": [121, 48], "kind": "commanddeclaration"}, {"full_name": "Int.nonneg_iff_normalize_eq_self", "code": "theorem nonneg_iff_normalize_eq_self (z : \u2124) : normalize z = z \u2194 0 \u2264 z", "start": [124, 1], "end": [125, 53], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_associated_of_nonneg", "code": "theorem eq_of_associated_of_nonneg {a b : \u2124} (h : Associated a b) (ha : 0 \u2264 a) (hb : 0 \u2264 b) :\n    a = b", "start": [128, 1], "end": [130, 98], "kind": "commanddeclaration"}, {"full_name": "Int.coe_gcd", "code": "theorem coe_gcd (i j : \u2124) : \u2191(Int.gcd i j) = GCDMonoid.gcd i j", "start": [155, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Int.coe_lcm", "code": "theorem coe_lcm (i j : \u2124) : \u2191(Int.lcm i j) = GCDMonoid.lcm i j", "start": [159, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_gcd", "code": "theorem natAbs_gcd (i j : \u2124) : natAbs (GCDMonoid.gcd i j) = Int.gcd i j", "start": [163, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_lcm", "code": "theorem natAbs_lcm (i j : \u2124) : natAbs (GCDMonoid.lcm i j) = Int.lcm i j", "start": [167, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Int.exists_unit_of_abs", "code": "theorem exists_unit_of_abs (a : \u2124) : \u2203 (u : \u2124) (_ : IsUnit u), (Int.natAbs a : \u2124) = u * a", "start": [173, 1], "end": [179, 33], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_natAbs", "code": "theorem gcd_eq_natAbs {a b : \u2124} : Int.gcd a b = Nat.gcd a.natAbs b.natAbs", "start": [182, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_one_iff_coprime", "code": "theorem gcd_eq_one_iff_coprime {a b : \u2124} : Int.gcd a b = 1 \u2194 IsCoprime a b", "start": [186, 1], "end": [199, 96], "kind": "commanddeclaration"}, {"full_name": "Int.coprime_iff_nat_coprime", "code": "theorem coprime_iff_nat_coprime {a b : \u2124} : IsCoprime a b \u2194 Nat.Coprime a.natAbs b.natAbs", "start": [202, 1], "end": [203, 75], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_ne_one_iff_gcd_mul_right_ne_one", "code": "theorem gcd_ne_one_iff_gcd_mul_right_ne_one {a : \u2124} {m n : \u2115} :\n    a.gcd (m * n) \u2260 1 \u2194 a.gcd m \u2260 1 \u2228 a.gcd n \u2260 1", "start": [206, 1], "end": [209, 89], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_one_of_gcd_mul_right_eq_one_left", "code": "theorem gcd_eq_one_of_gcd_mul_right_eq_one_left {a : \u2124} {m n : \u2115} (h : a.gcd (m * n) = 1) :\n    a.gcd m = 1", "start": [213, 1], "end": [216, 75], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_one_of_gcd_mul_right_eq_one_right", "code": "theorem gcd_eq_one_of_gcd_mul_right_eq_one_right {a : \u2124} {m n : \u2115} (h : a.gcd (m * n) = 1) :\n    a.gcd n = 1", "start": [220, 1], "end": [223, 74], "kind": "commanddeclaration"}, {"full_name": "Int.sq_of_gcd_eq_one", "code": "theorem sq_of_gcd_eq_one {a b c : \u2124} (h : Int.gcd a b = 1) (heq : a * b = c ^ 2) :\n    \u2203 a0 : \u2124, a = a0 ^ 2 \u2228 a = -a0 ^ 2", "start": [226, 1], "end": [236, 11], "kind": "commanddeclaration"}, {"full_name": "Int.sq_of_coprime", "code": "theorem sq_of_coprime {a b c : \u2124} (h : IsCoprime a b) (heq : a * b = c ^ 2) :\n    \u2203 a0 : \u2124, a = a0 ^ 2 \u2228 a = -a0 ^ 2", "start": [239, 1], "end": [241, 54], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_euclideanDomain_gcd", "code": "theorem natAbs_euclideanDomain_gcd (a b : \u2124) :\n    Int.natAbs (EuclideanDomain.gcd a b) = Int.gcd a b", "start": [244, 1], "end": [250, 81], "kind": "commanddeclaration"}, {"full_name": "associatesIntEquivNat", "code": "def associatesIntEquivNat : Associates \u2124 \u2243 \u2115 := by\n  refine' \u27e8fun z => z.out.natAbs, fun n => Associates.mk n, _, _\u27e9\n  \u00b7 refine' fun a =>\n      Quotient.inductionOn a fun a =>\n        Associates.mk_eq_mk_iff_associated.2 <| Associated.symm <| \u27e8normUnit a, _\u27e9\n    simp [Int.abs_eq_normalize]\n  \u00b7 intro n\n    dsimp\n    rw [\u2190 normalize_apply, \u2190 Int.abs_eq_normalize, Int.natAbs_abs, Int.natAbs_ofNat]", "start": [255, 1], "end": [264, 85], "kind": "commanddeclaration"}, {"full_name": "Int.Prime.dvd_mul", "code": "theorem Int.Prime.dvd_mul {m n : \u2124} {p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 m * n) :\n    p \u2223 m.natAbs \u2228 p \u2223 n.natAbs", "start": [267, 1], "end": [269, 62], "kind": "commanddeclaration"}, {"full_name": "Int.Prime.dvd_mul'", "code": "theorem Int.Prime.dvd_mul' {m n : \u2124} {p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 m * n) :\n    (p : \u2124) \u2223 m \u2228 (p : \u2124) \u2223 n", "start": [272, 1], "end": [275, 31], "kind": "commanddeclaration"}, {"full_name": "Int.Prime.dvd_pow", "code": "theorem Int.Prime.dvd_pow {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n    p \u2223 n.natAbs", "start": [278, 1], "end": [281, 28], "kind": "commanddeclaration"}, {"full_name": "Int.Prime.dvd_pow'", "code": "theorem Int.Prime.dvd_pow' {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n    (p : \u2124) \u2223 n", "start": [284, 1], "end": [287, 31], "kind": "commanddeclaration"}, {"full_name": "prime_two_or_dvd_of_dvd_two_mul_pow_self_two", "code": "theorem prime_two_or_dvd_of_dvd_two_mul_pow_self_two {m : \u2124} {p : \u2115} (hp : Nat.Prime p)\n    (h : (p : \u2124) \u2223 2 * m ^ 2) : p = 2 \u2228 p \u2223 Int.natAbs m", "start": [290, 1], "end": [297, 61], "kind": "commanddeclaration"}, {"full_name": "Int.exists_prime_and_dvd", "code": "theorem Int.exists_prime_and_dvd {n : \u2124} (hn : n.natAbs \u2260 1) : \u2203 p, Prime p \u2227 p \u2223 n", "start": [300, 1], "end": [302, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_eq", "code": "theorem Nat.factors_eq {n : \u2115} : normalizedFactors n = n.factors", "start": [307, 1], "end": [317, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_multiset_prod_of_irreducible", "code": "theorem Nat.factors_multiset_prod_of_irreducible {s : Multiset \u2115}\n    (h : \u2200 x : \u2115, x \u2208 s \u2192 Irreducible x) : normalizedFactors s.prod = s", "start": [320, 1], "end": [328, 39], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_int_iff_natAbs_finite", "code": "theorem finite_int_iff_natAbs_finite {a b : \u2124} : Finite a b \u2194 Finite a.natAbs b.natAbs", "start": [333, 1], "end": [334, 66], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_int_iff", "code": "theorem finite_int_iff {a b : \u2124} : Finite a b \u2194 a.natAbs \u2260 1 \u2227 b \u2260 0", "start": [337, 1], "end": [338, 89], "kind": "commanddeclaration"}, {"full_name": "multiplicity.decidableNat", "code": "instance decidableNat : DecidableRel fun a b : \u2115 => (multiplicity a b).Dom := fun _ _ =>\n  decidable_of_iff _ finite_nat_iff.symm", "start": [341, 1], "end": [342, 41], "kind": "commanddeclaration"}, {"full_name": "multiplicity.decidableInt", "code": "instance decidableInt : DecidableRel fun a b : \u2124 => (multiplicity a b).Dom := fun _ _ =>\n  decidable_of_iff _ finite_int_iff.symm", "start": [345, 1], "end": [346, 41], "kind": "commanddeclaration"}, {"full_name": "induction_on_primes", "code": "theorem induction_on_primes {P : \u2115 \u2192 Prop} (h\u2080 : P 0) (h\u2081 : P 1)\n    (h : \u2200 p a : \u2115, p.Prime \u2192 P a \u2192 P (p * a)) (n : \u2115) : P n", "start": [351, 1], "end": [359, 32], "kind": "commanddeclaration"}, {"full_name": "Int.associated_natAbs", "code": "theorem Int.associated_natAbs (k : \u2124) : Associated k k.natAbs", "start": [362, 1], "end": [363, 89], "kind": "commanddeclaration"}, {"full_name": "Int.prime_iff_natAbs_prime", "code": "theorem Int.prime_iff_natAbs_prime {k : \u2124} : Prime k \u2194 Nat.Prime k.natAbs", "start": [366, 1], "end": [367, 73], "kind": "commanddeclaration"}, {"full_name": "Int.associated_iff_natAbs", "code": "theorem Int.associated_iff_natAbs {a b : \u2124} : Associated a b \u2194 a.natAbs = b.natAbs", "start": [370, 1], "end": [373, 26], "kind": "commanddeclaration"}, {"full_name": "Int.associated_iff", "code": "theorem Int.associated_iff {a b : \u2124} : Associated a b \u2194 a = b \u2228 a = -b", "start": [376, 1], "end": [378, 33], "kind": "commanddeclaration"}, {"full_name": "Int.zmultiples_natAbs", "code": "theorem zmultiples_natAbs (a : \u2124) :\n    AddSubgroup.zmultiples (a.natAbs : \u2124) = AddSubgroup.zmultiples a", "start": [383, 1], "end": [386, 89], "kind": "commanddeclaration"}, {"full_name": "Int.span_natAbs", "code": "theorem span_natAbs (a : \u2124) : Ideal.span ({(a.natAbs : \u2124)} : Set \u2124) = Ideal.span {a}", "start": [389, 1], "end": [391, 35], "kind": "commanddeclaration"}, {"full_name": "Int.eq_pow_of_mul_eq_pow_bit1_left", "code": "theorem eq_pow_of_mul_eq_pow_bit1_left {a b c : \u2124} (hab : IsCoprime a b) {k : \u2115}\n    (h : a * b = c ^ bit1 k) : \u2203 d, a = d ^ bit1 k", "start": [397, 1], "end": [402, 44], "kind": "commanddeclaration"}, {"full_name": "Int.eq_pow_of_mul_eq_pow_bit1_right", "code": "theorem eq_pow_of_mul_eq_pow_bit1_right {a b c : \u2124} (hab : IsCoprime a b) {k : \u2115}\n    (h : a * b = c ^ bit1 k) : \u2203 d, b = d ^ bit1 k", "start": [405, 1], "end": [407, 67], "kind": "commanddeclaration"}, {"full_name": "Int.eq_pow_of_mul_eq_pow_bit1", "code": "theorem eq_pow_of_mul_eq_pow_bit1 {a b c : \u2124} (hab : IsCoprime a b) {k : \u2115}\n    (h : a * b = c ^ bit1 k) : (\u2203 d, a = d ^ bit1 k) \u2227 \u2203 e, b = e ^ bit1 k", "start": [410, 1], "end": [412, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Divisors.lean", "imports": ["Mathlib/Data/Nat/Factors.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Data/Nat/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.divisors", "code": "def divisors : Finset \u2115 :=\n  Finset.filter (fun x : \u2115 => x \u2223 n) (Finset.Ico 1 (n + 1))", "start": [40, 1], "end": [42, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors", "code": "def properDivisors : Finset \u2115 :=\n  Finset.filter (fun x : \u2115 => x \u2223 n) (Finset.Ico 1 n)", "start": [45, 1], "end": [48, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.divisorsAntidiagonal", "code": "def divisorsAntidiagonal : Finset (\u2115 \u00d7 \u2115) :=\n  Finset.filter (fun x => x.fst * x.snd = n) (Ico 1 (n + 1) \u00d7\u02e2 Ico 1 (n + 1))", "start": [51, 1], "end": [54, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_dvd_eq_divisors", "code": "@[simp]\ntheorem filter_dvd_eq_divisors (h : n \u2260 0) : (Finset.range n.succ).filter (\u00b7 \u2223 n) = n.divisors", "start": [59, 1], "end": [63, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_dvd_eq_properDivisors", "code": "@[simp]\ntheorem filter_dvd_eq_properDivisors (h : n \u2260 0) :\n    (Finset.range n).filter (\u00b7 \u2223 n) = n.properDivisors", "start": [66, 1], "end": [71, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors.not_self_mem", "code": "theorem properDivisors.not_self_mem : \u00acn \u2208 properDivisors n", "start": [74, 1], "end": [74, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_properDivisors", "code": "@[simp]\ntheorem mem_properDivisors {m : \u2115} : n \u2208 properDivisors m \u2194 n \u2223 m \u2227 n < m", "start": [77, 1], "end": [80, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.insert_self_properDivisors", "code": "theorem insert_self_properDivisors (h : n \u2260 0) : insert n (properDivisors n) = divisors n", "start": [83, 1], "end": [85, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.cons_self_properDivisors", "code": "theorem cons_self_properDivisors (h : n \u2260 0) :\n    cons n (properDivisors n) properDivisors.not_self_mem = divisors n", "start": [88, 1], "end": [90, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_divisors", "code": "@[simp]\ntheorem mem_divisors {m : \u2115} : n \u2208 divisors m \u2194 n \u2223 m \u2227 m \u2260 0", "start": [93, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.one_mem_divisors", "code": "theorem one_mem_divisors : 1 \u2208 divisors n \u2194 n \u2260 0", "start": [101, 1], "end": [101, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_divisors_self", "code": "theorem mem_divisors_self (n : \u2115) (h : n \u2260 0) : n \u2208 n.divisors", "start": [104, 1], "end": [105, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mem_divisors", "code": "theorem dvd_of_mem_divisors {m : \u2115} (h : n \u2208 divisors m) : n \u2223 m", "start": [108, 1], "end": [111, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_divisorsAntidiagonal", "code": "@[simp]\ntheorem mem_divisorsAntidiagonal {x : \u2115 \u00d7 \u2115} :\n    x \u2208 divisorsAntidiagonal n \u2194 x.fst * x.snd = n \u2227 n \u2260 0", "start": [114, 1], "end": [129, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.divisor_le", "code": "theorem divisor_le {m : \u2115} : n \u2208 divisors m \u2192 n \u2264 m", "start": [135, 1], "end": [139, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.divisors_subset_of_dvd", "code": "theorem divisors_subset_of_dvd {m : \u2115} (hzero : n \u2260 0) (h : m \u2223 n) : divisors m \u2286 divisors n", "start": [142, 1], "end": [143, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.divisors_subset_properDivisors", "code": "theorem divisors_subset_properDivisors {m : \u2115} (hzero : n \u2260 0) (h : m \u2223 n) (hdiff : m \u2260 n) :\n    divisors m \u2286 properDivisors n", "start": [146, 1], "end": [154, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.divisors_filter_dvd_of_dvd", "code": "lemma divisors_filter_dvd_of_dvd {n m : \u2115} (hn : n \u2260 0) (hm : m \u2223 n) :\n    (n.divisors.filter (\u00b7 \u2223 m)) = m.divisors := by\n  ext k\n  simp_rw [mem_filter, mem_divisors]\n  exact \u27e8fun \u27e8_, hkm\u27e9 \u21a6 \u27e8hkm, ne_zero_of_dvd_ne_zero hn hm\u27e9, fun \u27e8hk, _\u27e9 \u21a6 \u27e8\u27e8hk.trans hm, hn\u27e9, hk\u27e9\u27e9", "start": [157, 1], "end": [161, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.divisors_zero", "code": "@[simp]\ntheorem divisors_zero : divisors 0 = \u2205", "start": [163, 1], "end": [166, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors_zero", "code": "@[simp]\ntheorem properDivisors_zero : properDivisors 0 = \u2205", "start": [169, 1], "end": [172, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors_subset_divisors", "code": "theorem properDivisors_subset_divisors : properDivisors n \u2286 divisors n", "start": [175, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.divisors_one", "code": "@[simp]\ntheorem divisors_one : divisors 1 = {1}", "start": [179, 1], "end": [182, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors_one", "code": "@[simp]\ntheorem properDivisors_one : properDivisors 1 = \u2205", "start": [185, 1], "end": [186, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_mem_divisors", "code": "theorem pos_of_mem_divisors {m : \u2115} (h : m \u2208 n.divisors) : 0 < m", "start": [189, 1], "end": [193, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_mem_properDivisors", "code": "theorem pos_of_mem_properDivisors {m : \u2115} (h : m \u2208 n.properDivisors) : 0 < m", "start": [196, 1], "end": [197, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.one_mem_properDivisors_iff_one_lt", "code": "theorem one_mem_properDivisors_iff_one_lt : 1 \u2208 n.properDivisors \u2194 1 < n", "start": [200, 1], "end": [201, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.divisorsAntidiagonal_zero", "code": "@[simp]\ntheorem divisorsAntidiagonal_zero : divisorsAntidiagonal 0 = \u2205", "start": [204, 1], "end": [207, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.divisorsAntidiagonal_one", "code": "@[simp]\ntheorem divisorsAntidiagonal_one : divisorsAntidiagonal 1 = {(1, 1)}", "start": [210, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.swap_mem_divisorsAntidiagonal", "code": "theorem swap_mem_divisorsAntidiagonal {x : \u2115 \u00d7 \u2115} :\n    x.swap \u2208 divisorsAntidiagonal n \u2194 x \u2208 divisorsAntidiagonal n", "start": [222, 1], "end": [224, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.swap_mem_divisorsAntidiagonal_aux", "code": "@[simp]\ntheorem swap_mem_divisorsAntidiagonal_aux {x : \u2115 \u00d7 \u2115} :\n    x.snd * x.fst = n \u2227 \u00acn = 0 \u2194 x \u2208 divisorsAntidiagonal n", "start": [228, 1], "end": [231, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.fst_mem_divisors_of_mem_antidiagonal", "code": "theorem fst_mem_divisors_of_mem_antidiagonal {x : \u2115 \u00d7 \u2115} (h : x \u2208 divisorsAntidiagonal n) :\n    x.fst \u2208 divisors n", "start": [233, 1], "end": [236, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.snd_mem_divisors_of_mem_antidiagonal", "code": "theorem snd_mem_divisors_of_mem_antidiagonal {x : \u2115 \u00d7 \u2115} (h : x \u2208 divisorsAntidiagonal n) :\n    x.snd \u2208 divisors n", "start": [239, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.map_swap_divisorsAntidiagonal", "code": "@[simp]\ntheorem map_swap_divisorsAntidiagonal :\n    (divisorsAntidiagonal n).map (Equiv.prodComm _ _).toEmbedding = divisorsAntidiagonal n", "start": [245, 1], "end": [251, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.image_fst_divisorsAntidiagonal", "code": "@[simp]\ntheorem image_fst_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.fst = divisors n", "start": [254, 1], "end": [257, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.image_snd_divisorsAntidiagonal", "code": "@[simp]\ntheorem image_snd_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.snd = divisors n", "start": [260, 1], "end": [263, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.map_div_right_divisors", "code": "theorem map_div_right_divisors :\n    n.divisors.map \u27e8fun d => (d, n / d), fun p\u2081 p\u2082 => congr_arg Prod.fst\u27e9 =\n      n.divisorsAntidiagonal", "start": [266, 1], "end": [277, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.map_div_left_divisors", "code": "theorem map_div_left_divisors :\n    n.divisors.map \u27e8fun d => (n / d, d), fun p\u2081 p\u2082 => congr_arg Prod.snd\u27e9 =\n      n.divisorsAntidiagonal", "start": [280, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_divisors_eq_sum_properDivisors_add_self", "code": "theorem sum_divisors_eq_sum_properDivisors_add_self :\n    \u2211 i in divisors n, i = (\u2211 i in properDivisors n, i) + n", "start": [288, 1], "end": [292, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.Perfect", "code": "def Perfect (n : \u2115) : Prop :=\n  \u2211 i in properDivisors n, i = n \u2227 0 < n", "start": [295, 1], "end": [298, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.perfect_iff_sum_properDivisors", "code": "theorem perfect_iff_sum_properDivisors (h : 0 < n) : Perfect n \u2194 \u2211 i in properDivisors n, i = n", "start": [301, 1], "end": [302, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.perfect_iff_sum_divisors_eq_two_mul", "code": "theorem perfect_iff_sum_divisors_eq_two_mul (h : 0 < n) :\n    Perfect n \u2194 \u2211 i in divisors n, i = 2 * n", "start": [305, 1], "end": [310, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_divisors_prime_pow", "code": "theorem mem_divisors_prime_pow {p : \u2115} (pp : p.Prime) (k : \u2115) {x : \u2115} :\n    x \u2208 divisors (p ^ k) \u2194 \u2203 (j : \u2115) (_ : j \u2264 k), x = p ^ j", "start": [313, 1], "end": [316, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.divisors", "code": "theorem Prime.divisors {p : \u2115} (pp : p.Prime) : divisors p = {1, p}", "start": [319, 1], "end": [321, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.properDivisors", "code": "theorem Prime.properDivisors {p : \u2115} (pp : p.Prime) : properDivisors p = {1}", "start": [324, 1], "end": [326, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.divisors_prime_pow", "code": "theorem divisors_prime_pow {p : \u2115} (pp : p.Prime) (k : \u2115) :\n    divisors (p ^ k) = (Finset.range (k + 1)).map \u27e8Nat.pow p, pow_right_injective pp.two_le\u27e9", "start": [330, 1], "end": [340, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_properDivisors_of_subset_of_sum_eq_sum", "code": "theorem eq_properDivisors_of_subset_of_sum_eq_sum {s : Finset \u2115} (hsub : s \u2286 n.properDivisors) :\n    ((\u2211 x in s, x) = \u2211 x in n.properDivisors, x) \u2192 s = n.properDivisors", "start": [343, 1], "end": [361, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_properDivisors_dvd", "code": "theorem sum_properDivisors_dvd (h : (\u2211 x in n.properDivisors, x) \u2223 n) :\n    \u2211 x in n.properDivisors, x = 1 \u2228 \u2211 x in n.properDivisors, x = n", "start": [364, 1], "end": [378, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.prod_properDivisors", "code": "@[to_additive (attr := simp)]\ntheorem Prime.prod_properDivisors {\u03b1 : Type*} [CommMonoid \u03b1] {p : \u2115} {f : \u2115 \u2192 \u03b1} (h : p.Prime) :\n    \u220f x in p.properDivisors, f x = f 1", "start": [381, 1], "end": [383, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.prod_divisors", "code": "@[to_additive (attr := simp)]\ntheorem Prime.prod_divisors {\u03b1 : Type*} [CommMonoid \u03b1] {p : \u2115} {f : \u2115 \u2192 \u03b1} (h : p.Prime) :\n    \u220f x in p.divisors, f x = f p * f 1", "start": [387, 1], "end": [390, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors_eq_singleton_one_iff_prime", "code": "theorem properDivisors_eq_singleton_one_iff_prime : n.properDivisors = {1} \u2194 n.Prime", "start": [394, 1], "end": [408, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_properDivisors_eq_one_iff_prime", "code": "theorem sum_properDivisors_eq_one_iff_prime : \u2211 x in n.properDivisors, x = 1 \u2194 n.Prime", "start": [411, 1], "end": [423, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_properDivisors_prime_pow", "code": "theorem mem_properDivisors_prime_pow {p : \u2115} (pp : p.Prime) (k : \u2115) {x : \u2115} :\n    x \u2208 properDivisors (p ^ k) \u2194 \u2203 (j : \u2115) (_ : j < k), x = p ^ j", "start": [426, 1], "end": [438, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.properDivisors_prime_pow", "code": "theorem properDivisors_prime_pow {p : \u2115} (pp : p.Prime) (k : \u2115) :\n    properDivisors (p ^ k) = (Finset.range k).map \u27e8Nat.pow p, pow_right_injective pp.two_le\u27e9", "start": [442, 1], "end": [452, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_properDivisors_prime_pow", "code": "@[to_additive (attr := simp)]\ntheorem prod_properDivisors_prime_pow {\u03b1 : Type*} [CommMonoid \u03b1] {k p : \u2115} {f : \u2115 \u2192 \u03b1}\n    (h : p.Prime) : (\u220f x in (p ^ k).properDivisors, f x) = \u220f x in range k, f (p ^ x)", "start": [455, 1], "end": [458, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_divisors_prime_pow", "code": "@[to_additive (attr := simp) sum_divisors_prime_pow]\ntheorem prod_divisors_prime_pow {\u03b1 : Type*} [CommMonoid \u03b1] {k p : \u2115} {f : \u2115 \u2192 \u03b1} (h : p.Prime) :\n    (\u220f x in (p ^ k).divisors, f x) = \u220f x in range (k + 1), f (p ^ x)", "start": [462, 1], "end": [465, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_divisorsAntidiagonal", "code": "@[to_additive]\ntheorem prod_divisorsAntidiagonal {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) {n : \u2115} :\n    \u220f i in n.divisorsAntidiagonal, f i.1 i.2 = \u220f i in n.divisors, f i (n / i)", "start": [469, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_divisorsAntidiagonal'", "code": "@[to_additive]\ntheorem prod_divisorsAntidiagonal' {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) {n : \u2115} :\n    \u220f i in n.divisorsAntidiagonal, f i.1 i.2 = \u220f i in n.divisors, f (n / i) i", "start": [477, 1], "end": [481, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_divisors_eq_to_filter_divisors_prime", "code": "theorem prime_divisors_eq_to_filter_divisors_prime (n : \u2115) :\n    n.factors.toFinset = (divisors n).filter Prime", "start": [485, 1], "end": [491, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_divisors_filter_dvd_of_dvd", "code": "lemma prime_divisors_filter_dvd_of_dvd {m n : \u2115} (hn : n \u2260 0) (hmn : m \u2223 n) :\n    n.factors.toFinset.filter (\u00b7 \u2223 m) = m.factors.toFinset := by\n  simp_rw [prime_divisors_eq_to_filter_divisors_prime, filter_comm,\n    divisors_filter_dvd_of_dvd hn hmn]", "start": [494, 1], "end": [497, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.image_div_divisors_eq_divisors", "code": "@[simp]\ntheorem image_div_divisors_eq_divisors (n : \u2115) :\n    image (fun x : \u2115 => n / x) n.divisors = n.divisors", "start": [499, 1], "end": [514, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_div_divisors", "code": "@[to_additive sum_div_divisors]\ntheorem prod_div_divisors {\u03b1 : Type*} [CommMonoid \u03b1] (n : \u2115) (f : \u2115 \u2192 \u03b1) :\n    (\u220f d in n.divisors, f (n / d)) = n.divisors.prod f", "start": [520, 1], "end": [528, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/MaxPowDiv.lean", "imports": ["Mathlib/Tactic/Common.lean", "Mathlib/Data/Nat/Pow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.maxPowDiv", "code": "def maxPowDiv (p n : \u2115) : \u2115 :=\n  go 0 p n\nwhere go (k p n : \u2115) : \u2115 :=\n  if h : 1 < p \u2227 0 < n \u2227 n % p = 0 then\n    have : n / p < n := by apply Nat.div_lt_self <;> aesop\n    go (k+1) p (n / p)\n  else\n    k", "start": [26, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.go_eq", "code": "theorem go_eq {k p n : \u2115} :\n    go k p n = if 1 < p \u2227 0 < n \u2227 n % p = 0 then go (k+1) p (n / p) else k", "start": [45, 1], "end": [49, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.go_succ", "code": "theorem go_succ {k p n : \u2115} : go (k+1) p n = go k p n + 1", "start": [51, 1], "end": [58, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.zero_base", "code": "@[simp]\ntheorem zero_base {n : \u2115} : maxPowDiv 0 n = 0", "start": [60, 1], "end": [64, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.zero", "code": "@[simp]\ntheorem zero {p : \u2115} : maxPowDiv p 0 = 0", "start": [66, 1], "end": [70, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.base_mul_eq_succ", "code": "theorem base_mul_eq_succ {p n : \u2115} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv (p*n) = p.maxPowDiv n + 1", "start": [72, 1], "end": [79, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.base_pow_mul", "code": "theorem base_pow_mul {p n exp : \u2115} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv (p ^ exp * n) = p.maxPowDiv n + exp", "start": [81, 1], "end": [88, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.pow_dvd", "code": "theorem pow_dvd (p n : \u2115) : p ^ (p.maxPowDiv n) \u2223 n", "start": [90, 1], "end": [102, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.maxPowDiv.le_of_dvd", "code": "theorem le_of_dvd {p n pow : \u2115} (hp : 1 < p) (hn : 0 < n) (h : p ^ pow \u2223 n) :\n    pow \u2264 p.maxPowDiv n", "start": [104, 1], "end": [112, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/Hom.lean", "imports": ["Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.hom", "code": "@[simps]\ndef hom : C\u1d52\u1d56 \u00d7 C \u2964 Type v where\n  obj p := unop p.1 \u27f6 p.2\n  map f h := f.1.unop \u226b h \u226b f.2", "start": [26, 1], "end": [31, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/Currying.lean", "imports": ["Mathlib/CategoryTheory/Products/Bifunctor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.uncurry", "code": "@[simps]\ndef uncurry : (C \u2964 D \u2964 E) \u2964 C \u00d7 D \u2964 E\n    where\n  obj F :=\n    { obj := fun X => (F.obj X.1).obj X.2\n      map := fun {X} {Y} f => (F.map f.1).app X.2 \u226b (F.obj Y.1).map f.2\n      map_comp := fun f g => by\n        simp only [prod_comp_fst, prod_comp_snd, Functor.map_comp, NatTrans.comp_app,\n          Category.assoc]\n        slice_lhs 2 3 => rw [\u2190 NatTrans.naturality]\n        rw [Category.assoc] }\n  map T :=\n    { app := fun X => (T.app X.1).app X.2\n      naturality := fun X Y f => by\n        simp only [prod_comp_fst, prod_comp_snd, Category.comp_id, Category.assoc, Functor.map_id,\n          Functor.map_comp, NatTrans.id_app, NatTrans.comp_app]\n        slice_lhs 2 3 => rw [NatTrans.naturality]\n        slice_lhs 1 2 => rw [\u2190 NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app]\n        rw [Category.assoc] }", "start": [27, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.curryObj", "code": "def curryObj (F : C \u00d7 D \u2964 E) : C \u2964 D \u2964 E\n    where\n  obj X :=\n    { obj := fun Y => F.obj (X, Y)\n      map := fun g => F.map (\ud835\udfd9 X, g)\n      map_id := fun Y => by simp only [F.map_id]; rw [\u2190prod_id]; exact F.map_id \u27e8X,Y\u27e9\n      map_comp := fun f g => by simp [\u2190F.map_comp]}\n  map f :=\n    { app := fun Y => F.map (f, \ud835\udfd9 Y)\n      naturality := fun {Y} {Y'} g => by simp [\u2190F.map_comp] }\n  map_id := fun X => by ext Y; exact F.map_id _\n  map_comp := fun f g => by ext Y; dsimp; simp [\u2190F.map_comp]", "start": [50, 1], "end": [63, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.curry", "code": "@[simps! obj_obj_obj obj_obj_map obj_map_app map_app_app]\ndef curry : (C \u00d7 D \u2964 E) \u2964 C \u2964 D \u2964 E where\n  obj F := curryObj F\n  map T :=\n    { app := fun X =>\n        { app := fun Y => T.app (X, Y)\n          naturality := fun Y Y' g => by\n            dsimp [curryObj]\n            rw [NatTrans.naturality] }\n      naturality := fun X X' f => by\n        ext; dsimp [curryObj]\n        rw [NatTrans.naturality] }", "start": [66, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.currying", "code": "@[simps!]\ndef currying : C \u2964 D \u2964 E \u224c C \u00d7 D \u2964 E :=\n  Equivalence.mk uncurry curry\n    (NatIso.ofComponents fun F =>\n        NatIso.ofComponents fun X => NatIso.ofComponents fun Y => Iso.refl _)\n    (NatIso.ofComponents fun F => NatIso.ofComponents (fun X => eqToIso (by simp))\n      (by intros X Y f; cases X; cases Y; cases f; dsimp at *; rw [\u2190F.map_comp]; simp))", "start": [83, 1], "end": [91, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.flipIsoCurrySwapUncurry", "code": "@[simps!]\ndef flipIsoCurrySwapUncurry (F : C \u2964 D \u2964 E) : F.flip \u2245 curry.obj (Prod.swap _ _ \u22d9 uncurry.obj F) :=\n  NatIso.ofComponents fun d => NatIso.ofComponents fun c => Iso.refl _", "start": [94, 1], "end": [97, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uncurryObjFlip", "code": "@[simps!]\ndef uncurryObjFlip (F : C \u2964 D \u2964 E) : uncurry.obj F.flip \u2245 Prod.swap _ _ \u22d9 uncurry.obj F :=\n  NatIso.ofComponents fun p => Iso.refl _", "start": [100, 1], "end": [104, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskeringRight\u2082", "code": "@[simps!]\ndef whiskeringRight\u2082 : (C \u2964 D \u2964 E) \u2964 (B \u2964 C) \u2964 (B \u2964 D) \u2964 B \u2964 E :=\n  uncurry \u22d9\n    whiskeringRight _ _ _ \u22d9 (whiskeringLeft _ _ _).obj (prodFunctorToFunctorProd _ _ _) \u22d9 curry", "start": [109, 1], "end": [115, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/EpiMono.lean", "imports": ["Mathlib/CategoryTheory/LiftingProperties/Adjunction.lean", "Mathlib/CategoryTheory/EpiMono.lean", "Mathlib/CategoryTheory/Limits/Shapes/StrongEpi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.PreservesMonomorphisms", "code": "class PreservesMonomorphisms (F : C \u2964 D) : Prop where\n  \n  preserves : \u2200 {X Y : C} (f : X \u27f6 Y) [Mono f], Mono (F.map f)", "start": [29, 1], "end": [32, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_mono", "code": "instance map_mono (F : C \u2964 D) [PreservesMonomorphisms F] {X Y : C} (f : X \u27f6 Y) [Mono f] :\n    Mono (F.map f) :=\n  PreservesMonomorphisms.preserves f", "start": [35, 1], "end": [37, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesEpimorphisms", "code": "class PreservesEpimorphisms (F : C \u2964 D) : Prop where\n  \n  preserves : \u2200 {X Y : C} (f : X \u27f6 Y) [Epi f], Epi (F.map f)", "start": [40, 1], "end": [43, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_epi", "code": "instance map_epi (F : C \u2964 D) [PreservesEpimorphisms F] {X Y : C} (f : X \u27f6 Y) [Epi f] :\n    Epi (F.map f) :=\n  PreservesEpimorphisms.preserves f", "start": [46, 1], "end": [48, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ReflectsMonomorphisms", "code": "class ReflectsMonomorphisms (F : C \u2964 D) : Prop where\n   \n  reflects : \u2200 {X Y : C} (f : X \u27f6 Y), Mono (F.map f) \u2192 Mono f", "start": [51, 1], "end": [56, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mono_of_mono_map", "code": "theorem mono_of_mono_map (F : C \u2964 D) [ReflectsMonomorphisms F] {X Y : C} {f : X \u27f6 Y}\n    (h : Mono (F.map f)) : Mono f", "start": [59, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ReflectsEpimorphisms", "code": "class ReflectsEpimorphisms (F : C \u2964 D) : Prop where\n  \n  reflects : \u2200 {X Y : C} (f : X \u27f6 Y), Epi (F.map f) \u2192 Epi f", "start": [64, 1], "end": [69, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.epi_of_epi_map", "code": "theorem epi_of_epi_map (F : C \u2964 D) [ReflectsEpimorphisms F] {X Y : C} {f : X \u27f6 Y}\n    (h : Epi (F.map f)) : Epi f", "start": [72, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms_comp", "code": "instance preservesMonomorphisms_comp (F : C \u2964 D) (G : D \u2964 E) [PreservesMonomorphisms F]\n    [PreservesMonomorphisms G] : PreservesMonomorphisms (F \u22d9 G) where\n  preserves f h := by\n    rw [comp_map]\n    exact inferInstance", "start": [77, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphisms_comp", "code": "instance preservesEpimorphisms_comp (F : C \u2964 D) (G : D \u2964 E) [PreservesEpimorphisms F]\n    [PreservesEpimorphisms G] : PreservesEpimorphisms (F \u22d9 G) where\n  preserves f h := by\n    rw [comp_map]\n    exact inferInstance", "start": [84, 1], "end": [88, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsMonomorphisms_comp", "code": "instance reflectsMonomorphisms_comp (F : C \u2964 D) (G : D \u2964 E) [ReflectsMonomorphisms F]\n    [ReflectsMonomorphisms G] : ReflectsMonomorphisms (F \u22d9 G) where\n  reflects _ h := F.mono_of_mono_map (G.mono_of_mono_map h)", "start": [91, 1], "end": [93, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsEpimorphisms_comp", "code": "instance reflectsEpimorphisms_comp (F : C \u2964 D) (G : D \u2964 E) [ReflectsEpimorphisms F]\n    [ReflectsEpimorphisms G] : ReflectsEpimorphisms (F \u22d9 G) where\n  reflects _ h := F.epi_of_epi_map (G.epi_of_epi_map h)", "start": [96, 1], "end": [98, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphisms_of_preserves_of_reflects", "code": "theorem preservesEpimorphisms_of_preserves_of_reflects (F : C \u2964 D) (G : D \u2964 E)\n    [PreservesEpimorphisms (F \u22d9 G)] [ReflectsEpimorphisms G] : PreservesEpimorphisms F", "start": [101, 1], "end": [103, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms_of_preserves_of_reflects", "code": "theorem preservesMonomorphisms_of_preserves_of_reflects (F : C \u2964 D) (G : D \u2964 E)\n    [PreservesMonomorphisms (F \u22d9 G)] [ReflectsMonomorphisms G] : PreservesMonomorphisms F", "start": [106, 1], "end": [108, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsEpimorphisms_of_preserves_of_reflects", "code": "theorem reflectsEpimorphisms_of_preserves_of_reflects (F : C \u2964 D) (G : D \u2964 E)\n    [PreservesEpimorphisms G] [ReflectsEpimorphisms (F \u22d9 G)] : ReflectsEpimorphisms F", "start": [111, 1], "end": [113, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsMonomorphisms_of_preserves_of_reflects", "code": "theorem reflectsMonomorphisms_of_preserves_of_reflects (F : C \u2964 D) (G : D \u2964 E)\n    [PreservesMonomorphisms G] [ReflectsMonomorphisms (F \u22d9 G)] : ReflectsMonomorphisms F", "start": [116, 1], "end": [118, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms.of_iso", "code": "theorem preservesMonomorphisms.of_iso {F G : C \u2964 D} [PreservesMonomorphisms F] (\u03b1 : F \u2245 G) :\n    PreservesMonomorphisms G", "start": [121, 1], "end": [126, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms.iso_iff", "code": "theorem preservesMonomorphisms.iso_iff {F G : C \u2964 D} (\u03b1 : F \u2245 G) :\n    PreservesMonomorphisms F \u2194 PreservesMonomorphisms G", "start": [129, 1], "end": [131, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphisms.of_iso", "code": "theorem preservesEpimorphisms.of_iso {F G : C \u2964 D} [PreservesEpimorphisms F] (\u03b1 : F \u2245 G) :\n    PreservesEpimorphisms G", "start": [134, 1], "end": [139, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphisms.iso_iff", "code": "theorem preservesEpimorphisms.iso_iff {F G : C \u2964 D} (\u03b1 : F \u2245 G) :\n    PreservesEpimorphisms F \u2194 PreservesEpimorphisms G", "start": [142, 1], "end": [144, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsMonomorphisms.of_iso", "code": "theorem reflectsMonomorphisms.of_iso {F G : C \u2964 D} [ReflectsMonomorphisms F] (\u03b1 : F \u2245 G) :\n    ReflectsMonomorphisms G", "start": [147, 1], "end": [153, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsMonomorphisms.iso_iff", "code": "theorem reflectsMonomorphisms.iso_iff {F G : C \u2964 D} (\u03b1 : F \u2245 G) :\n    ReflectsMonomorphisms F \u2194 ReflectsMonomorphisms G", "start": [156, 1], "end": [158, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsEpimorphisms.of_iso", "code": "theorem reflectsEpimorphisms.of_iso {F G : C \u2964 D} [ReflectsEpimorphisms F] (\u03b1 : F \u2245 G) :\n    ReflectsEpimorphisms G", "start": [161, 1], "end": [167, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsEpimorphisms.iso_iff", "code": "theorem reflectsEpimorphisms.iso_iff {F G : C \u2964 D} (\u03b1 : F \u2245 G) :\n    ReflectsEpimorphisms F \u2194 ReflectsEpimorphisms G", "start": [170, 1], "end": [172, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphsisms_of_adjunction", "code": "theorem preservesEpimorphsisms_of_adjunction {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    PreservesEpimorphisms F", "start": [175, 1], "end": [182, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesEpimorphisms_of_isLeftAdjoint", "code": "instance (priority := 100) preservesEpimorphisms_of_isLeftAdjoint (F : C \u2964 D) [IsLeftAdjoint F] :\n    PreservesEpimorphisms F :=\n  preservesEpimorphsisms_of_adjunction (Adjunction.ofLeftAdjoint F)", "start": [185, 1], "end": [187, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms_of_adjunction", "code": "theorem preservesMonomorphisms_of_adjunction {F : C \u2964 D} {G : D \u2964 C} (adj : F \u22a3 G) :\n    PreservesMonomorphisms G", "start": [190, 1], "end": [197, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesMonomorphisms_of_isRightAdjoint", "code": "instance (priority := 100) preservesMonomorphisms_of_isRightAdjoint (F : C \u2964 D) [IsRightAdjoint F] :\n    PreservesMonomorphisms F :=\n  preservesMonomorphisms_of_adjunction (Adjunction.ofRightAdjoint F)", "start": [200, 1], "end": [202, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsMonomorphisms_of_faithful", "code": "instance (priority := 100) reflectsMonomorphisms_of_faithful (F : C \u2964 D) [Faithful F] :\n    ReflectsMonomorphisms F where\n  reflects {X} {Y} f hf :=\n    \u27e8fun {Z} g h hgh =>\n      F.map_injective ((cancel_mono (F.map f)).1 (by rw [\u2190 F.map_comp, hgh, F.map_comp]))\u27e9", "start": [205, 1], "end": [209, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reflectsEpimorphisms_of_faithful", "code": "instance (priority := 100) reflectsEpimorphisms_of_faithful (F : C \u2964 D) [Faithful F] :\n    ReflectsEpimorphisms F where\n  reflects {X} {Y} f hf :=\n    \u27e8fun {Z} g h hgh =>\n      F.map_injective ((cancel_epi (F.map f)).1 (by rw [\u2190 F.map_comp, hgh, F.map_comp]))\u27e9", "start": [212, 1], "end": [216, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.splitEpiEquiv", "code": "def splitEpiEquiv [Full F] [Faithful F] : SplitEpi f \u2243 SplitEpi (F.map f)\n    where\n  toFun f := f.map F\n  invFun s := by\n    refine' \u27e8F.preimage s.section_, _\u27e9\n    apply F.map_injective\n    simp only [map_comp, image_preimage, map_id]\n    apply SplitEpi.id\n  left_inv := by aesop_cat\n  right_inv := by\n      simp only [Function.RightInverse,Function.LeftInverse]\n      intro x\n      simp only [SplitEpi.map, preimage]\n      aesop_cat", "start": [223, 1], "end": [237, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isSplitEpi_iff", "code": "@[simp]\ntheorem isSplitEpi_iff [Full F] [Faithful F] : IsSplitEpi (F.map f) \u2194 IsSplitEpi f", "start": [240, 1], "end": [246, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.splitMonoEquiv", "code": "def splitMonoEquiv [Full F] [Faithful F] : SplitMono f \u2243 SplitMono (F.map f)\n    where\n  toFun f := f.map F\n  invFun s := by\n    refine' \u27e8F.preimage s.retraction, _\u27e9\n    apply F.map_injective\n    simp only [map_comp, image_preimage, map_id]\n    apply SplitMono.id\n  left_inv := by aesop_cat\n  right_inv := by\n    simp only [Function.RightInverse, Function.LeftInverse]\n    intro x\n    simp only [SplitMono.map,preimage]\n    aesop_cat", "start": [249, 1], "end": [263, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isSplitMono_iff", "code": "@[simp]\ntheorem isSplitMono_iff [Full F] [Faithful F] : IsSplitMono (F.map f) \u2194 IsSplitMono f", "start": [266, 1], "end": [272, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.epi_map_iff_epi", "code": "@[simp]\ntheorem epi_map_iff_epi [hF\u2081 : PreservesEpimorphisms F] [hF\u2082 : ReflectsEpimorphisms F] :\n    Epi (F.map f) \u2194 Epi f", "start": [275, 1], "end": [281, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mono_map_iff_mono", "code": "@[simp]\ntheorem mono_map_iff_mono [hF\u2081 : PreservesMonomorphisms F] [hF\u2082 : ReflectsMonomorphisms F] :\n    Mono (F.map f) \u2194 Mono f", "start": [284, 1], "end": [290, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.splitEpiCategoryImpOfIsEquivalence", "code": "theorem splitEpiCategoryImpOfIsEquivalence [IsEquivalence F] [SplitEpiCategory C] :\n    SplitEpiCategory D", "start": [293, 1], "end": [300, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.strongEpi_map_of_strongEpi", "code": "theorem strongEpi_map_of_strongEpi (adj : F \u22a3 F') (f : A \u27f6 B) [h\u2081 : F'.PreservesMonomorphisms]\n    [h\u2082 : F.PreservesEpimorphisms] [StrongEpi f] : StrongEpi (F.map f)", "start": [311, 1], "end": [316, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.strongEpi_map_of_isEquivalence", "code": "instance strongEpi_map_of_isEquivalence [IsEquivalence F] (f : A \u27f6 B) [_h : StrongEpi f] :\n    StrongEpi (F.map f) :=\n  F.asEquivalence.toAdjunction.strongEpi_map_of_strongEpi f", "start": [319, 1], "end": [321, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.strongEpi_map_iff_strongEpi_of_isEquivalence", "code": "@[simp]\ntheorem strongEpi_map_iff_strongEpi_of_isEquivalence [IsEquivalence F] :\n    StrongEpi (F.map f) \u2194 StrongEpi f", "start": [330, 1], "end": [340, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/Basic.lean", "imports": ["Mathlib/CategoryTheory/NatIso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bicategory", "code": "@[nolint checkUnivs]\nclass Bicategory (B : Type u) extends CategoryStruct.{v} B where\n  homCategory : \u2200 a b : B, Category.{w} (a \u27f6 b) := by infer_instance\n  whiskerLeft {a b c : B} (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u27f6 h) : f \u226b g \u27f6 f \u226b h\n  whiskerRight {a b c : B} {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) (h : b \u27f6 c) : f \u226b h \u27f6 g \u226b h\n  associator {a b c d : B} (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) : (f \u226b g) \u226b h \u2245 f \u226b g \u226b h\n  leftUnitor {a b : B} (f : a \u27f6 b) : \ud835\udfd9 a \u226b f \u2245 f\n  rightUnitor {a b : B} (f : a \u27f6 b) : f \u226b \ud835\udfd9 b \u2245 f\n  whiskerLeft_id : \u2200 {a b c} (f : a \u27f6 b) (g : b \u27f6 c), whiskerLeft f (\ud835\udfd9 g) = \ud835\udfd9 (f \u226b g) :=\n    by aesop_cat\n  whiskerLeft_comp :\n    \u2200 {a b c} (f : a \u27f6 b) {g h i : b \u27f6 c} (\u03b7 : g \u27f6 h) (\u03b8 : h \u27f6 i),\n      whiskerLeft f (\u03b7 \u226b \u03b8) = whiskerLeft f \u03b7 \u226b whiskerLeft f \u03b8 := by\n    aesop_cat\n  id_whiskerLeft :\n    \u2200 {a b} {f g : a \u27f6 b} (\u03b7 : f \u27f6 g),\n      whiskerLeft (\ud835\udfd9 a) \u03b7 = (leftUnitor f).hom \u226b \u03b7 \u226b (leftUnitor g).inv := by\n    aesop_cat\n  comp_whiskerLeft :\n    \u2200 {a b c d} (f : a \u27f6 b) (g : b \u27f6 c) {h h' : c \u27f6 d} (\u03b7 : h \u27f6 h'),\n      whiskerLeft (f \u226b g) \u03b7 =\n        (associator f g h).hom \u226b whiskerLeft f (whiskerLeft g \u03b7) \u226b (associator f g h').inv := by\n    aesop_cat\n  id_whiskerRight : \u2200 {a b c} (f : a \u27f6 b) (g : b \u27f6 c), whiskerRight (\ud835\udfd9 f) g = \ud835\udfd9 (f \u226b g) := by\n    aesop_cat\n  comp_whiskerRight :\n    \u2200 {a b c} {f g h : a \u27f6 b} (\u03b7 : f \u27f6 g) (\u03b8 : g \u27f6 h) (i : b \u27f6 c),\n      whiskerRight (\u03b7 \u226b \u03b8) i = whiskerRight \u03b7 i \u226b whiskerRight \u03b8 i := by\n    aesop_cat\n  whiskerRight_id :\n    \u2200 {a b} {f g : a \u27f6 b} (\u03b7 : f \u27f6 g),\n      whiskerRight \u03b7 (\ud835\udfd9 b) = (rightUnitor f).hom \u226b \u03b7 \u226b (rightUnitor g).inv := by\n    aesop_cat\n  whiskerRight_comp :\n    \u2200 {a b c d} {f f' : a \u27f6 b} (\u03b7 : f \u27f6 f') (g : b \u27f6 c) (h : c \u27f6 d),\n      whiskerRight \u03b7 (g \u226b h) =\n        (associator f g h).inv \u226b whiskerRight (whiskerRight \u03b7 g) h \u226b (associator f' g h).hom := by\n    aesop_cat\n  whisker_assoc :\n    \u2200 {a b c d} (f : a \u27f6 b) {g g' : b \u27f6 c} (\u03b7 : g \u27f6 g') (h : c \u27f6 d),\n      whiskerRight (whiskerLeft f \u03b7) h =\n        (associator f g h).hom \u226b whiskerLeft f (whiskerRight \u03b7 h) \u226b (associator f g' h).inv := by\n    aesop_cat\n  whisker_exchange :\n    \u2200 {a b c} {f g : a \u27f6 b} {h i : b \u27f6 c} (\u03b7 : f \u27f6 g) (\u03b8 : h \u27f6 i),\n      whiskerLeft f \u03b8 \u226b whiskerRight \u03b7 i = whiskerRight \u03b7 h \u226b whiskerLeft g \u03b8 := by\n    aesop_cat\n  pentagon :\n    \u2200 {a b c d e} (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e),\n      whiskerRight (associator f g h).hom i \u226b\n          (associator f (g \u226b h) i).hom \u226b whiskerLeft f (associator g h i).hom =\n        (associator (f \u226b g) h i).hom \u226b (associator f g (h \u226b i)).hom := by\n    aesop_cat\n  triangle :\n    \u2200 {a b c} (f : a \u27f6 b) (g : b \u27f6 c),\n      (associator f (\ud835\udfd9 b) g).hom \u226b whiskerLeft f (leftUnitor g).hom\n      = whiskerRight (rightUnitor f).hom g := by\n    aesop_cat", "start": [49, 1], "end": [127, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.hom_inv_whiskerLeft", "code": "@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerLeft (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u2245 h) :\n    f \u25c1 \u03b7.hom \u226b f \u25c1 \u03b7.inv = \ud835\udfd9 (f \u226b g)", "start": [195, 1], "end": [197, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.hom_inv_whiskerRight", "code": "@[reassoc (attr := simp)]\ntheorem hom_inv_whiskerRight {f g : a \u27f6 b} (\u03b7 : f \u2245 g) (h : b \u27f6 c) :\n    \u03b7.hom \u25b7 h \u226b \u03b7.inv \u25b7 h = \ud835\udfd9 (f \u226b h)", "start": [200, 1], "end": [202, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.inv_hom_whiskerLeft", "code": "@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerLeft (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u2245 h) :\n    f \u25c1 \u03b7.inv \u226b f \u25c1 \u03b7.hom = \ud835\udfd9 (f \u226b h)", "start": [205, 1], "end": [207, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.inv_hom_whiskerRight", "code": "@[reassoc (attr := simp)]\ntheorem inv_hom_whiskerRight {f g : a \u27f6 b} (\u03b7 : f \u2245 g) (h : b \u27f6 c) :\n    \u03b7.inv \u25b7 h \u226b \u03b7.hom \u25b7 h = \ud835\udfd9 (g \u226b h)", "start": [210, 1], "end": [212, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeftIso", "code": "@[simps]\ndef whiskerLeftIso (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u2245 h) : f \u226b g \u2245 f \u226b h\n    where\n  hom := f \u25c1 \u03b7.hom\n  inv := f \u25c1 \u03b7.inv", "start": [215, 1], "end": [220, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_isIso", "code": "instance whiskerLeft_isIso (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u27f6 h) [IsIso \u03b7] : IsIso (f \u25c1 \u03b7) :=\n  IsIso.of_iso (whiskerLeftIso f (asIso \u03b7))", "start": [223, 1], "end": [224, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.inv_whiskerLeft", "code": "@[simp]\ntheorem inv_whiskerLeft (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g \u27f6 h) [IsIso \u03b7] :\n    inv (f \u25c1 \u03b7) = f \u25c1 inv \u03b7", "start": [227, 1], "end": [231, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerRightIso", "code": "@[simps!]\ndef whiskerRightIso {f g : a \u27f6 b} (\u03b7 : f \u2245 g) (h : b \u27f6 c) : f \u226b h \u2245 g \u226b h\n    where\n  hom := \u03b7.hom \u25b7 h\n  inv := \u03b7.inv \u25b7 h", "start": [234, 1], "end": [239, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerRight_isIso", "code": "instance whiskerRight_isIso {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) (h : b \u27f6 c) [IsIso \u03b7] : IsIso (\u03b7 \u25b7 h) :=\n  IsIso.of_iso (whiskerRightIso (asIso \u03b7) h)", "start": [242, 1], "end": [243, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.inv_whiskerRight", "code": "@[simp]\ntheorem inv_whiskerRight {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) (h : b \u27f6 c) [IsIso \u03b7] :\n    inv (\u03b7 \u25b7 h) = inv \u03b7 \u25b7 h", "start": [246, 1], "end": [250, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_inv", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_inv (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    f \u25c1 (\u03b1_ g h i).inv \u226b (\u03b1_ f (g \u226b h) i).inv \u226b (\u03b1_ f g h).inv \u25b7 i =\n      (\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv", "start": [253, 1], "end": [257, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_inv_inv_hom_hom_inv", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_hom_inv (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ f (g \u226b h) i).inv \u226b (\u03b1_ f g h).inv \u25b7 i \u226b (\u03b1_ (f \u226b g) h i).hom =\n    f \u25c1 (\u03b1_ g h i).hom \u226b (\u03b1_ f g (h \u226b i)).inv", "start": [260, 1], "end": [265, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_inv_hom_hom_hom_inv", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_inv (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ (f \u226b g) h i).inv \u226b (\u03b1_ f g h).hom \u25b7 i \u226b (\u03b1_ f (g \u226b h) i).hom =\n      (\u03b1_ f g (h \u226b i)).hom \u226b f \u25c1 (\u03b1_ g h i).inv", "start": [268, 1], "end": [272, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_hom_inv_inv_inv_inv", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_inv (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    f \u25c1 (\u03b1_ g h i).hom \u226b (\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv =\n      (\u03b1_ f (g \u226b h) i).inv \u226b (\u03b1_ f g h).inv \u25b7 i", "start": [275, 1], "end": [279, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_hom_hom_inv_hom_hom", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_hom_hom (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ (f \u226b g) h i).hom \u226b (\u03b1_ f g (h \u226b i)).hom \u226b f \u25c1 (\u03b1_ g h i).inv =\n      (\u03b1_ f g h).hom \u25b7 i \u226b (\u03b1_ f (g \u226b h) i).hom", "start": [282, 1], "end": [286, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_hom_inv_inv_inv_hom", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_hom_inv_inv_inv_hom (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ f g (h \u226b i)).hom \u226b f \u25c1 (\u03b1_ g h i).inv \u226b (\u03b1_ f (g \u226b h) i).inv =\n    (\u03b1_ (f \u226b g) h i).inv \u226b (\u03b1_ f g h).hom \u25b7 i", "start": [289, 1], "end": [294, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_hom_hom_inv_inv_hom", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_hom_hom_inv_inv_hom (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ f (g \u226b h) i).hom \u226b f \u25c1 (\u03b1_ g h i).hom \u226b (\u03b1_ f g (h \u226b i)).inv =\n      (\u03b1_ f g h).inv \u25b7 i \u226b (\u03b1_ (f \u226b g) h i).hom", "start": [297, 1], "end": [301, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_inv_hom_hom_hom_hom", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_inv_hom_hom_hom_hom (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ f g h).inv \u25b7 i \u226b (\u03b1_ (f \u226b g) h i).hom \u226b (\u03b1_ f g (h \u226b i)).hom =\n      (\u03b1_ f (g \u226b h) i).hom \u226b f \u25c1 (\u03b1_ g h i).hom", "start": [304, 1], "end": [308, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.pentagon_inv_inv_hom_inv_inv", "code": "@[reassoc (attr := simp)]\ntheorem pentagon_inv_inv_hom_inv_inv (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d) (i : d \u27f6 e) :\n    (\u03b1_ f g (h \u226b i)).inv \u226b (\u03b1_ (f \u226b g) h i).inv \u226b (\u03b1_ f g h).hom \u25b7 i =\n      f \u25c1 (\u03b1_ g h i).inv \u226b (\u03b1_ f (g \u226b h) i).inv", "start": [311, 1], "end": [315, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.triangle_assoc_comp_left", "code": "theorem triangle_assoc_comp_left (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03b1_ f (\ud835\udfd9 b) g).hom \u226b f \u25c1 (\u03bb_ g).hom = (\u03c1_ f).hom \u25b7 g", "start": [318, 1], "end": [320, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.triangle_assoc_comp_right", "code": "@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03b1_ f (\ud835\udfd9 b) g).inv \u226b (\u03c1_ f).hom \u25b7 g = f \u25c1 (\u03bb_ g).hom", "start": [323, 1], "end": [325, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.triangle_assoc_comp_right_inv", "code": "@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_right_inv (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03c1_ f).inv \u25b7 g \u226b (\u03b1_ f (\ud835\udfd9 b) g).hom = f \u25c1 (\u03bb_ g).inv", "start": [328, 1], "end": [331, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.triangle_assoc_comp_left_inv", "code": "@[reassoc (attr := simp)]\ntheorem triangle_assoc_comp_left_inv (f : a \u27f6 b) (g : b \u27f6 c) :\n    f \u25c1 (\u03bb_ g).inv \u226b (\u03b1_ f (\ud835\udfd9 b) g).inv = (\u03c1_ f).inv \u25b7 g", "start": [334, 1], "end": [337, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_naturality_left", "code": "@[reassoc]\ntheorem associator_naturality_left {f f' : a \u27f6 b} (\u03b7 : f \u27f6 f') (g : b \u27f6 c) (h : c \u27f6 d) :\n    \u03b7 \u25b7 g \u25b7 h \u226b (\u03b1_ f' g h).hom = (\u03b1_ f g h).hom \u226b \u03b7 \u25b7 (g \u226b h)", "start": [340, 1], "end": [342, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_inv_naturality_left", "code": "@[reassoc]\ntheorem associator_inv_naturality_left {f f' : a \u27f6 b} (\u03b7 : f \u27f6 f') (g : b \u27f6 c) (h : c \u27f6 d) :\n    \u03b7 \u25b7 (g \u226b h) \u226b (\u03b1_ f' g h).inv = (\u03b1_ f g h).inv \u226b \u03b7 \u25b7 g \u25b7 h", "start": [345, 1], "end": [347, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerRight_comp_symm", "code": "@[reassoc]\ntheorem whiskerRight_comp_symm {f f' : a \u27f6 b} (\u03b7 : f \u27f6 f') (g : b \u27f6 c) (h : c \u27f6 d) :\n    \u03b7 \u25b7 g \u25b7 h = (\u03b1_ f g h).hom \u226b \u03b7 \u25b7 (g \u226b h) \u226b (\u03b1_ f' g h).inv", "start": [350, 1], "end": [352, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_naturality_middle", "code": "@[reassoc]\ntheorem associator_naturality_middle (f : a \u27f6 b) {g g' : b \u27f6 c} (\u03b7 : g \u27f6 g') (h : c \u27f6 d) :\n    (f \u25c1 \u03b7) \u25b7 h \u226b (\u03b1_ f g' h).hom = (\u03b1_ f g h).hom \u226b f \u25c1 \u03b7 \u25b7 h", "start": [355, 1], "end": [357, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_inv_naturality_middle", "code": "@[reassoc]\ntheorem associator_inv_naturality_middle (f : a \u27f6 b) {g g' : b \u27f6 c} (\u03b7 : g \u27f6 g') (h : c \u27f6 d) :\n    f \u25c1 \u03b7 \u25b7 h \u226b (\u03b1_ f g' h).inv = (\u03b1_ f g h).inv \u226b (f \u25c1 \u03b7) \u25b7 h", "start": [360, 1], "end": [362, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whisker_assoc_symm", "code": "@[reassoc]\ntheorem whisker_assoc_symm (f : a \u27f6 b) {g g' : b \u27f6 c} (\u03b7 : g \u27f6 g') (h : c \u27f6 d) :\n    f \u25c1 \u03b7 \u25b7 h = (\u03b1_ f g h).inv \u226b (f \u25c1 \u03b7) \u25b7 h \u226b (\u03b1_ f g' h).hom", "start": [365, 1], "end": [367, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_naturality_right", "code": "@[reassoc]\ntheorem associator_naturality_right (f : a \u27f6 b) (g : b \u27f6 c) {h h' : c \u27f6 d} (\u03b7 : h \u27f6 h') :\n    (f \u226b g) \u25c1 \u03b7 \u226b (\u03b1_ f g h').hom = (\u03b1_ f g h).hom \u226b f \u25c1 g \u25c1 \u03b7", "start": [370, 1], "end": [372, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associator_inv_naturality_right", "code": "@[reassoc]\ntheorem associator_inv_naturality_right (f : a \u27f6 b) (g : b \u27f6 c) {h h' : c \u27f6 d} (\u03b7 : h \u27f6 h') :\n    f \u25c1 g \u25c1 \u03b7 \u226b (\u03b1_ f g h').inv = (\u03b1_ f g h).inv \u226b (f \u226b g) \u25c1 \u03b7", "start": [375, 1], "end": [377, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.comp_whiskerLeft_symm", "code": "@[reassoc]\ntheorem comp_whiskerLeft_symm (f : a \u27f6 b) (g : b \u27f6 c) {h h' : c \u27f6 d} (\u03b7 : h \u27f6 h') :\n    f \u25c1 g \u25c1 \u03b7 = (\u03b1_ f g h).inv \u226b (f \u226b g) \u25c1 \u03b7 \u226b (\u03b1_ f g h').hom", "start": [380, 1], "end": [382, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_naturality", "code": "@[reassoc]\ntheorem leftUnitor_naturality {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) :\n    \ud835\udfd9 a \u25c1 \u03b7 \u226b (\u03bb_ g).hom = (\u03bb_ f).hom \u226b \u03b7", "start": [385, 1], "end": [388, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_inv_naturality", "code": "@[reassoc]\ntheorem leftUnitor_inv_naturality {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) :\n    \u03b7 \u226b (\u03bb_ g).inv = (\u03bb_ f).inv \u226b \ud835\udfd9 a \u25c1 \u03b7", "start": [391, 1], "end": [393, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.id_whiskerLeft_symm", "code": "theorem id_whiskerLeft_symm {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) : \u03b7 = (\u03bb_ f).inv \u226b \ud835\udfd9 a \u25c1 \u03b7 \u226b (\u03bb_ g).hom", "start": [396, 1], "end": [397, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightUnitor_naturality", "code": "@[reassoc]\ntheorem rightUnitor_naturality {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) : \u03b7 \u25b7 \ud835\udfd9 b \u226b (\u03c1_ g).hom = (\u03c1_ f).hom \u226b \u03b7", "start": [400, 1], "end": [402, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightUnitor_inv_naturality", "code": "@[reassoc]\ntheorem rightUnitor_inv_naturality {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) :\n    \u03b7 \u226b (\u03c1_ g).inv = (\u03c1_ f).inv \u226b \u03b7 \u25b7 \ud835\udfd9 b", "start": [405, 1], "end": [407, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerRight_id_symm", "code": "theorem whiskerRight_id_symm {f g : a \u27f6 b} (\u03b7 : f \u27f6 g) : \u03b7 = (\u03c1_ f).inv \u226b \u03b7 \u25b7 \ud835\udfd9 b \u226b (\u03c1_ g).hom", "start": [410, 1], "end": [411, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_iff", "code": "theorem whiskerLeft_iff {f g : a \u27f6 b} (\u03b7 \u03b8 : f \u27f6 g) : \ud835\udfd9 a \u25c1 \u03b7 = \ud835\udfd9 a \u25c1 \u03b8 \u2194 \u03b7 = \u03b8", "start": [414, 1], "end": [414, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerRight_iff", "code": "theorem whiskerRight_iff {f g : a \u27f6 b} (\u03b7 \u03b8 : f \u27f6 g) : \u03b7 \u25b7 \ud835\udfd9 b = \u03b8 \u25b7 \ud835\udfd9 b \u2194 \u03b7 = \u03b8", "start": [417, 1], "end": [417, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_whiskerRight", "code": "@[reassoc, simp]\ntheorem leftUnitor_whiskerRight (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03bb_ f).hom \u25b7 g = (\u03b1_ (\ud835\udfd9 a) f g).hom \u226b (\u03bb_ (f \u226b g)).hom", "start": [420, 1], "end": [428, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_inv_whiskerRight", "code": "@[reassoc, simp]\ntheorem leftUnitor_inv_whiskerRight (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03bb_ f).inv \u25b7 g = (\u03bb_ (f \u226b g)).inv \u226b (\u03b1_ (\ud835\udfd9 a) f g).inv", "start": [431, 1], "end": [434, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_rightUnitor", "code": "@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor (f : a \u27f6 b) (g : b \u27f6 c) :\n    f \u25c1 (\u03c1_ g).hom = (\u03b1_ f g (\ud835\udfd9 c)).inv \u226b (\u03c1_ (f \u226b g)).hom", "start": [437, 1], "end": [443, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_rightUnitor_inv", "code": "@[reassoc, simp]\ntheorem whiskerLeft_rightUnitor_inv (f : a \u27f6 b) (g : b \u27f6 c) :\n    f \u25c1 (\u03c1_ g).inv = (\u03c1_ (f \u226b g)).inv \u226b (\u03b1_ f g (\ud835\udfd9 c)).hom", "start": [446, 1], "end": [449, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_comp", "code": "@[reassoc]\ntheorem leftUnitor_comp (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03bb_ (f \u226b g)).hom = (\u03b1_ (\ud835\udfd9 a) f g).inv \u226b (\u03bb_ f).hom \u25b7 g", "start": [460, 1], "end": [462, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitor_comp_inv", "code": "@[reassoc]\ntheorem leftUnitor_comp_inv (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03bb_ (f \u226b g)).inv = (\u03bb_ f).inv \u25b7 g \u226b (\u03b1_ (\ud835\udfd9 a) f g).hom", "start": [465, 1], "end": [467, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightUnitor_comp", "code": "@[reassoc]\ntheorem rightUnitor_comp (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03c1_ (f \u226b g)).hom = (\u03b1_ f g (\ud835\udfd9 c)).hom \u226b f \u25c1 (\u03c1_ g).hom", "start": [470, 1], "end": [472, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightUnitor_comp_inv", "code": "@[reassoc]\ntheorem rightUnitor_comp_inv (f : a \u27f6 b) (g : b \u27f6 c) :\n    (\u03c1_ (f \u226b g)).inv = f \u25c1 (\u03c1_ g).inv \u226b (\u03b1_ f g (\ud835\udfd9 c)).inv", "start": [475, 1], "end": [477, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.unitors_equal", "code": "@[simp]\ntheorem unitors_equal : (\u03bb_ (\ud835\udfd9 a)).hom = (\u03c1_ (\ud835\udfd9 a)).hom", "start": [480, 1], "end": [483, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.unitors_inv_equal", "code": "@[simp]\ntheorem unitors_inv_equal : (\u03bb_ (\ud835\udfd9 a)).inv = (\u03c1_ (\ud835\udfd9 a)).inv", "start": [486, 1], "end": [487, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.precomp", "code": "@[simps]\ndef precomp (c : B) (f : a \u27f6 b) : (b \u27f6 c) \u2964 (a \u27f6 c) where\n  obj := (f \u226b \u00b7)\n  map := (f \u25c1 \u00b7)", "start": [494, 1], "end": [498, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.precomposing", "code": "@[simps]\ndef precomposing (a b c : B) : (a \u27f6 b) \u2964 (b \u27f6 c) \u2964 (a \u27f6 c) where\n  obj f := precomp c f\n  map \u03b7 := \u27e8(\u03b7 \u25b7 \u00b7), _\u27e9", "start": [500, 1], "end": [505, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.postcomp", "code": "@[simps]\ndef postcomp (a : B) (f : b \u27f6 c) : (a \u27f6 b) \u2964 (a \u27f6 c) where\n  obj := (\u00b7 \u226b f)\n  map := (\u00b7 \u25b7 f)", "start": [507, 1], "end": [511, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.postcomposing", "code": "@[simps]\ndef postcomposing (a b c : B) : (b \u27f6 c) \u2964 (a \u27f6 b) \u2964 (a \u27f6 c) where\n  obj f := postcomp a f\n  map \u03b7 := \u27e8(\u00b7 \u25c1 \u03b7), _\u27e9", "start": [513, 1], "end": [518, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associatorNatIsoLeft", "code": "@[simps!]\ndef associatorNatIsoLeft (a : B) (g : b \u27f6 c) (h : c \u27f6 d) :\n    (postcomposing a ..).obj g \u22d9 (postcomposing ..).obj h \u2245 (postcomposing ..).obj (g \u226b h) :=\n  NatIso.ofComponents (\u03b1_ \u00b7 g h)", "start": [520, 1], "end": [524, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associatorNatIsoMiddle", "code": "@[simps!]\ndef associatorNatIsoMiddle (f : a \u27f6 b) (h : c \u27f6 d) :\n    (precomposing ..).obj f \u22d9 (postcomposing ..).obj h \u2245\n      (postcomposing ..).obj h \u22d9 (precomposing ..).obj f :=\n  NatIso.ofComponents (\u03b1_ f \u00b7 h)", "start": [526, 1], "end": [531, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.associatorNatIsoRight", "code": "@[simps!]\ndef associatorNatIsoRight (f : a \u27f6 b) (g : b \u27f6 c) (d : B) :\n    (precomposing _ _ d).obj (f \u226b g) \u2245 (precomposing ..).obj g \u22d9 (precomposing ..).obj f :=\n  NatIso.ofComponents (\u03b1_ f g \u00b7)", "start": [533, 1], "end": [537, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.leftUnitorNatIso", "code": "@[simps!]\ndef leftUnitorNatIso (a b : B) : (precomposing _ _ b).obj (\ud835\udfd9 a) \u2245 \ud835\udfed (a \u27f6 b) :=\n  NatIso.ofComponents (\u03bb_ \u00b7)", "start": [539, 1], "end": [542, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.rightUnitorNatIso", "code": "@[simps!]\ndef rightUnitorNatIso (a b : B) : (postcomposing a _ _).obj (\ud835\udfd9 b) \u2245 \ud835\udfed (a \u27f6 b) :=\n  NatIso.ofComponents (\u03c1_ \u00b7)", "start": [544, 1], "end": [547, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GCDMonoid/Multiset.lean", "imports": ["Mathlib/Data/Multiset/FinsetOps.lean", "Mathlib/Data/Multiset/Fold.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.lcm", "code": "def lcm (s : Multiset \u03b1) : \u03b1 :=\n  s.fold GCDMonoid.lcm 1", "start": [38, 1], "end": [40, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_zero", "code": "@[simp]\ntheorem lcm_zero : (0 : Multiset \u03b1).lcm = 1", "start": [43, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_cons", "code": "@[simp]\ntheorem lcm_cons (a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).lcm = GCDMonoid.lcm a s.lcm", "start": [48, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_singleton", "code": "@[simp]\ntheorem lcm_singleton {a : \u03b1} : ({a} : Multiset \u03b1).lcm = normalize a", "start": [53, 1], "end": [55, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_add", "code": "@[simp]\ntheorem lcm_add (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 + s\u2082).lcm = GCDMonoid.lcm s\u2081.lcm s\u2082.lcm", "start": [58, 1], "end": [60, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_dvd", "code": "theorem lcm_dvd {s : Multiset \u03b1} {a : \u03b1} : s.lcm \u2223 a \u2194 \u2200 b \u2208 s, b \u2223 a", "start": [63, 1], "end": [65, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.dvd_lcm", "code": "theorem dvd_lcm {s : Multiset \u03b1} {a : \u03b1} (h : a \u2208 s) : a \u2223 s.lcm", "start": [68, 1], "end": [69, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_mono", "code": "theorem lcm_mono {s\u2081 s\u2082 : Multiset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081.lcm \u2223 s\u2082.lcm", "start": [72, 1], "end": [73, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.normalize_lcm", "code": "@[simp 1100]\ntheorem normalize_lcm (s : Multiset \u03b1) : normalize s.lcm = s.lcm", "start": [80, 1], "end": [82, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_eq_zero_iff", "code": "@[simp]\nnonrec theorem lcm_eq_zero_iff [Nontrivial \u03b1] (s : Multiset \u03b1) : s.lcm = 0 \u2194 (0 : \u03b1) \u2208 s", "start": [85, 1], "end": [89, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_dedup", "code": "@[simp]\ntheorem lcm_dedup (s : Multiset \u03b1) : (dedup s).lcm = s.lcm", "start": [94, 1], "end": [100, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_ndunion", "code": "@[simp]\ntheorem lcm_ndunion (s\u2081 s\u2082 : Multiset \u03b1) : (ndunion s\u2081 s\u2082).lcm = GCDMonoid.lcm s\u2081.lcm s\u2082.lcm", "start": [103, 1], "end": [106, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_union", "code": "@[simp]\ntheorem lcm_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).lcm = GCDMonoid.lcm s\u2081.lcm s\u2082.lcm", "start": [109, 1], "end": [112, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.lcm_ndinsert", "code": "@[simp]\ntheorem lcm_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).lcm = GCDMonoid.lcm a s.lcm", "start": [115, 1], "end": [118, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd", "code": "def gcd (s : Multiset \u03b1) : \u03b1 :=\n  s.fold GCDMonoid.gcd 0", "start": [128, 1], "end": [130, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_zero", "code": "@[simp]\ntheorem gcd_zero : (0 : Multiset \u03b1).gcd = 0", "start": [133, 1], "end": [135, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_cons", "code": "@[simp]\ntheorem gcd_cons (a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).gcd = GCDMonoid.gcd a s.gcd", "start": [138, 1], "end": [140, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_singleton", "code": "@[simp]\ntheorem gcd_singleton {a : \u03b1} : ({a} : Multiset \u03b1).gcd = normalize a", "start": [143, 1], "end": [145, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_add", "code": "@[simp]\ntheorem gcd_add (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 + s\u2082).gcd = GCDMonoid.gcd s\u2081.gcd s\u2082.gcd", "start": [148, 1], "end": [150, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.dvd_gcd", "code": "theorem dvd_gcd {s : Multiset \u03b1} {a : \u03b1} : a \u2223 s.gcd \u2194 \u2200 b \u2208 s, a \u2223 b", "start": [153, 1], "end": [155, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_dvd", "code": "theorem gcd_dvd {s : Multiset \u03b1} {a : \u03b1} (h : a \u2208 s) : s.gcd \u2223 a", "start": [158, 1], "end": [159, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_mono", "code": "theorem gcd_mono {s\u2081 s\u2082 : Multiset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2082.gcd \u2223 s\u2081.gcd", "start": [162, 1], "end": [163, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.normalize_gcd", "code": "@[simp 1100]\ntheorem normalize_gcd (s : Multiset \u03b1) : normalize s.gcd = s.gcd", "start": [168, 1], "end": [170, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_eq_zero_iff", "code": "theorem gcd_eq_zero_iff (s : Multiset \u03b1) : s.gcd = 0 \u2194 \u2200 x : \u03b1, x \u2208 s \u2192 x = 0", "start": [173, 1], "end": [182, 77], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_map_mul", "code": "theorem gcd_map_mul (a : \u03b1) (s : Multiset \u03b1) : (s.map ((\u00b7 * \u00b7) a)).gcd = normalize a * s.gcd", "start": [185, 1], "end": [190, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_dedup", "code": "@[simp]\ntheorem gcd_dedup (s : Multiset \u03b1) : (dedup s).gcd = s.gcd", "start": [197, 1], "end": [203, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_ndunion", "code": "@[simp]\ntheorem gcd_ndunion (s\u2081 s\u2082 : Multiset \u03b1) : (ndunion s\u2081 s\u2082).gcd = GCDMonoid.gcd s\u2081.gcd s\u2082.gcd", "start": [206, 1], "end": [209, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_union", "code": "@[simp]\ntheorem gcd_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).gcd = GCDMonoid.gcd s\u2081.gcd s\u2082.gcd", "start": [212, 1], "end": [215, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.gcd_ndinsert", "code": "@[simp]\ntheorem gcd_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).gcd = GCDMonoid.gcd a s.gcd", "start": [218, 1], "end": [221, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.extract_gcd'", "code": "theorem extract_gcd' (s t : Multiset \u03b1) (hs : \u2203 x, x \u2208 s \u2227 x \u2260 (0 : \u03b1))\n    (ht : s = t.map ((\u00b7 * \u00b7) s.gcd)) : t.gcd = 1", "start": [226, 1], "end": [231, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.extract_gcd", "code": "theorem extract_gcd (s : Multiset \u03b1) (hs : s \u2260 0) :\n    \u2203 t : Multiset \u03b1, s = t.map ((\u00b7 * \u00b7) s.gcd) \u2227 t.gcd = 1", "start": [240, 1], "end": [257, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/GCD.lean", "imports": ["Mathlib/Data/Int/GCD.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Tactic.NormNum.int_gcd_helper'", "code": "theorem int_gcd_helper' {d : \u2115} {x y : \u2124} (a b : \u2124) (h\u2081 : (d : \u2124) \u2223 x) (h\u2082 : (d : \u2124) \u2223 y)\n    (h\u2083 : x * a + y * b = d) : Int.gcd x y = d", "start": [22, 1], "end": [28, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_dvd_left", "code": "theorem nat_gcd_helper_dvd_left (x y : \u2115) (h : y % x = 0) : Nat.gcd x y = x", "start": [30, 1], "end": [31, 45], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_dvd_right", "code": "theorem nat_gcd_helper_dvd_right (x y : \u2115) (h : x % y = 0) : Nat.gcd x y = y", "start": [33, 1], "end": [34, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_2", "code": "theorem nat_gcd_helper_2 (d x y a b : \u2115) (hu : x % d = 0) (hv : y % d = 0)\n    (h : x * a = y * b + d) : Nat.gcd x y = d", "start": [36, 1], "end": [43, 19], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_1", "code": "theorem nat_gcd_helper_1 (d x y a b : \u2115) (hu : x % d = 0) (hv : y % d = 0)\n    (h : y * b = x * a + d) : Nat.gcd x y = d", "start": [45, 1], "end": [47, 65], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_1'", "code": "theorem nat_gcd_helper_1' (x y a b : \u2115) (h : y * b = x * a + 1) :\n    Nat.gcd x y = 1", "start": [49, 1], "end": [51, 63], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_gcd_helper_2'", "code": "theorem nat_gcd_helper_2' (x y a b : \u2115) (h : x * a = y * b + 1) :\n    Nat.gcd x y = 1", "start": [53, 1], "end": [55, 63], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.nat_lcm_helper", "code": "theorem nat_lcm_helper (x y d m : \u2115) (hd : Nat.gcd x y = d)\n    (d0 : Nat.beq d 0 = false)\n    (dm : x * y = d * m) : Nat.lcm x y = m", "start": [57, 1], "end": [62, 37], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.int_gcd_helper", "code": "theorem int_gcd_helper {x y : \u2124} {x' y' d : \u2115}\n    (hx : x.natAbs = x') (hy : y.natAbs = y') (h : Nat.gcd x' y' = d) :\n    Int.gcd x y = d", "start": [64, 1], "end": [66, 55], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.int_lcm_helper", "code": "theorem int_lcm_helper {x y : \u2124} {x' y' d : \u2115}\n    (hx : x.natAbs = x') (hy : y.natAbs = y') (h : Nat.lcm x' y' = d) :\n    Int.lcm x y = d", "start": [68, 1], "end": [70, 55], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isNat_gcd", "code": "theorem isNat_gcd : {x y nx ny z : \u2115} \u2192\n    IsNat x nx \u2192 IsNat y ny \u2192 Nat.gcd nx ny = z \u2192 IsNat (Nat.gcd x y) z", "start": [74, 1], "end": [76, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isNat_lcm", "code": "theorem isNat_lcm : {x y nx ny z : \u2115} \u2192\n    IsNat x nx \u2192 IsNat y ny \u2192 Nat.lcm nx ny = z \u2192 IsNat (Nat.lcm x y) z", "start": [78, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isInt_gcd", "code": "theorem isInt_gcd : {x y nx ny : \u2124} \u2192 {z : \u2115} \u2192\n    IsInt x nx \u2192 IsInt y ny \u2192 Int.gcd nx ny = z \u2192 IsNat (Int.gcd x y) z", "start": [82, 1], "end": [84, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isInt_lcm", "code": "theorem isInt_lcm : {x y nx ny : \u2124} \u2192 {z : \u2115} \u2192\n    IsInt x nx \u2192 IsInt y ny \u2192 Int.lcm nx ny = z \u2192 IsNat (Int.lcm x y) z", "start": [86, 1], "end": [88, 46], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveNatGCD", "code": "def proveNatGCD (ex ey : Q(\u2115)) : (ed : Q(\u2115)) \u00d7 Q(Nat.gcd $ex $ey = $ed) :=\n  match ex.natLit!, ey.natLit! with\n  | 0, _ => show (ed : Q(\u2115)) \u00d7 Q(Nat.gcd 0 $ey = $ed) from \u27e8ey, q(Nat.gcd_zero_left $ey)\u27e9\n  | _, 0 => show (ed : Q(\u2115)) \u00d7 Q(Nat.gcd $ex 0 = $ed) from \u27e8ex, q(Nat.gcd_zero_right $ex)\u27e9\n  | 1, _ => show (ed : Q(\u2115)) \u00d7 Q(Nat.gcd 1 $ey = $ed) from \u27e8mkRawNatLit 1, q(Nat.gcd_one_left $ey)\u27e9\n  | _, 1 => show (ed : Q(\u2115)) \u00d7 Q(Nat.gcd $ex 1 = $ed) from \u27e8mkRawNatLit 1, q(Nat.gcd_one_right $ex)\u27e9\n  | x, y =>\n    let (d, a, b) := Nat.xgcdAux x 1 0 y 0 1\n    if d = x then\n      have pq : Q(Nat.mod $ey $ex = 0) := (q(Eq.refl (nat_lit 0)) : Expr)\n      \u27e8ex, q(nat_gcd_helper_dvd_left $ex $ey $pq)\u27e9\n    else if d = y then\n      have pq : Q(Nat.mod $ex $ey = 0) := (q(Eq.refl (nat_lit 0)) : Expr)\n      \u27e8ey, q(nat_gcd_helper_dvd_right $ex $ey $pq)\u27e9\n    else\n      have ea' : Q(\u2115) := mkRawNatLit a.natAbs\n      have eb' : Q(\u2115) := mkRawNatLit b.natAbs\n      if d = 1 then\n        if a \u2265 0 then\n          have pt : Q($ex * $ea' = $ey * $eb' + 1) := (q(Eq.refl ($ex * $ea')) : Expr)\n          \u27e8mkRawNatLit 1, q(nat_gcd_helper_2' $ex $ey $ea' $eb' $pt)\u27e9\n        else\n          have pt : Q($ey * $eb' = $ex * $ea' + 1) := (q(Eq.refl ($ey * $eb')) : Expr)\n          \u27e8mkRawNatLit 1, q(nat_gcd_helper_1' $ex $ey $ea' $eb' $pt)\u27e9\n      else\n        have ed : Q(\u2115) := mkRawNatLit d\n        have pu : Q(Nat.mod $ex $ed = 0) := (q(Eq.refl (nat_lit 0)) : Expr)\n        have pv : Q(Nat.mod $ey $ed = 0) := (q(Eq.refl (nat_lit 0)) : Expr)\n        if a \u2265 0 then\n          have pt : Q($ex * $ea' = $ey * $eb' + $ed) := (q(Eq.refl ($ex * $ea')) : Expr)\n          \u27e8ed, q(nat_gcd_helper_2 $ed $ex $ey $ea' $eb' $pu $pv $pt)\u27e9\n        else\n          have pt : Q($ey * $eb' = $ex * $ea' + $ed) := (q(Eq.refl ($ey * $eb')) : Expr)\n          \u27e8ed, q(nat_gcd_helper_1 $ed $ex $ey $ea' $eb' $pu $pv $pt)\u27e9", "start": [90, 1], "end": [125, 70], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalNatGCD", "code": "@[norm_num Nat.gcd _ _]\ndef evalNatGCD : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app _ (x : Q(\u2115))) (y : Q(\u2115)) \u2190 Meta.whnfR e | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q Nat.gcd $x $y := \u27e8\u27e9\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8ex, p\u27e9 \u2190 deriveNat x s\u2115\n  let \u27e8ey, q\u27e9 \u2190 deriveNat y s\u2115\n  let \u27e8ed, pf\u27e9 := proveNatGCD ex ey\n  return .isNat s\u2115 ed q(isNat_gcd $p $q $pf)", "start": [127, 1], "end": [136, 45], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveNatLCM", "code": "def proveNatLCM (ex ey : Q(\u2115)) : (ed : Q(\u2115)) \u00d7 Q(Nat.lcm $ex $ey = $ed) :=\n  match ex.natLit!, ey.natLit! with\n  | 0, _ =>\n    show (ed : Q(\u2115)) \u00d7 Q(Nat.lcm 0 $ey = $ed) from \u27e8mkRawNatLit 0, q(Nat.lcm_zero_left $ey)\u27e9\n  | _, 0 =>\n    show (ed : Q(\u2115)) \u00d7 Q(Nat.lcm $ex 0 = $ed) from \u27e8mkRawNatLit 0, q(Nat.lcm_zero_right $ex)\u27e9\n  | 1, _ => show (ed : Q(\u2115)) \u00d7 Q(Nat.lcm 1 $ey = $ed) from \u27e8ey, q(Nat.lcm_one_left $ey)\u27e9\n  | _, 1 => show (ed : Q(\u2115)) \u00d7 Q(Nat.lcm $ex 1 = $ed) from \u27e8ex, q(Nat.lcm_one_right $ex)\u27e9\n  | x, y =>\n    let \u27e8ed, pd\u27e9 := proveNatGCD ex ey\n    have p0 : Q(Nat.beq $ed 0 = false) := (q(Eq.refl false) : Expr)\n    have em : Q(\u2115) := mkRawNatLit (x * y / ed.natLit!)\n    have pm : Q($ex * $ey = $ed * $em) := (q(Eq.refl ($ex * $ey)) : Expr)\n    \u27e8em, q(nat_lcm_helper $ex $ey $ed $em $pd $p0 $pm)\u27e9", "start": [138, 1], "end": [153, 56], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalNatLCM", "code": "@[norm_num Nat.lcm _ _]\ndef evalNatLCM : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app _ (x : Q(\u2115))) (y : Q(\u2115)) \u2190 Meta.whnfR e | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q Nat.lcm $x $y := \u27e8\u27e9\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8ex, p\u27e9 \u2190 deriveNat x s\u2115\n  let \u27e8ey, q\u27e9 \u2190 deriveNat y s\u2115\n  let \u27e8ed, pf\u27e9 := proveNatLCM ex ey\n  return .isNat s\u2115 ed q(isNat_lcm $p $q $pf)", "start": [155, 1], "end": [165, 45], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveIntGCD", "code": "def proveIntGCD (ex ey : Q(\u2124)) : (ed : Q(\u2115)) \u00d7 Q(Int.gcd $ex $ey = $ed) :=\n  let \u27e8ex', hx\u27e9 := rawIntLitNatAbs ex\n  let \u27e8ey', hy\u27e9 := rawIntLitNatAbs ey\n  let \u27e8ed, pf\u27e9 := proveNatGCD ex' ey'\n  \u27e8ed, q(int_gcd_helper $hx $hy $pf)\u27e9", "start": [167, 1], "end": [173, 38], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalIntGCD", "code": "@[norm_num Int.gcd _ _]\ndef evalIntGCD : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app _ (x : Q(\u2124))) (y : Q(\u2124)) \u2190 Meta.whnfR e | failure\n  let \u27e8ex, p\u27e9 \u2190 deriveInt x _\n  let \u27e8ey, q\u27e9 \u2190 deriveInt y _\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q Int.gcd $x $y := \u27e8\u27e9\n  let \u27e8ed, pf\u27e9 := proveIntGCD ex ey\n  return .isNat _ ed q(isInt_gcd $p $q $pf)", "start": [175, 1], "end": [184, 44], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveIntLCM", "code": "def proveIntLCM (ex ey : Q(\u2124)) : (ed : Q(\u2115)) \u00d7 Q(Int.lcm $ex $ey = $ed) :=\n  let \u27e8ex', hx\u27e9 := rawIntLitNatAbs ex\n  let \u27e8ey', hy\u27e9 := rawIntLitNatAbs ey\n  let \u27e8ed, pf\u27e9 := proveNatLCM ex' ey'\n  \u27e8ed, q(int_lcm_helper $hx $hy $pf)\u27e9", "start": [186, 1], "end": [192, 38], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalIntLCM", "code": "@[norm_num Int.lcm _ _]\ndef evalIntLCM : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app _ (x : Q(\u2124))) (y : Q(\u2124)) \u2190 Meta.whnfR e | failure\n  let \u27e8ex, p\u27e9 \u2190 deriveInt x _\n  let \u27e8ey, q\u27e9 \u2190 deriveInt y _\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q Int.lcm $x $y := \u27e8\u27e9\n  let \u27e8ed, pf\u27e9 := proveIntLCM ex ey\n  return .isNat _ ed q(isInt_lcm $p $q $pf)", "start": [194, 1], "end": [203, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Partition.lean", "imports": ["Mathlib/Combinatorics/Composition.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Partition", "code": "@[ext]\nstructure Partition (n : \u2115) where\n  \n  parts : Multiset \u2115\n  \n  parts_pos : \u2200 {i}, i \u2208 parts \u2192 0 < i\n  \n  parts_sum : parts.sum = n", "start": [54, 1], "end": [62, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.decidableEqParition", "code": "instance decidableEqParition: DecidableEq (Partition n)\n  | p, q => by simp [Partition.ext_iff]; exact decidableEq p.parts q.parts", "start": [69, 1], "end": [70, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.ofComposition", "code": "def ofComposition (n : \u2115) (c : Composition n) : Partition n\n    where\n  parts := c.blocks\n  parts_pos {i} hi := c.blocks_pos hi\n  parts_sum := by rw [Multiset.coe_sum, c.blocks_sum]", "start": [72, 1], "end": [77, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.ofComposition_surj", "code": "theorem ofComposition_surj {n : \u2115} : Function.Surjective (ofComposition n)", "start": [80, 1], "end": [84, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.ofSums", "code": "def ofSums (n : \u2115) (l : Multiset \u2115) (hl : l.sum = n) : Partition n\n    where\n  parts := l.filter (\u00b7 \u2260 0)\n  parts_pos {i} hi := Nat.pos_of_ne_zero <| by apply of_mem_filter hi\n  parts_sum := by\n    have lt : l.filter (\u00b7 = 0) + l.filter (\u00b7 \u2260 0) = l := filter_add_not _ l\n    apply_fun Multiset.sum at lt\n    have lz : (l.filter (\u00b7 = 0)).sum = 0 := by\n      rw [Multiset.sum_eq_zero_iff]\n      simp\n    rwa [sum_add (filter (fun x => x = 0) l) (filter (fun x => \u00acx = 0) l),lz,hl, zero_add] at lt", "start": [89, 1], "end": [102, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.ofMultiset", "code": "def ofMultiset (l : Multiset \u2115) : Partition l.sum :=\n  ofSums _ l rfl", "start": [105, 1], "end": [107, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.indiscretePartition", "code": "def indiscretePartition (n : \u2115) : Partition n :=\n  ofSums n {n} rfl", "start": [110, 1], "end": [112, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.count_ofSums_of_ne_zero", "code": "theorem count_ofSums_of_ne_zero {n : \u2115} {l : Multiset \u2115} (hl : l.sum = n) {i : \u2115} (hi : i \u2260 0) :\n    (ofSums n l hl).parts.count i = l.count i", "start": [118, 1], "end": [125, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.count_ofSums_zero", "code": "theorem count_ofSums_zero {n : \u2115} {l : Multiset \u2115} (hl : l.sum = n) :\n    (ofSums n l hl).parts.count 0 = 0", "start": [128, 1], "end": [130, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.odds", "code": "def odds (n : \u2115) : Finset (Partition n) :=\n  Finset.univ.filter fun c => \u2200 i \u2208 c.parts, \u00acEven i", "start": [139, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.distincts", "code": "def distincts (n : \u2115) : Finset (Partition n) :=\n  Finset.univ.filter fun c => c.parts.Nodup", "start": [144, 1], "end": [146, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.Partition.oddDistincts", "code": "def oddDistincts (n : \u2115) : Finset (Partition n) :=\n  odds n \u2229 distincts n", "start": [149, 1], "end": [151, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "imports": ["Mathlib/Data/Fintype/Perm.lean", "Mathlib/Algebra/Module/BigOperators.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Equiv/Fintype.lean", "Mathlib/GroupTheory/Perm/List.lean", "Mathlib/Data/Finset/NoncommProd.lean"], "premises": [{"full_name": "Equiv.Perm.SameCycle", "code": "def SameCycle (f : Perm \u03b1) (x y : \u03b1) : Prop :=\n  \u2203 i : \u2124, (f ^ i) x = y", "start": [72, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.refl", "code": "@[refl]\ntheorem SameCycle.refl (f : Perm \u03b1) (x : \u03b1) : SameCycle f x x", "start": [77, 1], "end": [79, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.rfl", "code": "theorem SameCycle.rfl : SameCycle f x x", "start": [82, 1], "end": [83, 21], "kind": "commanddeclaration"}, {"full_name": "Eq.sameCycle", "code": "protected theorem _root_.Eq.sameCycle (h : x = y) (f : Perm \u03b1) : f.SameCycle x y", "start": [86, 1], "end": [86, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.symm", "code": "@[symm]\ntheorem SameCycle.symm : SameCycle f x y \u2192 SameCycle f y x", "start": [89, 1], "end": [91, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_comm", "code": "theorem sameCycle_comm : SameCycle f x y \u2194 SameCycle f y x", "start": [94, 1], "end": [95, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.trans", "code": "@[trans]\ntheorem SameCycle.trans : SameCycle f x y \u2192 SameCycle f y z \u2192 SameCycle f x z", "start": [98, 1], "end": [100, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.equivalence", "code": "theorem SameCycle.equivalence : Equivalence (SameCycle f)", "start": [104, 1], "end": [105, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.setoid", "code": "def SameCycle.setoid (f : Perm \u03b1) : Setoid \u03b1 where\n  iseqv := SameCycle.equivalence f", "start": [107, 1], "end": [109, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_one", "code": "@[simp]\ntheorem sameCycle_one : SameCycle 1 x y \u2194 x = y", "start": [111, 1], "end": [112, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_inv", "code": "@[simp]\ntheorem sameCycle_inv : SameCycle f\u207b\u00b9 x y \u2194 SameCycle f x y", "start": [115, 1], "end": [117, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.of_inv", "code": "alias \u27e8SameCycle.of_inv, SameCycle.inv\u27e9 := sameCycle_inv", "start": [120, 1], "end": [120, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.inv", "code": "alias \u27e8SameCycle.of_inv, SameCycle.inv\u27e9 := sameCycle_inv", "start": [120, 1], "end": [120, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.sameCycle_conj", "code": "@[simp]\ntheorem sameCycle_conj : SameCycle (g * f * g\u207b\u00b9) x y \u2194 SameCycle f (g\u207b\u00b9 x) (g\u207b\u00b9 y)", "start": [124, 1], "end": [126, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.conj", "code": "theorem SameCycle.conj : SameCycle f x y \u2192 SameCycle (g * f * g\u207b\u00b9) (g x) (g y)", "start": [129, 1], "end": [130, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.apply_eq_self_iff", "code": "theorem SameCycle.apply_eq_self_iff : SameCycle f x y \u2192 (f x = x \u2194 f y = y)", "start": [133, 1], "end": [135, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.eq_of_left", "code": "theorem SameCycle.eq_of_left (h : SameCycle f x y) (hx : IsFixedPt f x) : x = y", "start": [138, 1], "end": [140, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.eq_of_right", "code": "theorem SameCycle.eq_of_right (h : SameCycle f x y) (hy : IsFixedPt f y) : x = y", "start": [143, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_apply_left", "code": "@[simp]\ntheorem sameCycle_apply_left : SameCycle f (f x) y \u2194 SameCycle f x y", "start": [147, 1], "end": [150, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_apply_right", "code": "@[simp]\ntheorem sameCycle_apply_right : SameCycle f x (f y) \u2194 SameCycle f x y", "start": [153, 1], "end": [155, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_inv_apply_left", "code": "@[simp]\ntheorem sameCycle_inv_apply_left : SameCycle f (f\u207b\u00b9 x) y \u2194 SameCycle f x y", "start": [158, 1], "end": [160, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_inv_apply_right", "code": "@[simp]\ntheorem sameCycle_inv_apply_right : SameCycle f x (f\u207b\u00b9 y) \u2194 SameCycle f x y", "start": [163, 1], "end": [165, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_zpow_left", "code": "@[simp]\ntheorem sameCycle_zpow_left {n : \u2124} : SameCycle f ((f ^ n) x) y \u2194 SameCycle f x y", "start": [168, 1], "end": [170, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_zpow_right", "code": "@[simp]\ntheorem sameCycle_zpow_right {n : \u2124} : SameCycle f x ((f ^ n) y) \u2194 SameCycle f x y", "start": [173, 1], "end": [175, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_pow_left", "code": "@[simp]\ntheorem sameCycle_pow_left {n : \u2115} : SameCycle f ((f ^ n) x) y \u2194 SameCycle f x y", "start": [178, 1], "end": [180, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_pow_right", "code": "@[simp]\ntheorem sameCycle_pow_right {n : \u2115} : SameCycle f x ((f ^ n) y) \u2194 SameCycle f x y", "start": [183, 1], "end": [185, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.of_apply_left", "code": "alias \u27e8SameCycle.of_apply_left, SameCycle.apply_left\u27e9 := sameCycle_apply_left", "start": [188, 1], "end": [188, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.apply_left", "code": "alias \u27e8SameCycle.of_apply_left, SameCycle.apply_left\u27e9 := sameCycle_apply_left", "start": [188, 1], "end": [188, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_apply_right", "code": "alias \u27e8SameCycle.of_apply_right, SameCycle.apply_right\u27e9 := sameCycle_apply_right", "start": [192, 1], "end": [192, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.apply_right", "code": "alias \u27e8SameCycle.of_apply_right, SameCycle.apply_right\u27e9 := sameCycle_apply_right", "start": [192, 1], "end": [192, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_inv_apply_left", "code": "alias \u27e8SameCycle.of_inv_apply_left, SameCycle.inv_apply_left\u27e9 := sameCycle_inv_apply_left", "start": [196, 1], "end": [196, 90], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.inv_apply_left", "code": "alias \u27e8SameCycle.of_inv_apply_left, SameCycle.inv_apply_left\u27e9 := sameCycle_inv_apply_left", "start": [196, 1], "end": [196, 90], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_inv_apply_right", "code": "alias \u27e8SameCycle.of_inv_apply_right, SameCycle.inv_apply_right\u27e9 := sameCycle_inv_apply_right", "start": [200, 1], "end": [200, 93], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.inv_apply_right", "code": "alias \u27e8SameCycle.of_inv_apply_right, SameCycle.inv_apply_right\u27e9 := sameCycle_inv_apply_right", "start": [200, 1], "end": [200, 93], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_pow_left", "code": "alias \u27e8SameCycle.of_pow_left, SameCycle.pow_left\u27e9 := sameCycle_pow_left", "start": [204, 1], "end": [204, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.pow_left", "code": "alias \u27e8SameCycle.of_pow_left, SameCycle.pow_left\u27e9 := sameCycle_pow_left", "start": [204, 1], "end": [204, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_pow_right", "code": "alias \u27e8SameCycle.of_pow_right, SameCycle.pow_right\u27e9 := sameCycle_pow_right", "start": [208, 1], "end": [208, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.pow_right", "code": "alias \u27e8SameCycle.of_pow_right, SameCycle.pow_right\u27e9 := sameCycle_pow_right", "start": [208, 1], "end": [208, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_zpow_left", "code": "alias \u27e8SameCycle.of_zpow_left, SameCycle.zpow_left\u27e9 := sameCycle_zpow_left", "start": [212, 1], "end": [212, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.zpow_left", "code": "alias \u27e8SameCycle.of_zpow_left, SameCycle.zpow_left\u27e9 := sameCycle_zpow_left", "start": [212, 1], "end": [212, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_zpow_right", "code": "alias \u27e8SameCycle.of_zpow_right, SameCycle.zpow_right\u27e9 := sameCycle_zpow_right", "start": [216, 1], "end": [216, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.zpow_right", "code": "alias \u27e8SameCycle.of_zpow_right, SameCycle.zpow_right\u27e9 := sameCycle_zpow_right", "start": [216, 1], "end": [216, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.of_pow", "code": "theorem SameCycle.of_pow {n : \u2115} : SameCycle (f ^ n) x y \u2192 SameCycle f x y", "start": [220, 1], "end": [221, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.of_zpow", "code": "theorem SameCycle.of_zpow {n : \u2124} : SameCycle (f ^ n) x y \u2192 SameCycle f x y", "start": [224, 1], "end": [225, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sameCycle_subtypePerm", "code": "@[simp]\ntheorem sameCycle_subtypePerm {h} {x y : { x // p x }} :\n    (f.subtypePerm h).SameCycle x y \u2194 f.SameCycle x y", "start": [228, 1], "end": [231, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.subtypePerm", "code": "alias \u27e8_, SameCycle.subtypePerm\u27e9 := sameCycle_subtypePerm", "start": [234, 1], "end": [234, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.sameCycle_extendDomain", "code": "@[simp]\ntheorem sameCycle_extendDomain {p : \u03b2 \u2192 Prop} [DecidablePred p] {f : \u03b1 \u2243 Subtype p} :\n    SameCycle (g.extendDomain f) (f x) (f y) \u2194 g.SameCycle x y", "start": [237, 1], "end": [241, 92], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.extendDomain", "code": "alias \u27e8_, SameCycle.extendDomain\u27e9 := sameCycle_extendDomain", "start": [244, 1], "end": [244, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.SameCycle.exists_pow_eq'", "code": "theorem SameCycle.exists_pow_eq' [Finite \u03b1] : SameCycle f x y \u2192 \u2203 i < orderOf f, (f ^ i) x = y", "start": [247, 1], "end": [256, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.exists_pow_eq''", "code": "theorem SameCycle.exists_pow_eq'' [Finite \u03b1] (h : SameCycle f x y) :\n    \u2203 (i : \u2115) (_ : 0 < i) (_ : i \u2264 orderOf f), (f ^ i) x = y", "start": [259, 1], "end": [265, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle", "code": "def IsCycle (f : Perm \u03b1) : Prop :=\n  \u2203 x, f x \u2260 x \u2227 \u2200 \u2983y\u2984, f y \u2260 y \u2192 SameCycle f x y", "start": [290, 1], "end": [293, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.ne_one", "code": "theorem IsCycle.ne_one (h : IsCycle f) : f \u2260 1", "start": [296, 1], "end": [296, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.not_isCycle_one", "code": "@[simp]\ntheorem not_isCycle_one : \u00ac(1 : Perm \u03b1).IsCycle", "start": [299, 1], "end": [300, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.sameCycle", "code": "protected theorem IsCycle.sameCycle (hf : IsCycle f) (hx : f x \u2260 x) (hy : f y \u2260 y) :\n    SameCycle f x y", "start": [303, 1], "end": [308, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.exists_zpow_eq", "code": "theorem IsCycle.exists_zpow_eq : IsCycle f \u2192 f x \u2260 x \u2192 f y \u2260 y \u2192 \u2203 i : \u2124, (f ^ i) x = y", "start": [311, 1], "end": [312, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.inv", "code": "theorem IsCycle.inv (hf : IsCycle f) : IsCycle f\u207b\u00b9", "start": [315, 1], "end": [317, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_inv", "code": "@[simp]\ntheorem isCycle_inv : IsCycle f\u207b\u00b9 \u2194 IsCycle f", "start": [320, 1], "end": [322, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.conj", "code": "theorem IsCycle.conj : IsCycle f \u2192 IsCycle (g * f * g\u207b\u00b9)", "start": [325, 1], "end": [329, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.extendDomain", "code": "protected theorem IsCycle.extendDomain {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p) :\n    IsCycle g \u2192 IsCycle (g.extendDomain f)", "start": [332, 1], "end": [342, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_iff_sameCycle", "code": "theorem isCycle_iff_sameCycle (hx : f x \u2260 x) : IsCycle f \u2194 \u2200 {y}, SameCycle f x y \u2194 f y \u2260 y", "start": [345, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.exists_pow_eq", "code": "theorem IsCycle.exists_pow_eq (hf : IsCycle f) (hx : f x \u2260 x) (hy : f y \u2260 y) :\n    \u2203 i : \u2115, (f ^ i) x = y", "start": [359, 1], "end": [365, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_swap", "code": "theorem isCycle_swap (hxy : x \u2260 y) : IsCycle (swap x y)", "start": [372, 1], "end": [378, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsSwap.isCycle", "code": "protected theorem IsSwap.isCycle : IsSwap f \u2192 IsCycle f", "start": [381, 1], "end": [383, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.two_le_card_support", "code": "theorem IsCycle.two_le_card_support (h : IsCycle f) : 2 \u2264 f.support.card", "start": [388, 1], "end": [389, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.exists_pow_eq_one", "code": "theorem IsCycle.exists_pow_eq_one [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) :\n    \u2203 (k : \u2115) (_ : 1 < k), f ^ k = 1", "start": [392, 1], "end": [402, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.zpowersEquivSupport", "code": "noncomputable def IsCycle.zpowersEquivSupport {\u03c3 : Perm \u03b1} (h\u03c3 : IsCycle \u03c3) :\n    (Subgroup.zpowers \u03c3) \u2243 \u03c3.support :=\n  Equiv.ofBijective\n    (fun (\u03c4 : \u21a5 ((Subgroup.zpowers \u03c3) : Set (Perm \u03b1))) =>\n      \u27e8(\u03c4 : Perm \u03b1) (Classical.choose h\u03c3), by\n        obtain \u27e8\u03c4, n, rfl\u27e9 := \u03c4\n        erw [Finset.mem_coe, Subtype.coe_mk, zpow_apply_mem_support, mem_support]\n        exact (Classical.choose_spec h\u03c3).1\u27e9)\n    (by\n      constructor\n      \u00b7 rintro \u27e8a, m, rfl\u27e9 \u27e8b, n, rfl\u27e9 h\n        ext y\n        by_cases hy : \u03c3 y = y\n        \u00b7 simp_rw [zpow_apply_eq_self_of_apply_eq_self hy]\n        \u00b7 obtain \u27e8i, rfl\u27e9 := (Classical.choose_spec h\u03c3).2 hy\n          rw [Subtype.coe_mk, Subtype.coe_mk, zpow_apply_comm \u03c3 m i, zpow_apply_comm \u03c3 n i]\n          exact congr_arg _ (Subtype.ext_iff.mp h)\n      \u00b7 rintro \u27e8y, hy\u27e9\n        erw [Finset.mem_coe, mem_support] at hy\n        obtain \u27e8n, rfl\u27e9 := (Classical.choose_spec h\u03c3).2 hy\n        exact \u27e8\u27e8\u03c3 ^ n, n, rfl\u27e9, rfl\u27e9)", "start": [405, 1], "end": [426, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.zpowersEquivSupport_apply", "code": "@[simp]\ntheorem IsCycle.zpowersEquivSupport_apply {\u03c3 : Perm \u03b1} (h\u03c3 : IsCycle \u03c3) {n : \u2115} :\n    h\u03c3.zpowersEquivSupport \u27e8\u03c3 ^ n, n, rfl\u27e9 =\n      \u27e8(\u03c3 ^ n) (Classical.choose h\u03c3),\n        pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec h\u03c3).1)\u27e9", "start": [429, 1], "end": [434, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.zpowersEquivSupport_symm_apply", "code": "@[simp]\ntheorem IsCycle.zpowersEquivSupport_symm_apply {\u03c3 : Perm \u03b1} (h\u03c3 : IsCycle \u03c3) (n : \u2115) :\n    h\u03c3.zpowersEquivSupport.symm\n        \u27e8(\u03c3 ^ n) (Classical.choose h\u03c3),\n          pow_apply_mem_support.2 (mem_support.2 (Classical.choose_spec h\u03c3).1)\u27e9 =\n      \u27e8\u03c3 ^ n, n, rfl\u27e9", "start": [437, 1], "end": [443, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.orderOf", "code": "protected theorem IsCycle.orderOf (hf : IsCycle f) : orderOf f = f.support.card", "start": [446, 1], "end": [448, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_swap_mul_aux\u2081", "code": "theorem isCycle_swap_mul_aux\u2081 {\u03b1 : Type*} [DecidableEq \u03b1] :\n    \u2200 (n : \u2115) {b x : \u03b1} {f : Perm \u03b1} (_ : (swap x (f x) * f) b \u2260 b) (_ : (f ^ n) (f x) = b),\n      \u2203 i : \u2124, ((swap x (f x) * f) ^ i) (f x) = b", "start": [451, 1], "end": [469, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_swap_mul_aux\u2082", "code": "theorem isCycle_swap_mul_aux\u2082 {\u03b1 : Type*} [DecidableEq \u03b1] :\n    \u2200 (n : \u2124) {b x : \u03b1} {f : Perm \u03b1} (_ : (swap x (f x) * f) b \u2260 b) (_ : (f ^ n) (f x) = b),\n      \u2203 i : \u2124, ((swap x (f x) * f) ^ i) (f x) = b", "start": [472, 1], "end": [500, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.eq_swap_of_apply_apply_eq_self", "code": "theorem IsCycle.eq_swap_of_apply_apply_eq_self {\u03b1 : Type*} [DecidableEq \u03b1] {f : Perm \u03b1}\n    (hf : IsCycle f) {x : \u03b1} (hfx : f x \u2260 x) (hffx : f (f x) = x) : f = swap x (f x)", "start": [503, 1], "end": [520, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.swap_mul", "code": "theorem IsCycle.swap_mul {\u03b1 : Type*} [DecidableEq \u03b1] {f : Perm \u03b1} (hf : IsCycle f) {x : \u03b1}\n    (hx : f x \u2260 x) (hffx : f (f x) \u2260 x) : IsCycle (swap x (f x) * f)", "start": [523, 1], "end": [534, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.sign", "code": "theorem IsCycle.sign {f : Perm \u03b1} (hf : IsCycle f) : sign f = -(-1) ^ f.support.card", "start": [537, 1], "end": [560, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.of_pow", "code": "theorem IsCycle.of_pow {n : \u2115} (h1 : IsCycle (f ^ n)) (h2 : f.support \u2286 (f ^ n).support) :\n    IsCycle f", "start": [563, 1], "end": [571, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.of_zpow", "code": "theorem IsCycle.of_zpow {n : \u2124} (h1 : IsCycle (f ^ n)) (h2 : f.support \u2286 (f ^ n).support) :\n    IsCycle f", "start": [576, 1], "end": [581, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.nodup_of_pairwise_disjoint_cycles", "code": "theorem nodup_of_pairwise_disjoint_cycles {l : List (Perm \u03b2)} (h1 : \u2200 f \u2208 l, IsCycle f)\n    (h2 : l.Pairwise Disjoint) : l.Nodup", "start": [584, 1], "end": [586, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.support_congr", "code": "theorem IsCycle.support_congr (hf : IsCycle f) (hg : IsCycle g) (h : f.support \u2286 g.support)\n    (h' : \u2200 x \u2208 f.support, f x = g x) : f = g", "start": [589, 1], "end": [607, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.eq_on_support_inter_nonempty_congr", "code": "theorem IsCycle.eq_on_support_inter_nonempty_congr (hf : IsCycle f) (hg : IsCycle g)\n    (h : \u2200 x \u2208 f.support \u2229 g.support, f x = g x)\n    (hx : f x = g x) (hx' : x \u2208 f.support) : f = g", "start": [610, 1], "end": [621, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.support_pow_eq_iff", "code": "theorem IsCycle.support_pow_eq_iff (hf : IsCycle f) {n : \u2115} :\n    support (f ^ n) = support f \u2194 \u00acorderOf f \u2223 n", "start": [624, 1], "end": [641, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.support_pow_of_pos_of_lt_orderOf", "code": "theorem IsCycle.support_pow_of_pos_of_lt_orderOf (hf : IsCycle f) {n : \u2115} (npos : 0 < n)\n    (hn : n < orderOf f) : (f ^ n).support = f.support", "start": [644, 1], "end": [646, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.pow_iff", "code": "theorem IsCycle.pow_iff [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) {n : \u2115} :\n    IsCycle (f ^ n) \u2194 n.Coprime (orderOf f)", "start": [649, 1], "end": [670, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.pow_eq_one_iff", "code": "theorem IsCycle.pow_eq_one_iff [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) {n : \u2115} :\n    f ^ n = 1 \u2194 \u2203 x, f x \u2260 x \u2227 (f ^ n) x = x", "start": [674, 1], "end": [688, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.pow_eq_one_iff'", "code": "theorem IsCycle.pow_eq_one_iff' [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) {n : \u2115} {x : \u03b2}\n    (hx : f x \u2260 x) : f ^ n = 1 \u2194 (f ^ n) x = x", "start": [692, 1], "end": [694, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.pow_eq_one_iff''", "code": "theorem IsCycle.pow_eq_one_iff'' [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) {n : \u2115} :\n    f ^ n = 1 \u2194 \u2200 x, f x \u2260 x \u2192 (f ^ n) x = x", "start": [698, 1], "end": [702, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.pow_eq_pow_iff", "code": "theorem IsCycle.pow_eq_pow_iff [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f) {a b : \u2115} :\n    f ^ a = f ^ b \u2194 \u2203 x, f x \u2260 x \u2227 (f ^ a) x = (f ^ b) x", "start": [706, 1], "end": [727, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.isCycle_pow_pos_of_lt_prime_order", "code": "theorem IsCycle.isCycle_pow_pos_of_lt_prime_order [Finite \u03b2] {f : Perm \u03b2} (hf : IsCycle f)\n    (hf' : (orderOf f).Prime) (n : \u2115) (hn : 0 < n) (hn' : n < orderOf f) : IsCycle (f ^ n)", "start": [730, 1], "end": [743, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn", "code": "def IsCycleOn (f : Perm \u03b1) (s : Set \u03b1) : Prop :=\n  Set.BijOn f s s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 f.SameCycle x y", "start": [755, 1], "end": [758, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_empty", "code": "@[simp]\ntheorem isCycleOn_empty : f.IsCycleOn \u2205", "start": [761, 1], "end": [762, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_one", "code": "@[simp]\ntheorem isCycleOn_one : (1 : Perm \u03b1).IsCycleOn s \u2194 s.Subsingleton", "start": [765, 1], "end": [767, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.subsingleton", "code": "alias \u27e8IsCycleOn.subsingleton, _root_.Set.Subsingleton.isCycleOn_one\u27e9 := isCycleOn_one", "start": [770, 1], "end": [770, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Subsingleton.isCycleOn_one", "code": "alias \u27e8IsCycleOn.subsingleton, _root_.Set.Subsingleton.isCycleOn_one\u27e9 := isCycleOn_one", "start": [770, 1], "end": [770, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.isCycleOn_singleton", "code": "@[simp]\ntheorem isCycleOn_singleton : f.IsCycleOn {a} \u2194 f a = a", "start": [774, 1], "end": [775, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_of_subsingleton", "code": "theorem isCycleOn_of_subsingleton [Subsingleton \u03b1] (f : Perm \u03b1) (s : Set \u03b1) : f.IsCycleOn s", "start": [778, 1], "end": [779, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_inv", "code": "@[simp]\ntheorem isCycleOn_inv : f\u207b\u00b9.IsCycleOn s \u2194 f.IsCycleOn s", "start": [782, 1], "end": [785, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.of_inv", "code": "alias \u27e8IsCycleOn.of_inv, IsCycleOn.inv\u27e9 := isCycleOn_inv", "start": [788, 1], "end": [788, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.IsCycleOn.inv", "code": "alias \u27e8IsCycleOn.of_inv, IsCycleOn.inv\u27e9 := isCycleOn_inv", "start": [788, 1], "end": [788, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.Perm.IsCycleOn.conj", "code": "theorem IsCycleOn.conj (h : f.IsCycleOn s) : (g * f * g\u207b\u00b9).IsCycleOn ((g : Perm \u03b1) '' s)", "start": [792, 1], "end": [795, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_swap", "code": "theorem isCycleOn_swap [DecidableEq \u03b1] (hab : a \u2260 b) : (swap a b).IsCycleOn {a, b}", "start": [798, 1], "end": [805, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.apply_ne", "code": "protected theorem IsCycleOn.apply_ne (hf : f.IsCycleOn s) (hs : s.Nontrivial) (ha : a \u2208 s) :\n    f a \u2260 a", "start": [808, 1], "end": [812, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.isCycleOn", "code": "protected theorem IsCycle.isCycleOn (hf : f.IsCycle) : f.IsCycleOn { x | f x \u2260 x }", "start": [815, 1], "end": [816, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_iff_exists_isCycleOn", "code": "theorem isCycle_iff_exists_isCycleOn :\n    f.IsCycle \u2194 \u2203 s : Set \u03b1, s.Nontrivial \u2227 f.IsCycleOn s \u2227 \u2200 \u2983x\u2984, \u00acIsFixedPt f x \u2192 x \u2208 s", "start": [819, 1], "end": [828, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.apply_mem_iff", "code": "theorem IsCycleOn.apply_mem_iff (hf : f.IsCycleOn s) : f x \u2208 s \u2194 x \u2208 s", "start": [831, 1], "end": [834, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.isCycle_subtypePerm", "code": "theorem IsCycleOn.isCycle_subtypePerm (hf : f.IsCycleOn s) (hs : s.Nontrivial) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycle", "start": [837, 1], "end": [843, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.subtypePerm", "code": "protected theorem IsCycleOn.subtypePerm (hf : f.IsCycleOn s) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycleOn _root_.Set.univ", "start": [846, 1], "end": [854, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.pow_apply_eq", "code": "theorem IsCycleOn.pow_apply_eq {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s) {n : \u2115} :\n    (f ^ n) a = a \u2194 s.card \u2223 n", "start": [858, 1], "end": [875, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.zpow_apply_eq", "code": "theorem IsCycleOn.zpow_apply_eq {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s) :\n    \u2200 {n : \u2124}, (f ^ n) a = a \u2194 (s.card : \u2124) \u2223 n", "start": [878, 1], "end": [883, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.pow_apply_eq_pow_apply", "code": "theorem IsCycleOn.pow_apply_eq_pow_apply {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s)\n    {m n : \u2115} : (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [MOD s.card]", "start": [886, 1], "end": [889, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.zpow_apply_eq_zpow_apply", "code": "theorem IsCycleOn.zpow_apply_eq_zpow_apply {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s)\n    {m n : \u2124} : (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [ZMOD s.card]", "start": [892, 1], "end": [895, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.pow_card_apply", "code": "theorem IsCycleOn.pow_card_apply {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s) :\n    (f ^ s.card) a = a", "start": [898, 1], "end": [900, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.exists_pow_eq", "code": "theorem IsCycleOn.exists_pow_eq {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s) (hb : b \u2208 s) :\n    \u2203 n < s.card, (f ^ n) a = b", "start": [903, 1], "end": [913, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.exists_pow_eq'", "code": "theorem IsCycleOn.exists_pow_eq' (hs : s.Finite) (hf : f.IsCycleOn s) (ha : a \u2208 s) (hb : b \u2208 s) :\n    \u2203 n : \u2115, (f ^ n) a = b", "start": [916, 1], "end": [920, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.range_pow", "code": "theorem IsCycleOn.range_pow (hs : s.Finite) (h : f.IsCycleOn s) (ha : a \u2208 s) :\n    Set.range (fun n => (f ^ n) a : \u2115 \u2192 \u03b1) = s", "start": [923, 1], "end": [926, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.range_zpow", "code": "theorem IsCycleOn.range_zpow (h : f.IsCycleOn s) (ha : a \u2208 s) :\n    Set.range (fun n => (f ^ n) a : \u2124 \u2192 \u03b1) = s", "start": [929, 1], "end": [931, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.of_pow", "code": "theorem IsCycleOn.of_pow {n : \u2115} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) : f.IsCycleOn s", "start": [934, 1], "end": [935, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.of_zpow", "code": "theorem IsCycleOn.of_zpow {n : \u2124} (hf : (f ^ n).IsCycleOn s) (h : Set.BijOn f s s) :\n    f.IsCycleOn s", "start": [938, 1], "end": [940, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.extendDomain", "code": "theorem IsCycleOn.extendDomain {p : \u03b2 \u2192 Prop} [DecidablePred p] (f : \u03b1 \u2243 Subtype p)\n    (h : g.IsCycleOn s) : (g.extendDomain f).IsCycleOn ((\u2191) \u2218 f '' s)", "start": [943, 1], "end": [947, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycleOn.countable", "code": "protected theorem IsCycleOn.countable (hs : f.IsCycleOn s) : s.Countable", "start": [950, 1], "end": [953, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf", "code": "def cycleOf (f : Perm \u03b1) (x : \u03b1) : Perm \u03b1 :=\n  ofSubtype (subtypePerm f fun _ => sameCycle_apply_right.symm : Perm { y // SameCycle f x y })", "start": [967, 1], "end": [969, 96], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply", "code": "theorem cycleOf_apply (f : Perm \u03b1) (x y : \u03b1) :\n    cycleOf f x y = if SameCycle f x y then f y else y", "start": [972, 1], "end": [979, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_inv", "code": "theorem cycleOf_inv (f : Perm \u03b1) (x : \u03b1) : (cycleOf f x)\u207b\u00b9 = cycleOf f\u207b\u00b9 x", "start": [982, 1], "end": [985, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_pow_apply_self", "code": "@[simp]\ntheorem cycleOf_pow_apply_self (f : Perm \u03b1) (x : \u03b1) : \u2200 n : \u2115, (cycleOf f x ^ n) x = (f ^ n) x", "start": [988, 1], "end": [994, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_zpow_apply_self", "code": "@[simp]\ntheorem cycleOf_zpow_apply_self (f : Perm \u03b1) (x : \u03b1) :\n    \u2200 n : \u2124, (cycleOf f x ^ n) x = (f ^ n) x", "start": [997, 1], "end": [1003, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.cycleOf_apply", "code": "theorem SameCycle.cycleOf_apply : SameCycle f x y \u2192 cycleOf f x y = f y", "start": [1006, 1], "end": [1007, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply_of_not_sameCycle", "code": "theorem cycleOf_apply_of_not_sameCycle : \u00acSameCycle f x y \u2192 cycleOf f x y = y", "start": [1010, 1], "end": [1011, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.cycleOf_eq", "code": "theorem SameCycle.cycleOf_eq (h : SameCycle f x y) : cycleOf f x = cycleOf f y", "start": [1014, 1], "end": [1019, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply_apply_zpow_self", "code": "@[simp]\ntheorem cycleOf_apply_apply_zpow_self (f : Perm \u03b1) (x : \u03b1) (k : \u2124) :\n    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm \u03b1) x", "start": [1022, 1], "end": [1027, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply_apply_pow_self", "code": "@[simp]\ntheorem cycleOf_apply_apply_pow_self (f : Perm \u03b1) (x : \u03b1) (k : \u2115) :\n    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm \u03b1) x", "start": [1030, 1], "end": [1033, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply_apply_self", "code": "@[simp]\ntheorem cycleOf_apply_apply_self (f : Perm \u03b1) (x : \u03b1) : cycleOf f x (f x) = f (f x)", "start": [1036, 1], "end": [1038, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_apply_self", "code": "@[simp]\ntheorem cycleOf_apply_self (f : Perm \u03b1) (x : \u03b1) : cycleOf f x x = f x", "start": [1041, 1], "end": [1043, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.cycleOf_eq", "code": "theorem IsCycle.cycleOf_eq (hf : IsCycle f) (hx : f x \u2260 x) : cycleOf f x = f", "start": [1046, 1], "end": [1051, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_eq_one_iff", "code": "@[simp]\ntheorem cycleOf_eq_one_iff (f : Perm \u03b1) : cycleOf f x = 1 \u2194 f x = x", "start": [1054, 1], "end": [1060, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_self_apply", "code": "@[simp]\ntheorem cycleOf_self_apply (f : Perm \u03b1) (x : \u03b1) : cycleOf f (f x) = cycleOf f x", "start": [1063, 1], "end": [1065, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_self_apply_pow", "code": "@[simp]\ntheorem cycleOf_self_apply_pow (f : Perm \u03b1) (n : \u2115) (x : \u03b1) : cycleOf f ((f ^ n) x) = cycleOf f x", "start": [1068, 1], "end": [1070, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_self_apply_zpow", "code": "@[simp]\ntheorem cycleOf_self_apply_zpow (f : Perm \u03b1) (n : \u2124) (x : \u03b1) :\n    cycleOf f ((f ^ n) x) = cycleOf f x", "start": [1073, 1], "end": [1076, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.cycleOf", "code": "protected theorem IsCycle.cycleOf (hf : IsCycle f) : cycleOf f x = if f x = x then 1 else f", "start": [1079, 1], "end": [1082, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_one", "code": "theorem cycleOf_one (x : \u03b1) : cycleOf 1 x = 1", "start": [1085, 1], "end": [1086, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_cycleOf", "code": "theorem isCycle_cycleOf (f : Perm \u03b1) (hx : f x \u2260 x) : IsCycle (cycleOf f x)", "start": [1089, 1], "end": [1098, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.two_le_card_support_cycleOf_iff", "code": "@[simp]\ntheorem two_le_card_support_cycleOf_iff : 2 \u2264 card (cycleOf f x).support \u2194 f x \u2260 x", "start": [1101, 1], "end": [1106, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_cycleOf_pos_iff", "code": "@[simp]\ntheorem card_support_cycleOf_pos_iff : 0 < card (cycleOf f x).support \u2194 f x \u2260 x", "start": [1109, 1], "end": [1112, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_apply_eq_pow_mod_orderOf_cycleOf_apply", "code": "theorem pow_apply_eq_pow_mod_orderOf_cycleOf_apply (f : Perm \u03b1) (n : \u2115) (x : \u03b1) :\n    (f ^ n) x = (f ^ (n % orderOf (cycleOf f x))) x", "start": [1115, 1], "end": [1117, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_mul_of_apply_right_eq_self", "code": "theorem cycleOf_mul_of_apply_right_eq_self (h : Commute f g) (x : \u03b1) (hx : g x = x) :\n    (f * g).cycleOf x = f.cycleOf x", "start": [1120, 1], "end": [1131, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.cycleOf_mul_distrib", "code": "theorem Disjoint.cycleOf_mul_distrib (h : f.Disjoint g) (x : \u03b1) :\n    (f * g).cycleOf x = f.cycleOf x * g.cycleOf x", "start": [1134, 1], "end": [1138, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_cycleOf_eq_nil_iff", "code": "theorem support_cycleOf_eq_nil_iff : (f.cycleOf x).support = \u2205 \u2194 x \u2209 f.support", "start": [1141, 1], "end": [1141, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_cycleOf_le", "code": "theorem support_cycleOf_le (f : Perm \u03b1) (x : \u03b1) : support (f.cycleOf x) \u2264 support f", "start": [1144, 1], "end": [1149, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_support_cycleOf_iff", "code": "theorem mem_support_cycleOf_iff : y \u2208 support (f.cycleOf x) \u2194 SameCycle f x y \u2227 x \u2208 support f", "start": [1152, 1], "end": [1162, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_support_cycleOf_iff'", "code": "theorem mem_support_cycleOf_iff' (hx : f x \u2260 x) : y \u2208 support (f.cycleOf x) \u2194 SameCycle f x y", "start": [1165, 1], "end": [1166, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.mem_support_iff", "code": "theorem SameCycle.mem_support_iff (h : SameCycle f x y) : x \u2208 support f \u2194 y \u2208 support f", "start": [1169, 1], "end": [1171, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_mod_card_support_cycleOf_self_apply", "code": "theorem pow_mod_card_support_cycleOf_self_apply (f : Perm \u03b1) (n : \u2115) (x : \u03b1) :\n    (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x", "start": [1174, 1], "end": [1179, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_cycleOf_iff", "code": "theorem isCycle_cycleOf_iff (f : Perm \u03b1) : IsCycle (cycleOf f x) \u2194 f x \u2260 x", "start": [1182, 1], "end": [1186, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycleOn_support_cycleOf", "code": "theorem isCycleOn_support_cycleOf (f : Perm \u03b1) (x : \u03b1) : f.IsCycleOn (f.cycleOf x).support", "start": [1189, 1], "end": [1199, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.exists_pow_eq_of_mem_support", "code": "theorem SameCycle.exists_pow_eq_of_mem_support (h : SameCycle f x y) (hx : x \u2208 f.support) :\n    \u2203 (i : \u2115) (_ : i < (f.cycleOf x).support.card), (f ^ i) x = y", "start": [1202, 1], "end": [1208, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.SameCycle.exists_pow_eq", "code": "theorem SameCycle.exists_pow_eq (f : Perm \u03b1) (h : SameCycle f x y) :\n    \u2203 (i : \u2115) (_ : 0 < i) (_ : i \u2264 (f.cycleOf x).support.card + 1), (f ^ i) x = y", "start": [1211, 1], "end": [1227, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsAux", "code": "def cycleFactorsAux [Fintype \u03b1] :\n    \u2200 (l : List \u03b1) (f : Perm \u03b1),\n      (\u2200 {x}, f x \u2260 x \u2192 x \u2208 l) \u2192\n        { l : List (Perm \u03b1) // l.prod = f \u2227 (\u2200 g \u2208 l, IsCycle g) \u2227 l.Pairwise Disjoint } := by\n  intro l f h\n  exact match l with\n  | [] => \u27e8[], by\n      { simp only [imp_false, List.Pairwise.nil, List.not_mem_nil, forall_const, and_true_iff,\n          forall_prop_of_false, Classical.not_not, not_false_iff, List.prod_nil] at *\n        ext\n        simp [*]}\u27e9\n  | x::l =>\n    if hx : f x = x then cycleFactorsAux l f (by\n        intro y hy; exact List.mem_of_ne_of_mem (fun h => hy (by rwa [h])) (h hy))\n    else\n      let \u27e8m, hm\u2081, hm\u2082, hm\u2083\u27e9 :=\n        cycleFactorsAux l ((cycleOf f x)\u207b\u00b9 * f) (by\n        intro y hy\n        exact List.mem_of_ne_of_mem\n            (fun h : y = x => by\n              rw [h, mul_apply, Ne.def, inv_eq_iff_eq, cycleOf_apply_self] at hy\n              exact hy rfl)\n            (h fun h : f y = y => by\n              rw [mul_apply, h, Ne.def, inv_eq_iff_eq, cycleOf_apply] at hy\n              split_ifs at hy <;> tauto))\n      \u27e8cycleOf f x::m, by\n        rw [List.prod_cons, hm\u2081]\n        simp,\n        fun g hg \u21a6 ((List.mem_cons).1 hg).elim (fun hg => hg.symm \u25b8 isCycle_cycleOf _ hx) (hm\u2082 g),\n        List.pairwise_cons.2\n          \u27e8fun g hg y =>\n            or_iff_not_imp_left.2 fun hfy =>\n              have hxy : SameCycle f x y :=\n                Classical.not_not.1 (mt cycleOf_apply_of_not_sameCycle hfy)\n              have hgm : (g::m.erase g) ~ m :=\n                List.cons_perm_iff_perm_erase.2 \u27e8hg, List.Perm.refl _\u27e9\n              have : \u2200 h \u2208 m.erase g, Disjoint g h :=\n                (List.pairwise_cons.1\n                    ((hgm.pairwise_iff fun a b (h : Disjoint a b) => h.symm).2 hm\u2083)).1\n              by_cases id fun hgy : g y \u2260 y =>\n                (disjoint_prod_right _ this y).resolve_right <| by\n                  have hsc : SameCycle f\u207b\u00b9 x (f y) := by\n                    rwa [sameCycle_inv, sameCycle_apply_right]\n                  rw [disjoint_prod_perm hm\u2083 hgm.symm, List.prod_cons,\n                      \u2190 eq_inv_mul_iff_mul_eq] at hm\u2081\n                  rwa [hm\u2081, mul_apply, mul_apply, cycleOf_inv, hsc.cycleOf_apply, inv_apply_self,\n                    inv_eq_iff_eq, eq_comm],\n            hm\u2083\u27e9\u27e9", "start": [1239, 1], "end": [1288, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_list_cycles_iff", "code": "theorem mem_list_cycles_iff {\u03b1 : Type*} [Finite \u03b1] {l : List (Perm \u03b1)}\n    (h1 : \u2200 \u03c3 : Perm \u03b1, \u03c3 \u2208 l \u2192 \u03c3.IsCycle) (h2 : l.Pairwise Disjoint) {\u03c3 : Perm \u03b1} :\n    \u03c3 \u2208 l \u2194 \u03c3.IsCycle \u2227 \u2200 (a : \u03b1) (_ : \u03c3 a \u2260 a), \u03c3 a = l.prod a", "start": [1291, 1], "end": [1316, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.list_cycles_perm_list_cycles", "code": "theorem list_cycles_perm_list_cycles {\u03b1 : Type*} [Finite \u03b1] {l\u2081 l\u2082 : List (Perm \u03b1)}\n    (h\u2080 : l\u2081.prod = l\u2082.prod) (h\u2081l\u2081 : \u2200 \u03c3 : Perm \u03b1, \u03c3 \u2208 l\u2081 \u2192 \u03c3.IsCycle)\n    (h\u2081l\u2082 : \u2200 \u03c3 : Perm \u03b1, \u03c3 \u2208 l\u2082 \u2192 \u03c3.IsCycle) (h\u2082l\u2081 : l\u2081.Pairwise Disjoint)\n    (h\u2082l\u2082 : l\u2082.Pairwise Disjoint) : l\u2081 ~ l\u2082", "start": [1319, 1], "end": [1331, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactors", "code": "def cycleFactors [Fintype \u03b1] [LinearOrder \u03b1] (f : Perm \u03b1) :\n    { l : List (Perm \u03b1) // l.prod = f \u2227 (\u2200 g \u2208 l, IsCycle g) \u2227 l.Pairwise Disjoint } :=\n  cycleFactorsAux (sort (\u03b1 := \u03b1) (\u00b7 \u2264 \u00b7) univ) f (fun {_ _} \u21a6 (mem_sort _).2 (mem_univ _))", "start": [1334, 1], "end": [1337, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.truncCycleFactors", "code": "def truncCycleFactors [Fintype \u03b1] (f : Perm \u03b1) :\n    Trunc { l : List (Perm \u03b1) // l.prod = f \u2227 (\u2200 g \u2208 l, IsCycle g) \u2227 l.Pairwise Disjoint } :=\n  Quotient.recOnSubsingleton (@univ \u03b1 _).1 (fun l h => Trunc.mk (cycleFactorsAux l f (h _)))\n    (show \u2200 x, f x \u2260 x \u2192 x \u2208 (@univ \u03b1 _).1 from fun _ _ => mem_univ _)", "start": [1340, 1], "end": [1345, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset", "code": "def cycleFactorsFinset : Finset (Perm \u03b1) :=\n  (truncCycleFactors f).lift\n    (fun l : { l : List (Perm \u03b1) // l.prod = f \u2227 (\u2200 g \u2208 l, IsCycle g) \u2227 l.Pairwise Disjoint } =>\n      l.val.toFinset)\n    fun \u27e8_, hl\u27e9 \u27e8_, hl'\u27e9 =>\n    List.toFinset_eq_of_perm _ _\n      (list_cycles_perm_list_cycles (hl'.left.symm \u25b8 hl.left) hl.right.left hl'.right.left\n        hl.right.right hl'.right.right)", "start": [1352, 1], "end": [1361, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_eq_list_toFinset", "code": "theorem cycleFactorsFinset_eq_list_toFinset {\u03c3 : Perm \u03b1} {l : List (Perm \u03b1)} (hn : l.Nodup) :\n    \u03c3.cycleFactorsFinset = l.toFinset \u2194\n      (\u2200 f : Perm \u03b1, f \u2208 l \u2192 f.IsCycle) \u2227 l.Pairwise Disjoint \u2227 l.prod = \u03c3", "start": [1364, 1], "end": [1384, 17], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_eq_finset", "code": "theorem cycleFactorsFinset_eq_finset {\u03c3 : Perm \u03b1} {s : Finset (Perm \u03b1)} :\n    \u03c3.cycleFactorsFinset = s \u2194\n      (\u2200 f : Perm \u03b1, f \u2208 s \u2192 f.IsCycle) \u2227\n        \u2203 h : (s : Set (Perm \u03b1)).Pairwise Disjoint,\n          s.noncommProd id (h.mono' fun _ _ => Disjoint.commute) = \u03c3", "start": [1387, 1], "end": [1393, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_pairwise_disjoint", "code": "theorem cycleFactorsFinset_pairwise_disjoint :\n    (cycleFactorsFinset f : Set (Perm \u03b1)).Pairwise Disjoint", "start": [1396, 1], "end": [1398, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_mem_commute", "code": "theorem cycleFactorsFinset_mem_commute : (cycleFactorsFinset f : Set (Perm \u03b1)).Pairwise Commute", "start": [1401, 1], "end": [1402, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_noncommProd", "code": "theorem cycleFactorsFinset_noncommProd\n    (comm : (cycleFactorsFinset f : Set (Perm \u03b1)).Pairwise Commute :=\n      cycleFactorsFinset_mem_commute f) :\n    f.cycleFactorsFinset.noncommProd id comm = f", "start": [1405, 1], "end": [1410, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_cycleFactorsFinset_iff", "code": "theorem mem_cycleFactorsFinset_iff {f p : Perm \u03b1} :\n    p \u2208 cycleFactorsFinset f \u2194 p.IsCycle \u2227 \u2200 a \u2208 p.support, p a = f a", "start": [1413, 1], "end": [1419, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleOf_mem_cycleFactorsFinset_iff", "code": "theorem cycleOf_mem_cycleFactorsFinset_iff {f : Perm \u03b1} {x : \u03b1} :\n    cycleOf f x \u2208 cycleFactorsFinset f \u2194 x \u2208 f.support", "start": [1422, 1], "end": [1438, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_cycleFactorsFinset_support_le", "code": "theorem mem_cycleFactorsFinset_support_le {p f : Perm \u03b1} (h : p \u2208 cycleFactorsFinset f) :\n    p.support \u2264 f.support", "start": [1441, 1], "end": [1445, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_eq_empty_iff", "code": "theorem cycleFactorsFinset_eq_empty_iff {f : Perm \u03b1} : cycleFactorsFinset f = \u2205 \u2194 f = 1", "start": [1448, 1], "end": [1449, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_one", "code": "@[simp]\ntheorem cycleFactorsFinset_one : cycleFactorsFinset (1 : Perm \u03b1) = \u2205", "start": [1452, 1], "end": [1454, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_eq_singleton_self_iff", "code": "@[simp]\ntheorem cycleFactorsFinset_eq_singleton_self_iff {f : Perm \u03b1} :\n    f.cycleFactorsFinset = {f} \u2194 f.IsCycle", "start": [1457, 1], "end": [1459, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.cycleFactorsFinset_eq_singleton", "code": "theorem IsCycle.cycleFactorsFinset_eq_singleton {f : Perm \u03b1} (hf : IsCycle f) :\n    f.cycleFactorsFinset = {f}", "start": [1462, 1], "end": [1464, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_eq_singleton_iff", "code": "theorem cycleFactorsFinset_eq_singleton_iff {f g : Perm \u03b1} :\n    f.cycleFactorsFinset = {g} \u2194 f.IsCycle \u2227 f = g", "start": [1467, 1], "end": [1473, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_injective", "code": "theorem cycleFactorsFinset_injective : Function.Injective (@cycleFactorsFinset \u03b1 _ _)", "start": [1476, 1], "end": [1480, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.disjoint_cycleFactorsFinset", "code": "theorem Disjoint.disjoint_cycleFactorsFinset {f g : Perm \u03b1} (h : Disjoint f g) :\n    _root_.Disjoint (cycleFactorsFinset f) (cycleFactorsFinset g)", "start": [1483, 1], "end": [1491, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.cycleFactorsFinset_mul_eq_union", "code": "theorem Disjoint.cycleFactorsFinset_mul_eq_union {f g : Perm \u03b1} (h : Disjoint f g) :\n    cycleFactorsFinset (f * g) = cycleFactorsFinset f \u222a cycleFactorsFinset g", "start": [1494, 1], "end": [1505, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.disjoint_mul_inv_of_mem_cycleFactorsFinset", "code": "theorem disjoint_mul_inv_of_mem_cycleFactorsFinset {f g : Perm \u03b1} (h : f \u2208 cycleFactorsFinset g) :\n    Disjoint (g * f\u207b\u00b9) f", "start": [1508, 1], "end": [1516, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycle_is_cycleOf", "code": "theorem cycle_is_cycleOf {f c : Equiv.Perm \u03b1} {a : \u03b1} (ha : a \u2208 c.support)\n    (hc : c \u2208 f.cycleFactorsFinset) : c = f.cycleOf a", "start": [1519, 1], "end": [1535, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycle_induction_on", "code": "@[elab_as_elim]\ntheorem cycle_induction_on [Finite \u03b2] (P : Perm \u03b2 \u2192 Prop) (\u03c3 : Perm \u03b2) (base_one : P 1)\n    (base_cycles : \u2200 \u03c3 : Perm \u03b2, \u03c3.IsCycle \u2192 P \u03c3)\n    (induction_disjoint : \u2200 \u03c3 \u03c4 : Perm \u03b2,\n      Disjoint \u03c3 \u03c4 \u2192 IsCycle \u03c3 \u2192 P \u03c3 \u2192 P \u03c4 \u2192 P (\u03c3 * \u03c4)) : P \u03c3", "start": [1540, 1], "end": [1559, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleFactorsFinset_mul_inv_mem_eq_sdiff", "code": "theorem cycleFactorsFinset_mul_inv_mem_eq_sdiff [Fintype \u03b1] {f g : Perm \u03b1}\n    (h : f \u2208 cycleFactorsFinset g) : cycleFactorsFinset (g * f\u207b\u00b9) = cycleFactorsFinset g \\ {f}", "start": [1562, 1], "end": [1606, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_isCycle", "code": "theorem closure_isCycle : closure { \u03c3 : Perm \u03b2 | IsCycle \u03c3 } = \u22a4", "start": [1615, 1], "end": [1619, 96], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_cycle_adjacent_swap", "code": "theorem closure_cycle_adjacent_swap {\u03c3 : Perm \u03b1} (h1 : IsCycle \u03c3) (h2 : \u03c3.support = \u22a4) (x : \u03b1) :\n    closure ({\u03c3, swap x (\u03c3 x)} : Set (Perm \u03b1)) = \u22a4", "start": [1624, 1], "end": [1671, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_cycle_coprime_swap", "code": "theorem closure_cycle_coprime_swap {n : \u2115} {\u03c3 : Perm \u03b1} (h0 : Nat.Coprime n (Fintype.card \u03b1))\n    (h1 : IsCycle \u03c3) (h2 : \u03c3.support = Finset.univ) (x : \u03b1) :\n    closure ({\u03c3, swap x ((\u03c3 ^ n) x)} : Set (Perm \u03b1)) = \u22a4", "start": [1674, 1], "end": [1686, 101], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.closure_prime_cycle_swap", "code": "theorem closure_prime_cycle_swap {\u03c3 \u03c4 : Perm \u03b1} (h0 : (Fintype.card \u03b1).Prime) (h1 : IsCycle \u03c3)\n    (h2 : \u03c3.support = Finset.univ) (h3 : IsSwap \u03c4) : closure ({\u03c3, \u03c4} : Set (Perm \u03b1)) = \u22a4", "start": [1689, 1], "end": [1700, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isConj_of_support_equiv", "code": "theorem isConj_of_support_equiv\n    (f : { x // x \u2208 (\u03c3.support : Set \u03b1) } \u2243 { x // x \u2208 (\u03c4.support : Set \u03b1) })\n    (hf :\n      \u2200 (x : \u03b1) (hx : x \u2208 (\u03c3.support : Set \u03b1)),\n        (f \u27e8\u03c3 x, apply_mem_support.2 hx\u27e9 : \u03b1) = \u03c4 \u2191(f \u27e8x, hx\u27e9)) :\n    IsConj \u03c3 \u03c4", "start": [1711, 1], "end": [1725, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.isConj", "code": "theorem IsCycle.isConj (h\u03c3 : IsCycle \u03c3) (h\u03c4 : IsCycle \u03c4) (h : \u03c3.support.card = \u03c4.support.card) :\n    IsConj \u03c3 \u03c4", "start": [1728, 1], "end": [1746, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.isConj_iff", "code": "theorem IsCycle.isConj_iff (h\u03c3 : IsCycle \u03c3) (h\u03c4 : IsCycle \u03c4) :\n    IsConj \u03c3 \u03c4 \u2194 \u03c3.support.card = \u03c4.support.card", "start": [1749, 1], "end": [1761, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.support_conj", "code": "@[simp]\ntheorem support_conj : (\u03c3 * \u03c4 * \u03c3\u207b\u00b9).support = \u03c4.support.map \u03c3.toEmbedding", "start": [1764, 1], "end": [1769, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_support_conj", "code": "theorem card_support_conj : (\u03c3 * \u03c4 * \u03c3\u207b\u00b9).support.card = \u03c4.support.card", "start": [1772, 1], "end": [1772, 83], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.isConj_mul", "code": "theorem Disjoint.isConj_mul {\u03b1 : Type*} [Finite \u03b1] {\u03c3 \u03c4 \u03c0 \u03c1 : Perm \u03b1} (hc1 : IsConj \u03c3 \u03c0)\n    (hc2 : IsConj \u03c4 \u03c1) (hd1 : Disjoint \u03c3 \u03c4) (hd2 : Disjoint \u03c0 \u03c1) : IsConj (\u03c3 * \u03c4) (\u03c0 * \u03c1)", "start": [1777, 1], "end": [1821, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.fixed_point_card_lt_of_ne_one", "code": "theorem fixed_point_card_lt_of_ne_one [Fintype \u03b1] {\u03c3 : Perm \u03b1} (h : \u03c3 \u2260 1) :\n    (filter (fun x => \u03c3 x = x) univ).card < Fintype.card \u03b1 - 1", "start": [1831, 1], "end": [1834, 40], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.isCycleOn_formPerm", "code": "theorem _root_.List.Nodup.isCycleOn_formPerm (h : l.Nodup) :\n    l.formPerm.IsCycleOn { a | a \u2208 l }", "start": [1848, 1], "end": [1856, 16], "kind": "commanddeclaration"}, {"full_name": "Int.addLeft_one_isCycle", "code": "theorem _root_.Int.addLeft_one_isCycle : (Equiv.addLeft 1 : Perm \u2124).IsCycle", "start": [1865, 1], "end": [1866, 44], "kind": "commanddeclaration"}, {"full_name": "Int.addRight_one_isCycle", "code": "theorem _root_.Int.addRight_one_isCycle : (Equiv.addRight 1 : Perm \u2124).IsCycle", "start": [1869, 1], "end": [1870, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_cycleOn", "code": "theorem _root_.Finset.exists_cycleOn (s : Finset \u03b1) :\n    \u2203 f : Perm \u03b1, f.IsCycleOn s \u2227 f.support \u2286 s", "start": [1879, 1], "end": [1885, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.exists_cycleOn", "code": "theorem _root_.Set.Countable.exists_cycleOn (hs : s.Countable) :\n    \u2203 f : Perm \u03b1, f.IsCycleOn s \u2227 { x | f x \u2260 x } \u2286 s", "start": [1894, 1], "end": [1912, 9], "kind": "commanddeclaration"}, {"full_name": "Set.prod_self_eq_iUnion_perm", "code": "theorem _root_.Set.prod_self_eq_iUnion_perm (hf : f.IsCycleOn s) :\n    s \u00d7\u02e2 s = \u22c3 n : \u2124, (fun a => (a, (f ^ n) a)) '' s", "start": [1915, 1], "end": [1923, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.product_self_eq_disjiUnion_perm_aux", "code": "theorem _root_.Finset.product_self_eq_disjiUnion_perm_aux (hf : f.IsCycleOn s) :\n    (range s.card : Set \u2115).PairwiseDisjoint fun k =>\n      s.map \u27e8fun i => (i, (f ^ k) i), fun i j => congr_arg Prod.fst\u27e9", "start": [1932, 1], "end": [1946, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.product_self_eq_disjiUnion_perm", "code": "theorem _root_.Finset.product_self_eq_disjiUnion_perm (hf : f.IsCycleOn s) :\n    s \u00d7\u02e2 s =\n      (range s.card).disjiUnion\n        (fun k => s.map \u27e8fun i => (i, (f ^ k) i), fun i j => congr_arg Prod.fst\u27e9)\n        (product_self_eq_disjiUnion_perm_aux hf)", "start": [1949, 1], "end": [1972, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_sum_eq_sum_perm", "code": "theorem _root_.Finset.sum_smul_sum_eq_sum_perm (h\u03c3 : \u03c3.IsCycleOn s) (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) :\n    ((\u2211 i in s, f i) \u2022 \u2211 i in s, g i) = \u2211 k in range s.card, \u2211 i in s, f i \u2022 g ((\u03c3 ^ k) i)", "start": [1981, 1], "end": [1984, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_mul_sum_eq_sum_perm", "code": "theorem _root_.Finset.sum_mul_sum_eq_sum_perm (h\u03c3 : \u03c3.IsCycleOn s) (f g : \u03b9 \u2192 \u03b1) :\n    ((\u2211 i in s, f i) * \u2211 i in s, g i) = \u2211 k in range s.card, \u2211 i in s, f i * g ((\u03c3 ^ k) i)", "start": [1987, 1], "end": [1989, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "imports": ["Mathlib/Data/List/FinRange.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/LinearAlgebra/Basic.lean", "Mathlib/Data/Fintype/Sort.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Algebra/BigOperators/Ring.lean"], "premises": [{"full_name": "MultilinearMap", "code": "structure MultilinearMap (R : Type uR) {\u03b9 : Type u\u03b9} (M\u2081 : \u03b9 \u2192 Type v\u2081) (M\u2082 : Type v\u2082) [Semiring R]\n  [\u2200 i, AddCommMonoid (M\u2081 i)] [AddCommMonoid M\u2082] [\u2200 i, Module R (M\u2081 i)] [Module R M\u2082] where\n  \n  toFun : (\u2200 i, M\u2081 i) \u2192 M\u2082\n  \n  map_add' :\n    \u2200 [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x y : M\u2081 i),\n      toFun (update m i (x + y)) = toFun (update m i x) + toFun (update m i y)\n  \n  map_smul' :\n    \u2200 [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (c : R) (x : M\u2081 i),\n      toFun (update m i (c \u2022 x)) = c \u2022 toFun (update m i x)", "start": [85, 1], "end": [98, 60], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe : f.toFun = \u21d1f", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : (\u2200 i, M\u2081 i) \u2192 M\u2082) (h\u2081 h\u2082) : \u21d1(\u27e8f, h\u2081, h\u2082\u27e9 : MultilinearMap R M\u2081 M\u2082) = f", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.congr_fun", "code": "theorem congr_fun {f g : MultilinearMap R M\u2081 M\u2082} (h : f = g) (x : \u2200 i, M\u2081 i) : f x = g x", "start": [129, 1], "end": [130, 24], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.congr_arg", "code": "nonrec theorem congr_arg (f : MultilinearMap R M\u2081 M\u2082) {x y : \u2200 i, M\u2081 i} (h : x = y) : f x = f y", "start": [133, 1], "end": [134, 24], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : MultilinearMap R M\u2081 M\u2082 \u2192 (\u2200 i, M\u2081 i) \u2192 M\u2082)", "start": [137, 1], "end": [138, 24], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_inj", "code": "@[norm_cast] theorem coe_inj {f g : MultilinearMap R M\u2081 M\u2082} : (f : (\u2200 i, M\u2081 i) \u2192 M\u2082) = g \u2194 f = g", "start": [141, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.ext", "code": "@[ext]\ntheorem ext {f f' : MultilinearMap R M\u2081 M\u2082} (H : \u2200 x, f x = f' x) : f = f'", "start": [146, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.ext_iff", "code": "theorem ext_iff {f g : MultilinearMap R M\u2081 M\u2082} : f = g \u2194 \u2200 x, f x = g x", "start": [151, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : MultilinearMap R M\u2081 M\u2082) (h\u2081 h\u2082) :\n    (\u27e8f, h\u2081, h\u2082\u27e9 : MultilinearMap R M\u2081 M\u2082) = f", "start": [155, 1], "end": [157, 54], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_add", "code": "@[simp]\nprotected theorem map_add [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x y : M\u2081 i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y)", "start": [160, 1], "end": [163, 21], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_smul", "code": "@[simp]\nprotected theorem map_smul [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (c : R) (x : M\u2081 i) :\n    f (update m i (c \u2022 x)) = c \u2022 f (update m i x)", "start": [166, 1], "end": [169, 22], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_coord_zero", "code": "theorem map_coord_zero {m : \u2200 i, M\u2081 i} (i : \u03b9) (h : m i = 0) : f m = 0", "start": [172, 1], "end": [175, 76], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_update_zero", "code": "@[simp]\ntheorem map_update_zero [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) : f (update m i 0) = 0", "start": [178, 1], "end": [180, 41], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_zero", "code": "@[simp]\ntheorem map_zero [Nonempty \u03b9] : f 0 = 0", "start": [183, 1], "end": [186, 31], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.add_apply", "code": "@[simp]\ntheorem add_apply (m : \u2200 i, M\u2081 i) : (f + f') m = f m + f' m", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.zero_apply", "code": "@[simp]\ntheorem zero_apply (m : \u2200 i, M\u2081 i) : (0 : MultilinearMap R M\u2081 M\u2082) m = 0", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.smul_apply", "code": "@[simp]\ntheorem smul_apply (f : MultilinearMap A M\u2081 M\u2082) (c : R') (m : \u2200 i, M\u2081 i) : (c \u2022 f) m = c \u2022 f m", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_smul", "code": "theorem coe_smul (c : R') (f : MultilinearMap A M\u2081 M\u2082) : \u21d1(c \u2022 f) = c \u2022 (\u21d1 f)", "start": [225, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (MultilinearMap R M\u2081 M\u2082) :=\n  coe_injective.addCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [231, 1], "end": [232, 68], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coeAddMonoidHom", "code": "@[simps] def coeAddMonoidHom : MultilinearMap R M\u2081 M\u2082 \u2192+ (((i : \u03b9) \u2192 M\u2081 i) \u2192 M\u2082) where\n  toFun := FunLike.coe; map_zero' := rfl; map_add' _ _ := rfl", "start": [235, 1], "end": [237, 62], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_sum", "code": "@[simp]\ntheorem coe_sum {\u03b1 : Type*} (f : \u03b1 \u2192 MultilinearMap R M\u2081 M\u2082) (s : Finset \u03b1) :\n    \u21d1(\u2211 a in s, f a) = \u2211 a in s, \u21d1(f a)", "start": [239, 1], "end": [242, 30], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.sum_apply", "code": "theorem sum_apply {\u03b1 : Type*} (f : \u03b1 \u2192 MultilinearMap R M\u2081 M\u2082) (m : \u2200 i, M\u2081 i) {s : Finset \u03b1} :\n    (\u2211 a in s, f a) m = \u2211 a in s, f a m", "start": [244, 1], "end": [245, 51], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.toLinearMap", "code": "@[simps]\ndef toLinearMap [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) : M\u2081 i \u2192\u2097[R] M\u2082 where\n  toFun x := f (update m i x)\n  map_add' x y := by simp\n  map_smul' c x := by simp", "start": [248, 1], "end": [254, 27], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.prod", "code": "@[simps]\ndef prod (f : MultilinearMap R M\u2081 M\u2082) (g : MultilinearMap R M\u2081 M\u2083) : MultilinearMap R M\u2081 (M\u2082 \u00d7 M\u2083)\n    where\n  toFun m := (f m, g m)\n  map_add' m i x y := by simp\n  map_smul' m i c x := by simp", "start": [258, 1], "end": [264, 31], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.pi", "code": "@[simps]\ndef pi {\u03b9' : Type*} {M' : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (M' i)] [\u2200 i, Module R (M' i)]\n    (f : \u2200 i, MultilinearMap R M\u2081 (M' i)) : MultilinearMap R M\u2081 (\u2200 i, M' i) where\n  toFun m i := f i m\n  map_add' _ _ _ _ := funext fun j => (f j).map_add _ _ _ _\n  map_smul' _ _ _ _ := funext fun j => (f j).map_smul _ _ _ _", "start": [268, 1], "end": [275, 62], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.ofSubsingleton", "code": "@[simps]\ndef ofSubsingleton [Subsingleton \u03b9] (i' : \u03b9) : MultilinearMap R (fun _ : \u03b9 => M\u2082) M\u2082 where\n  toFun := Function.eval i'\n  map_add' m i x y := by\n    rw [Subsingleton.elim i i']\n    simp only [Function.eval, Function.update_same]\n  map_smul' m i r x := by\n    rw [Subsingleton.elim i i']\n    simp only [Function.eval, Function.update_same]", "start": [283, 1], "end": [293, 52], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.constOfIsEmpty", "code": "@[simps (config := { fullyApplied := false })]\ndef constOfIsEmpty [IsEmpty \u03b9] (m : M\u2082) : MultilinearMap R M\u2081 M\u2082 where\n  toFun := Function.const _ m\n  map_add' _ := isEmptyElim\n  map_smul' _ := isEmptyElim", "start": [300, 1], "end": [306, 29], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.restr", "code": "def restr {k n : \u2115} (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (s : Finset (Fin n))\n    (hk : s.card = k) (z : M') : MultilinearMap R (fun _ : Fin k => M') M\u2082 where\n  toFun v := f fun j => if h : j \u2208 s then v ((FunLike.coe (s.orderIsoOfFin hk).symm) \u27e8j, h\u27e9) else z\n  \n  map_add' v i x y := by\n    have : FunLike.coe (s.orderIsoOfFin hk).symm = (s.orderIsoOfFin hk).toEquiv.symm := rfl\n    simp only [this]\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp\n  map_smul' v i c x := by\n    have : FunLike.coe (s.orderIsoOfFin hk).symm = (s.orderIsoOfFin hk).toEquiv.symm := rfl\n    simp only [this]\n    erw [dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv,\n      dite_comp_equiv_update (s.orderIsoOfFin hk).toEquiv]\n    simp", "start": [313, 1], "end": [335, 9], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.cons_add", "code": "theorem cons_add (f : MultilinearMap R M M\u2082) (m : \u2200 i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m)", "start": [338, 1], "end": [343, 72], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.cons_smul", "code": "theorem cons_smul (f : MultilinearMap R M M\u2082) (m : \u2200 i : Fin n, M i.succ) (c : R) (x : M 0) :\n    f (cons (c \u2022 x) m) = c \u2022 f (cons x m)", "start": [346, 1], "end": [351, 73], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.snoc_add", "code": "theorem snoc_add (f : MultilinearMap R M M\u2082)\n    (m : \u2200 i : Fin n, M (castSucc i)) (x y : M (last n)) :\n    f (snoc m (x + y)) = f (snoc m x) + f (snoc m y)", "start": [354, 1], "end": [360, 72], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.snoc_smul", "code": "theorem snoc_smul (f : MultilinearMap R M M\u2082) (m : \u2200 i : Fin n, M (castSucc i)) (c : R)\n    (x : M (last n)) : f (snoc m (c \u2022 x)) = c \u2022 f (snoc m x)", "start": [363, 1], "end": [368, 73], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap", "code": "def compLinearMap (g : MultilinearMap R M\u2081' M\u2082) (f : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i) : MultilinearMap R M\u2081 M\u2082\n    where\n  toFun m := g fun i => f i (m i)\n  map_add' m i x y := by\n    have : \u2200 j z, f j (update m i z j) = update (fun k => f k (m k)) i (f i z) j := fun j z =>\n      Function.apply_update (fun k => f k) _ _ _ _\n    simp [this]\n  map_smul' m i c x := by\n    have : \u2200 j z, f j (update m i z j) = update (fun k => f k (m k)) i (f i z) j := fun j z =>\n      Function.apply_update (fun k => f k) _ _ _ _\n    simp [this]", "start": [377, 1], "end": [390, 16], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap_apply", "code": "@[simp]\ntheorem compLinearMap_apply (g : MultilinearMap R M\u2081' M\u2082) (f : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i)\n    (m : \u2200 i, M\u2081 i) : g.compLinearMap f m = g fun i => f i (m i)", "start": [393, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap_assoc", "code": "theorem compLinearMap_assoc (g : MultilinearMap R M\u2081'' M\u2082) (f\u2081 : \u2200 i, M\u2081' i \u2192\u2097[R] M\u2081'' i)\n    (f\u2082 : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i) :\n    (g.compLinearMap f\u2081).compLinearMap f\u2082 = g.compLinearMap fun i => f\u2081 i \u2218\u2097 f\u2082 i", "start": [399, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.zero_compLinearMap", "code": "@[simp]\ntheorem zero_compLinearMap (f : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i) :\n    (0 : MultilinearMap R M\u2081' M\u2082).compLinearMap f = 0", "start": [407, 1], "end": [411, 19], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap_id", "code": "@[simp]\ntheorem compLinearMap_id (g : MultilinearMap R M\u2081' M\u2082) :\n    (g.compLinearMap fun _ => LinearMap.id) = g", "start": [414, 1], "end": [418, 19], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap_injective", "code": "theorem compLinearMap_injective (f : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i) (hf : \u2200 i, Surjective (f i)) :\n    Injective fun g : MultilinearMap R M\u2081' M\u2082 => g.compLinearMap f", "start": [421, 1], "end": [425, 88], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.compLinearMap_inj", "code": "theorem compLinearMap_inj (f : \u2200 i, M\u2081 i \u2192\u2097[R] M\u2081' i) (hf : \u2200 i, Surjective (f i))\n    (g\u2081 g\u2082 : MultilinearMap R M\u2081' M\u2082) : g\u2081.compLinearMap f = g\u2082.compLinearMap f \u2194 g\u2081 = g\u2082", "start": [428, 1], "end": [430, 40], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.comp_linearEquiv_eq_zero_iff", "code": "@[simp]\ntheorem comp_linearEquiv_eq_zero_iff (g : MultilinearMap R M\u2081' M\u2082) (f : \u2200 i, M\u2081 i \u2243\u2097[R] M\u2081' i) :\n    (g.compLinearMap fun i => (f i : M\u2081 i \u2192\u2097[R] M\u2081' i)) = 0 \u2194 g = 0", "start": [433, 1], "end": [439, 79], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_piecewise_add", "code": "theorem map_piecewise_add [DecidableEq \u03b9] (m m' : \u2200 i, M\u2081 i) (t : Finset \u03b9) :\n    f (t.piecewise (m + m') m') = \u2211 s in t.powerset, f (s.piecewise m m')", "start": [444, 1], "end": [478, 12], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_add_univ", "code": "theorem map_add_univ [DecidableEq \u03b9] [Fintype \u03b9] (m m' : \u2200 i, M\u2081 i) :\n    f (m + m') = \u2211 s : Finset \u03b9, f (s.piecewise m m')", "start": [481, 1], "end": [485, 51], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_sum_finset_aux", "code": "theorem map_sum_finset_aux [DecidableEq \u03b9] [Fintype \u03b9] {n : \u2115} (h : (\u2211 i, (A i).card) = n) :\n    (f fun i => \u2211 j in A i, g i j) = \u2211 r in piFinset A, f fun i => g i (r i)", "start": [494, 1], "end": [634, 28], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_sum_finset", "code": "theorem map_sum_finset [DecidableEq \u03b9] [Fintype \u03b9] :\n    (f fun i => \u2211 j in A i, g i j) = \u2211 r in piFinset A, f fun i => g i (r i)", "start": [637, 1], "end": [643, 31], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_sum", "code": "theorem map_sum [DecidableEq \u03b9] [Fintype \u03b9] [\u2200 i, Fintype (\u03b1 i)] :\n    (f fun i => \u2211 j, g i j) = \u2211 r : \u2200 i, \u03b1 i, f fun i => g i (r i)", "start": [646, 1], "end": [651, 42], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_update_sum", "code": "theorem map_update_sum {\u03b1 : Type*} [DecidableEq \u03b9] (t : Finset \u03b1) (i : \u03b9) (g : \u03b1 \u2192 M\u2081 i)\n    (m : \u2200 i, M\u2081 i) : f (update m i (\u2211 a in t, g a)) = \u2211 a in t, f (update m i (g a))", "start": [654, 1], "end": [659, 39], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.codRestrict", "code": "@[simps]\ndef codRestrict (f : MultilinearMap R M\u2081 M\u2082) (p : Submodule R M\u2082) (h : \u2200 v, f v \u2208 p) :\n    MultilinearMap R M\u2081 p where\n  toFun v := \u27e8f v, h v\u27e9\n  map_add' _ _ _ _ := Subtype.ext <| MultilinearMap.map_add _ _ _ _ _\n  map_smul' _ _ _ _ := Subtype.ext <| MultilinearMap.map_smul _ _ _ _ _", "start": [664, 1], "end": [672, 72], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.restrictScalars", "code": "def restrictScalars (f : MultilinearMap A M\u2081 M\u2082) : MultilinearMap R M\u2081 M\u2082 where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' m i := (f.toLinearMap m i).map_smul_of_tower", "start": [683, 1], "end": [688, 57], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (f : MultilinearMap A M\u2081 M\u2082) : \u21d1(f.restrictScalars R) = f", "start": [691, 1], "end": [693, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongr", "code": "@[simps apply]\ndef domDomCongr (\u03c3 : \u03b9\u2081 \u2243 \u03b9\u2082) (m : MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083) :\n    MultilinearMap R (fun _ : \u03b9\u2082 => M\u2082) M\u2083 where\n  toFun v := m fun i => v (\u03c3 i)\n  map_add' v i a b := by\n    letI := \u03c3.injective.decidableEq\n    simp_rw [Function.update_apply_equiv_apply v]\n    rw [m.map_add]\n  map_smul' v i a b := by\n    letI := \u03c3.injective.decidableEq\n    simp_rw [Function.update_apply_equiv_apply v]\n    rw [m.map_smul]", "start": [702, 1], "end": [717, 20], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongr_trans", "code": "theorem domDomCongr_trans (\u03c3\u2081 : \u03b9\u2081 \u2243 \u03b9\u2082) (\u03c3\u2082 : \u03b9\u2082 \u2243 \u03b9\u2083)\n    (m : MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083) :\n    m.domDomCongr (\u03c3\u2081.trans \u03c3\u2082) = (m.domDomCongr \u03c3\u2081).domDomCongr \u03c3\u2082", "start": [721, 1], "end": [724, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongr_mul", "code": "theorem domDomCongr_mul (\u03c3\u2081 : Equiv.Perm \u03b9\u2081) (\u03c3\u2082 : Equiv.Perm \u03b9\u2081)\n    (m : MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083) :\n    m.domDomCongr (\u03c3\u2082 * \u03c3\u2081) = (m.domDomCongr \u03c3\u2081).domDomCongr \u03c3\u2082", "start": [727, 1], "end": [730, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongrEquiv", "code": "@[simps apply symm_apply]\ndef domDomCongrEquiv (\u03c3 : \u03b9\u2081 \u2243 \u03b9\u2082) :\n    MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083 \u2243+ MultilinearMap R (fun _ : \u03b9\u2082 => M\u2082) M\u2083 where\n  toFun := domDomCongr \u03c3\n  invFun := domDomCongr \u03c3.symm\n  left_inv m := by\n    ext\n    simp [domDomCongr]\n  right_inv m := by\n    ext\n    simp [domDomCongr]\n  map_add' a b := by\n    ext\n    simp [domDomCongr]", "start": [733, 1], "end": [749, 23], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongr_eq_iff", "code": "@[simp]\ntheorem domDomCongr_eq_iff (\u03c3 : \u03b9\u2081 \u2243 \u03b9\u2082) (f g : MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083) :\n    f.domDomCongr \u03c3 = g.domDomCongr \u03c3 \u2194 f = g", "start": [754, 1], "end": [759, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compMultilinearMap", "code": "def compMultilinearMap (g : M\u2082 \u2192\u2097[R] M\u2083) (f : MultilinearMap R M\u2081 M\u2082) : MultilinearMap R M\u2081 M\u2083 where\n  toFun := g \u2218 f\n  map_add' m i x y := by simp\n  map_smul' m i c x := by simp", "start": [773, 1], "end": [777, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_compMultilinearMap", "code": "@[simp]\ntheorem coe_compMultilinearMap (g : M\u2082 \u2192\u2097[R] M\u2083) (f : MultilinearMap R M\u2081 M\u2082) :\n    \u21d1(g.compMultilinearMap f) = g \u2218 f", "start": [780, 1], "end": [783, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compMultilinearMap_apply", "code": "@[simp]\ntheorem compMultilinearMap_apply (g : M\u2082 \u2192\u2097[R] M\u2083) (f : MultilinearMap R M\u2081 M\u2082) (m : \u2200 i, M\u2081 i) :\n    g.compMultilinearMap f m = g (f m)", "start": [786, 1], "end": [789, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.subtype_compMultilinearMap_codRestrict", "code": "@[simp]\ntheorem subtype_compMultilinearMap_codRestrict (f : MultilinearMap R M\u2081 M\u2082) (p : Submodule R M\u2082)\n    (h) : p.subtype.compMultilinearMap (f.codRestrict p h) = f", "start": [792, 1], "end": [796, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compMultilinearMap_codRestrict", "code": "@[simp]\ntheorem compMultilinearMap_codRestrict (g : M\u2082 \u2192\u2097[R] M\u2083) (f : MultilinearMap R M\u2081 M\u2082)\n    (p : Submodule R M\u2083) (h) :\n    (g.codRestrict p h).compMultilinearMap f =\n      (g.compMultilinearMap f).codRestrict p fun v => h (f v)", "start": [799, 1], "end": [805, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compMultilinearMap_domDomCongr", "code": "@[simp]\ntheorem compMultilinearMap_domDomCongr (\u03c3 : \u03b9\u2081 \u2243 \u03b9\u2082) (g : M\u2082 \u2192\u2097[R] M\u2083)\n    (f : MultilinearMap R (fun _ : \u03b9\u2081 => M') M\u2082) :\n    (g.compMultilinearMap f).domDomCongr \u03c3 = g.compMultilinearMap (f.domDomCongr \u03c3)", "start": [810, 1], "end": [815, 36], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongrLinearEquiv'", "code": "@[simps apply symm_apply]\ndef domDomCongrLinearEquiv' {\u03b9' : Type*} (\u03c3 : \u03b9 \u2243 \u03b9') :\n    MultilinearMap R M\u2081 M\u2082 \u2243\u2097[S] MultilinearMap R (fun i => M\u2081 (\u03c3.symm i)) M\u2082 where\n  toFun f :=\n    { toFun := f \u2218 (\u03c3.piCongrLeft' M\u2081).symm\n      map_add' := fun m i => by\n        letI := \u03c3.decidableEq\n        rw [\u2190 \u03c3.apply_symm_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_symm_update, f.map_add]\n      map_smul' := fun m i c => by\n        letI := \u03c3.decidableEq\n        rw [\u2190 \u03c3.apply_symm_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_symm_update, f.map_smul] }\n  invFun f :=\n    { toFun := f \u2218 \u03c3.piCongrLeft' M\u2081\n      map_add' := fun m i => by\n        letI := \u03c3.symm.decidableEq\n        rw [\u2190 \u03c3.symm_apply_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_update, f.map_add]\n      map_smul' := fun m i c => by\n        letI := \u03c3.symm.decidableEq\n        rw [\u2190 \u03c3.symm_apply_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_update, f.map_smul] }\n  map_add' f\u2081 f\u2082 := by\n    ext\n    simp only [Function.comp, coe_mk, add_apply]\n  map_smul' c f := by\n    ext\n    simp only [Function.comp, coe_mk, smul_apply, RingHom.id_apply]\n  left_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.apply_symm_apply]", "start": [845, 1], "end": [884, 59], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.constLinearEquivOfIsEmpty", "code": "@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty \u03b9] : M\u2082 \u2243\u2097[S] MultilinearMap R M\u2081 M\u2082 where\n  toFun := MultilinearMap.constOfIsEmpty R _\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => MultilinearMap.congr_arg f <| Subsingleton.elim _ _", "start": [889, 1], "end": [898, 82], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domDomCongrLinearEquiv", "code": "@[simps apply symm_apply]\ndef domDomCongrLinearEquiv {\u03b9\u2081 \u03b9\u2082} (\u03c3 : \u03b9\u2081 \u2243 \u03b9\u2082) :\n    MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083 \u2243\u2097[S] MultilinearMap R (fun _ : \u03b9\u2082 => M\u2082) M\u2083 :=\n  { (domDomCongrEquiv \u03c3 :\n      MultilinearMap R (fun _ : \u03b9\u2081 => M\u2082) M\u2083 \u2243+ MultilinearMap R (fun _ : \u03b9\u2082 => M\u2082) M\u2083) with\n    map_smul' := fun c f => by\n      ext\n      simp [MultilinearMap.domDomCongr] }", "start": [905, 1], "end": [913, 42], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_piecewise_smul", "code": "theorem map_piecewise_smul [DecidableEq \u03b9] (c : \u03b9 \u2192 R) (m : \u2200 i, M\u2081 i) (s : Finset \u03b9) :\n    f (s.piecewise (fun i => c i \u2022 m i) m) = (\u220f i in s, c i) \u2022 f m", "start": [927, 1], "end": [944, 31], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_smul_univ", "code": "theorem map_smul_univ [Fintype \u03b9] (c : \u03b9 \u2192 R) (m : \u2200 i, M\u2081 i) :\n    (f fun i => c i \u2022 m i) = (\u220f i, c i) \u2022 f m", "start": [947, 1], "end": [951, 61], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_update_smul", "code": "@[simp]\ntheorem map_update_smul [DecidableEq \u03b9] [Fintype \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (c : R) (x : M\u2081 i) :\n    f (update (c \u2022 m) i x) = c ^ (Fintype.card \u03b9 - 1) \u2022 f (update m i x)", "start": [954, 1], "end": [961, 48], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiAlgebra", "code": "protected def mkPiAlgebra : MultilinearMap R (fun _ : \u03b9 => A) A where\n  toFun m := \u220f i, m i\n  map_add' m i x y := by simp [Finset.prod_update_of_mem, add_mul]\n  map_smul' m i c x := by simp [Finset.prod_update_of_mem]", "start": [969, 1], "end": [977, 59], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiAlgebra_apply", "code": "@[simp]\ntheorem mkPiAlgebra_apply (m : \u03b9 \u2192 A) : MultilinearMap.mkPiAlgebra R \u03b9 A m = \u220f i, m i", "start": [982, 1], "end": [984, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiAlgebraFin", "code": "protected def mkPiAlgebraFin : MultilinearMap R (fun _ : Fin n => A) A where\n  toFun m := (List.ofFn m).prod\n  map_add' {dec} m i x y := by\n    rw [Subsingleton.elim dec (by infer_instance)]\n    have : (List.finRange n).indexOf i < n := by\n      simpa using List.indexOf_lt_length.2 (List.mem_finRange i)\n    simp [List.ofFn_eq_map, (List.nodup_finRange n).map_update, List.prod_set, add_mul, this,\n      mul_add, add_mul]\n  map_smul' {dec} m i c x := by\n    rw [Subsingleton.elim dec (by infer_instance)]\n    have : (List.finRange n).indexOf i < n := by\n      simpa using List.indexOf_lt_length.2 (List.mem_finRange i)\n    simp [List.ofFn_eq_map, (List.nodup_finRange n).map_update, List.prod_set, this]", "start": [994, 1], "end": [1011, 85], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiAlgebraFin_apply", "code": "@[simp]\ntheorem mkPiAlgebraFin_apply (m : Fin n \u2192 A) :\n    MultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod", "start": [1016, 1], "end": [1019, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiAlgebraFin_apply_const", "code": "theorem mkPiAlgebraFin_apply_const (a : A) :\n    (MultilinearMap.mkPiAlgebraFin R n A fun _ => a) = a ^ n", "start": [1022, 1], "end": [1023, 72], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.smulRight", "code": "def smulRight (f : MultilinearMap R M\u2081 R) (z : M\u2082) : MultilinearMap R M\u2081 M\u2082 :=\n  (LinearMap.smulRight LinearMap.id z).compMultilinearMap f", "start": [1028, 1], "end": [1031, 60], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.smulRight_apply", "code": "@[simp]\ntheorem smulRight_apply (f : MultilinearMap R M\u2081 R) (z : M\u2082) (m : \u2200 i, M\u2081 i) :\n    f.smulRight z m = f m \u2022 z", "start": [1034, 1], "end": [1037, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing", "code": "protected def mkPiRing [Fintype \u03b9] (z : M\u2082) : MultilinearMap R (fun _ : \u03b9 => R) M\u2082 :=\n  (MultilinearMap.mkPiAlgebra R \u03b9 R).smulRight z", "start": [1042, 1], "end": [1046, 49], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing_apply", "code": "@[simp]\ntheorem mkPiRing_apply [Fintype \u03b9] (z : M\u2082) (m : \u03b9 \u2192 R) :\n    (MultilinearMap.mkPiRing R \u03b9 z : (\u03b9 \u2192 R) \u2192 M\u2082) m = (\u220f i, m i) \u2022 z", "start": [1051, 1], "end": [1054, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing_apply_one_eq_self", "code": "theorem mkPiRing_apply_one_eq_self [Fintype \u03b9] (f : MultilinearMap R (fun _ : \u03b9 => R) M\u2082) :\n    MultilinearMap.mkPiRing R \u03b9 (f fun _ => 1) = f", "start": [1057, 1], "end": [1063, 41], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing_eq_iff", "code": "theorem mkPiRing_eq_iff [Fintype \u03b9] {z\u2081 z\u2082 : M\u2082} :\n    MultilinearMap.mkPiRing R \u03b9 z\u2081 = MultilinearMap.mkPiRing R \u03b9 z\u2082 \u2194 z\u2081 = z\u2082", "start": [1066, 1], "end": [1072, 13], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing_zero", "code": "theorem mkPiRing_zero [Fintype \u03b9] : MultilinearMap.mkPiRing R \u03b9 (0 : M\u2082) = 0", "start": [1075, 1], "end": [1076, 65], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.mkPiRing_eq_zero_iff", "code": "theorem mkPiRing_eq_zero_iff [Fintype \u03b9] (z : M\u2082) : MultilinearMap.mkPiRing R \u03b9 z = 0 \u2194 z = 0", "start": [1079, 1], "end": [1080, 40], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (m : \u2200 i, M\u2081 i) : (-f) m = -f m", "start": [1093, 1], "end": [1095, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.sub_apply", "code": "@[simp]\ntheorem sub_apply (m : \u2200 i, M\u2081 i) : (f - g) m = f m - g m", "start": [1106, 1], "end": [1108, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_neg", "code": "@[simp]\ntheorem map_neg [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x : M\u2081 i) :\n    f (update m i (-x)) = -f (update m i x)", "start": [1131, 1], "end": [1135, 88], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_sub", "code": "@[simp]\ntheorem map_sub [DecidableEq \u03b9] (m : \u2200 i, M\u2081 i) (i : \u03b9) (x y : M\u2081 i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y)", "start": [1138, 1], "end": [1141, 71], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.piRingEquiv", "code": "protected def piRingEquiv [Fintype \u03b9] : M\u2082 \u2243\u2097[R] MultilinearMap R (fun _ : \u03b9 => R) M\u2082 where\n  toFun z := MultilinearMap.mkPiRing R \u03b9 z\n  invFun f := f fun _ => 1\n  map_add' z z' := by\n    ext m\n    simp [smul_add]\n  map_smul' c z := by\n    ext m\n    simp [smul_smul, mul_comm]\n  left_inv z := by simp\n  right_inv f := f.mkPiRing_apply_one_eq_self", "start": [1151, 1], "end": [1164, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.uncurryLeft", "code": "def LinearMap.uncurryLeft (f : M 0 \u2192\u2097[R] MultilinearMap R (fun i : Fin n => M i.succ) M\u2082) :\n    MultilinearMap R M M\u2082 where\n  toFun m := f (m 0) (tail m)\n  map_add' := @fun dec m i x y => by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    by_cases h : i = 0\n    \u00b7 subst i\n      simp only [update_same, map_add, tail_update_zero, MultilinearMap.add_apply]\n    \u00b7 simp_rw [update_noteq (Ne.symm h)]\n      revert x y\n      rw [\u2190 succ_pred i h]\n      intro x y\n      rw [tail_update_succ, MultilinearMap.map_add, tail_update_succ, tail_update_succ]\n  map_smul' := @fun dec m i c x => by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    by_cases h : i = 0\n    \u00b7 subst i\n      simp only [update_same, map_smul, tail_update_zero, MultilinearMap.smul_apply]\n    \u00b7 simp_rw [update_noteq (Ne.symm h)]\n      revert x\n      rw [\u2190 succ_pred i h]\n      intro x\n      rw [tail_update_succ, tail_update_succ, MultilinearMap.map_smul]", "start": [1196, 1], "end": [1223, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.uncurryLeft_apply", "code": "@[simp]\ntheorem LinearMap.uncurryLeft_apply (f : M 0 \u2192\u2097[R] MultilinearMap R (fun i : Fin n => M i.succ) M\u2082)\n    (m : \u2200 i, M i) : f.uncurryLeft m = f (m 0) (tail m)", "start": [1226, 1], "end": [1229, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryLeft", "code": "def MultilinearMap.curryLeft (f : MultilinearMap R M M\u2082) :\n    M 0 \u2192\u2097[R] MultilinearMap R (fun i : Fin n => M i.succ) M\u2082 where\n  toFun x :=\n    { toFun := fun m => f (cons x m)\n      map_add' := @fun dec m i y y' => by\n        rw [Subsingleton.elim dec (by clear dec; infer_instance)]\n        simp\n      map_smul' := @fun dec m i y c => by\n        rw [Subsingleton.elim dec (by clear dec; infer_instance)]\n        simp }\n  map_add' x y := by\n    ext m\n    exact cons_add f m x y\n  map_smul' c x := by\n    ext m\n    exact cons_smul f m c x", "start": [1232, 1], "end": [1251, 28], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryLeft_apply", "code": "@[simp]\ntheorem MultilinearMap.curryLeft_apply (f : MultilinearMap R M M\u2082) (x : M 0)\n    (m : \u2200 i : Fin n, M i.succ) : f.curryLeft x m = f (cons x m)", "start": [1254, 1], "end": [1257, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.curry_uncurryLeft", "code": "@[simp]\ntheorem LinearMap.curry_uncurryLeft (f : M 0 \u2192\u2097[R] MultilinearMap R (fun i :\n    Fin n => M i.succ) M\u2082) : f.uncurryLeft.curryLeft = f", "start": [1260, 1], "end": [1265, 17], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurry_curryLeft", "code": "@[simp]\ntheorem MultilinearMap.uncurry_curryLeft (f : MultilinearMap R M M\u2082) :\n    f.curryLeft.uncurryLeft = f", "start": [1268, 1], "end": [1272, 7], "kind": "commanddeclaration"}, {"full_name": "multilinearCurryLeftEquiv", "code": "def multilinearCurryLeftEquiv :\n    (M 0 \u2192\u2097[R] MultilinearMap R (fun i : Fin n => M i.succ) M\u2082) \u2243\u2097[R] MultilinearMap R M M\u2082 where\n  toFun := LinearMap.uncurryLeft\n  map_add' f\u2081 f\u2082 := by\n    ext m\n    rfl\n  map_smul' c f := by\n    ext m\n    rfl\n  invFun := MultilinearMap.curryLeft\n  left_inv := LinearMap.curry_uncurryLeft\n  right_inv := MultilinearMap.uncurry_curryLeft", "start": [1277, 1], "end": [1295, 48], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurryRight", "code": "def MultilinearMap.uncurryRight\n    (f : MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) \u2192\u2097[R] M\u2082)) :\n    MultilinearMap R M M\u2082 where\n  toFun m := f (init m) (m (last n))\n  map_add' {dec} m i x y := by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    by_cases h : i.val < n\n    \u00b7 have : last n \u2260 i := Ne.symm (ne_of_lt h)\n      simp_rw [update_noteq this]\n      revert x y\n      rw [(castSucc_castLT i h).symm]\n      intro x y\n      rw [init_update_castSucc, MultilinearMap.map_add, init_update_castSucc,\n        init_update_castSucc, LinearMap.add_apply]\n    \u00b7 revert x y\n      rw [eq_last_of_not_lt h]\n      intro x y\n      simp_rw [init_update_last, update_same, LinearMap.map_add]\n  map_smul' {dec} m i c x := by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    by_cases h : i.val < n\n    \u00b7 have : last n \u2260 i := Ne.symm (ne_of_lt h)\n      simp_rw [update_noteq this]\n      revert x\n      rw [(castSucc_castLT i h).symm]\n      intro x\n      rw [init_update_castSucc, init_update_castSucc, MultilinearMap.map_smul,\n        LinearMap.smul_apply]\n    \u00b7 revert x\n      rw [eq_last_of_not_lt h]\n      intro x\n      simp_rw [update_same, init_update_last, map_smul]", "start": [1303, 1], "end": [1339, 56], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurryRight_apply", "code": "@[simp]\ntheorem MultilinearMap.uncurryRight_apply\n    (f : MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) \u2192\u2097[R] M\u2082))\n    (m : \u2200 i, M i) : f.uncurryRight m = f (init m) (m (last n))", "start": [1342, 1], "end": [1346, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryRight", "code": "def MultilinearMap.curryRight (f : MultilinearMap R M M\u2082) :\n    MultilinearMap R (fun i : Fin n => M (Fin.castSucc i)) (M (last n) \u2192\u2097[R] M\u2082) where\n  toFun m :=\n    { toFun := fun x => f (snoc m x)\n      map_add' := fun x y => by simp_rw [f.snoc_add]\n      map_smul' := fun c x => by simp only [f.snoc_smul, RingHom.id_apply] }\n  map_add' := @fun dec m i x y => by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    ext z\n    change f (snoc (update m i (x + y)) z) = f (snoc (update m i x) z) + f (snoc (update m i y) z)\n    rw [snoc_update, snoc_update, snoc_update, f.map_add]\n  map_smul' := @fun dec m i c x => by\n    rw [Subsingleton.elim dec (by clear dec; infer_instance)]; clear dec\n    ext z\n    change f (snoc (update m i (c \u2022 x)) z) = c \u2022 f (snoc (update m i x) z)\n    rw [snoc_update, snoc_update, f.map_smul]", "start": [1349, 1], "end": [1367, 46], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryRight_apply", "code": "@[simp]\ntheorem MultilinearMap.curryRight_apply (f : MultilinearMap R M M\u2082)\n    (m : \u2200 i : Fin n, M (castSucc i)) (x : M (last n)) : f.curryRight m x = f (snoc m x)", "start": [1370, 1], "end": [1373, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curry_uncurryRight", "code": "@[simp]\ntheorem MultilinearMap.curry_uncurryRight\n    (f : MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) \u2192\u2097[R] M\u2082)) :\n    f.uncurryRight.curryRight = f", "start": [1376, 1], "end": [1382, 17], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurry_curryRight", "code": "@[simp]\ntheorem MultilinearMap.uncurry_curryRight (f : MultilinearMap R M M\u2082) :\n    f.curryRight.uncurryRight = f", "start": [1385, 1], "end": [1389, 7], "kind": "commanddeclaration"}, {"full_name": "multilinearCurryRightEquiv", "code": "def multilinearCurryRightEquiv :\n    MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) \u2192\u2097[R] M\u2082) \u2243\u2097[R]\n      MultilinearMap R M M\u2082 where\n  toFun := MultilinearMap.uncurryRight\n  map_add' f\u2081 f\u2082 := by\n    ext m\n    rfl\n  map_smul' c f := by\n    ext m\n    rw [smul_apply]\n    rfl\n  invFun := MultilinearMap.curryRight\n  left_inv := MultilinearMap.curry_uncurryRight\n  right_inv := MultilinearMap.uncurry_curryRight", "start": [1394, 1], "end": [1414, 49], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.currySum", "code": "def currySum (f : MultilinearMap R (fun _ : Sum \u03b9 \u03b9' => M') M\u2082) :\n    MultilinearMap R (fun _ : \u03b9 => M') (MultilinearMap R (fun _ : \u03b9' => M') M\u2082) where\n  toFun u :=\n    { toFun := fun v => f (Sum.elim u v)\n      map_add' := fun v i x y => by\n        letI := Classical.decEq \u03b9\n        simp only [\u2190 Sum.update_elim_inr, f.map_add]\n      map_smul' := fun v i c x => by\n        letI := Classical.decEq \u03b9\n        simp only [\u2190 Sum.update_elim_inr, f.map_smul] }\n  map_add' u i x y :=\n    ext fun v => by\n      letI := Classical.decEq \u03b9'\n      simp only [MultilinearMap.coe_mk, add_apply, \u2190 Sum.update_elim_inl, f.map_add]\n  map_smul' u i c x :=\n    ext fun v => by\n      letI := Classical.decEq \u03b9'\n      simp only [MultilinearMap.coe_mk, smul_apply, \u2190 Sum.update_elim_inl, f.map_smul]", "start": [1421, 1], "end": [1440, 87], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.currySum_apply", "code": "@[simp]\ntheorem currySum_apply (f : MultilinearMap R (fun _ : Sum \u03b9 \u03b9' => M') M\u2082) (u : \u03b9 \u2192 M')\n    (v : \u03b9' \u2192 M') : f.currySum u v = f (Sum.elim u v)", "start": [1443, 1], "end": [1446, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurrySum", "code": "def uncurrySum (f : MultilinearMap R (fun _ : \u03b9 => M') (MultilinearMap R (fun _ : \u03b9' => M') M\u2082)) :\n    MultilinearMap R (fun _ : Sum \u03b9 \u03b9' => M') M\u2082 where\n  toFun u := f (u \u2218 Sum.inl) (u \u2218 Sum.inr)\n  map_add' u i x y := by\n    letI := (@Sum.inl_injective \u03b9 \u03b9').decidableEq\n    letI := (@Sum.inr_injective \u03b9 \u03b9').decidableEq\n    cases i <;>\n      simp only [MultilinearMap.map_add, add_apply, Sum.update_inl_comp_inl,\n        Sum.update_inl_comp_inr, Sum.update_inr_comp_inl, Sum.update_inr_comp_inr]\n  map_smul' u i c x := by\n    letI := (@Sum.inl_injective \u03b9 \u03b9').decidableEq\n    letI := (@Sum.inr_injective \u03b9 \u03b9').decidableEq\n    cases i <;>\n      simp only [MultilinearMap.map_smul, smul_apply, Sum.update_inl_comp_inl,\n        Sum.update_inl_comp_inr, Sum.update_inr_comp_inl, Sum.update_inr_comp_inr]", "start": [1449, 1], "end": [1465, 83], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.uncurrySum_aux_apply", "code": "@[simp]\ntheorem uncurrySum_aux_apply\n    (f : MultilinearMap R (fun _ : \u03b9 => M') (MultilinearMap R (fun _ : \u03b9' => M') M\u2082))\n    (u : Sum \u03b9 \u03b9' \u2192 M') : f.uncurrySum u = f (u \u2218 Sum.inl) (u \u2218 Sum.inr)", "start": [1468, 1], "end": [1472, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.currySumEquiv", "code": "def currySumEquiv :\n    MultilinearMap R (fun _ : Sum \u03b9 \u03b9' => M') M\u2082 \u2243\u2097[R]\n      MultilinearMap R (fun _ : \u03b9 => M') (MultilinearMap R (fun _ : \u03b9' => M') M\u2082) where\n  toFun := currySum\n  invFun := uncurrySum\n  left_inv f := ext fun u => by simp\n  right_inv f := by\n    ext\n    simp\n  map_add' f g := by\n    ext\n    rfl\n  map_smul' c f := by\n    ext\n    rfl", "start": [1477, 1], "end": [1494, 8], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_currySumEquiv", "code": "@[simp]\ntheorem coe_currySumEquiv : \u21d1(currySumEquiv R \u03b9 M\u2082 M' \u03b9') = currySum", "start": [1499, 1], "end": [1501, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.coe_currySumEquiv_symm", "code": "@[simp]\ntheorem coe_currySumEquiv_symm : \u21d1(currySumEquiv R \u03b9 M\u2082 M' \u03b9').symm = uncurrySum", "start": [1505, 1], "end": [1507, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset", "code": "def curryFinFinset {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k) (hl : s\u1d9c.card = l) :\n    MultilinearMap R (fun _ : Fin n => M') M\u2082 \u2243\u2097[R]\n      MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M\u2082) :=\n  (domDomCongrLinearEquiv R R M' M\u2082 (finSumEquivOfFinset hk hl).symm).trans\n    (currySumEquiv R (Fin k) M\u2082 M' (Fin l))", "start": [1512, 1], "end": [1520, 44], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_apply", "code": "@[simp]\ntheorem curryFinFinset_apply {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k) (hl : s\u1d9c.card = l)\n    (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (mk : Fin k \u2192 M') (ml : Fin l \u2192 M') :\n    curryFinFinset R M\u2082 M' hk hl f mk ml =\n      f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i)", "start": [1525, 1], "end": [1530, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_symm_apply", "code": "@[simp]\ntheorem curryFinFinset_symm_apply {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : s\u1d9c.card = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M\u2082))\n    (m : Fin n \u2192 M') :\n    (curryFinFinset R M\u2082 M' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i =>\n        m <| finSumEquivOfFinset hk hl (Sum.inr i)", "start": [1533, 1], "end": [1541, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_symm_apply_piecewise_const", "code": "theorem curryFinFinset_symm_apply_piecewise_const {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : s\u1d9c.card = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M\u2082))\n    (x y : M') :\n    (curryFinFinset R M\u2082 M' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) =\n      f (fun _ => x) fun _ => y", "start": [1545, 1], "end": [1557, 62], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_symm_apply_piecewise_const_aux", "code": "@[simp]\ntheorem curryFinFinset_symm_apply_piecewise_const_aux {k l n : \u2115} {s : Finset (Fin n)}\n    (hk : s.card = k) (hl : s\u1d9c.card = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M\u2082))\n    (x y : M') :\n      ((\u21d1f fun _ => x) (fun i => (Finset.piecewise s (fun _ => x) (fun _ => y)\n          ((\u21d1(finSumEquivOfFinset hk hl)) (Sum.inr i)))) = f (fun _ => x) fun _ => y)", "start": [1560, 1], "end": [1570, 13], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_symm_apply_const", "code": "@[simp]\ntheorem curryFinFinset_symm_apply_const {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : s\u1d9c.card = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M\u2082))\n    (x : M') : ((curryFinFinset R M\u2082 M' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x", "start": [1572, 1], "end": [1577, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_apply_const", "code": "theorem curryFinFinset_apply_const {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : s\u1d9c.card = l) (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (x y : M') :\n    (curryFinFinset R M\u2082 M' hk hl f (fun _ => x) fun _ => y) =\n      f (s.piecewise (fun _ => x) fun _ => y)", "start": [1581, 1], "end": [1587, 36], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.curryFinFinset_apply_const_aux", "code": "@[simp]\ntheorem curryFinFinset_apply_const_aux {k l n : \u2115} {s : Finset (Fin n)} (hk : s.card = k)\n    (hl : s\u1d9c.card = l) (f : MultilinearMap R (fun _ : Fin n => M') M\u2082) (x y : M') :\n    (f fun i => Sum.elim (fun _ => x) (fun _ => y) ((\u21d1 (Equiv.symm (finSumEquivOfFinset hk hl))) i))\n      = f (s.piecewise (fun _ => x) fun _ => y)", "start": [1590, 1], "end": [1596, 35], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map", "code": "def map [Nonempty \u03b9] (f : MultilinearMap R M\u2081 M\u2082) (p : \u2200 i, Submodule R (M\u2081 i)) : SubMulAction R M\u2082\n    where\n  carrier := f '' { v | \u2200 i, v i \u2208 p i }\n  smul_mem' := fun c _ \u27e8x, hx, hf\u27e9 => by\n    let \u27e8i\u27e9 := \u2039Nonempty \u03b9\u203a\n    letI := Classical.decEq \u03b9\n    refine' \u27e8update x i (c \u2022 x i), fun j => if hij : j = i then _ else _, hf \u25b8 _\u27e9\n    \u00b7 rw [hij, update_same]\n      exact (p i).smul_mem _ (hx i)\n    \u00b7 rw [update_noteq hij]\n      exact hx j\n    \u00b7 rw [f.map_smul, update_eq_self]", "start": [1609, 1], "end": [1623, 38], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.map_nonempty", "code": "theorem map_nonempty [Nonempty \u03b9] (f : MultilinearMap R M\u2081 M\u2082) (p : \u2200 i, Submodule R (M\u2081 i)) :\n    (map f p : Set M\u2082).Nonempty", "start": [1626, 1], "end": [1629, 41], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.range", "code": "def range [Nonempty \u03b9] (f : MultilinearMap R M\u2081 M\u2082) : SubMulAction R M\u2082 :=\n  f.map fun _ => \u22a4", "start": [1632, 1], "end": [1634, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Basic.lean", "imports": ["Mathlib/Algebra/Regular/Pow.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Algebra/MonoidAlgebra/Support.lean", "Mathlib/Data/Finsupp/Antidiagonal.lean", "Mathlib/Order/SymmDiff.lean"], "premises": [{"full_name": "MvPolynomial", "code": "def MvPolynomial (\u03c3 : Type*) (R : Type*) [CommSemiring R] :=\n  AddMonoidAlgebra R (\u03c3 \u2192\u2080 \u2115)", "start": [87, 1], "end": [90, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.decidableEqMvPolynomial", "code": "instance decidableEqMvPolynomial [CommSemiring R] [DecidableEq \u03c3] [DecidableEq R] :\n    DecidableEq (MvPolynomial \u03c3 R) :=\n  Finsupp.decidableEq", "start": [105, 1], "end": [107, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.commSemiring", "code": "instance commSemiring [CommSemiring R] : CommSemiring (MvPolynomial \u03c3 R) :=\n  AddMonoidAlgebra.commSemiring", "start": [110, 1], "end": [111, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.inhabited", "code": "instance inhabited [CommSemiring R] : Inhabited (MvPolynomial \u03c3 R) :=\n  \u27e80\u27e9", "start": [113, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.distribuMulAction", "code": "instance distribuMulAction [Monoid R] [CommSemiring S\u2081] [DistribMulAction R S\u2081] :\n    DistribMulAction R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.distribMulAction", "start": [116, 1], "end": [118, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smulZeroClass", "code": "instance smulZeroClass [CommSemiring S\u2081] [SMulZeroClass R S\u2081] :\n    SMulZeroClass R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.smulZeroClass", "start": [120, 1], "end": [122, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.faithfulSMul", "code": "instance faithfulSMul [CommSemiring S\u2081] [SMulZeroClass R S\u2081] [FaithfulSMul R S\u2081] :\n    FaithfulSMul R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.faithfulSMul", "start": [124, 1], "end": [126, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.module", "code": "instance module [Semiring R] [CommSemiring S\u2081] [Module R S\u2081] : Module R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.module", "start": [128, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isScalarTower", "code": "instance isScalarTower [CommSemiring S\u2082] [SMul R S\u2081] [SMulZeroClass R S\u2082] [SMulZeroClass S\u2081 S\u2082]\n    [IsScalarTower R S\u2081 S\u2082] : IsScalarTower R S\u2081 (MvPolynomial \u03c3 S\u2082) :=\n  AddMonoidAlgebra.isScalarTower", "start": [131, 1], "end": [133, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smulCommClass", "code": "instance smulCommClass [CommSemiring S\u2082] [SMulZeroClass R S\u2082] [SMulZeroClass S\u2081 S\u2082]\n    [SMulCommClass R S\u2081 S\u2082] : SMulCommClass R S\u2081 (MvPolynomial \u03c3 S\u2082) :=\n  AddMonoidAlgebra.smulCommClass", "start": [135, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isCentralScalar", "code": "instance isCentralScalar [CommSemiring S\u2081] [SMulZeroClass R S\u2081] [SMulZeroClass R\u1d50\u1d52\u1d56 S\u2081]\n    [IsCentralScalar R S\u2081] : IsCentralScalar R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.isCentralScalar", "start": [139, 1], "end": [141, 35], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algebra", "code": "instance algebra [CommSemiring R] [CommSemiring S\u2081] [Algebra R S\u2081] :\n    Algebra R (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.algebra", "start": [143, 1], "end": [145, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isScalarTower_right", "code": "instance isScalarTower_right [CommSemiring S\u2081] [DistribSMul R S\u2081] [IsScalarTower R S\u2081 S\u2081] :\n    IsScalarTower R (MvPolynomial \u03c3 S\u2081) (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.isScalarTower_self _", "start": [147, 1], "end": [149, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smulCommClass_right", "code": "instance smulCommClass_right [CommSemiring S\u2081] [DistribSMul R S\u2081] [SMulCommClass R S\u2081 S\u2081] :\n    SMulCommClass R (MvPolynomial \u03c3 S\u2081) (MvPolynomial \u03c3 S\u2081) :=\n  AddMonoidAlgebra.smulCommClass_self _", "start": [152, 1], "end": [154, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.unique", "code": "instance unique [CommSemiring R] [Subsingleton R] : Unique (MvPolynomial \u03c3 R) :=\n  AddMonoidAlgebra.unique", "start": [157, 1], "end": [159, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial", "code": "def monomial (s : \u03c3 \u2192\u2080 \u2115) : R \u2192\u2097[R] MvPolynomial \u03c3 R :=\n  lsingle s", "start": [166, 1], "end": [168, 12], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.single_eq_monomial", "code": "theorem single_eq_monomial (s : \u03c3 \u2192\u2080 \u2115) (a : R) : Finsupp.single s a = monomial s a", "start": [171, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mul_def", "code": "theorem mul_def : p * q = p.sum fun m a => q.sum fun n b => monomial (m + n) (a * b)", "start": [175, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C", "code": "def C : R \u2192+* MvPolynomial \u03c3 R :=\n  { singleZeroRingHom with toFun := monomial 0 }", "start": [179, 1], "end": [181, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algebraMap_eq", "code": "theorem algebraMap_eq : algebraMap R (MvPolynomial \u03c3 R) = C", "start": [186, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X", "code": "def X (n : \u03c3) : MvPolynomial \u03c3 R :=\n  monomial (Finsupp.single n 1) 1", "start": [192, 1], "end": [194, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_left_injective", "code": "theorem monomial_left_injective {r : R} (hr : r \u2260 0) :\n    Function.Injective fun s : \u03c3 \u2192\u2080 \u2115 => monomial s r", "start": [197, 1], "end": [199, 35], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_left_inj", "code": "@[simp]\ntheorem monomial_left_inj {s t : \u03c3 \u2192\u2080 \u2115} {r : R} (hr : r \u2260 0) :\n    monomial s r = monomial t r \u2194 s = t", "start": [202, 1], "end": [205, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_apply", "code": "theorem C_apply : (C a : MvPolynomial \u03c3 R) = monomial 0 a", "start": [208, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_0", "code": "theorem C_0 : C 0 = (0 : MvPolynomial \u03c3 R)", "start": [213, 1], "end": [213, 57], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_1", "code": "theorem C_1 : C 1 = (1 : MvPolynomial \u03c3 R)", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_mul_monomial", "code": "theorem C_mul_monomial : C a * monomial s a' = monomial s (a * a')", "start": [221, 1], "end": [224, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_add", "code": "theorem C_add : (C (a + a') : MvPolynomial \u03c3 R) = C a + C a'", "start": [228, 1], "end": [229, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_mul", "code": "theorem C_mul : (C (a * a') : MvPolynomial \u03c3 R) = C a * C a'", "start": [233, 1], "end": [234, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_pow", "code": "theorem C_pow (a : R) (n : \u2115) : (C (a ^ n) : MvPolynomial \u03c3 R) = C a ^ n", "start": [238, 1], "end": [239, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_injective", "code": "theorem C_injective (\u03c3 : Type*) (R : Type*) [CommSemiring R] :\n    Function.Injective (C : R \u2192 MvPolynomial \u03c3 R)", "start": [242, 1], "end": [244, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_surjective", "code": "theorem C_surjective {R : Type*} [CommSemiring R] (\u03c3 : Type*) [IsEmpty \u03c3] :\n    Function.Surjective (C : R \u2192 MvPolynomial \u03c3 R)", "start": [247, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_inj", "code": "@[simp]\ntheorem C_inj {\u03c3 : Type*} (R : Type*) [CommSemiring R] (r s : R) :\n    (C r : MvPolynomial \u03c3 R) = C s \u2194 r = s", "start": [255, 1], "end": [258, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.infinite_of_infinite", "code": "instance infinite_of_infinite (\u03c3 : Type*) (R : Type*) [CommSemiring R] [Infinite R] :\n    Infinite (MvPolynomial \u03c3 R) :=\n  Infinite.of_injective C (C_injective _ _)", "start": [261, 1], "end": [263, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.infinite_of_nonempty", "code": "instance infinite_of_nonempty (\u03c3 : Type*) (R : Type*) [Nonempty \u03c3] [CommSemiring R]\n    [Nontrivial R] : Infinite (MvPolynomial \u03c3 R) :=\n  Infinite.of_injective ((fun s : \u03c3 \u2192\u2080 \u2115 => monomial s 1) \u2218 Finsupp.single (Classical.arbitrary \u03c3))\n    <| (monomial_left_injective one_ne_zero).comp (Finsupp.single_injective _)", "start": [266, 1], "end": [269, 79], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_eq_coe_nat", "code": "theorem C_eq_coe_nat (n : \u2115) : (C \u2191n : MvPolynomial \u03c3 R) = n", "start": [272, 1], "end": [273, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_mul'", "code": "theorem C_mul' : MvPolynomial.C a * p = a \u2022 p", "start": [276, 1], "end": [277, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smul_eq_C_mul", "code": "theorem smul_eq_C_mul (p : MvPolynomial \u03c3 R) (a : R) : a \u2022 p = C a * p", "start": [280, 1], "end": [281, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_eq_smul_one", "code": "theorem C_eq_smul_one : (C a : MvPolynomial \u03c3 R) = a \u2022 (1 : MvPolynomial \u03c3 R)", "start": [284, 1], "end": [285, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smul_monomial", "code": "theorem smul_monomial {S\u2081 : Type*} [SMulZeroClass S\u2081 R] (r : S\u2081) :\n    r \u2022 monomial s a = monomial s (r \u2022 a)", "start": [288, 1], "end": [290, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_injective", "code": "theorem X_injective [Nontrivial R] : Function.Injective (X : \u03c3 \u2192 MvPolynomial \u03c3 R)", "start": [293, 1], "end": [294, 89], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_inj", "code": "@[simp]\ntheorem X_inj [Nontrivial R] (m n : \u03c3) : X m = (X n : MvPolynomial \u03c3 R) \u2194 m = n", "start": [297, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_pow", "code": "theorem monomial_pow : monomial s a ^ e = monomial (e \u2022 s) (a ^ e)", "start": [302, 1], "end": [303, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_mul", "code": "@[simp]\ntheorem monomial_mul {s s' : \u03c3 \u2192\u2080 \u2115} {a b : R} :\n    monomial s a * monomial s' b = monomial (s + s') (a * b)", "start": [306, 1], "end": [309, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomialOneHom", "code": "def monomialOneHom : Multiplicative (\u03c3 \u2192\u2080 \u2115) \u2192* MvPolynomial \u03c3 R :=\n  AddMonoidAlgebra.of _ _", "start": [314, 1], "end": [316, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomialOneHom_apply", "code": "@[simp]\ntheorem monomialOneHom_apply : monomialOneHom R \u03c3 s = (monomial s 1 : MvPolynomial \u03c3 R)", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.X_pow_eq_monomial", "code": "theorem X_pow_eq_monomial : X n ^ e = monomial (Finsupp.single n e) (1 : R)", "start": [326, 1], "end": [327, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_add_single", "code": "theorem monomial_add_single : monomial (s + Finsupp.single n e) a = monomial s a * X n ^ e", "start": [330, 1], "end": [331, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_single_add", "code": "theorem monomial_single_add : monomial (Finsupp.single n e + s) a = X n ^ e * monomial s a", "start": [334, 1], "end": [335, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_mul_X_pow_eq_monomial", "code": "theorem C_mul_X_pow_eq_monomial {s : \u03c3} {a : R} {n : \u2115} :\n    C a * X s ^ n = monomial (Finsupp.single s n) a", "start": [338, 1], "end": [340, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_mul_X_eq_monomial", "code": "theorem C_mul_X_eq_monomial {s : \u03c3} {a : R} : C a * X s = monomial (Finsupp.single s 1) a", "start": [343, 1], "end": [344, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_zero", "code": "theorem monomial_zero {s : \u03c3 \u2192\u2080 \u2115} : monomial s (0 : R) = 0", "start": [348, 1], "end": [349, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_zero'", "code": "@[simp]\ntheorem monomial_zero' : (monomial (0 : \u03c3 \u2192\u2080 \u2115) : R \u2192 MvPolynomial \u03c3 R) = C", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_eq_zero", "code": "@[simp]\ntheorem monomial_eq_zero {s : \u03c3 \u2192\u2080 \u2115} {b : R} : monomial s b = 0 \u2194 b = 0", "start": [357, 1], "end": [359, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_monomial_eq", "code": "@[simp]\ntheorem sum_monomial_eq {A : Type*} [AddCommMonoid A] {u : \u03c3 \u2192\u2080 \u2115} {r : R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A}\n    (w : b u 0 = 0) : sum (monomial u r) b = b u r", "start": [362, 1], "end": [365, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_C", "code": "@[simp]\ntheorem sum_C {A : Type*} [AddCommMonoid A] {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A} (w : b 0 0 = 0) :\n    sum (C a) b = b 0 a", "start": [368, 1], "end": [371, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_sum_one", "code": "theorem monomial_sum_one {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u03c3 \u2192\u2080 \u2115) :\n    (monomial (\u2211 i in s, f i) 1 : MvPolynomial \u03c3 R) = \u220f i in s, monomial (f i) 1", "start": [374, 1], "end": [376, 72], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_sum_index", "code": "theorem monomial_sum_index {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u03c3 \u2192\u2080 \u2115) (a : R) :\n    monomial (\u2211 i in s, f i) a = C a * \u220f i in s, monomial (f i) 1", "start": [379, 1], "end": [381, 81], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_finsupp_sum_index", "code": "theorem monomial_finsupp_sum_index {\u03b1 \u03b2 : Type*} [Zero \u03b2] (f : \u03b1 \u2192\u2080 \u03b2) (g : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192\u2080 \u2115)\n    (a : R) : monomial (f.sum g) a = C a * f.prod fun a b => monomial (g a b) 1", "start": [384, 1], "end": [386, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_eq_monomial_iff", "code": "theorem monomial_eq_monomial_iff {\u03b1 : Type*} (a\u2081 a\u2082 : \u03b1 \u2192\u2080 \u2115) (b\u2081 b\u2082 : R) :\n    monomial a\u2081 b\u2081 = monomial a\u2082 b\u2082 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 \u2228 b\u2081 = 0 \u2227 b\u2082 = 0", "start": [389, 1], "end": [391, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_eq", "code": "theorem monomial_eq : monomial s a = C a * (s.prod fun n e => X n ^ e : MvPolynomial \u03c3 R)", "start": [394, 1], "end": [395, 82], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.induction_on_monomial", "code": "theorem induction_on_monomial {M : MvPolynomial \u03c3 R \u2192 Prop} (h_C : \u2200 a, M (C a))\n    (h_X : \u2200 p n, M p \u2192 M (p * X n)) : \u2200 s a, M (monomial s a)", "start": [398, 1], "end": [410, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.induction_on'", "code": "@[elab_as_elim]\ntheorem induction_on' {P : MvPolynomial \u03c3 R \u2192 Prop} (p : MvPolynomial \u03c3 R)\n    (h1 : \u2200 (u : \u03c3 \u2192\u2080 \u2115) (a : R), P (monomial u a))\n    (h2 : \u2200 p q : MvPolynomial \u03c3 R, P p \u2192 P q \u2192 P (p + q)) : P p", "start": [413, 1], "end": [424, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.induction_on'''", "code": "theorem induction_on''' {M : MvPolynomial \u03c3 R \u2192 Prop} (p : MvPolynomial \u03c3 R) (h_C : \u2200 a, M (C a))\n    (h_add_weak :\n      \u2200 (a : \u03c3 \u2192\u2080 \u2115) (b : R) (f : (\u03c3 \u2192\u2080 \u2115) \u2192\u2080 R),\n        a \u2209 f.support \u2192 b \u2260 0 \u2192 M f \u2192 M ((show (\u03c3 \u2192\u2080 \u2115) \u2192\u2080 R from monomial a b) + f)) :\n    M p", "start": [427, 1], "end": [434, 52], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.induction_on''", "code": "theorem induction_on'' {M : MvPolynomial \u03c3 R \u2192 Prop} (p : MvPolynomial \u03c3 R) (h_C : \u2200 a, M (C a))\n    (h_add_weak :\n      \u2200 (a : \u03c3 \u2192\u2080 \u2115) (b : R) (f : (\u03c3 \u2192\u2080 \u2115) \u2192\u2080 R),\n        a \u2209 f.support \u2192 b \u2260 0 \u2192 M f \u2192 M (monomial a b) \u2192\n          M ((show (\u03c3 \u2192\u2080 \u2115) \u2192\u2080 R from monomial a b) + f))\n    (h_X : \u2200 (p : MvPolynomial \u03c3 R) (n : \u03c3), M p \u2192 M (p * MvPolynomial.X n)) : M p", "start": [437, 1], "end": [446, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.induction_on", "code": "@[recursor 5]\ntheorem induction_on {M : MvPolynomial \u03c3 R \u2192 Prop} (p : MvPolynomial \u03c3 R) (h_C : \u2200 a, M (C a))\n    (h_add : \u2200 p q, M p \u2192 M q \u2192 M (p + q)) (h_X : \u2200 p n, M p \u2192 M (p * X n)) : M p", "start": [449, 1], "end": [453, 85], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ringHom_ext", "code": "theorem ringHom_ext {A : Type*} [Semiring A] {f g : MvPolynomial \u03c3 R \u2192+* A}\n    (hC : \u2200 r, f (C r) = g (C r)) (hX : \u2200 i, f (X i) = g (X i)) : f = g", "start": [456, 1], "end": [466, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ringHom_ext'", "code": "@[ext 1100]\ntheorem ringHom_ext' {A : Type*} [Semiring A] {f g : MvPolynomial \u03c3 R \u2192+* A}\n    (hC : f.comp C = g.comp C) (hX : \u2200 i, f (X i) = g (X i)) : f = g", "start": [469, 1], "end": [473, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.hom_eq_hom", "code": "theorem hom_eq_hom [Semiring S\u2082] (f g : MvPolynomial \u03c3 R \u2192+* S\u2082) (hC : f.comp C = g.comp C)\n    (hX : \u2200 n : \u03c3, f (X n) = g (X n)) (p : MvPolynomial \u03c3 R) : f p = g p", "start": [476, 1], "end": [478, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.is_id", "code": "theorem is_id (f : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 R) (hC : f.comp C = C)\n    (hX : \u2200 n : \u03c3, f (X n) = X n) (p : MvPolynomial \u03c3 R) : f p = p", "start": [481, 1], "end": [483, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algHom_ext'", "code": "@[ext 1100]\ntheorem algHom_ext' {A B : Type*} [CommSemiring A] [CommSemiring B] [Algebra R A] [Algebra R B]\n    {f g : MvPolynomial \u03c3 A \u2192\u2090[R] B}\n    (h\u2081 :\n      f.comp (IsScalarTower.toAlgHom R A (MvPolynomial \u03c3 A)) =\n        g.comp (IsScalarTower.toAlgHom R A (MvPolynomial \u03c3 A)))\n    (h\u2082 : \u2200 i, f (X i) = g (X i)) : f = g", "start": [486, 1], "end": [493, 94], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algHom_ext", "code": "@[ext 1200]\ntheorem algHom_ext {A : Type*} [Semiring A] [Algebra R A] {f g : MvPolynomial \u03c3 R \u2192\u2090[R] A}\n    (hf : \u2200 i : \u03c3, f (X i) = g (X i)) : f = g", "start": [496, 1], "end": [499, 84], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algHom_C", "code": "@[simp]\ntheorem algHom_C (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c3 R) (r : R) : f (C r) = C r", "start": [502, 1], "end": [504, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.adjoin_range_X", "code": "@[simp]\ntheorem adjoin_range_X : Algebra.adjoin R (range (X : \u03c3 \u2192 MvPolynomial \u03c3 R)) = \u22a4", "start": [507, 1], "end": [514, 84], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.linearMap_ext", "code": "@[ext]\ntheorem linearMap_ext {M : Type*} [AddCommMonoid M] [Module R M] {f g : MvPolynomial \u03c3 R \u2192\u2097[R] M}\n    (h : \u2200 s, f \u2218\u2097 monomial s = g \u2218\u2097 monomial s) : f = g", "start": [517, 1], "end": [520, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support", "code": "def support (p : MvPolynomial \u03c3 R) : Finset (\u03c3 \u2192\u2080 \u2115) :=\n  Finsupp.support p", "start": [525, 1], "end": [527, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.finsupp_support_eq_support", "code": "theorem finsupp_support_eq_support (p : MvPolynomial \u03c3 R) : Finsupp.support p = p.support", "start": [530, 1], "end": [531, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_monomial", "code": "theorem support_monomial [h : Decidable (a = 0)] :\n    (monomial s a).support = if a = 0 then \u2205 else {s}", "start": [534, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_monomial_subset", "code": "theorem support_monomial_subset : (monomial s a).support \u2286 {s}", "start": [542, 1], "end": [543, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_add", "code": "theorem support_add [DecidableEq \u03c3] : (p + q).support \u2286 p.support \u222a q.support", "start": [546, 1], "end": [547, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_X", "code": "theorem support_X [Nontrivial R] : (X n : MvPolynomial \u03c3 R).support = {Finsupp.single n 1}", "start": [550, 1], "end": [551, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_X_pow", "code": "theorem support_X_pow [Nontrivial R] (s : \u03c3) (n : \u2115) :\n    (X s ^ n : MvPolynomial \u03c3 R).support = {Finsupp.single s n}", "start": [554, 1], "end": [557, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_zero", "code": "@[simp]\ntheorem support_zero : (0 : MvPolynomial \u03c3 R).support = \u2205", "start": [560, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_smul", "code": "theorem support_smul {S\u2081 : Type*} [SMulZeroClass S\u2081 R] {a : S\u2081} {f : MvPolynomial \u03c3 R} :\n    (a \u2022 f).support \u2286 f.support", "start": [565, 1], "end": [567, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_sum", "code": "theorem support_sum {\u03b1 : Type*} [DecidableEq \u03c3] {s : Finset \u03b1} {f : \u03b1 \u2192 MvPolynomial \u03c3 R} :\n    (\u2211 x in s, f x).support \u2286 s.biUnion fun x => (f x).support", "start": [570, 1], "end": [572, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff", "code": "def coeff (m : \u03c3 \u2192\u2080 \u2115) (p : MvPolynomial \u03c3 R) : R :=\n  @FunLike.coe ((\u03c3 \u2192\u2080 \u2115) \u2192\u2080 R) _ _ _ p m", "start": [579, 1], "end": [581, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_support_iff", "code": "@[simp]\ntheorem mem_support_iff {p : MvPolynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} : m \u2208 p.support \u2194 p.coeff m \u2260 0", "start": [586, 1], "end": [588, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.not_mem_support_iff", "code": "theorem not_mem_support_iff {p : MvPolynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} : m \u2209 p.support \u2194 p.coeff m = 0", "start": [591, 1], "end": [592, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.sum_def", "code": "theorem sum_def {A} [AddCommMonoid A] {p : MvPolynomial \u03c3 R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A} :\n    p.sum b = \u2211 m in p.support, b m (p.coeff m)", "start": [595, 1], "end": [596, 89], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_mul", "code": "theorem support_mul [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    (p * q).support \u2286 p.support.biUnion fun a => q.support.biUnion fun b => {a + b}", "start": [599, 1], "end": [601, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ext", "code": "@[ext]\ntheorem ext (p q : MvPolynomial \u03c3 R) : (\u2200 m, coeff m p = coeff m q) \u2192 p = q", "start": [604, 1], "end": [606, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ext_iff", "code": "theorem ext_iff (p q : MvPolynomial \u03c3 R) : p = q \u2194 \u2200 m, coeff m p = coeff m q", "start": [609, 1], "end": [610, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_add", "code": "@[simp]\ntheorem coeff_add (m : \u03c3 \u2192\u2080 \u2115) (p q : MvPolynomial \u03c3 R) : coeff m (p + q) = coeff m p + coeff m q", "start": [613, 1], "end": [615, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_smul", "code": "@[simp]\ntheorem coeff_smul {S\u2081 : Type*} [SMulZeroClass S\u2081 R] (m : \u03c3 \u2192\u2080 \u2115) (C : S\u2081) (p : MvPolynomial \u03c3 R) :\n    coeff m (C \u2022 p) = C \u2022 coeff m p", "start": [618, 1], "end": [621, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_zero", "code": "@[simp]\ntheorem coeff_zero (m : \u03c3 \u2192\u2080 \u2115) : coeff m (0 : MvPolynomial \u03c3 R) = 0", "start": [624, 1], "end": [626, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_zero_X", "code": "@[simp]\ntheorem coeff_zero_X (i : \u03c3) : coeff 0 (X i : MvPolynomial \u03c3 R) = 0", "start": [629, 1], "end": [631, 63], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeffAddMonoidHom", "code": "@[simps]\ndef coeffAddMonoidHom (m : \u03c3 \u2192\u2080 \u2115) : MvPolynomial \u03c3 R \u2192+ R\n    where\n  toFun := coeff m\n  map_zero' := coeff_zero m\n  map_add' := coeff_add m", "start": [634, 1], "end": [640, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_sum", "code": "theorem coeff_sum {X : Type*} (s : Finset X) (f : X \u2192 MvPolynomial \u03c3 R) (m : \u03c3 \u2192\u2080 \u2115) :\n    coeff m (\u2211 x in s, f x) = \u2211 x in s, coeff m (f x)", "start": [643, 1], "end": [645, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monic_monomial_eq", "code": "theorem monic_monomial_eq (m) :\n    monomial m (1 : R) = (m.prod fun n e => X n ^ e : MvPolynomial \u03c3 R)", "start": [648, 1], "end": [649, 97], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_monomial", "code": "@[simp]\ntheorem coeff_monomial [DecidableEq \u03c3] (m n) (a) :\n    coeff m (monomial n a : MvPolynomial \u03c3 R) = if n = m then a else 0", "start": [652, 1], "end": [655, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_C", "code": "@[simp]\ntheorem coeff_C [DecidableEq \u03c3] (m) (a) :\n    coeff m (C a : MvPolynomial \u03c3 R) = if 0 = m then a else 0", "start": [658, 1], "end": [661, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eq_C_of_isEmpty", "code": "lemma eq_C_of_isEmpty [IsEmpty \u03c3] (p : MvPolynomial \u03c3 R) :\n    p = C (p.coeff 0) := by\n  obtain \u27e8x, rfl\u27e9 := C_surjective \u03c3 p\n  simp", "start": [664, 1], "end": [667, 7], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.coeff_one", "code": "theorem coeff_one [DecidableEq \u03c3] (m) : coeff m (1 : MvPolynomial \u03c3 R) = if 0 = m then 1 else 0", "start": [669, 1], "end": [670, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_zero_C", "code": "theorem coeff_zero_C (a) : coeff 0 (C a : MvPolynomial \u03c3 R) = a", "start": [674, 1], "end": [675, 17], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_zero_one", "code": "@[simp]\ntheorem coeff_zero_one : coeff 0 (1 : MvPolynomial \u03c3 R) = 1", "start": [678, 1], "end": [680, 17], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_X_pow", "code": "theorem coeff_X_pow [DecidableEq \u03c3] (i : \u03c3) (m) (k : \u2115) :\n    coeff m (X i ^ k : MvPolynomial \u03c3 R) = if Finsupp.single i k = m then 1 else 0", "start": [683, 1], "end": [688, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_X'", "code": "theorem coeff_X' [DecidableEq \u03c3] (i : \u03c3) (m) :\n    coeff m (X i : MvPolynomial \u03c3 R) = if Finsupp.single i 1 = m then 1 else 0", "start": [691, 1], "end": [693, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_X", "code": "@[simp]\ntheorem coeff_X (i : \u03c3) : coeff (Finsupp.single i 1) (X i : MvPolynomial \u03c3 R) = 1", "start": [696, 1], "end": [698, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_C_mul", "code": "@[simp]\ntheorem coeff_C_mul (m) (a : R) (p : MvPolynomial \u03c3 R) : coeff m (C a * p) = a * coeff m p", "start": [701, 1], "end": [706, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_mul", "code": "theorem coeff_mul [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) (n : \u03c3 \u2192\u2080 \u2115) :\n    coeff n (p * q) = \u2211 x in antidiagonal n, coeff x.1 p * coeff x.2 q", "start": [709, 1], "end": [711, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_mul_monomial", "code": "@[simp]\ntheorem coeff_mul_monomial (m) (s : \u03c3 \u2192\u2080 \u2115) (r : R) (p : MvPolynomial \u03c3 R) :\n    coeff (m + s) (p * monomial s r) = coeff m p * r", "start": [714, 1], "end": [717, 75], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_monomial_mul", "code": "@[simp]\ntheorem coeff_monomial_mul (m) (s : \u03c3 \u2192\u2080 \u2115) (r : R) (p : MvPolynomial \u03c3 R) :\n    coeff (s + m) (monomial s r * p) = r * coeff m p", "start": [720, 1], "end": [723, 76], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_mul_X", "code": "@[simp]\ntheorem coeff_mul_X (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    coeff (m + Finsupp.single s 1) (p * X s) = coeff m p", "start": [726, 1], "end": [729, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_X_mul", "code": "@[simp]\ntheorem coeff_X_mul (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    coeff (Finsupp.single s 1 + m) (X s * p) = coeff m p", "start": [732, 1], "end": [735, 49], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_mul_X", "code": "@[simp]\ntheorem support_mul_X (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    (p * X s).support = p.support.map (addRightEmbedding (Finsupp.single s 1))", "start": [738, 1], "end": [741, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_X_mul", "code": "@[simp]\ntheorem support_X_mul (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    (X s * p).support = p.support.map (addLeftEmbedding (Finsupp.single s 1))", "start": [744, 1], "end": [747, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_smul_eq", "code": "@[simp]\ntheorem support_smul_eq {S\u2081 : Type*} [Semiring S\u2081] [Module S\u2081 R] [NoZeroSMulDivisors S\u2081 R] {a : S\u2081}\n    (h : a \u2260 0) (p : MvPolynomial \u03c3 R) : (a \u2022 p).support = p.support", "start": [750, 1], "end": [753, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_sdiff_support_subset_support_add", "code": "theorem support_sdiff_support_subset_support_add [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    p.support \\ q.support \u2286 (p + q).support", "start": [756, 1], "end": [760, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_symmDiff_support_subset_support_add", "code": "theorem support_symmDiff_support_subset_support_add [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    p.support \u2206 q.support \u2286 (p + q).support", "start": [763, 1], "end": [769, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_mul_monomial'", "code": "theorem coeff_mul_monomial' (m) (s : \u03c3 \u2192\u2080 \u2115) (r : R) (p : MvPolynomial \u03c3 R) :\n    coeff m (p * monomial s r) = if s \u2264 m then coeff (m - s) p * r else 0", "start": [772, 1], "end": [792, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_monomial_mul'", "code": "theorem coeff_monomial_mul' (m) (s : \u03c3 \u2192\u2080 \u2115) (r : R) (p : MvPolynomial \u03c3 R) :\n    coeff m (monomial s r * p) = if s \u2264 m then r * coeff (m - s) p else 0", "start": [795, 1], "end": [799, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_mul_X'", "code": "theorem coeff_mul_X' [DecidableEq \u03c3] (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    coeff m (p * X s) = if s \u2208 m.support then coeff (m - Finsupp.single s 1) p else 0", "start": [802, 1], "end": [806, 13], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_X_mul'", "code": "theorem coeff_X_mul' [DecidableEq \u03c3] (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\n    coeff m (X s * p) = if s \u2208 m.support then coeff (m - Finsupp.single s 1) p else 0", "start": [809, 1], "end": [813, 13], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eq_zero_iff", "code": "theorem eq_zero_iff {p : MvPolynomial \u03c3 R} : p = 0 \u2194 \u2200 d, coeff d p = 0", "start": [816, 1], "end": [818, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.ne_zero_iff", "code": "theorem ne_zero_iff {p : MvPolynomial \u03c3 R} : p \u2260 0 \u2194 \u2203 d, coeff d p \u2260 0", "start": [821, 1], "end": [824, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_eq_empty", "code": "@[simp]\ntheorem support_eq_empty {p : MvPolynomial \u03c3 R} : p.support = \u2205 \u2194 p = 0", "start": [827, 1], "end": [829, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_coeff_ne_zero", "code": "theorem exists_coeff_ne_zero {p : MvPolynomial \u03c3 R} (h : p \u2260 0) : \u2203 d, coeff d p \u2260 0", "start": [832, 1], "end": [833, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_dvd_iff_dvd_coeff", "code": "theorem C_dvd_iff_dvd_coeff (r : R) (\u03c6 : MvPolynomial \u03c3 R) : C r \u2223 \u03c6 \u2194 \u2200 i, r \u2223 \u03c6.coeff i", "start": [836, 1], "end": [853, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.isRegular_X", "code": "@[simp] lemma isRegular_X : IsRegular (X n : MvPolynomial \u03c3 R) := by\n  suffices : IsLeftRegular (X n : MvPolynomial \u03c3 R)\n  \u00b7 exact \u27e8this, this.right_of_commute $ Commute.all _\u27e9\n  intro P Q (hPQ : (X n) * P = (X n) * Q)\n  ext i\n  rw [\u2190 coeff_X_mul i n P, hPQ, coeff_X_mul i n Q]", "start": [856, 1], "end": [861, 51], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.isRegular_X_pow", "code": "@[simp] lemma isRegular_X_pow (k : \u2115) : IsRegular (X n ^ k : MvPolynomial \u03c3 R) := isRegular_X.pow k", "start": [863, 1], "end": [863, 100], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.isRegular_prod_X", "code": "@[simp] lemma isRegular_prod_X (s : Finset \u03c3) :\n    IsRegular (\u220f n in s, X n : MvPolynomial \u03c3 R) :=\n  IsRegular.prod fun _ _ \u21a6 isRegular_X", "start": [865, 1], "end": [867, 39], "kind": "mathlibtacticlemma"}, {"full_name": "MvPolynomial.constantCoeff", "code": "def constantCoeff : MvPolynomial \u03c3 R \u2192+* R\n    where\n  toFun := coeff 0\n  map_one' := by simp [AddMonoidAlgebra.one_def]\n  map_mul' := by classical simp [coeff_mul, Finsupp.support_single_ne_zero]\n  map_zero' := coeff_zero _\n  map_add' := coeff_add _", "start": [873, 1], "end": [882, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_eq", "code": "theorem constantCoeff_eq : (constantCoeff : MvPolynomial \u03c3 R \u2192 R) = coeff 0", "start": [885, 1], "end": [886, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_C", "code": "@[simp]\ntheorem constantCoeff_C (r : R) : constantCoeff (C r : MvPolynomial \u03c3 R) = r", "start": [891, 1], "end": [893, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_X", "code": "@[simp]\ntheorem constantCoeff_X (i : \u03c3) : constantCoeff (X i : MvPolynomial \u03c3 R) = 0", "start": [900, 1], "end": [902, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_smul", "code": "@[simp 1001]\ntheorem constantCoeff_smul {R : Type*} [SMulZeroClass R S\u2081] (a : R) (f : MvPolynomial \u03c3 S\u2081) :\n    constantCoeff (a \u2022 f) = a \u2022 constantCoeff f", "start": [908, 1], "end": [911, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_monomial", "code": "theorem constantCoeff_monomial [DecidableEq \u03c3] (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\n    constantCoeff (monomial d r) = if d = 0 then r else 0", "start": [914, 1], "end": [916, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_comp_C", "code": "@[simp]\ntheorem constantCoeff_comp_C : constantCoeff.comp (C : R \u2192+* MvPolynomial \u03c3 R) = RingHom.id R", "start": [921, 1], "end": [924, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_comp_algebraMap", "code": "@[simp]\ntheorem constantCoeff_comp_algebraMap :\n    constantCoeff.comp (algebraMap R (MvPolynomial \u03c3 R)) = RingHom.id R", "start": [927, 1], "end": [930, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_sum_monomial_coeff", "code": "@[simp]\ntheorem support_sum_monomial_coeff (p : MvPolynomial \u03c3 R) :\n    (\u2211 v in p.support, monomial v (coeff v p)) = p", "start": [937, 1], "end": [940, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.as_sum", "code": "theorem as_sum (p : MvPolynomial \u03c3 R) : p = \u2211 v in p.support, monomial v (coeff v p)", "start": [943, 1], "end": [944, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082", "code": "def eval\u2082 (p : MvPolynomial \u03c3 R) : S\u2081 :=\n  p.sum fun s a => f a * s.prod fun n e => g n ^ e", "start": [953, 1], "end": [956, 51], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_eq", "code": "theorem eval\u2082_eq (g : R \u2192+* S\u2081) (X : \u03c3 \u2192 S\u2081) (f : MvPolynomial \u03c3 R) :\n    f.eval\u2082 g X = \u2211 d in f.support, g (f.coeff d) * \u220f i in d.support, X i ^ d i", "start": [959, 1], "end": [961, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_eq'", "code": "theorem eval\u2082_eq' [Fintype \u03c3] (g : R \u2192+* S\u2081) (X : \u03c3 \u2192 S\u2081) (f : MvPolynomial \u03c3 R) :\n    f.eval\u2082 g X = \u2211 d in f.support, g (f.coeff d) * \u220f i, X i ^ d i", "start": [964, 1], "end": [967, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_zero", "code": "@[simp]\ntheorem eval\u2082_zero : (0 : MvPolynomial \u03c3 R).eval\u2082 f g = 0", "start": [970, 1], "end": [972, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_add", "code": "@[simp]\ntheorem eval\u2082_add : (p + q).eval\u2082 f g = p.eval\u2082 f g + q.eval\u2082 f g", "start": [977, 1], "end": [979, 94], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_monomial", "code": "@[simp]\ntheorem eval\u2082_monomial : (monomial s a).eval\u2082 f g = f a * s.prod fun n e => g n ^ e", "start": [982, 1], "end": [984, 50], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_C", "code": "@[simp]\ntheorem eval\u2082_C (a) : (C a).eval\u2082 f g = f a", "start": [987, 1], "end": [989, 57], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_one", "code": "@[simp]\ntheorem eval\u2082_one : (1 : MvPolynomial \u03c3 R).eval\u2082 f g = 1", "start": [992, 1], "end": [994, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_X", "code": "@[simp]\ntheorem eval\u2082_X (n) : (X n).eval\u2082 f g = g n", "start": [997, 1], "end": [999, 66], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_mul_monomial", "code": "theorem eval\u2082_mul_monomial :\n    \u2200 {s a}, (p * monomial s a).eval\u2082 f g = p.eval\u2082 f g * f a * s.prod fun n e => g n ^ e", "start": [1002, 1], "end": [1017, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_mul_C", "code": "theorem eval\u2082_mul_C : (p * C a).eval\u2082 f g = p.eval\u2082 f g * f a", "start": [1020, 1], "end": [1021, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_mul", "code": "@[simp]\ntheorem eval\u2082_mul : \u2200 {p}, (p * q).eval\u2082 f g = p.eval\u2082 f g * q.eval\u2082 f g", "start": [1024, 1], "end": [1029, 97], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_pow", "code": "@[simp]\ntheorem eval\u2082_pow {p : MvPolynomial \u03c3 R} : \u2200 {n : \u2115}, (p ^ n).eval\u2082 f g = p.eval\u2082 f g ^ n", "start": [1032, 1], "end": [1037, 78], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom", "code": "def eval\u2082Hom (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) : MvPolynomial \u03c3 R \u2192+* S\u2081\n    where\n  toFun := eval\u2082 f g\n  map_one' := eval\u2082_one _ _\n  map_mul' _ _ := eval\u2082_mul _ _\n  map_zero' := eval\u2082_zero f g\n  map_add' _ _ := eval\u2082_add _ _", "start": [1040, 1], "end": [1047, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coe_eval\u2082Hom", "code": "@[simp]\ntheorem coe_eval\u2082Hom (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) : \u21d1(eval\u2082Hom f g) = eval\u2082 f g", "start": [1050, 1], "end": [1052, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_congr", "code": "theorem eval\u2082Hom_congr {f\u2081 f\u2082 : R \u2192+* S\u2081} {g\u2081 g\u2082 : \u03c3 \u2192 S\u2081} {p\u2081 p\u2082 : MvPolynomial \u03c3 R} :\n    f\u2081 = f\u2082 \u2192 g\u2081 = g\u2082 \u2192 p\u2081 = p\u2082 \u2192 eval\u2082Hom f\u2081 g\u2081 p\u2081 = eval\u2082Hom f\u2082 g\u2082 p\u2082", "start": [1055, 1], "end": [1057, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_C", "code": "@[simp]\ntheorem eval\u2082Hom_C (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (r : R) : eval\u2082Hom f g (C r) = f r", "start": [1062, 1], "end": [1064, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_X'", "code": "@[simp]\ntheorem eval\u2082Hom_X' (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (i : \u03c3) : eval\u2082Hom f g (X i) = g i", "start": [1067, 1], "end": [1069, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comp_eval\u2082Hom", "code": "@[simp]\ntheorem comp_eval\u2082Hom [CommSemiring S\u2082] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (\u03c6 : S\u2081 \u2192+* S\u2082) :\n    \u03c6.comp (eval\u2082Hom f g) = eval\u2082Hom (\u03c6.comp f) fun i => \u03c6 (g i)", "start": [1072, 1], "end": [1079, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_eval\u2082Hom", "code": "theorem map_eval\u2082Hom [CommSemiring S\u2082] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (\u03c6 : S\u2081 \u2192+* S\u2082)\n    (p : MvPolynomial \u03c3 R) : \u03c6 (eval\u2082Hom f g p) = eval\u2082Hom (\u03c6.comp f) (fun i => \u03c6 (g i)) p", "start": [1082, 1], "end": [1085, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_monomial", "code": "theorem eval\u2082Hom_monomial (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\n    eval\u2082Hom f g (monomial d r) = f r * d.prod fun i k => g i ^ k", "start": [1088, 1], "end": [1091, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_comp_left", "code": "theorem eval\u2082_comp_left {S\u2082} [CommSemiring S\u2082] (k : S\u2081 \u2192+* S\u2082) (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (p) :\n    k (eval\u2082 f g p) = eval\u2082 (k.comp f) (k \u2218 g) p", "start": [1096, 1], "end": [1099, 89], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_eta", "code": "@[simp]\ntheorem eval\u2082_eta (p : MvPolynomial \u03c3 R) : eval\u2082 C X p = p", "start": [1104, 1], "end": [1107, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_congr", "code": "theorem eval\u2082_congr (g\u2081 g\u2082 : \u03c3 \u2192 S\u2081)\n    (h : \u2200 {i : \u03c3} {c : \u03c3 \u2192\u2080 \u2115}, i \u2208 c.support \u2192 coeff c p \u2260 0 \u2192 g\u2081 i = g\u2082 i) :\n    p.eval\u2082 f g\u2081 = p.eval\u2082 f g\u2082", "start": [1110, 1], "end": [1118, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_sum", "code": "theorem eval\u2082_sum (s : Finset S\u2082) (p : S\u2082 \u2192 MvPolynomial \u03c3 R) :\n    eval\u2082 f g (\u2211 x in s, p x) = \u2211 x in s, eval\u2082 f g (p x)", "start": [1121, 1], "end": [1123, 29], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_prod", "code": "@[to_additive existing (attr := simp)]\ntheorem eval\u2082_prod (s : Finset S\u2082) (p : S\u2082 \u2192 MvPolynomial \u03c3 R) :\n    eval\u2082 f g (\u220f x in s, p x) = \u220f x in s, eval\u2082 f g (p x)", "start": [1126, 1], "end": [1129, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_assoc", "code": "theorem eval\u2082_assoc (q : S\u2082 \u2192 MvPolynomial \u03c3 R) (p : MvPolynomial S\u2082 R) :\n    eval\u2082 f (fun t => eval\u2082 f g (q t)) p = eval\u2082 f g (eval\u2082 C q p)", "start": [1132, 1], "end": [1135, 58], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval", "code": "def eval (f : \u03c3 \u2192 R) : MvPolynomial \u03c3 R \u2192+* R :=\n  eval\u2082Hom (RingHom.id _) f", "start": [1144, 1], "end": [1146, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_eq", "code": "theorem eval_eq (X : \u03c3 \u2192 R) (f : MvPolynomial \u03c3 R) :\n    eval X f = \u2211 d in f.support, f.coeff d * \u220f i in d.support, X i ^ d i", "start": [1149, 1], "end": [1151, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_eq'", "code": "theorem eval_eq' [Fintype \u03c3] (X : \u03c3 \u2192 R) (f : MvPolynomial \u03c3 R) :\n    eval X f = \u2211 d in f.support, f.coeff d * \u220f i, X i ^ d i", "start": [1154, 1], "end": [1156, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_monomial", "code": "theorem eval_monomial : eval f (monomial s a) = a * s.prod fun n e => f n ^ e", "start": [1159, 1], "end": [1160, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_C", "code": "@[simp]\ntheorem eval_C : \u2200 a, eval f (C a) = a", "start": [1163, 1], "end": [1165, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_X", "code": "@[simp]\ntheorem eval_X : \u2200 n, eval f (X n) = f n", "start": [1168, 1], "end": [1170, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.smul_eval", "code": "@[simp]\ntheorem smul_eval (x) (p : MvPolynomial \u03c3 R) (s) : eval x (s \u2022 p) = s * eval x p", "start": [1173, 1], "end": [1175, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_add", "code": "theorem eval_add : eval f (p + q) = eval f p + eval f q", "start": [1178, 1], "end": [1179, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_mul", "code": "theorem eval_mul : eval f (p * q) = eval f p * eval f q", "start": [1181, 1], "end": [1182, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_pow", "code": "theorem eval_pow : \u2200 n, eval f (p ^ n) = eval f p ^ n", "start": [1184, 1], "end": [1185, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_sum", "code": "theorem eval_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) (g : \u03c3 \u2192 R) :\n    eval g (\u2211 i in s, f i) = \u2211 i in s, eval g (f i)", "start": [1187, 1], "end": [1189, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_prod", "code": "@[to_additive existing]\ntheorem eval_prod {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) (g : \u03c3 \u2192 R) :\n    eval g (\u220f i in s, f i) = \u220f i in s, eval g (f i)", "start": [1192, 1], "end": [1195, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_assoc", "code": "theorem eval_assoc {\u03c4} (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (g : \u03c4 \u2192 R) (p : MvPolynomial \u03c3 R) :\n    eval (eval g \u2218 f) p = eval g (eval\u2082 C f p)", "start": [1198, 1], "end": [1202, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_id", "code": "@[simp]\ntheorem eval\u2082_id (p : MvPolynomial \u03c3 R) : eval\u2082 (RingHom.id _) g p = eval g p", "start": [1205, 1], "end": [1207, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_eval\u2082", "code": "theorem eval_eval\u2082 [CommSemiring R] [CommSemiring S]\n    (f : R \u2192+* MvPolynomial \u03c4 S) (g : \u03c3 \u2192 MvPolynomial \u03c4 S) (p : MvPolynomial \u03c3 R) :\n    eval x (eval\u2082 f g p) = eval\u2082 ((eval x).comp f) (fun s => eval x (g s)) p", "start": [1210, 1], "end": [1218, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map", "code": "def map : MvPolynomial \u03c3 R \u2192+* MvPolynomial \u03c3 S\u2081 :=\n  eval\u2082Hom (C.comp f) X", "start": [1227, 1], "end": [1229, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_monomial", "code": "@[simp]\ntheorem map_monomial (s : \u03c3 \u2192\u2080 \u2115) (a : R) : map f (monomial s a) = monomial s (f a)", "start": [1232, 1], "end": [1234, 46], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_C", "code": "@[simp]\ntheorem map_C : \u2200 a : R, map f (C a : MvPolynomial \u03c3 R) = C (f a)", "start": [1237, 1], "end": [1239, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_X", "code": "@[simp]\ntheorem map_X : \u2200 n : \u03c3, map f (X n : MvPolynomial \u03c3 R) = X n", "start": [1242, 1], "end": [1244, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_id", "code": "theorem map_id : \u2200 p : MvPolynomial \u03c3 R, map (RingHom.id R) p = p", "start": [1247, 1], "end": [1248, 12], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_map", "code": "theorem map_map [CommSemiring S\u2082] (g : S\u2081 \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    map g (map f p) = map (g.comp f) p", "start": [1251, 1], "end": [1258, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_eq_eval_map", "code": "theorem eval\u2082_eq_eval_map (g : \u03c3 \u2192 S\u2081) (p : MvPolynomial \u03c3 R) : p.eval\u2082 f g = eval g (map f p)", "start": [1261, 1], "end": [1273, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_comp_right", "code": "theorem eval\u2082_comp_right {S\u2082} [CommSemiring S\u2082] (k : S\u2081 \u2192+* S\u2082) (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (p) :\n    k (eval\u2082 f g p) = eval\u2082 k (k \u2218 g) (map f p)", "start": [1276, 1], "end": [1285, 8], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_eval\u2082", "code": "theorem map_eval\u2082 (f : R \u2192+* S\u2081) (g : S\u2082 \u2192 MvPolynomial S\u2083 R) (p : MvPolynomial S\u2082 R) :\n    map f (eval\u2082 C g p) = eval\u2082 C (map f \u2218 g) (map f p)", "start": [1288, 1], "end": [1297, 8], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_map", "code": "theorem coeff_map (p : MvPolynomial \u03c3 R) : \u2200 m : \u03c3 \u2192\u2080 \u2115, coeff m (map f p) = f (coeff m p)", "start": [1300, 1], "end": [1317, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_injective", "code": "theorem map_injective (hf : Function.Injective f) :\n    Function.Injective (map f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c3 S\u2081)", "start": [1320, 1], "end": [1325, 17], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_surjective", "code": "theorem map_surjective (hf : Function.Surjective f) :\n    Function.Surjective (map f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c3 S\u2081)", "start": [1328, 1], "end": [1335, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_leftInverse", "code": "theorem map_leftInverse {f : R \u2192+* S\u2081} {g : S\u2081 \u2192+* R} (hf : Function.LeftInverse f g) :\n    Function.LeftInverse (map f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c3 S\u2081) (map g)", "start": [1338, 1], "end": [1341, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_rightInverse", "code": "theorem map_rightInverse {f : R \u2192+* S\u2081} {g : S\u2081 \u2192+* R} (hf : Function.RightInverse f g) :\n    Function.RightInverse (map f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c3 S\u2081) (map g)", "start": [1344, 1], "end": [1347, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_map", "code": "@[simp]\ntheorem eval_map (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081) (p : MvPolynomial \u03c3 R) :\n    eval g (map f p) = eval\u2082 f g p", "start": [1350, 1], "end": [1353, 82], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_map", "code": "@[simp]\ntheorem eval\u2082_map [CommSemiring S\u2082] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2082) (\u03c6 : S\u2081 \u2192+* S\u2082)\n    (p : MvPolynomial \u03c3 R) : eval\u2082 \u03c6 g (map f p) = eval\u2082 (\u03c6.comp f) g p", "start": [1356, 1], "end": [1359, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_map_hom", "code": "@[simp]\ntheorem eval\u2082Hom_map_hom [CommSemiring S\u2082] (f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2082) (\u03c6 : S\u2081 \u2192+* S\u2082)\n    (p : MvPolynomial \u03c3 R) : eval\u2082Hom \u03c6 g (map f p) = eval\u2082Hom (\u03c6.comp f) g p", "start": [1362, 1], "end": [1365, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_map", "code": "@[simp]\ntheorem constantCoeff_map (f : R \u2192+* S\u2081) (\u03c6 : MvPolynomial \u03c3 R) :\n    constantCoeff (MvPolynomial.map f \u03c6) = f (constantCoeff \u03c6)", "start": [1368, 1], "end": [1371, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_comp_map", "code": "theorem constantCoeff_comp_map (f : R \u2192+* S\u2081) :\n    (constantCoeff : MvPolynomial \u03c3 S\u2081 \u2192+* S\u2081).comp (MvPolynomial.map f) = f.comp constantCoeff", "start": [1374, 1], "end": [1376, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_map_subset", "code": "theorem support_map_subset (p : MvPolynomial \u03c3 R) : (map f p).support \u2286 p.support", "start": [1379, 1], "end": [1387, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_map_of_injective", "code": "theorem support_map_of_injective (p : MvPolynomial \u03c3 R) {f : R \u2192+* S\u2081} (hf : Injective f) :\n    (map f p).support = p.support", "start": [1390, 1], "end": [1400, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.C_dvd_iff_map_hom_eq_zero", "code": "theorem C_dvd_iff_map_hom_eq_zero (q : R \u2192+* S\u2081) (r : R) (hr : \u2200 r' : R, q r' = 0 \u2194 r \u2223 r')\n    (\u03c6 : MvPolynomial \u03c3 R) : C r \u2223 \u03c6 \u2194 map q \u03c6 = 0", "start": [1403, 1], "end": [1406, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_mapRange_eq_iff", "code": "theorem map_mapRange_eq_iff (f : R \u2192+* S\u2081) (g : S\u2081 \u2192 R) (hg : g 0 = 0) (\u03c6 : MvPolynomial \u03c3 S\u2081) :\n    map f (Finsupp.mapRange g hg \u03c6) = \u03c6 \u2194 \u2200 d, f (g (coeff d \u03c6)) = coeff d \u03c6", "start": [1409, 1], "end": [1415, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgHom", "code": "@[simps!]\ndef mapAlgHom [CommSemiring S\u2082] [Algebra R S\u2081] [Algebra R S\u2082] (f : S\u2081 \u2192\u2090[R] S\u2082) :\n    MvPolynomial \u03c3 S\u2081 \u2192\u2090[R] MvPolynomial \u03c3 S\u2082 :=\n  { map (\u2191f : S\u2081 \u2192+* S\u2082) with\n    commutes' := fun r => by\n      have h\u2081 : algebraMap R (MvPolynomial \u03c3 S\u2081) r = C (algebraMap R S\u2081 r) := rfl\n      have h\u2082 : algebraMap R (MvPolynomial \u03c3 S\u2082) r = C (algebraMap R S\u2082 r) := rfl\n      simp_rw [OneHom.toFun_eq_coe]\n      change @FunLike.coe (_ \u2192+* _) _ _ _ _ _ = _\n      rw [h\u2081, h\u2082, map, eval\u2082Hom_C, RingHom.comp_apply, AlgHom.coe_toRingHom, AlgHom.commutes] }", "start": [1418, 1], "end": [1429, 96], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgHom_id", "code": "@[simp]\ntheorem mapAlgHom_id [Algebra R S\u2081] :\n    mapAlgHom (AlgHom.id R S\u2081) = AlgHom.id R (MvPolynomial \u03c3 S\u2081)", "start": [1432, 1], "end": [1435, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mapAlgHom_coe_ringHom", "code": "@[simp]\ntheorem mapAlgHom_coe_ringHom [CommSemiring S\u2082] [Algebra R S\u2081] [Algebra R S\u2082] (f : S\u2081 \u2192\u2090[R] S\u2082) :\n    \u2191(mapAlgHom f : _ \u2192\u2090[R] MvPolynomial \u03c3 S\u2082) =\n      (map \u2191f : MvPolynomial \u03c3 S\u2081 \u2192+* MvPolynomial \u03c3 S\u2082)", "start": [1438, 1], "end": [1442, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.algebraMap_apply", "code": "theorem algebraMap_apply (r : R) : algebraMap R (MvPolynomial \u03c3 S\u2081) r = C (algebraMap R S\u2081 r)", "start": [1456, 1], "end": [1456, 101], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval", "code": "def aeval : MvPolynomial \u03c3 R \u2192\u2090[R] S\u2081 :=\n  { eval\u2082Hom (algebraMap R S\u2081) f with commutes' := fun _r => eval\u2082_C _ _ _ }", "start": [1459, 1], "end": [1462, 77], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_def", "code": "theorem aeval_def (p : MvPolynomial \u03c3 R) : aeval f p = eval\u2082 (algebraMap R S\u2081) f p", "start": [1465, 1], "end": [1466, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_eq_eval\u2082Hom", "code": "theorem aeval_eq_eval\u2082Hom (p : MvPolynomial \u03c3 R) : aeval f p = eval\u2082Hom (algebraMap R S\u2081) f p", "start": [1469, 1], "end": [1470, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_X", "code": "@[simp]\ntheorem aeval_X (s : \u03c3) : aeval f (X s : MvPolynomial _ R) = f s", "start": [1473, 1], "end": [1475, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_C", "code": "@[simp]\ntheorem aeval_C (r : R) : aeval f (C r) = algebraMap R S\u2081 r", "start": [1478, 1], "end": [1480, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_unique", "code": "theorem aeval_unique (\u03c6 : MvPolynomial \u03c3 R \u2192\u2090[R] S\u2081) : \u03c6 = aeval (\u03c6 \u2218 X)", "start": [1483, 1], "end": [1485, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_X_left", "code": "theorem aeval_X_left : aeval X = AlgHom.id R (MvPolynomial \u03c3 R)", "start": [1488, 1], "end": [1489, 38], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_X_left_apply", "code": "theorem aeval_X_left_apply (p : MvPolynomial \u03c3 R) : aeval X p = p", "start": [1492, 1], "end": [1493, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.comp_aeval", "code": "theorem comp_aeval {B : Type*} [CommSemiring B] [Algebra R B] (\u03c6 : S\u2081 \u2192\u2090[R] B) :\n    \u03c6.comp (aeval f) = aeval fun i => \u03c6 (f i)", "start": [1496, 1], "end": [1499, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_aeval", "code": "@[simp]\ntheorem map_aeval {B : Type*} [CommSemiring B] (g : \u03c3 \u2192 S\u2081) (\u03c6 : S\u2081 \u2192+* B) (p : MvPolynomial \u03c3 R) :\n    \u03c6 (aeval g p) = eval\u2082Hom (\u03c6.comp (algebraMap R S\u2081)) (fun i => \u03c6 (g i)) p", "start": [1502, 1], "end": [1506, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_zero", "code": "@[simp]\ntheorem eval\u2082Hom_zero (f : R \u2192+* S\u2082) : eval\u2082Hom f (0 : \u03c3 \u2192 S\u2082) = f.comp constantCoeff", "start": [1509, 1], "end": [1511, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_zero'", "code": "@[simp]\ntheorem eval\u2082Hom_zero' (f : R \u2192+* S\u2082) : eval\u2082Hom f (fun _ => 0 : \u03c3 \u2192 S\u2082) = f.comp constantCoeff", "start": [1514, 1], "end": [1516, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_zero_apply", "code": "theorem eval\u2082Hom_zero_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    eval\u2082Hom f (0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p)", "start": [1519, 1], "end": [1521, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_zero'_apply", "code": "theorem eval\u2082Hom_zero'_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    eval\u2082Hom f (fun _ => 0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p)", "start": [1524, 1], "end": [1526, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_zero_apply", "code": "@[simp]\ntheorem eval\u2082_zero_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    eval\u2082 f (0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p)", "start": [1529, 1], "end": [1532, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_zero'_apply", "code": "@[simp]\ntheorem eval\u2082_zero'_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\n    eval\u2082 f (fun _ => 0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p)", "start": [1535, 1], "end": [1538, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_zero", "code": "@[simp]\ntheorem aeval_zero (p : MvPolynomial \u03c3 R) :\n    aeval (0 : \u03c3 \u2192 S\u2081) p = algebraMap _ _ (constantCoeff p)", "start": [1541, 1], "end": [1544, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_zero'", "code": "@[simp]\ntheorem aeval_zero' (p : MvPolynomial \u03c3 R) :\n    aeval (fun _ => 0 : \u03c3 \u2192 S\u2081) p = algebraMap _ _ (constantCoeff p)", "start": [1547, 1], "end": [1550, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_zero", "code": "@[simp]\ntheorem eval_zero : eval (0 : \u03c3 \u2192 R) = constantCoeff", "start": [1553, 1], "end": [1555, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_zero'", "code": "@[simp]\ntheorem eval_zero' : eval (fun _ => 0 : \u03c3 \u2192 R) = constantCoeff", "start": [1558, 1], "end": [1560, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_monomial", "code": "theorem aeval_monomial (g : \u03c3 \u2192 S\u2081) (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\n    aeval g (monomial d r) = algebraMap _ _ r * d.prod fun i k => g i ^ k", "start": [1563, 1], "end": [1565, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_eq_zero", "code": "theorem eval\u2082Hom_eq_zero (f : R \u2192+* S\u2082) (g : \u03c3 \u2192 S\u2082) (\u03c6 : MvPolynomial \u03c3 R)\n    (h : \u2200 d, \u03c6.coeff d \u2260 0 \u2192 \u2203 i \u2208 d.support, g i = 0) : eval\u2082Hom f g \u03c6 = 0", "start": [1568, 1], "end": [1575, 51], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_eq_zero", "code": "theorem aeval_eq_zero [Algebra R S\u2082] (f : \u03c3 \u2192 S\u2082) (\u03c6 : MvPolynomial \u03c3 R)\n    (h : \u2200 d, \u03c6.coeff d \u2260 0 \u2192 \u2203 i \u2208 d.support, f i = 0) : aeval f \u03c6 = 0", "start": [1578, 1], "end": [1580, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_sum", "code": "theorem aeval_sum {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    aeval f (\u2211 i in s, \u03c6 i) = \u2211 i in s, aeval f (\u03c6 i)", "start": [1583, 1], "end": [1585, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_prod", "code": "@[to_additive existing]\ntheorem aeval_prod {\u03b9 : Type*} (s : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    aeval f (\u220f i in s, \u03c6 i) = \u220f i in s, aeval f (\u03c6 i)", "start": [1588, 1], "end": [1591, 38], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_range_eq_range_aeval", "code": "theorem _root_.Algebra.adjoin_range_eq_range_aeval :\n    Algebra.adjoin R (Set.range f) = (MvPolynomial.aeval f).range", "start": [1596, 1], "end": [1599, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin_eq_range", "code": "theorem _root_.Algebra.adjoin_eq_range (s : Set S\u2081) :\n    Algebra.adjoin R s = (MvPolynomial.aeval ((\u2191) : s \u2192 S\u2081)).range", "start": [1602, 1], "end": [1604, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower", "code": "def aevalTower (f : R \u2192\u2090[S] A) (X : \u03c3 \u2192 A) : MvPolynomial \u03c3 R \u2192\u2090[S] A :=\n  { eval\u2082Hom (\u2191f) X with\n    commutes' := fun r => by\n      simp [IsScalarTower.algebraMap_eq S R (MvPolynomial \u03c3 R), algebraMap_eq] }", "start": [1615, 1], "end": [1620, 81], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_X", "code": "@[simp]\ntheorem aevalTower_X (i : \u03c3) : aevalTower g y (X i) = y i", "start": [1625, 1], "end": [1627, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_C", "code": "@[simp]\ntheorem aevalTower_C (x : R) : aevalTower g y (C x) = g x", "start": [1630, 1], "end": [1632, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_comp_C", "code": "@[simp]\ntheorem aevalTower_comp_C : (aevalTower g y : MvPolynomial \u03c3 R \u2192+* A).comp C = g", "start": [1635, 1], "end": [1637, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_algebraMap", "code": "@[simp]\ntheorem aevalTower_algebraMap (x : R) : aevalTower g y (algebraMap R (MvPolynomial \u03c3 R) x) = g x", "start": [1640, 1], "end": [1642, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_comp_algebraMap", "code": "@[simp]\ntheorem aevalTower_comp_algebraMap :\n    (aevalTower g y : MvPolynomial \u03c3 R \u2192+* A).comp (algebraMap R (MvPolynomial \u03c3 R)) = g", "start": [1645, 1], "end": [1648, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_toAlgHom", "code": "theorem aevalTower_toAlgHom (x : R) :\n    aevalTower g y (IsScalarTower.toAlgHom S R (MvPolynomial \u03c3 R) x) = g x", "start": [1651, 1], "end": [1653, 30], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_comp_toAlgHom", "code": "@[simp]\ntheorem aevalTower_comp_toAlgHom :\n    (aevalTower g y).comp (IsScalarTower.toAlgHom S R (MvPolynomial \u03c3 R)) = g", "start": [1656, 1], "end": [1659, 65], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_id", "code": "@[simp]\ntheorem aevalTower_id :\n    aevalTower (AlgHom.id S S) = (aeval : (\u03c3 \u2192 S) \u2192 MvPolynomial \u03c3 S \u2192\u2090[S] S)", "start": [1662, 1], "end": [1666, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aevalTower_ofId", "code": "@[simp]\ntheorem aevalTower_ofId :\n    aevalTower (Algebra.ofId S A) = (aeval : (\u03c3 \u2192 A) \u2192 MvPolynomial \u03c3 S \u2192\u2090[S] A)", "start": [1669, 1], "end": [1673, 36], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_mem", "code": "theorem eval\u2082_mem {f : R \u2192+* S} {p : MvPolynomial \u03c3 R} {s : subS}\n    (hs : \u2200 i \u2208 p.support, f (p.coeff i) \u2208 s) {v : \u03c3 \u2192 S} (hv : \u2200 i, v i \u2208 s) :\n    MvPolynomial.eval\u2082 f v p \u2208 s", "start": [1682, 1], "end": [1705, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_mem", "code": "theorem eval_mem {p : MvPolynomial \u03c3 S} {s : subS} (hs : \u2200 i \u2208 p.support, p.coeff i \u2208 s) {v : \u03c3 \u2192 S}\n    (hv : \u2200 i, v i \u2208 s) : MvPolynomial.eval v p \u2208 s", "start": [1708, 1], "end": [1710, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Degree/Lemmas.lean", "imports": ["Mathlib/Data/Polynomial/Eval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.natDegree_comp_le", "code": "theorem natDegree_comp_le : natDegree (p.comp q) \u2264 natDegree p * natDegree q", "start": [37, 1], "end": [61, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_of_root", "code": "theorem degree_pos_of_root {p : R[X]} (hp : p \u2260 0) (h : IsRoot p a) : 0 < degree p", "start": [64, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_le_iff_coeff_eq_zero", "code": "theorem natDegree_le_iff_coeff_eq_zero : p.natDegree \u2264 n \u2194 \u2200 N : \u2115, n < N \u2192 p.coeff N = 0", "start": [72, 1], "end": [73, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_le_iff_left", "code": "theorem natDegree_add_le_iff_left {n : \u2115} (p q : R[X]) (qn : q.natDegree \u2264 n) :\n    (p + q).natDegree \u2264 n \u2194 p.natDegree \u2264 n", "start": [76, 1], "end": [81, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_le_iff_right", "code": "theorem natDegree_add_le_iff_right {n : \u2115} (p q : R[X]) (pn : p.natDegree \u2264 n) :\n    (p + q).natDegree \u2264 n \u2194 q.natDegree \u2264 n", "start": [84, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_le", "code": "theorem natDegree_C_mul_le (a : R) (f : R[X]) : (C a * f).natDegree \u2264 f.natDegree", "start": [90, 1], "end": [94, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_C_le", "code": "theorem natDegree_mul_C_le (f : R[X]) (a : R) : (f * C a).natDegree \u2264 f.natDegree", "start": [98, 1], "end": [102, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_natDegree_of_le_mem_support", "code": "theorem eq_natDegree_of_le_mem_support (pn : p.natDegree \u2264 n) (ns : n \u2208 p.support) :\n    p.natDegree = n", "start": [106, 1], "end": [108, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_eq_of_mul_eq_one", "code": "theorem natDegree_C_mul_eq_of_mul_eq_one {ai : R} (au : ai * a = 1) :\n    (C a * p).natDegree = p.natDegree", "start": [111, 1], "end": [117, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_C_eq_of_mul_eq_one", "code": "theorem natDegree_mul_C_eq_of_mul_eq_one {ai : R} (au : a * ai = 1) :\n    (p * C a).natDegree = p.natDegree", "start": [121, 1], "end": [127, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_C_eq_of_mul_ne_zero", "code": "theorem natDegree_mul_C_eq_of_mul_ne_zero (h : p.leadingCoeff * a \u2260 0) :\n    (p * C a).natDegree = p.natDegree", "start": [131, 1], "end": [138, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul_eq_of_mul_ne_zero", "code": "theorem natDegree_C_mul_eq_of_mul_ne_zero (h : a * p.leadingCoeff \u2260 0) :\n    (C a * p).natDegree = p.natDegree", "start": [142, 1], "end": [149, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_add_coeff_mul", "code": "theorem natDegree_add_coeff_mul (f g : R[X]) :\n    (f * g).coeff (f.natDegree + g.natDegree) = f.coeff f.natDegree * g.coeff g.natDegree", "start": [153, 1], "end": [155, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_lt_coeff_mul", "code": "theorem natDegree_lt_coeff_mul (h : p.natDegree + q.natDegree < m + n) :\n    (p * q).coeff (m + n) = 0", "start": [158, 1], "end": [160, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_of_natDegree_le", "code": "theorem coeff_mul_of_natDegree_le (pm : p.natDegree \u2264 m) (qn : q.natDegree \u2264 n) :\n    (p * q).coeff (m + n) = p.coeff m * q.coeff n", "start": [163, 1], "end": [172, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_pow_of_natDegree_le", "code": "theorem coeff_pow_of_natDegree_le (pn : p.natDegree \u2264 n) :\n    (p ^ m).coeff (m * n) = p.coeff n ^ m", "start": [175, 1], "end": [181, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_pow_eq_ite_of_natDegree_le_of_le", "code": "theorem coeff_pow_eq_ite_of_natDegree_le_of_le {o : \u2115}\n    (pn : natDegree p \u2264 n) (mno : m * n \u2264 o) :\n    coeff (p ^ m) o = if o = m * n then (coeff p n) ^ m else 0", "start": [184, 1], "end": [190, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_add_eq_left_of_lt", "code": "theorem coeff_add_eq_left_of_lt (qn : q.natDegree < n) : (p + q).coeff n = p.coeff n", "start": [192, 1], "end": [194, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_add_eq_right_of_lt", "code": "theorem coeff_add_eq_right_of_lt (pn : p.natDegree < n) : (p + q).coeff n = q.coeff n", "start": [197, 1], "end": [199, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_sum_eq_of_disjoint", "code": "theorem degree_sum_eq_of_disjoint (f : S \u2192 R[X]) (s : Finset S)\n    (h : Set.Pairwise { i | i \u2208 s \u2227 f i \u2260 0 } (Ne on degree \u2218 f)) :\n    degree (s.sum f) = s.sup fun i => degree (f i)", "start": [202, 1], "end": [225, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sum_eq_of_disjoint", "code": "theorem natDegree_sum_eq_of_disjoint (f : S \u2192 R[X]) (s : Finset S)\n    (h : Set.Pairwise { i | i \u2208 s \u2227 f i \u2260 0 } (Ne on natDegree \u2218 f)) :\n    natDegree (s.sum f) = s.sup fun i => natDegree (f i)", "start": [228, 1], "end": [258, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_bit0", "code": "theorem natDegree_bit0 (a : R[X]) : (bit0 a).natDegree \u2264 a.natDegree", "start": [262, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_bit1", "code": "theorem natDegree_bit1 (a : R[X]) : (bit1 a).natDegree \u2264 a.natDegree", "start": [267, 1], "end": [268, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pos_of_eval\u2082_root", "code": "theorem natDegree_pos_of_eval\u2082_root {p : R[X]} (hp : p \u2260 0) (f : R \u2192+* S) {z : S}\n    (hz : eval\u2082 f z p = 0) (inj : \u2200 x : R, f x = 0 \u2192 x = 0) : 0 < natDegree p", "start": [273, 1], "end": [279, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_of_eval\u2082_root", "code": "theorem degree_pos_of_eval\u2082_root {p : R[X]} (hp : p \u2260 0) (f : R \u2192+* S) {z : S}\n    (hz : eval\u2082 f z p = 0) (inj : \u2200 x : R, f x = 0 \u2192 x = 0) : 0 < degree p", "start": [282, 1], "end": [284, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_lt_degree", "code": "@[simp]\ntheorem coe_lt_degree {p : R[X]} {n : \u2115} : (n : WithBot \u2115) < degree p \u2194 n < natDegree p", "start": [287, 1], "end": [291, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_map_eq_iff", "code": "@[simp]\ntheorem degree_map_eq_iff {f : R \u2192+* S} {p : Polynomial R} :\n    degree (map f p) = degree p \u2194 f (leadingCoeff p) \u2260 0 \u2228 p = 0", "start": [294, 1], "end": [305, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_map_eq_iff", "code": "@[simp]\ntheorem natDegree_map_eq_iff {f : R \u2192+* S} {p : Polynomial R} :\n    natDegree (map f p) = natDegree p \u2194 f (p.leadingCoeff) \u2260 0 \u2228 natDegree p = 0", "start": [307, 1], "end": [316, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub", "code": "theorem natDegree_sub : (p - q).natDegree = (q - p).natDegree", "start": [326, 1], "end": [326, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_le_iff_left", "code": "theorem natDegree_sub_le_iff_left (qn : q.natDegree \u2264 n) :\n    (p - q).natDegree \u2264 n \u2194 p.natDegree \u2264 n", "start": [329, 1], "end": [332, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_le_iff_right", "code": "theorem natDegree_sub_le_iff_right (pn : p.natDegree \u2264 n) :\n    (p - q).natDegree \u2264 n \u2194 q.natDegree \u2264 n", "start": [335, 1], "end": [336, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_sub_eq_left_of_lt", "code": "theorem coeff_sub_eq_left_of_lt (dg : q.natDegree < n) : (p - q).coeff n = p.coeff n", "start": [339, 1], "end": [341, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_sub_eq_neg_right_of_lt", "code": "theorem coeff_sub_eq_neg_right_of_lt (df : p.natDegree < n) : (p - q).coeff n = -q.coeff n", "start": [344, 1], "end": [345, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_C", "code": "theorem degree_mul_C (a0 : a \u2260 0) : (p * C a).degree = p.degree", "start": [354, 1], "end": [355, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_C_mul", "code": "theorem degree_C_mul (a0 : a \u2260 0) : (C a * p).degree = p.degree", "start": [359, 1], "end": [360, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_C", "code": "theorem natDegree_mul_C (a0 : a \u2260 0) : (p * C a).natDegree = p.natDegree", "start": [364, 1], "end": [365, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_C_mul", "code": "theorem natDegree_C_mul (a0 : a \u2260 0) : (C a * p).natDegree = p.natDegree", "start": [369, 1], "end": [370, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_comp", "code": "theorem natDegree_comp : natDegree (p.comp q) = natDegree p * natDegree q", "start": [374, 1], "end": [382, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_iterate_comp", "code": "@[simp]\ntheorem natDegree_iterate_comp (k : \u2115) :\n    (p.comp^[k] q).natDegree = p.natDegree ^ k * q.natDegree", "start": [385, 1], "end": [390, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_comp", "code": "theorem leadingCoeff_comp (hq : natDegree q \u2260 0) :\n    leadingCoeff (p.comp q) = leadingCoeff p * leadingCoeff q ^ natDegree p", "start": [393, 1], "end": [395, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/FractionRing.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/RingTheory/Localization/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsFractionRing", "code": "abbrev IsFractionRing [CommRing K] [Algebra R K] :=\n  IsLocalization (nonZeroDivisors R) K", "start": [42, 1], "end": [44, 39], "kind": "commanddeclaration"}, {"full_name": "Rat.isFractionRing", "code": "instance Rat.isFractionRing : IsFractionRing \u2124 \u211a where\n  map_units' := by\n    rintro \u27e8x, hx\u27e9\n    rw [mem_nonZeroDivisors_iff_ne_zero] at hx\n    simpa only [eq_intCast, isUnit_iff_ne_zero, Int.cast_eq_zero, Ne.def, Subtype.coe_mk] using hx\n  surj' := by\n    rintro \u27e8n, d, hd, h\u27e9\n    refine' \u27e8\u27e8n, \u27e8d, _\u27e9\u27e9, Rat.mul_den_eq_num\u27e9\n    rw [mem_nonZeroDivisors_iff_ne_zero, Int.coe_nat_ne_zero_iff_pos]\n    exact Nat.zero_lt_of_ne_zero hd\n  eq_iff_exists' := by\n    intro x y\n    rw [eq_intCast, eq_intCast, Int.cast_inj]\n    apply Iff.intro\n    \u00b7 rintro rfl\n      use 1\n    \u00b7 rintro \u27e8\u27e8c, hc\u27e9, h\u27e9\n      apply mul_left_cancel\u2080 _ h\n      rwa [mem_nonZeroDivisors_iff_ne_zero] at hc", "start": [47, 1], "end": [66, 50], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.to_map_eq_zero_iff", "code": "theorem to_map_eq_zero_iff {x : R} : algebraMap R K x = 0 \u2194 x = 0", "start": [79, 1], "end": [80, 45], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.injective", "code": "protected theorem injective : Function.Injective (algebraMap R K)", "start": [85, 1], "end": [86, 44], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.coe_inj", "code": "@[norm_cast, simp]\ntheorem coe_inj {a b : R} : (Algebra.cast a : K) = Algebra.cast b \u2194 a = b", "start": [91, 1], "end": [94, 40], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.to_map_ne_zero_of_mem_nonZeroDivisors", "code": "protected theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] {x : R}\n    (hx : x \u2208 nonZeroDivisors R) : algebraMap R K x \u2260 0", "start": [100, 1], "end": [102, 67], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.isDomain", "code": "protected theorem isDomain : IsDomain K", "start": [107, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.inv", "code": "protected noncomputable irreducible_def inv (z : K) : K := open Classical in\n  if h : z = 0 then 0\n  else\n    mk' K \u2191(sec (nonZeroDivisors A) z).2\n      \u27e8(sec _ z).1,\n        mem_nonZeroDivisors_iff_ne_zero.2 fun h0 =>\n          h <| eq_zero_of_fst_eq_zero (sec_spec (nonZeroDivisors A) z) h0\u27e9", "start": [113, 1], "end": [120, 75], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "IsFractionRing.mul_inv_cancel", "code": "protected theorem mul_inv_cancel (x : K) (hx : x \u2260 0) : x * IsFractionRing.inv A x = 1", "start": [123, 1], "end": [132, 27], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.toField", "code": "@[reducible]\nnoncomputable def toField : Field K :=\n  { IsFractionRing.isDomain A, inferInstanceAs (CommRing K) with\n    inv := IsFractionRing.inv A\n    mul_inv_cancel := IsFractionRing.mul_inv_cancel A\n    inv_zero := by\n      change IsFractionRing.inv A (0 : K) = 0\n      rw [IsFractionRing.inv]\n      exact dif_pos rfl }", "start": [135, 1], "end": [145, 26], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.mk'_mk_eq_div", "code": "theorem mk'_mk_eq_div {r s} (hs : s \u2208 nonZeroDivisors A) :\n    mk' K r \u27e8s, hs\u27e9 = algebraMap A K r / algebraMap A K s", "start": [153, 1], "end": [157, 72], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.mk'_eq_div", "code": "@[simp]\ntheorem mk'_eq_div {r} (s : nonZeroDivisors A) : mk' K r s = algebraMap A K r / algebraMap A K s", "start": [160, 1], "end": [162, 20], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.div_surjective", "code": "theorem div_surjective (z : K) :\n    \u2203 (x y : A) (hy : y \u2208 nonZeroDivisors A), algebraMap _ _ x / algebraMap _ _ y = z", "start": [165, 1], "end": [168, 39], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.isUnit_map_of_injective", "code": "theorem isUnit_map_of_injective (hg : Function.Injective g) (y : nonZeroDivisors A) :\n    IsUnit (g y)", "start": [171, 1], "end": [174, 86], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.mk'_eq_zero_iff_eq_zero", "code": "@[simp]\ntheorem mk'_eq_zero_iff_eq_zero [Algebra R K] [IsFractionRing R K] {x : R} {y : nonZeroDivisors R} :\n    mk' K x y = 0 \u2194 x = 0", "start": [177, 1], "end": [182, 34], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.mk'_eq_one_iff_eq", "code": "theorem mk'_eq_one_iff_eq {x : A} {y : nonZeroDivisors A} : mk' K x y = 1 \u2194 x = y", "start": [185, 1], "end": [191, 43], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.lift", "code": "noncomputable def lift (hg : Injective g) : K \u2192+* L :=\n  IsLocalization.lift fun y : nonZeroDivisors A => isUnit_map_of_injective hg y", "start": [196, 1], "end": [201, 80], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.lift_algebraMap", "code": "@[simp]\ntheorem lift_algebraMap (hg : Injective g) (x) : lift hg (algebraMap A K x) = g x", "start": [204, 1], "end": [210, 14], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.lift_mk'", "code": "theorem lift_mk' (hg : Injective g) (x) (y : nonZeroDivisors A) : lift hg (mk' K x y) = g x / g y", "start": [213, 1], "end": [218, 55], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.map", "code": "noncomputable def map {A B K L : Type*} [CommRing A] [CommRing B] [IsDomain B] [CommRing K]\n    [Algebra A K] [IsFractionRing A K] [CommRing L] [Algebra B L] [IsFractionRing B L] {j : A \u2192+* B}\n    (hj : Injective j) : K \u2192+* L :=\n  IsLocalization.map L j\n    (show nonZeroDivisors A \u2264 (nonZeroDivisors B).comap j from\n      nonZeroDivisors_le_comap_nonZeroDivisors_of_injective j hj)", "start": [221, 1], "end": [230, 66], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.fieldEquivOfRingEquiv", "code": "noncomputable def fieldEquivOfRingEquiv [Algebra B L] [IsFractionRing B L] (h : A \u2243+* B) :\n    K \u2243+* L :=\n  ringEquivOfRingEquiv K L h\n    (by\n      ext b\n      show b \u2208 h.toEquiv '' _ \u2194 _\n      erw [h.toEquiv.image_eq_preimage, Set.preimage, Set.mem_setOf_eq,\n        mem_nonZeroDivisors_iff_ne_zero, mem_nonZeroDivisors_iff_ne_zero]\n      exact h.symm.map_ne_zero_iff)", "start": [233, 1], "end": [244, 36], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.isFractionRing_iff_of_base_ringEquiv", "code": "theorem isFractionRing_iff_of_base_ringEquiv (h : R \u2243+* P) :\n    IsFractionRing R S \u2194\n      @IsFractionRing P _ S _ ((algebraMap R S).comp h.symm.toRingHom).toAlgebra", "start": [247, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "IsFractionRing.nontrivial", "code": "protected theorem nontrivial (R S : Type*) [CommRing R] [Nontrivial R] [CommRing S] [Algebra R S]\n    [IsFractionRing R S] : Nontrivial S", "start": [266, 1], "end": [273, 80], "kind": "commanddeclaration"}, {"full_name": "FractionRing", "code": "@[reducible]\ndef FractionRing :=\n  Localization (nonZeroDivisors R)", "start": [280, 1], "end": [289, 35], "kind": "commanddeclaration"}, {"full_name": "FractionRing.unique", "code": "instance unique [Subsingleton R] : Unique (FractionRing R) :=\n  Localization.instUniqueLocalization", "start": [294, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "FractionRing.field", "code": "noncomputable instance field : Field (FractionRing A) := IsFractionRing.toField A", "start": [302, 1], "end": [304, 82], "kind": "commanddeclaration"}, {"full_name": "FractionRing.mk_eq_div", "code": "@[simp]\ntheorem mk_eq_div {r s} :\n    (Localization.mk r s : FractionRing A) =\n      (algebraMap _ _ r / algebraMap A _ s : FractionRing A)", "start": [306, 1], "end": [310, 60], "kind": "commanddeclaration"}, {"full_name": "FractionRing.liftAlgebra", "code": "@[reducible]\nnoncomputable def liftAlgebra [IsDomain R] [Field K] [Algebra R K]\n    [NoZeroSMulDivisors R K] : Algebra (FractionRing R) K :=\n  RingHom.toAlgebra (IsFractionRing.lift (NoZeroSMulDivisors.algebraMap_injective R _))", "start": [313, 1], "end": [319, 88], "kind": "commanddeclaration"}, {"full_name": "FractionRing.isScalarTower_liftAlgebra", "code": "theorem isScalarTower_liftAlgebra [IsDomain R] [Field K] [Algebra R K] [NoZeroSMulDivisors R K] :\n    by letI := liftAlgebra R K; exact IsScalarTower R (FractionRing R) K", "start": [322, 1], "end": [327, 90], "kind": "commanddeclaration"}, {"full_name": "FractionRing.algEquiv", "code": "noncomputable def algEquiv (K : Type*) [Field K] [Algebra A K] [IsFractionRing A K] :\n    FractionRing A \u2243\u2090[A] K :=\n  Localization.algEquiv (nonZeroDivisors A) K", "start": [329, 1], "end": [334, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharZero/Infinite.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Algebra/CharZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CharZero.infinite", "code": "instance (priority := 100) CharZero.infinite : Infinite M :=\n  Infinite.of_injective Nat.cast Nat.cast_injective", "start": [19, 1], "end": [20, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Polynomial/BigOperators.lean", "imports": ["Mathlib/Data/Polynomial/Monic.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.natDegree_list_sum_le", "code": "theorem natDegree_list_sum_le (l : List S[X]) : natDegree l.sum \u2264 (l.map natDegree).foldr max 0", "start": [48, 1], "end": [49, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_sum_le", "code": "theorem natDegree_multiset_sum_le (l : Multiset S[X]) :\n    natDegree l.sum \u2264 (l.map natDegree).foldr max max_left_comm 0", "start": [52, 1], "end": [54, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sum_le", "code": "theorem natDegree_sum_le (f : \u03b9 \u2192 S[X]) :\n    natDegree (\u2211 i in s, f i) \u2264 s.fold max 0 (natDegree \u2218 f)", "start": [57, 1], "end": [59, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_list_sum_le", "code": "theorem degree_list_sum_le (l : List S[X]) : degree l.sum \u2264 (l.map natDegree).maximum", "start": [62, 1], "end": [73, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_list_prod_le", "code": "theorem natDegree_list_prod_le (l : List S[X]) : natDegree l.prod \u2264 (l.map natDegree).sum", "start": [76, 1], "end": [79, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_list_prod_le", "code": "theorem degree_list_prod_le (l : List S[X]) : degree l.prod \u2264 (l.map degree).sum", "start": [82, 1], "end": [85, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_list_prod_of_natDegree_le", "code": "theorem coeff_list_prod_of_natDegree_le (l : List S[X]) (n : \u2115) (hl : \u2200 p \u2208 l, natDegree p \u2264 n) :\n    coeff (List.prod l) (l.length * n) = (l.map fun p => coeff p n).prod", "start": [88, 1], "end": [107, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_prod_le", "code": "theorem natDegree_multiset_prod_le : t.prod.natDegree \u2264 (t.map natDegree).sum", "start": [116, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_prod_le", "code": "theorem natDegree_prod_le : (\u220f i in s, f i).natDegree \u2264 \u2211 i in s, (f i).natDegree", "start": [120, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_multiset_prod_le", "code": "theorem degree_multiset_prod_le : t.prod.degree \u2264 (t.map Polynomial.degree).sum", "start": [124, 1], "end": [128, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_prod_le", "code": "theorem degree_prod_le : (\u220f i in s, f i).degree \u2264 \u2211 i in s, (f i).degree", "start": [131, 1], "end": [132, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_multiset_prod'", "code": "theorem leadingCoeff_multiset_prod' (h : (t.map leadingCoeff).prod \u2260 0) :\n    t.prod.leadingCoeff = (t.map leadingCoeff).prod", "start": [135, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_prod'", "code": "theorem leadingCoeff_prod' (h : (\u220f i in s, (f i).leadingCoeff) \u2260 0) :\n    (\u220f i in s, f i).leadingCoeff = \u220f i in s, (f i).leadingCoeff", "start": [155, 1], "end": [163, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_prod'", "code": "theorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod \u2260 0) :\n    t.prod.natDegree = (t.map fun f => natDegree f).sum", "start": [166, 1], "end": [180, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_prod'", "code": "theorem natDegree_prod' (h : (\u220f i in s, (f i).leadingCoeff) \u2260 0) :\n    (\u220f i in s, f i).natDegree = \u2211 i in s, (f i).natDegree", "start": [183, 1], "end": [191, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_prod_of_monic", "code": "theorem natDegree_multiset_prod_of_monic (h : \u2200 f \u2208 t, Monic f) :\n    t.prod.natDegree = (t.map natDegree).sum", "start": [194, 1], "end": [207, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_prod_of_monic", "code": "theorem natDegree_prod_of_monic (h : \u2200 i \u2208 s, (f i).Monic) :\n    (\u220f i in s, f i).natDegree = \u2211 i in s, (f i).natDegree", "start": [210, 1], "end": [212, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_multiset_prod_of_natDegree_le", "code": "theorem coeff_multiset_prod_of_natDegree_le (n : \u2115) (hl : \u2200 p \u2208 t, natDegree p \u2264 n) :\n    coeff t.prod ((Multiset.card t) * n) = (t.map fun p => coeff p n).prod", "start": [215, 1], "end": [218, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_prod_of_natDegree_le", "code": "theorem coeff_prod_of_natDegree_le (f : \u03b9 \u2192 R[X]) (n : \u2115) (h : \u2200 p \u2208 s, natDegree (f p) \u2264 n) :\n    coeff (\u220f i in s, f i) (s.card * n) = \u220f i in s, coeff (f i) n", "start": [221, 1], "end": [227, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_multiset_prod", "code": "theorem coeff_zero_multiset_prod : t.prod.coeff 0 = (t.map fun f => coeff f 0).prod", "start": [230, 1], "end": [232, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero_prod", "code": "theorem coeff_zero_prod : (\u220f i in s, f i).coeff 0 = \u220f i in s, (f i).coeff 0", "start": [235, 1], "end": [236, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.multiset_prod_X_sub_C_nextCoeff", "code": "theorem multiset_prod_X_sub_C_nextCoeff (t : Multiset R) :\n    nextCoeff (t.map fun x => X - C x).prod = -t.sum", "start": [249, 1], "end": [255, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_X_sub_C_nextCoeff", "code": "theorem prod_X_sub_C_nextCoeff {s : Finset \u03b9} (f : \u03b9 \u2192 R) :\n    nextCoeff (\u220f i in s, (X - C (f i))) = -\u2211 i in s, f i", "start": [259, 1], "end": [261, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.multiset_prod_X_sub_C_coeff_card_pred", "code": "theorem multiset_prod_X_sub_C_coeff_card_pred (t : Multiset R) (ht : 0 < Multiset.card t) :\n    (t.map fun x => X - C x).prod.coeff ((Multiset.card t) - 1) = -t.sum", "start": [265, 1], "end": [278, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_X_sub_C_coeff_card_pred", "code": "theorem prod_X_sub_C_coeff_card_pred (s : Finset \u03b9) (f : \u03b9 \u2192 R) (hs : 0 < s.card) :\n    (\u220f i in s, (X - C (f i))).coeff (s.card - 1) = -\u2211 i in s, f i", "start": [282, 1], "end": [284, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_list_prod", "code": "theorem degree_list_prod [Nontrivial R] (l : List R[X]) : l.prod.degree = (l.map degree).sum", "start": [296, 1], "end": [301, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_prod", "code": "theorem natDegree_prod (h : \u2200 i \u2208 s, f i \u2260 0) :\n    (\u220f i in s, f i).natDegree = \u2211 i in s, (f i).natDegree", "start": [310, 1], "end": [321, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_prod", "code": "theorem natDegree_multiset_prod (h : (0 : R[X]) \u2209 t) :\n    natDegree t.prod = (t.map natDegree).sum", "start": [324, 1], "end": [330, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_multiset_prod", "code": "theorem degree_multiset_prod [Nontrivial R] : t.prod.degree = (t.map fun f => degree f).sum", "start": [333, 1], "end": [337, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_prod", "code": "theorem degree_prod [Nontrivial R] : (\u220f i in s, f i).degree = \u2211 i in s, (f i).degree", "start": [340, 1], "end": [344, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_multiset_prod", "code": "theorem leadingCoeff_multiset_prod :\n    t.prod.leadingCoeff = (t.map fun f => leadingCoeff f).prod", "start": [347, 1], "end": [356, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_prod", "code": "theorem leadingCoeff_prod : (\u220f i in s, f i).leadingCoeff = \u220f i in s, (f i).leadingCoeff", "start": [359, 1], "end": [366, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Div.lean", "imports": ["Mathlib/Data/Polynomial/AlgebraMap.lean", "Mathlib/RingTheory/Multiplicity.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Inductions.lean", "Mathlib/Data/Polynomial/Monic.lean"], "premises": [{"full_name": "Polynomial.X_dvd_iff", "code": "theorem X_dvd_iff {f : R[X]} : X \u2223 f \u2194 f.coeff 0 = 0", "start": [38, 1], "end": [40, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_dvd_iff", "code": "theorem X_pow_dvd_iff {f : R[X]} {n : \u2115} : X ^ n \u2223 f \u2194 \u2200 d < n, f.coeff d = 0", "start": [44, 1], "end": [55, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.multiplicity_finite_of_degree_pos_of_monic", "code": "theorem multiplicity_finite_of_degree_pos_of_monic (hp : (0 : WithBot \u2115) < degree p) (hmp : Monic p)\n    (hq : q \u2260 0) : multiplicity.Finite p q", "start": [65, 1], "end": [86, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_wf_lemma", "code": "theorem div_wf_lemma (h : degree q \u2264 degree p \u2227 p \u2260 0) (hq : Monic q) :\n    degree (p - C (leadingCoeff p) * X ^ (natDegree p - natDegree q) * q) < degree p", "start": [95, 1], "end": [106, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divModByMonicAux", "code": "noncomputable def divModByMonicAux : \u2200 (_p : R[X]) {q : R[X]}, Monic q \u2192 R[X] \u00d7 R[X]\n  | p, q, hq =>\n    letI := Classical.decEq R\n    if h : degree q \u2264 degree p \u2227 p \u2260 0 then\n      let z := C (leadingCoeff p) * X ^ (natDegree p - natDegree q)\n      have _wf := div_wf_lemma h hq\n      let dm := divModByMonicAux (p - z * q) hq\n      \u27e8z + dm.1, dm.2\u27e9\n    else \u27e80, p\u27e9\n  termination_by divModByMonicAux p q hq => p", "start": [109, 1], "end": [119, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic", "code": "def divByMonic (p q : R[X]) : R[X] :=\n  letI := Classical.decEq R\n  if hq : Monic q then (divModByMonicAux p hq).1 else 0", "start": [122, 1], "end": [125, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic", "code": "def modByMonic (p q : R[X]) : R[X] :=\n  letI := Classical.decEq R\n  if hq : Monic q then (divModByMonicAux p hq).2 else p", "start": [128, 1], "end": [131, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_modByMonic_lt", "code": "theorem degree_modByMonic_lt [Nontrivial R] :\n    \u2200 (p : R[X]) {q : R[X]} (_hq : Monic q), degree (p %\u2098 q) < degree q", "start": [140, 1], "end": [168, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_modByMonic_lt", "code": "theorem natDegree_modByMonic_lt (p : R[X]) {q : R[X]} (hmq : Monic q) (hq : q \u2260 1) :\n    natDegree (p %\u2098 q) < q.natDegree", "start": [171, 1], "end": [178, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_modByMonic", "code": "@[simp]\ntheorem zero_modByMonic (p : R[X]) : 0 %\u2098 p = 0", "start": [180, 1], "end": [187, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_divByMonic", "code": "@[simp]\ntheorem zero_divByMonic (p : R[X]) : 0 /\u2098 p = 0", "start": [190, 1], "end": [197, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_zero", "code": "@[simp]\ntheorem modByMonic_zero (p : R[X]) : p %\u2098 0 = p", "start": [200, 1], "end": [206, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_zero", "code": "@[simp]\ntheorem divByMonic_zero (p : R[X]) : p /\u2098 0 = 0", "start": [209, 1], "end": [215, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_eq_of_not_monic", "code": "theorem divByMonic_eq_of_not_monic (p : R[X]) (hq : \u00acMonic q) : p /\u2098 q = 0", "start": [218, 1], "end": [219, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_eq_of_not_monic", "code": "theorem modByMonic_eq_of_not_monic (p : R[X]) (hq : \u00acMonic q) : p %\u2098 q = p", "start": [222, 1], "end": [223, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_eq_self_iff", "code": "theorem modByMonic_eq_self_iff [Nontrivial R] (hq : Monic q) : p %\u2098 q = p \u2194 degree p < degree q", "start": [226, 1], "end": [230, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_modByMonic_le", "code": "theorem degree_modByMonic_le (p : R[X]) {q : R[X]} (hq : Monic q) : degree (p %\u2098 q) \u2264 degree q", "start": [233, 1], "end": [235, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_modByMonic_le", "code": "theorem natDegree_modByMonic_le (p : Polynomial R) {g : Polynomial R} (hg : g.Monic) :\n    natDegree (p %\u2098 g) \u2264 g.natDegree", "start": [238, 1], "end": [240, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_dvd_sub_C", "code": "theorem X_dvd_sub_C : X \u2223 p - C (p.coeff 0)", "start": [248, 1], "end": [249, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_eq_sub_mul_div", "code": "theorem modByMonic_eq_sub_mul_div :\n    \u2200 (p : R[X]) {q : R[X]} (_hq : Monic q), p %\u2098 q = p - q * (p /\u2098 q)", "start": [251, 1], "end": [270, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_add_div", "code": "theorem modByMonic_add_div (p : R[X]) {q : R[X]} (hq : Monic q) : p %\u2098 q + q * (p /\u2098 q) = p", "start": [273, 1], "end": [274, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_eq_zero_iff", "code": "theorem divByMonic_eq_zero_iff [Nontrivial R] (hq : Monic q) : p /\u2098 q = 0 \u2194 degree p < degree q", "start": [277, 1], "end": [284, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_divByMonic", "code": "theorem degree_add_divByMonic (hq : Monic q) (h : degree q \u2264 degree p) :\n    degree q + degree (p /\u2098 q) = degree p", "start": [287, 1], "end": [303, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_divByMonic_le", "code": "theorem degree_divByMonic_le (p q : R[X]) : degree (p /\u2098 q) \u2264 degree p", "start": [306, 1], "end": [319, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_divByMonic_lt", "code": "theorem degree_divByMonic_lt (p : R[X]) {q : R[X]} (hq : Monic q) (hp0 : p \u2260 0)\n    (h0q : 0 < degree q) : degree (p /\u2098 q) < degree p", "start": [322, 1], "end": [335, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_divByMonic", "code": "theorem natDegree_divByMonic {R : Type u} [CommRing R] (f : R[X]) {g : R[X]} (hg : g.Monic) :\n    natDegree (f /\u2098 g) = natDegree f - natDegree g", "start": [338, 1], "end": [355, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_modByMonic_unique", "code": "theorem div_modByMonic_unique {f g} (q r : R[X]) (hg : Monic g)\n    (h : r + g * q = f \u2227 degree r < degree g) : f /\u2098 g = q \u2227 f %\u2098 g = r", "start": [358, 1], "end": [379, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_mod_divByMonic", "code": "theorem map_mod_divByMonic [CommRing S] (f : R \u2192+* S) (hq : Monic q) :\n    (p /\u2098 q).map f = p.map f /\u2098 q.map f \u2227 (p %\u2098 q).map f = p.map f %\u2098 q.map f", "start": [382, 1], "end": [396, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_divByMonic", "code": "theorem map_divByMonic [CommRing S] (f : R \u2192+* S) (hq : Monic q) :\n    (p /\u2098 q).map f = p.map f /\u2098 q.map f", "start": [399, 1], "end": [401, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_modByMonic", "code": "theorem map_modByMonic [CommRing S] (f : R \u2192+* S) (hq : Monic q) :\n    (p %\u2098 q).map f = p.map f %\u2098 q.map f", "start": [404, 1], "end": [406, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_iff_modByMonic_eq_zero", "code": "theorem dvd_iff_modByMonic_eq_zero (hq : Monic q) : p %\u2098 q = 0 \u2194 q \u2223 p", "start": [409, 1], "end": [423, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_dvd_map", "code": "theorem map_dvd_map [CommRing S] (f : R \u2192+* S) (hf : Function.Injective f) {x y : R[X]}\n    (hx : x.Monic) : x.map f \u2223 y.map f \u2194 x \u2223 y", "start": [426, 1], "end": [432, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_one", "code": "@[simp]\ntheorem modByMonic_one (p : R[X]) : p %\u2098 1 = 0", "start": [435, 1], "end": [437, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_one", "code": "@[simp]\ntheorem divByMonic_one (p : R[X]) : p /\u2098 1 = p", "start": [440, 1], "end": [442, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_X_sub_C_eq_C_eval", "code": "@[simp]\ntheorem modByMonic_X_sub_C_eq_C_eval (p : R[X]) (a : R) : p %\u2098 (X - C a) = C (p.eval a)", "start": [445, 1], "end": [459, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_divByMonic_eq_iff_isRoot", "code": "theorem mul_divByMonic_eq_iff_isRoot : (X - C a) * (p /\u2098 (X - C a)) = p \u2194 IsRoot p a", "start": [463, 1], "end": [469, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_iff_isRoot", "code": "theorem dvd_iff_isRoot : X - C a \u2223 p \u2194 IsRoot p a", "start": [472, 1], "end": [476, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_sub_C_dvd_sub_C_eval", "code": "theorem X_sub_C_dvd_sub_C_eval : X - C a \u2223 p - C (p.eval a)", "start": [479, 1], "end": [480, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_span_C_X_sub_C_X_sub_C_iff_eval_eval_eq_zero", "code": "theorem mem_span_C_X_sub_C_X_sub_C_iff_eval_eval_eq_zero {b : R[X]} {P : R[X][X]} :\n    P \u2208 Ideal.span {C (X - C a), X - C b} \u2194 (P.eval b).eval a = 0", "start": [484, 1], "end": [492, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_X", "code": "theorem modByMonic_X (p : R[X]) : p %\u2098 X = C (p.eval 0)", "start": [496, 1], "end": [497, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_modByMonic_eq_self_of_root", "code": "theorem eval\u2082_modByMonic_eq_self_of_root [CommRing S] {f : R \u2192+* S} {p q : R[X]} (hq : q.Monic)\n    {x : S} (hx : q.eval\u2082 f x = 0) : (p %\u2098 q).eval\u2082 f x = p.eval\u2082 f x", "start": [501, 1], "end": [503, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_modByMonic_coeff", "code": "theorem sum_modByMonic_coeff (hq : q.Monic) {n : \u2115} (hn : q.degree \u2264 n) :\n    (\u2211 i : Fin n, monomial i ((p %\u2098 q).coeff i)) = p %\u2098 q", "start": [506, 1], "end": [511, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sub_dvd_eval_sub", "code": "theorem sub_dvd_eval_sub (a b : R) (p : R[X]) : a - b \u2223 p.eval a - p.eval b", "start": [514, 1], "end": [517, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_div_mod_by_monic_cancel_left", "code": "theorem mul_div_mod_by_monic_cancel_left (p : R[X]) {q : R[X]} (hmo : q.Monic) :\n    q * p /\u2098 q = p", "start": [520, 1], "end": [525, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_isField", "code": "theorem not_isField : \u00acIsField R[X]", "start": [530, 1], "end": [539, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ker_evalRingHom", "code": "theorem ker_evalRingHom (x : R) : RingHom.ker (evalRingHom x) = Ideal.span {X - C x}", "start": [544, 1], "end": [546, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.decidableDvdMonic", "code": "def decidableDvdMonic [DecidableEq R] (p : R[X]) (hq : Monic q) : Decidable (q \u2223 p) :=\n  decidable_of_iff (p %\u2098 q = 0) (dvd_iff_modByMonic_eq_zero hq)", "start": [551, 1], "end": [556, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.multiplicity_X_sub_C_finite", "code": "theorem multiplicity_X_sub_C_finite (a : R) (h0 : p \u2260 0) : multiplicity.Finite (X - C a) p", "start": [559, 1], "end": [563, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity", "code": "def rootMultiplicity (a : R) (p : R[X]) : \u2115 :=\n  letI := Classical.decEq R\n  if h0 : p = 0 then 0\n  else\n    let _ : DecidablePred fun n : \u2115 => \u00ac(X - C a) ^ (n + 1) \u2223 p := fun n =>\n      @Not.decidable _ (decidableDvdMonic p ((monic_X_sub_C a).pow (n + 1)))\n    Nat.find (multiplicity_X_sub_C_finite a h0)", "start": [569, 1], "end": [578, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_eq_nat_find_of_nonzero", "code": "theorem rootMultiplicity_eq_nat_find_of_nonzero [DecidableEq R] {p : R[X]} (p0 : p \u2260 0) {a : R} :\n    letI : DecidablePred fun n : \u2115 => \u00ac(X - C a) ^ (n + 1) \u2223 p := fun n =>\n      @Not.decidable _ (decidableDvdMonic p ((monic_X_sub_C a).pow (n + 1)))\n    rootMultiplicity a p = Nat.find (multiplicity_X_sub_C_finite a p0)", "start": [584, 1], "end": [590, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_eq_multiplicity", "code": "theorem rootMultiplicity_eq_multiplicity [DecidableEq R] [@DecidableRel R[X] (\u00b7 \u2223 \u00b7)]\n    (p : R[X]) (a : R) :\n    rootMultiplicity a p =\n      if h0 : p = 0 then 0 else (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a h0)", "start": [592, 1], "end": [596, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_zero", "code": "@[simp]\ntheorem rootMultiplicity_zero {x : R} : rootMultiplicity x 0 = 0", "start": [599, 1], "end": [601, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_eq_zero_iff", "code": "@[simp]\ntheorem rootMultiplicity_eq_zero_iff {p : R[X]} {x : R} :\n    rootMultiplicity x p = 0 \u2194 IsRoot p x \u2192 p = 0", "start": [604, 1], "end": [609, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_eq_zero", "code": "theorem rootMultiplicity_eq_zero {p : R[X]} {x : R} (h : \u00acIsRoot p x) : rootMultiplicity x p = 0", "start": [612, 1], "end": [613, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_pos'", "code": "@[simp]\ntheorem rootMultiplicity_pos' {p : R[X]} {x : R} : 0 < rootMultiplicity x p \u2194 p \u2260 0 \u2227 IsRoot p x", "start": [616, 1], "end": [618, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_pos", "code": "theorem rootMultiplicity_pos {p : R[X]} (hp : p \u2260 0) {x : R} :\n    0 < rootMultiplicity x p \u2194 IsRoot p x", "start": [621, 1], "end": [623, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_C", "code": "@[simp]\ntheorem rootMultiplicity_C (r a : R) : rootMultiplicity a (C r) = 0", "start": [626, 1], "end": [628, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.pow_rootMultiplicity_dvd", "code": "theorem pow_rootMultiplicity_dvd (p : R[X]) (a : R) : (X - C a) ^ rootMultiplicity a p \u2223 p", "start": [632, 1], "end": [637, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_mul_pow_rootMultiplicity_eq", "code": "theorem divByMonic_mul_pow_rootMultiplicity_eq (p : R[X]) (a : R) :\n    p /\u2098 (X - C a) ^ rootMultiplicity a p * (X - C a) ^ rootMultiplicity a p = p", "start": [640, 1], "end": [646, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_divByMonic_pow_rootMultiplicity_ne_zero", "code": "theorem eval_divByMonic_pow_rootMultiplicity_ne_zero {p : R[X]} (a : R) (hp : p \u2260 0) :\n    eval a (p /\u2098 (X - C a) ^ rootMultiplicity a p) \u2260 0", "start": [649, 1], "end": [662, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "imports": ["Mathlib/MeasureTheory/Measure/OuterMeasure.lean", "Mathlib/Order/Filter/CountableInter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Measure", "code": "structure Measure (\u03b1 : Type*) [MeasurableSpace \u03b1] extends OuterMeasure \u03b1 where\n  m_iUnion \u2983f : \u2115 \u2192 Set \u03b1\u2984 :\n    (\u2200 i, MeasurableSet (f i)) \u2192\n      Pairwise (Disjoint on f) \u2192 measureOf (\u22c3 i, f i) = \u2211' i, measureOf (f i)\n  trimmed : toOuterMeasure.trim = toOuterMeasure", "start": [71, 1], "end": [78, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.instCoeFun", "code": "instance Measure.instCoeFun [MeasurableSpace \u03b1] : CoeFun (Measure \u03b1) fun _ => Set \u03b1 \u2192 \u211d\u22650\u221e :=\n  \u27e8fun m => m.toOuterMeasure\u27e9", "start": [81, 1], "end": [88, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ofMeasurable", "code": "def ofMeasurable (m : \u2200 s : Set \u03b1, MeasurableSet s \u2192 \u211d\u22650\u221e) (m0 : m \u2205 MeasurableSet.empty = 0)\n    (mU :\n      \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (h : \u2200 i, MeasurableSet (f i)),\n        Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) (MeasurableSet.iUnion h) = \u2211' i, m (f i) (h i)) :\n    Measure \u03b1 :=\n  { inducedOuterMeasure m _ m0 with\n    m_iUnion := fun f hf hd =>\n      show inducedOuterMeasure m _ m0 (iUnion f) = \u2211' i, inducedOuterMeasure m _ m0 (f i) by\n        rw [inducedOuterMeasure_eq m0 mU, mU hf hd]\n        congr; funext n; rw [inducedOuterMeasure_eq m0 mU]\n    trimmed :=\n      show (inducedOuterMeasure m _ m0).trim = inducedOuterMeasure m _ m0 by\n        unfold OuterMeasure.trim\n        congr; funext s hs\n        exact inducedOuterMeasure_eq m0 mU hs }", "start": [102, 1], "end": [117, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ofMeasurable_apply", "code": "theorem ofMeasurable_apply {m : \u2200 s : Set \u03b1, MeasurableSet s \u2192 \u211d\u22650\u221e}\n    {m0 : m \u2205 MeasurableSet.empty = 0}\n    {mU :\n      \u2200 \u2983f : \u2115 \u2192 Set \u03b1\u2984 (h : \u2200 i, MeasurableSet (f i)),\n        Pairwise (Disjoint on f) \u2192 m (\u22c3 i, f i) (MeasurableSet.iUnion h) = \u2211' i, m (f i) (h i)}\n    (s : Set \u03b1) (hs : MeasurableSet s) : ofMeasurable m m0 mU s = m s hs", "start": [120, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.toOuterMeasure_injective", "code": "theorem toOuterMeasure_injective : Injective (toOuterMeasure : Measure \u03b1 \u2192 OuterMeasure \u03b1)", "start": [129, 1], "end": [131, 8], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext", "code": "@[ext]\ntheorem ext (h : \u2200 s, MeasurableSet s \u2192 \u03bc\u2081 s = \u03bc\u2082 s) : \u03bc\u2081 = \u03bc\u2082", "start": [134, 1], "end": [137, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_iff", "code": "theorem ext_iff : \u03bc\u2081 = \u03bc\u2082 \u2194 \u2200 s, MeasurableSet s \u2192 \u03bc\u2081 s = \u03bc\u2082 s", "start": [140, 1], "end": [141, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ext_iff'", "code": "theorem ext_iff' : \u03bc\u2081 = \u03bc\u2082 \u2194 \u2200 s, \u03bc\u2081 s = \u03bc\u2082 s", "start": [144, 1], "end": [145, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_trim", "code": "theorem measure_eq_trim (s : Set \u03b1) : \u03bc s = \u03bc.toOuterMeasure.trim s", "start": [153, 1], "end": [153, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_iInf", "code": "theorem measure_eq_iInf (s : Set \u03b1) : \u03bc s = \u2a05 (t) (_ : s \u2286 t) (_ : MeasurableSet t), \u03bc t", "start": [156, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_iInf'", "code": "theorem measure_eq_iInf' (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    \u03bc s = \u2a05 t : { t // s \u2286 t \u2227 MeasurableSet t }, \u03bc t", "start": [160, 1], "end": [165, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_inducedOuterMeasure", "code": "theorem measure_eq_inducedOuterMeasure :\n    \u03bc s = inducedOuterMeasure (fun s _ => \u03bc s) MeasurableSet.empty \u03bc.empty s", "start": [168, 1], "end": [170, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toOuterMeasure_eq_inducedOuterMeasure", "code": "theorem toOuterMeasure_eq_inducedOuterMeasure :\n    \u03bc.toOuterMeasure = inducedOuterMeasure (fun s _ => \u03bc s) MeasurableSet.empty \u03bc.empty", "start": [173, 1], "end": [175, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_eq_extend", "code": "theorem measure_eq_extend (hs : MeasurableSet s) :\n    \u03bc s = extend (fun t (_ht : MeasurableSet t) => \u03bc t) s", "start": [178, 1], "end": [181, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_empty", "code": "theorem measure_empty : \u03bc \u2205 = 0", "start": [185, 1], "end": [186, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nonempty_of_measure_ne_zero", "code": "theorem nonempty_of_measure_ne_zero (h : \u03bc s \u2260 0) : s.Nonempty", "start": [189, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_mono", "code": "theorem measure_mono (h : s\u2081 \u2286 s\u2082) : \u03bc s\u2081 \u2264 \u03bc s\u2082", "start": [193, 1], "end": [194, 11], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_mono_null", "code": "theorem measure_mono_null (h : s\u2081 \u2286 s\u2082) (h\u2082 : \u03bc s\u2082 = 0) : \u03bc s\u2081 = 0", "start": [197, 1], "end": [198, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_mono_top", "code": "theorem measure_mono_top (h : s\u2081 \u2286 s\u2082) (h\u2081 : \u03bc s\u2081 = \u221e) : \u03bc s\u2082 = \u221e", "start": [201, 1], "end": [202, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_le_measure_union_left", "code": "@[simp, mono]\ntheorem measure_le_measure_union_left : \u03bc s \u2264 \u03bc (s \u222a t)", "start": [205, 1], "end": [206, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_le_measure_union_right", "code": "@[simp, mono]\ntheorem measure_le_measure_union_right : \u03bc t \u2264 \u03bc (s \u222a t)", "start": [208, 1], "end": [209, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_superset", "code": "theorem exists_measurable_superset (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u03bc t = \u03bc s", "start": [211, 1], "end": [214, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_superset_forall_eq", "code": "theorem exists_measurable_superset_forall_eq {\u03b9} [Countable \u03b9] (\u03bc : \u03b9 \u2192 Measure \u03b1) (s : Set \u03b1) :\n    \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u2200 i, \u03bc i t = \u03bc i s", "start": [217, 1], "end": [222, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_superset\u2082", "code": "theorem exists_measurable_superset\u2082 (\u03bc \u03bd : Measure \u03b1) (s : Set \u03b1) :\n    \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u03bc t = \u03bc s \u2227 \u03bd t = \u03bd s", "start": [225, 1], "end": [228, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_superset_of_null", "code": "theorem exists_measurable_superset_of_null (h : \u03bc s = 0) : \u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u03bc t = 0", "start": [231, 1], "end": [232, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measurable_superset_iff_measure_eq_zero", "code": "theorem exists_measurable_superset_iff_measure_eq_zero :\n    (\u2203 t, s \u2286 t \u2227 MeasurableSet t \u2227 \u03bc t = 0) \u2194 \u03bc s = 0", "start": [235, 1], "end": [237, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_le", "code": "theorem measure_iUnion_le [Countable \u03b2] (s : \u03b2 \u2192 Set \u03b1) : \u03bc (\u22c3 i, s i) \u2264 \u2211' i, \u03bc (s i)", "start": [240, 1], "end": [241, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_le", "code": "theorem measure_biUnion_le {s : Set \u03b2} (hs : s.Countable) (f : \u03b2 \u2192 Set \u03b1) :\n    \u03bc (\u22c3 b \u2208 s, f b) \u2264 \u2211' p : s, \u03bc (f p)", "start": [244, 1], "end": [248, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_finset_le", "code": "theorem measure_biUnion_finset_le (s : Finset \u03b2) (f : \u03b2 \u2192 Set \u03b1) :\n    \u03bc (\u22c3 b \u2208 s, f b) \u2264 \u2211 p in s, \u03bc (f p)", "start": [251, 1], "end": [254, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_fintype_le", "code": "theorem measure_iUnion_fintype_le [Fintype \u03b2] (f : \u03b2 \u2192 Set \u03b1) : \u03bc (\u22c3 b, f b) \u2264 \u2211 p, \u03bc (f p)", "start": [257, 1], "end": [259, 7], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_lt_top", "code": "theorem measure_biUnion_lt_top {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Finite)\n    (hfin : \u2200 i \u2208 s, \u03bc (f i) \u2260 \u221e) : \u03bc (\u22c3 i \u2208 s, f i) < \u221e", "start": [262, 1], "end": [267, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_null", "code": "theorem measure_iUnion_null [Countable \u03b2] {s : \u03b2 \u2192 Set \u03b1} : (\u2200 i, \u03bc (s i) = 0) \u2192 \u03bc (\u22c3 i, s i) = 0", "start": [270, 1], "end": [271, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_null_iff", "code": "theorem measure_iUnion_null_iff [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} :\n    \u03bc (\u22c3 i, s i) = 0 \u2194 \u2200 i, \u03bc (s i) = 0", "start": [275, 1], "end": [277, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion_null_iff'", "code": "theorem measure_iUnion_null_iff' {\u03b9 : Prop} {s : \u03b9 \u2192 Set \u03b1} : \u03bc (\u22c3 i, s i) = 0 \u2194 \u2200 i, \u03bc (s i) = 0", "start": [280, 1], "end": [285, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_biUnion_null_iff", "code": "theorem measure_biUnion_null_iff {s : Set \u03b9} (hs : s.Countable) {t : \u03b9 \u2192 Set \u03b1} :\n    \u03bc (\u22c3 i \u2208 s, t i) = 0 \u2194 \u2200 i \u2208 s, \u03bc (t i) = 0", "start": [288, 1], "end": [290, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_sUnion_null_iff", "code": "theorem measure_sUnion_null_iff {S : Set (Set \u03b1)} (hS : S.Countable) :\n    \u03bc (\u22c3\u2080 S) = 0 \u2194 \u2200 s \u2208 S, \u03bc s = 0", "start": [293, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_le", "code": "theorem measure_union_le (s\u2081 s\u2082 : Set \u03b1) : \u03bc (s\u2081 \u222a s\u2082) \u2264 \u03bc s\u2081 + \u03bc s\u2082", "start": [298, 1], "end": [299, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_null", "code": "theorem measure_union_null : \u03bc s\u2081 = 0 \u2192 \u03bc s\u2082 = 0 \u2192 \u03bc (s\u2081 \u222a s\u2082) = 0", "start": [302, 1], "end": [303, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_null_iff", "code": "@[simp]\ntheorem measure_union_null_iff : \u03bc (s\u2081 \u222a s\u2082) = 0 \u2194 \u03bc s\u2081 = 0 \u2227 \u03bc s\u2082 = 0", "start": [306, 1], "end": [310, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_lt_top", "code": "theorem measure_union_lt_top (hs : \u03bc s < \u221e) (ht : \u03bc t < \u221e) : \u03bc (s \u222a t) < \u221e", "start": [313, 1], "end": [314, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_lt_top_iff", "code": "@[simp]\ntheorem measure_union_lt_top_iff : \u03bc (s \u222a t) < \u221e \u2194 \u03bc s < \u221e \u2227 \u03bc t < \u221e", "start": [317, 1], "end": [321, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_ne_top", "code": "theorem measure_union_ne_top (hs : \u03bc s \u2260 \u221e) (ht : \u03bc t \u2260 \u221e) : \u03bc (s \u222a t) \u2260 \u221e", "start": [324, 1], "end": [325, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_symmDiff_ne_top", "code": "theorem measure_symmDiff_ne_top (hs : \u03bc s \u2260 \u221e) (ht : \u03bc t \u2260 \u221e) : \u03bc (s \u2206 t) \u2260 \u221e", "start": [328, 1], "end": [329, 89], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_eq_top_iff", "code": "@[simp]\ntheorem measure_union_eq_top_iff : \u03bc (s \u222a t) = \u221e \u2194 \u03bc s = \u221e \u2228 \u03bc t = \u221e", "start": [331, 1], "end": [333, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_measure_pos_of_not_measure_iUnion_null", "code": "theorem exists_measure_pos_of_not_measure_iUnion_null [Countable \u03b2] {s : \u03b2 \u2192 Set \u03b1}\n    (hs : \u03bc (\u22c3 n, s n) \u2260 0) : \u2203 n, 0 < \u03bc (s n)", "start": [336, 1], "end": [339, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_lt_top_of_subset", "code": "theorem measure_lt_top_of_subset (hst : t \u2286 s) (hs : \u03bc s \u2260 \u221e) : \u03bc t < \u221e", "start": [342, 1], "end": [343, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_lt_top_of_left_ne_top", "code": "theorem measure_inter_lt_top_of_left_ne_top (hs_finite : \u03bc s \u2260 \u221e) : \u03bc (s \u2229 t) < \u221e", "start": [345, 1], "end": [346, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_lt_top_of_right_ne_top", "code": "theorem measure_inter_lt_top_of_right_ne_top (ht_finite : \u03bc t \u2260 \u221e) : \u03bc (s \u2229 t) < \u221e", "start": [349, 1], "end": [350, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_null_of_null_right", "code": "theorem measure_inter_null_of_null_right (S : Set \u03b1) {T : Set \u03b1} (h : \u03bc T = 0) : \u03bc (S \u2229 T) = 0", "start": [353, 1], "end": [354, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_null_of_null_left", "code": "theorem measure_inter_null_of_null_left {S : Set \u03b1} (T : Set \u03b1) (h : \u03bc S = 0) : \u03bc (S \u2229 T) = 0", "start": [357, 1], "end": [358, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae", "code": "def Measure.ae {\u03b1} {m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Filter \u03b1 where\n  sets := { s | \u03bc s\u1d9c = 0 }\n  univ_sets := by simp\n  inter_sets hs ht := by simp only [compl_inter, mem_setOf_eq]; exact measure_union_null hs ht\n  sets_of_superset hs hst := measure_mono_null (Set.compl_subset_compl.2 hst) hs", "start": [364, 1], "end": [369, 81], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mem_ae_iff", "code": "theorem mem_ae_iff {s : Set \u03b1} : s \u2208 \u03bc.ae \u2194 \u03bc s\u1d9c = 0", "start": [384, 1], "end": [385, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_iff", "code": "theorem ae_iff {p : \u03b1 \u2192 Prop} : (\u2200\u1d50 a \u2202\u03bc, p a) \u2194 \u03bc { a | \u00acp a } = 0", "start": [388, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.compl_mem_ae_iff", "code": "theorem compl_mem_ae_iff {s : Set \u03b1} : s\u1d9c \u2208 \u03bc.ae \u2194 \u03bc s = 0", "start": [392, 1], "end": [392, 101], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.frequently_ae_iff", "code": "theorem frequently_ae_iff {p : \u03b1 \u2192 Prop} : (\u2203\u1d50 a \u2202\u03bc, p a) \u2194 \u03bc { a | p a } \u2260 0", "start": [395, 1], "end": [396, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.frequently_ae_mem_iff", "code": "theorem frequently_ae_mem_iff {s : Set \u03b1} : (\u2203\u1d50 a \u2202\u03bc, a \u2208 s) \u2194 \u03bc s \u2260 0", "start": [399, 1], "end": [400, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_zero_iff_ae_nmem", "code": "theorem measure_zero_iff_ae_nmem {s : Set \u03b1} : \u03bc s = 0 \u2194 \u2200\u1d50 a \u2202\u03bc, a \u2209 s", "start": [403, 1], "end": [404, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_of_all", "code": "theorem ae_of_all {p : \u03b1 \u2192 Prop} (\u03bc : Measure \u03b1) : (\u2200 a, p a) \u2192 \u2200\u1d50 a \u2202\u03bc, p a", "start": [407, 1], "end": [408, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.instCountableInterFilter", "code": "instance instCountableInterFilter : CountableInterFilter \u03bc.ae :=\n  \u27e8by\n    intro S hSc hS\n    rw [mem_ae_iff, compl_sInter, sUnion_image]\n    exact (measure_biUnion_null_iff hSc).2 hS\u27e9", "start": [415, 1], "end": [419, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_all_iff", "code": "theorem ae_all_iff {\u03b9 : Sort*} [Countable \u03b9] {p : \u03b1 \u2192 \u03b9 \u2192 Prop} :\n    (\u2200\u1d50 a \u2202\u03bc, \u2200 i, p a i) \u2194 \u2200 i, \u2200\u1d50 a \u2202\u03bc, p a i", "start": [422, 1], "end": [424, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.all_ae_of", "code": "theorem all_ae_of {\u03b9 : Sort _} {p : \u03b1 \u2192 \u03b9 \u2192 Prop} (hp : \u2200\u1d50 a \u2202\u03bc, \u2200 i, p a i) (i : \u03b9) :\n    \u2200\u1d50 a \u2202\u03bc, p a i", "start": [427, 1], "end": [429, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_ball_iff", "code": "theorem ae_ball_iff {S : Set \u03b9} (hS : S.Countable) {p : \u2200 (_x : \u03b1), \u2200 i \u2208 S, Prop} :\n    (\u2200\u1d50 x \u2202\u03bc, \u2200 i (hi : i \u2208 S), p x i hi) \u2194 \u2200 i (hi : i \u2208 S), \u2200\u1d50 x \u2202\u03bc, p x i hi", "start": [431, 1], "end": [433, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_refl", "code": "theorem ae_eq_refl (f : \u03b1 \u2192 \u03b4) : f =\u1d50[\u03bc] f", "start": [436, 1], "end": [437, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_symm", "code": "theorem ae_eq_symm {f g : \u03b1 \u2192 \u03b4} (h : f =\u1d50[\u03bc] g) : g =\u1d50[\u03bc] f", "start": [440, 1], "end": [441, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_trans", "code": "theorem ae_eq_trans {f g h : \u03b1 \u2192 \u03b4} (h\u2081 : f =\u1d50[\u03bc] g) (h\u2082 : g =\u1d50[\u03bc] h) : f =\u1d50[\u03bc] h", "start": [444, 1], "end": [445, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_of_ae_lt", "code": "theorem ae_le_of_ae_lt {f g : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200\u1d50 x \u2202\u03bc, f x < g x) : f \u2264\u1d50[\u03bc] g", "start": [448, 1], "end": [452, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_empty", "code": "@[simp]\ntheorem ae_eq_empty : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2194 \u03bc s = 0", "start": [455, 1], "end": [457, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_univ", "code": "@[simp high]\ntheorem ae_eq_univ : s =\u1d50[\u03bc] (univ : Set \u03b1) \u2194 \u03bc s\u1d9c = 0", "start": [461, 1], "end": [463, 20], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_set", "code": "theorem ae_le_set : s \u2264\u1d50[\u03bc] t \u2194 \u03bc (s \\ t) = 0", "start": [466, 1], "end": [469, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_set_inter", "code": "theorem ae_le_set_inter {s' t' : Set \u03b1} (h : s \u2264\u1d50[\u03bc] t) (h' : s' \u2264\u1d50[\u03bc] t') :\n    (s \u2229 s' : Set \u03b1) \u2264\u1d50[\u03bc] (t \u2229 t' : Set \u03b1)", "start": [473, 1], "end": [475, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_set_union", "code": "theorem ae_le_set_union {s' t' : Set \u03b1} (h : s \u2264\u1d50[\u03bc] t) (h' : s' \u2264\u1d50[\u03bc] t') :\n    (s \u222a s' : Set \u03b1) \u2264\u1d50[\u03bc] (t \u222a t' : Set \u03b1)", "start": [478, 1], "end": [480, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_right", "code": "theorem union_ae_eq_right : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] t \u2194 \u03bc (s \\ t) = 0", "start": [483, 1], "end": [485, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.diff_ae_eq_self", "code": "theorem diff_ae_eq_self : (s \\ t : Set \u03b1) =\u1d50[\u03bc] s \u2194 \u03bc (s \u2229 t) = 0", "start": [488, 1], "end": [490, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.diff_null_ae_eq_self", "code": "theorem diff_null_ae_eq_self (ht : \u03bc t = 0) : (s \\ t : Set \u03b1) =\u1d50[\u03bc] s", "start": [493, 1], "end": [494, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_set", "code": "theorem ae_eq_set {s t : Set \u03b1} : s =\u1d50[\u03bc] t \u2194 \u03bc (s \\ t) = 0 \u2227 \u03bc (t \\ s) = 0", "start": [497, 1], "end": [498, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_symmDiff_eq_zero_iff", "code": "@[simp]\ntheorem measure_symmDiff_eq_zero_iff {s t : Set \u03b1} : \u03bc (s \u2206 t) = 0 \u2194 s =\u1d50[\u03bc] t", "start": [501, 1], "end": [503, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_set_compl_compl", "code": "@[simp]\ntheorem ae_eq_set_compl_compl {s t : Set \u03b1} : s\u1d9c =\u1d50[\u03bc] t\u1d9c \u2194 s =\u1d50[\u03bc] t", "start": [506, 1], "end": [508, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_set_compl", "code": "theorem ae_eq_set_compl {s t : Set \u03b1} : s\u1d9c =\u1d50[\u03bc] t \u2194 s =\u1d50[\u03bc] t\u1d9c", "start": [511, 1], "end": [512, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_set_inter", "code": "theorem ae_eq_set_inter {s' t' : Set \u03b1} (h : s =\u1d50[\u03bc] t) (h' : s' =\u1d50[\u03bc] t') :\n    (s \u2229 s' : Set \u03b1) =\u1d50[\u03bc] (t \u2229 t' : Set \u03b1)", "start": [515, 1], "end": [517, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_eq_set_union", "code": "theorem ae_eq_set_union {s' t' : Set \u03b1} (h : s =\u1d50[\u03bc] t) (h' : s' =\u1d50[\u03bc] t') :\n    (s \u222a s' : Set \u03b1) =\u1d50[\u03bc] (t \u222a t' : Set \u03b1)", "start": [520, 1], "end": [522, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_univ_of_ae_eq_univ_left", "code": "theorem union_ae_eq_univ_of_ae_eq_univ_left (h : s =\u1d50[\u03bc] univ) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] univ", "start": [525, 1], "end": [527, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_univ_of_ae_eq_univ_right", "code": "theorem union_ae_eq_univ_of_ae_eq_univ_right (h : t =\u1d50[\u03bc] univ) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] univ", "start": [530, 1], "end": [532, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_right_of_ae_eq_empty", "code": "theorem union_ae_eq_right_of_ae_eq_empty (h : s =\u1d50[\u03bc] (\u2205 : Set \u03b1)) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] t", "start": [535, 1], "end": [537, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.union_ae_eq_left_of_ae_eq_empty", "code": "theorem union_ae_eq_left_of_ae_eq_empty (h : t =\u1d50[\u03bc] (\u2205 : Set \u03b1)) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] s", "start": [540, 1], "end": [542, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inter_ae_eq_right_of_ae_eq_univ", "code": "theorem inter_ae_eq_right_of_ae_eq_univ (h : s =\u1d50[\u03bc] univ) : (s \u2229 t : Set \u03b1) =\u1d50[\u03bc] t", "start": [545, 1], "end": [547, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inter_ae_eq_left_of_ae_eq_univ", "code": "theorem inter_ae_eq_left_of_ae_eq_univ (h : t =\u1d50[\u03bc] univ) : (s \u2229 t : Set \u03b1) =\u1d50[\u03bc] s", "start": [550, 1], "end": [552, 18], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inter_ae_eq_empty_of_ae_eq_empty_left", "code": "theorem inter_ae_eq_empty_of_ae_eq_empty_left (h : s =\u1d50[\u03bc] (\u2205 : Set \u03b1)) :\n    (s \u2229 t : Set \u03b1) =\u1d50[\u03bc] (\u2205 : Set \u03b1)", "start": [555, 1], "end": [558, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.inter_ae_eq_empty_of_ae_eq_empty_right", "code": "theorem inter_ae_eq_empty_of_ae_eq_empty_right (h : t =\u1d50[\u03bc] (\u2205 : Set \u03b1)) :\n    (s \u2229 t : Set \u03b1) =\u1d50[\u03bc] (\u2205 : Set \u03b1)", "start": [561, 1], "end": [564, 19], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.ae_induction_on_inter", "code": "theorem _root_.MeasurableSpace.ae_induction_on_inter {\u03b2} [MeasurableSpace \u03b2] {\u03bc : Measure \u03b2}\n    {C : \u03b2 \u2192 Set \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} [m : MeasurableSpace \u03b1]\n    (h_eq : m = MeasurableSpace.generateFrom s)\n    (h_inter : IsPiSystem s) (h_empty : \u2200\u1d50 x \u2202\u03bc, C x \u2205) (h_basic : \u2200\u1d50 x \u2202\u03bc, \u2200 t \u2208 s, C x t)\n    (h_compl : \u2200\u1d50 x \u2202\u03bc, \u2200 t, MeasurableSet t \u2192 C x t \u2192 C x t\u1d9c)\n    (h_union : \u2200\u1d50 x \u2202\u03bc, \u2200 f : \u2115 \u2192 Set \u03b1,\n        Pairwise (Disjoint on f) \u2192 (\u2200 i, MeasurableSet (f i)) \u2192 (\u2200 i, C x (f i)) \u2192 C x (\u22c3 i, f i)) :\n    \u2200\u1d50 x \u2202\u03bc, \u2200 \u2983t\u2984, MeasurableSet t \u2192 C x t", "start": [567, 1], "end": [585, 94], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_ae_eq_one", "code": "@[to_additive]\ntheorem _root_.Set.mulIndicator_ae_eq_one {M : Type*} [One M] {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    s.mulIndicator f =\u1d50[\u03bc] 1 \u2194 \u03bc (s \u2229 f.mulSupport) = 0", "start": [587, 1], "end": [590, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_mono_ae", "code": "@[mono]\ntheorem measure_mono_ae (H : s \u2264\u1d50[\u03bc] t) : \u03bc s \u2264 \u03bc t", "start": [594, 1], "end": [601, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.measure_le", "code": "alias _root_.Filter.EventuallyLE.measure_le := measure_mono_ae", "start": [604, 1], "end": [604, 63], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.measure_congr", "code": "theorem measure_congr (H : s =\u1d50[\u03bc] t) : \u03bc s = \u03bc t", "start": [607, 1], "end": [609, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.measure_eq", "code": "alias _root_.Filter.EventuallyEq.measure_eq := measure_congr", "start": [612, 1], "end": [612, 61], "kind": "stdtacticaliasalias"}, {"full_name": "MeasureTheory.measure_mono_null_ae", "code": "theorem measure_mono_null_ae (H : s \u2264\u1d50[\u03bc] t) (ht : \u03bc t = 0) : \u03bc s = 0", "start": [615, 1], "end": [616, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.toMeasurable", "code": "irreducible_def toMeasurable (\u03bc : Measure \u03b1) (s : Set \u03b1) : Set \u03b1 :=\n  if h : \u2203 t, t \u2287 s \u2227 MeasurableSet t \u2227 t =\u1d50[\u03bc] s then h.choose else\n    if h' : \u2203 t, t \u2287 s \u2227 MeasurableSet t \u2227\n      \u2200 u, MeasurableSet u \u2192 \u03bc (t \u2229 u) = \u03bc (s \u2229 u) then h'.choose\n    else (exists_measurable_superset \u03bc s).choose", "start": [619, 1], "end": [630, 49], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "MeasureTheory.subset_toMeasurable", "code": "theorem subset_toMeasurable (\u03bc : Measure \u03b1) (s : Set \u03b1) : s \u2286 toMeasurable \u03bc s", "start": [633, 1], "end": [635, 95], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_le_toMeasurable", "code": "theorem ae_le_toMeasurable : s \u2264\u1d50[\u03bc] toMeasurable \u03bc s", "start": [638, 1], "end": [639, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurableSet_toMeasurable", "code": "@[simp]\ntheorem measurableSet_toMeasurable (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    MeasurableSet (toMeasurable \u03bc s)", "start": [644, 1], "end": [649, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_toMeasurable", "code": "@[simp]\ntheorem measure_toMeasurable (s : Set \u03b1) : \u03bc (toMeasurable \u03bc s) = \u03bc s", "start": [652, 1], "end": [657, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasureSpace", "code": "class MeasureSpace (\u03b1 : Type*) extends MeasurableSpace \u03b1 where\n  volume : Measure \u03b1", "start": [660, 1], "end": [663, 21], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable", "code": "def AEMeasurable {_m : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1 := by volume_tac) : Prop :=\n  \u2203 g : \u03b1 \u2192 \u03b2, Measurable g \u2227 f =\u1d50[\u03bc] g", "start": [706, 1], "end": [709, 40], "kind": "commanddeclaration"}, {"full_name": "Measurable.aemeasurable", "code": "@[aesop unsafe 30% apply (rule_sets [Measurable])]\ntheorem Measurable.aemeasurable (h : Measurable f) : AEMeasurable f \u03bc", "start": [712, 1], "end": [714, 23], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.mk", "code": "def mk (f : \u03b1 \u2192 \u03b2) (h : AEMeasurable f \u03bc) : \u03b1 \u2192 \u03b2 :=\n  Classical.choose h", "start": [719, 1], "end": [723, 21], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.measurable_mk", "code": "@[measurability]\ntheorem measurable_mk (h : AEMeasurable f \u03bc) : Measurable (h.mk f)", "start": [726, 1], "end": [728, 30], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.ae_eq_mk", "code": "theorem ae_eq_mk (h : AEMeasurable f \u03bc) : f =\u1d50[\u03bc] h.mk f", "start": [731, 1], "end": [732, 30], "kind": "commanddeclaration"}, {"full_name": "AEMeasurable.congr", "code": "theorem congr (hf : AEMeasurable f \u03bc) (h : f =\u1d50[\u03bc] g) : AEMeasurable g \u03bc", "start": [735, 1], "end": [736, 56], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_congr", "code": "theorem aemeasurable_congr (h : f =\u1d50[\u03bc] g) : AEMeasurable f \u03bc \u2194 AEMeasurable g \u03bc", "start": [741, 1], "end": [742, 78], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_const", "code": "@[simp, measurability]\ntheorem aemeasurable_const {b : \u03b2} : AEMeasurable (fun _a : \u03b1 => b) \u03bc", "start": [745, 1], "end": [747, 32], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_id", "code": "@[measurability]\ntheorem aemeasurable_id : AEMeasurable id \u03bc", "start": [750, 1], "end": [752, 29], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_id'", "code": "@[measurability]\ntheorem aemeasurable_id' : AEMeasurable (fun x => x) \u03bc", "start": [755, 1], "end": [757, 29], "kind": "commanddeclaration"}, {"full_name": "Measurable.comp_aemeasurable", "code": "theorem Measurable.comp_aemeasurable [MeasurableSpace \u03b4] {f : \u03b1 \u2192 \u03b4} {g : \u03b4 \u2192 \u03b2} (hg : Measurable g)\n    (hf : AEMeasurable f \u03bc) : AEMeasurable (g \u2218 f) \u03bc", "start": [760, 1], "end": [762, 79], "kind": "commanddeclaration"}, {"full_name": "Measurable.comp_aemeasurable'", "code": "@[measurability]\ntheorem Measurable.comp_aemeasurable' [MeasurableSpace \u03b4] {f : \u03b1 \u2192 \u03b4} {g : \u03b4 \u2192 \u03b2}\n    (hg : Measurable g) (hf : AEMeasurable f \u03bc) : AEMeasurable (fun x => g (f x)) \u03bc", "start": [765, 1], "end": [768, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Hull.lean", "imports": ["Mathlib/Order/Closure.lean", "Mathlib/Analysis/Convex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "convexHull", "code": "def convexHull : ClosureOperator (Set E) :=\n  ClosureOperator.mk\u2083 (fun s => \u22c2 (t : Set E) (_ : s \u2286 t) (_ : Convex \ud835\udd5c t), t) (Convex \ud835\udd5c)\n    (fun _ =>\n      Set.subset_iInter fun _ => Set.subset_iInter fun hst => Set.subset_iInter fun _ => hst)\n    (fun _ => convex_iInter fun _ => convex_iInter fun _ => convex_iInter id) fun _ t hst ht =>\n    Set.iInter_subset_of_subset t <| Set.iInter_subset_of_subset hst <| Set.iInter_subset _ ht", "start": [42, 1], "end": [48, 95], "kind": "commanddeclaration"}, {"full_name": "subset_convexHull", "code": "theorem subset_convexHull : s \u2286 convexHull \ud835\udd5c s", "start": [53, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "convex_convexHull", "code": "theorem convex_convexHull : Convex \ud835\udd5c (convexHull \ud835\udd5c s)", "start": [57, 1], "end": [58, 36], "kind": "commanddeclaration"}, {"full_name": "convexHull_eq_iInter", "code": "theorem convexHull_eq_iInter : convexHull \ud835\udd5c s =\n    \u22c2 (t : Set E) (_ : s \u2286 t) (_ : Convex \ud835\udd5c t), t", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "mem_convexHull_iff", "code": "theorem mem_convexHull_iff : x \u2208 convexHull \ud835\udd5c s \u2194 \u2200 t, s \u2286 t \u2192 Convex \ud835\udd5c t \u2192 x \u2208 t", "start": [68, 1], "end": [69, 45], "kind": "commanddeclaration"}, {"full_name": "convexHull_min", "code": "theorem convexHull_min (hst : s \u2286 t) (ht : Convex \ud835\udd5c t) : convexHull \ud835\udd5c s \u2286 t", "start": [72, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "Convex.convexHull_subset_iff", "code": "theorem Convex.convexHull_subset_iff (ht : Convex \ud835\udd5c t) : convexHull \ud835\udd5c s \u2286 t \u2194 s \u2286 t", "start": [76, 1], "end": [77, 64], "kind": "commanddeclaration"}, {"full_name": "convexHull_mono", "code": "@[mono]\ntheorem convexHull_mono (hst : s \u2286 t) : convexHull \ud835\udd5c s \u2286 convexHull \ud835\udd5c t", "start": [80, 1], "end": [82, 30], "kind": "commanddeclaration"}, {"full_name": "Convex.convexHull_eq", "code": "theorem Convex.convexHull_eq : Convex \ud835\udd5c s \u2192 convexHull \ud835\udd5c s = s", "start": [85, 1], "end": [85, 99], "kind": "commanddeclaration"}, {"full_name": "convexHull_univ", "code": "@[simp]\ntheorem convexHull_univ : convexHull \ud835\udd5c (univ : Set E) = univ", "start": [88, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "convexHull_empty", "code": "@[simp]\ntheorem convexHull_empty : convexHull \ud835\udd5c (\u2205 : Set E) = \u2205", "start": [93, 1], "end": [95, 29], "kind": "commanddeclaration"}, {"full_name": "convexHull_empty_iff", "code": "@[simp]\ntheorem convexHull_empty_iff : convexHull \ud835\udd5c s = \u2205 \u2194 s = \u2205", "start": [98, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "convexHull_nonempty_iff", "code": "@[simp]\ntheorem convexHull_nonempty_iff : (convexHull \ud835\udd5c s).Nonempty \u2194 s.Nonempty", "start": [108, 1], "end": [111, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.convexHull", "code": "protected alias \u27e8_, Set.Nonempty.convexHull\u27e9 := convexHull_nonempty_iff", "start": [114, 1], "end": [114, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "segment_subset_convexHull", "code": "theorem segment_subset_convexHull (hx : x \u2208 s) (hy : y \u2208 s) : segment \ud835\udd5c x y \u2286 convexHull \ud835\udd5c s", "start": [117, 1], "end": [118, 95], "kind": "commanddeclaration"}, {"full_name": "convexHull_singleton", "code": "@[simp]\ntheorem convexHull_singleton (x : E) : convexHull \ud835\udd5c ({x} : Set E) = {x}", "start": [121, 1], "end": [123, 37], "kind": "commanddeclaration"}, {"full_name": "convexHull_zero", "code": "@[simp]\ntheorem convexHull_zero : convexHull \ud835\udd5c (0 : Set E) = 0", "start": [126, 1], "end": [128, 25], "kind": "commanddeclaration"}, {"full_name": "convexHull_pair", "code": "@[simp]\ntheorem convexHull_pair (x y : E) : convexHull \ud835\udd5c {x, y} = segment \ud835\udd5c x y", "start": [131, 1], "end": [136, 58], "kind": "commanddeclaration"}, {"full_name": "convexHull_convexHull_union_left", "code": "theorem convexHull_convexHull_union_left (s t : Set E) :\n    convexHull \ud835\udd5c (convexHull \ud835\udd5c s \u222a t) = convexHull \ud835\udd5c (s \u222a t)", "start": [139, 1], "end": [141, 49], "kind": "commanddeclaration"}, {"full_name": "convexHull_convexHull_union_right", "code": "theorem convexHull_convexHull_union_right (s t : Set E) :\n    convexHull \ud835\udd5c (s \u222a convexHull \ud835\udd5c t) = convexHull \ud835\udd5c (s \u222a t)", "start": [144, 1], "end": [146, 50], "kind": "commanddeclaration"}, {"full_name": "Convex.convex_remove_iff_not_mem_convexHull_remove", "code": "theorem Convex.convex_remove_iff_not_mem_convexHull_remove {s : Set E} (hs : Convex \ud835\udd5c s) (x : E) :\n    Convex \ud835\udd5c (s \\ {x}) \u2194 x \u2209 convexHull \ud835\udd5c (s \\ {x})", "start": [149, 1], "end": [163, 21], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.convexHull_image", "code": "theorem IsLinearMap.convexHull_image {f : E \u2192 F} (hf : IsLinearMap \ud835\udd5c f) (s : Set E) :\n    convexHull \ud835\udd5c (f '' s) = f '' convexHull \ud835\udd5c s", "start": [166, 1], "end": [173, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.convexHull_image", "code": "theorem LinearMap.convexHull_image (f : E \u2192\u2097[\ud835\udd5c] F) (s : Set E) :\n    convexHull \ud835\udd5c (f '' s) = f '' convexHull \ud835\udd5c s", "start": [176, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "convexHull_smul", "code": "theorem convexHull_smul (a : \ud835\udd5c) (s : Set E) : convexHull \ud835\udd5c (a \u2022 s) = a \u2022 convexHull \ud835\udd5c s", "start": [189, 1], "end": [190, 45], "kind": "commanddeclaration"}, {"full_name": "AffineMap.image_convexHull", "code": "theorem AffineMap.image_convexHull (f : E \u2192\u1d43[\ud835\udd5c] F) :\n    f '' convexHull \ud835\udd5c s = convexHull \ud835\udd5c (f '' s)", "start": [203, 1], "end": [211, 47], "kind": "commanddeclaration"}, {"full_name": "convexHull_subset_affineSpan", "code": "theorem convexHull_subset_affineSpan : convexHull \ud835\udd5c s \u2286 (affineSpan \ud835\udd5c s : Set E)", "start": [214, 1], "end": [215, 65], "kind": "commanddeclaration"}, {"full_name": "affineSpan_convexHull", "code": "@[simp]\ntheorem affineSpan_convexHull : affineSpan \ud835\udd5c (convexHull \ud835\udd5c s) = affineSpan \ud835\udd5c s", "start": [218, 1], "end": [222, 39], "kind": "commanddeclaration"}, {"full_name": "convexHull_neg", "code": "theorem convexHull_neg (s : Set E) : convexHull \ud835\udd5c (-s) = -convexHull \ud835\udd5c s", "start": [225, 1], "end": [227, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sign.lean", "imports": ["Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Data/Int/Lemmas.lean", "Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SignType", "code": "inductive SignType\n  | zero\n  | neg\n  | pos\n  deriving DecidableEq, Inhabited", "start": [19, 1], "end": [24, 34], "kind": "commanddeclaration"}, {"full_name": "SignType.zero_eq_zero", "code": "@[simp]\ntheorem zero_eq_zero : zero = 0", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_eq_neg_one", "code": "@[simp]\ntheorem neg_eq_neg_one : neg = -1", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.pos_eq_one", "code": "@[simp]\ntheorem pos_eq_one : pos = 1", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.LE", "code": "protected inductive LE : SignType \u2192 SignType \u2192 Prop\n  | of_neg (a) : SignType.LE neg a\n  | zero : SignType.LE zero zero\n  | of_pos (a) : SignType.LE a pos", "start": [74, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "SignType.LE.decidableRel", "code": "instance LE.decidableRel : DecidableRel SignType.LE := fun a b => by\n  cases a <;> cases b <;> first | exact isTrue (by constructor)| exact isFalse (by rintro \u27e8_\u27e9)", "start": [84, 1], "end": [85, 95], "kind": "commanddeclaration"}, {"full_name": "SignType.decidableEq", "code": "instance decidableEq : DecidableEq SignType := fun a b => by\n  cases a <;> cases b <;> first | exact isTrue (by constructor)| exact isFalse (by rintro \u27e8_\u27e9)", "start": [87, 1], "end": [88, 95], "kind": "commanddeclaration"}, {"full_name": "SignType.mul_comm", "code": "private lemma mul_comm : \u2200 (a b : SignType), a * b = b * a := by rintro \u27e8\u27e9 \u27e8\u27e9 <;> rfl", "start": [90, 1], "end": [90, 86], "kind": "mathlibtacticlemma"}, {"full_name": "SignType.mul_assoc", "code": "private lemma mul_assoc : \u2200 (a b c : SignType), (a * b) * c = a * (b * c) := by\n  rintro \u27e8\u27e9 \u27e8\u27e9 \u27e8\u27e9 <;> rfl", "start": [91, 1], "end": [92, 26], "kind": "mathlibtacticlemma"}, {"full_name": "SignType.le_antisymm", "code": "private lemma le_antisymm (a b : SignType) (_ : a \u2264 b) (_: b \u2264 a) : a = b := by\n  cases a <;> cases b <;> trivial", "start": [111, 1], "end": [112, 34], "kind": "mathlibtacticlemma"}, {"full_name": "SignType.le_trans", "code": "private lemma le_trans (a b c : SignType) (_ : a \u2264 b) (_: b \u2264 c) : a \u2264 c := by\n  cases a <;> cases b <;> cases c <;> first | tauto | constructor", "start": [114, 1], "end": [115, 66], "kind": "mathlibtacticlemma"}, {"full_name": "SignType.fin3Equiv", "code": "def fin3Equiv : SignType \u2243* Fin 3 where\n  toFun a :=\n    match a with\n    | 0 => \u27e80, by simp\u27e9\n    | 1 => \u27e81, by simp\u27e9\n    | -1 => \u27e82, by simp\u27e9\n  invFun a :=\n    match a with\n    | \u27e80, _\u27e9 => 0\n    | \u27e81, _\u27e9 => 1\n    | \u27e82, _\u27e9 => -1\n    | \u27e8n + 3, h\u27e9 => (h.not_le le_add_self).elim\n  left_inv a := by cases a <;> rfl\n  right_inv a :=\n    match a with\n    | \u27e80, _\u27e9 => by simp\n    | \u27e81, _\u27e9 => by simp\n    | \u27e82, _\u27e9 => by simp\n    | \u27e8n + 3, h\u27e9 => by simp at h\n  map_mul' a b := by\n    cases a <;> cases b <;> simp", "start": [137, 1], "end": [158, 33], "kind": "commanddeclaration"}, {"full_name": "SignType.nonneg_iff", "code": "theorem nonneg_iff {a : SignType} : 0 \u2264 a \u2194 a = 0 \u2228 a = 1", "start": [164, 1], "end": [164, 83], "kind": "commanddeclaration"}, {"full_name": "SignType.nonneg_iff_ne_neg_one", "code": "theorem nonneg_iff_ne_neg_one {a : SignType} : 0 \u2264 a \u2194 a \u2260 -1", "start": [167, 1], "end": [167, 87], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_one_lt_iff", "code": "theorem neg_one_lt_iff {a : SignType} : -1 < a \u2194 0 \u2264 a", "start": [170, 1], "end": [170, 80], "kind": "commanddeclaration"}, {"full_name": "SignType.nonpos_iff", "code": "theorem nonpos_iff {a : SignType} : a \u2264 0 \u2194 a = -1 \u2228 a = 0", "start": [173, 1], "end": [173, 84], "kind": "commanddeclaration"}, {"full_name": "SignType.nonpos_iff_ne_one", "code": "theorem nonpos_iff_ne_one {a : SignType} : a \u2264 0 \u2194 a \u2260 1", "start": [176, 1], "end": [176, 82], "kind": "commanddeclaration"}, {"full_name": "SignType.lt_one_iff", "code": "theorem lt_one_iff {a : SignType} : a < 1 \u2194 a \u2264 0", "start": [179, 1], "end": [179, 75], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_iff", "code": "@[simp]\ntheorem neg_iff {a : SignType} : a < 0 \u2194 a = -1", "start": [182, 1], "end": [183, 73], "kind": "commanddeclaration"}, {"full_name": "SignType.le_neg_one_iff", "code": "@[simp]\ntheorem le_neg_one_iff {a : SignType} : a \u2264 -1 \u2194 a = -1", "start": [186, 1], "end": [188, 13], "kind": "commanddeclaration"}, {"full_name": "SignType.pos_iff", "code": "@[simp]\ntheorem pos_iff {a : SignType} : 0 < a \u2194 a = 1", "start": [191, 1], "end": [192, 72], "kind": "commanddeclaration"}, {"full_name": "SignType.one_le_iff", "code": "@[simp]\ntheorem one_le_iff {a : SignType} : 1 \u2264 a \u2194 a = 1", "start": [195, 1], "end": [197, 13], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_one_le", "code": "@[simp]\ntheorem neg_one_le (a : SignType) : -1 \u2264 a", "start": [200, 1], "end": [202, 9], "kind": "commanddeclaration"}, {"full_name": "SignType.le_one", "code": "@[simp]\ntheorem le_one (a : SignType) : a \u2264 1", "start": [205, 1], "end": [207, 9], "kind": "commanddeclaration"}, {"full_name": "SignType.not_lt_neg_one", "code": "@[simp]\ntheorem not_lt_neg_one (a : SignType) : \u00aca < -1", "start": [210, 1], "end": [212, 13], "kind": "commanddeclaration"}, {"full_name": "SignType.not_one_lt", "code": "@[simp]\ntheorem not_one_lt (a : SignType) : \u00ac1 < a", "start": [215, 1], "end": [217, 13], "kind": "commanddeclaration"}, {"full_name": "SignType.self_eq_neg_iff", "code": "@[simp]\ntheorem self_eq_neg_iff (a : SignType) : a = -a \u2194 a = 0", "start": [220, 1], "end": [221, 81], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_eq_self_iff", "code": "@[simp]\ntheorem neg_eq_self_iff (a : SignType) : -a = a \u2194 a = 0", "start": [224, 1], "end": [225, 81], "kind": "commanddeclaration"}, {"full_name": "SignType.neg_one_lt_one", "code": "@[simp]\ntheorem neg_one_lt_one : (-1 : SignType) < 1", "start": [228, 1], "end": [230, 13], "kind": "commanddeclaration"}, {"full_name": "SignType.cast", "code": "@[coe]\ndef cast : SignType \u2192 \u03b1\n  | zero => 0\n  | pos => 1\n  | neg => -1", "start": [239, 1], "end": [245, 14], "kind": "commanddeclaration"}, {"full_name": "SignType.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u2191(0 : SignType) = (0 : \u03b1)", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.coe_one", "code": "@[simp]\ntheorem coe_one : \u2191(1 : SignType) = (1 : \u03b1)", "start": [259, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.coe_neg_one", "code": "@[simp]\ntheorem coe_neg_one : \u2191(-1 : SignType) = (-1 : \u03b1)", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "SignType.castHom", "code": "@[simps]\ndef castHom {\u03b1} [MulZeroOneClass \u03b1] [HasDistribNeg \u03b1] : SignType \u2192*\u2080 \u03b1 where\n  toFun := cast\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' x y := by cases x <;> cases y <;> simp [zero_eq_zero, pos_eq_one, neg_eq_neg_one]", "start": [271, 1], "end": [277, 93], "kind": "commanddeclaration"}, {"full_name": "SignType.univ_eq", "code": "theorem univ_eq : (Finset.univ : Finset SignType) = {0, -1, 1}", "start": [281, 1], "end": [282, 9], "kind": "commanddeclaration"}, {"full_name": "SignType.range_eq", "code": "theorem range_eq {\u03b1} (f : SignType \u2192 \u03b1) : Set.range f = {f zero, f neg, f pos}", "start": [284, 1], "end": [286, 37], "kind": "commanddeclaration"}, {"full_name": "SignType.sign", "code": "def SignType.sign : \u03b1 \u2192o SignType :=\n  \u27e8fun a => if 0 < a then 1 else if a < 0 then -1 else 0, fun a b h => by\n    dsimp\n    split_ifs with h\u2081 h\u2082 h\u2083 h\u2084 _ _ h\u2082 h\u2083 <;> try constructor\n    \u00b7 cases lt_irrefl 0 (h\u2081.trans <| h.trans_lt h\u2083)\n    \u00b7 cases h\u2082 (h\u2081.trans_le h)\n    \u00b7 cases h\u2084 (h.trans_lt h\u2083)\u27e9", "start": [300, 1], "end": [307, 32], "kind": "commanddeclaration"}, {"full_name": "sign_apply", "code": "theorem sign_apply : sign a = ite (0 < a) 1 (ite (a < 0) (-1) 0)", "start": [310, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "sign_zero", "code": "@[simp]\ntheorem sign_zero : sign (0 : \u03b1) = 0", "start": [314, 1], "end": [315, 61], "kind": "commanddeclaration"}, {"full_name": "sign_pos", "code": "@[simp]\ntheorem sign_pos (ha : 0 < a) : sign a = 1", "start": [318, 1], "end": [319, 74], "kind": "commanddeclaration"}, {"full_name": "sign_neg", "code": "@[simp]\ntheorem sign_neg (ha : a < 0) : sign a = -1", "start": [322, 1], "end": [323, 95], "kind": "commanddeclaration"}, {"full_name": "sign_eq_one_iff", "code": "theorem sign_eq_one_iff : sign a = 1 \u2194 0 < a", "start": [326, 1], "end": [330, 17], "kind": "commanddeclaration"}, {"full_name": "sign_eq_neg_one_iff", "code": "theorem sign_eq_neg_one_iff : sign a = -1 \u2194 a < 0", "start": [333, 1], "end": [337, 15], "kind": "commanddeclaration"}, {"full_name": "sign_eq_zero_iff", "code": "@[simp]\ntheorem sign_eq_zero_iff : sign a = 0 \u2194 a = 0", "start": [346, 1], "end": [352, 44], "kind": "commanddeclaration"}, {"full_name": "sign_ne_zero", "code": "theorem sign_ne_zero : sign a \u2260 0 \u2194 a \u2260 0", "start": [355, 1], "end": [356, 23], "kind": "commanddeclaration"}, {"full_name": "sign_nonneg_iff", "code": "@[simp]\ntheorem sign_nonneg_iff : 0 \u2264 sign a \u2194 0 \u2264 a", "start": [359, 1], "end": [364, 23], "kind": "commanddeclaration"}, {"full_name": "sign_nonpos_iff", "code": "@[simp]\ntheorem sign_nonpos_iff : sign a \u2264 0 \u2194 a \u2264 0", "start": [367, 1], "end": [372, 19], "kind": "commanddeclaration"}, {"full_name": "sign_one", "code": "theorem sign_one : sign (1 : \u03b1) = 1", "start": [382, 1], "end": [383, 23], "kind": "commanddeclaration"}, {"full_name": "sign_mul", "code": "theorem sign_mul (x y : \u03b1) : sign (x * y) = sign x * sign y", "start": [396, 1], "end": [398, 87], "kind": "commanddeclaration"}, {"full_name": "sign_mul_abs", "code": "@[simp] theorem sign_mul_abs (x : \u03b1) : (sign x * |x| : \u03b1) = x", "start": [401, 1], "end": [405, 54], "kind": "commanddeclaration"}, {"full_name": "abs_mul_sign", "code": "@[simp] theorem abs_mul_sign (x : \u03b1) : (|x| * sign x : \u03b1) = x", "start": [407, 1], "end": [411, 54], "kind": "commanddeclaration"}, {"full_name": "signHom", "code": "def signHom : \u03b1 \u2192*\u2080 SignType where\n  toFun := sign\n  map_zero' := sign_zero\n  map_one' := sign_one\n  map_mul' := sign_mul", "start": [413, 1], "end": [422, 23], "kind": "commanddeclaration"}, {"full_name": "sign_pow", "code": "theorem sign_pow (x : \u03b1) (n : \u2115) : sign (x ^ n) = sign x ^ n", "start": [425, 1], "end": [425, 84], "kind": "commanddeclaration"}, {"full_name": "Left.sign_neg", "code": "theorem Left.sign_neg [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) : sign (-a) = -sign a", "start": [434, 1], "end": [440, 9], "kind": "commanddeclaration"}, {"full_name": "Right.sign_neg", "code": "theorem Right.sign_neg [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) :\n    sign (-a) = -sign a", "start": [443, 1], "end": [450, 9], "kind": "commanddeclaration"}, {"full_name": "sign_sum", "code": "theorem sign_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} (hs : s.Nonempty) (t : SignType)\n    (h : \u2200 i \u2208 s, sign (f i) = t) : sign (\u2211 i in s, f i) = t", "start": [465, 1], "end": [473, 30], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_sign", "code": "theorem sign_eq_sign (n : \u2124) : Int.sign n = SignType.sign n", "start": [480, 1], "end": [481, 73], "kind": "commanddeclaration"}, {"full_name": "exists_signed_sum_aux", "code": "private theorem exists_signed_sum_aux {\u03b1 : Type u_1} [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2124) :\n    \u2203 (\u03b2 : Type u_1) (t : Finset \u03b2) (sgn : \u03b2 \u2192 SignType) (g : \u03b2 \u2192 \u03b1),\n      (\u2200 b, g b \u2208 s) \u2227\n        (t.card = \u2211 a in s, (f a).natAbs) \u2227\n          \u2200 a \u2208 s, (\u2211 b in t, if g b = a then (sgn b : \u2124) else 0) = f a", "start": [492, 1], "end": [503, 68], "kind": "commanddeclaration"}, {"full_name": "exists_signed_sum", "code": "theorem exists_signed_sum {\u03b1 : Type u_1} [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2124) :\n    \u2203 (\u03b2 : Type u_1) (_ : Fintype \u03b2) (sgn : \u03b2 \u2192 SignType) (g : \u03b2 \u2192 \u03b1),\n      (\u2200 b, g b \u2208 s) \u2227\n        (Fintype.card \u03b2 = \u2211 a in s, (f a).natAbs) \u2227\n          \u2200 a \u2208 s, (\u2211 b, if g b = a then (sgn b : \u2124) else 0) = f a", "start": [505, 1], "end": [513, 81], "kind": "commanddeclaration"}, {"full_name": "exists_signed_sum'", "code": "theorem exists_signed_sum' {\u03b1 : Type u_1} [Nonempty \u03b1] [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2124)\n    (n : \u2115) (h : (\u2211 i in s, (f i).natAbs) \u2264 n) :\n    \u2203 (\u03b2 : Type u_1) (_ : Fintype \u03b2) (sgn : \u03b2 \u2192 SignType) (g : \u03b2 \u2192 \u03b1),\n      (\u2200 b, g b \u2209 s \u2192 sgn b = 0) \u2227\n        Fintype.card \u03b2 = n \u2227 \u2200 a \u2208 s, (\u2211 i, if g i = a then (sgn i : \u2124) else 0) = f a", "start": [516, 1], "end": [529, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Algebra/Module/BigOperators.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "Finset.univ_fin2", "code": "theorem univ_fin2 : (univ : Finset (Fin 2)) = {0, 1}", "start": [52, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint", "code": "def weightedVSubOfPoint (p : \u03b9 \u2192 P) (b : P) : (\u03b9 \u2192 k) \u2192\u2097[k] V :=\n  \u2211 i in s, (LinearMap.proj i : (\u03b9 \u2192 k) \u2192\u2097[k] k).smulRight (p i -\u1d65 b)", "start": [65, 1], "end": [72, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_apply", "code": "@[simp]\ntheorem weightedVSubOfPoint_apply (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) :\n    s.weightedVSubOfPoint p b w = \u2211 i in s, w i \u2022 (p i -\u1d65 b)", "start": [75, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_apply_const", "code": "@[simp (high)]\ntheorem weightedVSubOfPoint_apply_const (w : \u03b9 \u2192 k) (p : P) (b : P) :\n    s.weightedVSubOfPoint (fun _ => p) b w = (\u2211 i in s, w i) \u2022 (p -\u1d65 b)", "start": [81, 1], "end": [85, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_congr", "code": "theorem weightedVSubOfPoint_congr {w\u2081 w\u2082 : \u03b9 \u2192 k} (hw : \u2200 i \u2208 s, w\u2081 i = w\u2082 i) {p\u2081 p\u2082 : \u03b9 \u2192 P}\n    (hp : \u2200 i \u2208 s, p\u2081 i = p\u2082 i) (b : P) :\n    s.weightedVSubOfPoint p\u2081 b w\u2081 = s.weightedVSubOfPoint p\u2082 b w\u2082", "start": [88, 1], "end": [95, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_eq_of_weights_eq", "code": "theorem weightedVSubOfPoint_eq_of_weights_eq (p : \u03b9 \u2192 P) (j : \u03b9) (w\u2081 w\u2082 : \u03b9 \u2192 k)\n    (hw : \u2200 i, i \u2260 j \u2192 w\u2081 i = w\u2082 i) :\n    s.weightedVSubOfPoint p (p j) w\u2081 = s.weightedVSubOfPoint p (p j) w\u2082", "start": [98, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_eq_of_sum_eq_zero", "code": "theorem weightedVSubOfPoint_eq_of_sum_eq_zero (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (h : \u2211 i in s, w i = 0)\n    (b\u2081 b\u2082 : P) : s.weightedVSubOfPoint p b\u2081 w = s.weightedVSubOfPoint p b\u2082 w", "start": [111, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_vadd_eq_of_sum_eq_one", "code": "theorem weightedVSubOfPoint_vadd_eq_of_sum_eq_one (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (h : \u2211 i in s, w i = 1)\n    (b\u2081 b\u2082 : P) : s.weightedVSubOfPoint p b\u2081 w +\u1d65 b\u2081 = s.weightedVSubOfPoint p b\u2082 w +\u1d65 b\u2082", "start": [125, 1], "end": [139, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_erase", "code": "@[simp (high)]\ntheorem weightedVSubOfPoint_erase [DecidableEq \u03b9] (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (i : \u03b9) :\n    (s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w", "start": [142, 1], "end": [149, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_insert", "code": "@[simp (high)]\ntheorem weightedVSubOfPoint_insert [DecidableEq \u03b9] (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (i : \u03b9) :\n    (insert i s).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w", "start": [152, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_indicator_subset", "code": "theorem weightedVSubOfPoint_indicator_subset (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) {s\u2081 s\u2082 : Finset \u03b9}\n    (h : s\u2081 \u2286 s\u2082) :\n    s\u2081.weightedVSubOfPoint p b w = s\u2082.weightedVSubOfPoint p b (Set.indicator (\u2191s\u2081) w)", "start": [162, 1], "end": [169, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_map", "code": "theorem weightedVSubOfPoint_map (e : \u03b9\u2082 \u21aa \u03b9) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) :\n    (s\u2082.map e).weightedVSubOfPoint p b w = s\u2082.weightedVSubOfPoint (p \u2218 e) b (w \u2218 e)", "start": [172, 1], "end": [178, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_eq_weightedVSubOfPoint_sub", "code": "theorem sum_smul_vsub_eq_weightedVSubOfPoint_sub (w : \u03b9 \u2192 k) (p\u2081 p\u2082 : \u03b9 \u2192 P) (b : P) :\n    (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082 i)) =\n      s.weightedVSubOfPoint p\u2081 b w - s.weightedVSubOfPoint p\u2082 b w", "start": [181, 1], "end": [186, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_const_eq_weightedVSubOfPoint_sub", "code": "theorem sum_smul_vsub_const_eq_weightedVSubOfPoint_sub (w : \u03b9 \u2192 k) (p\u2081 : \u03b9 \u2192 P) (p\u2082 b : P) :\n    (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082)) = s.weightedVSubOfPoint p\u2081 b w - (\u2211 i in s, w i) \u2022 (p\u2082 -\u1d65 b)", "start": [189, 1], "end": [193, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_const_vsub_eq_sub_weightedVSubOfPoint", "code": "theorem sum_smul_const_vsub_eq_sub_weightedVSubOfPoint (w : \u03b9 \u2192 k) (p\u2082 : \u03b9 \u2192 P) (p\u2081 b : P) :\n    (\u2211 i in s, w i \u2022 (p\u2081 -\u1d65 p\u2082 i)) = (\u2211 i in s, w i) \u2022 (p\u2081 -\u1d65 b) - s.weightedVSubOfPoint p\u2082 b w", "start": [196, 1], "end": [200, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_sdiff", "code": "theorem weightedVSubOfPoint_sdiff [DecidableEq \u03b9] {s\u2082 : Finset \u03b9} (h : s\u2082 \u2286 s) (w : \u03b9 \u2192 k)\n    (p : \u03b9 \u2192 P) (b : P) :\n    (s \\ s\u2082).weightedVSubOfPoint p b w + s\u2082.weightedVSubOfPoint p b w =\n      s.weightedVSubOfPoint p b w", "start": [203, 1], "end": [208, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_sdiff_sub", "code": "theorem weightedVSubOfPoint_sdiff_sub [DecidableEq \u03b9] {s\u2082 : Finset \u03b9} (h : s\u2082 \u2286 s) (w : \u03b9 \u2192 k)\n    (p : \u03b9 \u2192 P) (b : P) :\n    (s \\ s\u2082).weightedVSubOfPoint p b w - s\u2082.weightedVSubOfPoint p b (-w) =\n      s.weightedVSubOfPoint p b w", "start": [211, 1], "end": [216, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_subtype_eq_filter", "code": "theorem weightedVSubOfPoint_subtype_eq_filter (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) (pred : \u03b9 \u2192 Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).weightedVSubOfPoint (fun i => p i) b fun i => w i) =\n      (s.filter pred).weightedVSubOfPoint p b w", "start": [219, 1], "end": [224, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_filter_of_ne", "code": "theorem weightedVSubOfPoint_filter_of_ne (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) {pred : \u03b9 \u2192 Prop}\n    [DecidablePred pred] (h : \u2200 i \u2208 s, w i \u2260 0 \u2192 pred i) :\n    (s.filter pred).weightedVSubOfPoint p b w = s.weightedVSubOfPoint p b w", "start": [227, 1], "end": [236, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubOfPoint_const_smul", "code": "theorem weightedVSubOfPoint_const_smul (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (b : P) (c : k) :\n    s.weightedVSubOfPoint p b (c \u2022 w) = c \u2022 s.weightedVSubOfPoint p b w", "start": [239, 1], "end": [243, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub", "code": "def weightedVSub (p : \u03b9 \u2192 P) : (\u03b9 \u2192 k) \u2192\u2097[k] V :=\n  s.weightedVSubOfPoint p (Classical.choice S.Nonempty)", "start": [246, 1], "end": [251, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_apply", "code": "theorem weightedVSub_apply (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    s.weightedVSub p w = \u2211 i in s, w i \u2022 (p i -\u1d65 Classical.choice S.Nonempty)", "start": [254, 1], "end": [262, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero", "code": "theorem weightedVSub_eq_weightedVSubOfPoint_of_sum_eq_zero (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P)\n    (h : \u2211 i in s, w i = 0) (b : P) : s.weightedVSub p w = s.weightedVSubOfPoint p b w", "start": [265, 1], "end": [269, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_apply_const", "code": "@[simp]\ntheorem weightedVSub_apply_const (w : \u03b9 \u2192 k) (p : P) (h : \u2211 i in s, w i = 0) :\n    s.weightedVSub (fun _ => p) w = 0", "start": [272, 1], "end": [277, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_empty", "code": "@[simp]\ntheorem weightedVSub_empty (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) : (\u2205 : Finset \u03b9).weightedVSub p w = (0 : V)", "start": [280, 1], "end": [283, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_congr", "code": "theorem weightedVSub_congr {w\u2081 w\u2082 : \u03b9 \u2192 k} (hw : \u2200 i \u2208 s, w\u2081 i = w\u2082 i) {p\u2081 p\u2082 : \u03b9 \u2192 P}\n    (hp : \u2200 i \u2208 s, p\u2081 i = p\u2082 i) : s.weightedVSub p\u2081 w\u2081 = s.weightedVSub p\u2082 w\u2082", "start": [286, 1], "end": [290, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_indicator_subset", "code": "theorem weightedVSub_indicator_subset (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {s\u2081 s\u2082 : Finset \u03b9} (h : s\u2081 \u2286 s\u2082) :\n    s\u2081.weightedVSub p w = s\u2082.weightedVSub p (Set.indicator (\u2191s\u2081) w)", "start": [293, 1], "end": [297, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_map", "code": "theorem weightedVSub_map (e : \u03b9\u2082 \u21aa \u03b9) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    (s\u2082.map e).weightedVSub p w = s\u2082.weightedVSub (p \u2218 e) (w \u2218 e)", "start": [300, 1], "end": [305, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_eq_weightedVSub_sub", "code": "theorem sum_smul_vsub_eq_weightedVSub_sub (w : \u03b9 \u2192 k) (p\u2081 p\u2082 : \u03b9 \u2192 P) :\n    (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082 i)) = s.weightedVSub p\u2081 w - s.weightedVSub p\u2082 w", "start": [308, 1], "end": [312, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_const_eq_weightedVSub", "code": "theorem sum_smul_vsub_const_eq_weightedVSub (w : \u03b9 \u2192 k) (p\u2081 : \u03b9 \u2192 P) (p\u2082 : P)\n    (h : \u2211 i in s, w i = 0) : (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082)) = s.weightedVSub p\u2081 w", "start": [315, 1], "end": [319, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_const_vsub_eq_neg_weightedVSub", "code": "theorem sum_smul_const_vsub_eq_neg_weightedVSub (w : \u03b9 \u2192 k) (p\u2082 : \u03b9 \u2192 P) (p\u2081 : P)\n    (h : \u2211 i in s, w i = 0) : (\u2211 i in s, w i \u2022 (p\u2081 -\u1d65 p\u2082 i)) = -s.weightedVSub p\u2082 w", "start": [322, 1], "end": [326, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_sdiff", "code": "theorem weightedVSub_sdiff [DecidableEq \u03b9] {s\u2082 : Finset \u03b9} (h : s\u2082 \u2286 s) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    (s \\ s\u2082).weightedVSub p w + s\u2082.weightedVSub p w = s.weightedVSub p w", "start": [329, 1], "end": [332, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_sdiff_sub", "code": "theorem weightedVSub_sdiff_sub [DecidableEq \u03b9] {s\u2082 : Finset \u03b9} (h : s\u2082 \u2286 s) (w : \u03b9 \u2192 k)\n    (p : \u03b9 \u2192 P) : (s \\ s\u2082).weightedVSub p w - s\u2082.weightedVSub p (-w) = s.weightedVSub p w", "start": [335, 1], "end": [338, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_subtype_eq_filter", "code": "theorem weightedVSub_subtype_eq_filter (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (pred : \u03b9 \u2192 Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).weightedVSub (fun i => p i) fun i => w i) =\n      (s.filter pred).weightedVSub p w", "start": [341, 1], "end": [346, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_filter_of_ne", "code": "theorem weightedVSub_filter_of_ne (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {pred : \u03b9 \u2192 Prop} [DecidablePred pred]\n    (h : \u2200 i \u2208 s, w i \u2260 0 \u2192 pred i) : (s.filter pred).weightedVSub p w = s.weightedVSub p w", "start": [349, 1], "end": [353, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_const_smul", "code": "theorem weightedVSub_const_smul (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (c : k) :\n    s.weightedVSub p (c \u2022 w) = c \u2022 s.weightedVSub p w", "start": [356, 1], "end": [359, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination", "code": "def affineCombination (p : \u03b9 \u2192 P) : (\u03b9 \u2192 k) \u2192\u1d43[k] P\n    where\n  toFun w := s.weightedVSubOfPoint p (Classical.choice S.Nonempty) w +\u1d65 Classical.choice S.Nonempty\n  linear := s.weightedVSub p\n  map_vadd' w\u2081 w\u2082 := by simp_rw [vadd_vadd, weightedVSub, vadd_eq_add, LinearMap.map_add]", "start": [366, 1], "end": [376, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_linear", "code": "@[simp]\ntheorem affineCombination_linear (p : \u03b9 \u2192 P) :\n    (s.affineCombination k p).linear = s.weightedVSub p", "start": [379, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_apply", "code": "theorem affineCombination_apply (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    (s.affineCombination k p) w =\n      s.weightedVSubOfPoint p (Classical.choice S.Nonempty) w +\u1d65 Classical.choice S.Nonempty", "start": [389, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_apply_const", "code": "@[simp]\ntheorem affineCombination_apply_const (w : \u03b9 \u2192 k) (p : P) (h : \u2211 i in s, w i = 1) :\n    s.affineCombination k (fun _ => p) w = p", "start": [402, 1], "end": [406, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_congr", "code": "theorem affineCombination_congr {w\u2081 w\u2082 : \u03b9 \u2192 k} (hw : \u2200 i \u2208 s, w\u2081 i = w\u2082 i) {p\u2081 p\u2082 : \u03b9 \u2192 P}\n    (hp : \u2200 i \u2208 s, p\u2081 i = p\u2082 i) : s.affineCombination k p\u2081 w\u2081 = s.affineCombination k p\u2082 w\u2082", "start": [409, 1], "end": [413, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one", "code": "theorem affineCombination_eq_weightedVSubOfPoint_vadd_of_sum_eq_one (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P)\n    (h : \u2211 i in s, w i = 1) (b : P) :\n    s.affineCombination k p w = s.weightedVSubOfPoint p b w +\u1d65 b", "start": [416, 1], "end": [421, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_vadd_affineCombination", "code": "theorem weightedVSub_vadd_affineCombination (w\u2081 w\u2082 : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    s.weightedVSub p w\u2081 +\u1d65 s.affineCombination k p w\u2082 = s.affineCombination k p (w\u2081 + w\u2082)", "start": [424, 1], "end": [427, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_vsub", "code": "theorem affineCombination_vsub (w\u2081 w\u2082 : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    s.affineCombination k p w\u2081 -\u1d65 s.affineCombination k p w\u2082 = s.weightedVSub p (w\u2081 - w\u2082)", "start": [430, 1], "end": [433, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_affineCombination_of_injective", "code": "theorem attach_affineCombination_of_injective [DecidableEq P] (s : Finset P) (w : P \u2192 k) (f : s \u2192 P)\n    (hf : Function.Injective f) :\n    s.attach.affineCombination k f (w \u2218 f) = (image f univ).affineCombination k id w", "start": [436, 1], "end": [449, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_affineCombination_coe", "code": "theorem attach_affineCombination_coe (s : Finset P) (w : P \u2192 k) :\n    s.attach.affineCombination k ((\u2191) : s \u2192 P) (w \u2218 (\u2191)) = s.affineCombination k id w", "start": [452, 1], "end": [455, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_eq_linear_combination", "code": "@[simp]\ntheorem weightedVSub_eq_linear_combination {\u03b9} (s : Finset \u03b9) {w : \u03b9 \u2192 k} {p : \u03b9 \u2192 V}\n    (hw : s.sum w = 0) : s.weightedVSub p w = \u2211 i in s, w i \u2022 p i", "start": [458, 1], "end": [463, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_eq_linear_combination", "code": "@[simp]\ntheorem affineCombination_eq_linear_combination (s : Finset \u03b9) (p : \u03b9 \u2192 V) (w : \u03b9 \u2192 k)\n    (hw : \u2211 i in s, w i = 1) : s.affineCombination k p w = \u2211 i in s, w i \u2022 p i", "start": [466, 1], "end": [471, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_of_eq_one_of_eq_zero", "code": "@[simp]\ntheorem affineCombination_of_eq_one_of_eq_zero (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {i : \u03b9} (his : i \u2208 s)\n    (hwi : w i = 1) (hw0 : \u2200 i2 \u2208 s, i2 \u2260 i \u2192 w i2 = 0) : s.affineCombination k p w = p i", "start": [474, 1], "end": [487, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_indicator_subset", "code": "theorem affineCombination_indicator_subset (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {s\u2081 s\u2082 : Finset \u03b9}\n    (h : s\u2081 \u2286 s\u2082) :\n    s\u2081.affineCombination k p w = s\u2082.affineCombination k p (Set.indicator (\u2191s\u2081) w)", "start": [490, 1], "end": [496, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_map", "code": "theorem affineCombination_map (e : \u03b9\u2082 \u21aa \u03b9) (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) :\n    (s\u2082.map e).affineCombination k p w = s\u2082.affineCombination k (p \u2218 e) (w \u2218 e)", "start": [499, 1], "end": [504, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_eq_affineCombination_vsub", "code": "theorem sum_smul_vsub_eq_affineCombination_vsub (w : \u03b9 \u2192 k) (p\u2081 p\u2082 : \u03b9 \u2192 P) :\n    (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082 i)) =\n      s.affineCombination k p\u2081 w -\u1d65 s.affineCombination k p\u2082 w", "start": [507, 1], "end": [513, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_vsub_const_eq_affineCombination_vsub", "code": "theorem sum_smul_vsub_const_eq_affineCombination_vsub (w : \u03b9 \u2192 k) (p\u2081 : \u03b9 \u2192 P) (p\u2082 : P)\n    (h : \u2211 i in s, w i = 1) : (\u2211 i in s, w i \u2022 (p\u2081 i -\u1d65 p\u2082)) = s.affineCombination k p\u2081 w -\u1d65 p\u2082", "start": [516, 1], "end": [520, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_const_vsub_eq_vsub_affineCombination", "code": "theorem sum_smul_const_vsub_eq_vsub_affineCombination (w : \u03b9 \u2192 k) (p\u2082 : \u03b9 \u2192 P) (p\u2081 : P)\n    (h : \u2211 i in s, w i = 1) : (\u2211 i in s, w i \u2022 (p\u2081 -\u1d65 p\u2082 i)) = p\u2081 -\u1d65 s.affineCombination k p\u2082 w", "start": [523, 1], "end": [527, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_sdiff_sub", "code": "theorem affineCombination_sdiff_sub [DecidableEq \u03b9] {s\u2082 : Finset \u03b9} (h : s\u2082 \u2286 s) (w : \u03b9 \u2192 k)\n    (p : \u03b9 \u2192 P) :\n    (s \\ s\u2082).affineCombination k p w -\u1d65 s\u2082.affineCombination k p (-w) = s.weightedVSub p w", "start": [530, 1], "end": [535, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one", "code": "theorem affineCombination_eq_of_weightedVSub_eq_zero_of_eq_neg_one {w : \u03b9 \u2192 k} {p : \u03b9 \u2192 P}\n    (hw : s.weightedVSub p w = (0 : V)) {i : \u03b9} [DecidablePred (\u00b7 \u2260 i)] (his : i \u2208 s)\n    (hwi : w i = -1) : (s.filter (\u00b7 \u2260 i)).affineCombination k p w = p i", "start": [538, 1], "end": [550, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_subtype_eq_filter", "code": "theorem affineCombination_subtype_eq_filter (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (pred : \u03b9 \u2192 Prop)\n    [DecidablePred pred] :\n    ((s.subtype pred).affineCombination k (fun i => p i) fun i => w i) =\n      (s.filter pred).affineCombination k p w", "start": [553, 1], "end": [558, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_filter_of_ne", "code": "theorem affineCombination_filter_of_ne (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) {pred : \u03b9 \u2192 Prop}\n    [DecidablePred pred] (h : \u2200 i \u2208 s, w i \u2260 0 \u2192 pred i) :\n    (s.filter pred).affineCombination k p w = s.affineCombination k p w", "start": [561, 1], "end": [567, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype", "code": "theorem eq_weightedVSubOfPoint_subset_iff_eq_weightedVSubOfPoint_subtype {v : V} {x : k} {s : Set \u03b9}\n    {p : \u03b9 \u2192 P} {b : P} :\n    (\u2203 (fs : Finset \u03b9) (_ : \u2191fs \u2286 s) (w : \u03b9 \u2192 k) (_ : \u2211 i in fs, w i = x),\n        v = fs.weightedVSubOfPoint p b w) \u2194\n      \u2203 (fs : Finset s) (w : s \u2192 k) (_ : \u2211 i in fs, w i = x),\n        v = fs.weightedVSubOfPoint (fun i : s => p i) b w", "start": [570, 1], "end": [592, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_weightedVSub_subset_iff_eq_weightedVSub_subtype", "code": "theorem eq_weightedVSub_subset_iff_eq_weightedVSub_subtype {v : V} {s : Set \u03b9} {p : \u03b9 \u2192 P} :\n    (\u2203 (fs : Finset \u03b9) (_ : \u2191fs \u2286 s) (w : \u03b9 \u2192 k) (_ : \u2211 i in fs, w i = 0),\n        v = fs.weightedVSub p w) \u2194\n      \u2203 (fs : Finset s) (w : s \u2192 k) (_ : \u2211 i in fs, w i = 0),\n        v = fs.weightedVSub (fun i : s => p i) w", "start": [597, 1], "end": [608, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_affineCombination_subset_iff_eq_affineCombination_subtype", "code": "theorem eq_affineCombination_subset_iff_eq_affineCombination_subtype {p0 : P} {s : Set \u03b9}\n    {p : \u03b9 \u2192 P} :\n    (\u2203 (fs : Finset \u03b9) (_ : \u2191fs \u2286 s) (w : \u03b9 \u2192 k) (_ : \u2211 i in fs, w i = 1),\n        p0 = fs.affineCombination k p w) \u2194\n      \u2203 (fs : Finset s) (w : s \u2192 k) (_ : \u2211 i in fs, w i = 1),\n        p0 = fs.affineCombination k (fun i : s => p i) w", "start": [613, 1], "end": [627, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.map_affineCombination", "code": "theorem map_affineCombination {V\u2082 P\u2082 : Type*} [AddCommGroup V\u2082] [Module k V\u2082] [AffineSpace V\u2082 P\u2082]\n    (p : \u03b9 \u2192 P) (w : \u03b9 \u2192 k) (hw : s.sum w = 1) (f : P \u2192\u1d43[k] P\u2082) :\n    f (s.affineCombination k p w) = s.affineCombination k (f \u2218 p) w", "start": [632, 1], "end": [642, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationSingleWeights", "code": "def affineCombinationSingleWeights [DecidableEq \u03b9] (i : \u03b9) : \u03b9 \u2192 k :=\n  Function.update (Function.const \u03b9 0) i 1", "start": [647, 1], "end": [649, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationSingleWeights_apply_self", "code": "@[simp]\ntheorem affineCombinationSingleWeights_apply_self [DecidableEq \u03b9] (i : \u03b9) :\n    affineCombinationSingleWeights k i i = 1", "start": [652, 1], "end": [654, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationSingleWeights_apply_of_ne", "code": "@[simp]\ntheorem affineCombinationSingleWeights_apply_of_ne [DecidableEq \u03b9] {i j : \u03b9} (h : j \u2260 i) :\n    affineCombinationSingleWeights k i j = 0", "start": [657, 1], "end": [659, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_affineCombinationSingleWeights", "code": "@[simp]\ntheorem sum_affineCombinationSingleWeights [DecidableEq \u03b9] {i : \u03b9} (h : i \u2208 s) :\n    \u2211 j in s, affineCombinationSingleWeights k i j = 1", "start": [662, 1], "end": [666, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubVSubWeights", "code": "def weightedVSubVSubWeights [DecidableEq \u03b9] (i j : \u03b9) : \u03b9 \u2192 k :=\n  affineCombinationSingleWeights k i - affineCombinationSingleWeights k j", "start": [669, 1], "end": [671, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubVSubWeights_self", "code": "@[simp]\ntheorem weightedVSubVSubWeights_self [DecidableEq \u03b9] (i : \u03b9) : weightedVSubVSubWeights k i i = 0", "start": [674, 1], "end": [676, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubVSubWeights_apply_left", "code": "@[simp]\ntheorem weightedVSubVSubWeights_apply_left [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) :\n    weightedVSubVSubWeights k i j i = 1", "start": [679, 1], "end": [681, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubVSubWeights_apply_right", "code": "@[simp]\ntheorem weightedVSubVSubWeights_apply_right [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) :\n    weightedVSubVSubWeights k i j j = -1", "start": [684, 1], "end": [686, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSubVSubWeights_apply_of_ne", "code": "@[simp]\ntheorem weightedVSubVSubWeights_apply_of_ne [DecidableEq \u03b9] {i j t : \u03b9} (hi : t \u2260 i) (hj : t \u2260 j) :\n    weightedVSubVSubWeights k i j t = 0", "start": [689, 1], "end": [691, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_weightedVSubVSubWeights", "code": "@[simp]\ntheorem sum_weightedVSubVSubWeights [DecidableEq \u03b9] {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s) :\n    \u2211 t in s, weightedVSubVSubWeights k i j t = 0", "start": [694, 1], "end": [698, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationLineMapWeights", "code": "def affineCombinationLineMapWeights [DecidableEq \u03b9] (i j : \u03b9) (c : k) : \u03b9 \u2192 k :=\n  c \u2022 weightedVSubVSubWeights k j i + affineCombinationSingleWeights k i", "start": [703, 1], "end": [705, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationLineMapWeights_self", "code": "@[simp]\ntheorem affineCombinationLineMapWeights_self [DecidableEq \u03b9] (i : \u03b9) (c : k) :\n    affineCombinationLineMapWeights i i c = affineCombinationSingleWeights k i", "start": [708, 1], "end": [711, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationLineMapWeights_apply_left", "code": "@[simp]\ntheorem affineCombinationLineMapWeights_apply_left [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) (c : k) :\n    affineCombinationLineMapWeights i j c i = 1 - c", "start": [714, 1], "end": [717, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationLineMapWeights_apply_right", "code": "@[simp]\ntheorem affineCombinationLineMapWeights_apply_right [DecidableEq \u03b9] {i j : \u03b9} (h : i \u2260 j) (c : k) :\n    affineCombinationLineMapWeights i j c j = c", "start": [720, 1], "end": [723, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombinationLineMapWeights_apply_of_ne", "code": "@[simp]\ntheorem affineCombinationLineMapWeights_apply_of_ne [DecidableEq \u03b9] {i j t : \u03b9} (hi : t \u2260 i)\n    (hj : t \u2260 j) (c : k) : affineCombinationLineMapWeights i j c t = 0", "start": [726, 1], "end": [729, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_affineCombinationLineMapWeights", "code": "@[simp]\ntheorem sum_affineCombinationLineMapWeights [DecidableEq \u03b9] {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s)\n    (c : k) : \u2211 t in s, affineCombinationLineMapWeights i j c t = 1", "start": [732, 1], "end": [736, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_affineCombinationSingleWeights", "code": "@[simp]\ntheorem affineCombination_affineCombinationSingleWeights [DecidableEq \u03b9] (p : \u03b9 \u2192 P) {i : \u03b9}\n    (hi : i \u2208 s) : s.affineCombination k p (affineCombinationSingleWeights k i) = p i", "start": [741, 1], "end": [747, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.weightedVSub_weightedVSubVSubWeights", "code": "@[simp]\ntheorem weightedVSub_weightedVSubVSubWeights [DecidableEq \u03b9] (p : \u03b9 \u2192 P) {i j : \u03b9} (hi : i \u2208 s)\n    (hj : j \u2208 s) : s.weightedVSub p (weightedVSubVSubWeights k i j) = p i -\u1d65 p j", "start": [750, 1], "end": [757, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.affineCombination_affineCombinationLineMapWeights", "code": "@[simp]\ntheorem affineCombination_affineCombinationLineMapWeights [DecidableEq \u03b9] (p : \u03b9 \u2192 P) {i j : \u03b9}\n    (hi : i \u2208 s) (hj : j \u2208 s) (c : k) :\n    s.affineCombination k p (affineCombinationLineMapWeights i j c) =\n      AffineMap.lineMap (p i) (p j) c", "start": [762, 1], "end": [771, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.centroidWeights", "code": "def centroidWeights : \u03b9 \u2192 k :=\n  Function.const \u03b9 (card s : k)\u207b\u00b9", "start": [782, 1], "end": [784, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.centroidWeights_apply", "code": "@[simp]\ntheorem centroidWeights_apply (i : \u03b9) : s.centroidWeights k i = (card s : k)\u207b\u00b9", "start": [787, 1], "end": [790, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.centroidWeights_eq_const", "code": "theorem centroidWeights_eq_const : s.centroidWeights k = Function.const \u03b9 (card s : k)\u207b\u00b9", "start": [793, 1], "end": [795, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeights_eq_one_of_cast_card_ne_zero", "code": "theorem sum_centroidWeights_eq_one_of_cast_card_ne_zero (h : (card s : k) \u2260 0) :\n    \u2211 i in s, s.centroidWeights k i = 1", "start": [800, 1], "end": [803, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeights_eq_one_of_card_ne_zero", "code": "theorem sum_centroidWeights_eq_one_of_card_ne_zero [CharZero k] (h : card s \u2260 0) :\n    \u2211 i in s, s.centroidWeights k i = 1", "start": [808, 1], "end": [815, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeights_eq_one_of_nonempty", "code": "theorem sum_centroidWeights_eq_one_of_nonempty [CharZero k] (h : s.Nonempty) :\n    \u2211 i in s, s.centroidWeights k i = 1", "start": [818, 1], "end": [822, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeights_eq_one_of_card_eq_add_one", "code": "theorem sum_centroidWeights_eq_one_of_card_eq_add_one [CharZero k] {n : \u2115} (h : card s = n + 1) :\n    \u2211 i in s, s.centroidWeights k i = 1", "start": [825, 1], "end": [829, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid", "code": "def centroid (p : \u03b9 \u2192 P) : P :=\n  s.affineCombination k p (s.centroidWeights k)", "start": [832, 1], "end": [836, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_def", "code": "theorem centroid_def (p : \u03b9 \u2192 P) : s.centroid k p = s.affineCombination k p (s.centroidWeights k)", "start": [839, 1], "end": [841, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_univ", "code": "theorem centroid_univ (s : Finset P) : univ.centroid k ((\u2191) : s \u2192 P) = s.centroid k id", "start": [844, 1], "end": [848, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_singleton", "code": "@[simp]\ntheorem centroid_singleton (p : \u03b9 \u2192 P) (i : \u03b9) : ({i} : Finset \u03b9).centroid k p = p i", "start": [851, 1], "end": [854, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_pair", "code": "theorem centroid_pair [DecidableEq \u03b9] [Invertible (2 : k)] (p : \u03b9 \u2192 P) (i\u2081 i\u2082 : \u03b9) :\n    ({i\u2081, i\u2082} : Finset \u03b9).centroid k p = (2\u207b\u00b9 : k) \u2022 (p i\u2082 -\u1d65 p i\u2081) +\u1d65 p i\u2081", "start": [857, 1], "end": [870, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_pair_fin", "code": "theorem centroid_pair_fin [Invertible (2 : k)] (p : Fin 2 \u2192 P) :\n    univ.centroid k p = (2\u207b\u00b9 : k) \u2022 (p 1 -\u1d65 p 0) +\u1d65 p 0", "start": [873, 1], "end": [878, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_map", "code": "theorem centroid_map (e : \u03b9\u2082 \u21aa \u03b9) (p : \u03b9 \u2192 P) : (s\u2082.map e).centroid k p = s\u2082.centroid k (p \u2218 e)", "start": [881, 1], "end": [884, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.centroidWeightsIndicator", "code": "def centroidWeightsIndicator : \u03b9 \u2192 k :=\n  Set.indicator (\u2191s) (s.centroidWeights k)", "start": [887, 1], "end": [894, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.centroidWeightsIndicator_def", "code": "theorem centroidWeightsIndicator_def :\n    s.centroidWeightsIndicator k = Set.indicator (\u2191s) (s.centroidWeights k)", "start": [897, 1], "end": [900, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeightsIndicator", "code": "theorem sum_centroidWeightsIndicator [Fintype \u03b9] :\n    \u2211 i, s.centroidWeightsIndicator k i = \u2211 i in s, s.centroidWeights k i", "start": [903, 1], "end": [906, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeightsIndicator_eq_one_of_card_ne_zero", "code": "theorem sum_centroidWeightsIndicator_eq_one_of_card_ne_zero [CharZero k] [Fintype \u03b9]\n    (h : card s \u2260 0) : \u2211 i, s.centroidWeightsIndicator k i = 1", "start": [909, 1], "end": [915, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeightsIndicator_eq_one_of_nonempty", "code": "theorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype \u03b9] (h : s.Nonempty) :\n    \u2211 i, s.centroidWeightsIndicator k i = 1", "start": [918, 1], "end": [923, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one", "code": "theorem sum_centroidWeightsIndicator_eq_one_of_card_eq_add_one [CharZero k] [Fintype \u03b9] {n : \u2115}\n    (h : card s = n + 1) : \u2211 i, s.centroidWeightsIndicator k i = 1", "start": [926, 1], "end": [931, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_eq_affineCombination_fintype", "code": "theorem centroid_eq_affineCombination_fintype [Fintype \u03b9] (p : \u03b9 \u2192 P) :\n    s.centroid k p = univ.affineCombination k p (s.centroidWeightsIndicator k)", "start": [934, 1], "end": [937, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_eq_centroid_image_of_inj_on", "code": "theorem centroid_eq_centroid_image_of_inj_on {p : \u03b9 \u2192 P}\n    (hi : \u2200 (i) (_ : i \u2208 s) (j) (_ : j \u2208 s), p i = p j \u2192 i = j) {ps : Set P} [Fintype ps]\n    (hps : ps = p '' \u2191s) : s.centroid k p = (univ : Finset ps).centroid k fun x => (x : P)", "start": [940, 1], "end": [969, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.centroid_eq_of_inj_on_of_image_eq", "code": "theorem centroid_eq_of_inj_on_of_image_eq {p : \u03b9 \u2192 P}\n    (hi : \u2200 (i) (_ : i \u2208 s) (j) (_ : j \u2208 s), p i = p j \u2192 i = j) {p\u2082 : \u03b9\u2082 \u2192 P}\n    (hi\u2082 : \u2200 (i) (_ : i \u2208 s\u2082) (j) (_ : j \u2208 s\u2082), p\u2082 i = p\u2082 j \u2192 i = j) (he : p '' \u2191s = p\u2082 '' \u2191s\u2082) :\n    s.centroid k p = s\u2082.centroid k p\u2082", "start": [972, 1], "end": [980, 56], "kind": "commanddeclaration"}, {"full_name": "weightedVSub_mem_vectorSpan", "code": "theorem weightedVSub_mem_vectorSpan {s : Finset \u03b9} {w : \u03b9 \u2192 k} (h : \u2211 i in s, w i = 0)\n    (p : \u03b9 \u2192 P) : s.weightedVSub p w \u2208 vectorSpan k (Set.range p)", "start": [989, 1], "end": [1007, 37], "kind": "commanddeclaration"}, {"full_name": "affineCombination_mem_affineSpan", "code": "theorem affineCombination_mem_affineSpan [Nontrivial k] {s : Finset \u03b9} {w : \u03b9 \u2192 k}\n    (h : \u2211 i in s, w i = 1) (p : \u03b9 \u2192 P) :\n    s.affineCombination k p w \u2208 affineSpan k (Set.range p)", "start": [1010, 1], "end": [1035, 96], "kind": "commanddeclaration"}, {"full_name": "mem_vectorSpan_iff_eq_weightedVSub", "code": "theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : \u03b9 \u2192 P} :\n    v \u2208 vectorSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k) (_ : \u2211 i in s, w i = 0), v = s.weightedVSub p w", "start": [1040, 1], "end": [1080, 45], "kind": "commanddeclaration"}, {"full_name": "eq_affineCombination_of_mem_affineSpan", "code": "theorem eq_affineCombination_of_mem_affineSpan {p1 : P} {p : \u03b9 \u2192 P}\n    (h : p1 \u2208 affineSpan k (Set.range p)) :\n    \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k) (_ : \u2211 i in s, w i = 1), p1 = s.affineCombination k p w", "start": [1085, 1], "end": [1120, 60], "kind": "commanddeclaration"}, {"full_name": "eq_affineCombination_of_mem_affineSpan_of_fintype", "code": "theorem eq_affineCombination_of_mem_affineSpan_of_fintype [Fintype \u03b9] {p1 : P} {p : \u03b9 \u2192 P}\n    (h : p1 \u2208 affineSpan k (Set.range p)) :\n    \u2203 (w : \u03b9 \u2192 k) (_ : \u2211 i, w i = 1), p1 = Finset.univ.affineCombination k p w", "start": [1123, 1], "end": [1131, 40], "kind": "commanddeclaration"}, {"full_name": "mem_affineSpan_iff_eq_affineCombination", "code": "theorem mem_affineSpan_iff_eq_affineCombination [Nontrivial k] {p1 : P} {p : \u03b9 \u2192 P} :\n    p1 \u2208 affineSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k) (_ : \u2211 i in s, w i = 1), p1 = s.affineCombination k p w", "start": [1136, 1], "end": [1145, 48], "kind": "commanddeclaration"}, {"full_name": "mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd", "code": "theorem mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd [Nontrivial k] (p : \u03b9 \u2192 P) (j : \u03b9) (q : P) :\n    q \u2208 affineSpan k (Set.range p) \u2194\n      \u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k), q = s.weightedVSubOfPoint p (p j) w +\u1d65 p j", "start": [1148, 1], "end": [1171, 50], "kind": "commanddeclaration"}, {"full_name": "affineSpan_eq_affineSpan_lineMap_units", "code": "theorem affineSpan_eq_affineSpan_lineMap_units [Nontrivial k] {s : Set P} {p : P} (hp : p \u2208 s)\n    (w : s \u2192 Units k) :\n    affineSpan k (Set.range fun q : s => AffineMap.lineMap p \u2191q (w q : k)) = affineSpan k s", "start": [1176, 1], "end": [1192, 25], "kind": "commanddeclaration"}, {"full_name": "centroid_mem_affineSpan_of_cast_card_ne_zero", "code": "theorem centroid_mem_affineSpan_of_cast_card_ne_zero {s : Finset \u03b9} (p : \u03b9 \u2192 P)\n    (h : (card s : k) \u2260 0) : s.centroid k p \u2208 affineSpan k (range p)", "start": [1205, 1], "end": [1209, 91], "kind": "commanddeclaration"}, {"full_name": "centroid_mem_affineSpan_of_card_ne_zero", "code": "theorem centroid_mem_affineSpan_of_card_ne_zero [CharZero k] {s : Finset \u03b9} (p : \u03b9 \u2192 P)\n    (h : card s \u2260 0) : s.centroid k p \u2208 affineSpan k (range p)", "start": [1214, 1], "end": [1218, 88], "kind": "commanddeclaration"}, {"full_name": "centroid_mem_affineSpan_of_nonempty", "code": "theorem centroid_mem_affineSpan_of_nonempty [CharZero k] {s : Finset \u03b9} (p : \u03b9 \u2192 P)\n    (h : s.Nonempty) : s.centroid k p \u2208 affineSpan k (range p)", "start": [1221, 1], "end": [1225, 84], "kind": "commanddeclaration"}, {"full_name": "centroid_mem_affineSpan_of_card_eq_add_one", "code": "theorem centroid_mem_affineSpan_of_card_eq_add_one [CharZero k] {s : Finset \u03b9} (p : \u03b9 \u2192 P) {n : \u2115}\n    (h : card s = n + 1) : s.centroid k p \u2208 affineSpan k (range p)", "start": [1228, 1], "end": [1232, 91], "kind": "commanddeclaration"}, {"full_name": "AffineMap.weightedVSubOfPoint", "code": "def weightedVSubOfPoint (w : \u03b9 \u2192 k) : (\u03b9 \u2192 P) \u00d7 P \u2192\u1d43[k] V where\n  toFun p := s.weightedVSubOfPoint p.fst p.snd w\n  linear := \u2211 i in s, w i \u2022 ((LinearMap.proj i).comp (LinearMap.fst _ _ _) - LinearMap.snd _ _ _)\n  map_vadd' := by\n    rintro \u27e8p, b\u27e9 \u27e8v, b'\u27e9\n    simp [LinearMap.sum_apply, Finset.weightedVSubOfPoint, vsub_vadd_eq_vsub_sub,\n     vadd_vsub_assoc,\n     add_sub, \u2190 sub_add_eq_add_sub, smul_add, Finset.sum_add_distrib, Prod.mk_vadd_mk v]", "start": [1244, 1], "end": [1253, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "imports": ["Mathlib/Topology/Instances/NNReal.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "cauchySeq_finset_iff_vanishing_norm", "code": "theorem cauchySeq_finset_iff_vanishing_norm {f : \u03b9 \u2192 E} :\n    (CauchySeq fun s : Finset \u03b9 => \u2211 i in s, f i) \u2194\n      \u2200 \u03b5 > (0 : \u211d), \u2203 s : Finset \u03b9, \u2200 t, Disjoint t s \u2192 \u2016\u2211 i in t, f i\u2016 < \u03b5", "start": [40, 1], "end": [46, 47], "kind": "commanddeclaration"}, {"full_name": "summable_iff_vanishing_norm", "code": "theorem summable_iff_vanishing_norm [CompleteSpace E] {f : \u03b9 \u2192 E} :\n    Summable f \u2194 \u2200 \u03b5 > (0 : \u211d), \u2203 s : Finset \u03b9, \u2200 t, Disjoint t s \u2192 \u2016\u2211 i in t, f i\u2016 < \u03b5", "start": [49, 1], "end": [51, 74], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_finset_of_norm_bounded_eventually", "code": "theorem cauchySeq_finset_of_norm_bounded_eventually {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d} (hg : Summable g)\n    (h : \u2200\u1da0 i in cofinite, \u2016f i\u2016 \u2264 g i) : CauchySeq fun s => \u2211 i in s, f i", "start": [54, 1], "end": [67, 46], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_finset_of_norm_bounded", "code": "theorem cauchySeq_finset_of_norm_bounded {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d) (hg : Summable g)\n    (h : \u2200 i, \u2016f i\u2016 \u2264 g i) : CauchySeq fun s : Finset \u03b9 => \u2211 i in s, f i", "start": [70, 1], "end": [72, 75], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_range_of_norm_bounded", "code": "theorem cauchySeq_range_of_norm_bounded {f : \u2115 \u2192 E} (g : \u2115 \u2192 \u211d)\n    (hg : CauchySeq fun n => \u2211 i in range n, g i) (hf : \u2200 i, \u2016f i\u2016 \u2264 g i) :\n    CauchySeq fun n => \u2211 i in range n, f i", "start": [75, 1], "end": [88, 16], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_finset_of_summable_norm", "code": "theorem cauchySeq_finset_of_summable_norm {f : \u03b9 \u2192 E} (hf : Summable fun a => \u2016f a\u2016) :\n    CauchySeq fun s : Finset \u03b9 => \u2211 a in s, f a", "start": [91, 1], "end": [93, 57], "kind": "commanddeclaration"}, {"full_name": "hasSum_of_subseq_of_summable", "code": "theorem hasSum_of_subseq_of_summable {f : \u03b9 \u2192 E} (hf : Summable fun a => \u2016f a\u2016) {s : \u03b1 \u2192 Finset \u03b9}\n    {p : Filter \u03b1} [NeBot p] (hs : Tendsto s p atTop) {a : E}\n    (ha : Tendsto (fun b => \u2211 i in s b, f i) p (\ud835\udcdd a)) : HasSum f a", "start": [96, 1], "end": [102, 83], "kind": "commanddeclaration"}, {"full_name": "hasSum_iff_tendsto_nat_of_summable_norm", "code": "theorem hasSum_iff_tendsto_nat_of_summable_norm {f : \u2115 \u2192 E} {a : E} (hf : Summable fun i => \u2016f i\u2016) :\n    HasSum f a \u2194 Tendsto (fun n : \u2115 => \u2211 i in range n, f i) atTop (\ud835\udcdd a)", "start": [105, 1], "end": [107, 96], "kind": "commanddeclaration"}, {"full_name": "summable_of_norm_bounded", "code": "theorem summable_of_norm_bounded [CompleteSpace E] {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d) (hg : Summable g)\n    (h : \u2200 i, \u2016f i\u2016 \u2264 g i) : Summable f", "start": [110, 1], "end": [115, 48], "kind": "commanddeclaration"}, {"full_name": "HasSum.norm_le_of_bounded", "code": "theorem HasSum.norm_le_of_bounded {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d} {a : E} {b : \u211d} (hf : HasSum f a)\n    (hg : HasSum g b) (h : \u2200 i, \u2016f i\u2016 \u2264 g i) : \u2016a\u2016 \u2264 b", "start": [118, 1], "end": [120, 86], "kind": "commanddeclaration"}, {"full_name": "tsum_of_norm_bounded", "code": "theorem tsum_of_norm_bounded {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d} {a : \u211d} (hg : HasSum g a)\n    (h : \u2200 i, \u2016f i\u2016 \u2264 g i) : \u2016\u2211' i : \u03b9, f i\u2016 \u2264 a", "start": [123, 1], "end": [131, 89], "kind": "commanddeclaration"}, {"full_name": "norm_tsum_le_tsum_norm", "code": "theorem norm_tsum_le_tsum_norm {f : \u03b9 \u2192 E} (hf : Summable fun i => \u2016f i\u2016) :\n    \u2016\u2211' i, f i\u2016 \u2264 \u2211' i, \u2016f i\u2016", "start": [134, 1], "end": [138, 50], "kind": "commanddeclaration"}, {"full_name": "tsum_of_nnnorm_bounded", "code": "theorem tsum_of_nnnorm_bounded {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d\u22650} {a : \u211d\u22650} (hg : HasSum g a)\n    (h : \u2200 i, \u2016f i\u2016\u208a \u2264 g i) : \u2016\u2211' i : \u03b9, f i\u2016\u208a \u2264 a", "start": [141, 1], "end": [148, 34], "kind": "commanddeclaration"}, {"full_name": "nnnorm_tsum_le", "code": "theorem nnnorm_tsum_le {f : \u03b9 \u2192 E} (hf : Summable fun i => \u2016f i\u2016\u208a) : \u2016\u2211' i, f i\u2016\u208a \u2264 \u2211' i, \u2016f i\u2016\u208a", "start": [151, 1], "end": [155, 52], "kind": "commanddeclaration"}, {"full_name": "summable_of_norm_bounded_eventually", "code": "theorem summable_of_norm_bounded_eventually {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d) (hg : Summable g)\n    (h : \u2200\u1da0 i in cofinite, \u2016f i\u2016 \u2264 g i) : Summable f", "start": [160, 1], "end": [164, 86], "kind": "commanddeclaration"}, {"full_name": "summable_of_nnnorm_bounded", "code": "theorem summable_of_nnnorm_bounded {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d\u22650) (hg : Summable g)\n    (h : \u2200 i, \u2016f i\u2016\u208a \u2264 g i) : Summable f", "start": [167, 1], "end": [170, 23], "kind": "commanddeclaration"}, {"full_name": "summable_of_summable_norm", "code": "theorem summable_of_summable_norm {f : \u03b9 \u2192 E} (hf : Summable fun a => \u2016f a\u2016) : Summable f", "start": [173, 1], "end": [174, 49], "kind": "commanddeclaration"}, {"full_name": "summable_of_summable_nnnorm", "code": "theorem summable_of_summable_nnnorm {f : \u03b9 \u2192 E} (hf : Summable fun a => \u2016f a\u2016\u208a) : Summable f", "start": [177, 1], "end": [178, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/LocalHomeomorph.lean", "imports": ["Mathlib/Logic/Equiv/LocalEquiv.lean", "Mathlib/Topology/Sets/Opens.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocalHomeomorph", "code": "structure LocalHomeomorph (\u03b1 : Type*) (\u03b2 : Type*) [TopologicalSpace \u03b1]\n  [TopologicalSpace \u03b2] extends LocalEquiv \u03b1 \u03b2 where\n  open_source : IsOpen source\n  open_target : IsOpen target\n  continuous_toFun : ContinuousOn toFun source\n  continuous_invFun : ContinuousOn invFun target", "start": [55, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.toFun'", "code": "@[coe] def toFun' : \u03b1 \u2192 \u03b2 := e.toFun", "start": [69, 1], "end": [72, 37], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm", "code": "protected def symm : LocalHomeomorph \u03b2 \u03b1 where\n  toLocalEquiv := e.toLocalEquiv.symm\n  open_source := e.open_target\n  open_target := e.open_source\n  continuous_toFun := e.continuous_invFun\n  continuous_invFun := e.continuous_toFun", "start": [78, 1], "end": [84, 42], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.Simps.apply", "code": "def Simps.apply (e : LocalHomeomorph \u03b1 \u03b2) : \u03b1 \u2192 \u03b2 := e", "start": [87, 1], "end": [89, 55], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.Simps.symm_apply", "code": "def Simps.symm_apply (e : LocalHomeomorph \u03b1 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm", "start": [92, 1], "end": [93, 65], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousOn", "code": "protected theorem continuousOn : ContinuousOn e e.source", "start": [98, 1], "end": [99, 21], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousOn_symm", "code": "theorem continuousOn_symm : ContinuousOn e.symm e.target", "start": [102, 1], "end": [103, 22], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.mk_coe", "code": "@[simp, mfld_simps]\ntheorem mk_coe (e : LocalEquiv \u03b1 \u03b2) (a b c d) : (LocalHomeomorph.mk e a b c d : \u03b1 \u2192 \u03b2) = e", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.mk_coe_symm", "code": "@[simp, mfld_simps]\ntheorem mk_coe_symm (e : LocalEquiv \u03b1 \u03b2) (a b c d) :\n    ((LocalHomeomorph.mk e a b c d).symm : \u03b2 \u2192 \u03b1) = e.symm", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.toLocalEquiv_injective", "code": "theorem toLocalEquiv_injective : Injective (toLocalEquiv : LocalHomeomorph \u03b1 \u03b2 \u2192 LocalEquiv \u03b1 \u03b2)", "start": [117, 1], "end": [118, 49], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.toFun_eq_coe", "code": "@[simp, mfld_simps]\ntheorem toFun_eq_coe (e : LocalHomeomorph \u03b1 \u03b2) : e.toFun = e", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.invFun_eq_coe", "code": "@[simp, mfld_simps]\ntheorem invFun_eq_coe (e : LocalHomeomorph \u03b1 \u03b2) : e.invFun = e.symm", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.coe_coe", "code": "@[simp, mfld_simps]\ntheorem coe_coe : (e.toLocalEquiv : \u03b1 \u2192 \u03b2) = e", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.coe_coe_symm", "code": "@[simp, mfld_simps]\ntheorem coe_coe_symm : (e.toLocalEquiv.symm : \u03b2 \u2192 \u03b1) = e.symm", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_source", "code": "@[simp, mfld_simps]\ntheorem map_source {x : \u03b1} (h : x \u2208 e.source) : e x \u2208 e.target", "start": [143, 1], "end": [145, 18], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_target", "code": "@[simp, mfld_simps]\ntheorem map_target {x : \u03b2} (h : x \u2208 e.target) : e.symm x \u2208 e.source", "start": [148, 1], "end": [150, 18], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.left_inv", "code": "@[simp, mfld_simps]\ntheorem left_inv {x : \u03b1} (h : x \u2208 e.source) : e.symm (e x) = x", "start": [153, 1], "end": [155, 16], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.right_inv", "code": "@[simp, mfld_simps]\ntheorem right_inv {x : \u03b2} (h : x \u2208 e.target) : e (e.symm x) = x", "start": [158, 1], "end": [160, 17], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eq_symm_apply", "code": "theorem eq_symm_apply {x : \u03b1} {y : \u03b2} (hx : x \u2208 e.source) (hy : y \u2208 e.target) :\n    x = e.symm y \u2194 e x = y", "start": [163, 1], "end": [165, 37], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.mapsTo", "code": "protected theorem mapsTo : MapsTo e e.source e.target", "start": [168, 1], "end": [168, 79], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_mapsTo", "code": "protected theorem symm_mapsTo : MapsTo e.symm e.target e.source", "start": [171, 1], "end": [172, 16], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.leftInvOn", "code": "protected theorem leftInvOn : LeftInvOn e.symm e e.source", "start": [175, 1], "end": [175, 81], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.rightInvOn", "code": "protected theorem rightInvOn : RightInvOn e.symm e e.target", "start": [178, 1], "end": [178, 84], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.invOn", "code": "protected theorem invOn : InvOn e.symm e e.source e.target", "start": [181, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.injOn", "code": "protected theorem injOn : InjOn e e.source", "start": [185, 1], "end": [186, 20], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.bijOn", "code": "protected theorem bijOn : BijOn e e.source e.target", "start": [189, 1], "end": [190, 39], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.surjOn", "code": "protected theorem surjOn : SurjOn e e.source e.target", "start": [193, 1], "end": [194, 17], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toLocalHomeomorphOfImageEq", "code": "@[simps! (config := .asFn) apply symm_apply toLocalEquiv,\n  simps! (config := .lemmasOnly) source target]\ndef _root_.Homeomorph.toLocalHomeomorphOfImageEq (e : \u03b1 \u2243\u209c \u03b2) (s : Set \u03b1) (hs : IsOpen s)\n    (t : Set \u03b2) (h : e '' s = t) : LocalHomeomorph \u03b1 \u03b2 where\n  toLocalEquiv := e.toLocalEquivOfImageEq s t h\n  open_source := hs\n  open_target := by simpa [\u2190 h]\n  continuous_toFun := e.continuous.continuousOn\n  continuous_invFun := e.symm.continuous.continuousOn", "start": [197, 1], "end": [207, 54], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toLocalHomeomorph", "code": "@[simps! (config := mfld_cfg)]\ndef _root_.Homeomorph.toLocalHomeomorph (e : \u03b1 \u2243\u209c \u03b2) : LocalHomeomorph \u03b1 \u03b2 :=\n  e.toLocalHomeomorphOfImageEq univ isOpen_univ univ <| by rw [image_univ, e.surjective.range_eq]", "start": [209, 1], "end": [212, 98], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.replaceEquiv", "code": "def replaceEquiv (e : LocalHomeomorph \u03b1 \u03b2) (e' : LocalEquiv \u03b1 \u03b2) (h : e.toLocalEquiv = e') :\n    LocalHomeomorph \u03b1 \u03b2 where\n  toLocalEquiv := e'\n  open_source := h \u25b8 e.open_source\n  open_target := h \u25b8 e.open_target\n  continuous_toFun := h \u25b8 e.continuous_toFun\n  continuous_invFun := h \u25b8 e.continuous_invFun", "start": [215, 1], "end": [222, 47], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.replaceEquiv_eq_self", "code": "theorem replaceEquiv_eq_self (e : LocalHomeomorph \u03b1 \u03b2) (e' : LocalEquiv \u03b1 \u03b2)\n    (h : e.toLocalEquiv = e') : e.replaceEquiv e' h = e", "start": [225, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.source_preimage_target", "code": "theorem source_preimage_target : e.source \u2286 e \u207b\u00b9' e.target", "start": [232, 1], "end": [233, 11], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eq_of_localEquiv_eq", "code": "@[deprecated toLocalEquiv_injective]\ntheorem eq_of_localEquiv_eq {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e.toLocalEquiv = e'.toLocalEquiv) :\n    e = e'", "start": [236, 1], "end": [238, 39], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_left_inverse", "code": "theorem eventually_left_inverse (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) :\n    \u2200\u1da0 y in \ud835\udcdd x, e.symm (e y) = y", "start": [241, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_left_inverse'", "code": "theorem eventually_left_inverse' (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.target) :\n    \u2200\u1da0 y in \ud835\udcdd (e.symm x), e.symm (e y) = y", "start": [246, 1], "end": [248, 46], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_right_inverse", "code": "theorem eventually_right_inverse (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.target) :\n    \u2200\u1da0 y in \ud835\udcdd x, e (e.symm y) = y", "start": [251, 1], "end": [253, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_right_inverse'", "code": "theorem eventually_right_inverse' (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) :\n    \u2200\u1da0 y in \ud835\udcdd (e x), e (e.symm y) = y", "start": [256, 1], "end": [258, 47], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_ne_nhdsWithin", "code": "theorem eventually_ne_nhdsWithin (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) :\n    \u2200\u1da0 x' in \ud835\udcdd[\u2260] x, e x' \u2260 e x", "start": [261, 1], "end": [265, 71], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.nhdsWithin_source_inter", "code": "theorem nhdsWithin_source_inter {x} (hx : x \u2208 e.source) (s : Set \u03b1) : \ud835\udcdd[e.source \u2229 s] x = \ud835\udcdd[s] x", "start": [268, 1], "end": [269, 91], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.nhdsWithin_target_inter", "code": "theorem nhdsWithin_target_inter {x} (hx : x \u2208 e.target) (s : Set \u03b2) : \ud835\udcdd[e.target \u2229 s] x = \ud835\udcdd[s] x", "start": [272, 1], "end": [273, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_eq_target_inter_inv_preimage", "code": "theorem image_eq_target_inter_inv_preimage {s : Set \u03b1} (h : s \u2286 e.source) :\n    e '' s = e.target \u2229 e.symm \u207b\u00b9' s", "start": [276, 1], "end": [278, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_source_inter_eq'", "code": "theorem image_source_inter_eq' (s : Set \u03b1) : e '' (e.source \u2229 s) = e.target \u2229 e.symm \u207b\u00b9' s", "start": [281, 1], "end": [282, 42], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_source_inter_eq", "code": "theorem image_source_inter_eq (s : Set \u03b1) :\n    e '' (e.source \u2229 s) = e.target \u2229 e.symm \u207b\u00b9' (e.source \u2229 s)", "start": [285, 1], "end": [287, 41], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_image_eq_source_inter_preimage", "code": "theorem symm_image_eq_source_inter_preimage {s : Set \u03b2} (h : s \u2286 e.target) :\n    e.symm '' s = e.source \u2229 e \u207b\u00b9' s", "start": [290, 1], "end": [292, 46], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_image_target_inter_eq", "code": "theorem symm_image_target_inter_eq (s : Set \u03b2) :\n    e.symm '' (e.target \u2229 s) = e.source \u2229 e \u207b\u00b9' (e.target \u2229 s)", "start": [295, 1], "end": [297, 33], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.source_inter_preimage_inv_preimage", "code": "theorem source_inter_preimage_inv_preimage (s : Set \u03b1) :\n    e.source \u2229 e \u207b\u00b9' (e.symm \u207b\u00b9' s) = e.source \u2229 s", "start": [300, 1], "end": [302, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.target_inter_inv_preimage_preimage", "code": "theorem target_inter_inv_preimage_preimage (s : Set \u03b2) :\n    e.target \u2229 e.symm \u207b\u00b9' (e \u207b\u00b9' s) = e.target \u2229 s", "start": [305, 1], "end": [307, 46], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.source_inter_preimage_target_inter", "code": "theorem source_inter_preimage_target_inter (s : Set \u03b2) :\n    e.source \u2229 e \u207b\u00b9' (e.target \u2229 s) = e.source \u2229 e \u207b\u00b9' s", "start": [310, 1], "end": [312, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_source_eq_target", "code": "theorem image_source_eq_target (e : LocalHomeomorph \u03b1 \u03b2) : e '' e.source = e.target", "start": [315, 1], "end": [316, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_image_target_eq_source", "code": "theorem symm_image_target_eq_source (e : LocalHomeomorph \u03b1 \u03b2) : e.symm '' e.target = e.source", "start": [319, 1], "end": [320, 32], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ext", "code": "@[ext]\nprotected theorem ext (e' : LocalHomeomorph \u03b1 \u03b2) (h : \u2200 x, e x = e' x)\n    (hinv : \u2200 x, e.symm x = e'.symm x) (hs : e.source = e'.source) : e = e'", "start": [323, 1], "end": [330, 52], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ext_iff", "code": "protected theorem ext_iff {e e' : LocalHomeomorph \u03b1 \u03b2} :\n    e = e' \u2194 (\u2200 x, e x = e' x) \u2227 (\u2200 x, e.symm x = e'.symm x) \u2227 e.source = e'.source", "start": [333, 1], "end": [337, 80], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem symm_toLocalEquiv : e.symm.toLocalEquiv = e.toLocalEquiv.symm", "start": [340, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_source", "code": "theorem symm_source : e.symm.source = e.target", "start": [346, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_target", "code": "theorem symm_target : e.symm.target = e.source", "start": [350, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_symm", "code": "@[simp, mfld_simps] theorem symm_symm : e.symm.symm = e", "start": [354, 1], "end": [354, 63], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousAt", "code": "protected theorem continuousAt {x : \u03b1} (h : x \u2208 e.source) : ContinuousAt e x", "start": [357, 1], "end": [359, 63], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousAt_symm", "code": "theorem continuousAt_symm {x : \u03b2} (h : x \u2208 e.target) : ContinuousAt e.symm x", "start": [362, 1], "end": [364, 24], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.tendsto_symm", "code": "theorem tendsto_symm {x} (hx : x \u2208 e.source) : Tendsto e.symm (\ud835\udcdd (e x)) (\ud835\udcdd x)", "start": [367, 1], "end": [368, 87], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_nhds_eq", "code": "theorem map_nhds_eq {x} (hx : x \u2208 e.source) : map e (\ud835\udcdd x) = \ud835\udcdd (e x)", "start": [371, 1], "end": [373, 81], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_map_nhds_eq", "code": "theorem symm_map_nhds_eq {x} (hx : x \u2208 e.source) : map e.symm (\ud835\udcdd (e x)) = \ud835\udcdd x", "start": [376, 1], "end": [377, 73], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_mem_nhds", "code": "theorem image_mem_nhds {x} (hx : x \u2208 e.source) {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) : e '' s \u2208 \ud835\udcdd (e x)", "start": [380, 1], "end": [381, 45], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_nhdsWithin_eq", "code": "theorem map_nhdsWithin_eq (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) (s : Set \u03b1) :\n    map e (\ud835\udcdd[s] x) = \ud835\udcdd[e '' (e.source \u2229 s)] e x", "start": [384, 1], "end": [392, 47], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_nhdsWithin_preimage_eq", "code": "theorem map_nhdsWithin_preimage_eq (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) (s : Set \u03b2) :\n    map e (\ud835\udcdd[e \u207b\u00b9' s] x) = \ud835\udcdd[s] e x", "start": [395, 1], "end": [398, 49], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_nhds", "code": "theorem eventually_nhds (e : LocalHomeomorph \u03b1 \u03b2) {x : \u03b1} (p : \u03b2 \u2192 Prop) (hx : x \u2208 e.source) :\n    (\u2200\u1da0 y in \ud835\udcdd (e x), p y) \u2194 \u2200\u1da0 x in \ud835\udcdd x, p (e x)", "start": [401, 1], "end": [403, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_nhds'", "code": "theorem eventually_nhds' (e : LocalHomeomorph \u03b1 \u03b2) {x : \u03b1} (p : \u03b1 \u2192 Prop) (hx : x \u2208 e.source) :\n    (\u2200\u1da0 y in \ud835\udcdd (e x), p (e.symm y)) \u2194 \u2200\u1da0 x in \ud835\udcdd x, p x", "start": [406, 1], "end": [410, 10], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_nhdsWithin", "code": "theorem eventually_nhdsWithin (e : LocalHomeomorph \u03b1 \u03b2) {x : \u03b1} (p : \u03b2 \u2192 Prop) {s : Set \u03b1}\n    (hx : x \u2208 e.source) : (\u2200\u1da0 y in \ud835\udcdd[e.symm \u207b\u00b9' s] e x, p y) \u2194 \u2200\u1da0 x in \ud835\udcdd[s] x, p (e x)", "start": [413, 1], "end": [416, 97], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eventually_nhdsWithin'", "code": "theorem eventually_nhdsWithin' (e : LocalHomeomorph \u03b1 \u03b2) {x : \u03b1} (p : \u03b1 \u2192 Prop) {s : Set \u03b1}\n    (hx : x \u2208 e.source) : (\u2200\u1da0 y in \ud835\udcdd[e.symm \u207b\u00b9' s] e x, p (e.symm y)) \u2194 \u2200\u1da0 x in \ud835\udcdd[s] x, p x", "start": [419, 1], "end": [424, 10], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_eventuallyEq_target_inter_preimage_inter", "code": "theorem preimage_eventuallyEq_target_inter_preimage_inter {e : LocalHomeomorph \u03b1 \u03b2} {s : Set \u03b1}\n    {t : Set \u03b3} {x : \u03b1} {f : \u03b1 \u2192 \u03b3} (hf : ContinuousWithinAt f s x) (hxe : x \u2208 e.source)\n    (ht : t \u2208 \ud835\udcdd (f x)) :\n    e.symm \u207b\u00b9' s =\u1da0[\ud835\udcdd (e x)] (e.target \u2229 e.symm \u207b\u00b9' (s \u2229 f \u207b\u00b9' t) : Set \u03b2)", "start": [427, 1], "end": [439, 39], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_open_of_open", "code": "theorem preimage_open_of_open {s : Set \u03b2} (hs : IsOpen s) : IsOpen (e.source \u2229 e \u207b\u00b9' s)", "start": [442, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage", "code": "def IsImage (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 e.source \u2192 (e x \u2208 t \u2194 x \u2208 s)", "start": [461, 1], "end": [469, 42], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.toLocalEquiv", "code": "theorem toLocalEquiv (h : e.IsImage s t) : e.toLocalEquiv.IsImage s t", "start": [476, 1], "end": [477, 4], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.apply_mem_iff", "code": "theorem apply_mem_iff (h : e.IsImage s t) (hx : x \u2208 e.source) : e x \u2208 t \u2194 x \u2208 s", "start": [480, 1], "end": [481, 7], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm", "code": "protected theorem symm (h : e.IsImage s t) : e.symm.IsImage t s", "start": [484, 1], "end": [485, 22], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_apply_mem_iff", "code": "theorem symm_apply_mem_iff (h : e.IsImage s t) (hy : y \u2208 e.target) : e.symm y \u2208 s \u2194 y \u2208 t", "start": [488, 1], "end": [489, 12], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_iff", "code": "@[simp]\ntheorem symm_iff : e.symm.IsImage t s \u2194 e.IsImage s t", "start": [492, 1], "end": [494, 37], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.mapsTo", "code": "protected theorem mapsTo (h : e.IsImage s t) : MapsTo e (e.source \u2229 s) (e.target \u2229 t)", "start": [497, 1], "end": [498, 24], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_mapsTo", "code": "theorem symm_mapsTo (h : e.IsImage s t) : MapsTo e.symm (e.target \u2229 t) (e.source \u2229 s)", "start": [501, 1], "end": [502, 16], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.image_eq", "code": "theorem image_eq (h : e.IsImage s t) : e '' (e.source \u2229 s) = e.target \u2229 t", "start": [505, 1], "end": [506, 26], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_image_eq", "code": "theorem symm_image_eq (h : e.IsImage s t) : e.symm '' (e.target \u2229 t) = e.source \u2229 s", "start": [509, 1], "end": [510, 18], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.iff_preimage_eq", "code": "theorem iff_preimage_eq : e.IsImage s t \u2194 e.source \u2229 e \u207b\u00b9' t = e.source \u2229 s", "start": [513, 1], "end": [514, 37], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.preimage_eq", "code": "alias \u27e8preimage_eq, of_preimage_eq\u27e9 := iff_preimage_eq", "start": [517, 1], "end": [517, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.of_preimage_eq", "code": "alias \u27e8preimage_eq, of_preimage_eq\u27e9 := iff_preimage_eq", "start": [517, 1], "end": [517, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.iff_symm_preimage_eq", "code": "theorem iff_symm_preimage_eq : e.IsImage s t \u2194 e.target \u2229 e.symm \u207b\u00b9' s = e.target \u2229 t", "start": [521, 1], "end": [522, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_preimage_eq", "code": "alias \u27e8symm_preimage_eq, of_symm_preimage_eq\u27e9 := iff_symm_preimage_eq", "start": [525, 1], "end": [525, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.of_symm_preimage_eq", "code": "alias \u27e8symm_preimage_eq, of_symm_preimage_eq\u27e9 := iff_symm_preimage_eq", "start": [525, 1], "end": [525, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.iff_symm_preimage_eq'", "code": "theorem iff_symm_preimage_eq' :\n    e.IsImage s t \u2194 e.target \u2229 e.symm \u207b\u00b9' (e.source \u2229 s) = e.target \u2229 t", "start": [529, 1], "end": [531, 79], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_preimage_eq'", "code": "alias \u27e8symm_preimage_eq', of_symm_preimage_eq'\u27e9 := iff_symm_preimage_eq'", "start": [534, 1], "end": [534, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.of_symm_preimage_eq'", "code": "alias \u27e8symm_preimage_eq', of_symm_preimage_eq'\u27e9 := iff_symm_preimage_eq'", "start": [534, 1], "end": [534, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.iff_preimage_eq'", "code": "theorem iff_preimage_eq' : e.IsImage s t \u2194 e.source \u2229 e \u207b\u00b9' (e.target \u2229 t) = e.source \u2229 s", "start": [538, 1], "end": [539, 44], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.preimage_eq'", "code": "alias \u27e8preimage_eq', of_preimage_eq'\u27e9 := iff_preimage_eq'", "start": [542, 1], "end": [542, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.of_preimage_eq'", "code": "alias \u27e8preimage_eq', of_preimage_eq'\u27e9 := iff_preimage_eq'", "start": [542, 1], "end": [542, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LocalHomeomorph.IsImage.of_image_eq", "code": "theorem of_image_eq (h : e '' (e.source \u2229 s) = e.target \u2229 t) : e.IsImage s t", "start": [546, 1], "end": [547, 35], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.of_symm_image_eq", "code": "theorem of_symm_image_eq (h : e.symm '' (e.target \u2229 t) = e.source \u2229 s) : e.IsImage s t", "start": [550, 1], "end": [551, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.compl", "code": "protected theorem compl (h : e.IsImage s t) : e.IsImage s\u1d9c t\u1d9c", "start": [554, 1], "end": [554, 88], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.inter", "code": "protected theorem inter {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \u2229 s') (t \u2229 t')", "start": [557, 1], "end": [558, 66], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.union", "code": "protected theorem union {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \u222a s') (t \u222a t')", "start": [561, 1], "end": [562, 65], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.diff", "code": "protected theorem diff {s' t'} (h : e.IsImage s t) (h' : e.IsImage s' t') :\n    e.IsImage (s \\ s') (t \\ t')", "start": [565, 1], "end": [567, 19], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.leftInvOn_piecewise", "code": "theorem leftInvOn_piecewise {e' : LocalHomeomorph \u03b1 \u03b2} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : e.IsImage s t) (h' : e'.IsImage s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source)", "start": [570, 1], "end": [573, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.inter_eq_of_inter_eq_of_eqOn", "code": "theorem inter_eq_of_inter_eq_of_eqOn {e' : LocalHomeomorph \u03b1 \u03b2} (h : e.IsImage s t)\n    (h' : e'.IsImage s t) (hs : e.source \u2229 s = e'.source \u2229 s) (Heq : EqOn e e' (e.source \u2229 s)) :\n    e.target \u2229 t = e'.target \u2229 t", "start": [576, 1], "end": [579, 56], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.symm_eqOn_of_inter_eq_of_eqOn", "code": "theorem symm_eqOn_of_inter_eq_of_eqOn {e' : LocalHomeomorph \u03b1 \u03b2} (h : e.IsImage s t)\n    (hs : e.source \u2229 s = e'.source \u2229 s) (Heq : EqOn e e' (e.source \u2229 s)) :\n    EqOn e.symm e'.symm (e.target \u2229 t)", "start": [582, 1], "end": [585, 55], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.map_nhdsWithin_eq", "code": "theorem map_nhdsWithin_eq (h : e.IsImage s t) (hx : x \u2208 e.source) : map e (\ud835\udcdd[s] x) = \ud835\udcdd[t] e x", "start": [588, 1], "end": [589, 87], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.closure", "code": "protected theorem closure (h : e.IsImage s t) : e.IsImage (closure s) (closure t)", "start": [592, 1], "end": [593, 88], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.interior", "code": "protected theorem interior (h : e.IsImage s t) : e.IsImage (interior s) (interior t)", "start": [596, 1], "end": [597, 70], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.frontier", "code": "protected theorem frontier (h : e.IsImage s t) : e.IsImage (frontier s) (frontier t)", "start": [600, 1], "end": [601, 28], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.isOpen_iff", "code": "theorem isOpen_iff (h : e.IsImage s t) : IsOpen (e.source \u2229 s) \u2194 IsOpen (e.target \u2229 t)", "start": [604, 1], "end": [606, 49], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.IsImage.restr", "code": "@[simps toLocalEquiv]\ndef restr (h : e.IsImage s t) (hs : IsOpen (e.source \u2229 s)) : LocalHomeomorph \u03b1 \u03b2 where\n  toLocalEquiv := h.toLocalEquiv.restr\n  open_source := hs\n  open_target := h.isOpen_iff.1 hs\n  continuous_toFun := e.continuousOn.mono (inter_subset_left _ _)\n  continuous_invFun := e.symm.continuousOn.mono (inter_subset_left _ _)", "start": [609, 1], "end": [616, 72], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.isImage_source_target", "code": "theorem isImage_source_target : e.IsImage e.source e.target", "start": [621, 1], "end": [622, 39], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.isImage_source_target_of_disjoint", "code": "theorem isImage_source_target_of_disjoint (e' : LocalHomeomorph \u03b1 \u03b2)\n    (hs : Disjoint e.source e'.source) (ht : Disjoint e.target e'.target) :\n    e.IsImage e'.source e'.target", "start": [625, 1], "end": [628, 73], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_interior", "code": "theorem preimage_interior (s : Set \u03b2) :\n    e.source \u2229 e \u207b\u00b9' interior s = e.source \u2229 interior (e \u207b\u00b9' s)", "start": [631, 1], "end": [635, 52], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_closure", "code": "theorem preimage_closure (s : Set \u03b2) : e.source \u2229 e \u207b\u00b9' closure s = e.source \u2229 closure (e \u207b\u00b9' s)", "start": [638, 1], "end": [639, 51], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_frontier", "code": "theorem preimage_frontier (s : Set \u03b2) :\n    e.source \u2229 e \u207b\u00b9' frontier s = e.source \u2229 frontier (e \u207b\u00b9' s)", "start": [642, 1], "end": [644, 52], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.preimage_open_of_open_symm", "code": "theorem preimage_open_of_open_symm {s : Set \u03b1} (hs : IsOpen s) : IsOpen (e.target \u2229 e.symm \u207b\u00b9' s)", "start": [647, 1], "end": [648, 61], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_open_of_open", "code": "theorem image_open_of_open {s : Set \u03b1} (hs : IsOpen s) (h : s \u2286 e.source) : IsOpen (e '' s)", "start": [651, 1], "end": [655, 67], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_open_of_open'", "code": "theorem image_open_of_open' {s : Set \u03b1} (hs : IsOpen s) : IsOpen (e '' (e.source \u2229 s))", "start": [658, 1], "end": [660, 79], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofContinuousOpenRestrict", "code": "def ofContinuousOpenRestrict (e : LocalEquiv \u03b1 \u03b2) (hc : ContinuousOn e e.source)\n    (ho : IsOpenMap (e.source.restrict e)) (hs : IsOpen e.source) : LocalHomeomorph \u03b1 \u03b2 where\n  toLocalEquiv := e\n  open_source := hs\n  open_target := by simpa only [range_restrict, e.image_source_eq_target] using ho.isOpen_range\n  continuous_toFun := hc\n  continuous_invFun := e.image_source_eq_target \u25b8 ho.continuousOn_image_of_leftInvOn e.leftInvOn", "start": [663, 1], "end": [670, 97], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofContinuousOpen", "code": "def ofContinuousOpen (e : LocalEquiv \u03b1 \u03b2) (hc : ContinuousOn e e.source) (ho : IsOpenMap e)\n    (hs : IsOpen e.source) : LocalHomeomorph \u03b1 \u03b2 :=\n  ofContinuousOpenRestrict e hc (ho.restrict hs) hs", "start": [673, 1], "end": [676, 52], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restrOpen", "code": "protected def restrOpen (s : Set \u03b1) (hs : IsOpen s) : LocalHomeomorph \u03b1 \u03b2 :=\n  (@IsImage.of_symm_preimage_eq \u03b1 \u03b2 _ _ e s (e.symm \u207b\u00b9' s) rfl).restr\n    (IsOpen.inter e.open_source hs)", "start": [679, 1], "end": [684, 36], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restrOpen_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem restrOpen_toLocalEquiv (s : Set \u03b1) (hs : IsOpen s) :\n    (e.restrOpen s hs).toLocalEquiv = e.toLocalEquiv.restr s", "start": [687, 1], "end": [690, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restrOpen_source", "code": "theorem restrOpen_source (s : Set \u03b1) (hs : IsOpen s) : (e.restrOpen s hs).source = e.source \u2229 s", "start": [694, 1], "end": [695, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr", "code": "@[simps! (config := mfld_cfg) apply symm_apply, simps! (config := .lemmasOnly) source target]\nprotected def restr (s : Set \u03b1) : LocalHomeomorph \u03b1 \u03b2 :=\n  e.restrOpen (interior s) isOpen_interior", "start": [698, 1], "end": [704, 43], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem restr_toLocalEquiv (s : Set \u03b1) :\n    (e.restr s).toLocalEquiv = e.toLocalEquiv.restr (interior s)", "start": [707, 1], "end": [710, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_source'", "code": "theorem restr_source' (s : Set \u03b1) (hs : IsOpen s) : (e.restr s).source = e.source \u2229 s", "start": [713, 1], "end": [714, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_toLocalEquiv'", "code": "theorem restr_toLocalEquiv' (s : Set \u03b1) (hs : IsOpen s) :\n    (e.restr s).toLocalEquiv = e.toLocalEquiv.restr s", "start": [717, 1], "end": [719, 44], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_eq_of_source_subset", "code": "theorem restr_eq_of_source_subset {e : LocalHomeomorph \u03b1 \u03b2} {s : Set \u03b1} (h : e.source \u2286 s) :\n    e.restr s = e", "start": [722, 1], "end": [724, 101], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_univ", "code": "@[simp, mfld_simps]\ntheorem restr_univ {e : LocalHomeomorph \u03b1 \u03b2} : e.restr univ = e", "start": [727, 1], "end": [729, 44], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_source_inter", "code": "theorem restr_source_inter (s : Set \u03b1) : e.restr (e.source \u2229 s) = e.restr s", "start": [732, 1], "end": [734, 50], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.refl", "code": "@[simps! (config := mfld_cfg) apply, simps! (config := .lemmasOnly) source target]\nprotected def refl (\u03b1 : Type*) [TopologicalSpace \u03b1] : LocalHomeomorph \u03b1 \u03b1 :=\n  (Homeomorph.refl \u03b1).toLocalHomeomorph", "start": [737, 1], "end": [740, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.refl_localEquiv", "code": "@[simp, mfld_simps]\ntheorem refl_localEquiv : (LocalHomeomorph.refl \u03b1).toLocalEquiv = LocalEquiv.refl \u03b1", "start": [743, 1], "end": [745, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.refl_symm", "code": "@[simp, mfld_simps]\ntheorem refl_symm : (LocalHomeomorph.refl \u03b1).symm = LocalHomeomorph.refl \u03b1", "start": [748, 1], "end": [750, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet", "code": "@[simps! (config := mfld_cfg) apply, simps! (config := .lemmasOnly) source target]\ndef ofSet (s : Set \u03b1) (hs : IsOpen s) : LocalHomeomorph \u03b1 \u03b1 where\n  toLocalEquiv := LocalEquiv.ofSet s\n  open_source := hs\n  open_target := hs\n  continuous_toFun := continuous_id.continuousOn\n  continuous_invFun := continuous_id.continuousOn", "start": [757, 1], "end": [764, 50], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem ofSet_toLocalEquiv : (ofSet s hs).toLocalEquiv = LocalEquiv.ofSet s", "start": [767, 1], "end": [769, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_symm", "code": "@[simp, mfld_simps]\ntheorem ofSet_symm : (ofSet s hs).symm = ofSet s hs", "start": [772, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_univ_eq_refl", "code": "@[simp, mfld_simps]\ntheorem ofSet_univ_eq_refl : ofSet univ isOpen_univ = LocalHomeomorph.refl \u03b1", "start": [777, 1], "end": [778, 96], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans'", "code": "@[simps! apply symm_apply toLocalEquiv, simps! (config := .lemmasOnly) source target]\nprotected def trans' (h : e.target = e'.source) : LocalHomeomorph \u03b1 \u03b3 where\n  toLocalEquiv := LocalEquiv.trans' e.toLocalEquiv e'.toLocalEquiv h\n  open_source := e.open_source\n  open_target := e'.open_target\n  continuous_toFun :=  e'.continuousOn.comp e.continuousOn <| h \u25b8 e.mapsTo\n  continuous_invFun := e.continuousOn_symm.comp e'.continuousOn_symm <| h.symm \u25b8 e'.symm_mapsTo", "start": [783, 1], "end": [791, 96], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans", "code": "protected def trans : LocalHomeomorph \u03b1 \u03b3 :=\n  LocalHomeomorph.trans' (e.symm.restrOpen e'.source e'.open_source).symm\n    (e'.restrOpen e.target e.open_target) (by simp [inter_comm])", "start": [794, 1], "end": [798, 65], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_toLocalEquiv", "code": "@[simp, mfld_simps]\ntheorem trans_toLocalEquiv : (e.trans e').toLocalEquiv = e.toLocalEquiv.trans e'.toLocalEquiv", "start": [801, 1], "end": [803, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.coe_trans", "code": "@[simp, mfld_simps]\ntheorem coe_trans : (e.trans e' : \u03b1 \u2192 \u03b3) = e' \u2218 e", "start": [806, 1], "end": [808, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.coe_trans_symm", "code": "@[simp, mfld_simps]\ntheorem coe_trans_symm : ((e.trans e').symm : \u03b3 \u2192 \u03b1) = e.symm \u2218 e'.symm", "start": [811, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_apply", "code": "theorem trans_apply {x : \u03b1} : (e.trans e') x = e' (e x)", "start": [816, 1], "end": [817, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_symm_eq_symm_trans_symm", "code": "theorem trans_symm_eq_symm_trans_symm : (e.trans e').symm = e'.symm.trans e.symm", "start": [820, 1], "end": [820, 88], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_source", "code": "theorem trans_source : (e.trans e').source = e.source \u2229 e \u207b\u00b9' e'.source", "start": [825, 1], "end": [826, 57], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_source'", "code": "theorem trans_source' : (e.trans e').source = e.source \u2229 e \u207b\u00b9' (e.target \u2229 e'.source)", "start": [829, 1], "end": [830, 58], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_source''", "code": "theorem trans_source'' : (e.trans e').source = e.symm '' (e.target \u2229 e'.source)", "start": [833, 1], "end": [834, 59], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.image_trans_source", "code": "theorem image_trans_source : e '' (e.trans e').source = e.target \u2229 e'.source", "start": [837, 1], "end": [838, 63], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_target", "code": "theorem trans_target : (e.trans e').target = e'.target \u2229 e'.symm \u207b\u00b9' e.target", "start": [841, 1], "end": [842, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_target'", "code": "theorem trans_target' : (e.trans e').target = e'.target \u2229 e'.symm \u207b\u00b9' (e'.source \u2229 e.target)", "start": [845, 1], "end": [846, 31], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_target''", "code": "theorem trans_target'' : (e.trans e').target = e' '' (e'.source \u2229 e.target)", "start": [849, 1], "end": [850, 32], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.inv_image_trans_target", "code": "theorem inv_image_trans_target : e'.symm '' (e.trans e').target = e'.source \u2229 e.target", "start": [853, 1], "end": [854, 36], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_assoc", "code": "theorem trans_assoc (e'' : LocalHomeomorph \u03b3 \u03b4) :\n    (e.trans e').trans e'' = e.trans (e'.trans e'')", "start": [857, 1], "end": [859, 48], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_refl", "code": "@[simp, mfld_simps]\ntheorem trans_refl : e.trans (LocalHomeomorph.refl \u03b2) = e", "start": [862, 1], "end": [864, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.refl_trans", "code": "@[simp, mfld_simps]\ntheorem refl_trans : (LocalHomeomorph.refl \u03b1).trans e = e", "start": [867, 1], "end": [869, 40], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_ofSet", "code": "theorem trans_ofSet {s : Set \u03b2} (hs : IsOpen s) : e.trans (ofSet s hs) = e.restr (e \u207b\u00b9' s)", "start": [872, 1], "end": [874, 87], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_of_set'", "code": "theorem trans_of_set' {s : Set \u03b2} (hs : IsOpen s) :\n    e.trans (ofSet s hs) = e.restr (e.source \u2229 e \u207b\u00b9' s)", "start": [877, 1], "end": [878, 99], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_trans", "code": "theorem ofSet_trans {s : Set \u03b1} (hs : IsOpen s) : (ofSet s hs).trans e = e.restr s", "start": [881, 1], "end": [882, 96], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_trans'", "code": "theorem ofSet_trans' {s : Set \u03b1} (hs : IsOpen s) : (ofSet s hs).trans e = e.restr (e.source \u2229 s)", "start": [885, 1], "end": [886, 42], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.ofSet_trans_ofSet", "code": "@[simp, mfld_simps]\ntheorem ofSet_trans_ofSet {s : Set \u03b1} (hs : IsOpen s) {s' : Set \u03b1} (hs' : IsOpen s') :\n    (ofSet s hs).trans (ofSet s' hs') = ofSet (s \u2229 s') (IsOpen.inter hs hs')", "start": [889, 1], "end": [893, 33], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.restr_trans", "code": "theorem restr_trans (s : Set \u03b1) : (e.restr s).trans e' = (e.trans e').restr s", "start": [896, 1], "end": [897, 95], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.transHomeomorph", "code": "@[simps! (config := { fullyApplied := false })]\ndef transHomeomorph (e' : \u03b2 \u2243\u209c \u03b3) : LocalHomeomorph \u03b1 \u03b3 where\n  toLocalEquiv := e.toLocalEquiv.transEquiv e'.toEquiv\n  open_source := e.open_source\n  open_target := e.open_target.preimage e'.symm.continuous\n  continuous_toFun := e'.continuous.comp_continuousOn e.continuousOn\n  continuous_invFun := e.symm.continuousOn.comp e'.symm.continuous.continuousOn fun _ => id", "start": [900, 1], "end": [908, 92], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.transHomeomorph_eq_trans", "code": "theorem transHomeomorph_eq_trans (e' : \u03b2 \u2243\u209c \u03b3) :\n    e.transHomeomorph e' = e.trans e'.toLocalHomeomorph", "start": [911, 1], "end": [913, 63], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.transLocalHomeomorph", "code": "@[simps! (config := { fullyApplied := false })]\ndef _root_.Homeomorph.transLocalHomeomorph (e : \u03b1 \u2243\u209c \u03b2) : LocalHomeomorph \u03b1 \u03b3 where\n  toLocalEquiv := e.toEquiv.transLocalEquiv e'.toLocalEquiv\n  open_source := e'.open_source.preimage e.continuous\n  open_target := e'.open_target\n  continuous_toFun := e'.continuousOn.comp e.continuous.continuousOn fun _ => id\n  continuous_invFun := e.symm.continuous.comp_continuousOn e'.symm.continuousOn", "start": [916, 1], "end": [924, 80], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.transLocalHomeomorph_eq_trans", "code": "theorem _root_.Homeomorph.transLocalHomeomorph_eq_trans (e : \u03b1 \u2243\u209c \u03b2) :\n    e.transLocalHomeomorph e' = e.toLocalHomeomorph.trans e'", "start": [927, 1], "end": [929, 63], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource", "code": "def EqOnSource (e e' : LocalHomeomorph \u03b1 \u03b2) : Prop :=\n  e.source = e'.source \u2227 EqOn e e' e.source", "start": [932, 1], "end": [935, 44], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eqOnSource_iff", "code": "theorem eqOnSource_iff (e e' : LocalHomeomorph \u03b1 \u03b2) :\n    EqOnSource e e' \u2194 LocalEquiv.EqOnSource e.toLocalEquiv e'.toLocalEquiv", "start": [938, 1], "end": [940, 10], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eqOnSourceSetoid", "code": "instance eqOnSourceSetoid : Setoid (LocalHomeomorph \u03b1 \u03b2) :=\n  { LocalEquiv.eqOnSourceSetoid.comap toLocalEquiv with r := EqOnSource }", "start": [943, 1], "end": [945, 74], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eqOnSource_refl", "code": "theorem eqOnSource_refl : e \u2248 e", "start": [947, 1], "end": [947, 49], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.symm'", "code": "theorem EqOnSource.symm' {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') : e.symm \u2248 e'.symm", "start": [950, 1], "end": [952, 32], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.source_eq", "code": "theorem EqOnSource.source_eq {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') : e.source = e'.source", "start": [955, 1], "end": [957, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.target_eq", "code": "theorem EqOnSource.target_eq {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') : e.target = e'.target", "start": [960, 1], "end": [962, 12], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.eqOn", "code": "theorem EqOnSource.eqOn {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') : EqOn e e' e.source", "start": [965, 1], "end": [967, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.symm_eqOn_target", "code": "theorem EqOnSource.symm_eqOn_target {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') :\n    EqOn e.symm e'.symm e.target", "start": [970, 1], "end": [973, 12], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.trans'", "code": "theorem EqOnSource.trans' {e e' : LocalHomeomorph \u03b1 \u03b2} {f f' : LocalHomeomorph \u03b2 \u03b3} (he : e \u2248 e')\n    (hf : f \u2248 f') : e.trans f \u2248 e'.trans f'", "start": [976, 1], "end": [979, 37], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.EqOnSource.restr", "code": "theorem EqOnSource.restr {e e' : LocalHomeomorph \u03b1 \u03b2} (he : e \u2248 e') (s : Set \u03b1) :\n    e.restr s \u2248 e'.restr s", "start": [982, 1], "end": [985, 35], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.Set.EqOn.restr_eqOn_source", "code": "theorem Set.EqOn.restr_eqOn_source {e e' : LocalHomeomorph \u03b1 \u03b2}\n    (h : EqOn e e' (e.source \u2229 e'.source)) : e.restr e'.source \u2248 e'.restr e.source", "start": [988, 1], "end": [995, 75], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_self_symm", "code": "theorem trans_self_symm : e.trans e.symm \u2248 LocalHomeomorph.ofSet e.source e.open_source", "start": [998, 1], "end": [1001, 31], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.trans_symm_self", "code": "theorem trans_symm_self : e.symm.trans e \u2248 LocalHomeomorph.ofSet e.target e.open_target", "start": [1004, 1], "end": [1005, 25], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.eq_of_eq_on_source_univ", "code": "theorem eq_of_eq_on_source_univ {e e' : LocalHomeomorph \u03b1 \u03b2} (h : e \u2248 e') (s : e.source = univ)\n    (t : e.target = univ) : e = e'", "start": [1008, 1], "end": [1010, 73], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.prod", "code": "@[simps! (config := mfld_cfg) toLocalEquiv apply,\n  simps! (config := .lemmasOnly) source target symm_apply]\ndef prod (e : LocalHomeomorph \u03b1 \u03b2) (e' : LocalHomeomorph \u03b3 \u03b4) :\n    LocalHomeomorph (\u03b1 \u00d7 \u03b3) (\u03b2 \u00d7 \u03b4) where\n  open_source := e.open_source.prod e'.open_source\n  open_target := e.open_target.prod e'.open_target\n  continuous_toFun := e.continuousOn.prod_map e'.continuousOn\n  continuous_invFun := e.continuousOn_symm.prod_map e'.continuousOn_symm\n  toLocalEquiv := e.toLocalEquiv.prod e'.toLocalEquiv", "start": [1015, 1], "end": [1024, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.prod_symm", "code": "@[simp, mfld_simps]\ntheorem prod_symm (e : LocalHomeomorph \u03b1 \u03b2) (e' : LocalHomeomorph \u03b3 \u03b4) :\n    (e.prod e').symm = e.symm.prod e'.symm", "start": [1027, 1], "end": [1030, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.refl_prod_refl", "code": "@[simp]\ntheorem refl_prod_refl {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] :\n    (LocalHomeomorph.refl \u03b1).prod (LocalHomeomorph.refl \u03b2) = LocalHomeomorph.refl (\u03b1 \u00d7 \u03b2)", "start": [1033, 1], "end": [1036, 71], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.prod_trans", "code": "@[simp, mfld_simps]\ntheorem prod_trans {\u03b7 : Type*} {\u03b5 : Type*} [TopologicalSpace \u03b7] [TopologicalSpace \u03b5]\n    (e : LocalHomeomorph \u03b1 \u03b2) (f : LocalHomeomorph \u03b2 \u03b3) (e' : LocalHomeomorph \u03b4 \u03b7)\n    (f' : LocalHomeomorph \u03b7 \u03b5) : (e.prod e').trans (f.prod f') = (e.trans f).prod (e'.trans f')", "start": [1039, 1], "end": [1043, 46], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.prod_eq_prod_of_nonempty", "code": "theorem prod_eq_prod_of_nonempty {e\u2081 e\u2081' : LocalHomeomorph \u03b1 \u03b2} {e\u2082 e\u2082' : LocalHomeomorph \u03b3 \u03b4}\n    (h : (e\u2081.prod e\u2082).source.Nonempty) : e\u2081.prod e\u2082 = e\u2081'.prod e\u2082' \u2194 e\u2081 = e\u2081' \u2227 e\u2082 = e\u2082'", "start": [1046, 1], "end": [1055, 30], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.prod_eq_prod_of_nonempty'", "code": "theorem prod_eq_prod_of_nonempty' {e\u2081 e\u2081' : LocalHomeomorph \u03b1 \u03b2} {e\u2082 e\u2082' : LocalHomeomorph \u03b3 \u03b4}\n    (h : (e\u2081'.prod e\u2082').source.Nonempty) : e\u2081.prod e\u2082 = e\u2081'.prod e\u2082' \u2194 e\u2081 = e\u2081' \u2227 e\u2082 = e\u2082'", "start": [1058, 1], "end": [1060, 68], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.piecewise", "code": "@[simps! (config := { fullyApplied := false }) toLocalEquiv apply]\ndef piecewise (e e' : LocalHomeomorph \u03b1 \u03b2) (s : Set \u03b1) (t : Set \u03b2) [\u2200 x, Decidable (x \u2208 s)]\n    [\u2200 y, Decidable (y \u2208 t)] (H : e.IsImage s t) (H' : e'.IsImage s t)\n    (Hs : e.source \u2229 frontier s = e'.source \u2229 frontier s)\n    (Heq : EqOn e e' (e.source \u2229 frontier s)) : LocalHomeomorph \u03b1 \u03b2 where\n  toLocalEquiv := e.toLocalEquiv.piecewise e'.toLocalEquiv s t H H'\n  open_source := e.open_source.ite e'.open_source Hs\n  open_target :=\n    e.open_target.ite e'.open_target <| H.frontier.inter_eq_of_inter_eq_of_eqOn H'.frontier Hs Heq\n  continuous_toFun := continuousOn_piecewise_ite e.continuousOn e'.continuousOn Hs Heq\n  continuous_invFun :=\n    continuousOn_piecewise_ite e.continuousOn_symm e'.continuousOn_symm\n      (H.frontier.inter_eq_of_inter_eq_of_eqOn H'.frontier Hs Heq)\n      (H.frontier.symm_eqOn_of_inter_eq_of_eqOn Hs Heq)", "start": [1067, 1], "end": [1088, 56], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.symm_piecewise", "code": "@[simp]\ntheorem symm_piecewise (e e' : LocalHomeomorph \u03b1 \u03b2) {s : Set \u03b1} {t : Set \u03b2} [\u2200 x, Decidable (x \u2208 s)]\n    [\u2200 y, Decidable (y \u2208 t)] (H : e.IsImage s t) (H' : e'.IsImage s t)\n    (Hs : e.source \u2229 frontier s = e'.source \u2229 frontier s)\n    (Heq : EqOn e e' (e.source \u2229 frontier s)) :\n    (e.piecewise e' s t H H' Hs Heq).symm =\n      e.symm.piecewise e'.symm t s H.symm H'.symm\n        (H.frontier.inter_eq_of_inter_eq_of_eqOn H'.frontier Hs Heq)\n        (H.frontier.symm_eqOn_of_inter_eq_of_eqOn Hs Heq)", "start": [1091, 1], "end": [1100, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.disjointUnion", "code": "def disjointUnion (e e' : LocalHomeomorph \u03b1 \u03b2) [\u2200 x, Decidable (x \u2208 e.source)]\n    [\u2200 y, Decidable (y \u2208 e.target)] (Hs : Disjoint e.source e'.source)\n    (Ht : Disjoint e.target e'.target) : LocalHomeomorph \u03b1 \u03b2 :=\n  (e.piecewise e' e.source e.target e.isImage_source_target\n        (e'.isImage_source_target_of_disjoint e Hs.symm Ht.symm)\n        (by rw [e.open_source.inter_frontier_eq, (Hs.symm.frontier_right e'.open_source).inter_eq])\n        (by\n          rw [e.open_source.inter_frontier_eq]\n          exact eqOn_empty _ _)).replaceEquiv\n    (e.toLocalEquiv.disjointUnion e'.toLocalEquiv Hs Ht)\n    (LocalEquiv.disjointUnion_eq_piecewise _ _ _ _).symm", "start": [1103, 1], "end": [1116, 57], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.pi", "code": "@[simps toLocalEquiv]\ndef pi : LocalHomeomorph (\u2200 i, Xi i) (\u2200 i, Yi i) where\n  toLocalEquiv := LocalEquiv.pi fun i => (ei i).toLocalEquiv\n  open_source := isOpen_set_pi finite_univ fun i _ => (ei i).open_source\n  open_target := isOpen_set_pi finite_univ fun i _ => (ei i).open_target\n  continuous_toFun := continuousOn_pi.2 fun i =>\n    (ei i).continuousOn.comp (continuous_apply _).continuousOn fun _f hf => hf i trivial\n  continuous_invFun := continuousOn_pi.2 fun i =>\n    (ei i).continuousOn_symm.comp (continuous_apply _).continuousOn fun _f hf => hf i trivial", "start": [1126, 1], "end": [1135, 94], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousWithinAt_iff_continuousWithinAt_comp_right", "code": "theorem continuousWithinAt_iff_continuousWithinAt_comp_right {f : \u03b2 \u2192 \u03b3} {s : Set \u03b2} {x : \u03b2}\n    (h : x \u2208 e.target) :\n    ContinuousWithinAt f s x \u2194 ContinuousWithinAt (f \u2218 e) (e \u207b\u00b9' s) (e.symm x)", "start": [1142, 1], "end": [1148, 75], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousAt_iff_continuousAt_comp_right", "code": "theorem continuousAt_iff_continuousAt_comp_right {f : \u03b2 \u2192 \u03b3} {x : \u03b2} (h : x \u2208 e.target) :\n    ContinuousAt f x \u2194 ContinuousAt (f \u2218 e) (e.symm x)", "start": [1151, 1], "end": [1156, 44], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousOn_iff_continuousOn_comp_right", "code": "theorem continuousOn_iff_continuousOn_comp_right {f : \u03b2 \u2192 \u03b3} {s : Set \u03b2} (h : s \u2286 e.target) :\n    ContinuousOn f s \u2194 ContinuousOn (f \u2218 e) (e.source \u2229 e \u207b\u00b9' s)", "start": [1159, 1], "end": [1167, 60], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousWithinAt_iff_continuousWithinAt_comp_left", "code": "theorem continuousWithinAt_iff_continuousWithinAt_comp_left {f : \u03b3 \u2192 \u03b1} {s : Set \u03b3} {x : \u03b3}\n    (hx : f x \u2208 e.source) (h : f \u207b\u00b9' e.source \u2208 \ud835\udcdd[s] x) :\n    ContinuousWithinAt f s x \u2194 ContinuousWithinAt (e \u2218 f) s x", "start": [1170, 1], "end": [1182, 85], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousAt_iff_continuousAt_comp_left", "code": "theorem continuousAt_iff_continuousAt_comp_left {f : \u03b3 \u2192 \u03b1} {x : \u03b3} (h : f \u207b\u00b9' e.source \u2208 \ud835\udcdd x) :\n    ContinuousAt f x \u2194 ContinuousAt (e \u2218 f) x", "start": [1185, 1], "end": [1192, 65], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuousOn_iff_continuousOn_comp_left", "code": "theorem continuousOn_iff_continuousOn_comp_left {f : \u03b3 \u2192 \u03b1} {s : Set \u03b3} (h : s \u2286 f \u207b\u00b9' e.source) :\n    ContinuousOn f s \u2194 ContinuousOn (e \u2218 f) s", "start": [1195, 1], "end": [1201, 46], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.continuous_iff_continuous_comp_left", "code": "theorem continuous_iff_continuous_comp_left {f : \u03b3 \u2192 \u03b1} (h : f \u207b\u00b9' e.source = univ) :\n    Continuous f \u2194 Continuous (e \u2218 f)", "start": [1204, 1], "end": [1209, 69], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.homeomorphOfImageSubsetSource", "code": "@[simps]\ndef homeomorphOfImageSubsetSource {s : Set \u03b1} {t : Set \u03b2} (hs : s \u2286 e.source) (ht : e '' s = t) :\n    s \u2243\u209c t :=\n  have h\u2081 : MapsTo e s t := mapsTo'.2 ht.subset\n  have h\u2082 : t \u2286 e.target := ht \u25b8 e.image_source_eq_target \u25b8 image_subset e hs\n  have h\u2083 : MapsTo e.symm t s := ht \u25b8 ball_image_iff.2 <| fun _x hx =>\n      (e.left_inv (hs hx)).symm \u25b8 hx\n  { toFun := MapsTo.restrict e s t h\u2081\n    invFun := MapsTo.restrict e.symm t s h\u2083\n    left_inv := fun a => Subtype.ext (e.left_inv (hs a.2))\n    right_inv := fun b => Subtype.eq <| e.right_inv (h\u2082 b.2)\n    continuous_toFun := (e.continuousOn.mono hs).restrict_mapsTo h\u2081\n    continuous_invFun := (e.continuousOn_symm.mono h\u2082).restrict_mapsTo h\u2083 }", "start": [1214, 1], "end": [1227, 76], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.toHomeomorphSourceTarget", "code": "@[simps!] def toHomeomorphSourceTarget : e.source \u2243\u209c e.target :=\n  e.homeomorphOfImageSubsetSource subset_rfl e.image_source_eq_target", "start": [1230, 1], "end": [1233, 70], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.secondCountableTopology_source", "code": "theorem secondCountableTopology_source [SecondCountableTopology \u03b2] (e : LocalHomeomorph \u03b1 \u03b2) :\n    SecondCountableTopology e.source", "start": [1236, 1], "end": [1238, 53], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.nhds_eq_comap_inf_principal", "code": "theorem nhds_eq_comap_inf_principal {x} (hx : x \u2208 e.source) :\n    \ud835\udcdd x = comap e (\ud835\udcdd (e x)) \u2293 \ud835\udcdf e.source", "start": [1241, 1], "end": [1246, 71], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.toHomeomorphOfSourceEqUnivTargetEqUniv", "code": "@[simps (config := mfld_cfg) apply symm_apply] def toHomeomorphOfSourceEqUnivTargetEqUniv (h : e.source = (univ : Set \u03b1)) (h' : e.target = univ) :\n    \u03b1 \u2243\u209c \u03b2 where\n  toFun := e\n  invFun := e.symm\n  left_inv x :=\n    e.left_inv <| by\n      rw [h]\n      exact mem_univ _\n  right_inv x :=\n    e.right_inv <| by\n      rw [h']\n      exact mem_univ _\n  continuous_toFun := by\n    simpa only [continuous_iff_continuousOn_univ, h] using e.continuousOn\n  continuous_invFun := by\n    simpa only [continuous_iff_continuousOn_univ, h'] using e.continuousOn_symm", "start": [1248, 1], "end": [1266, 80], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.openEmbedding_restrict", "code": "theorem openEmbedding_restrict : OpenEmbedding (e.source.restrict e)", "start": [1269, 1], "end": [1273, 98], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.to_openEmbedding", "code": "theorem to_openEmbedding (h : e.source = Set.univ) : OpenEmbedding e", "start": [1275, 1], "end": [1279, 80], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.refl_toLocalHomeomorph", "code": "@[simp, mfld_simps]\ntheorem refl_toLocalHomeomorph : (Homeomorph.refl \u03b1).toLocalHomeomorph = LocalHomeomorph.refl \u03b1", "start": [1291, 1], "end": [1293, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_toLocalHomeomorph", "code": "@[simp, mfld_simps]\ntheorem symm_toLocalHomeomorph : e.symm.toLocalHomeomorph = e.toLocalHomeomorph.symm", "start": [1296, 1], "end": [1298, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.trans_toLocalHomeomorph", "code": "@[simp, mfld_simps]\ntheorem trans_toLocalHomeomorph :\n    (e.trans e').toLocalHomeomorph = e.toLocalHomeomorph.trans e'.toLocalHomeomorph", "start": [1301, 1], "end": [1304, 73], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.toLocalHomeomorph", "code": "@[simps! (config := mfld_cfg) apply source target]\nnoncomputable def toLocalHomeomorph [Nonempty \u03b1] : LocalHomeomorph \u03b1 \u03b2 :=\n  LocalHomeomorph.ofContinuousOpen ((h.toEmbedding.inj.injOn univ).toLocalEquiv _ _)\n    h.continuous.continuousOn h.isOpenMap isOpen_univ", "start": [1313, 1], "end": [1318, 54], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.continuousAt_iff", "code": "theorem continuousAt_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : OpenEmbedding f) {x : \u03b1} :\n    ContinuousAt (g \u2218 f) x \u2194 ContinuousAt g (f x)", "start": [1321, 1], "end": [1323, 23], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.localHomeomorphSubtypeCoe", "code": "noncomputable def localHomeomorphSubtypeCoe : LocalHomeomorph s \u03b1 :=\n  OpenEmbedding.toLocalHomeomorph _ s.2.openEmbedding_subtype_val", "start": [1334, 1], "end": [1337, 66], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.localHomeomorphSubtypeCoe_coe", "code": "@[simp, mfld_simps]\ntheorem localHomeomorphSubtypeCoe_coe : (s.localHomeomorphSubtypeCoe : s \u2192 \u03b1) = (\u2191)", "start": [1340, 1], "end": [1342, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.localHomeomorphSubtypeCoe_source", "code": "@[simp, mfld_simps]\ntheorem localHomeomorphSubtypeCoe_source : s.localHomeomorphSubtypeCoe.source = Set.univ", "start": [1345, 1], "end": [1347, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Opens.localHomeomorphSubtypeCoe_target", "code": "@[simp, mfld_simps]\ntheorem localHomeomorphSubtypeCoe_target : s.localHomeomorphSubtypeCoe.target = s", "start": [1350, 1], "end": [1353, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr", "code": "noncomputable def subtypeRestr : LocalHomeomorph s \u03b2 :=\n  s.localHomeomorphSubtypeCoe.trans e", "start": [1366, 1], "end": [1369, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr_def", "code": "theorem subtypeRestr_def : e.subtypeRestr s = s.localHomeomorphSubtypeCoe.trans e", "start": [1372, 1], "end": [1373, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr_coe", "code": "@[simp, mfld_simps]\ntheorem subtypeRestr_coe :\n    ((e.subtypeRestr s : LocalHomeomorph s \u03b2) : s \u2192 \u03b2) = Set.restrict \u2191s (e : \u03b1 \u2192 \u03b2)", "start": [1376, 1], "end": [1379, 6], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr_source", "code": "@[simp, mfld_simps]\ntheorem subtypeRestr_source : (e.subtypeRestr s).source = (\u2191) \u207b\u00b9' e.source", "start": [1382, 1], "end": [1384, 43], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.map_subtype_source", "code": "theorem map_subtype_source {x : s} (hxe : (x : \u03b1) \u2208 e.source): e x \u2208 (e.subtypeRestr s).target", "start": [1389, 1], "end": [1392, 15], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr_symm_trans_subtypeRestr", "code": "theorem subtypeRestr_symm_trans_subtypeRestr (f f' : LocalHomeomorph \u03b1 \u03b2) :\n    (f.subtypeRestr s).symm.trans (f'.subtypeRestr s) \u2248\n      (f.symm.trans f').restr (f.target \u2229 f.symm \u207b\u00b9' s)", "start": [1399, 1], "end": [1414, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.subtypeRestr_symm_eqOn_of_le", "code": "theorem subtypeRestr_symm_eqOn_of_le {U V : Opens \u03b1} [Nonempty U] [Nonempty V] (hUV : U \u2264 V) :\n    EqOn (e.subtypeRestr V).symm (Set.inclusion hUV \u2218 (e.subtypeRestr U).symm)\n      (e.subtypeRestr U).target", "start": [1417, 1], "end": [1433, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Module.lean", "imports": ["Mathlib/Data/Complex/Cardinality.lean", "Mathlib/Algebra/Order/SMul.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CharP/Invertible.lean", "Mathlib/FieldTheory/Tower.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "Complex.mulAction", "code": "instance mulAction [Monoid R] [MulAction R \u211d] : MulAction R \u2102 where\n  one_smul x := by ext <;> simp [smul_re, smul_im, one_smul]\n  mul_smul r s x := by ext <;> simp [smul_re, smul_im, mul_smul]", "start": [62, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.distribSMul", "code": "instance distribSMul [DistribSMul R \u211d] : DistribSMul R \u2102 where\n  smul_add r x y := by ext <;> simp [smul_re, smul_im, smul_add]\n  smul_zero r := by ext <;> simp [smul_re, smul_im, smul_zero]", "start": [66, 1], "end": [68, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_algebraMap", "code": "@[simp]\ntheorem coe_algebraMap : (algebraMap \u211d \u2102 : \u211d \u2192 \u2102) = ((\u2191) : \u211d \u2192 \u2102)", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_coe_real_complex", "code": "@[simp]\ntheorem _root_.AlgHom.map_coe_real_complex (f : \u2102 \u2192\u2090[\u211d] A) (x : \u211d) : f x = algebraMap \u211d A x", "start": [95, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.algHom_ext", "code": "@[ext]\ntheorem algHom_ext \u2983f g : \u2102 \u2192\u2090[\u211d] A\u2984 (h : f I = g I) : f = g", "start": [102, 1], "end": [106, 94], "kind": "commanddeclaration"}, {"full_name": "Complex.basisOneI", "code": "noncomputable def basisOneI : Basis (Fin 2) \u211d \u2102 :=\n  Basis.ofEquivFun\n    { toFun := fun z => ![z.re, z.im]\n      invFun := fun c => c 0 + c 1 \u2022 I\n      left_inv := fun z => by simp\n      right_inv := fun c => by\n        ext i\n        fin_cases i <;> simp\n      map_add' := fun z z' => by simp\n      map_smul' := fun c z => by simp }", "start": [113, 1], "end": [123, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_basisOneI_repr", "code": "@[simp]\ntheorem coe_basisOneI_repr (z : \u2102) : \u21d1(basisOneI.repr z) = ![z.re, z.im]", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_basisOneI", "code": "@[simp]\ntheorem coe_basisOneI : \u21d1basisOneI = ![1, I]", "start": [133, 1], "end": [142, 101], "kind": "commanddeclaration"}, {"full_name": "Complex.finrank_real_complex", "code": "@[simp]\ntheorem finrank_real_complex : FiniteDimensional.finrank \u211d \u2102 = 2", "start": [149, 1], "end": [151, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.rank_real_complex", "code": "@[simp]\ntheorem rank_real_complex : Module.rank \u211d \u2102 = 2", "start": [154, 1], "end": [155, 101], "kind": "commanddeclaration"}, {"full_name": "Complex.rank_real_complex'", "code": "theorem rank_real_complex'.{u} : Cardinal.lift.{u} (Module.rank \u211d \u2102) = 2", "start": [158, 1], "end": [159, 86], "kind": "commanddeclaration"}, {"full_name": "Complex.finrank_real_complex_fact", "code": "theorem finrank_real_complex_fact : Fact (finrank \u211d \u2102 = 2)", "start": [162, 1], "end": [165, 25], "kind": "commanddeclaration"}, {"full_name": "Module.complexToReal", "code": "instance (priority := 900) Module.complexToReal (E : Type*) [AddCommGroup E] [Module \u2102 E] :\n    Module \u211d E :=\n  RestrictScalars.module \u211d \u2102 E", "start": [172, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "Module.real_complex_tower", "code": "instance Module.real_complex_tower (E : Type*) [AddCommGroup E] [Module \u2102 E] :\n    IsScalarTower \u211d \u2102 E :=\n  RestrictScalars.isScalarTower \u211d \u2102 E", "start": [177, 1], "end": [179, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_smul", "code": "@[simp, norm_cast]\ntheorem Complex.coe_smul {E : Type*} [AddCommGroup E] [Module \u2102 E] (x : \u211d) (y : E) :\n    (x : \u2102) \u2022 y = x \u2022 y", "start": [182, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.complexToReal", "code": "instance (priority := 900) SMulCommClass.complexToReal {M E : Type*} [AddCommGroup E] [Module \u2102 E]\n    [SMul M E] [SMulCommClass \u2102 M E] : SMulCommClass \u211d M E where\n  smul_comm r _ _ := (smul_comm (r : \u2102) _ _ : _)", "start": [188, 1], "end": [192, 49], "kind": "commanddeclaration"}, {"full_name": "FiniteDimensional.complexToReal", "code": "instance (priority := 100) FiniteDimensional.complexToReal (E : Type*) [AddCommGroup E]\n    [Module \u2102 E] [FiniteDimensional \u2102 E] : FiniteDimensional \u211d E :=\n  FiniteDimensional.trans \u211d \u2102 E", "start": [195, 1], "end": [197, 32], "kind": "commanddeclaration"}, {"full_name": "rank_real_of_complex", "code": "theorem rank_real_of_complex (E : Type*) [AddCommGroup E] [Module \u2102 E] :\n    Module.rank \u211d E = 2 * Module.rank \u2102 E", "start": [200, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "finrank_real_of_complex", "code": "theorem finrank_real_of_complex (E : Type*) [AddCommGroup E] [Module \u2102 E] :\n    FiniteDimensional.finrank \u211d E = 2 * FiniteDimensional.finrank \u2102 E", "start": [207, 1], "end": [209, 83], "kind": "commanddeclaration"}, {"full_name": "StarModule.complexToReal", "code": "instance (priority := 900) StarModule.complexToReal {E : Type*} [AddCommGroup E] [Star E]\n    [Module \u2102 E] [StarModule \u2102 E] : StarModule \u211d E :=\n  \u27e8fun r a => by rw [\u2190 smul_one_smul \u2102 r a, star_smul, star_smul, star_one, smul_one_smul]\u27e9", "start": [212, 1], "end": [214, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.reLm", "code": "def reLm : \u2102 \u2192\u2097[\u211d] \u211d where\n  toFun x := x.re\n  map_add' := add_re\n  map_smul' := by simp", "start": [221, 1], "end": [225, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.reLm_coe", "code": "@[simp]\ntheorem reLm_coe : \u21d1reLm = re", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.imLm", "code": "def imLm : \u2102 \u2192\u2097[\u211d] \u211d where\n  toFun x := x.im\n  map_add' := add_im\n  map_smul' := by simp", "start": [233, 1], "end": [237, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.imLm_coe", "code": "@[simp]\ntheorem imLm_coe : \u21d1imLm = im", "start": [240, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealAm", "code": "def ofRealAm : \u211d \u2192\u2090[\u211d] \u2102 :=\n  Algebra.ofId \u211d \u2102", "start": [245, 1], "end": [247, 19], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealAm_coe", "code": "@[simp]\ntheorem ofRealAm_coe : \u21d1ofRealAm = ((\u2191) : \u211d \u2192 \u2102)", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conjAe", "code": "def conjAe : \u2102 \u2243\u2090[\u211d] \u2102 :=\n  { conj with\n    invFun := conj\n    left_inv := star_star\n    right_inv := star_star\n    commutes' := conj_ofReal }", "start": [255, 1], "end": [261, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.conjAe_coe", "code": "@[simp]\ntheorem conjAe_coe : \u21d1conjAe = conj", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.toMatrix_conjAe", "code": "@[simp]\ntheorem toMatrix_conjAe :\n    LinearMap.toMatrix basisOneI basisOneI conjAe.toLinearMap = !![1, 0; 0, -1]", "start": [269, 1], "end": [275, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.real_algHom_eq_id_or_conj", "code": "theorem real_algHom_eq_id_or_conj (f : \u2102 \u2192\u2090[\u211d] \u2102) : f = AlgHom.id \u211d \u2102 \u2228 f = conjAe", "start": [278, 1], "end": [283, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProdAddHom", "code": "@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdAddHom : \u2102 \u2243+ \u211d \u00d7 \u211d :=\n  { equivRealProd with map_add' := by simp }", "start": [286, 1], "end": [289, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProdLm", "code": "@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdLm : \u2102 \u2243\u2097[\u211d] \u211d \u00d7 \u211d :=\n  { equivRealProdAddHom with\n    map_smul' := fun r c => by simp [equivRealProdAddHom, (Prod.smul_def), smul_eq_mul] }", "start": [292, 1], "end": [297, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.liftAux", "code": "def liftAux (I' : A) (hf : I' * I' = -1) : \u2102 \u2192\u2090[\u211d] A :=\n  AlgHom.ofLinearMap\n    ((Algebra.linearMap \u211d A).comp reLm + (LinearMap.toSpanSingleton _ _ I').comp imLm)\n    (show algebraMap \u211d A 1 + (0 : \u211d) \u2022 I' = 1 by rw [RingHom.map_one, zero_smul, add_zero])\n    fun \u27e8x\u2081, y\u2081\u27e9 \u27e8x\u2082, y\u2082\u27e9 =>\n    show\n      algebraMap \u211d A (x\u2081 * x\u2082 - y\u2081 * y\u2082) + (x\u2081 * y\u2082 + y\u2081 * x\u2082) \u2022 I' =\n        (algebraMap \u211d A x\u2081 + y\u2081 \u2022 I') * (algebraMap \u211d A x\u2082 + y\u2082 \u2022 I') by\n      rw [add_mul, mul_add, mul_add, add_comm _ (y\u2081 \u2022 I' * y\u2082 \u2022 I'), add_add_add_comm]\n      congr 1\n      \u00b7 let inst : SMulCommClass \u211d A A := by infer_instance  rw [smul_mul_smul, hf, smul_neg, \u2190 Algebra.algebraMap_eq_smul_one, \u2190 sub_eq_add_neg, \u2190\n          RingHom.map_mul, \u2190 RingHom.map_sub]\n      \u00b7 rw [Algebra.smul_def, Algebra.smul_def, Algebra.smul_def, \u2190 Algebra.right_comm _ x\u2082, \u2190\n          mul_assoc, \u2190 add_mul, \u2190 RingHom.map_mul, \u2190 RingHom.map_mul, \u2190 RingHom.map_add]", "start": [304, 1], "end": [322, 89], "kind": "commanddeclaration"}, {"full_name": "Complex.liftAux_apply", "code": "@[simp]\ntheorem liftAux_apply (I' : A) (hI') (z : \u2102) : liftAux I' hI' z = algebraMap \u211d A z.re + z.im \u2022 I'", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.liftAux_apply_I", "code": "theorem liftAux_apply_I (I' : A) (hI') : liftAux I' hI' I = I'", "start": [330, 1], "end": [330, 74], "kind": "commanddeclaration"}, {"full_name": "Complex.lift", "code": "@[simps (config := { simpRhs := true })]\ndef lift : { I' : A // I' * I' = -1 } \u2243 (\u2102 \u2192\u2090[\u211d] A) where\n  toFun I' := liftAux I' I'.prop\n  invFun F := \u27e8F I, by rw [\u2190 F.map_mul, I_mul_I, AlgHom.map_neg, AlgHom.map_one]\u27e9\n  left_inv I' := Subtype.ext <| liftAux_apply_I (I' : A) I'.prop\n  right_inv F := algHom_ext <| liftAux_apply_I _ _", "start": [334, 1], "end": [345, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.liftAux_I", "code": "@[simp]\ntheorem liftAux_I : liftAux I I_mul_I = AlgHom.id \u211d \u2102", "start": [349, 1], "end": [351, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.liftAux_neg_I", "code": "@[simp]\ntheorem liftAux_neg_I : liftAux (-I) ((neg_mul_neg _ _).trans I_mul_I) = conjAe", "start": [356, 1], "end": [358, 56], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.negISMul", "code": "@[simps]\ndef skewAdjoint.negISMul : skewAdjoint A \u2192\u2097[\u211d] selfAdjoint A where\n  toFun a :=\n    \u27e8-I \u2022 \u2191a, by\n      simp only [neg_smul, neg_mem_iff, selfAdjoint.mem_iff, star_smul, star_def, conj_I,\n        star_val_eq, smul_neg, neg_neg]\u27e9\n  map_add' a b := by\n    ext\n    simp only [AddSubgroup.coe_add, smul_add, AddMemClass.mk_add_mk]\n  map_smul' a b := by\n    ext\n    simp only [neg_smul, skewAdjoint.val_smul, AddSubgroup.coe_mk, RingHom.id_apply,\n      selfAdjoint.val_smul, smul_neg, neg_inj]\n    rw [smul_comm]", "start": [372, 1], "end": [387, 19], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.I_smul_neg_I", "code": "theorem skewAdjoint.I_smul_neg_I (a : skewAdjoint A) : I \u2022 (skewAdjoint.negISMul a : A) = a", "start": [391, 1], "end": [393, 13], "kind": "commanddeclaration"}, {"full_name": "realPart", "code": "noncomputable def realPart : A \u2192\u2097[\u211d] selfAdjoint A :=\n  selfAdjointPart \u211d", "start": [397, 1], "end": [401, 20], "kind": "commanddeclaration"}, {"full_name": "imaginaryPart", "code": "noncomputable def imaginaryPart : A \u2192\u2097[\u211d] selfAdjoint A :=\n  skewAdjoint.negISMul.comp (skewAdjointPart \u211d)", "start": [404, 1], "end": [410, 48], "kind": "commanddeclaration"}, {"full_name": "realPart_apply_coe", "code": "theorem realPart_apply_coe (a : A) : (\u211c a : A) = (2 : \u211d)\u207b\u00b9 \u2022 (a + star a)", "start": [420, 1], "end": [422, 54], "kind": "commanddeclaration"}, {"full_name": "imaginaryPart_apply_coe", "code": "theorem imaginaryPart_apply_coe (a : A) : (\u2111 a : A) = -I \u2022 (2 : \u211d)\u207b\u00b9 \u2022 (a - star a)", "start": [425, 1], "end": [428, 55], "kind": "commanddeclaration"}, {"full_name": "realPart_add_I_smul_imaginaryPart", "code": "theorem realPart_add_I_smul_imaginaryPart (a : A) : (\u211c a : A) + I \u2022 (\u2111 a : A) = a", "start": [431, 1], "end": [436, 42], "kind": "commanddeclaration"}, {"full_name": "realPart_I_smul", "code": "@[simp]\ntheorem realPart_I_smul (a : A) : \u211c (I \u2022 a) = -\u2111 a", "start": [440, 1], "end": [446, 82], "kind": "commanddeclaration"}, {"full_name": "imaginaryPart_I_smul", "code": "@[simp]\ntheorem imaginaryPart_I_smul (a : A) : \u2111 (I \u2022 a) = \u211c a", "start": [450, 1], "end": [456, 21], "kind": "commanddeclaration"}, {"full_name": "realPart_smul", "code": "theorem realPart_smul (z : \u2102) (a : A) : \u211c (z \u2022 a) = z.re \u2022 \u211c a - z.im \u2022 \u2111 a", "start": [460, 1], "end": [462, 60], "kind": "commanddeclaration"}, {"full_name": "imaginaryPart_smul", "code": "theorem imaginaryPart_smul (z : \u2102) (a : A) : \u2111 (z \u2022 a) = z.re \u2022 \u2111 a + z.im \u2022 \u211c a", "start": [465, 1], "end": [467, 44], "kind": "commanddeclaration"}, {"full_name": "skewAdjointPart_eq_I_smul_imaginaryPart", "code": "lemma skewAdjointPart_eq_I_smul_imaginaryPart (x : A) :\n    (skewAdjointPart \u211d x : A) = I \u2022 (imaginaryPart x : A) := by\n  simp [imaginaryPart_apply_coe, smul_smul]", "start": [470, 1], "end": [472, 44], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_eq_neg_I_smul_skewAdjointPart", "code": "lemma imaginaryPart_eq_neg_I_smul_skewAdjointPart (x : A) :\n    (imaginaryPart x : A) = -I \u2022 (skewAdjointPart \u211d x : A) :=\n  rfl", "start": [474, 1], "end": [476, 6], "kind": "mathlibtacticlemma"}, {"full_name": "IsSelfAdjoint.coe_realPart", "code": "lemma IsSelfAdjoint.coe_realPart {x : A} (hx : IsSelfAdjoint x) :\n    (\u211c x : A) = x :=\n  hx.coe_selfAdjointPart_apply \u211d", "start": [478, 1], "end": [480, 33], "kind": "mathlibtacticlemma"}, {"full_name": "IsSelfAdjoint.imaginaryPart", "code": "lemma IsSelfAdjoint.imaginaryPart {x : A} (hx : IsSelfAdjoint x) :\n    \u2111 x = 0 := by\n  rw [imaginaryPart, LinearMap.comp_apply, hx.skewAdjointPart_apply _, map_zero]", "start": [482, 1], "end": [484, 81], "kind": "mathlibtacticlemma"}, {"full_name": "realPart_comp_subtype_selfAdjoint", "code": "lemma realPart_comp_subtype_selfAdjoint :\n    realPart.comp (selfAdjoint.submodule \u211d A).subtype = LinearMap.id :=\n  selfAdjointPart_comp_subtype_selfAdjoint \u211d", "start": [486, 1], "end": [488, 45], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_comp_subtype_selfAdjoint", "code": "lemma imaginaryPart_comp_subtype_selfAdjoint :\n    imaginaryPart.comp (selfAdjoint.submodule \u211d A).subtype = 0 := by\n  rw [imaginaryPart, LinearMap.comp_assoc, skewAdjointPart_comp_subtype_selfAdjoint,\n    LinearMap.comp_zero]", "start": [490, 1], "end": [493, 25], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_realPart", "code": "@[simp]\nlemma imaginaryPart_realPart {x : A} : \u2111 (\u211c x : A) = 0 :=\n  (\u211c x).property.imaginaryPart", "start": [495, 1], "end": [497, 31], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_imaginaryPart", "code": "@[simp]\nlemma imaginaryPart_imaginaryPart {x : A} : \u2111 (\u2111 x : A) = 0 :=\n  (\u2111 x).property.imaginaryPart", "start": [499, 1], "end": [501, 31], "kind": "mathlibtacticlemma"}, {"full_name": "realPart_idem", "code": "@[simp]\nlemma realPart_idem {x : A} : \u211c (\u211c x : A) = \u211c x :=\n  Subtype.ext <| (\u211c x).property.coe_realPart", "start": [503, 1], "end": [505, 45], "kind": "mathlibtacticlemma"}, {"full_name": "realPart_imaginaryPart", "code": "@[simp]\nlemma realPart_imaginaryPart {x : A} : \u211c (\u2111 x : A) = \u2111 x :=\n  Subtype.ext <| (\u2111 x).property.coe_realPart", "start": [507, 1], "end": [509, 45], "kind": "mathlibtacticlemma"}, {"full_name": "realPart_surjective", "code": "lemma realPart_surjective : Function.Surjective (realPart (A := A)) :=\n  fun x \u21a6 \u27e8(x : A), Subtype.ext x.property.coe_realPart\u27e9", "start": [511, 1], "end": [512, 57], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_surjective", "code": "lemma imaginaryPart_surjective : Function.Surjective (imaginaryPart (A := A)) :=\n  fun x \u21a6\n    \u27e8I \u2022 (x : A), Subtype.ext <| by simp only [imaginaryPart_I_smul, x.property.coe_realPart]\u27e9", "start": [514, 1], "end": [516, 95], "kind": "mathlibtacticlemma"}, {"full_name": "span_selfAdjoint", "code": "lemma span_selfAdjoint : span \u2102 (selfAdjoint A : Set A) = \u22a4 := by\n  refine eq_top_iff'.mpr fun x \u21a6 ?_\n  rw [\u2190realPart_add_I_smul_imaginaryPart x]\n  exact add_mem (subset_span (\u211c x).property) <|\n    SMulMemClass.smul_mem _ <| subset_span (\u2111 x).property", "start": [520, 1], "end": [524, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Complex.selfAdjointEquiv", "code": "@[simps apply symm_apply]\ndef Complex.selfAdjointEquiv : selfAdjoint \u2102 \u2243\u2097[\u211d] \u211d where\n  toFun := fun z \u21a6 (z : \u2102).re\n  invFun := fun x \u21a6 \u27e8x, conj_ofReal x\u27e9\n  left_inv := fun z \u21a6 Subtype.ext <| conj_eq_iff_re.mp z.property.star_eq\n  right_inv := fun x \u21a6 rfl\n  map_add' := by simp\n  map_smul' := by simp", "start": [526, 1], "end": [534, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.coe_selfAdjointEquiv", "code": "lemma Complex.coe_selfAdjointEquiv (z : selfAdjoint \u2102) :\n    (selfAdjointEquiv z : \u2102) = z := by\n  simpa [selfAdjointEquiv_symm_apply]\n    using (congr_arg Subtype.val <| Complex.selfAdjointEquiv.left_inv z)", "start": [536, 1], "end": [539, 73], "kind": "mathlibtacticlemma"}, {"full_name": "realPart_ofReal", "code": "@[simp]\nlemma realPart_ofReal (r : \u211d) : (\u211c (r : \u2102) : \u2102) = r := by\n  rw [realPart_apply_coe, star_def, conj_ofReal, \u2190two_smul \u211d (r : \u2102)]\n  simp", "start": [541, 1], "end": [544, 7], "kind": "mathlibtacticlemma"}, {"full_name": "imaginaryPart_ofReal", "code": "@[simp]\nlemma imaginaryPart_ofReal (r : \u211d) : \u2111 (r : \u2102) = 0 := by\n  ext1; simp [imaginaryPart_apply_coe, conj_ofReal]", "start": [546, 1], "end": [548, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Complex.coe_realPart", "code": "lemma Complex.coe_realPart (z : \u2102) : (\u211c z : \u2102) = z.re := calc\n  (\u211c z : \u2102) = _    := by congrm (\u211c $((re_add_im z).symm))\n  _          = z.re := by\n    rw [map_add, AddSubmonoid.coe_add, mul_comm, \u2190smul_eq_mul, realPart_I_smul]\n    simp [conj_ofReal, \u2190two_mul]", "start": [550, 1], "end": [554, 33], "kind": "mathlibtacticlemma"}, {"full_name": "Real.rank_rat_real", "code": "@[simp]\nlemma Real.rank_rat_real : Module.rank \u211a \u211d = continuum := by\n  refine (Free.rank_eq_mk_of_infinite_lt \u211a \u211d ?_).trans mk_real\n  simpa [mk_real] using aleph0_lt_continuum", "start": [561, 1], "end": [564, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Complex.rank_rat_complex", "code": "@[simp]\nlemma Complex.rank_rat_complex : Module.rank \u211a \u2102 = continuum := by\n  refine (Free.rank_eq_mk_of_infinite_lt \u211a \u2102 ?_).trans mk_complex\n  simpa using aleph0_lt_continuum", "start": [566, 1], "end": [569, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Complex.nonempty_linearEquiv_real", "code": "theorem Complex.nonempty_linearEquiv_real : Nonempty (\u2102 \u2243\u2097[\u211a] \u211d)", "start": [571, 1], "end": [574, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/ContinuousLinearMap.lean", "imports": ["Mathlib/Analysis/NormedSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.mkContinuous", "code": "def LinearMap.mkContinuous (C : \u211d) (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : E \u2192SL[\u03c3] F :=\n  \u27e8f, AddMonoidHomClass.continuous_of_bound f C h\u27e9", "start": [50, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuousOfExistsBound", "code": "def LinearMap.mkContinuousOfExistsBound (h : \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) : E \u2192SL[\u03c3] F :=\n  \u27e8f,\n    let \u27e8C, hC\u27e9 := h\n    AddMonoidHomClass.continuous_of_bound f C hC\u27e9", "start": [57, 1], "end": [63, 50], "kind": "commanddeclaration"}, {"full_name": "continuous_of_linear_of_bound\u209b\u2097", "code": "theorem continuous_of_linear_of_bound\u209b\u2097 {f : E \u2192 F} (h_add : \u2200 x y, f (x + y) = f x + f y)\n    (h_smul : \u2200 (c : \ud835\udd5c) (x), f (c \u2022 x) = \u03c3 c \u2022 f x) {C : \u211d} (h_bound : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    Continuous f", "start": [66, 1], "end": [73, 52], "kind": "commanddeclaration"}, {"full_name": "continuous_of_linear_of_bound", "code": "theorem continuous_of_linear_of_bound {f : E \u2192 G} (h_add : \u2200 x y, f (x + y) = f x + f y)\n    (h_smul : \u2200 (c : \ud835\udd5c) (x), f (c \u2022 x) = c \u2022 f x) {C : \u211d} (h_bound : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    Continuous f", "start": [76, 1], "end": [83, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous_coe", "code": "@[simp, norm_cast]\ntheorem LinearMap.mkContinuous_coe (C : \u211d) (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    (f.mkContinuous C h : E \u2192\u209b\u2097[\u03c3] F) = f", "start": [86, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuous_apply", "code": "@[simp]\ntheorem LinearMap.mkContinuous_apply (C : \u211d) (h : \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) (x : E) :\n    f.mkContinuous C h x = f x", "start": [92, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuousOfExistsBound_coe", "code": "@[simp, norm_cast]\ntheorem LinearMap.mkContinuousOfExistsBound_coe (h : \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) :\n    (f.mkContinuousOfExistsBound h : E \u2192\u209b\u2097[\u03c3] F) = f", "start": [98, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mkContinuousOfExistsBound_apply", "code": "@[simp]\ntheorem LinearMap.mkContinuousOfExistsBound_apply (h : \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C * \u2016x\u2016) (x : E) :\n    f.mkContinuousOfExistsBound h x = f x", "start": [104, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.antilipschitz_of_bound", "code": "theorem antilipschitz_of_bound (f : E \u2192SL[\u03c3] F) {K : \u211d\u22650} (h : \u2200 x, \u2016x\u2016 \u2264 K * \u2016f x\u2016) :\n    AntilipschitzWith K f", "start": [112, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.bound_of_antilipschitz", "code": "theorem bound_of_antilipschitz (f : E \u2192SL[\u03c3] F) {K : \u211d\u22650} (h : AntilipschitzWith K f) (x) :\n    \u2016x\u2016 \u2264 K * \u2016f x\u2016", "start": [117, 1], "end": [119, 44], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toContinuousLinearEquivOfBounds", "code": "def LinearEquiv.toContinuousLinearEquivOfBounds (e : E \u2243\u209b\u2097[\u03c3] F) (C_to C_inv : \u211d)\n    (h_to : \u2200 x, \u2016e x\u2016 \u2264 C_to * \u2016x\u2016) (h_inv : \u2200 x : F, \u2016e.symm x\u2016 \u2264 C_inv * \u2016x\u2016) : E \u2243SL[\u03c3] F where\n  toLinearEquiv := e\n  continuous_toFun := AddMonoidHomClass.continuous_of_bound e C_to h_to\n  continuous_invFun := AddMonoidHomClass.continuous_of_bound e.symm C_inv h_inv", "start": [128, 1], "end": [134, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toContinuousLinearMap\u2081", "code": "def LinearMap.toContinuousLinearMap\u2081 (f : \ud835\udd5c \u2192\u2097[\ud835\udd5c] E) : \ud835\udd5c \u2192L[\ud835\udd5c] E :=\n  f.mkContinuous \u2016f 1\u2016 fun x => by\n    conv_lhs => rw [\u2190 mul_one x]\n    rw [\u2190 smul_eq_mul, f.map_smul, mul_comm]; exact norm_smul_le _ _", "start": [145, 1], "end": [151, 69], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toContinuousLinearMap\u2081_coe", "code": "@[simp]\ntheorem LinearMap.toContinuousLinearMap\u2081_coe (f : \ud835\udd5c \u2192\u2097[\ud835\udd5c] E) :\n    (f.toContinuousLinearMap\u2081 : \ud835\udd5c \u2192\u2097[\ud835\udd5c] E) = f", "start": [154, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toContinuousLinearMap\u2081_apply", "code": "@[simp]\ntheorem LinearMap.toContinuousLinearMap\u2081_apply (f : \ud835\udd5c \u2192\u2097[\ud835\udd5c] E) (x) :\n    f.toContinuousLinearMap\u2081 x = f x", "start": [160, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.uniformEmbedding_of_bound", "code": "theorem ContinuousLinearMap.uniformEmbedding_of_bound {K : \u211d\u22650} (hf : \u2200 x, \u2016x\u2016 \u2264 K * \u2016f x\u2016) :\n    UniformEmbedding f", "start": [173, 1], "end": [175, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.ofHomothety", "code": "def ContinuousLinearMap.ofHomothety (f : E \u2192\u209b\u2097[\u03c3] F) (a : \u211d) (hf : \u2200 x, \u2016f x\u2016 = a * \u2016x\u2016) :\n    E \u2192SL[\u03c3] F :=\n  f.mkContinuous a fun x => le_of_eq (hf x)", "start": [188, 1], "end": [195, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.homothety_inverse", "code": "theorem ContinuousLinearEquiv.homothety_inverse (a : \u211d) (ha : 0 < a) (f : E \u2243\u209b\u2097[\u03c3] F) :\n    (\u2200 x : E, \u2016f x\u2016 = a * \u2016x\u2016) \u2192 \u2200 y : F, \u2016f.symm y\u2016 = a\u207b\u00b9 * \u2016y\u2016", "start": [200, 1], "end": [207, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.ofHomothety", "code": "noncomputable def ContinuousLinearEquiv.ofHomothety (f : E \u2243\u209b\u2097[\u03c3] F) (a : \u211d) (ha : 0 < a)\n    (hf : \u2200 x, \u2016f x\u2016 = a * \u2016x\u2016) : E \u2243SL[\u03c3] F :=\n  LinearEquiv.toContinuousLinearEquivOfBounds f a a\u207b\u00b9 (fun x => (hf x).le) fun x =>\n    (ContinuousLinearEquiv.homothety_inverse a ha f hf x).le", "start": [210, 1], "end": [214, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toSpanSingleton_homothety", "code": "theorem toSpanSingleton_homothety (x : E) (c : \ud835\udd5c) :\n    \u2016LinearMap.toSpanSingleton \ud835\udd5c E x c\u2016 = \u2016x\u2016 * \u2016c\u2016", "start": [229, 1], "end": [232, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toSpanNonzeroSingleton_homothety", "code": "theorem toSpanNonzeroSingleton_homothety (x : E) (h : x \u2260 0) (c : \ud835\udd5c) :\n    \u2016LinearEquiv.toSpanNonzeroSingleton \ud835\udd5c E x h c\u2016 = \u2016x\u2016 * \u2016c\u2016", "start": [246, 1], "end": [248, 54], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toSpanNonzeroSingleton", "code": "noncomputable def toSpanNonzeroSingleton (x : E) (h : x \u2260 0) : \ud835\udd5c \u2243L[\ud835\udd5c] \ud835\udd5c \u2219 x :=\n  ofHomothety (LinearEquiv.toSpanNonzeroSingleton \ud835\udd5c E x h) \u2016x\u2016 (norm_pos_iff.mpr h)\n    (toSpanNonzeroSingleton_homothety \ud835\udd5c x h)", "start": [256, 1], "end": [260, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coord", "code": "noncomputable def coord (x : E) (h : x \u2260 0) : (\ud835\udd5c \u2219 x) \u2192L[\ud835\udd5c] \ud835\udd5c :=\n  (toSpanNonzeroSingleton \ud835\udd5c x h).symm", "start": [263, 1], "end": [266, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coe_toSpanNonzeroSingleton_symm", "code": "@[simp]\ntheorem coe_toSpanNonzeroSingleton_symm {x : E} (h : x \u2260 0) :\n    \u21d1(toSpanNonzeroSingleton \ud835\udd5c x h).symm = coord \ud835\udd5c x h", "start": [269, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coord_toSpanNonzeroSingleton", "code": "@[simp]\ntheorem coord_toSpanNonzeroSingleton {x : E} (h : x \u2260 0) (c : \ud835\udd5c) :\n    coord \ud835\udd5c x h (toSpanNonzeroSingleton \ud835\udd5c x h c) = c", "start": [275, 1], "end": [278, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.toSpanNonzeroSingleton_coord", "code": "@[simp]\ntheorem toSpanNonzeroSingleton_coord {x : E} (h : x \u2260 0) (y : \ud835\udd5c \u2219 x) :\n    toSpanNonzeroSingleton \ud835\udd5c x h (coord \ud835\udd5c x h y) = y", "start": [281, 1], "end": [284, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.coord_self", "code": "@[simp]\ntheorem coord_self (x : E) (h : x \u2260 0) :\n    (coord \ud835\udd5c x h) (\u27e8x, Submodule.mem_span_singleton_self x\u27e9 : \ud835\udd5c \u2219 x) = 1", "start": [287, 1], "end": [290, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/Topology/Algebra/StarSubalgebra.lean", "Mathlib/Algebra/Star/SelfAdjoint.lean", "Mathlib/Topology/Algebra/Module/Star.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Algebra/Star/Unitary.lean", "Mathlib/Analysis/NormedSpace/LinearIsometry.lean"], "premises": [{"full_name": "NormedStarGroup", "code": "class NormedStarGroup (E : Type*) [SeminormedAddCommGroup E] [StarAddMonoid E] : Prop where\n  norm_star : \u2200 x : E, \u2016x\u22c6\u2016 = \u2016x\u2016", "start": [41, 1], "end": [43, 34], "kind": "commanddeclaration"}, {"full_name": "nnnorm_star", "code": "@[simp]\ntheorem nnnorm_star (x : E) : \u2016star x\u2016\u208a = \u2016x\u2016\u208a", "start": [56, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "starNormedAddGroupHom", "code": "def starNormedAddGroupHom : NormedAddGroupHom E E :=\n  { starAddEquiv with bound' := \u27e81, fun _ => le_trans (norm_star _).le (one_mul _).symm.le\u27e9 }", "start": [61, 1], "end": [63, 94], "kind": "commanddeclaration"}, {"full_name": "star_isometry", "code": "theorem star_isometry : Isometry (star : E \u2192 E)", "start": [66, 1], "end": [69, 90], "kind": "commanddeclaration"}, {"full_name": "NormedStarGroup.to_continuousStar", "code": "instance (priority := 100) NormedStarGroup.to_continuousStar : ContinuousStar E :=\n  \u27e8star_isometry.continuous\u27e9", "start": [72, 1], "end": [73, 29], "kind": "commanddeclaration"}, {"full_name": "RingHomIsometric.starRingEnd", "code": "instance RingHomIsometric.starRingEnd [NormedCommRing E] [StarRing E] [NormedStarGroup E] :\n    RingHomIsometric (starRingEnd E) :=\n  \u27e8@norm_star _ _ _ _\u27e9", "start": [78, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "CstarRing", "code": "class CstarRing (E : Type*) [NonUnitalNormedRing E] [StarRing E] : Prop where\n  norm_star_mul_self : \u2200 {x : E}, \u2016x\u22c6 * x\u2016 = \u2016x\u2016 * \u2016x\u2016", "start": [83, 1], "end": [86, 55], "kind": "commanddeclaration"}, {"full_name": "CstarRing.to_normedStarGroup", "code": "instance (priority := 100) to_normedStarGroup : NormedStarGroup E :=\n  \u27e8by\n    intro x\n    by_cases htriv : x = 0\n    \u00b7 simp only [htriv, star_zero]\n    \u00b7 have hnt : 0 < \u2016x\u2016 := norm_pos_iff.mpr htriv\n      have hnt_star : 0 < \u2016x\u22c6\u2016 :=\n        norm_pos_iff.mpr ((AddEquiv.map_ne_zero_iff starAddEquiv (M := E)).mpr htriv)\n      have h\u2081 :=\n        calc\n          \u2016x\u2016 * \u2016x\u2016 = \u2016x\u22c6 * x\u2016 := norm_star_mul_self.symm\n          _ \u2264 \u2016x\u22c6\u2016 * \u2016x\u2016 := norm_mul_le _ _\n      have h\u2082 :=\n        calc\n          \u2016x\u22c6\u2016 * \u2016x\u22c6\u2016 = \u2016x * x\u22c6\u2016 := by rw [\u2190 norm_star_mul_self, star_star]\n          _ \u2264 \u2016x\u2016 * \u2016x\u22c6\u2016 := norm_mul_le _ _\n      exact le_antisymm (le_of_mul_le_mul_right h\u2082 hnt_star) (le_of_mul_le_mul_right h\u2081 hnt)\u27e9", "start": [98, 1], "end": [115, 94], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_self_mul_star", "code": "theorem norm_self_mul_star {x : E} : \u2016x * x\u22c6\u2016 = \u2016x\u2016 * \u2016x\u2016", "start": [118, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_star_mul_self'", "code": "theorem norm_star_mul_self' {x : E} : \u2016x\u22c6 * x\u2016 = \u2016x\u22c6\u2016 * \u2016x\u2016", "start": [123, 1], "end": [123, 101], "kind": "commanddeclaration"}, {"full_name": "CstarRing.nnnorm_self_mul_star", "code": "theorem nnnorm_self_mul_star {x : E} : \u2016x * x\u22c6\u2016\u208a = \u2016x\u2016\u208a * \u2016x\u2016\u208a", "start": [126, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "CstarRing.nnnorm_star_mul_self", "code": "theorem nnnorm_star_mul_self {x : E} : \u2016x\u22c6 * x\u2016\u208a = \u2016x\u2016\u208a * \u2016x\u2016\u208a", "start": [130, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "CstarRing.star_mul_self_eq_zero_iff", "code": "@[simp]\ntheorem star_mul_self_eq_zero_iff (x : E) : x\u22c6 * x = 0 \u2194 x = 0", "start": [134, 1], "end": [137, 44], "kind": "commanddeclaration"}, {"full_name": "CstarRing.star_mul_self_ne_zero_iff", "code": "theorem star_mul_self_ne_zero_iff (x : E) : x\u22c6 * x \u2260 0 \u2194 x \u2260 0", "start": [140, 1], "end": [141, 48], "kind": "commanddeclaration"}, {"full_name": "CstarRing.mul_star_self_eq_zero_iff", "code": "@[simp]\ntheorem mul_star_self_eq_zero_iff (x : E) : x * x\u22c6 = 0 \u2194 x = 0", "start": [144, 1], "end": [146, 89], "kind": "commanddeclaration"}, {"full_name": "CstarRing.mul_star_self_ne_zero_iff", "code": "theorem mul_star_self_ne_zero_iff (x : E) : x * x\u22c6 \u2260 0 \u2194 x \u2260 0", "start": [149, 1], "end": [150, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.starRing'", "code": "instance _root_.Pi.starRing' : StarRing (\u2200 i, R i) :=\n  inferInstance", "start": [165, 1], "end": [168, 16], "kind": "commanddeclaration"}, {"full_name": "Prod.cstarRing", "code": "instance _root_.Prod.cstarRing : CstarRing (R\u2081 \u00d7 R\u2082) where\n  norm_star_mul_self {x} := by\n    dsimp only [norm]\n    simp only [Prod.fst_mul, Prod.fst_star, Prod.snd_mul, Prod.snd_star, norm_star_mul_self, \u2190 sq]\n    refine' le_antisymm _ _\n    \u00b7 refine' max_le _ _ <;> rw [sq_le_sq, abs_of_nonneg (norm_nonneg _)]\n      exact (le_max_left _ _).trans (le_abs_self _)\n      exact (le_max_right _ _).trans (le_abs_self _)\n    \u00b7 rw [le_sup_iff]\n      rcases le_total \u2016x.fst\u2016 \u2016x.snd\u2016 with (h | h) <;> simp [h]", "start": [173, 1], "end": [182, 64], "kind": "commanddeclaration"}, {"full_name": "Pi.cstarRing", "code": "instance _root_.Pi.cstarRing : CstarRing (\u2200 i, R i) where\n  norm_star_mul_self {x} := by\n    simp only [norm, Pi.mul_apply, Pi.star_apply, nnnorm_star_mul_self, \u2190 sq]\n    norm_cast\n    exact\n      (Finset.comp_sup_eq_sup_comp_of_is_total (fun x : NNReal => x ^ 2)\n          (fun x y h => by simpa only [sq] using mul_le_mul' h h) (by simp)).symm", "start": [185, 1], "end": [191, 82], "kind": "commanddeclaration"}, {"full_name": "Pi.cstarRing'", "code": "instance _root_.Pi.cstarRing' : CstarRing (\u03b9 \u2192 R\u2081) :=\n  Pi.cstarRing", "start": [194, 1], "end": [195, 15], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_one", "code": "@[simp, nolint simpNF] theorem norm_one [Nontrivial E] : \u2016(1 : E)\u2016 = 1", "start": [205, 1], "end": [208, 82], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_coe_unitary", "code": "theorem norm_coe_unitary [Nontrivial E] (U : unitary E) : \u2016(U : E)\u2016 = 1", "start": [215, 1], "end": [217, 51], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_of_mem_unitary", "code": "@[simp]\ntheorem norm_of_mem_unitary [Nontrivial E] {U : E} (hU : U \u2208 unitary E) : \u2016U\u2016 = 1", "start": [220, 1], "end": [222, 27], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_coe_unitary_mul", "code": "@[simp]\ntheorem norm_coe_unitary_mul (U : unitary E) (A : E) : \u2016(U : E) * A\u2016 = \u2016A\u2016", "start": [225, 1], "end": [237, 72], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_unitary_smul", "code": "@[simp]\ntheorem norm_unitary_smul (U : unitary E) (A : E) : \u2016U \u2022 A\u2016 = \u2016A\u2016", "start": [240, 1], "end": [242, 27], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_mem_unitary_mul", "code": "theorem norm_mem_unitary_mul {U : E} (A : E) (hU : U \u2208 unitary E) : \u2016U * A\u2016 = \u2016A\u2016", "start": [245, 1], "end": [246, 33], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_mul_coe_unitary", "code": "@[simp]\ntheorem norm_mul_coe_unitary (A : E) (U : unitary E) : \u2016A * U\u2016 = \u2016A\u2016", "start": [249, 1], "end": [255, 27], "kind": "commanddeclaration"}, {"full_name": "CstarRing.norm_mul_mem_unitary", "code": "theorem norm_mul_mem_unitary (A : E) {U : E} (hU : U \u2208 unitary E) : \u2016A * U\u2016 = \u2016A\u2016", "start": [258, 1], "end": [259, 33], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.nnnorm_pow_two_pow", "code": "theorem IsSelfAdjoint.nnnorm_pow_two_pow [NormedRing E] [StarRing E] [CstarRing E] {x : E}\n    (hx : IsSelfAdjoint x) (n : \u2115) : \u2016x ^ 2 ^ n\u2016\u208a = \u2016x\u2016\u208a ^ 2 ^ n", "start": [266, 1], "end": [272, 72], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.nnnorm_pow_two_pow", "code": "theorem selfAdjoint.nnnorm_pow_two_pow [NormedRing E] [StarRing E] [CstarRing E] (x : selfAdjoint E)\n    (n : \u2115) : \u2016x ^ 2 ^ n\u2016\u208a = \u2016x\u2016\u208a ^ 2 ^ n", "start": [275, 1], "end": [277, 30], "kind": "commanddeclaration"}, {"full_name": "star\u2097\u1d62", "code": "def star\u2097\u1d62 : E \u2243\u2097\u1d62\u22c6[\ud835\udd5c] E :=\n  { starAddEquiv with\n    map_smul' := star_smul\n    norm_map' := norm_star }", "start": [290, 1], "end": [294, 29], "kind": "commanddeclaration"}, {"full_name": "coe_star\u2097\u1d62", "code": "@[simp]\ntheorem coe_star\u2097\u1d62 : (star\u2097\u1d62 \ud835\udd5c : E \u2192 E) = star", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "star\u2097\u1d62_apply", "code": "theorem star\u2097\u1d62_apply {x : E} : star\u2097\u1d62 \ud835\udd5c x = star x", "start": [304, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "star\u2097\u1d62_toContinuousLinearEquiv", "code": "@[simp]\ntheorem star\u2097\u1d62_toContinuousLinearEquiv :\n    (star\u2097\u1d62 \ud835\udd5c : E \u2243\u2097\u1d62\u22c6[\ud835\udd5c] E).toContinuousLinearEquiv = (starL \ud835\udd5c : E \u2243L\u22c6[\ud835\udd5c] E)", "start": [308, 1], "end": [311, 32], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.toNormedAlgebra", "code": "instance toNormedAlgebra {\ud835\udd5c A : Type*} [NormedField \ud835\udd5c] [StarRing \ud835\udd5c] [SeminormedRing A] [StarRing A]\n    [NormedAlgebra \ud835\udd5c A] [StarModule \ud835\udd5c A] (S : StarSubalgebra \ud835\udd5c A) : NormedAlgebra \ud835\udd5c S :=\n  @NormedAlgebra.induced _ \ud835\udd5c S A _ (SubringClass.toRing S) S.algebra _ _ _ S.subtype", "start": [318, 1], "end": [320, 85], "kind": "commanddeclaration"}, {"full_name": "StarSubalgebra.to_cstarRing", "code": "instance to_cstarRing {R A} [CommRing R] [StarRing R] [NormedRing A] [StarRing A] [CstarRing A]\n    [Algebra R A] [StarModule R A] (S : StarSubalgebra R A) : CstarRing S where\n  norm_star_mul_self {x} := @CstarRing.norm_star_mul_self A _ _ _ x", "start": [323, 1], "end": [325, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Instances.lean", "imports": ["Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Algebra/Ring/Regular.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Icc.zero", "code": "instance zero : Zero (Icc (0 : \u03b1) 1) where zero := \u27e80, left_mem_Icc.2 zero_le_one\u27e9", "start": [51, 1], "end": [51, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.one", "code": "instance one : One (Icc (0 : \u03b1) 1) where one := \u27e81, right_mem_Icc.2 zero_le_one\u27e9", "start": [54, 1], "end": [54, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u2191(0 : Icc (0 : \u03b1) 1) = (0 : \u03b1)", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : \u2191(1 : Icc (0 : \u03b1) 1) = (1 : \u03b1)", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mk_zero", "code": "@[simp]\ntheorem mk_zero (h : (0 : \u03b1) \u2208 Icc (0 : \u03b1) 1) : (\u27e80, h\u27e9 : Icc (0 : \u03b1) 1) = 0", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mk_one", "code": "@[simp]\ntheorem mk_one (h : (1 : \u03b1) \u2208 Icc (0 : \u03b1) 1) : (\u27e81, h\u27e9 : Icc (0 : \u03b1) 1) = 1", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_eq_zero {x : Icc (0 : \u03b1) 1} : (x : \u03b1) = 0 \u2194 x = 0", "start": [77, 1], "end": [80, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_ne_zero", "code": "theorem coe_ne_zero {x : Icc (0 : \u03b1) 1} : (x : \u03b1) \u2260 0 \u2194 x \u2260 0", "start": [83, 1], "end": [84, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_eq_one", "code": "@[simp, norm_cast]\ntheorem coe_eq_one {x : Icc (0 : \u03b1) 1} : (x : \u03b1) = 1 \u2194 x = 1", "start": [87, 1], "end": [90, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_ne_one", "code": "theorem coe_ne_one {x : Icc (0 : \u03b1) 1} : (x : \u03b1) \u2260 1 \u2194 x \u2260 1", "start": [93, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_nonneg", "code": "theorem coe_nonneg (x : Icc (0 : \u03b1) 1) : 0 \u2264 (x : \u03b1)", "start": [97, 1], "end": [98, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_le_one", "code": "theorem coe_le_one (x : Icc (0 : \u03b1) 1) : (x : \u03b1) \u2264 1", "start": [101, 1], "end": [102, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.nonneg", "code": "theorem nonneg {t : Icc (0 : \u03b1) 1} : 0 \u2264 t", "start": [105, 1], "end": [107, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.le_one", "code": "theorem le_one {t : Icc (0 : \u03b1) 1} : t \u2264 1", "start": [110, 1], "end": [112, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mul", "code": "instance mul : Mul (Icc (0 : \u03b1) 1) where\n  mul p q := \u27e8p * q, \u27e8mul_nonneg p.2.1 q.2.1, mul_le_one p.2.2 q.2.1 q.2.2\u27e9\u27e9", "start": [115, 1], "end": [116, 77], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.pow", "code": "instance pow : Pow (Icc (0 : \u03b1) 1) \u2115 where\n  pow p n := \u27e8p.1 ^ n, \u27e8pow_nonneg p.2.1 n, pow_le_one n p.2.1 p.2.2\u27e9\u27e9", "start": [119, 1], "end": [120, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : Icc (0 : \u03b1) 1) : \u2191(x * y) = (x * y : \u03b1)", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : Icc (0 : \u03b1) 1) (n : \u2115) : \u2191(x ^ n) = ((x : \u03b1) ^ n)", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mul_le_left", "code": "theorem mul_le_left {x y : Icc (0 : \u03b1) 1} : x * y \u2264 x", "start": [133, 1], "end": [134, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mul_le_right", "code": "theorem mul_le_right {x y : Icc (0 : \u03b1) 1} : x * y \u2264 y", "start": [137, 1], "end": [138, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.monoidWithZero", "code": "instance monoidWithZero : MonoidWithZero (Icc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.monoidWithZero _ coe_zero coe_one coe_mul coe_pow", "start": [141, 1], "end": [142, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.commMonoidWithZero", "code": "instance commMonoidWithZero {\u03b1 : Type*} [OrderedCommSemiring \u03b1] :\n    CommMonoidWithZero (Icc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.commMonoidWithZero _ coe_zero coe_one coe_mul coe_pow", "start": [145, 1], "end": [147, 78], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.cancelMonoidWithZero", "code": "instance cancelMonoidWithZero {\u03b1 : Type*} [OrderedRing \u03b1] [NoZeroDivisors \u03b1] :\n    CancelMonoidWithZero (Icc (0 : \u03b1) 1) :=\n  @Function.Injective.cancelMonoidWithZero \u03b1 _ NoZeroDivisors.toCancelMonoidWithZero _ _ _ _\n    (fun v => v.val) Subtype.coe_injective coe_zero coe_one coe_mul coe_pow", "start": [150, 1], "end": [153, 76], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.cancelCommMonoidWithZero", "code": "instance cancelCommMonoidWithZero {\u03b1 : Type*} [OrderedCommRing \u03b1] [NoZeroDivisors \u03b1] :\n    CancelCommMonoidWithZero (Icc (0 : \u03b1) 1) :=\n  @Function.Injective.cancelCommMonoidWithZero \u03b1 _ NoZeroDivisors.toCancelCommMonoidWithZero _ _ _ _\n    (fun v => v.val) Subtype.coe_injective coe_zero coe_one coe_mul coe_pow", "start": [156, 1], "end": [159, 76], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.one_sub_mem", "code": "theorem one_sub_mem {t : \u03b2} (ht : t \u2208 Icc (0 : \u03b2) 1) : 1 - t \u2208 Icc (0 : \u03b2) 1", "start": [164, 1], "end": [166, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.mem_iff_one_sub_mem", "code": "theorem mem_iff_one_sub_mem {t : \u03b2} : t \u2208 Icc (0 : \u03b2) 1 \u2194 1 - t \u2208 Icc (0 : \u03b2) 1", "start": [169, 1], "end": [170, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.one_sub_nonneg", "code": "theorem one_sub_nonneg (x : Icc (0 : \u03b2) 1) : 0 \u2264 1 - (x : \u03b2)", "start": [173, 1], "end": [173, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.one_sub_le_one", "code": "theorem one_sub_le_one (x : Icc (0 : \u03b2) 1) : 1 - (x : \u03b2) \u2264 1", "start": [176, 1], "end": [176, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.zero", "code": "instance zero [Nontrivial \u03b1] : Zero (Ico (0 : \u03b1) 1) where zero := \u27e80, left_mem_Ico.2 zero_lt_one\u27e9", "start": [186, 1], "end": [186, 98], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero [Nontrivial \u03b1] : \u2191(0 : Ico (0 : \u03b1) 1) = (0 : \u03b1)", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.mk_zero", "code": "@[simp]\ntheorem mk_zero [Nontrivial \u03b1] (h : (0 : \u03b1) \u2208 Ico (0 : \u03b1) 1) : (\u27e80, h\u27e9 : Ico (0 : \u03b1) 1) = 0", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_eq_zero [Nontrivial \u03b1] {x : Ico (0 : \u03b1) 1} : (x : \u03b1) = 0 \u2194 x = 0", "start": [199, 1], "end": [202, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_ne_zero", "code": "theorem coe_ne_zero [Nontrivial \u03b1] {x : Ico (0 : \u03b1) 1} : (x : \u03b1) \u2260 0 \u2194 x \u2260 0", "start": [205, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_nonneg", "code": "theorem coe_nonneg (x : Ico (0 : \u03b1) 1) : 0 \u2264 (x : \u03b1)", "start": [209, 1], "end": [210, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_lt_one", "code": "theorem coe_lt_one (x : Ico (0 : \u03b1) 1) : (x : \u03b1) < 1", "start": [213, 1], "end": [214, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.nonneg", "code": "theorem nonneg [Nontrivial \u03b1] {t : Ico (0 : \u03b1) 1} : 0 \u2264 t", "start": [217, 1], "end": [219, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.mul", "code": "instance mul : Mul (Ico (0 : \u03b1) 1) where\n  mul p q :=\n    \u27e8p * q, \u27e8mul_nonneg p.2.1 q.2.1, mul_lt_one_of_nonneg_of_lt_one_right p.2.2.le q.2.1 q.2.2\u27e9\u27e9", "start": [222, 1], "end": [224, 97], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : Ico (0 : \u03b1) 1) : \u2191(x * y) = (x * y : \u03b1)", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.semigroup", "code": "instance semigroup : Semigroup (Ico (0 : \u03b1) 1) :=\n  Subtype.coe_injective.semigroup _ coe_mul", "start": [232, 1], "end": [233, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.commSemigroup", "code": "instance commSemigroup {\u03b1 : Type*} [OrderedCommSemiring \u03b1] : CommSemigroup (Ico (0 : \u03b1) 1) :=\n  Subtype.coe_injective.commSemigroup _ coe_mul", "start": [236, 1], "end": [237, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.one", "code": "instance one [Nontrivial \u03b1] : One (Ioc (0 : \u03b1) 1) where one := \u27e81, \u27e8zero_lt_one, le_refl 1\u27e9\u27e9", "start": [251, 1], "end": [251, 93], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one [Nontrivial \u03b1] : \u2191(1 : Ioc (0 : \u03b1) 1) = (1 : \u03b1)", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.mk_one", "code": "@[simp]\ntheorem mk_one [Nontrivial \u03b1] (h : (1 : \u03b1) \u2208 Ioc (0 : \u03b1) 1) : (\u27e81, h\u27e9 : Ioc (0 : \u03b1) 1) = 1", "start": [259, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_eq_one", "code": "@[simp, norm_cast]\ntheorem coe_eq_one [Nontrivial \u03b1] {x : Ioc (0 : \u03b1) 1} : (x : \u03b1) = 1 \u2194 x = 1", "start": [264, 1], "end": [267, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_ne_one", "code": "theorem coe_ne_one [Nontrivial \u03b1] {x : Ioc (0 : \u03b1) 1} : (x : \u03b1) \u2260 1 \u2194 x \u2260 1", "start": [270, 1], "end": [271, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_pos", "code": "theorem coe_pos (x : Ioc (0 : \u03b1) 1) : 0 < (x : \u03b1)", "start": [274, 1], "end": [275, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_le_one", "code": "theorem coe_le_one (x : Ioc (0 : \u03b1) 1) : (x : \u03b1) \u2264 1", "start": [278, 1], "end": [279, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.le_one", "code": "theorem le_one [Nontrivial \u03b1] {t : Ioc (0 : \u03b1) 1} : t \u2264 1", "start": [282, 1], "end": [284, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.mul", "code": "instance mul : Mul (Ioc (0 : \u03b1) 1) where\n  mul p q := \u27e8p.1 * q.1, \u27e8mul_pos p.2.1 q.2.1, mul_le_one p.2.2 (le_of_lt q.2.1) q.2.2\u27e9\u27e9", "start": [287, 1], "end": [288, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.pow", "code": "instance pow : Pow (Ioc (0 : \u03b1) 1) \u2115 where\n  pow p n := \u27e8p.1 ^ n, \u27e8pow_pos p.2.1 n, pow_le_one n (le_of_lt p.2.1) p.2.2\u27e9\u27e9", "start": [291, 1], "end": [292, 79], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : Ioc (0 : \u03b1) 1) : \u2191(x * y) = (x * y : \u03b1)", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : Ioc (0 : \u03b1) 1) (n : \u2115) : \u2191(x ^ n) = ((x : \u03b1) ^ n)", "start": [300, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.semigroup", "code": "instance semigroup : Semigroup (Ioc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.semigroup _ coe_mul", "start": [305, 1], "end": [306, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.monoid", "code": "instance monoid [Nontrivial \u03b1] : Monoid (Ioc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.monoid _ coe_one coe_mul coe_pow", "start": [309, 1], "end": [310, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.commSemigroup", "code": "instance commSemigroup {\u03b1 : Type*} [StrictOrderedCommSemiring \u03b1] : CommSemigroup (Ioc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.commSemigroup _ coe_mul", "start": [313, 1], "end": [314, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.commMonoid", "code": "instance commMonoid {\u03b1 : Type*} [StrictOrderedCommSemiring \u03b1] [Nontrivial \u03b1] :\n    CommMonoid (Ioc (0 : \u03b1) 1) :=\n  Subtype.coe_injective.commMonoid _ coe_one coe_mul coe_pow", "start": [317, 1], "end": [319, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.cancelMonoid", "code": "instance cancelMonoid {\u03b1 : Type*} [StrictOrderedRing \u03b1] [IsDomain \u03b1] :\n    CancelMonoid (Ioc (0 : \u03b1) 1) :=\n  { Set.Ioc.monoid with\n    mul_left_cancel := fun a _ _ h =>\n      Subtype.ext <| mul_left_cancel\u2080 a.prop.1.ne' <| (congr_arg Subtype.val h : _)\n    mul_right_cancel := fun _ b _ h =>\n      Subtype.ext <| mul_right_cancel\u2080 b.prop.1.ne' <| (congr_arg Subtype.val h : _) }", "start": [322, 1], "end": [328, 87], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.cancelCommMonoid", "code": "instance cancelCommMonoid {\u03b1 : Type*} [StrictOrderedCommRing \u03b1] [IsDomain \u03b1] :\n    CancelCommMonoid (Ioc (0 : \u03b1) 1) :=\n  { Set.Ioc.cancelMonoid, Set.Ioc.commMonoid with }", "start": [331, 1], "end": [333, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.pos", "code": "theorem pos (x : Ioo (0 : \u03b1) 1) : 0 < (x : \u03b1)", "start": [343, 1], "end": [344, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.lt_one", "code": "theorem lt_one (x : Ioo (0 : \u03b1) 1) : (x : \u03b1) < 1", "start": [347, 1], "end": [348, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.mul", "code": "instance mul : Mul (Ioo (0 : \u03b1) 1) where\n  mul p q :=\n    \u27e8p.1 * q.1, \u27e8mul_pos p.2.1 q.2.1, mul_lt_one_of_nonneg_of_lt_one_right p.2.2.le q.2.1.le q.2.2\u27e9\u27e9", "start": [351, 1], "end": [353, 101], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : Ioo (0 : \u03b1) 1) : \u2191(x * y) = (x * y : \u03b1)", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.semigroup", "code": "instance semigroup : Semigroup (Ioo (0 : \u03b1) 1) :=\n  Subtype.coe_injective.semigroup _ coe_mul", "start": [361, 1], "end": [362, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.commSemigroup", "code": "instance commSemigroup {\u03b1 : Type*} [StrictOrderedCommSemiring \u03b1] : CommSemigroup (Ioo (0 : \u03b1) 1) :=\n  Subtype.coe_injective.commSemigroup _ coe_mul", "start": [365, 1], "end": [366, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.one_sub_mem", "code": "theorem one_sub_mem {t : \u03b2} (ht : t \u2208 Ioo (0 : \u03b2) 1) : 1 - t \u2208 Ioo (0 : \u03b2) 1", "start": [371, 1], "end": [374, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.mem_iff_one_sub_mem", "code": "theorem mem_iff_one_sub_mem {t : \u03b2} : t \u2208 Ioo (0 : \u03b2) 1 \u2194 1 - t \u2208 Ioo (0 : \u03b2) 1", "start": [377, 1], "end": [378, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.one_minus_pos", "code": "theorem one_minus_pos (x : Ioo (0 : \u03b2) 1) : 0 < 1 - (x : \u03b2)", "start": [381, 1], "end": [381, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo.one_minus_lt_one", "code": "theorem one_minus_lt_one (x : Ioo (0 : \u03b2) 1) : 1 - (x : \u03b2) < 1", "start": [384, 1], "end": [384, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Padics/PadicVal.lean", "imports": ["Mathlib/Tactic/IntervalCases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/MaxPowDiv.lean", "Mathlib/NumberTheory/Divisors.lean", "Mathlib/Data/Nat/Digits.lean", "Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Data/Nat/Multiplicity.lean"], "premises": [{"full_name": "padicValNat", "code": "def padicValNat (p : \u2115) (n : \u2115) : \u2115 :=\n  if h : p \u2260 1 \u2227 0 < n then (multiplicity p n).get (multiplicity.finite_nat_iff.2 h) else 0", "start": [74, 1], "end": [77, 92], "kind": "commanddeclaration"}, {"full_name": "padicValNat.zero", "code": "@[simp]\nprotected theorem zero : padicValNat p 0 = 0", "start": [86, 1], "end": [88, 70], "kind": "commanddeclaration"}, {"full_name": "padicValNat.one", "code": "@[simp]\nprotected theorem one : padicValNat p 1 = 0", "start": [91, 1], "end": [97, 8], "kind": "commanddeclaration"}, {"full_name": "padicValNat.self", "code": "@[simp]\ntheorem self (hp : 1 < p) : padicValNat p p = 1", "start": [100, 1], "end": [105, 45], "kind": "commanddeclaration"}, {"full_name": "padicValNat.eq_zero_iff", "code": "@[simp]\ntheorem eq_zero_iff {n : \u2115} : padicValNat p n = 0 \u2194 p = 1 \u2228 n = 0 \u2228 \u00acp \u2223 n", "start": [108, 1], "end": [111, 83], "kind": "commanddeclaration"}, {"full_name": "padicValNat.eq_zero_of_not_dvd", "code": "theorem eq_zero_of_not_dvd {n : \u2115} (h : \u00acp \u2223 n) : padicValNat p n = 0", "start": [114, 1], "end": [115, 38], "kind": "commanddeclaration"}, {"full_name": "padicValNat.maxPowDiv_eq_multiplicity", "code": "theorem maxPowDiv_eq_multiplicity {p n : \u2115} (hp : 1 < p) (hn : 0 < n) :\n    p.maxPowDiv n = multiplicity p n", "start": [120, 1], "end": [125, 7], "kind": "commanddeclaration"}, {"full_name": "padicValNat.maxPowDiv_eq_multiplicity_get", "code": "theorem maxPowDiv_eq_multiplicity_get {p n : \u2115} (hp : 1 < p) (hn : 0 < n) (h : Finite p n) :\n    p.maxPowDiv n = (multiplicity p n).get h", "start": [127, 1], "end": [130, 47], "kind": "commanddeclaration"}, {"full_name": "padicValNat.padicValNat_eq_maxPowDiv", "code": "@[csimp]\ntheorem padicValNat_eq_maxPowDiv : @padicValNat = @maxPowDiv", "start": [132, 1], "end": [147, 15], "kind": "commanddeclaration"}, {"full_name": "padicValInt", "code": "def padicValInt (p : \u2115) (z : \u2124) : \u2115 :=\n  padicValNat p z.natAbs", "start": [151, 1], "end": [154, 25], "kind": "commanddeclaration"}, {"full_name": "padicValInt.of_ne_one_ne_zero", "code": "theorem of_ne_one_ne_zero {z : \u2124} (hp : p \u2260 1) (hz : z \u2260 0) :\n    padicValInt p z =\n      (multiplicity (p : \u2124) z).get\n        (by\n          apply multiplicity.finite_int_iff.2\n          simp [hp, hz])", "start": [163, 1], "end": [170, 42], "kind": "commanddeclaration"}, {"full_name": "padicValInt.zero", "code": "@[simp]\nprotected theorem zero : padicValInt p 0 = 0", "start": [173, 1], "end": [175, 70], "kind": "commanddeclaration"}, {"full_name": "padicValInt.one", "code": "@[simp]\nprotected theorem one : padicValInt p 1 = 0", "start": [178, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "padicValInt.of_nat", "code": "@[simp]\ntheorem of_nat {n : \u2115} : padicValInt p n = padicValNat p n", "start": [183, 1], "end": [185, 84], "kind": "commanddeclaration"}, {"full_name": "padicValInt.self", "code": "theorem self (hp : 1 < p) : padicValInt p p = 1", "start": [188, 1], "end": [189, 81], "kind": "commanddeclaration"}, {"full_name": "padicValInt.eq_zero_of_not_dvd", "code": "theorem eq_zero_of_not_dvd {z : \u2124} (h : \u00ac(p : \u2124) \u2223 z) : padicValInt p z = 0", "start": [192, 1], "end": [194, 73], "kind": "commanddeclaration"}, {"full_name": "padicValRat", "code": "def padicValRat (p : \u2115) (q : \u211a) : \u2124 :=\n  padicValInt p q.num - padicValNat p q.den", "start": [199, 1], "end": [202, 44], "kind": "commanddeclaration"}, {"full_name": "padicValRat_def", "code": "lemma padicValRat_def (p : \u2115) (q : \u211a) :\n    padicValRat p q = padicValInt p q.num - padicValNat p q.den :=\n  rfl", "start": [205, 1], "end": [207, 6], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat.neg", "code": "@[simp]\nprotected theorem neg (q : \u211a) : padicValRat p (-q) = padicValRat p q", "start": [215, 1], "end": [218, 34], "kind": "commanddeclaration"}, {"full_name": "padicValRat.zero", "code": "@[simp]\nprotected theorem zero : padicValRat p 0 = 0", "start": [221, 1], "end": [223, 70], "kind": "commanddeclaration"}, {"full_name": "padicValRat.one", "code": "@[simp]\nprotected theorem one : padicValRat p 1 = 0", "start": [226, 1], "end": [228, 69], "kind": "commanddeclaration"}, {"full_name": "padicValRat.of_int", "code": "@[simp]\ntheorem of_int {z : \u2124} : padicValRat p z = padicValInt p z", "start": [231, 1], "end": [233, 84], "kind": "commanddeclaration"}, {"full_name": "padicValRat.of_int_multiplicity", "code": "theorem of_int_multiplicity {z : \u2124} (hp : p \u2260 1) (hz : z \u2260 0) :\n    padicValRat p (z : \u211a) = (multiplicity (p : \u2124) z).get (finite_int_iff.2 \u27e8hp, hz\u27e9)", "start": [236, 1], "end": [239, 51], "kind": "commanddeclaration"}, {"full_name": "padicValRat.multiplicity_sub_multiplicity", "code": "theorem multiplicity_sub_multiplicity {q : \u211a} (hp : p \u2260 1) (hq : q \u2260 0) :\n    padicValRat p q =\n      (multiplicity (p : \u2124) q.num).get (finite_int_iff.2 \u27e8hp, Rat.num_ne_zero_of_ne_zero hq\u27e9) -\n        (multiplicity p q.den).get\n          (by\n            rw [\u2190 finite_iff_dom, finite_nat_iff]\n            exact \u27e8hp, q.pos\u27e9)", "start": [242, 1], "end": [251, 40], "kind": "commanddeclaration"}, {"full_name": "padicValRat.of_nat", "code": "@[simp]\ntheorem of_nat {n : \u2115} : padicValRat p n = padicValNat p n", "start": [254, 1], "end": [256, 84], "kind": "commanddeclaration"}, {"full_name": "padicValRat.self", "code": "theorem self (hp : 1 < p) : padicValRat p p = 1", "start": [259, 1], "end": [260, 64], "kind": "commanddeclaration"}, {"full_name": "zero_le_padicValRat_of_nat", "code": "theorem zero_le_padicValRat_of_nat (n : \u2115) : 0 \u2264 padicValRat p n", "start": [269, 1], "end": [269, 76], "kind": "commanddeclaration"}, {"full_name": "padicValRat_of_nat", "code": "@[norm_cast]\ntheorem padicValRat_of_nat (n : \u2115) : \u2191(padicValNat p n) = padicValRat p n", "start": [272, 1], "end": [274, 85], "kind": "commanddeclaration"}, {"full_name": "padicValNat_def", "code": "theorem padicValNat_def [hp : Fact p.Prime] {n : \u2115} (hn : 0 < n) :\n    padicValNat p n = (multiplicity p n).get (multiplicity.finite_nat_iff.2 \u27e8hp.out.ne_one, hn\u27e9)", "start": [277, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "padicValNat_def'", "code": "theorem padicValNat_def' {n : \u2115} (hp : p \u2260 1) (hn : 0 < n) :\n    \u2191(padicValNat p n) = multiplicity p n", "start": [284, 1], "end": [285, 75], "kind": "commanddeclaration"}, {"full_name": "padicValNat_self", "code": "@[simp]\ntheorem padicValNat_self [Fact p.Prime] : padicValNat p p = 1", "start": [288, 1], "end": [291, 7], "kind": "commanddeclaration"}, {"full_name": "one_le_padicValNat_of_dvd", "code": "theorem one_le_padicValNat_of_dvd {n : \u2115} [hp : Fact p.Prime] (hn : 0 < n) (div : p \u2223 n) :\n    1 \u2264 padicValNat p n", "start": [294, 1], "end": [297, 13], "kind": "commanddeclaration"}, {"full_name": "dvd_iff_padicValNat_ne_zero", "code": "theorem dvd_iff_padicValNat_ne_zero {p n : \u2115} [Fact p.Prime] (hn0 : n \u2260 0) :\n    p \u2223 n \u2194 padicValNat p n \u2260 0", "start": [300, 1], "end": [303, 63], "kind": "commanddeclaration"}, {"full_name": "padicValRat.finite_int_prime_iff", "code": "theorem finite_int_prime_iff {a : \u2124} : Finite (p : \u2124) a \u2194 a \u2260 0", "start": [314, 1], "end": [316, 37], "kind": "commanddeclaration"}, {"full_name": "padicValRat.defn", "code": "protected theorem defn (p : \u2115) [hp : Fact p.Prime] {q : \u211a} {n d : \u2124} (hqz : q \u2260 0)\n    (qdf : q = n /. d) :\n    padicValRat p q =\n      (multiplicity (p : \u2124) n).get\n          (finite_int_iff.2 \u27e8hp.1.ne_one, fun hn => by simp_all\u27e9) -\n        (multiplicity (p : \u2124) d).get\n          (finite_int_iff.2 \u27e8hp.1.ne_one, fun hd => by simp_all\u27e9)", "start": [319, 1], "end": [335, 7], "kind": "commanddeclaration"}, {"full_name": "padicValRat.mul", "code": "protected theorem mul {q r : \u211a} (hq : q \u2260 0) (hr : r \u2260 0) :\n    padicValRat p (q * r) = padicValRat p q + padicValRat p r", "start": [341, 1], "end": [352, 7], "kind": "commanddeclaration"}, {"full_name": "padicValRat.pow", "code": "protected theorem pow {q : \u211a} (hq : q \u2260 0) {k : \u2115} : padicValRat p (q ^ k) = k * padicValRat p q", "start": [357, 1], "end": [360, 88], "kind": "commanddeclaration"}, {"full_name": "padicValRat.inv", "code": "protected theorem inv (q : \u211a) : padicValRat p q\u207b\u00b9 = -padicValRat p q", "start": [363, 1], "end": [368, 23], "kind": "commanddeclaration"}, {"full_name": "padicValRat.div", "code": "protected theorem div {q r : \u211a} (hq : q \u2260 0) (hr : r \u2260 0) :\n    padicValRat p (q / r) = padicValRat p q - padicValRat p r", "start": [371, 1], "end": [374, 94], "kind": "commanddeclaration"}, {"full_name": "padicValRat.padicValRat_le_padicValRat_iff", "code": "theorem padicValRat_le_padicValRat_iff {n\u2081 n\u2082 d\u2081 d\u2082 : \u2124} (hn\u2081 : n\u2081 \u2260 0) (hn\u2082 : n\u2082 \u2260 0)\n    (hd\u2081 : d\u2081 \u2260 0) (hd\u2082 : d\u2082 \u2260 0) :\n    padicValRat p (n\u2081 /. d\u2081) \u2264 padicValRat p (n\u2082 /. d\u2082) \u2194\n      \u2200 n : \u2115, (p : \u2124) ^ n \u2223 n\u2081 * d\u2082 \u2192 (p : \u2124) ^ n \u2223 n\u2082 * d\u2081", "start": [377, 1], "end": [393, 40], "kind": "commanddeclaration"}, {"full_name": "padicValRat.le_padicValRat_add_of_le", "code": "theorem le_padicValRat_add_of_le {q r : \u211a} (hqr : q + r \u2260 0)\n    (h : padicValRat p q \u2264 padicValRat p r) : padicValRat p q \u2264 padicValRat p (q + r)", "start": [396, 1], "end": [427, 41], "kind": "commanddeclaration"}, {"full_name": "padicValRat.min_le_padicValRat_add", "code": "theorem min_le_padicValRat_add {q r : \u211a} (hqr : q + r \u2260 0) :\n    min (padicValRat p q) (padicValRat p r) \u2264 padicValRat p (q + r)", "start": [430, 1], "end": [435, 100], "kind": "commanddeclaration"}, {"full_name": "padicValRat.add_eq_min", "code": "lemma add_eq_min {q r : \u211a} (hqr : q + r \u2260 0) (hq : q \u2260 0) (hr : r \u2260 0)\n    (hval : padicValRat p q \u2260 padicValRat p r) :\n    padicValRat p (q + r) = min (padicValRat p q) (padicValRat p r) := by\n  have h1 := min_le_padicValRat_add (p := p) hqr\n  have h2 := min_le_padicValRat_add (p := p) (ne_of_eq_of_ne (add_neg_cancel_right q r) hq)\n  have h3 := min_le_padicValRat_add (p := p) (ne_of_eq_of_ne (add_neg_cancel_right r q) hr)\n  rw [add_neg_cancel_right, padicValRat.neg] at h2 h3\n  rw [add_comm] at h3\n  refine' le_antisymm (le_min _ _) h1\n  \u00b7 contrapose! h2\n    rw [min_eq_right h2.le] at h3\n    exact lt_min h2 (lt_of_le_of_ne h3 hval)\n  \u00b7 contrapose! h3\n    rw [min_eq_right h3.le] at h2\n    exact lt_min h3 (lt_of_le_of_ne h2 hval.symm)", "start": [438, 1], "end": [453, 50], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat.add_eq_of_lt", "code": "lemma add_eq_of_lt {q r : \u211a} (hqr : q + r \u2260 0)\n    (hq : q \u2260 0) (hr : r \u2260 0) (hval : padicValRat p q < padicValRat p r) :\n    padicValRat p (q + r) = padicValRat p q := by\n  rw [add_eq_min hqr hq hr (ne_of_lt hval), min_eq_left (le_of_lt hval)]", "start": [455, 1], "end": [458, 73], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat.lt_add_of_lt", "code": "lemma lt_add_of_lt {q r\u2081 r\u2082 : \u211a} (hqr : r\u2081 + r\u2082 \u2260 0)\n    (hval\u2081 : padicValRat p q < padicValRat p r\u2081) (hval\u2082 : padicValRat p q < padicValRat p r\u2082) :\n    padicValRat p q < padicValRat p (r\u2081 + r\u2082) :=\n  lt_of_lt_of_le (lt_min hval\u2081 hval\u2082) (padicValRat.min_le_padicValRat_add hqr)", "start": [460, 1], "end": [463, 79], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat.self_pow_inv", "code": "@[simp]\nlemma self_pow_inv (r : \u2115) : padicValRat p ((p : \u211a) ^ r)\u207b\u00b9 = -r := by\n  rw [padicValRat.inv, neg_inj, padicValRat.pow (Nat.cast_ne_zero.mpr hp.elim.ne_zero),\n      padicValRat.self hp.elim.one_lt, mul_one]", "start": [465, 1], "end": [468, 48], "kind": "mathlibtacticlemma"}, {"full_name": "padicValRat.sum_pos_of_pos", "code": "theorem sum_pos_of_pos {n : \u2115} {F : \u2115 \u2192 \u211a} (hF : \u2200 i, i < n \u2192 0 < padicValRat p (F i))\n    (hn0 : \u2211 i in Finset.range n, F i \u2260 0) : 0 < padicValRat p (\u2211 i in Finset.range n, F i)", "start": [472, 1], "end": [484, 48], "kind": "commanddeclaration"}, {"full_name": "padicValRat.lt_sum_of_lt", "code": "theorem lt_sum_of_lt {p j : \u2115} [hp : Fact (Nat.Prime p)] {F : \u2115 \u2192 \u211a} {S : Finset \u2115}\n    (hS : S.Nonempty) (hF : \u2200 i, i \u2208 S \u2192 padicValRat p (F j) < padicValRat p (F i))\n    (hn1 : \u2200 i : \u2115, 0 < F i) : padicValRat p (F j) < padicValRat p (\u2211 i in S, F i)", "start": [487, 1], "end": [499, 99], "kind": "commanddeclaration"}, {"full_name": "padicValNat.mul", "code": "protected theorem mul : a \u2260 0 \u2192 b \u2260 0 \u2192 padicValNat p (a * b) = padicValNat p a + padicValNat p b", "start": [507, 1], "end": [509, 45], "kind": "commanddeclaration"}, {"full_name": "padicValNat.div_of_dvd", "code": "protected theorem div_of_dvd (h : b \u2223 a) :\n    padicValNat p (a / b) = padicValNat p a - padicValNat p b", "start": [512, 1], "end": [518, 87], "kind": "commanddeclaration"}, {"full_name": "padicValNat.div", "code": "protected theorem div (dvd : p \u2223 b) : padicValNat p (b / p) = padicValNat p b - 1", "start": [521, 1], "end": [523, 52], "kind": "commanddeclaration"}, {"full_name": "padicValNat.pow", "code": "protected theorem pow (n : \u2115) (ha : a \u2260 0) : padicValNat p (a ^ n) = n * padicValNat p a", "start": [526, 1], "end": [528, 92], "kind": "commanddeclaration"}, {"full_name": "padicValNat.prime_pow", "code": "@[simp]\nprotected theorem prime_pow (n : \u2115) : padicValNat p (p ^ n) = n", "start": [531, 1], "end": [533, 80], "kind": "commanddeclaration"}, {"full_name": "padicValNat.div_pow", "code": "protected theorem div_pow (dvd : p ^ a \u2223 b) : padicValNat p (b / p ^ a) = padicValNat p b - a", "start": [536, 1], "end": [537, 57], "kind": "commanddeclaration"}, {"full_name": "padicValNat.div'", "code": "protected theorem div' {m : \u2115} (cpm : Coprime p m) {b : \u2115} (dvd : m \u2223 b) :\n    padicValNat p (b / m) = padicValNat p b", "start": [540, 1], "end": [543, 18], "kind": "commanddeclaration"}, {"full_name": "dvd_of_one_le_padicValNat", "code": "theorem dvd_of_one_le_padicValNat {n : \u2115} (hp : 1 \u2264 padicValNat p n) : p \u2223 n", "start": [552, 1], "end": [555, 52], "kind": "commanddeclaration"}, {"full_name": "pow_padicValNat_dvd", "code": "theorem pow_padicValNat_dvd {n : \u2115} : p ^ padicValNat p n \u2223 n", "start": [558, 1], "end": [561, 81], "kind": "commanddeclaration"}, {"full_name": "padicValNat_dvd_iff_le", "code": "theorem padicValNat_dvd_iff_le [hp : Fact p.Prime] {a n : \u2115} (ha : a \u2260 0) :\n    p ^ n \u2223 a \u2194 n \u2264 padicValNat p a", "start": [564, 1], "end": [566, 100], "kind": "commanddeclaration"}, {"full_name": "padicValNat_dvd_iff", "code": "theorem padicValNat_dvd_iff (n : \u2115) [hp : Fact p.Prime] (a : \u2115) :\n    p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a", "start": [569, 1], "end": [573, 52], "kind": "commanddeclaration"}, {"full_name": "pow_succ_padicValNat_not_dvd", "code": "theorem pow_succ_padicValNat_not_dvd {n : \u2115} [hp : Fact p.Prime] (hn : n \u2260 0) :\n    \u00acp ^ (padicValNat p n + 1) \u2223 n", "start": [576, 1], "end": [579, 27], "kind": "commanddeclaration"}, {"full_name": "padicValNat_primes", "code": "theorem padicValNat_primes {q : \u2115} [hp : Fact p.Prime] [hq : Fact q.Prime] (neq : p \u2260 q) :\n    padicValNat p q = 0", "start": [582, 1], "end": [585, 69], "kind": "commanddeclaration"}, {"full_name": "padicValNat_le_nat_log", "code": "lemma padicValNat_le_nat_log (n : \u2115) : padicValNat p n \u2264 Nat.log p n := by\n  rcases n with _ | n\n  \u00b7 simp\n  rcases p with _ | _ | p\n  \u00b7 simp\n  \u00b7 simp\n  exact Nat.le_log_of_pow_le p.one_lt_succ_succ (le_of_dvd n.succ_pos pow_padicValNat_dvd)", "start": [588, 1], "end": [595, 91], "kind": "mathlibtacticlemma"}, {"full_name": "nat_log_eq_padicValNat_iff", "code": "lemma nat_log_eq_padicValNat_iff {n : \u2115} [hp : Fact (Nat.Prime p)] (hn : 0 < n) :\n    Nat.log p n = padicValNat p n \u2194 n < p ^ (padicValNat p n + 1) := by\n  rw [Nat.log_eq_iff (Or.inr \u27e8(Nat.Prime.one_lt' p).out, by linarith\u27e9), and_iff_right_iff_imp]\n  exact (fun _ => Nat.le_of_dvd hn pow_padicValNat_dvd)", "start": [597, 1], "end": [602, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.log_ne_padicValNat_succ", "code": "lemma Nat.log_ne_padicValNat_succ {n : \u2115} (hn : n \u2260 0) : log 2 n \u2260 padicValNat 2 (n + 1) := by\n  rw [Ne, log_eq_iff (by simp [hn])]\n  rintro \u27e8h1, h2\u27e9\n  rw [\u2190 lt_add_one_iff, \u2190 mul_one (2 ^ _)] at h1\n  rw [\u2190 add_one_le_iff, pow_succ] at h2\n  refine' not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 _) pow_padicValNat_dvd\n  exact pow_succ_padicValNat_not_dvd n.succ_ne_zero \u2218 dvd_of_eq", "start": [604, 1], "end": [610, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.max_log_padicValNat_succ_eq_log_succ", "code": "lemma Nat.max_log_padicValNat_succ_eq_log_succ (n : \u2115) :\n    max (log 2 n) (padicValNat 2 (n + 1)) = log 2 (n + 1) := by\n  apply le_antisymm (max_le (le_log_of_pow_le one_lt_two (pow_log_le_add_one 2 n))\n    (padicValNat_le_nat_log (n + 1)))\n  rw [le_max_iff, or_iff_not_imp_left, not_le]\n  intro h\n  replace h := le_antisymm (add_one_le_iff.mpr (lt_pow_of_log_lt one_lt_two h))\n    (pow_log_le_self 2 n.succ_ne_zero)\n  rw [h, padicValNat.prime_pow, \u2190 h]", "start": [612, 1], "end": [620, 37], "kind": "mathlibtacticlemma"}, {"full_name": "range_pow_padicValNat_subset_divisors", "code": "theorem range_pow_padicValNat_subset_divisors {n : \u2115} (hn : n \u2260 0) :\n    (Finset.range (padicValNat p n + 1)).image (p ^ \u00b7) \u2286 n.divisors", "start": [624, 1], "end": [630, 71], "kind": "commanddeclaration"}, {"full_name": "range_pow_padicValNat_subset_divisors'", "code": "theorem range_pow_padicValNat_subset_divisors' {n : \u2115} [hp : Fact p.Prime] :\n    ((Finset.range (padicValNat p n)).image fun t => p ^ (t + 1)) \u2286 n.divisors.erase 1", "start": [633, 1], "end": [642, 58], "kind": "commanddeclaration"}, {"full_name": "padicValNat_factorial_mul", "code": "theorem padicValNat_factorial_mul (n : \u2115) [hp : Fact p.Prime]:\n    padicValNat p (p * n) ! = padicValNat p n ! + n", "start": [645, 1], "end": [651, 48], "kind": "commanddeclaration"}, {"full_name": "padicValNat_eq_zero_of_mem_Ioo", "code": "theorem padicValNat_eq_zero_of_mem_Ioo {m k : \u2115}\n    (hm : m \u2208 Set.Ioo (p * k) (p * (k + 1))) : padicValNat p m = 0", "start": [653, 1], "end": [657, 82], "kind": "commanddeclaration"}, {"full_name": "padicValNat_factorial_mul_add", "code": "theorem padicValNat_factorial_mul_add {n : \u2115} (m : \u2115) [hp : Fact p.Prime] (h : n < p) :\n    padicValNat p (p * m + n) ! = padicValNat p (p * m) !", "start": [659, 1], "end": [668, 16], "kind": "commanddeclaration"}, {"full_name": "padicValNat_mul_div_factorial", "code": "@[simp] theorem padicValNat_mul_div_factorial (n : \u2115) [hp : Fact p.Prime] :\n    padicValNat p (p * (n / p))! = padicValNat p n !", "start": [670, 1], "end": [675, 76], "kind": "commanddeclaration"}, {"full_name": "padicValNat_factorial", "code": "theorem padicValNat_factorial {n b : \u2115} [hp : Fact p.Prime] (hnb : log p n < b) :\n    padicValNat p (n !) = \u2211 i in Finset.Ico 1 b, n / p ^ i", "start": [677, 1], "end": [684, 47], "kind": "commanddeclaration"}, {"full_name": "sub_one_mul_padicValNat_factorial", "code": "theorem sub_one_mul_padicValNat_factorial [hp : Fact p.Prime] (n : \u2115):\n    (p - 1) * padicValNat p (n !) = n - (p.digits n).sum", "start": [686, 1], "end": [693, 72], "kind": "commanddeclaration"}, {"full_name": "padicValNat_choose", "code": "theorem padicValNat_choose {n k b : \u2115} [hp : Fact p.Prime] (hkn : k \u2264 n) (hnb : log p n < b) :\n    padicValNat p (choose n k) =\n    ((Finset.Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + (n - k) % p ^ i).card", "start": [695, 1], "end": [704, 43], "kind": "commanddeclaration"}, {"full_name": "padicValNat_choose'", "code": "theorem padicValNat_choose' {n k b : \u2115} [hp : Fact p.Prime] (hnb : log p (n + k) < b) :\n    padicValNat p (choose (n + k) k) =\n    ((Finset.Ico 1 b).filter fun i => p ^ i \u2264 k % p ^ i + n % p ^ i).card", "start": [706, 1], "end": [715, 62], "kind": "commanddeclaration"}, {"full_name": "sub_one_mul_padicValNat_choose_eq_sub_sum_digits'", "code": "theorem sub_one_mul_padicValNat_choose_eq_sub_sum_digits' {k n : \u2115} [hp : Fact p.Prime] :\n    (p - 1) * padicValNat p (choose (n + k) k) =\n    (p.digits k).sum + (p.digits n).sum - (p.digits (n + k)).sum", "start": [717, 1], "end": [732, 88], "kind": "commanddeclaration"}, {"full_name": "sub_one_mul_padicValNat_choose_eq_sub_sum_digits", "code": "theorem sub_one_mul_padicValNat_choose_eq_sub_sum_digits {k n : \u2115} [hp : Fact p.Prime]\n    (h : k \u2264 n) : (p - 1) * padicValNat p (choose n k) =\n    (p.digits k).sum + (p.digits (n - k)).sum - (p.digits n).sum", "start": [734, 1], "end": [742, 45], "kind": "commanddeclaration"}, {"full_name": "padicValInt_dvd_iff", "code": "theorem padicValInt_dvd_iff (n : \u2115) (a : \u2124) : (p : \u2124) ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValInt p a", "start": [750, 1], "end": [752, 21], "kind": "commanddeclaration"}, {"full_name": "padicValInt_dvd", "code": "theorem padicValInt_dvd (a : \u2124) : (p : \u2124) ^ padicValInt p a \u2223 a", "start": [755, 1], "end": [757, 22], "kind": "commanddeclaration"}, {"full_name": "padicValInt_self", "code": "theorem padicValInt_self : padicValInt p p = 1", "start": [760, 1], "end": [761, 33], "kind": "commanddeclaration"}, {"full_name": "padicValInt.mul", "code": "theorem padicValInt.mul {a b : \u2124} (ha : a \u2260 0) (hb : b \u2260 0) :\n    padicValInt p (a * b) = padicValInt p a + padicValInt p b", "start": [764, 1], "end": [767, 68], "kind": "commanddeclaration"}, {"full_name": "padicValInt_mul_eq_succ", "code": "theorem padicValInt_mul_eq_succ (a : \u2124) (ha : a \u2260 0) :\n    padicValInt p (a * p) = padicValInt p a + 1", "start": [770, 1], "end": [773, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/PrimeFin.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "Mathlib/Data/Countable/Defs.lean", "Mathlib/Data/Nat/Factors.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.infinite_setOf_prime", "code": "theorem infinite_setOf_prime : { p | Prime p }.Infinite", "start": [21, 1], "end": [23, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.infinite", "code": "instance Primes.infinite : Infinite Primes := infinite_setOf_prime.to_subtype", "start": [26, 1], "end": [26, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.countable", "code": "instance Primes.countable : Countable Primes := \u27e8\u27e8coeNat.coe, coe_nat_injective\u27e9\u27e9", "start": [28, 1], "end": [28, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_mul_toFinset", "code": "theorem factors_mul_toFinset {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a * b).factors.toFinset = a.factors.toFinset \u222a b.factors.toFinset", "start": [30, 1], "end": [34, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_succ_factors_toFinset", "code": "theorem pow_succ_factors_toFinset (n k : \u2115) :\n    (n ^ (k + 1)).factors.toFinset = n.factors.toFinset", "start": [37, 1], "end": [43, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_factors_toFinset", "code": "theorem pow_factors_toFinset (n : \u2115) {k : \u2115} (hk : k \u2260 0) :\n    (n ^ k).factors.toFinset = n.factors.toFinset", "start": [46, 1], "end": [50, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_pow_prime_divisor", "code": "theorem prime_pow_prime_divisor {p k : \u2115} (hk : k \u2260 0) (hp : Prime p) :\n    (p ^ k).factors.toFinset = {p}", "start": [53, 1], "end": [55, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_mul_toFinset_of_coprime", "code": "theorem factors_mul_toFinset_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    (a * b).factors.toFinset = a.factors.toFinset \u222a b.factors.toFinset", "start": [58, 1], "end": [60, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Count.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.count", "code": "def count (n : \u2115) : \u2115 :=\n  (List.range n).countP p", "start": [32, 1], "end": [34, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.count_zero", "code": "@[simp]\ntheorem count_zero : count p 0 = 0", "start": [37, 1], "end": [39, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.CountSet.fintype", "code": "def CountSet.fintype (n : \u2115) : Fintype { i // i < n \u2227 p i } := by\n  apply Fintype.ofFinset ((Finset.range n).filter p)\n  intro x\n  rw [mem_filter, mem_range]\n  rfl", "start": [42, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.count_eq_card_filter_range", "code": "theorem count_eq_card_filter_range (n : \u2115) : count p n = ((range n).filter p).card", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.count_eq_card_fintype", "code": "theorem count_eq_card_fintype (n : \u2115) : count p n = Fintype.card { k : \u2115 // k < n \u2227 p k }", "start": [59, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.count_succ", "code": "theorem count_succ (n : \u2115) : count p (n + 1) = count p n + if p n then 1 else 0", "start": [65, 1], "end": [66, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.count_monotone", "code": "@[mono]\ntheorem count_monotone : Monotone (count p)", "start": [69, 1], "end": [71, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.count_add", "code": "theorem count_add (a b : \u2115) : count p (a + b) = count p a + count (fun k \u21a6 p (a + k)) b", "start": [74, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.count_add'", "code": "theorem count_add' (a b : \u2115) : count p (a + b) = count (fun k \u21a6 p (k + b)) a + count p b", "start": [86, 1], "end": [88, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.count_one", "code": "theorem count_one : count p 1 = if p 0 then 1 else 0", "start": [91, 1], "end": [91, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.count_succ'", "code": "theorem count_succ' (n : \u2115) :\n    count p (n + 1) = count (fun k \u21a6 p (k + 1)) n + if p 0 then 1 else 0", "start": [94, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.count_lt_count_succ_iff", "code": "@[simp]\ntheorem count_lt_count_succ_iff {n : \u2115} : count p n < count p (n + 1) \u2194 p n", "start": [101, 1], "end": [103, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.count_succ_eq_succ_count_iff", "code": "theorem count_succ_eq_succ_count_iff {n : \u2115} : count p (n + 1) = count p n + 1 \u2194 p n", "start": [106, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.count_succ_eq_count_iff", "code": "theorem count_succ_eq_count_iff {n : \u2115} : count p (n + 1) = count p n \u2194 \u00acp n", "start": [110, 1], "end": [111, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.count_succ_eq_succ_count", "code": "alias \u27e8_, count_succ_eq_succ_count\u27e9 := count_succ_eq_succ_count_iff", "start": [114, 1], "end": [114, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.count_succ_eq_count", "code": "alias \u27e8_, count_succ_eq_count\u27e9 := count_succ_eq_count_iff", "start": [117, 1], "end": [117, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.count_le_cardinal", "code": "theorem count_le_cardinal (n : \u2115) : (count p n : Cardinal) \u2264 Cardinal.mk { k | p k }", "start": [120, 1], "end": [122, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_count_lt_count", "code": "theorem lt_of_count_lt_count {a b : \u2115} (h : count p a < count p b) : a < b", "start": [125, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.count_strict_mono", "code": "theorem count_strict_mono {m n : \u2115} (hm : p m) (hmn : m < n) : count p m < count p n", "start": [129, 1], "end": [130, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.count_injective", "code": "theorem count_injective {m n : \u2115} (hm : p m) (hn : p n) (heq : count p m = count p n) : m = n", "start": [133, 1], "end": [137, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.count_le_card", "code": "theorem count_le_card (hp : (setOf p).Finite) (n : \u2115) : count p n \u2264 hp.toFinset.card", "start": [140, 1], "end": [142, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.count_lt_card", "code": "theorem count_lt_card {n : \u2115} (hp : (setOf p).Finite) (hpn : p n) : count p n < hp.toFinset.card", "start": [145, 1], "end": [146, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.count_mono_left", "code": "theorem count_mono_left {n : \u2115} (hpq : \u2200 k, p k \u2192 q k) : count p n \u2264 count q n", "start": [153, 1], "end": [155, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Yoneda.lean", "imports": ["Mathlib/CategoryTheory/Functor/Currying.lean", "Mathlib/CategoryTheory/Products/Basic.lean", "Mathlib/CategoryTheory/Functor/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.yoneda", "code": "@[simps]\ndef yoneda : C \u2964 C\u1d52\u1d56 \u2964 Type v\u2081 where\n  obj X :=\n    { obj := fun Y => unop Y \u27f6 X\n      map := fun f g => f.unop \u226b g }\n  map f :=\n    { app := fun Y g => g \u226b f }", "start": [36, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coyoneda", "code": "@[simps]\ndef coyoneda : C\u1d52\u1d56 \u2964 C \u2964 Type v\u2081 where\n  obj X :=\n    { obj := fun Y => unop X \u27f6 Y\n      map := fun f g => g \u226b f }\n  map f :=\n    { app := fun Y g => f.unop \u226b g }", "start": [49, 1], "end": [57, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.obj_map_id", "code": "theorem obj_map_id {X Y : C} (f : op X \u27f6 op Y) :\n    (yoneda.obj X).map f (\ud835\udfd9 X) = (yoneda.map f.unop).app (op Y) (\ud835\udfd9 Y)", "start": [62, 1], "end": [65, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.naturality", "code": "@[simp]\ntheorem naturality {X Y : C} (\u03b1 : yoneda.obj X \u27f6 yoneda.obj Y) {Z Z' : C} (f : Z \u27f6 Z')\n    (h : Z' \u27f6 X) : f \u226b \u03b1.app (op Z') h = \u03b1.app (op Z) (f \u226b h)", "start": [68, 1], "end": [71, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.yonedaFull", "code": "instance yonedaFull : Full (yoneda : C \u2964 C\u1d52\u1d56 \u2964 Type v\u2081) where\n  preimage {X} {Y} f := f.app (op X) (\ud835\udfd9 X)", "start": [74, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.yoneda_faithful", "code": "instance yoneda_faithful : Faithful (yoneda : C \u2964 C\u1d52\u1d56 \u2964 Type v\u2081) where\n  map_injective {X} {Y} f g p := by\n    convert congr_fun (congr_app p (op X)) (\ud835\udfd9 X) using 1 <;> dsimp <;> simp", "start": [82, 1], "end": [88, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.ext", "code": "def ext (X Y : C) (p : \u2200 {Z : C}, (Z \u27f6 X) \u2192 (Z \u27f6 Y)) (q : \u2200 {Z : C}, (Z \u27f6 Y) \u2192 (Z \u27f6 X))\n    (h\u2081 : \u2200 {Z : C} (f : Z \u27f6 X), q (p f) = f) (h\u2082 : \u2200 {Z : C} (f : Z \u27f6 Y), p (q f) = f)\n    (n : \u2200 {Z Z' : C} (f : Z' \u27f6 Z) (g : Z \u27f6 X), p (f \u226b g) = f \u226b p g) : X \u2245 Y :=\n  yoneda.preimageIso\n    (NatIso.ofComponents fun Z =>\n      { hom := p\n        inv := q })", "start": [91, 1], "end": [105, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Yoneda.isIso", "code": "theorem isIso {X Y : C} (f : X \u27f6 Y) [IsIso (yoneda.map f)] : IsIso f", "start": [108, 1], "end": [111, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.naturality", "code": "@[simp]\ntheorem naturality {X Y : C\u1d52\u1d56} (\u03b1 : coyoneda.obj X \u27f6 coyoneda.obj Y) {Z Z' : C} (f : Z' \u27f6 Z)\n    (h : unop X \u27f6 Z') : \u03b1.app Z' h \u226b f = \u03b1.app Z (h \u226b f)", "start": [118, 1], "end": [121, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.coyonedaFull", "code": "instance coyonedaFull : Full (coyoneda : C\u1d52\u1d56 \u2964 C \u2964 Type v\u2081) where\n  preimage {X} _ f := (f.app _ (\ud835\udfd9 X.unop)).op\n  witness {X} {Y} f := by simp only [coyoneda]; aesop_cat", "start": [124, 1], "end": [126, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.coyoneda_faithful", "code": "instance coyoneda_faithful : Faithful (coyoneda : C\u1d52\u1d56 \u2964 C \u2964 Type v\u2081) where\n  map_injective {X} _ _ _ p := by\n    have t := congr_fun (congr_app p X.unop) (\ud835\udfd9 _)\n    simpa using congr_arg Quiver.Hom.op t", "start": [129, 1], "end": [132, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.isIso", "code": "theorem isIso {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) [IsIso (coyoneda.map f)] : IsIso f", "start": [135, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.punitIso", "code": "def punitIso : coyoneda.obj (Opposite.op PUnit) \u2245 \ud835\udfed (Type v\u2081) :=\n  NatIso.ofComponents fun X =>\n    { hom := fun f => f \u27e8\u27e9\n      inv := fun x _ => x }", "start": [141, 1], "end": [145, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Coyoneda.objOpOp", "code": "@[simps!]\ndef objOpOp (X : C) : coyoneda.obj (op (op X)) \u2245 yoneda.obj X :=\n  NatIso.ofComponents fun _ => (opEquiv _ _).toIso", "start": [148, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.Representable", "code": "class Representable (F : C\u1d52\u1d56 \u2964 Type v\u2081) : Prop where\n  \n  has_representation : \u2203 (X : _) (f : yoneda.obj X \u27f6 F), IsIso f", "start": [158, 1], "end": [164, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.Corepresentable", "code": "class Corepresentable (F : C \u2964 Type v\u2081) : Prop where\n  \n  has_corepresentation : \u2203 (X : _) (f : coyoneda.obj X \u27f6 F), IsIso f", "start": [169, 1], "end": [175, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprX", "code": "noncomputable def reprX : C :=\n  (Representable.has_representation : \u2203 (_ : _) (_ : _ \u27f6 F), _).choose", "start": [189, 1], "end": [191, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprF", "code": "noncomputable def reprF : yoneda.obj F.reprX \u27f6 F :=\n  Representable.has_representation.choose_spec.choose", "start": [195, 1], "end": [197, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprx", "code": "noncomputable def reprx : F.obj (op F.reprX) :=\n  F.reprF.app (op F.reprX) (\ud835\udfd9 F.reprX)", "start": [200, 1], "end": [204, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprW", "code": "noncomputable def reprW : yoneda.obj F.reprX \u2245 F :=\n  asIso F.reprF", "start": [210, 1], "end": [214, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprW_hom", "code": "@[simp]\ntheorem reprW_hom : F.reprW.hom = F.reprF", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.reprW_app_hom", "code": "theorem reprW_app_hom (X : C\u1d52\u1d56) (f : unop X \u27f6 F.reprX) :\n    (F.reprW.app X).hom f = F.map f.op F.reprx", "start": [222, 1], "end": [227, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coreprX", "code": "noncomputable def coreprX : C :=\n  (Corepresentable.has_corepresentation : \u2203 (_ : _) (_ : _ \u27f6 F), _).choose.unop", "start": [238, 1], "end": [240, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coreprF", "code": "noncomputable def coreprF : coyoneda.obj (op F.coreprX) \u27f6 F :=\n  Corepresentable.has_corepresentation.choose_spec.choose", "start": [244, 1], "end": [246, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coreprx", "code": "noncomputable def coreprx : F.obj F.coreprX :=\n  F.coreprF.app F.coreprX (\ud835\udfd9 F.coreprX)", "start": [249, 1], "end": [253, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coreprW", "code": "noncomputable def coreprW : coyoneda.obj (op F.coreprX) \u2245 F :=\n  asIso F.coreprF", "start": [259, 1], "end": [263, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.coreprW_app_hom", "code": "theorem coreprW_app_hom (X : C) (f : F.coreprX \u27f6 X) :\n    (F.coreprW.app X).hom f = F.map f F.coreprx", "start": [266, 1], "end": [271, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.representable_of_nat_iso", "code": "theorem representable_of_nat_iso (F : C\u1d52\u1d56 \u2964 Type v\u2081) {G} (i : F \u2245 G) [F.Representable] :\n    G.Representable", "start": [278, 1], "end": [280, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.corepresentable_of_nat_iso", "code": "theorem corepresentable_of_nat_iso (F : C \u2964 Type v\u2081) {G} (i : F \u2245 G) [F.Corepresentable] :\n    G.Corepresentable", "start": [283, 1], "end": [285, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodCategoryInstance1", "code": "instance prodCategoryInstance1 : Category ((C\u1d52\u1d56 \u2964 Type v\u2081) \u00d7 C\u1d52\u1d56) :=\n  CategoryTheory.prod.{max u\u2081 v\u2081, v\u2081} (C\u1d52\u1d56 \u2964 Type v\u2081) C\u1d52\u1d56", "start": [296, 1], "end": [297, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodCategoryInstance2", "code": "instance prodCategoryInstance2 : Category (C\u1d52\u1d56 \u00d7 (C\u1d52\u1d56 \u2964 Type v\u2081)) :=\n  CategoryTheory.prod.{v\u2081, max u\u2081 v\u2081} C\u1d52\u1d56 (C\u1d52\u1d56 \u2964 Type v\u2081)", "start": [300, 1], "end": [301, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEvaluation", "code": "def yonedaEvaluation : C\u1d52\u1d56 \u00d7 (C\u1d52\u1d56 \u2964 Type v\u2081) \u2964 Type max u\u2081 v\u2081 :=\n  evaluationUncurried C\u1d52\u1d56 (Type v\u2081) \u22d9 uliftFunctor.{u\u2081}", "start": [306, 1], "end": [310, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEvaluation_map_down", "code": "@[simp]\ntheorem yonedaEvaluation_map_down (P Q : C\u1d52\u1d56 \u00d7 (C\u1d52\u1d56 \u2964 Type v\u2081)) (\u03b1 : P \u27f6 Q)\n    (x : (yonedaEvaluation C).obj P) :\n    ((yonedaEvaluation C).map \u03b1 x).down = \u03b1.2.app Q.1 (P.2.map \u03b1.1 x.down)", "start": [313, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaPairing", "code": "def yonedaPairing : C\u1d52\u1d56 \u00d7 (C\u1d52\u1d56 \u2964 Type v\u2081) \u2964 Type max u\u2081 v\u2081 :=\n  Functor.prod yoneda.op (\ud835\udfed (C\u1d52\u1d56 \u2964 Type v\u2081)) \u22d9 Functor.hom (C\u1d52\u1d56 \u2964 Type v\u2081)", "start": [320, 1], "end": [324, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaPairingExt", "code": "@[ext]\nlemma yonedaPairingExt {x y : (yonedaPairing C).obj X} (w : \u2200 Y, x.app Y = y.app Y) : x = y :=\n  NatTrans.ext _ _ (funext w)", "start": [330, 1], "end": [332, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaPairing_map", "code": "@[simp]\ntheorem yonedaPairing_map (P Q : C\u1d52\u1d56 \u00d7 (C\u1d52\u1d56 \u2964 Type v\u2081)) (\u03b1 : P \u27f6 Q) (\u03b2 : (yonedaPairing C).obj P) :\n    (yonedaPairing C).map \u03b1 \u03b2 = yoneda.map \u03b1.1.unop \u226b \u03b2 \u226b \u03b1.2", "start": [334, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaLemma", "code": "def yonedaLemma : yonedaPairing C \u2245 yonedaEvaluation C where\n  hom :=\n    { app := fun F x => ULift.up ((x.app F.1) (\ud835\udfd9 (unop F.1)))\n      naturality := by\n        intro X Y f\n        simp only [yonedaEvaluation]\n        ext\n        dsimp\n        erw [Category.id_comp, \u2190FunctorToTypes.naturality]\n        simp only [Category.comp_id, yoneda_obj_map] }\n  inv :=\n    { app := fun F x =>\n        { app := fun X a => (F.2.map a.op) x.down\n          naturality := by\n            intro X Y f\n            ext\n            dsimp\n            rw [FunctorToTypes.map_comp_apply] }\n      naturality := by\n        intro X Y f\n        simp only [yoneda]\n        ext\n        dsimp\n        rw [\u2190FunctorToTypes.naturality X.snd Y.snd f.snd, FunctorToTypes.map_comp_apply] }\n  hom_inv_id := by\n    ext\n    dsimp\n    erw [\u2190 FunctorToTypes.naturality, obj_map_id]\n    simp only [yoneda_map_app, Quiver.Hom.unop_op]\n    erw [Category.id_comp]\n  inv_hom_id := by\n    ext\n    dsimp\n    rw [FunctorToTypes.map_id_apply, ULift.up_down]", "start": [340, 1], "end": [379, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaSections", "code": "@[simps!]\ndef yonedaSections (X : C) (F : C\u1d52\u1d56 \u2964 Type v\u2081) : (yoneda.obj X \u27f6 F) \u2245 ULift.{u\u2081} (F.obj (op X)) :=\n  (yonedaLemma C).app (op X, F)", "start": [384, 1], "end": [390, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEquiv", "code": "def yonedaEquiv {X : C} {F : C\u1d52\u1d56 \u2964 Type v\u2081} : (yoneda.obj X \u27f6 F) \u2243 F.obj (op X) :=\n  (yonedaSections X F).toEquiv.trans Equiv.ulift", "start": [393, 1], "end": [397, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEquiv_apply", "code": "@[simp]\ntheorem yonedaEquiv_apply {X : C} {F : C\u1d52\u1d56 \u2964 Type v\u2081} (f : yoneda.obj X \u27f6 F) :\n    yonedaEquiv f = f.app (op X) (\ud835\udfd9 X)", "start": [400, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEquiv_symm_app_apply", "code": "@[simp]\ntheorem yonedaEquiv_symm_app_apply {X : C} {F : C\u1d52\u1d56 \u2964 Type v\u2081} (x : F.obj (op X)) (Y : C\u1d52\u1d56)\n    (f : Y.unop \u27f6 X) : (yonedaEquiv.symm x).app Y f = F.map f.op x", "start": [406, 1], "end": [409, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEquiv_naturality", "code": "theorem yonedaEquiv_naturality {X Y : C} {F : C\u1d52\u1d56 \u2964 Type v\u2081} (f : yoneda.obj X \u27f6 F) (g : Y \u27f6 X) :\n    F.map g.op (yonedaEquiv f) = yonedaEquiv (yoneda.map g \u226b f)", "start": [412, 1], "end": [417, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaEquiv_naturality'", "code": "lemma yonedaEquiv_naturality' {X Y : C\u1d52\u1d56} {F : C\u1d52\u1d56 \u2964 Type v\u2081} (f : yoneda.obj (unop X) \u27f6 F)\n    (g : X \u27f6 Y) : F.map g (yonedaEquiv f) = yonedaEquiv (yoneda.map g.unop \u226b f) :=\n  yonedaEquiv_naturality _ _", "start": [420, 1], "end": [422, 29], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaEquiv_comp", "code": "lemma yonedaEquiv_comp {X : C} {F G : C\u1d52\u1d56 \u2964 Type v\u2081} (\u03b1 : yoneda.obj X \u27f6 F) (\u03b2 : F \u27f6 G)  :\n    yonedaEquiv (\u03b1 \u226b \u03b2) = \u03b2.app _ (yonedaEquiv \u03b1) :=\n  rfl", "start": [424, 1], "end": [426, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaEquiv_comp'", "code": "lemma yonedaEquiv_comp' {X : C\u1d52\u1d56} {F G : C\u1d52\u1d56 \u2964 Type v\u2081} (\u03b1 : yoneda.obj (unop X) \u27f6 F) (\u03b2 : F \u27f6 G)  :\n    yonedaEquiv (\u03b1 \u226b \u03b2) = \u03b2.app X (yonedaEquiv \u03b1) :=\n  rfl", "start": [428, 1], "end": [430, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaEquiv_yoneda_map", "code": "@[simp, nolint simpNF]\nlemma yonedaEquiv_yoneda_map {X Y : C} (f : X \u27f6 Y) : yonedaEquiv (yoneda.map f) = f := by\n  rw [yonedaEquiv_apply]\n  simp", "start": [433, 1], "end": [436, 7], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaEquiv_symm_map", "code": "lemma yonedaEquiv_symm_map {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) {F : C\u1d52\u1d56 \u2964 Type v\u2081} (t : F.obj X) :\n    yonedaEquiv.symm (F.map f t) = yoneda.map f.unop \u226b yonedaEquiv.symm t := by\n  obtain \u27e8u, rfl\u27e9 := yonedaEquiv.surjective t\n  rw [yonedaEquiv_naturality', Equiv.symm_apply_apply, Equiv.symm_apply_apply]", "start": [438, 1], "end": [441, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.yonedaSectionsSmall", "code": "def yonedaSectionsSmall {C : Type u\u2081} [SmallCategory C] (X : C) (F : C\u1d52\u1d56 \u2964 Type u\u2081) :\n    (yoneda.obj X \u27f6 F) \u2245 F.obj (op X) :=\n  yonedaSections X F \u226a\u226b uliftTrivial _", "start": [443, 1], "end": [448, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaSectionsSmall_hom", "code": "@[simp]\ntheorem yonedaSectionsSmall_hom {C : Type u\u2081} [SmallCategory C] (X : C) (F : C\u1d52\u1d56 \u2964 Type u\u2081)\n    (f : yoneda.obj X \u27f6 F) : (yonedaSectionsSmall X F).hom f = f.app _ (\ud835\udfd9 _)", "start": [451, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.yonedaSectionsSmall_inv_app_apply", "code": "@[simp]\ntheorem yonedaSectionsSmall_inv_app_apply {C : Type u\u2081} [SmallCategory C] (X : C)\n    (F : C\u1d52\u1d56 \u2964 Type u\u2081) (t : F.obj (op X)) (Y : C\u1d52\u1d56) (f : Y.unop \u27f6 X) :\n    ((yonedaSectionsSmall X F).inv t).app Y f = F.map f.op t", "start": [457, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.curriedYonedaLemma", "code": "def curriedYonedaLemma {C : Type u\u2081} [SmallCategory C] :\n    (yoneda.op \u22d9 coyoneda : C\u1d52\u1d56 \u2964 (C\u1d52\u1d56 \u2964 Type u\u2081) \u2964 Type u\u2081) \u2245 evaluation C\u1d52\u1d56 (Type u\u2081) := by\n  refine eqToIso ?_ \u226a\u226b curry.mapIso\n    (yonedaLemma C \u226a\u226b isoWhiskerLeft (evaluationUncurried C\u1d52\u1d56 (Type u\u2081)) uliftFunctorTrivial) \u226a\u226b\n    eqToIso ?_\n  \u00b7 apply Functor.ext\n    \u00b7 intro X Y f\n      ext\n      simp\n    \u00b7 aesop_cat\n  \u00b7 apply Functor.ext\n    \u00b7 intro X Y f\n      ext\n      simp\n    \u00b7 intro X\n      simp only [curry, yoneda, coyoneda, curryObj, yonedaPairing]\n      aesop_cat", "start": [467, 1], "end": [484, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.curriedYonedaLemma'", "code": "def curriedYonedaLemma' {C : Type u\u2081} [SmallCategory C] :\n    yoneda \u22d9 (whiskeringLeft C\u1d52\u1d56 (C\u1d52\u1d56 \u2964 Type u\u2081)\u1d52\u1d56 (Type u\u2081)).obj yoneda.op\n      \u2245 \ud835\udfed (C\u1d52\u1d56 \u2964 Type u\u2081) := by\n  refine eqToIso ?_ \u226a\u226b curry.mapIso (isoWhiskerLeft (Prod.swap _ _)\n    (yonedaLemma C \u226a\u226b isoWhiskerLeft (evaluationUncurried C\u1d52\u1d56 (Type u\u2081)) uliftFunctorTrivial :_))\n    \u226a\u226b eqToIso ?_\n  \u00b7 apply Functor.ext\n    \u00b7 intro X Y f\n      aesop_cat\n  \u00b7 apply Functor.ext\n    \u00b7 aesop_cat", "start": [487, 1], "end": [498, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_yoneda_map_bijective", "code": "lemma isIso_of_yoneda_map_bijective {X Y : C} (f : X \u27f6 Y)\n    (hf : \u2200 (T : C), Function.Bijective (fun (x : T \u27f6 X) => x \u226b f)) :\n    IsIso f := by\n  obtain \u27e8g, hg : g \u226b f = \ud835\udfd9 Y\u27e9 := (hf Y).2 (\ud835\udfd9 Y)\n  exact \u27e8g, (hf _).1 (by aesop_cat), hg\u27e9", "start": [501, 1], "end": [505, 41], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "imports": ["Mathlib/CategoryTheory/Balanced.lean", "Mathlib/CategoryTheory/Functor/EpiMono.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ReflectsIsomorphisms", "code": "class ReflectsIsomorphisms (F : C \u2964 D) : Prop where\n  \n  reflects : \u2200 {A B : C} (f : A \u27f6 B) [IsIso (F.map f)], IsIso f", "start": [37, 1], "end": [43, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_reflects_iso", "code": "theorem isIso_of_reflects_iso {A B : C} (f : A \u27f6 B) (F : C \u2964 D) [IsIso (F.map f)]\n    [ReflectsIsomorphisms F] : IsIso f", "start": [46, 1], "end": [49, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsIsomorphisms_of_full_and_faithful", "code": "instance (priority := 100) reflectsIsomorphisms_of_full_and_faithful\n    (F : C \u2964 D) [Full F] [Faithful F] :\n    ReflectsIsomorphisms F where\n  reflects f i :=\n    \u27e8\u27e8F.preimage (inv (F.map f)), \u27e8F.map_injective (by simp), F.map_injective (by simp)\u27e9\u27e9\u27e9", "start": [52, 1], "end": [56, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsIsomorphisms_of_comp", "code": "instance reflectsIsomorphisms_of_comp (F : C \u2964 D) (G : D \u2964 E)\n    [ReflectsIsomorphisms F] [ReflectsIsomorphisms G] :\n    ReflectsIsomorphisms (F \u22d9 G) :=\n  \u27e8fun f (hf : IsIso (G.map _)) => by\n    haveI := isIso_of_reflects_iso (F.map f) G\n    exact isIso_of_reflects_iso f F\u27e9", "start": [59, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reflectsIsomorphisms_of_reflectsMonomorphisms_of_reflectsEpimorphisms", "code": "instance (priority := 100) reflectsIsomorphisms_of_reflectsMonomorphisms_of_reflectsEpimorphisms\n    [Balanced C] (F : C \u2964 D) [ReflectsMonomorphisms F] [ReflectsEpimorphisms F] :\n    ReflectsIsomorphisms F where\n  reflects f hf := by\n    haveI : Epi f := epi_of_epi_map F inferInstance\n    haveI : Mono f := mono_of_mono_map F inferInstance\n    exact isIso_of_mono_of_epi f", "start": [66, 1], "end": [72, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/DiscreteCategory.lean", "imports": ["Mathlib/Data/ULift.lean", "Mathlib/CategoryTheory/EqToHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Discrete", "code": "@[ext, aesop safe cases (rule_sets [CategoryTheory])]\nstructure Discrete (\u03b1 : Type u\u2081) where\n  \n  as : \u03b1", "start": [44, 1], "end": [51, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.mk_as", "code": "@[simp]\ntheorem Discrete.mk_as {\u03b1 : Type u\u2081} (X : Discrete \u03b1) : Discrete.mk X.as = X", "start": [54, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discreteEquiv", "code": "@[simps]\ndef discreteEquiv {\u03b1 : Type u\u2081} : Discrete \u03b1 \u2243 \u03b1 where\n  toFun := Discrete.as\n  invFun := Discrete.mk\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [60, 1], "end": [66, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.discreteCategory", "code": "instance discreteCategory (\u03b1 : Type u\u2081) : SmallCategory (Discrete \u03b1) where\n  Hom X Y := ULift (PLift (X.as = Y.as))\n  id X := ULift.up (PLift.up rfl)\n  comp {X Y Z} g f := by\n    cases X\n    cases Y\n    cases Z\n    rcases f with \u27e8\u27e8\u27e8\u27e9\u27e9\u27e9\n    exact g", "start": [72, 1], "end": [87, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.instSubsingletonDiscreteHom", "code": "instance instSubsingletonDiscreteHom (X Y : Discrete \u03b1) : Subsingleton (X \u27f6 Y) :=\n  show Subsingleton (ULift (PLift _)) from inferInstance", "start": [100, 1], "end": [101, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.discreteCases", "code": "def discreteCases : TacticM Unit := do\n  evalTactic (\u2190 `(tactic| discrete_cases))", "start": [109, 1], "end": [119, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.eq_of_hom", "code": "theorem eq_of_hom {X Y : Discrete \u03b1} (i : X \u27f6 Y) : X.as = Y.as", "start": [131, 1], "end": [133, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.eqToHom", "code": "protected abbrev eqToHom {X Y : Discrete \u03b1} (h : X.as = Y.as) : X \u27f6 Y :=\n  eqToHom (by aesop_cat)", "start": [136, 1], "end": [139, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.eqToIso", "code": "protected abbrev eqToIso {X Y : Discrete \u03b1} (h : X.as = Y.as) : X \u2245 Y :=\n  eqToIso (by aesop_cat)", "start": [142, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.eqToHom'", "code": "abbrev eqToHom' {a b : \u03b1} (h : a = b) : Discrete.mk a \u27f6 Discrete.mk b :=\n  Discrete.eqToHom h", "start": [148, 1], "end": [150, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.eqToIso'", "code": "abbrev eqToIso' {a b : \u03b1} (h : a = b) : Discrete.mk a \u2245 Discrete.mk b :=\n  Discrete.eqToIso h", "start": [153, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.id_def", "code": "@[simp]\ntheorem id_def (X : Discrete \u03b1) : ULift.up (PLift.up (Eq.refl X.as)) = \ud835\udfd9 X", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.functor", "code": "def functor {I : Type u\u2081} (F : I \u2192 C) : Discrete I \u2964 C where\n  obj := F \u2218 Discrete.as\n  map {X Y} f := by\n    dsimp\n    rcases f with \u27e8\u27e8h\u27e9\u27e9\n    exact eqToHom (congrArg _ h)", "start": [171, 1], "end": [177, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.functor_obj", "code": "@[simp]\ntheorem functor_obj {I : Type u\u2081} (F : I \u2192 C) (i : I) :\n    (Discrete.functor F).obj (Discrete.mk i) = F i", "start": [180, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.functor_map", "code": "theorem functor_map {I : Type u\u2081} (F : I \u2192 C) {i : Discrete I} (f : i \u27f6 i) :\n    (Discrete.functor F).map f = \ud835\udfd9 (F i.as)", "start": [186, 1], "end": [187, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.functorComp", "code": "@[simps!]\ndef functorComp {I : Type u\u2081} {J : Type u\u2081'} (f : J \u2192 C) (g : I \u2192 J) :\n    Discrete.functor (f \u2218 g) \u2245 Discrete.functor (Discrete.mk \u2218 g) \u22d9 Discrete.functor f :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [190, 1], "end": [196, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.natTrans", "code": "@[simps]\ndef natTrans {I : Type u\u2081} {F G : Discrete I \u2964 C} (f : \u2200 i : Discrete I, F.obj i \u27f6 G.obj i) :\n    F \u27f6 G where\n  app := f\n  naturality := fun {X Y} \u27e8\u27e8g\u27e9\u27e9 => by\n    discrete_cases\n    rcases g\n    change F.map (\ud835\udfd9 _) \u226b _ = _ \u226b G.map (\ud835\udfd9 _)\n    simp", "start": [199, 1], "end": [211, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.natIso", "code": "@[simps!]\ndef natIso {I : Type u\u2081} {F G : Discrete I \u2964 C} (f : \u2200 i : Discrete I, F.obj i \u2245 G.obj i) :\n    F \u2245 G :=\n  NatIso.ofComponents f fun \u27e8\u27e8g\u27e9\u27e9 => by\n    discrete_cases\n    rcases g\n    change F.map (\ud835\udfd9 _) \u226b _ = _ \u226b G.map (\ud835\udfd9 _)\n    simp", "start": [214, 1], "end": [225, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.natIso_app", "code": "@[simp]\ntheorem natIso_app {I : Type u\u2081} {F G : Discrete I \u2964 C} (f : \u2200 i : Discrete I, F.obj i \u2245 G.obj i)\n    (i : Discrete I) : (Discrete.natIso f).app i = f i", "start": [228, 1], "end": [230, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.natIsoFunctor", "code": "@[simp]\ndef natIsoFunctor {I : Type u\u2081} {F : Discrete I \u2964 C} : F \u2245 Discrete.functor (F.obj \u2218 Discrete.mk) :=\n  natIso fun _ => Iso.refl _", "start": [233, 1], "end": [237, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.compNatIsoDiscrete", "code": "@[simp]\ndef compNatIsoDiscrete {I : Type u\u2081} {D : Type u\u2083} [Category.{v\u2083} D] (F : I \u2192 C) (G : C \u2964 D) :\n    Discrete.functor F \u22d9 G \u2245 Discrete.functor (G.obj \u2218 F) :=\n  natIso fun _ => Iso.refl _", "start": [240, 1], "end": [244, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.equivalence", "code": "@[simps]\ndef equivalence {I : Type u\u2081} {J : Type u\u2082} (e : I \u2243 J) : Discrete I \u224c Discrete J where\n  functor := Discrete.functor (Discrete.mk \u2218 (e : I \u2192 J))\n  inverse := Discrete.functor (Discrete.mk \u2218 (e.symm : J \u2192 I))\n  unitIso :=\n    Discrete.natIso fun i => eqToIso (by aesop_cat)\n  counitIso :=\n    Discrete.natIso fun j => eqToIso (by aesop_cat)", "start": [247, 1], "end": [257, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.equivOfEquivalence", "code": "@[simps]\ndef equivOfEquivalence {\u03b1 : Type u\u2081} {\u03b2 : Type u\u2082} (h : Discrete \u03b1 \u224c Discrete \u03b2) : \u03b1 \u2243 \u03b2 where\n  toFun := Discrete.as \u2218 h.functor.obj \u2218 Discrete.mk\n  invFun := Discrete.as \u2218 h.inverse.obj \u2218 Discrete.mk\n  left_inv a := by simpa using eq_of_hom (h.unitIso.app (Discrete.mk a)).2\n  right_inv a := by simpa using eq_of_hom (h.counitIso.app (Discrete.mk a)).1", "start": [260, 1], "end": [266, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.opposite", "code": "@[simps! functor_obj_as inverse_obj]\nprotected def opposite (\u03b1 : Type u\u2081) : (Discrete \u03b1)\u1d52\u1d56 \u224c Discrete \u03b1 :=\n  let F : Discrete \u03b1 \u2964 (Discrete \u03b1)\u1d52\u1d56 := Discrete.functor fun x => op (Discrete.mk x)\n  Equivalence.mk F.leftOp F\n  (NatIso.ofComponents fun \u27e8X\u27e9 => Iso.refl _)\n  (Discrete.natIso fun \u27e8X\u27e9 => Iso.refl _)", "start": [277, 1], "end": [283, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Discrete.functor_map_id", "code": "@[simp]\ntheorem functor_map_id (F : Discrete J \u2964 C) {j : Discrete J} (f : j \u27f6 j) :\n    F.map f = \ud835\udfd9 (F.obj j)", "start": [289, 1], "end": [294, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/Strict.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/Basic.lean", "Mathlib/CategoryTheory/EqToHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bicategory.Strict", "code": "class Bicategory.Strict : Prop where\n  \n  id_comp : \u2200 {a b : B} (f : a \u27f6 b), \ud835\udfd9 a \u226b f = f := by aesop_cat\n  \n  comp_id : \u2200 {a b : B} (f : a \u27f6 b), f \u226b \ud835\udfd9 b = f := by aesop_cat\n  \n  assoc : \u2200 {a b c d : B} (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d), (f \u226b g) \u226b h = f \u226b g \u226b h := by\n    aesop_cat\n  \n  leftUnitor_eqToIso : \u2200 {a b : B} (f : a \u27f6 b), \u03bb_ f = eqToIso (id_comp f) := by aesop_cat\n  \n  rightUnitor_eqToIso : \u2200 {a b : B} (f : a \u27f6 b), \u03c1_ f = eqToIso (comp_id f) := by aesop_cat\n  \n  associator_eqToIso :\n    \u2200 {a b c d : B} (f : a \u27f6 b) (g : b \u27f6 c) (h : c \u27f6 d), \u03b1_ f g h = eqToIso (assoc f g h) := by\n    aesop_cat", "start": [35, 1], "end": [53, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StrictBicategory.category", "code": "instance (priority := 100) StrictBicategory.category [Bicategory.Strict B] : Category B\n    where\n  id_comp := Bicategory.Strict.id_comp\n  comp_id := Bicategory.Strict.comp_id\n  assoc := Bicategory.Strict.assoc", "start": [66, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.whiskerLeft_eqToHom", "code": "@[simp]\ntheorem whiskerLeft_eqToHom {a b c : B} (f : a \u27f6 b) {g h : b \u27f6 c} (\u03b7 : g = h) :\n    f \u25c1 eqToHom \u03b7 = eqToHom (congr_arg\u2082 (\u00b7 \u226b \u00b7) rfl \u03b7)", "start": [78, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.eqToHom_whiskerRight", "code": "@[simp]\ntheorem eqToHom_whiskerRight {a b c : B} {f g : a \u27f6 b} (\u03b7 : f = g) (h : b \u27f6 c) :\n    eqToHom \u03b7 \u25b7 h = eqToHom (congr_arg\u2082 (\u00b7 \u226b \u00b7) \u03b7 rfl)", "start": [85, 1], "end": [89, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/ConcreteCategory/Bundled.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Tactic/CoeExt.lean", "lake-packages/std/Std/Tactic/Lint/Frontend.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Tactic/Lint/Misc.lean"], "premises": [{"full_name": "CategoryTheory.Bundled", "code": "structure Bundled (c : Type u \u2192 Type v) : Type max (u + 1) v where\n  \n  \u03b1 : Type u\n  \n  str : c \u03b1 := by infer_instance", "start": [29, 1], "end": [35, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bundled.of", "code": "def of {c : Type u \u2192 Type v} (\u03b1 : Type u) [str : c \u03b1] : Bundled c :=\n  \u27e8\u03b1, str\u27e9", "start": [48, 1], "end": [50, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bundled.coeSort", "code": "instance coeSort : CoeSort (Bundled c) (Type u) :=\n  \u27e8Bundled.\u03b1\u27e9", "start": [53, 1], "end": [54, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bundled.coe_mk", "code": "theorem coe_mk (\u03b1) (str) : (@Bundled.mk c \u03b1 str : Type u) = \u03b1", "start": [56, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bundled.map", "code": "def map (f : \u2200 {\u03b1}, c \u03b1 \u2192 d \u03b1) (b : Bundled c) : Bundled d :=\n  \u27e8b, f b.str\u27e9", "start": [72, 1], "end": [74, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Option.lean", "imports": ["Mathlib/Logic/Equiv/Option.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "Mathlib/Data/Fintype/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.optionCongr_one", "code": "@[simp]\ntheorem Equiv.optionCongr_one {\u03b1 : Type*} : (1 : Perm \u03b1).optionCongr = 1", "start": [19, 1], "end": [21, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_swap", "code": "@[simp]\ntheorem Equiv.optionCongr_swap {\u03b1 : Type*} [DecidableEq \u03b1] (x y : \u03b1) :\n    optionCongr (swap x y) = swap (some x) (some y)", "start": [24, 1], "end": [32, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_sign", "code": "@[simp]\ntheorem Equiv.optionCongr_sign {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] (e : Perm \u03b1) :\n    Perm.sign e.optionCongr = Perm.sign e", "start": [35, 1], "end": [41, 59], "kind": "commanddeclaration"}, {"full_name": "map_equiv_removeNone", "code": "@[simp]\ntheorem map_equiv_removeNone {\u03b1 : Type*} [DecidableEq \u03b1] (\u03c3 : Perm (Option \u03b1)) :\n    (removeNone \u03c3).optionCongr = swap none (\u03c3 none) * \u03c3", "start": [44, 1], "end": [56, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeOption", "code": "@[simps]\ndef Equiv.Perm.decomposeOption {\u03b1 : Type*} [DecidableEq \u03b1] : Perm (Option \u03b1) \u2243 Option \u03b1 \u00d7 Perm \u03b1\n    where\n  toFun \u03c3 := (\u03c3 none, removeNone \u03c3)\n  invFun i := swap none i.1 * i.2.optionCongr\n  left_inv \u03c3 := by simp\n  right_inv := fun \u27e8x, \u03c3\u27e9 => by\n    have : removeNone (swap none x * \u03c3.optionCongr) = \u03c3 :=\n      Equiv.optionCongr_injective (by simp [\u2190 mul_assoc])\n    simp [\u2190 Perm.eq_inv_iff_eq, this]", "start": [59, 1], "end": [71, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeOption_symm_of_none_apply", "code": "theorem Equiv.Perm.decomposeOption_symm_of_none_apply {\u03b1 : Type*} [DecidableEq \u03b1] (e : Perm \u03b1)\n    (i : Option \u03b1) : Equiv.Perm.decomposeOption.symm (none, e) i = i.map e", "start": [74, 1], "end": [75, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeOption_symm_sign", "code": "theorem Equiv.Perm.decomposeOption_symm_sign {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] (e : Perm \u03b1) :\n    Perm.sign (Equiv.Perm.decomposeOption.symm (none, e)) = Perm.sign e", "start": [78, 1], "end": [79, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_perm_option", "code": "theorem Finset.univ_perm_option {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] :\n    @Finset.univ (Perm <| Option \u03b1) _ =\n      (Finset.univ : Finset <| Option \u03b1 \u00d7 Perm \u03b1).map Equiv.Perm.decomposeOption.symm.toEmbedding", "start": [82, 1], "end": [87, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "imports": ["Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "Mathlib/Data/List/Rotate.lean", "Mathlib/Combinatorics/Partition.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/NormNum/GCD.lean", "Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Algebra/GCDMonoid/Multiset.lean"], "premises": [{"full_name": "Equiv.Perm.cycleType", "code": "def cycleType (\u03c3 : Perm \u03b1) : Multiset \u2115 :=\n  \u03c3.cycleFactorsFinset.1.map (Finset.card \u2218 support)", "start": [46, 1], "end": [48, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_def", "code": "theorem cycleType_def (\u03c3 : Perm \u03b1) :\n    \u03c3.cycleType = \u03c3.cycleFactorsFinset.1.map (Finset.card \u2218 support)", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_eq'", "code": "theorem cycleType_eq' {\u03c3 : Perm \u03b1} (s : Finset (Perm \u03b1)) (h1 : \u2200 f : Perm \u03b1, f \u2208 s \u2192 f.IsCycle)\n    (h2 : (s : Set (Perm \u03b1)).Pairwise Disjoint)\n    (h0 : s.noncommProd id (h2.imp fun _ _ => Disjoint.commute) = \u03c3) :\n    \u03c3.cycleType = s.1.map (Finset.card \u2218 support)", "start": [56, 1], "end": [63, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_eq", "code": "theorem cycleType_eq {\u03c3 : Perm \u03b1} (l : List (Perm \u03b1)) (h0 : l.prod = \u03c3)\n    (h1 : \u2200 \u03c3 : Perm \u03b1, \u03c3 \u2208 l \u2192 \u03c3.IsCycle) (h2 : l.Pairwise Disjoint) :\n    \u03c3.cycleType = l.map (Finset.card \u2218 support)", "start": [66, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_eq_zero", "code": "@[simp] theorem cycleType_eq_zero {\u03c3 : Perm \u03b1} : \u03c3.cycleType = 0 \u2194 \u03c3 = 1", "start": [77, 1], "end": [79, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_one", "code": "@[simp] theorem cycleType_one : (1 : Perm \u03b1).cycleType = 0", "start": [82, 1], "end": [83, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_cycleType_eq_zero", "code": "theorem card_cycleType_eq_zero {\u03c3 : Perm \u03b1} : Multiset.card \u03c3.cycleType = 0 \u2194 \u03c3 = 1", "start": [86, 1], "end": [87, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_cycleType_pos", "code": "theorem card_cycleType_pos {\u03c3 : Perm \u03b1} : 0 < Multiset.card \u03c3.cycleType \u2194 \u03c3 \u2260 1", "start": [90, 1], "end": [91, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.two_le_of_mem_cycleType", "code": "theorem two_le_of_mem_cycleType {\u03c3 : Perm \u03b1} {n : \u2115} (h : n \u2208 \u03c3.cycleType) : 2 \u2264 n", "start": [93, 1], "end": [97, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_lt_of_mem_cycleType", "code": "theorem one_lt_of_mem_cycleType {\u03c3 : Perm \u03b1} {n : \u2115} (h : n \u2208 \u03c3.cycleType) : 1 < n", "start": [100, 1], "end": [101, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsCycle.cycleType", "code": "theorem IsCycle.cycleType {\u03c3 : Perm \u03b1} (h\u03c3 : IsCycle \u03c3) : \u03c3.cycleType = [\u03c3.support.card]", "start": [104, 1], "end": [106, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_cycleType_eq_one", "code": "theorem card_cycleType_eq_one {\u03c3 : Perm \u03b1} : Multiset.card \u03c3.cycleType = 1 \u2194 \u03c3.IsCycle", "start": [109, 1], "end": [118, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.Disjoint.cycleType", "code": "theorem Disjoint.cycleType {\u03c3 \u03c4 : Perm \u03b1} (h : Disjoint \u03c3 \u03c4) :\n    (\u03c3 * \u03c4).cycleType = \u03c3.cycleType + \u03c4.cycleType", "start": [121, 1], "end": [125, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_inv", "code": "@[simp] theorem cycleType_inv (\u03c3 : Perm \u03b1) : \u03c3\u207b\u00b9.cycleType = \u03c3.cycleType", "start": [128, 1], "end": [134, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_conj", "code": "@[simp] theorem cycleType_conj {\u03c3 \u03c4 : Perm \u03b1} : (\u03c4 * \u03c3 * \u03c4\u207b\u00b9).cycleType = \u03c3.cycleType", "start": [137, 1], "end": [143, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sum_cycleType", "code": "theorem sum_cycleType (\u03c3 : Perm \u03b1) : \u03c3.cycleType.sum = \u03c3.support.card", "start": [146, 1], "end": [150, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_of_cycleType'", "code": "theorem sign_of_cycleType' (\u03c3 : Perm \u03b1) :\n    sign \u03c3 = (\u03c3.cycleType.map fun n => -(-1 : \u2124\u02e3) ^ n).prod", "start": [153, 1], "end": [158, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sign_of_cycleType", "code": "theorem sign_of_cycleType (f : Perm \u03b1) :\n    sign f = (-1 : \u2124\u02e3) ^ (f.cycleType.sum + Multiset.card f.cycleType)", "start": [161, 1], "end": [167, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.lcm_cycleType", "code": "@[simp] theorem lcm_cycleType (\u03c3 : Perm \u03b1) : \u03c3.cycleType.lcm = orderOf \u03c3", "start": [170, 1], "end": [175, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.dvd_of_mem_cycleType", "code": "theorem dvd_of_mem_cycleType {\u03c3 : Perm \u03b1} {n : \u2115} (h : n \u2208 \u03c3.cycleType) : n \u2223 orderOf \u03c3", "start": [178, 1], "end": [180, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.orderOf_cycleOf_dvd_orderOf", "code": "theorem orderOf_cycleOf_dvd_orderOf (f : Perm \u03b1) (x : \u03b1) : orderOf (cycleOf f x) \u2223 orderOf f", "start": [183, 1], "end": [191, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.two_dvd_card_support", "code": "theorem two_dvd_card_support {\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ 2 = 1) : 2 \u2223 \u03c3.support.card", "start": [194, 1], "end": [200, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_prime_order", "code": "theorem cycleType_prime_order {\u03c3 : Perm \u03b1} (h\u03c3 : (orderOf \u03c3).Prime) :\n    \u2203 n : \u2115, \u03c3.cycleType = replicate (n + 1) (orderOf \u03c3)", "start": [203, 1], "end": [210, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_of_prime_order", "code": "theorem isCycle_of_prime_order {\u03c3 : Perm \u03b1} (h1 : (orderOf \u03c3).Prime)\n    (h2 : \u03c3.support.card < 2 * orderOf \u03c3) : \u03c3.IsCycle", "start": [213, 1], "end": [218, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_le_of_mem_cycleFactorsFinset", "code": "theorem cycleType_le_of_mem_cycleFactorsFinset {f g : Perm \u03b1} (hf : f \u2208 g.cycleFactorsFinset) :\n    f.cycleType \u2264 g.cycleType", "start": [221, 1], "end": [226, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub", "code": "theorem cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub\n    {f g : Perm \u03b1} (hf : f \u2208 g.cycleFactorsFinset) :\n    (g * f\u207b\u00b9).cycleType = g.cycleType - f.cycleType", "start": [229, 1], "end": [234, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isConj_of_cycleType_eq", "code": "theorem isConj_of_cycleType_eq {\u03c3 \u03c4 : Perm \u03b1} (h : cycleType \u03c3 = cycleType \u03c4) : IsConj \u03c3 \u03c4", "start": [237, 1], "end": [263, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isConj_iff_cycleType_eq", "code": "theorem isConj_iff_cycleType_eq {\u03c3 \u03c4 : Perm \u03b1} : IsConj \u03c3 \u03c4 \u2194 \u03c3.cycleType = \u03c4.cycleType", "start": [266, 1], "end": [269, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_extendDomain", "code": "@[simp]\ntheorem cycleType_extendDomain {\u03b2 : Type*} [Fintype \u03b2] [DecidableEq \u03b2] {p : \u03b2 \u2192 Prop}\n    [DecidablePred p] (f : \u03b1 \u2243 Subtype p) {g : Perm \u03b1} :\n    cycleType (g.extendDomain f) = cycleType g", "start": [272, 1], "end": [281, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_ofSubtype", "code": "theorem cycleType_ofSubtype {p : \u03b1 \u2192 Prop} [DecidablePred p] {g : Perm (Subtype p)} :\n    cycleType (ofSubtype g) = cycleType g", "start": [284, 1], "end": [286, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_cycleType_iff", "code": "theorem mem_cycleType_iff {n : \u2115} {\u03c3 : Perm \u03b1} :\n    n \u2208 cycleType \u03c3 \u2194 \u2203 c \u03c4, \u03c3 = c * \u03c4 \u2227 Disjoint c \u03c4 \u2227 IsCycle c \u2227 c.support.card = n", "start": [289, 1], "end": [301, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.le_card_support_of_mem_cycleType", "code": "theorem le_card_support_of_mem_cycleType {n : \u2115} {\u03c3 : Perm \u03b1} (h : n \u2208 cycleType \u03c3) :\n    n \u2264 \u03c3.support.card", "start": [304, 1], "end": [306, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.cycleType_of_card_le_mem_cycleType_add_two", "code": "theorem cycleType_of_card_le_mem_cycleType_add_two {n : \u2115} {g : Perm \u03b1}\n    (hn2 : Fintype.card \u03b1 < n + 2) (hng : n \u2208 g.cycleType) : g.cycleType = {n}", "start": [309, 1], "end": [317, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_compl_support_modEq", "code": "theorem card_compl_support_modEq [DecidableEq \u03b1] {p n : \u2115} [hp : Fact p.Prime] {\u03c3 : Perm \u03b1}\n    (h\u03c3 : \u03c3 ^ p ^ n = 1) : \u03c3.support\u1d9c.card \u2261 Fintype.card \u03b1 [MOD p]", "start": [322, 1], "end": [330, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.card_fixedPoints_modEq", "code": "theorem card_fixedPoints_modEq [DecidableEq \u03b1] {f : Function.End \u03b1} {p n : \u2115}\n    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :\n    Fintype.card \u03b1 \u2261 Fintype.card f.fixedPoints [MOD p]", "start": [334, 1], "end": [349, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.exists_fixed_point_of_prime", "code": "theorem exists_fixed_point_of_prime {p n : \u2115} [hp : Fact p.Prime] (h\u03b1 : \u00acp \u2223 Fintype.card \u03b1)\n    {\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ p ^ n = 1) : \u2203 a : \u03b1, \u03c3 a = a", "start": [351, 1], "end": [357, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.exists_fixed_point_of_prime'", "code": "theorem exists_fixed_point_of_prime' {p n : \u2115} [hp : Fact p.Prime] (h\u03b1 : p \u2223 Fintype.card \u03b1)\n    {\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ p ^ n = 1) {a : \u03b1} (ha : \u03c3 a = a) : \u2203 b : \u03b1, \u03c3 b = b \u2227 b \u2260 a", "start": [360, 1], "end": [368, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_of_prime_order'", "code": "theorem isCycle_of_prime_order' {\u03c3 : Perm \u03b1} (h1 : (orderOf \u03c3).Prime)\n    (h2 : Fintype.card \u03b1 < 2 * orderOf \u03c3) : \u03c3.IsCycle", "start": [371, 1], "end": [373, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isCycle_of_prime_order''", "code": "theorem isCycle_of_prime_order'' {\u03c3 : Perm \u03b1} (h1 : (Fintype.card \u03b1).Prime)\n    (h2 : orderOf \u03c3 = Fintype.card \u03b1) : \u03c3.IsCycle", "start": [376, 1], "end": [380, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.vectorsProdEqOne", "code": "def vectorsProdEqOne : Set (Vector G n) :=\n  { v | v.toList.prod = 1 }", "start": [387, 1], "end": [389, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.mem_iff", "code": "theorem mem_iff {n : \u2115} (v : Vector G n) : v \u2208 vectorsProdEqOne G n \u2194 v.toList.prod = 1", "start": [394, 1], "end": [395, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.zero_eq", "code": "theorem zero_eq : vectorsProdEqOne G 0 = {Vector.nil}", "start": [398, 1], "end": [399, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.one_eq", "code": "theorem one_eq : vectorsProdEqOne G 1 = {Vector.nil.cons 1}", "start": [402, 1], "end": [405, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.zeroUnique", "code": "instance zeroUnique : Unique (vectorsProdEqOne G 0) := by\n  rw [zero_eq]\n  exact Set.uniqueSingleton Vector.nil", "start": [408, 1], "end": [410, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.oneUnique", "code": "instance oneUnique : Unique (vectorsProdEqOne G 1) := by\n  rw [one_eq]\n  exact Set.uniqueSingleton (Vector.nil.cons 1)", "start": [413, 1], "end": [415, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.vectorEquiv", "code": "@[simps]\ndef vectorEquiv : Vector G n \u2243 vectorsProdEqOne G (n + 1) where\n  toFun v := \u27e8v.toList.prod\u207b\u00b9 ::\u1d65 v, by\n    rw [mem_iff, Vector.toList_cons, List.prod_cons, inv_mul_self]\u27e9\n  invFun v := v.1.tail\n  left_inv v := v.tail_cons v.toList.prod\u207b\u00b9\n  right_inv v := Subtype.ext <|\n    calc\n      v.1.tail.toList.prod\u207b\u00b9 ::\u1d65 v.1.tail = v.1.head ::\u1d65 v.1.tail :=\n        congr_arg (\u00b7 ::\u1d65 v.1.tail) <| Eq.symm <| eq_inv_of_mul_eq_one_left <| by\n          rw [\u2190 List.prod_cons, \u2190 Vector.toList_cons, v.1.cons_head_tail]\n          exact v.2\n      _ = v.1 := v.1.cons_head_tail", "start": [418, 1], "end": [432, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.equivVector", "code": "def equivVector : \u2200 n, vectorsProdEqOne G n \u2243 Vector G (n - 1)\n  | 0 => (equivOfUnique (vectorsProdEqOne G 0) (vectorsProdEqOne G 1)).trans (vectorEquiv G 0).symm\n  | (n + 1) => (vectorEquiv G n).symm", "start": [435, 1], "end": [439, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.card", "code": "theorem card [Fintype G] : Fintype.card (vectorsProdEqOne G n) = Fintype.card G ^ (n - 1)", "start": [445, 1], "end": [446, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.rotate", "code": "def rotate : vectorsProdEqOne G n :=\n  \u27e8\u27e8_, (v.1.1.length_rotate k).trans v.1.2\u27e9, List.prod_rotate_eq_one_of_prod_eq_one v.2 k\u27e9", "start": [452, 1], "end": [454, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.rotate_zero", "code": "theorem rotate_zero : rotate v 0 = v", "start": [457, 1], "end": [458, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.rotate_rotate", "code": "theorem rotate_rotate : rotate (rotate v j) k = rotate v (j + k)", "start": [461, 1], "end": [462, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.VectorsProdEqOne.rotate_length", "code": "theorem rotate_length : rotate v n = v", "start": [465, 1], "end": [466, 81], "kind": "commanddeclaration"}, {"full_name": "exists_prime_orderOf_dvd_card", "code": "theorem _root_.exists_prime_orderOf_dvd_card {G : Type*} [Group G] [Fintype G] (p : \u2115)\n    [hp : Fact p.Prime] (hdvd : p \u2223 Fintype.card G) : \u2203 x : G, orderOf x = p", "start": [471, 1], "end": [501, 8], "kind": "commanddeclaration"}, {"full_name": "exists_prime_addOrderOf_dvd_card", "code": "theorem _root_.exists_prime_addOrderOf_dvd_card {G : Type*} [AddGroup G] [Fintype G] (p : \u2115)\n    [hp : Fact p.Prime] (hdvd : p \u2223 Fintype.card G) : \u2203 x : G, addOrderOf x = p", "start": [504, 1], "end": [508, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subgroup_eq_top_of_swap_mem", "code": "theorem subgroup_eq_top_of_swap_mem [DecidableEq \u03b1] {H : Subgroup (Perm \u03b1)}\n    [d : DecidablePred (\u00b7 \u2208 H)] {\u03c4 : Perm \u03b1} (h0 : (Fintype.card \u03b1).Prime)\n    (h1 : Fintype.card \u03b1 \u2223 Fintype.card H) (h2 : \u03c4 \u2208 H) (h3 : IsSwap \u03c4) : H = \u22a4", "start": [515, 1], "end": [526, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.partition", "code": "def partition (\u03c3 : Perm \u03b1) : (Fintype.card \u03b1).Partition where\n  parts := \u03c3.cycleType + replicate (Fintype.card \u03b1 - \u03c3.support.card) 1\n  parts_pos {n hn} := by\n    cases' mem_add.mp hn with hn hn\n    \u00b7 exact zero_lt_one.trans (one_lt_of_mem_cycleType hn)\n    \u00b7 exact lt_of_lt_of_le zero_lt_one (ge_of_eq (Multiset.eq_of_mem_replicate hn))\n  parts_sum := by\n    rw [sum_add, sum_cycleType, Multiset.sum_replicate, nsmul_eq_mul, Nat.cast_id, mul_one,\n      add_tsub_cancel_of_le \u03c3.support.card_le_univ]", "start": [533, 1], "end": [542, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.parts_partition", "code": "theorem parts_partition {\u03c3 : Perm \u03b1} :\n    \u03c3.partition.parts = \u03c3.cycleType + replicate (Fintype.card \u03b1 - \u03c3.support.card) 1", "start": [545, 1], "end": [547, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.filter_parts_partition_eq_cycleType", "code": "theorem filter_parts_partition_eq_cycleType {\u03c3 : Perm \u03b1} :\n    ((partition \u03c3).parts.filter fun n => 2 \u2264 n) = \u03c3.cycleType", "start": [550, 1], "end": [555, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.partition_eq_of_isConj", "code": "theorem partition_eq_of_isConj {\u03c3 \u03c4 : Perm \u03b1} : IsConj \u03c3 \u03c4 \u2194 \u03c3.partition = \u03c4.partition", "start": [558, 1], "end": [563, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle", "code": "def IsThreeCycle [DecidableEq \u03b1] (\u03c3 : Perm \u03b1) : Prop :=\n  \u03c3.cycleType = {3}", "start": [573, 1], "end": [575, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.cycleType", "code": "theorem cycleType (h : IsThreeCycle \u03c3) : \u03c3.cycleType = {3}", "start": [582, 1], "end": [583, 4], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.card_support", "code": "theorem card_support (h : IsThreeCycle \u03c3) : \u03c3.support.card = 3", "start": [586, 1], "end": [587, 60], "kind": "commanddeclaration"}, {"full_name": "card_support_eq_three_iff", "code": "theorem _root_.card_support_eq_three_iff : \u03c3.support.card = 3 \u2194 \u03c3.IsThreeCycle", "start": [590, 1], "end": [605, 92], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.isCycle", "code": "theorem isCycle (h : IsThreeCycle \u03c3) : IsCycle \u03c3", "start": [608, 1], "end": [609, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.sign", "code": "theorem sign (h : IsThreeCycle \u03c3) : sign \u03c3 = 1", "start": [612, 1], "end": [614, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.inv", "code": "theorem inv {f : Perm \u03b1} (h : IsThreeCycle f) : IsThreeCycle f\u207b\u00b9", "start": [617, 1], "end": [618, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.inv_iff", "code": "@[simp]\ntheorem inv_iff {f : Perm \u03b1} : IsThreeCycle f\u207b\u00b9 \u2194 IsThreeCycle f", "start": [621, 1], "end": [625, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.orderOf", "code": "theorem orderOf {g : Perm \u03b1} (ht : IsThreeCycle g) : orderOf g = 3", "start": [628, 1], "end": [629, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsThreeCycle.isThreeCycle_sq", "code": "theorem isThreeCycle_sq {g : Perm \u03b1} (ht : IsThreeCycle g) : IsThreeCycle (g * g)", "start": [632, 1], "end": [635, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.isThreeCycle_swap_mul_swap_same", "code": "theorem isThreeCycle_swap_mul_swap_same {a b c : \u03b1} (ab : a \u2260 b) (ac : a \u2260 c) (bc : b \u2260 c) :\n    IsThreeCycle (swap a b * swap a c)", "start": [644, 1], "end": [660, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.swap_mul_swap_same_mem_closure_three_cycles", "code": "theorem swap_mul_swap_same_mem_closure_three_cycles {a b c : \u03b1} (ab : a \u2260 b) (ac : a \u2260 c) :\n    swap a b * swap a c \u2208 closure { \u03c3 : Perm \u03b1 | IsThreeCycle \u03c3 }", "start": [665, 1], "end": [670, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.IsSwap.mul_mem_closure_three_cycles", "code": "theorem IsSwap.mul_mem_closure_three_cycles {\u03c3 \u03c4 : Perm \u03b1} (h\u03c3 : IsSwap \u03c3) (h\u03c4 : IsSwap \u03c4) :\n    \u03c3 * \u03c4 \u2208 closure { \u03c3 : Perm \u03b1 | IsThreeCycle \u03c3 }", "start": [673, 1], "end": [685, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Multilinear/Basis.lean", "imports": ["Mathlib/LinearAlgebra/Basis.lean", "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Basis.ext_multilinear_fin", "code": "theorem Basis.ext_multilinear_fin {f g : MultilinearMap R M M\u2082} {\u03b9\u2081 : Fin n \u2192 Type*}\n    (e : \u2200 i, Basis (\u03b9\u2081 i) R (M i))\n    (h : \u2200 v : \u2200 i, \u03b9\u2081 i, (f fun i => e i (v i)) = g fun i => e i (v i)) : f = g", "start": [32, 1], "end": [51, 40], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_multilinear", "code": "theorem Basis.ext_multilinear [Finite \u03b9] {f g : MultilinearMap R (fun _ : \u03b9 => M\u2082) M\u2083} {\u03b9\u2081 : Type*}\n    (e : Basis \u03b9\u2081 R M\u2082) (h : \u2200 v : \u03b9 \u2192 \u03b9\u2081, (f fun i => e (v i)) = g fun i => e (v i)) : f = g", "start": [54, 1], "end": [63, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PEquiv.lean", "imports": ["Mathlib/Data/Set/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PEquiv", "code": "structure PEquiv (\u03b1 : Type u) (\u03b2 : Type v) where\n  \n  toFun : \u03b1 \u2192 Option \u03b2\n  \n  invFun : \u03b2 \u2192 Option \u03b1\n  \n  inv : \u2200 (a : \u03b1) (b : \u03b2), a \u2208 invFun b \u2194 b \u2208 toFun a", "start": [45, 1], "end": [54, 54], "kind": "commanddeclaration"}, {"full_name": "PEquiv.coe_mk", "code": "@[simp] theorem coe_mk (f\u2081 : \u03b1 \u2192 Option \u03b2) (f\u2082 h) : (mk f\u2081 f\u2082 h : \u03b1 \u2192 Option \u03b2) = f\u2081", "start": [75, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.coe_mk_apply", "code": "theorem coe_mk_apply (f\u2081 : \u03b1 \u2192 Option \u03b2) (f\u2082 : \u03b2 \u2192 Option \u03b1) (h) (x : \u03b1) :\n    (PEquiv.mk f\u2081 f\u2082 h : \u03b1 \u2192 Option \u03b2) x = f\u2081 x", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ext", "code": "@[ext] theorem ext {f g : \u03b1 \u2243. \u03b2} (h : \u2200 x, f x = g x) : f = g", "start": [83, 1], "end": [84, 20], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ext_iff", "code": "theorem ext_iff {f g : \u03b1 \u2243. \u03b2} : f = g \u2194 \u2200 x, f x = g x", "start": [87, 1], "end": [88, 18], "kind": "commanddeclaration"}, {"full_name": "PEquiv.refl", "code": "@[refl]\nprotected def refl (\u03b1 : Type*) : \u03b1 \u2243. \u03b1 where\n  toFun := some\n  invFun := some\n  inv _ _ := eq_comm", "start": [91, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm", "code": "@[symm]\nprotected def symm (f : \u03b1 \u2243. \u03b2) : \u03b2 \u2243. \u03b1 where\n  toFun := f.2\n  invFun := f.1\n  inv _ _ := (f.inv _ _).symm", "start": [99, 1], "end": [104, 30], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_iff_mem", "code": "theorem mem_iff_mem (f : \u03b1 \u2243. \u03b2) : \u2200 {a : \u03b1} {b : \u03b2}, a \u2208 f.symm b \u2194 b \u2208 f a", "start": [107, 1], "end": [108, 10], "kind": "commanddeclaration"}, {"full_name": "PEquiv.eq_some_iff", "code": "theorem eq_some_iff (f : \u03b1 \u2243. \u03b2) : \u2200 {a : \u03b1} {b : \u03b2}, f.symm b = some a \u2194 f a = some b", "start": [111, 1], "end": [112, 10], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans", "code": "@[trans]\nprotected def trans (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) :\n    \u03b1 \u2243. \u03b3 where\n  toFun a := (f a).bind g\n  invFun a := (g.symm a).bind f.symm\n  inv a b := by simp_all [and_comm, eq_some_iff f, eq_some_iff g]", "start": [115, 1], "end": [121, 66], "kind": "commanddeclaration"}, {"full_name": "PEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply (a : \u03b1) : PEquiv.refl \u03b1 a = some a", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_refl", "code": "@[simp]\ntheorem symm_refl : (PEquiv.refl \u03b1).symm = PEquiv.refl \u03b1", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (f : \u03b1 \u2243. \u03b2) : f.symm.symm = f", "start": [134, 1], "end": [135, 68], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_injective", "code": "theorem symm_injective : Function.Injective (@PEquiv.symm \u03b1 \u03b2)", "start": [138, 1], "end": [139, 34], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_assoc", "code": "theorem trans_assoc (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) (h : \u03b3 \u2243. \u03b4) :\n    (f.trans g).trans h = f.trans (g.trans h)", "start": [142, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_trans", "code": "theorem mem_trans (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) (a : \u03b1) (c : \u03b3) :\n    c \u2208 f.trans g a \u2194 \u2203 b, b \u2208 f a \u2227 c \u2208 g b", "start": [147, 1], "end": [149, 23], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_eq_some", "code": "theorem trans_eq_some (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) (a : \u03b1) (c : \u03b3) :\n    f.trans g a = some c \u2194 \u2203 b, f a = some b \u2227 g b = some c", "start": [152, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_eq_none", "code": "theorem trans_eq_none (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) (a : \u03b1) :\n    f.trans g a = none \u2194 \u2200 b c, b \u2209 f a \u2228 c \u2209 g b", "start": [157, 1], "end": [161, 20], "kind": "commanddeclaration"}, {"full_name": "PEquiv.refl_trans", "code": "@[simp]\ntheorem refl_trans (f : \u03b1 \u2243. \u03b2) : (PEquiv.refl \u03b1).trans f = f", "start": [164, 1], "end": [166, 33], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_refl", "code": "@[simp]\ntheorem trans_refl (f : \u03b1 \u2243. \u03b2) : f.trans (PEquiv.refl \u03b2) = f", "start": [169, 1], "end": [171, 34], "kind": "commanddeclaration"}, {"full_name": "PEquiv.inj", "code": "protected theorem inj (f : \u03b1 \u2243. \u03b2) {a\u2081 a\u2082 : \u03b1} {b : \u03b2} (h\u2081 : b \u2208 f a\u2081) (h\u2082 : b \u2208 f a\u2082) : a\u2081 = a\u2082", "start": [174, 1], "end": [175, 62], "kind": "commanddeclaration"}, {"full_name": "PEquiv.injective_of_forall_ne_isSome", "code": "theorem injective_of_forall_ne_isSome (f : \u03b1 \u2243. \u03b2) (a\u2082 : \u03b1)\n    (h : \u2200 a\u2081 : \u03b1, a\u2081 \u2260 a\u2082 \u2192 isSome (f a\u2081)) : Injective f", "start": [178, 1], "end": [189, 15], "kind": "commanddeclaration"}, {"full_name": "PEquiv.injective_of_forall_isSome", "code": "theorem injective_of_forall_isSome {f : \u03b1 \u2243. \u03b2} (h : \u2200 a : \u03b1, isSome (f a)) : Injective f", "start": [192, 1], "end": [196, 18], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet", "code": "def ofSet (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] :\n    \u03b1 \u2243. \u03b1 where\n  toFun a := if a \u2208 s then some a else none\n  invFun a := if a \u2208 s then some a else none\n  inv a b := by\n    dsimp only\n    split_ifs with hb ha ha\n    \u00b7 simp [eq_comm]\n    \u00b7 simp [ne_of_mem_of_not_mem hb ha]\n    \u00b7 simp [ne_of_mem_of_not_mem ha hb]\n    \u00b7 simp", "start": [203, 1], "end": [214, 11], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_ofSet_self_iff", "code": "theorem mem_ofSet_self_iff {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} : a \u2208 ofSet s a \u2194 a \u2208 s", "start": [217, 1], "end": [218, 43], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_ofSet_iff", "code": "theorem mem_ofSet_iff {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a b : \u03b1} :\n    a \u2208 ofSet s b \u2194 a = b \u2227 a \u2208 s", "start": [221, 1], "end": [230, 12], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet_eq_some_iff", "code": "@[simp]\ntheorem ofSet_eq_some_iff {s : Set \u03b1} {_ : DecidablePred (\u00b7 \u2208 s)} {a b : \u03b1} :\n    ofSet s b = some a \u2194 a = b \u2227 a \u2208 s", "start": [233, 1], "end": [236, 16], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet_eq_some_self_iff", "code": "theorem ofSet_eq_some_self_iff {s : Set \u03b1} {_ : DecidablePred (\u00b7 \u2208 s)} {a : \u03b1} :\n    ofSet s a = some a \u2194 a \u2208 s", "start": [239, 1], "end": [241, 21], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet_symm", "code": "@[simp]\ntheorem ofSet_symm : (ofSet s).symm = ofSet s", "start": [244, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet_univ", "code": "@[simp]\ntheorem ofSet_univ : ofSet Set.univ = PEquiv.refl \u03b1", "start": [249, 1], "end": [251, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.ofSet_eq_refl", "code": "@[simp]\ntheorem ofSet_eq_refl {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] :\n    ofSet s = PEquiv.refl \u03b1 \u2194 s = Set.univ", "start": [254, 1], "end": [261, 56], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_trans_rev", "code": "theorem symm_trans_rev (f : \u03b1 \u2243. \u03b2) (g : \u03b2 \u2243. \u03b3) : (f.trans g).symm = g.symm.trans f.symm", "start": [266, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.self_trans_symm", "code": "theorem self_trans_symm (f : \u03b1 \u2243. \u03b2) : f.trans f.symm = ofSet { a | (f a).isSome }", "start": [270, 1], "end": [278, 44], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_trans_self", "code": "theorem symm_trans_self (f : \u03b1 \u2243. \u03b2) : f.symm.trans f = ofSet { b | (f.symm b).isSome }", "start": [281, 1], "end": [282, 74], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_symm_eq_iff_forall_isSome", "code": "theorem trans_symm_eq_iff_forall_isSome {f : \u03b1 \u2243. \u03b2} :\n    f.trans f.symm = PEquiv.refl \u03b1 \u2194 \u2200 a, isSome (f a)", "start": [285, 1], "end": [287, 67], "kind": "commanddeclaration"}, {"full_name": "PEquiv.instBotPEquiv", "code": "instance instBotPEquiv : Bot (\u03b1 \u2243. \u03b2) :=\n  \u27e8{  toFun := fun _ => none\n      invFun := fun _ => none\n      inv := by simp }\u27e9", "start": [290, 1], "end": [293, 24], "kind": "commanddeclaration"}, {"full_name": "PEquiv.bot_apply", "code": "@[simp]\ntheorem bot_apply (a : \u03b1) : (\u22a5 : \u03b1 \u2243. \u03b2) a = none", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_bot", "code": "@[simp]\ntheorem symm_bot : (\u22a5 : \u03b1 \u2243. \u03b2).symm = \u22a5", "start": [303, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_bot", "code": "@[simp]\ntheorem trans_bot (f : \u03b1 \u2243. \u03b2) : f.trans (\u22a5 : \u03b2 \u2243. \u03b3) = \u22a5", "start": [308, 1], "end": [310, 34], "kind": "commanddeclaration"}, {"full_name": "PEquiv.bot_trans", "code": "@[simp]\ntheorem bot_trans (f : \u03b2 \u2243. \u03b3) : (\u22a5 : \u03b1 \u2243. \u03b2).trans f = \u22a5", "start": [313, 1], "end": [315, 34], "kind": "commanddeclaration"}, {"full_name": "PEquiv.isSome_symm_get", "code": "theorem isSome_symm_get (f : \u03b1 \u2243. \u03b2) {a : \u03b1} (h : isSome (f a)) :\n    isSome (f.symm (Option.get _ h))", "start": [318, 1], "end": [320, 59], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single", "code": "def single (a : \u03b1) (b : \u03b2) :\n    \u03b1 \u2243. \u03b2 where\n  toFun x := if x = a then some b else none\n  invFun x := if x = b then some a else none\n  inv x y := by\n    dsimp only\n    split_ifs with h1 h2\n    \u00b7 simp [*]\n    \u00b7 simp only [mem_def, some.injEq, iff_false] at *\n      exact Ne.symm h2\n    \u00b7 simp only [mem_def, some.injEq, false_iff] at *\n      exact Ne.symm h1\n    \u00b7 simp", "start": [327, 1], "end": [340, 11], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_single", "code": "theorem mem_single (a : \u03b1) (b : \u03b2) : b \u2208 single a b a", "start": [343, 1], "end": [344, 13], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mem_single_iff", "code": "theorem mem_single_iff (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) : b\u2081 \u2208 single a\u2082 b\u2082 a\u2081 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082", "start": [347, 1], "end": [348, 50], "kind": "commanddeclaration"}, {"full_name": "PEquiv.symm_single", "code": "@[simp]\ntheorem symm_single (a : \u03b1) (b : \u03b2) : (single a b).symm = single b a", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_apply", "code": "@[simp]\ntheorem single_apply (a : \u03b1) (b : \u03b2) : single a b a = some b", "start": [356, 1], "end": [358, 13], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_apply_of_ne", "code": "theorem single_apply_of_ne {a\u2081 a\u2082 : \u03b1} (h : a\u2081 \u2260 a\u2082) (b : \u03b2) : single a\u2081 b a\u2082 = none", "start": [361, 1], "end": [362, 16], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_trans_of_mem", "code": "theorem single_trans_of_mem (a : \u03b1) {b : \u03b2} {c : \u03b3} {f : \u03b2 \u2243. \u03b3} (h : c \u2208 f b) :\n    (single a b).trans f = single a c", "start": [365, 1], "end": [369, 25], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_single_of_mem", "code": "theorem trans_single_of_mem {a : \u03b1} {b : \u03b2} (c : \u03b3) {f : \u03b1 \u2243. \u03b2} (h : b \u2208 f a) :\n    f.trans (single b c) = single a c", "start": [372, 1], "end": [374, 64], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_trans_single", "code": "@[simp]\ntheorem single_trans_single (a : \u03b1) (b : \u03b2) (c : \u03b3) :\n    (single a b).trans (single b c) = single a c", "start": [377, 1], "end": [380, 41], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_subsingleton_eq_refl", "code": "@[simp]\ntheorem single_subsingleton_eq_refl [Subsingleton \u03b1] (a b : \u03b1) : single a b = PEquiv.refl \u03b1", "start": [383, 1], "end": [387, 84], "kind": "commanddeclaration"}, {"full_name": "PEquiv.trans_single_of_eq_none", "code": "theorem trans_single_of_eq_none {b : \u03b2} (c : \u03b3) {f : \u03b4 \u2243. \u03b2} (h : f.symm b = none) :\n    f.trans (single b c) = \u22a5", "start": [390, 1], "end": [397, 25], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_trans_of_eq_none", "code": "theorem single_trans_of_eq_none (a : \u03b1) {b : \u03b2} {f : \u03b2 \u2243. \u03b4} (h : f b = none) :\n    (single a b).trans f = \u22a5", "start": [400, 1], "end": [402, 48], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_trans_single_of_ne", "code": "theorem single_trans_single_of_ne {b\u2081 b\u2082 : \u03b2} (h : b\u2081 \u2260 b\u2082) (a : \u03b1) (c : \u03b3) :\n    (single a b\u2081).trans (single b\u2082 c) = \u22a5", "start": [405, 1], "end": [407, 58], "kind": "commanddeclaration"}, {"full_name": "PEquiv.instPartialOrderPEquiv", "code": "instance instPartialOrderPEquiv : PartialOrder (\u03b1 \u2243. \u03b2) where\n  le f g := \u2200 (a : \u03b1) (b : \u03b2), b \u2208 f a \u2192 b \u2208 g a\n  le_refl _ _ _ := id\n  le_trans f g h fg gh a b := gh a b \u2218 fg a b\n  le_antisymm f g fg gf :=\n    ext\n      (by\n        intro a\n        cases' h : g a with b\n        \u00b7 exact eq_none_iff_forall_not_mem.2 fun b hb => Option.not_mem_none b <| h \u25b8 fg a b hb\n        \u00b7 exact gf _ _ h)", "start": [414, 1], "end": [424, 26], "kind": "commanddeclaration"}, {"full_name": "PEquiv.le_def", "code": "theorem le_def {f g : \u03b1 \u2243. \u03b2} : f \u2264 g \u2194 \u2200 (a : \u03b1) (b : \u03b2), b \u2208 f a \u2192 b \u2208 g a", "start": [426, 1], "end": [427, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.toPEquiv", "code": "def toPEquiv (f : \u03b1 \u2243 \u03b2) : \u03b1 \u2243. \u03b2 where\n  toFun := some \u2218 f\n  invFun := some \u2218 f.symm\n  inv := by simp [Equiv.eq_symm_apply, eq_comm]", "start": [470, 1], "end": [474, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.toPEquiv_refl", "code": "@[simp]\ntheorem toPEquiv_refl : (Equiv.refl \u03b1).toPEquiv = PEquiv.refl \u03b1", "start": [477, 1], "end": [479, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toPEquiv_trans", "code": "theorem toPEquiv_trans (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) :\n    (f.trans g).toPEquiv = f.toPEquiv.trans g.toPEquiv", "start": [482, 1], "end": [484, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toPEquiv_symm", "code": "theorem toPEquiv_symm (f : \u03b1 \u2243 \u03b2) : f.symm.toPEquiv = f.toPEquiv.symm", "start": [487, 1], "end": [488, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toPEquiv_apply", "code": "theorem toPEquiv_apply (f : \u03b1 \u2243 \u03b2) (x : \u03b1) : f.toPEquiv x = some (f x)", "start": [491, 1], "end": [492, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Rename.lean", "imports": ["Mathlib/Data/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.rename", "code": "def rename (f : \u03c3 \u2192 \u03c4) : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R :=\n  aeval (X \u2218 f)", "start": [55, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_C", "code": "@[simp]\ntheorem rename_C (f : \u03c3 \u2192 \u03c4) (r : R) : rename f (C r) = C r", "start": [60, 1], "end": [62, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_X", "code": "@[simp]\ntheorem rename_X (f : \u03c3 \u2192 \u03c4) (i : \u03c3) : rename f (X i : MvPolynomial \u03c3 R) = X (f i)", "start": [66, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.map_rename", "code": "theorem map_rename (f : R \u2192+* S) (g : \u03c3 \u2192 \u03c4) (p : MvPolynomial \u03c3 R) :\n    map f (rename g p) = rename g (map f p)", "start": [72, 1], "end": [77, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_rename", "code": "@[simp]\ntheorem rename_rename (f : \u03c3 \u2192 \u03c4) (g : \u03c4 \u2192 \u03b1) (p : MvPolynomial \u03c3 R) :\n    rename g (rename f p) = rename (g \u2218 f) p", "start": [80, 1], "end": [90, 63], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_id", "code": "@[simp]\ntheorem rename_id (p : MvPolynomial \u03c3 R) : rename id p = p", "start": [93, 1], "end": [95, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_monomial", "code": "theorem rename_monomial (f : \u03c3 \u2192 \u03c4) (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\n    rename f (monomial d r) = monomial (d.mapDomain f) r", "start": [98, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_eq", "code": "theorem rename_eq (f : \u03c3 \u2192 \u03c4) (p : MvPolynomial \u03c3 R) :\n    rename f p = Finsupp.mapDomain (Finsupp.mapDomain f) p", "start": [107, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_injective", "code": "theorem rename_injective (f : \u03c3 \u2192 \u03c4) (hf : Function.Injective f) :\n    Function.Injective (rename f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c4 R)", "start": [114, 1], "end": [120, 69], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.killCompl", "code": "def killCompl : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c3 R :=\n  aeval fun i => if h : i \u2208 Set.range f then X <| (Equiv.ofInjective f hf).symm \u27e8i, h\u27e9 else 0", "start": [129, 1], "end": [133, 94], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.killCompl_comp_rename", "code": "theorem killCompl_comp_rename : (killCompl hf).comp (rename f) = AlgHom.id R _", "start": [136, 1], "end": [139, 96], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.killCompl_rename_app", "code": "@[simp]\ntheorem killCompl_rename_app (p : MvPolynomial \u03c3 R) : killCompl hf (rename f p) = p", "start": [142, 1], "end": [144, 48], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.renameEquiv", "code": "@[simps apply]\ndef renameEquiv (f : \u03c3 \u2243 \u03c4) : MvPolynomial \u03c3 R \u2243\u2090[R] MvPolynomial \u03c4 R :=\n  { rename f with\n    toFun := rename f\n    invFun := rename f.symm\n    left_inv := fun p => by rw [rename_rename, f.symm_comp_self, rename_id]\n    right_inv := fun p => by rw [rename_rename, f.self_comp_symm, rename_id] }", "start": [153, 1], "end": [160, 79], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.renameEquiv_refl", "code": "@[simp]\ntheorem renameEquiv_refl : renameEquiv R (Equiv.refl \u03c3) = AlgEquiv.refl", "start": [163, 1], "end": [165, 25], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.renameEquiv_symm", "code": "@[simp]\ntheorem renameEquiv_symm (f : \u03c3 \u2243 \u03c4) : (renameEquiv R f).symm = renameEquiv R f.symm", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.renameEquiv_trans", "code": "@[simp]\ntheorem renameEquiv_trans (e : \u03c3 \u2243 \u03c4) (f : \u03c4 \u2243 \u03b1) :\n    (renameEquiv R e).trans (renameEquiv R f) = renameEquiv R (e.trans f)", "start": [173, 1], "end": [176, 35], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_rename", "code": "theorem eval\u2082_rename : (rename k p).eval\u2082 f g = p.eval\u2082 f (g \u2218 k)", "start": [185, 1], "end": [188, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_rename", "code": "theorem eval\u2082Hom_rename : eval\u2082Hom f g (rename k p) = eval\u2082Hom f (g \u2218 k) p", "start": [191, 1], "end": [192, 23], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_rename", "code": "theorem aeval_rename [Algebra R S] : aeval g (rename k p) = aeval (g \u2218 k) p", "start": [195, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_eval\u2082", "code": "theorem rename_eval\u2082 (g : \u03c4 \u2192 MvPolynomial \u03c3 R) :\n    rename k (p.eval\u2082 C (g \u2218 k)) = (rename k p).eval\u2082 C (rename k \u2218 g)", "start": [199, 1], "end": [203, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rename_prod_mk_eval\u2082", "code": "theorem rename_prod_mk_eval\u2082 (j : \u03c4) (g : \u03c3 \u2192 MvPolynomial \u03c3 R) :\n    rename (Prod.mk j) (p.eval\u2082 C g) = p.eval\u2082 C fun x => rename (Prod.mk j) (g x)", "start": [206, 1], "end": [210, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_rename_prod_mk", "code": "theorem eval\u2082_rename_prod_mk (g : \u03c3 \u00d7 \u03c4 \u2192 S) (i : \u03c3) (p : MvPolynomial \u03c4 R) :\n    (rename (Prod.mk i) p).eval\u2082 f g = eval\u2082 f (fun j => g (i, j)) p", "start": [213, 1], "end": [217, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval_rename_prod_mk", "code": "theorem eval_rename_prod_mk (g : \u03c3 \u00d7 \u03c4 \u2192 R) (i : \u03c3) (p : MvPolynomial \u03c4 R) :\n    eval g (rename (Prod.mk i) p) = eval (fun j => g (i, j)) p", "start": [220, 1], "end": [222, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_finset_rename", "code": "theorem exists_finset_rename (p : MvPolynomial \u03c3 R) :\n    \u2203 (s : Finset \u03c3) (q : MvPolynomial { x // x \u2208 s } R), p = rename (\u2191) q", "start": [227, 1], "end": [247, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_finset_rename\u2082", "code": "theorem exists_finset_rename\u2082 (p\u2081 p\u2082 : MvPolynomial \u03c3 R) :\n    \u2203 (s : Finset \u03c3) (q\u2081 q\u2082 : MvPolynomial s R), p\u2081 = rename (\u2191) q\u2081 \u2227 p\u2082 = rename (\u2191) q\u2082", "start": [250, 1], "end": [268, 10], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_fin_rename", "code": "theorem exists_fin_rename (p : MvPolynomial \u03c3 R) :\n    \u2203 (n : \u2115) (f : Fin n \u2192 \u03c3) (_hf : Injective f) (q : MvPolynomial (Fin n) R), p = rename f q", "start": [271, 1], "end": [279, 67], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082_cast_comp", "code": "theorem eval\u2082_cast_comp (f : \u03c3 \u2192 \u03c4) (c : \u2124 \u2192+* R) (g : \u03c4 \u2192 R) (p : MvPolynomial \u03c3 \u2124) :\n    eval\u2082 c (g \u2218 f) p = eval\u2082 c g (rename f p)", "start": [284, 1], "end": [288, 98], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_rename_mapDomain", "code": "@[simp]\ntheorem coeff_rename_mapDomain (f : \u03c3 \u2192 \u03c4) (hf : Injective f) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c3 \u2192\u2080 \u2115) :\n    (rename f \u03c6).coeff (d.mapDomain f) = \u03c6.coeff d", "start": [293, 1], "end": [303, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_rename_eq_zero", "code": "theorem coeff_rename_eq_zero (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c4 \u2192\u2080 \u2115)\n    (h : \u2200 u : \u03c3 \u2192\u2080 \u2115, u.mapDomain f = d \u2192 \u03c6.coeff u = 0) : (rename f \u03c6).coeff d = 0", "start": [306, 1], "end": [316, 16], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_rename_ne_zero", "code": "theorem coeff_rename_ne_zero (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c4 \u2192\u2080 \u2115)\n    (h : (rename f \u03c6).coeff d \u2260 0) : \u2203 u : \u03c3 \u2192\u2080 \u2115, u.mapDomain f = d \u2227 \u03c6.coeff u \u2260 0", "start": [319, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.constantCoeff_rename", "code": "@[simp]\ntheorem constantCoeff_rename {\u03c4 : Type*} (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) :\n    constantCoeff (rename f \u03c6) = constantCoeff \u03c6", "start": [325, 1], "end": [334, 79], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.support_rename_of_injective", "code": "theorem support_rename_of_injective {p : MvPolynomial \u03c3 R} {f : \u03c3 \u2192 \u03c4} [DecidableEq \u03c4]\n    (h : Function.Injective f) :\n    (rename f p).support = Finset.image (Finsupp.mapDomain f) p.support", "start": [341, 1], "end": [345, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ComputeDegree.lean", "imports": ["Mathlib/Data/Polynomial/Degree/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_C_le", "code": "theorem natDegree_C_le (a : R) : natDegree (C a) \u2264 0", "start": [86, 1], "end": [86, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_nat_cast_le", "code": "theorem natDegree_nat_cast_le (n : \u2115) : natDegree (n : R[X]) \u2264 0", "start": [88, 1], "end": [88, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_zero_le", "code": "theorem natDegree_zero_le : natDegree (0 : R[X]) \u2264 0", "start": [89, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_one_le", "code": "theorem natDegree_one_le : natDegree (1 : R[X]) \u2264 0", "start": [90, 1], "end": [90, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_add_of_eq", "code": "theorem coeff_add_of_eq {n : \u2115} {a b : R} {f g : R[X]}\n    (h_add_left : f.coeff n = a) (h_add_right : g.coeff n = b) :\n    (f + g).coeff n = a + b", "start": [92, 1], "end": [94, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_mul_add_of_le_natDegree_of_eq_ite", "code": "theorem coeff_mul_add_of_le_natDegree_of_eq_ite {d df dg : \u2115} {a b : R} {f g : R[X]}\n    (h_mul_left : natDegree f \u2264 df) (h_mul_right : natDegree g \u2264 dg)\n    (h_mul_left : f.coeff df = a) (h_mul_right : g.coeff dg = b) (ddf : df + dg \u2264 d) :\n    (f * g).coeff d = if d = df + dg then a * b else 0", "start": [96, 1], "end": [106, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_pow_of_natDegree_le_of_eq_ite'", "code": "theorem coeff_pow_of_natDegree_le_of_eq_ite' [Semiring R] {m n o : \u2115} {a : R} {p : R[X]}\n    (h_pow : natDegree p \u2264 n) (h_exp : m * n \u2264 o) (h_pow_bas : coeff p n = a) :\n    coeff (p ^ m) o = if o = m * n then a ^ m else 0", "start": [108, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_eq_of_le_of_coeff_ne_zero'", "code": "theorem natDegree_eq_of_le_of_coeff_ne_zero' {deg m o : \u2115} {c : R} {p : R[X]}\n    (h_natDeg_le : natDegree p \u2264 m) (coeff_eq : coeff p o = c)\n    (coeff_ne_zero : c \u2260 0) (deg_eq_deg : m = deg) (coeff_eq_deg : o = deg) :\n    natDegree p = deg", "start": [121, 1], "end": [136, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.degree_eq_of_le_of_coeff_ne_zero'", "code": "theorem degree_eq_of_le_of_coeff_ne_zero' {deg m o : WithBot \u2115} {c : R} {p : R[X]}\n    (h_deg_le : degree p \u2264 m) (coeff_eq : coeff p (WithBot.unbot' 0 deg) = c)\n    (coeff_ne_zero : c \u2260 0) (deg_eq_deg : m = deg) (coeff_eq_deg : o = deg) :\n    degree p = deg", "start": [138, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_congr_lhs", "code": "theorem coeff_congr_lhs : coeff f n = r", "start": [150, 1], "end": [150, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_congr", "code": "theorem coeff_congr {s : R} (rs : r = s) : coeff f n = s", "start": [151, 1], "end": [151, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.natDegree_int_cast_le", "code": "theorem natDegree_int_cast_le (n : \u2124) : natDegree (n : R[X]) \u2264 0", "start": [160, 1], "end": [160, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_sub_of_eq", "code": "theorem coeff_sub_of_eq {n : \u2115} {a b : R} {f g : R[X]} (hf : f.coeff n = a) (hg : g.coeff n = b) :\n    (f - g).coeff n = a - b", "start": [162, 1], "end": [163, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.coeff_int_cast_ite", "code": "theorem coeff_int_cast_ite {n : \u2115} {a : \u2124} : (Int.cast a : R[X]).coeff n = ite (n = 0) a 0", "start": [165, 1], "end": [166, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.twoHeadsArgs", "code": "def twoHeadsArgs (e : Expr) : Name \u00d7 Name \u00d7 Sum Name Name \u00d7 List Bool := Id.run do\n  let (eq_or_le, lhs, rhs) \u2190 match e.getAppFnArgs with\n    | (na@``Eq, #[_, lhs, rhs])       => pure (na, lhs, rhs)\n    | (na@``LE.le, #[_, _, lhs, rhs]) => pure (na, lhs, rhs)\n    | _ => return (.anonymous, .anonymous, .inl .anonymous, [])\n  let (ndeg_or_deg_or_coeff, pol, and?) \u2190 match lhs.getAppFnArgs with\n    | (na@``Polynomial.natDegree, #[_, _, pol])     => (na, pol, [rhs.isMVar])\n    | (na@``Polynomial.degree,    #[_, _, pol])     => (na, pol, [rhs.isMVar])\n    | (na@``Polynomial.coeff,     #[_, _, pol, c])  => (na, pol, [rhs.isMVar, c.isMVar])\n    | _ => return (.anonymous, eq_or_le, .inl .anonymous, [])\n  let head := match pol.numeral? with\n    | some 0 => .inl `zero\n    | some 1 => .inl `one\n    | some _ => .inl `many\n    | none => match pol.getAppFnArgs with\n      | (``FunLike.coe, #[_, _, _, _, polFun, _]) =>\n        let na := polFun.getAppFn.constName\n        if na \u2208 [``Polynomial.monomial, ``Polynomial.C] then\n          .inr na\n        else\n          .inl .anonymous\n      | (na, _) => .inr na\n  (ndeg_or_deg_or_coeff, eq_or_le, head, and?)", "start": [176, 1], "end": [221, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.getCongrLemma", "code": "def getCongrLemma (twoH : Name \u00d7 Name \u00d7 List Bool) (debug : Bool := false) : Name :=\n  let nam := match twoH with\n    | (_,           ``LE.le, [rhs]) => if rhs then ``id else ``le_trans\n    | (``natDegree, ``Eq, [rhs])    => if rhs then ``id else ``natDegree_eq_of_le_of_coeff_ne_zero'\n    | (``degree,    ``Eq, [rhs])    => if rhs then ``id else ``degree_eq_of_le_of_coeff_ne_zero'\n    | (``coeff,     ``Eq, [rhs, c]) =>\n      match rhs, c with\n      | false, false => ``coeff_congr\n      | false, true  => ``Eq.trans\n      | true, false  => ``coeff_congr_lhs\n      | true, true   => ``id\n    | _ => ``id\n  if debug then\n    let natr := if nam.getString == `trans then nam else nam.getString\n    dbg_trace f!\"congr lemma: '{natr}'\"\n    nam\n  else\n    nam", "start": [223, 1], "end": [262, 8], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.dispatchLemma", "code": "def dispatchLemma\n    (twoH : Name \u00d7 Name \u00d7 Sum Name Name \u00d7 List Bool) (debug : Bool := false) : Name :=\n  match twoH with\n    | (.anonymous, _, _) => ``id | (_, .anonymous, _) => ``id | (na1, na2, head, bools) =>\n      let msg := f!\"\\ndispatchLemma:\\n  {head}\"\n      if false \u2208 bools then getCongrLemma (na1, na2, bools) debug\n      else\n      let \u03c0 (natDegLE : Name) (degLE : Name) (coeff : Name) : Name := Id.run do\n        let lem := match na1, na2 with\n          | ``natDegree, ``LE.le => natDegLE\n          | ``degree, ``LE.le => degLE\n          | ``coeff, ``Eq => coeff\n          | _, ``LE.le => ``le_rfl\n          | _, _ => ``rfl\n        if debug then\n          dbg_trace f!\"{lem.getString}\\n{msg}\"\n        lem\n      match head with\n        | .inl `zero => \u03c0 ``natDegree_zero_le ``degree_zero_le ``coeff_zero\n        | .inl `one  => \u03c0 ``natDegree_one_le ``degree_one_le ``coeff_one\n        | .inl `many => \u03c0 ``natDegree_nat_cast_le ``degree_nat_cast_le ``coeff_nat_cast_ite\n        | .inl .anonymous => \u03c0 ``le_rfl ``le_rfl ``rfl\n        | .inr ``HAdd.hAdd =>\n          \u03c0 ``natDegree_add_le_of_le ``degree_add_le_of_le ``coeff_add_of_eq\n        | .inr ``HSub.hSub =>\n          \u03c0 ``natDegree_sub_le_of_le ``degree_sub_le_of_le ``coeff_sub_of_eq\n        | .inr ``HMul.hMul =>\n          \u03c0 ``natDegree_mul_le_of_le ``degree_mul_le_of_le ``coeff_mul_add_of_le_natDegree_of_eq_ite\n        | .inr ``HPow.hPow =>\n          \u03c0 ``natDegree_pow_le_of_le ``degree_pow_le_of_le ``coeff_pow_of_natDegree_le_of_eq_ite'\n        | .inr ``Neg.neg =>\n          \u03c0 ``natDegree_neg_le_of_le ``degree_neg_le_of_le ``coeff_neg\n        | .inr ``Polynomial.X =>\n          \u03c0 ``natDegree_X_le ``degree_X_le ``coeff_X\n        | .inr ``Nat.cast =>\n          \u03c0 ``natDegree_nat_cast_le ``degree_nat_cast_le ``coeff_nat_cast_ite\n        | .inr ``NatCast.natCast =>\n          \u03c0 ``natDegree_nat_cast_le ``degree_nat_cast_le ``coeff_nat_cast_ite\n        | .inr ``Int.cast =>\n          \u03c0 ``natDegree_int_cast_le ``degree_int_cast_le ``coeff_int_cast_ite\n        | .inr ``IntCast.intCast =>\n          \u03c0 ``natDegree_int_cast_le ``degree_int_cast_le ``coeff_int_cast_ite\n        | .inr ``Polynomial.monomial =>\n          \u03c0 ``natDegree_monomial_le ``degree_monomial_le ``coeff_monomial\n        | .inr ``Polynomial.C =>\n          \u03c0 ``natDegree_C_le ``degree_C_le ``coeff_C\n        | _ => \u03c0 ``le_rfl ``le_rfl ``rfl", "start": [264, 1], "end": [323, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.try_rfl", "code": "def try_rfl (mvs : List MVarId) : MetaM (List MVarId) := do\n  let (yesMV, noMV) := \u2190 mvs.partitionM fun mv =>\n                          return hasExprMVar (\u2190 instantiateMVars (\u2190 mv.getDecl).type)\n  let tried_rfl := \u2190 noMV.mapM fun g => g.applyConst ``rfl <|> return [g]\n  let assignable := \u2190 yesMV.mapM fun g => do\n    let tgt := \u2190 instantiateMVars (\u2190 g.getDecl).type\n    match tgt.eq? with\n      | some (_, lhs, rhs) =>\n        if (isMVar rhs && (! hasExprMVar lhs)) ||\n           (isMVar lhs && (! hasExprMVar rhs)) then\n           g.applyConst ``rfl\n        else pure [g]\n      | none =>\n        return [g]\n  return (assignable.join ++ tried_rfl.join)", "start": [325, 1], "end": [351, 45], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.splitApply", "code": "def splitApply (mvs static : List MVarId) : MetaM ((List MVarId) \u00d7 (List MVarId)) := do\n  let (can_progress, curr_static) := \u2190 mvs.partitionM fun mv => do\n    return dispatchLemma (twoHeadsArgs (\u2190 mv.getType'')) != ``id\n  let progress := \u2190 can_progress.mapM fun mv => do\n    let lem := dispatchLemma <| twoHeadsArgs (\u2190 mv.getType'')\n    mv.applyConst <| lem\n  return (progress.join, static ++ curr_static)", "start": [353, 1], "end": [369, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ComputeDegree.miscomputedDegree?", "code": "def miscomputedDegree? (deg : Expr) : List Expr \u2192 List MessageData\n  | tgt::tgts =>\n    let rest := miscomputedDegree? deg tgts\n    if tgt.ne?.isSome then\n      m!\"* the coefficient of degree {deg} may be zero\" :: rest\n    else if let some ((Expr.const ``Nat []), lhs, _) := tgt.le? then\n      m!\"* there is at least one term of na\u00efve degree {lhs}\" :: rest\n    else if let some (_, lhs, _) := tgt.eq? then\n      m!\"* there may be a term of na\u00efve degree {lhs}\" :: rest\n    else rest\n  | [] => []", "start": [371, 1], "end": [402, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Derivative.lean", "imports": ["Mathlib/Data/Polynomial/Eval.lean", "Mathlib/Algebra/Hom/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.derivative", "code": "def derivative : R[X] \u2192\u2097[R] R[X] where\n  toFun p := p.sum fun n a => C (a * n) * X ^ (n - 1)\n  map_add' p q := by\n    dsimp only\n    rw [sum_add_index] <;>\n      simp only [add_mul, forall_const, RingHom.map_add, eq_self_iff_true, zero_mul,\n        RingHom.map_zero]\n  map_smul' a p := by\n    dsimp; rw [sum_smul_index] <;>\n      simp only [mul_sum, \u2190 C_mul', mul_assoc, coeff_C_mul, RingHom.map_mul, forall_const, zero_mul,\n        RingHom.map_zero, sum]", "start": [38, 1], "end": [49, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_apply", "code": "theorem derivative_apply (p : R[X]) : derivative p = p.sum fun n a => C (a * n) * X ^ (n - 1)", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_derivative", "code": "theorem coeff_derivative (p : R[X]) (n : \u2115) :\n    coeff (derivative p) n = coeff p (n + 1) * (n + 1)", "start": [56, 1], "end": [72, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_zero", "code": "theorem derivative_zero : derivative (0 : R[X]) = 0", "start": [76, 1], "end": [77, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_zero", "code": "@[simp]\ntheorem iterate_derivative_zero {k : \u2115} : derivative^[k] (0 : R[X]) = 0", "start": [80, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_monomial", "code": "@[simp]\ntheorem derivative_monomial (a : R) (n : \u2115) :\n    derivative (monomial n a) = monomial (n - 1) (a * n)", "start": [87, 1], "end": [91, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_C_mul_X", "code": "theorem derivative_C_mul_X (a : R) : derivative (C a * X) = C a", "start": [94, 1], "end": [95, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_C_mul_X_pow", "code": "theorem derivative_C_mul_X_pow (a : R) (n : \u2115) :\n    derivative (C a * X ^ n) = C (a * n) * X ^ (n - 1)", "start": [99, 1], "end": [101, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_C_mul_X_sq", "code": "theorem derivative_C_mul_X_sq (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X", "start": [105, 1], "end": [106, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_pow", "code": "@[simp]\ntheorem derivative_X_pow (n : \u2115) : derivative (X ^ n : R[X]) = C (n : R) * X ^ (n - 1)", "start": [110, 1], "end": [112, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_sq", "code": "theorem derivative_X_sq : derivative (X ^ 2 : R[X]) = C 2 * X", "start": [117, 1], "end": [118, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_C", "code": "@[simp]\ntheorem derivative_C {a : R} : derivative (C a) = 0", "start": [122, 1], "end": [123, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_of_natDegree_zero", "code": "theorem derivative_of_natDegree_zero {p : R[X]} (hp : p.natDegree = 0) : derivative p = 0", "start": [127, 1], "end": [128, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X", "code": "@[simp]\ntheorem derivative_X : derivative (X : R[X]) = 1", "start": [131, 1], "end": [133, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_one", "code": "@[simp]\ntheorem derivative_one : derivative (1 : R[X]) = 0", "start": [137, 1], "end": [139, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_bit0", "code": "theorem derivative_bit0 {a : R[X]} : derivative (bit0 a) = bit0 (derivative a)", "start": [144, 1], "end": [144, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_bit1", "code": "theorem derivative_bit1 {a : R[X]} : derivative (bit1 a) = bit0 (derivative a)", "start": [149, 1], "end": [149, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_add", "code": "theorem derivative_add {f g : R[X]} : derivative (f + g) = derivative f + derivative g", "start": [153, 1], "end": [154, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_add_C", "code": "theorem derivative_X_add_C (c : R) : derivative (X + C c) = 1", "start": [158, 1], "end": [159, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_sum", "code": "theorem derivative_sum {s : Finset \u03b9} {f : \u03b9 \u2192 R[X]} :\n    derivative (\u2211 b in s, f b) = \u2211 b in s, derivative (f b)", "start": [164, 1], "end": [166, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_smul", "code": "theorem derivative_smul {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R] (s : S)\n    (p : R[X]) : derivative (s \u2022 p) = s \u2022 derivative p", "start": [170, 1], "end": [172, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_smul", "code": "@[simp]\ntheorem iterate_derivative_smul {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R]\n    (s : S) (p : R[X]) (k : \u2115) : derivative^[k] (s \u2022 p) = s \u2022 derivative^[k] p", "start": [175, 1], "end": [180, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_C_mul", "code": "@[simp]\ntheorem iterate_derivative_C_mul (a : R) (p : R[X]) (k : \u2115) :\n    derivative^[k] (C a * p) = C a * derivative^[k] p", "start": [183, 1], "end": [186, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.of_mem_support_derivative", "code": "theorem of_mem_support_derivative {p : R[X]} {n : \u2115} (h : n \u2208 p.derivative.support) :\n    n + 1 \u2208 p.support", "start": [190, 1], "end": [193, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_derivative_lt", "code": "theorem degree_derivative_lt {p : R[X]} (hp : p \u2260 0) : p.derivative.degree < p.degree", "start": [196, 1], "end": [199, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_derivative_le", "code": "theorem degree_derivative_le {p : R[X]} : p.derivative.degree \u2264 p.degree", "start": [202, 1], "end": [204, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_derivative_lt", "code": "theorem natDegree_derivative_lt {p : R[X]} (hp : p.natDegree \u2260 0) :\n    p.derivative.natDegree < p.natDegree", "start": [207, 1], "end": [213, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_derivative_le", "code": "theorem natDegree_derivative_le (p : R[X]) : p.derivative.natDegree \u2264 p.natDegree - 1", "start": [216, 1], "end": [219, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_iterate_derivative", "code": "theorem natDegree_iterate_derivative (p : R[X]) (k : \u2115) :\n    (derivative^[k] p).natDegree \u2264 p.natDegree - k", "start": [222, 1], "end": [228, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_nat_cast", "code": "@[simp]\ntheorem derivative_nat_cast {n : \u2115} : derivative (n : R[X]) = 0", "start": [230, 1], "end": [233, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_ofNat", "code": "@[simp]\ntheorem derivative_ofNat (n : \u2115) [n.AtLeastTwo] :\n    derivative (no_index (OfNat.ofNat n) : R[X]) = 0", "start": [237, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_eq_zero", "code": "theorem iterate_derivative_eq_zero {p : R[X]} {x : \u2115} (hx : p.natDegree < x) :\n    Polynomial.derivative^[x] p = 0", "start": [242, 1], "end": [251, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_C", "code": "@[simp]\ntheorem iterate_derivative_C {k} (h : 0 < k) : derivative^[k] (C a : R[X]) = 0", "start": [254, 1], "end": [256, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_one", "code": "@[simp]\ntheorem iterate_derivative_one {k} (h : 0 < k) : derivative^[k] (1 : R[X]) = 0", "start": [260, 1], "end": [262, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X", "code": "@[simp]\ntheorem iterate_derivative_X {k} (h : 1 < k) : derivative^[k] (X : R[X]) = 0", "start": [265, 1], "end": [267, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_zero_of_derivative_eq_zero", "code": "theorem natDegree_eq_zero_of_derivative_eq_zero [NoZeroSMulDivisors \u2115 R] {f : R[X]}\n    (h : derivative f = 0) : f.natDegree = 0", "start": [271, 1], "end": [285, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_C_of_derivative_eq_zero", "code": "theorem eq_C_of_derivative_eq_zero [NoZeroSMulDivisors \u2115 R] {f : R[X]} (h : derivative f = 0) :\n    f = C (f.coeff 0)", "start": [288, 1], "end": [290, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_mul", "code": "@[simp]\ntheorem derivative_mul {f g : R[X]} : derivative (f * g) = derivative f * g + f * derivative g", "start": [294, 1], "end": [328, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_eval", "code": "theorem derivative_eval (p : R[X]) (x : R) :\n    p.derivative.eval x = p.sum fun n a => a * n * x ^ (n - 1)", "start": [331, 1], "end": [333, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_map", "code": "@[simp]\ntheorem derivative_map [Semiring S] (p : R[X]) (f : R \u2192+* S) :\n    derivative (p.map f) = p.derivative.map f", "start": [336, 1], "end": [345, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_map", "code": "@[simp]\ntheorem iterate_derivative_map [Semiring S] (p : R[X]) (f : R \u2192+* S) (k : \u2115) :\n    Polynomial.derivative^[k] (p.map f) = (Polynomial.derivative^[k] p).map f", "start": [348, 1], "end": [353, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_nat_cast_mul", "code": "theorem derivative_nat_cast_mul {n : \u2115} {f : R[X]} :\n    derivative ((n : R[X]) * f) = n * derivative f", "start": [356, 1], "end": [358, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_nat_cast_mul", "code": "@[simp]\ntheorem iterate_derivative_nat_cast_mul {n k : \u2115} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f", "start": [361, 1], "end": [364, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_support_derivative", "code": "theorem mem_support_derivative [NoZeroSMulDivisors \u2115 R] (p : R[X]) (n : \u2115) :\n    n \u2208 (derivative p).support \u2194 n + 1 \u2208 p.support", "start": [367, 1], "end": [372, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_derivative_eq", "code": "@[simp]\ntheorem degree_derivative_eq [NoZeroSMulDivisors \u2115 R] (p : R[X]) (hp : 0 < natDegree p) :\n    degree (derivative p) = (natDegree p - 1 : \u2115)", "start": [375, 1], "end": [390, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_iterate_derivative", "code": "theorem coeff_iterate_derivative {k} (p : R[X]) (m : \u2115) :\n    (derivative^[k] p).coeff m = (m + k).descFactorial k \u2022 p.coeff (m + k)", "start": [396, 1], "end": [410, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_mul", "code": "theorem iterate_derivative_mul {n} (p q : R[X]) :\n    derivative^[n] (p * q) =\n      \u2211 k in range n.succ, (n.choose k \u2022 (derivative^[n - k] p * derivative^[k] q))", "start": [412, 1], "end": [452, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_pow_succ", "code": "theorem derivative_pow_succ (p : R[X]) (n : \u2115) :\n    derivative (p ^ (n + 1)) = C (n + 1 : R) * p ^ n * derivative p", "start": [461, 1], "end": [465, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_pow", "code": "theorem derivative_pow (p : R[X]) (n : \u2115) :\n    derivative (p ^ n) = C (n : R) * p ^ (n - 1) * derivative p", "start": [468, 1], "end": [471, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_sq", "code": "theorem derivative_sq (p : R[X]) : derivative (p ^ 2) = C 2 * p * derivative p", "start": [474, 1], "end": [475, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_iterate_derivative_pow", "code": "theorem dvd_iterate_derivative_pow (f : R[X]) (n : \u2115) {m : \u2115} (c : R) (hm : m \u2260 0) :\n    (n : R) \u2223 eval c (derivative^[m] (f ^ n))", "start": [478, 1], "end": [483, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X_pow_eq_nat_cast_mul", "code": "theorem iterate_derivative_X_pow_eq_nat_cast_mul (n k : \u2115) :\n    derivative^[k] (X ^ n : R[X]) = \u2191(Nat.descFactorial n k : R[X]) * X ^ (n - k)", "start": [486, 1], "end": [492, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X_pow_eq_C_mul", "code": "theorem iterate_derivative_X_pow_eq_C_mul (n k : \u2115) :\n    derivative^[k] (X ^ n : R[X]) = C (Nat.descFactorial n k : R) * X ^ (n - k)", "start": [496, 1], "end": [498, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X_pow_eq_smul", "code": "theorem iterate_derivative_X_pow_eq_smul (n : \u2115) (k : \u2115) :\n    derivative^[k] (X ^ n : R[X]) = (Nat.descFactorial n k : R) \u2022 X ^ (n - k)", "start": [502, 1], "end": [504, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_add_C_pow", "code": "theorem derivative_X_add_C_pow (c : R) (m : \u2115) :\n    derivative ((X + C c) ^ m) = C (m : R) * (X + C c) ^ (m - 1)", "start": [508, 1], "end": [510, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_add_C_sq", "code": "theorem derivative_X_add_C_sq (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c)", "start": [514, 1], "end": [515, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X_add_pow", "code": "theorem iterate_derivative_X_add_pow (n k : \u2115) (c : R) :\n    derivative^[k] ((X + C c) ^ n) = Nat.descFactorial n k \u2022 (X + C c) ^ (n - k)", "start": [519, 1], "end": [527, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_comp", "code": "theorem derivative_comp (p q : R[X]) :\n    derivative (p.comp q) = derivative q * p.derivative.comp q", "start": [531, 1], "end": [537, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_eval\u2082_C", "code": "theorem derivative_eval\u2082_C (p q : R[X]) :\n    derivative (p.eval\u2082 C q) = p.derivative.eval\u2082 C q * derivative q", "start": [540, 1], "end": [548, 96], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_prod", "code": "theorem derivative_prod [DecidableEq \u03b9] {s : Multiset \u03b9} {f : \u03b9 \u2192 R[X]} :\n    derivative (Multiset.map f s).prod =\n      (Multiset.map (fun i => (Multiset.map f (s.erase i)).prod * derivative (f i)) s).sum", "start": [552, 1], "end": [566, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_neg", "code": "theorem derivative_neg (f : R[X]) : derivative (-f) = -derivative f", "start": [576, 1], "end": [577, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_neg", "code": "@[simp]\ntheorem iterate_derivative_neg {f : R[X]} {k : \u2115} : derivative^[k] (-f) = -derivative^[k] f", "start": [580, 1], "end": [582, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_sub", "code": "theorem derivative_sub {f g : R[X]} : derivative (f - g) = derivative f - derivative g", "start": [586, 1], "end": [587, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_sub_C", "code": "theorem derivative_X_sub_C (c : R) : derivative (X - C c) = 1", "start": [591, 1], "end": [592, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_sub", "code": "@[simp]\ntheorem iterate_derivative_sub {k : \u2115} {f g : R[X]} :\n    derivative^[k] (f - g) = derivative^[k] f - derivative^[k] g", "start": [596, 1], "end": [599, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_int_cast", "code": "@[simp]\ntheorem derivative_int_cast {n : \u2124} : derivative (n : R[X]) = 0", "start": [602, 1], "end": [605, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_int_cast_mul", "code": "theorem derivative_int_cast_mul {n : \u2124} {f : R[X]} : derivative ((n : R[X]) * f) =\n    n * derivative f", "start": [608, 1], "end": [610, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_int_cast_mul", "code": "@[simp]\ntheorem iterate_derivative_int_cast_mul {n : \u2124} {k : \u2115} {f : R[X]} :\n    derivative^[k] ((n : R[X]) * f) = n * derivative^[k] f", "start": [613, 1], "end": [616, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_comp_one_sub_X", "code": "theorem derivative_comp_one_sub_X (p : R[X]) :\n    derivative (p.comp (1 - X)) = -p.derivative.comp (1 - X)", "start": [625, 1], "end": [626, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_comp_one_sub_X", "code": "@[simp]\ntheorem iterate_derivative_comp_one_sub_X (p : R[X]) (k : \u2115) :\n    derivative^[k] (p.comp (1 - X)) = (-1) ^ k * (derivative^[k] p).comp (1 - X)", "start": [630, 1], "end": [635, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_multiset_prod_X_sub_C_derivative", "code": "theorem eval_multiset_prod_X_sub_C_derivative [DecidableEq R]\n    {S : Multiset R} {r : R} (hr : r \u2208 S) :\n    eval r (derivative (Multiset.map (fun a => X - C a) S).prod) =\n      (Multiset.map (fun a => r - a) (S.erase r)).prod", "start": [639, 1], "end": [645, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_sub_C_pow", "code": "theorem derivative_X_sub_C_pow (c : R) (m : \u2115) :\n    derivative ((X - C c) ^ m) = C (m : R) * (X - C c) ^ (m - 1)", "start": [649, 1], "end": [651, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_X_sub_C_sq", "code": "theorem derivative_X_sub_C_sq (c : R) : derivative ((X - C c) ^ 2) = C 2 * (X - C c)", "start": [655, 1], "end": [656, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.iterate_derivative_X_sub_pow", "code": "theorem iterate_derivative_X_sub_pow (n k : \u2115) (c : R) :\n    (derivative^[k]) ((X - C c) ^ n : R[X]) = n.descFactorial k \u2022 (X - C c) ^ (n - k)", "start": [660, 1], "end": [662, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/RingDivision.lean", "imports": ["Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/Data/Polynomial/Div.lean", "Mathlib/Algebra/Polynomial/BigOperators.lean", "Mathlib/Algebra/CharZero/Infinite.lean", "Mathlib/RingTheory/Localization/FractionRing.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.natDegree_pos_of_aeval_root", "code": "theorem natDegree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p \u2260 0) {z : S}\n    (hz : aeval z p = 0) (inj : \u2200 x : R, algebraMap R S x = 0 \u2192 x = 0) : 0 < p.natDegree", "start": [57, 1], "end": [59, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_of_aeval_root", "code": "theorem degree_pos_of_aeval_root [Algebra R S] {p : R[X]} (hp : p \u2260 0) {z : S} (hz : aeval z p = 0)\n    (inj : \u2200 x : R, algebraMap R S x = 0 \u2192 x = 0) : 0 < p.degree", "start": [62, 1], "end": [64, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_eq_of_dvd_sub", "code": "theorem modByMonic_eq_of_dvd_sub (hq : q.Monic) {p\u2081 p\u2082 : R[X]} (h : q \u2223 p\u2081 - p\u2082) :\n    p\u2081 %\u2098 q = p\u2082 %\u2098 q", "start": [67, 1], "end": [72, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.add_modByMonic", "code": "theorem add_modByMonic (p\u2081 p\u2082 : R[X]) : (p\u2081 + p\u2082) %\u2098 q = p\u2081 %\u2098 q + p\u2082 %\u2098 q", "start": [75, 1], "end": [86, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_modByMonic", "code": "theorem smul_modByMonic (c : R) (p : R[X]) : c \u2022 p %\u2098 q = c \u2022 (p %\u2098 q)", "start": [89, 1], "end": [97, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonicHom", "code": "@[simps]\ndef modByMonicHom (q : R[X]) : R[X] \u2192\u2097[R] R[X] where\n  toFun p := p %\u2098 q\n  map_add' := add_modByMonic\n  map_smul' := smul_modByMonic", "start": [100, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_modByMonic_eq_self_of_root", "code": "theorem aeval_modByMonic_eq_self_of_root [Algebra R S] {p q : R[X]} (hq : q.Monic) {x : S}\n    (hx : aeval x q = 0) : aeval x (p %\u2098 q) = aeval x p", "start": [114, 1], "end": [118, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul", "code": "theorem natDegree_mul (hp : p \u2260 0) (hq : q \u2260 0) : (p*q).natDegree = p.natDegree + q.natDegree", "start": [135, 1], "end": [137, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.trailingDegree_mul", "code": "theorem trailingDegree_mul : (p * q).trailingDegree = p.trailingDegree + q.trailingDegree", "start": [140, 1], "end": [147, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_pow", "code": "@[simp]\ntheorem natDegree_pow (p : R[X]) (n : \u2115) : natDegree (p ^ n) = n * natDegree p", "start": [150, 1], "end": [158, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_mul_left", "code": "theorem degree_le_mul_left (p : R[X]) (hq : q \u2260 0) : degree p \u2264 degree (p * q)", "start": [161, 1], "end": [166, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_le_of_dvd", "code": "theorem natDegree_le_of_dvd {p q : R[X]} (h1 : p \u2223 q) (h2 : q \u2260 0) : p.natDegree \u2264 q.natDegree", "start": [169, 1], "end": [171, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_le_of_dvd", "code": "theorem degree_le_of_dvd {p q : R[X]} (h1 : p \u2223 q) (h2 : q \u2260 0) : degree p \u2264 degree q", "start": [174, 1], "end": [176, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_dvd_of_degree_lt", "code": "theorem eq_zero_of_dvd_of_degree_lt {p q : R[X]} (h\u2081 : p \u2223 q) (h\u2082 : degree q < degree p) :\n    q = 0", "start": [179, 1], "end": [182, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_dvd_of_natDegree_lt", "code": "theorem eq_zero_of_dvd_of_natDegree_lt {p q : R[X]} (h\u2081 : p \u2223 q) (h\u2082 : natDegree q < natDegree p) :\n    q = 0", "start": [185, 1], "end": [188, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_dvd_of_degree_lt", "code": "theorem not_dvd_of_degree_lt {p q : R[X]} (h0 : q \u2260 0) (hl : q.degree < p.degree) : \u00acp \u2223 q", "start": [191, 1], "end": [193, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_dvd_of_natDegree_lt", "code": "theorem not_dvd_of_natDegree_lt {p q : R[X]} (h0 : q \u2260 0) (hl : q.natDegree < p.natDegree) :\n    \u00acp \u2223 q", "start": [196, 1], "end": [199, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_sub_eq_of_prod_eq", "code": "theorem natDegree_sub_eq_of_prod_eq {p\u2081 p\u2082 q\u2081 q\u2082 : R[X]} (hp\u2081 : p\u2081 \u2260 0) (hq\u2081 : q\u2081 \u2260 0)\n    (hp\u2082 : p\u2082 \u2260 0) (hq\u2082 : q\u2082 \u2260 0) (h_eq : p\u2081 * q\u2082 = p\u2082 * q\u2081) :\n    (p\u2081.natDegree : \u2124) - q\u2081.natDegree = (p\u2082.natDegree : \u2124) - q\u2082.natDegree", "start": [202, 1], "end": [208, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_eq_zero_of_isUnit", "code": "theorem natDegree_eq_zero_of_isUnit (h : IsUnit p) : natDegree p = 0", "start": [211, 1], "end": [216, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_zero_of_isUnit", "code": "theorem degree_eq_zero_of_isUnit [Nontrivial R] (h : IsUnit p) : degree p = 0", "start": [219, 1], "end": [221, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_coe_units", "code": "@[simp]\ntheorem degree_coe_units [Nontrivial R] (u : R[X]\u02e3) : degree (u : R[X]) = 0", "start": [224, 1], "end": [226, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_iff", "code": "theorem isUnit_iff : IsUnit p \u2194 \u2203 r : R, IsUnit r \u2227 C r = p", "start": [229, 1], "end": [236, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.irreducible_of_monic", "code": "theorem irreducible_of_monic (hp : p.Monic) (hp1 : p \u2260 1) :\n    Irreducible p \u2194 \u2200 f g : R[X], f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f = 1 \u2228 g = 1", "start": [278, 1], "end": [288, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.irreducible_iff_natDegree", "code": "theorem Monic.irreducible_iff_natDegree (hp : p.Monic) :\n    Irreducible p \u2194\n      p \u2260 1 \u2227 \u2200 f g : R[X], f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 f.natDegree = 0 \u2228 g.natDegree = 0", "start": [291, 1], "end": [297, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.irreducible_iff_natDegree'", "code": "theorem Monic.irreducible_iff_natDegree' (hp : p.Monic) : Irreducible p \u2194 p \u2260 1 \u2227\n    \u2200 f g : R[X], f.Monic \u2192 g.Monic \u2192 f * g = p \u2192 g.natDegree \u2209 Ioc 0 (p.natDegree / 2)", "start": [300, 1], "end": [311, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.not_irreducible_iff_exists_add_mul_eq_coeff", "code": "theorem Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :\n    \u00acIrreducible p \u2194 \u2203 c\u2081 c\u2082, p.coeff 0 = c\u2081 * c\u2082 \u2227 p.coeff 1 = c\u2081 + c\u2082", "start": [314, 1], "end": [336, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_mul", "code": "theorem root_mul : IsRoot (p * q) a \u2194 IsRoot p a \u2228 IsRoot q a", "start": [339, 1], "end": [340, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_or_root_of_root_mul", "code": "theorem root_or_root_of_root_mul (h : IsRoot (p * q) a) : IsRoot p a \u2228 IsRoot q a", "start": [343, 1], "end": [344, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_rootMultiplicity_iff", "code": "theorem le_rootMultiplicity_iff {p : R[X]} (p0 : p \u2260 0) {a : R} {n : \u2115} :\n    n \u2264 rootMultiplicity a p \u2194 (X - C a) ^ n \u2223 p", "start": [368, 1], "end": [379, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_le_iff", "code": "theorem rootMultiplicity_le_iff {p : R[X]} (p0 : p \u2260 0) (a : R) (n : \u2115) :\n    rootMultiplicity a p \u2264 n \u2194 \u00ac(X - C a) ^ (n + 1) \u2223 p", "start": [382, 1], "end": [384, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.pow_rootMultiplicity_not_dvd", "code": "theorem pow_rootMultiplicity_not_dvd {p : R[X]} (p0 : p \u2260 0) (a : R) :\n    \u00ac(X - C a) ^ (rootMultiplicity a p + 1) \u2223 p", "start": [387, 1], "end": [388, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_add", "code": "theorem rootMultiplicity_add {p q : R[X]} (a : R) (hzero : p + q \u2260 0) :\n    min (rootMultiplicity a p) (rootMultiplicity a q) \u2264 rootMultiplicity a (p + q)", "start": [391, 1], "end": [397, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prime_X_sub_C", "code": "theorem prime_X_sub_C (r : R) : Prime (X - C r)", "start": [406, 1], "end": [409, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prime_X", "code": "theorem prime_X : Prime (X : R[X])", "start": [413, 1], "end": [415, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.prime_of_degree_eq_one", "code": "theorem Monic.prime_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Prime p", "start": [419, 1], "end": [421, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.irreducible_X_sub_C", "code": "theorem irreducible_X_sub_C (r : R) : Irreducible (X - C r)", "start": [424, 1], "end": [425, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.irreducible_X", "code": "theorem irreducible_X : Irreducible (X : R[X])", "start": [429, 1], "end": [430, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.irreducible_of_degree_eq_one", "code": "theorem Monic.irreducible_of_degree_eq_one (hp1 : degree p = 1) (hm : Monic p) : Irreducible p", "start": [434, 1], "end": [435, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_monic_of_associated", "code": "theorem eq_of_monic_of_associated (hp : p.Monic) (hq : q.Monic) (hpq : Associated p q) : p = q", "start": [438, 1], "end": [443, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_mul", "code": "theorem rootMultiplicity_mul {p q : R[X]} {x : R} (hpq : p * q \u2260 0) :\n    rootMultiplicity x (p * q) = rootMultiplicity x p + rootMultiplicity x q", "start": [446, 1], "end": [453, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_X_sub_C_self", "code": "theorem rootMultiplicity_X_sub_C_self {x : R} : rootMultiplicity x (X - C x) = 1", "start": [456, 1], "end": [459, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_X_sub_C", "code": "theorem rootMultiplicity_X_sub_C [DecidableEq R] {x y : R} :\n    rootMultiplicity x (X - C y) = if x = y then 1 else 0", "start": [464, 1], "end": [469, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_X_sub_C_pow", "code": "theorem rootMultiplicity_X_sub_C_pow (a : R) (n : \u2115) : rootMultiplicity a ((X - C a) ^ n) = n", "start": [473, 1], "end": [480, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_multiset_roots", "code": "theorem exists_multiset_roots [DecidableEq R] :\n    \u2200 {p : R[X]} (_ : p \u2260 0), \u2203 s : Multiset R,\n      (Multiset.card s : WithBot \u2115) \u2264 degree p \u2227 \u2200 a, s.count a = rootMultiplicity a p", "start": [484, 1], "end": [529, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots", "code": "noncomputable def roots (p : R[X]) : Multiset R :=\n  haveI := Classical.decEq R\n  haveI := Classical.dec (p = 0)\n  if h : p = 0 then \u2205 else Classical.choose (exists_multiset_roots h)", "start": [532, 1], "end": [537, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_def", "code": "theorem roots_def [DecidableEq R] (p : R[X]) [Decidable (p = 0)] :\n    p.roots = if h : p = 0 then \u2205 else Classical.choose (exists_multiset_roots h)", "start": [540, 1], "end": [546, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_zero", "code": "@[simp]\ntheorem roots_zero : (0 : R[X]).roots = 0", "start": [549, 1], "end": [551, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots", "code": "theorem card_roots (hp0 : p \u2260 0) : (Multiset.card (roots p) : WithBot \u2115) \u2264 degree p", "start": [554, 1], "end": [558, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots'", "code": "theorem card_roots' (p : R[X]) : Multiset.card p.roots \u2264 natDegree p", "start": [561, 1], "end": [564, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_sub_C", "code": "theorem card_roots_sub_C {p : R[X]} {a : R} (hp0 : 0 < degree p) :\n    (Multiset.card (p - C a).roots : WithBot \u2115) \u2264 degree p", "start": [567, 1], "end": [572, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_sub_C'", "code": "theorem card_roots_sub_C' {p : R[X]} {a : R} (hp0 : 0 < degree p) :\n    Multiset.card (p - C a).roots \u2264 natDegree p", "start": [576, 1], "end": [580, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.count_roots", "code": "@[simp]\ntheorem count_roots [DecidableEq R] (p : R[X]) : p.roots.count a = rootMultiplicity a p", "start": [584, 1], "end": [590, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots'", "code": "@[simp]\ntheorem mem_roots' : a \u2208 p.roots \u2194 p \u2260 0 \u2227 IsRoot p a", "start": [593, 1], "end": [596, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots", "code": "theorem mem_roots (hp : p \u2260 0) : a \u2208 p.roots \u2194 IsRoot p a", "start": [599, 1], "end": [600, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_mem_roots", "code": "theorem ne_zero_of_mem_roots (h : a \u2208 p.roots) : p \u2260 0", "start": [603, 1], "end": [604, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_of_mem_roots", "code": "theorem isRoot_of_mem_roots (h : a \u2208 p.roots) : IsRoot p a", "start": [607, 1], "end": [608, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots_iff_aeval_eq_zero", "code": "lemma mem_roots_iff_aeval_eq_zero (w : p \u2260 0) : x \u2208 roots p \u2194 aeval x p = 0 := by\n  rw [mem_roots w, IsRoot.def, aeval_def, eval\u2082_eq_eval_map]\n  simp", "start": [612, 1], "end": [614, 7], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.card_le_degree_of_subset_roots", "code": "theorem card_le_degree_of_subset_roots {p : R[X]} {Z : Finset R} (h : Z.val \u2286 p.roots) :\n    Z.card \u2264 p.natDegree", "start": [616, 1], "end": [618, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.finite_setOf_isRoot", "code": "theorem finite_setOf_isRoot {p : R[X]} (hp : p \u2260 0) : Set.Finite { x | IsRoot p x }", "start": [621, 1], "end": [624, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_infinite_isRoot", "code": "theorem eq_zero_of_infinite_isRoot (p : R[X]) (h : Set.Infinite { x | IsRoot p x }) : p = 0", "start": [627, 1], "end": [628, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_max_root", "code": "theorem exists_max_root [LinearOrder R] (p : R[X]) (hp : p \u2260 0) : \u2203 x\u2080, \u2200 x, p.IsRoot x \u2192 x \u2264 x\u2080", "start": [631, 1], "end": [632, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_min_root", "code": "theorem exists_min_root [LinearOrder R] (p : R[X]) (hp : p \u2260 0) : \u2203 x\u2080, \u2200 x, p.IsRoot x \u2192 x\u2080 \u2264 x", "start": [635, 1], "end": [636, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_infinite_eval_eq", "code": "theorem eq_of_infinite_eval_eq (p q : R[X]) (h : Set.Infinite { x | eval x p = eval x q }) :\n    p = q", "start": [639, 1], "end": [643, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_mul", "code": "theorem roots_mul {p q : R[X]} (hpq : p * q \u2260 0) : (p * q).roots = p.roots + q.roots", "start": [646, 1], "end": [649, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots.le_of_dvd", "code": "theorem roots.le_of_dvd (h : q \u2260 0) : p \u2223 q \u2192 roots p \u2264 roots q", "start": [652, 1], "end": [654, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots_sub_C'", "code": "theorem mem_roots_sub_C' {p : R[X]} {a x : R} : x \u2208 (p - C a).roots \u2194 p \u2260 C a \u2227 p.eval x = a", "start": [657, 1], "end": [658, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots_sub_C", "code": "theorem mem_roots_sub_C {p : R[X]} {a x : R} (hp0 : 0 < degree p) :\n    x \u2208 (p - C a).roots \u2194 p.eval x = a", "start": [662, 1], "end": [664, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_X_sub_C", "code": "@[simp]\ntheorem roots_X_sub_C (r : R) : roots (X - C r) = {r}", "start": [668, 1], "end": [672, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_X", "code": "@[simp]\ntheorem roots_X : roots (X : R[X]) = {0}", "start": [676, 1], "end": [677, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_C", "code": "@[simp]\ntheorem roots_C (x : R) : (C x).roots = 0", "start": [681, 1], "end": [687, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_one", "code": "@[simp]\ntheorem roots_one : (1 : R[X]).roots = \u2205", "start": [691, 1], "end": [693, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_C_mul", "code": "@[simp]\ntheorem roots_C_mul (p : R[X]) (ha : a \u2260 0) : (C a * p).roots = p.roots", "start": [696, 1], "end": [700, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_smul_nonzero", "code": "@[simp]\ntheorem roots_smul_nonzero (p : R[X]) (ha : a \u2260 0) : (a \u2022 p).roots = p.roots", "start": [704, 1], "end": [706, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_list_prod", "code": "theorem roots_list_prod (L : List R[X]) :\n    (0 : R[X]) \u2209 L \u2192 L.prod.roots = (L : Multiset R[X]).bind roots", "start": [709, 1], "end": [714, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_multiset_prod", "code": "theorem roots_multiset_prod (m : Multiset R[X]) : (0 : R[X]) \u2209 m \u2192 m.prod.roots = m.bind roots", "start": [717, 1], "end": [719, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_prod", "code": "theorem roots_prod {\u03b9 : Type*} (f : \u03b9 \u2192 R[X]) (s : Finset \u03b9) :\n    s.prod f \u2260 0 \u2192 (s.prod f).roots = s.val.bind fun i => roots (f i)", "start": [722, 1], "end": [725, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_pow", "code": "@[simp]\ntheorem roots_pow (p : R[X]) (n : \u2115) : (p ^ n).roots = n \u2022 p.roots", "start": [728, 1], "end": [735, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_X_pow", "code": "theorem roots_X_pow (n : \u2115) : (X ^ n : R[X]).roots = n \u2022 ({0} : Multiset R)", "start": [738, 1], "end": [739, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_C_mul_X_pow", "code": "theorem roots_C_mul_X_pow (ha : a \u2260 0) (n : \u2115) :\n    Polynomial.roots (C a * X ^ n) = n \u2022 ({0} : Multiset R)", "start": [743, 1], "end": [745, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_monomial", "code": "@[simp]\ntheorem roots_monomial (ha : a \u2260 0) (n : \u2115) : (monomial n a).roots = n \u2022 ({0} : Multiset R)", "start": [749, 1], "end": [751, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_prod_X_sub_C", "code": "theorem roots_prod_X_sub_C (s : Finset R) : (s.prod fun a => X - C a).roots = s.val", "start": [754, 1], "end": [758, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_multiset_prod_X_sub_C", "code": "@[simp]\ntheorem roots_multiset_prod_X_sub_C (s : Multiset R) : (s.map fun a => X - C a).prod.roots = s", "start": [762, 1], "end": [769, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_multiset_prod_X_sub_C_eq_card", "code": "@[simp]\ntheorem natDegree_multiset_prod_X_sub_C_eq_card (s : Multiset R) :\n    (s.map fun a => X - C a).prod.natDegree = Multiset.card s", "start": [773, 1], "end": [779, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_X_pow_sub_C", "code": "theorem card_roots_X_pow_sub_C {n : \u2115} (hn : 0 < n) (a : R) :\n    Multiset.card (roots ((X : R[X]) ^ n - C a)) \u2264 n", "start": [783, 1], "end": [789, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRoots", "code": "def nthRoots (n : \u2115) (a : R) : Multiset R :=\n  roots ((X : R[X]) ^ n - C a)", "start": [795, 1], "end": [797, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_nthRoots", "code": "@[simp]\ntheorem mem_nthRoots {n : \u2115} (hn : 0 < n) {a x : R} : x \u2208 nthRoots n a \u2194 x ^ n = a", "start": [800, 1], "end": [803, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRoots_zero", "code": "@[simp]\ntheorem nthRoots_zero (r : R) : nthRoots 0 r = 0", "start": [806, 1], "end": [808, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_nthRoots", "code": "theorem card_nthRoots (n : \u2115) (a : R) : Multiset.card (nthRoots n a) \u2264 n", "start": [811, 1], "end": [825, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRoots_two_eq_zero_iff", "code": "@[simp]\ntheorem nthRoots_two_eq_zero_iff {r : R} : nthRoots 2 r = 0 \u2194 \u00acIsSquare r", "start": [828, 1], "end": [831, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRootsFinset", "code": "def nthRootsFinset (n : \u2115) (R : Type*) [CommRing R] [IsDomain R] : Finset R :=\n  haveI := Classical.decEq R\n  Multiset.toFinset (nthRoots n (1 : R))", "start": [834, 1], "end": [837, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRootsFinset_def", "code": "lemma nthRootsFinset_def (n : \u2115) (R : Type*) [CommRing R] [IsDomain R] [DecidableEq R] :\n    nthRootsFinset n R = Multiset.toFinset (nthRoots n (1 : R)) := by\n  unfold nthRootsFinset\n  convert rfl", "start": [841, 1], "end": [844, 14], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.mem_nthRootsFinset", "code": "@[simp]\ntheorem mem_nthRootsFinset {n : \u2115} (h : 0 < n) {x : R} :\n    x \u2208 nthRootsFinset n R \u2194 x ^ (n : \u2115) = 1", "start": [846, 1], "end": [850, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nthRootsFinset_zero", "code": "@[simp]\ntheorem nthRootsFinset_zero : nthRootsFinset 0 R = \u2205", "start": [853, 1], "end": [854, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.comp", "code": "theorem Monic.comp (hp : p.Monic) (hq : q.Monic) (h : q.natDegree \u2260 0) : (p.comp q).Monic", "start": [859, 1], "end": [860, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.comp_X_add_C", "code": "theorem Monic.comp_X_add_C (hp : p.Monic) (r : R) : (p.comp (X + C r)).Monic", "start": [863, 1], "end": [866, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.comp_X_sub_C", "code": "theorem Monic.comp_X_sub_C (hp : p.Monic) (r : R) : (p.comp (X - C r)).Monic", "start": [870, 1], "end": [871, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.units_coeff_zero_smul", "code": "theorem units_coeff_zero_smul (c : R[X]\u02e3) (p : R[X]) : (c : R[X]).coeff 0 \u2022 p = c * p", "start": [875, 1], "end": [876, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_coe_units", "code": "@[simp]\ntheorem natDegree_coe_units (u : R[X]\u02e3) : natDegree (u : R[X]) = 0", "start": [879, 1], "end": [881, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.comp_eq_zero_iff", "code": "theorem comp_eq_zero_iff : p.comp q = 0 \u2194 p = 0 \u2228 p.eval (q.coeff 0) = 0 \u2227 q = C (q.coeff 0)", "start": [884, 1], "end": [896, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.zero_of_eval_zero", "code": "theorem zero_of_eval_zero [Infinite R] (p : R[X]) (h : \u2200 x, p.eval x = 0) : p = 0", "start": [899, 1], "end": [903, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.funext", "code": "theorem funext [Infinite R] {p q : R[X]} (ext : \u2200 r : R, p.eval r = q.eval r) : p = q", "start": [906, 1], "end": [910, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots", "code": "noncomputable abbrev aroots (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] : Multiset S :=\n  (p.map (algebraMap T S)).roots", "start": [915, 1], "end": [918, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_def", "code": "theorem aroots_def (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] :\n    p.aroots S = (p.map (algebraMap T S)).roots", "start": [920, 1], "end": [922, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_aroots'", "code": "theorem mem_aroots' [CommRing S] [IsDomain S] [Algebra T S] {p : T[X]} {a : S} :\n    a \u2208 p.aroots S \u2194 p.map (algebraMap T S) \u2260 0 \u2227 aeval a p = 0", "start": [924, 1], "end": [926, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_aroots", "code": "theorem mem_aroots [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {p : T[X]} {a : S} : a \u2208 p.aroots S \u2194 p \u2260 0 \u2227 aeval a p = 0", "start": [928, 1], "end": [931, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_mul", "code": "theorem aroots_mul [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {p q : T[X]} (hpq : p * q \u2260 0) :\n    (p * q).aroots S = p.aroots S + q.aroots S", "start": [933, 1], "end": [939, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_X_sub_C", "code": "@[simp]\ntheorem aroots_X_sub_C [CommRing S] [IsDomain S] [Algebra T S]\n    (r : T) : aroots (X - C r) S = {algebraMap T S r}", "start": [941, 1], "end": [944, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_X", "code": "@[simp]\ntheorem aroots_X [CommRing S] [IsDomain S] [Algebra T S] :\n    aroots (X : T[X]) S = {0}", "start": [946, 1], "end": [949, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_C", "code": "@[simp]\ntheorem aroots_C [CommRing S] [IsDomain S] [Algebra T S] (a : T) : (C a).aroots S = 0", "start": [951, 1], "end": [953, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_zero", "code": "@[simp]\ntheorem aroots_zero (S) [CommRing S] [IsDomain S] [Algebra T S] : (0 : T[X]).aroots S = 0", "start": [955, 1], "end": [957, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_one", "code": "@[simp]\ntheorem aroots_one [CommRing S] [IsDomain S] [Algebra T S] :\n    (1 : T[X]).aroots S = 0", "start": [959, 1], "end": [962, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_C_mul", "code": "@[simp]\ntheorem aroots_C_mul [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (p : T[X]) (ha : a \u2260 0) :\n    (C a * p).aroots S = p.aroots S", "start": [964, 1], "end": [970, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_smul_nonzero", "code": "@[simp]\ntheorem aroots_smul_nonzero [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (p : T[X]) (ha : a \u2260 0) :\n    (a \u2022 p).aroots S = p.aroots S", "start": [972, 1], "end": [976, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_pow", "code": "@[simp]\ntheorem aroots_pow [CommRing S] [IsDomain S] [Algebra T S] (p : T[X]) (n : \u2115) :\n    (p ^ n).aroots S = n \u2022 p.aroots S", "start": [978, 1], "end": [981, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_X_pow", "code": "theorem aroots_X_pow [CommRing S] [IsDomain S] [Algebra T S] (n : \u2115) :\n    (X ^ n : T[X]).aroots S = n \u2022 ({0} : Multiset S)", "start": [983, 1], "end": [985, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_C_mul_X_pow", "code": "theorem aroots_C_mul_X_pow [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (ha : a \u2260 0) (n : \u2115) :\n    (C a * X ^ n : T[X]).aroots S = n \u2022 ({0} : Multiset S)", "start": [987, 1], "end": [990, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aroots_monomial", "code": "@[simp]\ntheorem aroots_monomial [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : T} (ha : a \u2260 0) (n : \u2115) :\n    (monomial n a).aroots S = n \u2022 ({0} : Multiset S)", "start": [992, 1], "end": [996, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet", "code": "def rootSet (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] : Set S :=\n  haveI := Classical.decEq S\n  (p.aroots S).toFinset", "start": [998, 1], "end": [1004, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_def", "code": "theorem rootSet_def (p : T[X]) (S) [CommRing S] [IsDomain S] [Algebra T S] [DecidableEq S] :\n    p.rootSet S = (p.aroots S).toFinset", "start": [1007, 1], "end": [1010, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_C", "code": "@[simp]\ntheorem rootSet_C [CommRing S] [IsDomain S] [Algebra T S] (a : T) : (C a).rootSet S = \u2205", "start": [1013, 1], "end": [1016, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_zero", "code": "@[simp]\ntheorem rootSet_zero (S) [CommRing S] [IsDomain S] [Algebra T S] : (0 : T[X]).rootSet S = \u2205", "start": [1020, 1], "end": [1022, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSetFintype", "code": "instance rootSetFintype (p : T[X]) (S : Type*) [CommRing S] [IsDomain S] [Algebra T S] :\n    Fintype (p.rootSet S) :=\n  FinsetCoe.fintype _", "start": [1025, 1], "end": [1027, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_finite", "code": "theorem rootSet_finite (p : T[X]) (S : Type*) [CommRing S] [IsDomain S] [Algebra T S] :\n    (p.rootSet S).Finite", "start": [1030, 1], "end": [1032, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bUnion_roots_finite", "code": "theorem bUnion_roots_finite {R S : Type*} [Semiring R] [CommRing S] [IsDomain S] [DecidableEq S]\n    (m : R \u2192+* S) (d : \u2115) {U : Set R} (h : U.Finite) :\n    (\u22c3 (f : R[X]) (_ : f.natDegree \u2264 d \u2227 \u2200 i, f.coeff i \u2208 U),\n        ((f.map m).roots.toFinset.toSet : Set S)).Finite", "start": [1035, 1], "end": [1050, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_rootSet'", "code": "theorem mem_rootSet' {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S] {a : S} :\n    a \u2208 p.rootSet S \u2194 p.map (algebraMap T S) \u2260 0 \u2227 aeval a p = 0", "start": [1053, 1], "end": [1056, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_rootSet", "code": "theorem mem_rootSet {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] {a : S} : a \u2208 p.rootSet S \u2194 p \u2260 0 \u2227 aeval a p = 0", "start": [1059, 1], "end": [1061, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_rootSet_of_ne", "code": "theorem mem_rootSet_of_ne {p : T[X]} {S : Type*} [CommRing S] [IsDomain S] [Algebra T S]\n    [NoZeroSMulDivisors T S] (hp : p \u2260 0) {a : S} : a \u2208 p.rootSet S \u2194 aeval a p = 0", "start": [1064, 1], "end": [1066, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_maps_to'", "code": "theorem rootSet_maps_to' {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']\n    [IsDomain S'] [Algebra T S'] (hp : p.map (algebraMap T S') = 0 \u2192 p.map (algebraMap T S) = 0)\n    (f : S \u2192\u2090[T] S') : (p.rootSet S).MapsTo f (p.rootSet S')", "start": [1069, 1], "end": [1074, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ne_zero_of_mem_rootSet", "code": "theorem ne_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}\n    (h : a \u2208 p.rootSet S) : p \u2260 0", "start": [1077, 1], "end": [1078, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.aeval_eq_zero_of_mem_rootSet", "code": "theorem aeval_eq_zero_of_mem_rootSet {p : T[X]} [CommRing S] [IsDomain S] [Algebra T S] {a : S}\n    (hx : a \u2208 p.rootSet S) : aeval a p = 0", "start": [1081, 1], "end": [1083, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_mapsTo", "code": "theorem rootSet_mapsTo {p : T[X]} {S S'} [CommRing S] [IsDomain S] [Algebra T S] [CommRing S']\n    [IsDomain S'] [Algebra T S'] [NoZeroSMulDivisors T S'] (f : S \u2192\u2090[T] S') :\n    (p.rootSet S).MapsTo f (p.rootSet S')", "start": [1086, 1], "end": [1092, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_coe_units_zero_ne_zero", "code": "theorem coeff_coe_units_zero_ne_zero (u : R[X]\u02e3) : coeff (u : R[X]) 0 \u2260 0", "start": [1097, 1], "end": [1100, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_degree_of_associated", "code": "theorem degree_eq_degree_of_associated (h : Associated p q) : degree p = degree q", "start": [1103, 1], "end": [1105, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_eq_one_of_irreducible_of_root", "code": "theorem degree_eq_one_of_irreducible_of_root (hi : Irreducible p) {x : R} (hx : IsRoot p x) :\n    degree p = 1", "start": [1108, 1], "end": [1117, 94], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_divByMonic_of_monic", "code": "theorem leadingCoeff_divByMonic_of_monic {R : Type u} [CommRing R] {p q : R[X]} (hmonic : q.Monic)\n    (hdegree : q.degree \u2264 p.degree) : (p /\u2098 q).leadingCoeff = p.leadingCoeff", "start": [1120, 1], "end": [1130, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_divByMonic_X_sub_C", "code": "theorem leadingCoeff_divByMonic_X_sub_C (p : R[X]) (hp : degree p \u2260 0) (a : R) :\n    leadingCoeff (p /\u2098 (X - C a)) = leadingCoeff p", "start": [1133, 1], "end": [1139, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le", "code": "theorem eq_leadingCoeff_mul_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]}\n    (hp : p.Monic) (hdiv : p \u2223 q) (hdeg : q.natDegree \u2264 p.natDegree) :\n    q = C q.leadingCoeff * p", "start": [1143, 1], "end": [1156, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_of_monic_of_dvd_of_natDegree_le", "code": "theorem eq_of_monic_of_dvd_of_natDegree_le {R} [CommRing R] {p q : R[X]} (hp : p.Monic)\n    (hq : q.Monic) (hdiv : p \u2223 q) (hdeg : q.natDegree \u2264 p.natDegree) : q = p", "start": [1159, 1], "end": [1162, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isCoprime_X_sub_C_of_isUnit_sub", "code": "theorem isCoprime_X_sub_C_of_isUnit_sub {R} [CommRing R] {a b : R} (h : IsUnit (a - b)) :\n    IsCoprime (X - C a) (X - C b)", "start": [1165, 1], "end": [1171, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.pairwise_coprime_X_sub_C", "code": "theorem pairwise_coprime_X_sub_C {K} [Field K] {I : Type v} {s : I \u2192 K} (H : Function.Injective s) :\n    Pairwise (IsCoprime on fun i : I => X - C (s i))", "start": [1175, 1], "end": [1177, 73], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_prod_multiset_X_sub_C", "code": "theorem monic_prod_multiset_X_sub_C : Monic (p.roots.map fun a => X - C a).prod", "start": [1181, 1], "end": [1182, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_multiset_root_eq_finset_root", "code": "theorem prod_multiset_root_eq_finset_root [DecidableEq R] :\n    (p.roots.map fun a => X - C a).prod =\n      p.roots.toFinset.prod fun a => (X - C a) ^ rootMultiplicity a p", "start": [1186, 1], "end": [1189, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_multiset_X_sub_C_dvd", "code": "theorem prod_multiset_X_sub_C_dvd (p : R[X]) : (p.roots.map fun a => X - C a).prod \u2223 p", "start": [1192, 1], "end": [1200, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_X_sub_C_dvd_iff_le_roots", "code": "theorem _root_.Multiset.prod_X_sub_C_dvd_iff_le_roots {p : R[X]} (hp : p \u2260 0) (s : Multiset R) :\n    (s.map fun a => X - C a).prod \u2223 p \u2194 s \u2264 p.roots", "start": [1204, 1], "end": [1214, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_prod_multiset_X_sub_C_mul", "code": "theorem exists_prod_multiset_X_sub_C_mul (p : R[X]) :\n    \u2203 q,\n      (p.roots.map fun a => X - C a).prod * q = p \u2227\n        Multiset.card p.roots + q.natDegree = p.natDegree \u2227 q.roots = 0", "start": [1218, 1], "end": [1233, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_leadingCoeff_mul_prod_multiset_X_sub_C", "code": "theorem C_leadingCoeff_mul_prod_multiset_X_sub_C (hroots : Multiset.card p.roots = p.natDegree) :\n    C p.leadingCoeff * (p.roots.map fun a => X - C a).prod = p", "start": [1237, 1], "end": [1243, 74], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prod_multiset_X_sub_C_of_monic_of_roots_card_eq", "code": "theorem prod_multiset_X_sub_C_of_monic_of_roots_card_eq (hp : p.Monic)\n    (hroots : Multiset.card p.roots = p.natDegree) : (p.roots.map fun a => X - C a).prod = p", "start": [1247, 1], "end": [1252, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.le_rootMultiplicity_map", "code": "theorem le_rootMultiplicity_map {p : A[X]} {f : A \u2192+* B} (hmap : map f p \u2260 0) (a : A) :\n    rootMultiplicity a p \u2264 rootMultiplicity (f a) (p.map f)", "start": [1262, 1], "end": [1266, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_rootMultiplicity_map", "code": "theorem eq_rootMultiplicity_map {p : A[X]} {f : A \u2192+* B} (hf : Function.Injective f) (a : A) :\n    rootMultiplicity a p = rootMultiplicity (f a) (p.map f)", "start": [1269, 1], "end": [1275, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.count_map_roots", "code": "theorem count_map_roots [IsDomain A] [DecidableEq B] {p : A[X]} {f : A \u2192+* B} (hmap : map f p \u2260 0)\n    (b : B) :\n    (p.roots.map f).count b \u2264 rootMultiplicity b (p.map f)", "start": [1278, 1], "end": [1289, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.count_map_roots_of_injective", "code": "theorem count_map_roots_of_injective [IsDomain A] [DecidableEq B] (p : A[X]) {f : A \u2192+* B}\n    (hf : Function.Injective f) (b : B) :\n    (p.roots.map f).count b \u2264 rootMultiplicity b (p.map f)", "start": [1292, 1], "end": [1298, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_roots_le", "code": "theorem map_roots_le [IsDomain A] [IsDomain B] {p : A[X]} {f : A \u2192+* B} (h : p.map f \u2260 0) :\n    p.roots.map f \u2264 (p.map f).roots", "start": [1301, 1], "end": [1306, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_roots_le_of_injective", "code": "theorem map_roots_le_of_injective [IsDomain A] [IsDomain B] (p : A[X]) {f : A \u2192+* B}\n    (hf : Function.Injective f) : p.roots.map f \u2264 (p.map f).roots", "start": [1309, 1], "end": [1313, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_le_map", "code": "theorem card_roots_le_map [IsDomain A] [IsDomain B] {p : A[X]} {f : A \u2192+* B} (h : p.map f \u2260 0) :\n    Multiset.card p.roots \u2264 Multiset.card (p.map f).roots", "start": [1316, 1], "end": [1319, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_roots_le_map_of_injective", "code": "theorem card_roots_le_map_of_injective [IsDomain A] [IsDomain B] {p : A[X]} {f : A \u2192+* B}\n    (hf : Function.Injective f) : Multiset.card p.roots \u2264 Multiset.card (p.map f).roots", "start": [1322, 1], "end": [1326, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_map_of_injective_of_card_eq_natDegree", "code": "theorem roots_map_of_injective_of_card_eq_natDegree [IsDomain A] [IsDomain B] {p : A[X]}\n    {f : A \u2192+* B} (hf : Function.Injective f) (hroots : Multiset.card p.roots = p.natDegree) :\n    p.roots.map f = (p.map f).roots", "start": [1329, 1], "end": [1333, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_of_isUnit_leadingCoeff_of_isUnit_map", "code": "theorem isUnit_of_isUnit_leadingCoeff_of_isUnit_map {f : R[X]} (hf : IsUnit f.leadingCoeff)\n    (H : IsUnit (map \u03c6 f)) : IsUnit f", "start": [1342, 1], "end": [1357, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.irreducible_of_irreducible_map", "code": "theorem Monic.irreducible_of_irreducible_map (f : R[X]) (h_mon : Monic f)\n    (h_irr : Irreducible (Polynomial.map \u03c6 f)) : Irreducible f", "start": [1366, 1], "end": [1384, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/EuclideanDomain.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/RingTheory/PrincipalIdealDomain.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "Mathlib/Algebra/EuclideanDomain/Basic.lean"], "premises": [{"full_name": "gcd_ne_zero_of_left", "code": "theorem gcd_ne_zero_of_left (hp : p \u2260 0) : GCDMonoid.gcd p q \u2260 0", "start": [34, 1], "end": [35, 51], "kind": "commanddeclaration"}, {"full_name": "gcd_ne_zero_of_right", "code": "theorem gcd_ne_zero_of_right (hp : q \u2260 0) : GCDMonoid.gcd p q \u2260 0", "start": [38, 1], "end": [39, 52], "kind": "commanddeclaration"}, {"full_name": "left_div_gcd_ne_zero", "code": "theorem left_div_gcd_ne_zero {p q : R} (hp : p \u2260 0) : p / GCDMonoid.gcd p q \u2260 0", "start": [42, 1], "end": [47, 11], "kind": "commanddeclaration"}, {"full_name": "right_div_gcd_ne_zero", "code": "theorem right_div_gcd_ne_zero {p q : R} (hq : q \u2260 0) : q / GCDMonoid.gcd p q \u2260 0", "start": [50, 1], "end": [55, 11], "kind": "commanddeclaration"}, {"full_name": "isCoprime_div_gcd_div_gcd", "code": "theorem isCoprime_div_gcd_div_gcd (hq : q \u2260 0) :\n    IsCoprime (p / GCDMonoid.gcd p q) (q / GCDMonoid.gcd p q)", "start": [58, 1], "end": [64, 30], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcdMonoid", "code": "def gcdMonoid (R) [EuclideanDomain R] [DecidableEq R] : GCDMonoid R where\n  gcd := gcd\n  lcm := lcm\n  gcd_dvd_left := gcd_dvd_left\n  gcd_dvd_right := gcd_dvd_right\n  dvd_gcd := dvd_gcd\n  gcd_mul_lcm a b := by rw [EuclideanDomain.gcd_mul_lcm]\n  lcm_zero_left := lcm_zero_left\n  lcm_zero_right := lcm_zero_right", "start": [71, 1], "end": [81, 35], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.span_gcd", "code": "theorem span_gcd (x y : \u03b1) :\n    span ({gcd x y} : Set \u03b1) = span ({x, y} : Set \u03b1)", "start": [86, 1], "end": [89, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_isUnit_iff", "code": "theorem gcd_isUnit_iff {x y : \u03b1} : IsUnit (gcd x y) \u2194 IsCoprime x y", "start": [92, 1], "end": [94, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.isCoprime_of_dvd", "code": "theorem isCoprime_of_dvd {x y : \u03b1} (nonzero : \u00ac(x = 0 \u2227 y = 0))\n    (H : \u2200 z \u2208 nonunits \u03b1, z \u2260 0 \u2192 z \u2223 x \u2192 \u00acz \u2223 y) : IsCoprime x y", "start": [98, 1], "end": [101, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.dvd_or_coprime", "code": "theorem dvd_or_coprime (x y : \u03b1) (h : Irreducible x) :\n    x \u2223 y \u2228 IsCoprime x y", "start": [105, 1], "end": [108, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/CountableSeparatingOn.lean", "imports": ["Mathlib/Order/Filter/CountableInter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasCountableSeparatingOn", "code": "class HasCountableSeparatingOn (\u03b1 : Type*) (p : Set \u03b1 \u2192 Prop) (t : Set \u03b1) : Prop where\n  exists_countable_separating : \u2203 S : Set (Set \u03b1), S.Countable \u2227 (\u2200 s \u2208 S, p s) \u2227\n    \u2200 x \u2208 t, \u2200 y \u2208 t, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y", "start": [77, 1], "end": [87, 55], "kind": "commanddeclaration"}, {"full_name": "exists_countable_separating", "code": "theorem exists_countable_separating (\u03b1 : Type*) (p : Set \u03b1 \u2192 Prop) (t : Set \u03b1)\n    [h : HasCountableSeparatingOn \u03b1 p t] :\n    \u2203 S : Set (Set \u03b1), S.Countable \u2227 (\u2200 s \u2208 S, p s) \u2227\n      \u2200 x \u2208 t, \u2200 y \u2208 t, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y", "start": [89, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "exists_nonempty_countable_separating", "code": "theorem exists_nonempty_countable_separating (\u03b1 : Type*) {p : Set \u03b1 \u2192 Prop} {s\u2080} (hp : p s\u2080)\n    (t : Set \u03b1) [HasCountableSeparatingOn \u03b1 p t] :\n    \u2203 S : Set (Set \u03b1), S.Nonempty \u2227 S.Countable \u2227 (\u2200 s \u2208 S, p s) \u2227\n      \u2200 x \u2208 t, \u2200 y \u2208 t, (\u2200 s \u2208 S, x \u2208 s \u2194 y \u2208 s) \u2192 x = y", "start": [95, 1], "end": [101, 70], "kind": "commanddeclaration"}, {"full_name": "exists_seq_separating", "code": "theorem exists_seq_separating (\u03b1 : Type*) {p : Set \u03b1 \u2192 Prop} {s\u2080} (hp : p s\u2080) (t : Set \u03b1)\n    [HasCountableSeparatingOn \u03b1 p t] :\n    \u2203 S : \u2115 \u2192 Set \u03b1, (\u2200 n, p (S n)) \u2227 \u2200 x \u2208 t, \u2200 y \u2208 t, (\u2200 n, x \u2208 S n \u2194 y \u2208 S n) \u2192 x = y", "start": [103, 1], "end": [109, 41], "kind": "commanddeclaration"}, {"full_name": "HasCountableSeparatingOn.mono", "code": "theorem HasCountableSeparatingOn.mono {\u03b1} {p\u2081 p\u2082 : Set \u03b1 \u2192 Prop} {t\u2081 t\u2082 : Set \u03b1}\n    [h : HasCountableSeparatingOn \u03b1 p\u2081 t\u2081] (hp : \u2200 s, p\u2081 s \u2192 p\u2082 s) (ht : t\u2082 \u2286 t\u2081) :\n    HasCountableSeparatingOn \u03b1 p\u2082 t\u2082 where", "start": [111, 1], "end": [116, 82], "kind": "commanddeclaration"}, {"full_name": "HasCountableSeparatingOn.of_subtype", "code": "theorem HasCountableSeparatingOn.of_subtype {\u03b1 : Type*} {p : Set \u03b1 \u2192 Prop} {t : Set \u03b1}\n    {q : Set t \u2192 Prop} [h : HasCountableSeparatingOn t q univ]\n    (hpq : \u2200 U, q U \u2192 \u2203 V, p V \u2227 (\u2191) \u207b\u00b9' V = U) : HasCountableSeparatingOn \u03b1 p t", "start": [118, 1], "end": [126, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_subset_subsingleton_mem_of_forall_separating", "code": "theorem exists_subset_subsingleton_mem_of_forall_separating (p : Set \u03b1 \u2192 Prop)\n    {s : Set \u03b1} [h : HasCountableSeparatingOn \u03b1 p s] (hs : s \u2208 l)\n    (hl : \u2200 U, p U \u2192 U \u2208 l \u2228 U\u1d9c \u2208 l) : \u2203 t, t \u2286 s \u2227 t.Subsingleton \u2227 t \u2208 l", "start": [145, 1], "end": [159, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating", "code": "theorem exists_mem_singleton_mem_of_mem_of_nonempty_of_forall_separating (p : Set \u03b1 \u2192 Prop)\n    {s : Set \u03b1} [HasCountableSeparatingOn \u03b1 p s] (hs : s \u2208 l) (hne : s.Nonempty)\n    (hl : \u2200 U, p U \u2192 U \u2208 l \u2228 U\u1d9c \u2208 l) : \u2203 a \u2208 s, {a} \u2208 l", "start": [161, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_singleton_mem_of_mem_of_forall_separating", "code": "theorem exists_singleton_mem_of_mem_of_forall_separating [Nonempty \u03b1] (p : Set \u03b1 \u2192 Prop)\n    {s : Set \u03b1} [HasCountableSeparatingOn \u03b1 p s] (hs : s \u2208 l) (hl : \u2200 U, p U \u2192 U \u2208 l \u2228 U\u1d9c \u2208 l) :\n    \u2203 a, {a} \u2208 l", "start": [169, 1], "end": [175, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_subsingleton_mem_of_forall_separating", "code": "theorem exists_subsingleton_mem_of_forall_separating (p : Set \u03b1 \u2192 Prop)\n    [HasCountableSeparatingOn \u03b1 p univ] (hl : \u2200 U, p U \u2192 U \u2208 l \u2228 U\u1d9c \u2208 l) :\n    \u2203 s : Set \u03b1, s.Subsingleton \u2227 s \u2208 l", "start": [177, 1], "end": [181, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_singleton_mem_of_forall_separating", "code": "theorem exists_singleton_mem_of_forall_separating [Nonempty \u03b1] (p : Set \u03b1 \u2192 Prop)\n    [HasCountableSeparatingOn \u03b1 p univ] (hl : \u2200 U, p U \u2192 U \u2208 l \u2228 U\u1d9c \u2208 l) :\n    \u2203 x : \u03b1, {x} \u2208 l", "start": [183, 1], "end": [186, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_mem_eventuallyEq_const_of_eventually_mem_of_forall_separating", "code": "theorem exists_mem_eventuallyEq_const_of_eventually_mem_of_forall_separating (p : Set \u03b2 \u2192 Prop)\n    {s : Set \u03b2} [HasCountableSeparatingOn \u03b2 p s] (hs : \u2200\u1da0 x in l, f x \u2208 s) (hne : s.Nonempty)\n    (h : \u2200 U, p U \u2192 (\u2200\u1da0 x in l, f x \u2208 U) \u2228 (\u2200\u1da0 x in l, f x \u2209 U)) :\n    \u2203 a \u2208 s, f =\u1da0[l] const \u03b1 a", "start": [196, 1], "end": [200, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_eventuallyEq_const_of_eventually_mem_of_forall_separating", "code": "theorem exists_eventuallyEq_const_of_eventually_mem_of_forall_separating [Nonempty \u03b2]\n    (p : Set \u03b2 \u2192 Prop) {s : Set \u03b2} [HasCountableSeparatingOn \u03b2 p s] (hs : \u2200\u1da0 x in l, f x \u2208 s)\n    (h : \u2200 U, p U \u2192 (\u2200\u1da0 x in l, f x \u2208 U) \u2228 (\u2200\u1da0 x in l, f x \u2209 U)) :\n    \u2203 a, f =\u1da0[l] const \u03b1 a", "start": [202, 1], "end": [206, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_eventuallyEq_const_of_forall_separating", "code": "theorem exists_eventuallyEq_const_of_forall_separating [Nonempty \u03b2] (p : Set \u03b2 \u2192 Prop)\n    [HasCountableSeparatingOn \u03b2 p univ]\n    (h : \u2200 U, p U \u2192 (\u2200\u1da0 x in l, f x \u2208 U) \u2228 (\u2200\u1da0 x in l, f x \u2209 U)) :\n    \u2203 a, f =\u1da0[l] const \u03b1 a", "start": [208, 1], "end": [212, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.of_eventually_mem_of_forall_separating_mem_iff", "code": "theorem of_eventually_mem_of_forall_separating_mem_iff (p : Set \u03b2 \u2192 Prop) {s : Set \u03b2}\n    [h' : HasCountableSeparatingOn \u03b2 p s] (hf : \u2200\u1da0 x in l, f x \u2208 s) (hg : \u2200\u1da0 x in l, g x \u2208 s)\n    (h : \u2200 U : Set \u03b2, p U \u2192 \u2200\u1da0 x in l, f x \u2208 U \u2194 g x \u2208 U) : f =\u1da0[l] g", "start": [224, 1], "end": [230, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.of_forall_separating_mem_iff", "code": "theorem of_forall_separating_mem_iff (p : Set \u03b2 \u2192 Prop)\n    [HasCountableSeparatingOn \u03b2 p univ] (h : \u2200 U : Set \u03b2, p U \u2192 \u2200\u1da0 x in l, f x \u2208 U \u2194 g x \u2208 U) :\n    f =\u1da0[l] g", "start": [232, 1], "end": [235, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.of_eventually_mem_of_forall_separating_preimage", "code": "theorem of_eventually_mem_of_forall_separating_preimage (p : Set \u03b2 \u2192 Prop) {s : Set \u03b2}\n    [HasCountableSeparatingOn \u03b2 p s] (hf : \u2200\u1da0 x in l, f x \u2208 s) (hg : \u2200\u1da0 x in l, g x \u2208 s)\n    (h : \u2200 U : Set \u03b2, p U \u2192 f \u207b\u00b9' U =\u1da0[l] g \u207b\u00b9' U) : f =\u1da0[l] g", "start": [237, 1], "end": [240, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.of_forall_separating_preimage", "code": "theorem of_forall_separating_preimage (p : Set \u03b2 \u2192 Prop) [HasCountableSeparatingOn \u03b2 p univ]\n    (h : \u2200 U : Set \u03b2, p U \u2192 f \u207b\u00b9' U =\u1da0[l] g \u207b\u00b9' U) : f =\u1da0[l] g", "start": [242, 1], "end": [244, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Prod/TProd.lean", "imports": ["Mathlib/Data/List/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.TProd", "code": "def TProd (l : List \u03b9) : Type v :=\n  l.foldr (fun i \u03b2 => \u03b1 i \u00d7 \u03b2) PUnit", "start": [46, 1], "end": [48, 37], "kind": "commanddeclaration"}, {"full_name": "List.TProd.mk", "code": "protected def mk : \u2200 (l : List \u03b9) (_f : \u2200 i, \u03b1 i), TProd \u03b1 l\n  | [] => fun _ => PUnit.unit\n  | i :: is => fun f => (f i, TProd.mk is f)", "start": [57, 1], "end": [60, 45], "kind": "commanddeclaration"}, {"full_name": "List.TProd.fst_mk", "code": "@[simp]\ntheorem fst_mk (i : \u03b9) (l : List \u03b9) (f : \u2200 i, \u03b1 i) : (TProd.mk (i :: l) f).1 = f i", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "List.TProd.snd_mk", "code": "@[simp]\ntheorem snd_mk (i : \u03b9) (l : List \u03b9) (f : \u2200 i, \u03b1 i) :\n    (TProd.mk.{u,v} (i :: l) f).2 = TProd.mk.{u,v} l f", "start": [71, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim", "code": "protected def elim : \u2200 {l : List \u03b9} (_ : TProd \u03b1 l) {i : \u03b9} (_ : i \u2208 l), \u03b1 i\n  | i :: is, v, j, hj =>\n    if hji : j = i then by\n      subst hji\n      exact v.1\n    else TProd.elim v.2 ((List.mem_cons.mp hj).resolve_left hji)", "start": [79, 1], "end": [86, 65], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim_self", "code": "@[simp]\ntheorem elim_self (v : TProd \u03b1 (i :: l)) : v.elim (l.mem_cons_self i) = v.1", "start": [89, 1], "end": [90, 100], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim_of_ne", "code": "@[simp]\ntheorem elim_of_ne (hj : j \u2208 i :: l) (hji : j \u2260 i) (v : TProd \u03b1 (i :: l)) :\n    v.elim hj = TProd.elim v.2 ((List.mem_cons.mp hj).resolve_left hji)", "start": [93, 1], "end": [95, 101], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim_of_mem", "code": "@[simp]\ntheorem elim_of_mem (hl : (i :: l).Nodup) (hj : j \u2208 l) (v : TProd \u03b1 (i :: l)) :\n    v.elim (mem_cons_of_mem _ hj) = TProd.elim v.2 hj", "start": [98, 1], "end": [103, 22], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim_mk", "code": "theorem elim_mk : \u2200 (l : List \u03b9) (f : \u2200 i, \u03b1 i) {i : \u03b9} (hi : i \u2208 l), (TProd.mk l f).elim hi = f i", "start": [106, 1], "end": [112, 48], "kind": "commanddeclaration"}, {"full_name": "List.TProd.ext", "code": "@[ext]\ntheorem ext :\n    \u2200 {l : List \u03b9} (_ : l.Nodup) {v w : TProd \u03b1 l}\n      (_ : \u2200 (i) (hi : i \u2208 l), v.elim hi = w.elim hi), v = w", "start": [115, 1], "end": [123, 47], "kind": "commanddeclaration"}, {"full_name": "List.TProd.elim'", "code": "@[simp]\nprotected def elim' (h : \u2200 i, i \u2208 l) (v : TProd \u03b1 l) (i : \u03b9) : \u03b1 i :=\n  v.elim (h i)", "start": [126, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "List.TProd.mk_elim", "code": "theorem mk_elim (hnd : l.Nodup) (h : \u2200 i, i \u2208 l) (v : TProd \u03b1 l) : TProd.mk l (v.elim' h) = v", "start": [133, 1], "end": [134, 46], "kind": "commanddeclaration"}, {"full_name": "List.TProd.piEquivTProd", "code": "def piEquivTProd (hnd : l.Nodup) (h : \u2200 i, i \u2208 l) : (\u2200 i, \u03b1 i) \u2243 TProd \u03b1 l :=\n  \u27e8TProd.mk l, TProd.elim' h, fun f => funext fun i => elim_mk l f (h i), mk_elim hnd h\u27e9", "start": [137, 1], "end": [139, 89], "kind": "commanddeclaration"}, {"full_name": "Set.tprod", "code": "@[simp]\nprotected def tprod : \u2200 (l : List \u03b9) (_t : \u2200 i, Set (\u03b1 i)), Set (TProd \u03b1 l)\n  | [], _ => univ\n  | i :: is, t => t i \u00d7\u02e2 Set.tprod is t", "start": [150, 1], "end": [154, 40], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_tprod", "code": "theorem mk_preimage_tprod :\n    \u2200 (l : List \u03b9) (t : \u2200 i, Set (\u03b1 i)), TProd.mk l \u207b\u00b9' Set.tprod l t = { i | i \u2208 l }.pi t", "start": [157, 1], "end": [170, 21], "kind": "commanddeclaration"}, {"full_name": "Set.elim_preimage_pi", "code": "theorem elim_preimage_pi [DecidableEq \u03b9] {l : List \u03b9} (hnd : l.Nodup) (h : \u2200 i, i \u2208 l)\n    (t : \u2200 i, Set (\u03b1 i)) : TProd.elim' h \u207b\u00b9' pi univ t = Set.tprod l t", "start": [173, 1], "end": [180, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/AEDisjoint.lean", "imports": ["Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.AEDisjoint", "code": "def AEDisjoint (s t : Set \u03b1) :=\n  \u03bc (s \u2229 t) = 0", "start": [25, 1], "end": [27, 16], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_null_pairwise_disjoint_diff", "code": "theorem exists_null_pairwise_disjoint_diff [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (hd : Pairwise (AEDisjoint \u03bc on s)) : \u2203 t : \u03b9 \u2192 Set \u03b1, (\u2200 i, MeasurableSet (t i)) \u2227\n    (\u2200 i, \u03bc (t i) = 0) \u2227 Pairwise (Disjoint on fun i => s i \\ t i)", "start": [32, 1], "end": [45, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.eq", "code": "protected theorem eq (h : AEDisjoint \u03bc s t) : \u03bc (s \u2229 t) = 0", "start": [50, 1], "end": [51, 4], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.symm", "code": "@[symm]\nprotected theorem symm (h : AEDisjoint \u03bc s t) : AEDisjoint \u03bc t s", "start": [54, 1], "end": [55, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.symmetric", "code": "protected theorem symmetric : Symmetric (AEDisjoint \u03bc)", "start": [58, 1], "end": [58, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.comm", "code": "protected theorem comm : AEDisjoint \u03bc s t \u2194 AEDisjoint \u03bc t s", "start": [61, 1], "end": [62, 37], "kind": "commanddeclaration"}, {"full_name": "Disjoint.aedisjoint", "code": "protected theorem _root_.Disjoint.aedisjoint (h : Disjoint s t) : AEDisjoint \u03bc s t", "start": [65, 1], "end": [66, 66], "kind": "commanddeclaration"}, {"full_name": "Pairwise.aedisjoint", "code": "protected theorem _root_.Pairwise.aedisjoint {f : \u03b9 \u2192 Set \u03b1} (hf : Pairwise (Disjoint on f)) :\n    Pairwise (AEDisjoint \u03bc on f)", "start": [69, 1], "end": [71, 38], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.aedisjoint", "code": "protected theorem _root_.Set.PairwiseDisjoint.aedisjoint {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9}\n    (hf : s.PairwiseDisjoint f) : s.Pairwise (AEDisjoint \u03bc on f)", "start": [74, 1], "end": [76, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.mono_ae", "code": "theorem mono_ae (h : AEDisjoint \u03bc s t) (hu : u \u2264\u1d50[\u03bc] s) (hv : v \u2264\u1d50[\u03bc] t) : AEDisjoint \u03bc u v", "start": [79, 1], "end": [80, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.mono", "code": "protected theorem mono (h : AEDisjoint \u03bc s t) (hu : u \u2286 s) (hv : v \u2286 t) : AEDisjoint \u03bc u v", "start": [83, 1], "end": [84, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.congr", "code": "protected theorem congr (h : AEDisjoint \u03bc s t) (hu : u =\u1d50[\u03bc] s) (hv : v =\u1d50[\u03bc] t) :\n    AEDisjoint \u03bc u v", "start": [87, 1], "end": [89, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.iUnion_left_iff", "code": "@[simp]\ntheorem iUnion_left_iff [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} :\n    AEDisjoint \u03bc (\u22c3 i, s i) t \u2194 \u2200 i, AEDisjoint \u03bc (s i) t", "start": [92, 1], "end": [95, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.iUnion_right_iff", "code": "@[simp]\ntheorem iUnion_right_iff [Countable \u03b9] {t : \u03b9 \u2192 Set \u03b1} :\n    AEDisjoint \u03bc s (\u22c3 i, t i) \u2194 \u2200 i, AEDisjoint \u03bc s (t i)", "start": [98, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.union_left_iff", "code": "@[simp]\ntheorem union_left_iff : AEDisjoint \u03bc (s \u222a t) u \u2194 AEDisjoint \u03bc s u \u2227 AEDisjoint \u03bc t u", "start": [104, 1], "end": [106, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.union_right_iff", "code": "@[simp]\ntheorem union_right_iff : AEDisjoint \u03bc s (t \u222a u) \u2194 AEDisjoint \u03bc s t \u2227 AEDisjoint \u03bc s u", "start": [109, 1], "end": [111, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.union_left", "code": "theorem union_left (hs : AEDisjoint \u03bc s u) (ht : AEDisjoint \u03bc t u) : AEDisjoint \u03bc (s \u222a t) u", "start": [114, 1], "end": [115, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.union_right", "code": "theorem union_right (ht : AEDisjoint \u03bc s t) (hu : AEDisjoint \u03bc s u) : AEDisjoint \u03bc s (t \u222a u)", "start": [118, 1], "end": [119, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.diff_ae_eq_left", "code": "theorem diff_ae_eq_left (h : AEDisjoint \u03bc s t) : (s \\ t : Set \u03b1) =\u1d50[\u03bc] s", "start": [122, 1], "end": [123, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.diff_ae_eq_right", "code": "theorem diff_ae_eq_right (h : AEDisjoint \u03bc s t) : (t \\ s : Set \u03b1) =\u1d50[\u03bc] t", "start": [126, 1], "end": [127, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.measure_diff_left", "code": "theorem measure_diff_left (h : AEDisjoint \u03bc s t) : \u03bc (s \\ t) = \u03bc s", "start": [130, 1], "end": [131, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.measure_diff_right", "code": "theorem measure_diff_right (h : AEDisjoint \u03bc s t) : \u03bc (t \\ s) = \u03bc t", "start": [134, 1], "end": [135, 49], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.exists_disjoint_diff", "code": "theorem exists_disjoint_diff (h : AEDisjoint \u03bc s t) :\n    \u2203 u, MeasurableSet u \u2227 \u03bc u = 0 \u2227 Disjoint (s \\ u) t", "start": [138, 1], "end": [144, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.of_null_right", "code": "theorem of_null_right (h : \u03bc t = 0) : AEDisjoint \u03bc s t", "start": [147, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEDisjoint.of_null_left", "code": "theorem of_null_left (h : \u03bc s = 0) : AEDisjoint \u03bc s t", "start": [151, 1], "end": [152, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aedisjoint_compl_left", "code": "theorem aedisjoint_compl_left : AEDisjoint \u03bc s\u1d9c s", "start": [157, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.aedisjoint_compl_right", "code": "theorem aedisjoint_compl_right : AEDisjoint \u03bc s s\u1d9c", "start": [161, 1], "end": [162, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/Basic.lean", "imports": ["Mathlib/Analysis/Convex/Hull.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Analysis/Convex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Absorbs", "code": "def Absorbs (A B : Set E) :=\n  \u2203 r, 0 < r \u2227 \u2200 a : \ud835\udd5c, r \u2264 \u2016a\u2016 \u2192 B \u2286 a \u2022 A", "start": [56, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "absorbs_empty", "code": "@[simp]\ntheorem absorbs_empty {s : Set E} : Absorbs \ud835\udd5c s (\u2205 : Set E)", "start": [64, 1], "end": [66, 49], "kind": "commanddeclaration"}, {"full_name": "Absorbs.mono", "code": "theorem Absorbs.mono (hs : Absorbs \ud835\udd5c s u) (hst : s \u2286 t) (hvu : v \u2286 u) : Absorbs \ud835\udd5c t v", "start": [69, 1], "end": [71, 73], "kind": "commanddeclaration"}, {"full_name": "Absorbs.mono_left", "code": "theorem Absorbs.mono_left (hs : Absorbs \ud835\udd5c s u) (h : s \u2286 t) : Absorbs \ud835\udd5c t u", "start": [74, 1], "end": [75, 23], "kind": "commanddeclaration"}, {"full_name": "Absorbs.mono_right", "code": "theorem Absorbs.mono_right (hs : Absorbs \ud835\udd5c s u) (h : v \u2286 u) : Absorbs \ud835\udd5c s v", "start": [78, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "Absorbs.union", "code": "theorem Absorbs.union (hu : Absorbs \ud835\udd5c s u) (hv : Absorbs \ud835\udd5c s v) : Absorbs \ud835\udd5c s (u \u222a v)", "start": [82, 1], "end": [87, 83], "kind": "commanddeclaration"}, {"full_name": "absorbs_union", "code": "@[simp]\ntheorem absorbs_union : Absorbs \ud835\udd5c s (u \u222a v) \u2194 Absorbs \ud835\udd5c s u \u2227 Absorbs \ud835\udd5c s v", "start": [90, 1], "end": [93, 28], "kind": "commanddeclaration"}, {"full_name": "absorbs_iUnion_finset", "code": "theorem absorbs_iUnion_finset {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 Set E} :\n    Absorbs \ud835\udd5c s (\u22c3 i \u2208 t, f i) \u2194 \u2200 i \u2208 t, Absorbs \ud835\udd5c s (f i)", "start": [96, 1], "end": [108, 96], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.absorbs_iUnion", "code": "theorem Set.Finite.absorbs_iUnion {\u03b9 : Type*} {s : Set E} {t : Set \u03b9} {f : \u03b9 \u2192 Set E}\n    (hi : t.Finite) : Absorbs \ud835\udd5c s (\u22c3 i \u2208 t, f i) \u2194 \u2200 i \u2208 t, Absorbs \ud835\udd5c s (f i)", "start": [111, 1], "end": [115, 30], "kind": "commanddeclaration"}, {"full_name": "Absorbent", "code": "def Absorbent (A : Set E) :=\n  \u2200 x, \u2203 r, 0 < r \u2227 \u2200 a : \ud835\udd5c, r \u2264 \u2016a\u2016 \u2192 x \u2208 a \u2022 A", "start": [120, 1], "end": [122, 49], "kind": "commanddeclaration"}, {"full_name": "Absorbent.subset", "code": "theorem Absorbent.subset (hA : Absorbent \ud835\udd5c A) (hAB : A \u2286 B) : Absorbent \ud835\udd5c B", "start": [127, 1], "end": [129, 98], "kind": "commanddeclaration"}, {"full_name": "absorbent_iff_forall_absorbs_singleton", "code": "theorem absorbent_iff_forall_absorbs_singleton : Absorbent \ud835\udd5c A \u2194 \u2200 x, Absorbs \ud835\udd5c A {x}", "start": [132, 1], "end": [133, 53], "kind": "commanddeclaration"}, {"full_name": "Absorbent.absorbs", "code": "theorem Absorbent.absorbs (hs : Absorbent \ud835\udd5c s) {x : E} : Absorbs \ud835\udd5c s {x}", "start": [136, 1], "end": [137, 48], "kind": "commanddeclaration"}, {"full_name": "absorbent_iff_nonneg_lt", "code": "theorem absorbent_iff_nonneg_lt :\n    Absorbent \ud835\udd5c A \u2194 \u2200 x, \u2203 r, 0 \u2264 r \u2227 \u2200 \u2983a : \ud835\udd5c\u2984, r < \u2016a\u2016 \u2192 x \u2208 a \u2022 A", "start": [140, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "Absorbent.absorbs_finite", "code": "theorem Absorbent.absorbs_finite {s : Set E} (hs : Absorbent \ud835\udd5c s) {v : Set E} (hv : v.Finite) :\n    Absorbs \ud835\udd5c s v", "start": [148, 1], "end": [151, 52], "kind": "commanddeclaration"}, {"full_name": "Balanced", "code": "def Balanced (A : Set E) :=\n  \u2200 a : \ud835\udd5c, \u2016a\u2016 \u2264 1 \u2192 a \u2022 A \u2286 A", "start": [156, 1], "end": [158, 31], "kind": "commanddeclaration"}, {"full_name": "balanced_iff_smul_mem", "code": "theorem balanced_iff_smul_mem : Balanced \ud835\udd5c s \u2194 \u2200 \u2983a : \ud835\udd5c\u2984, \u2016a\u2016 \u2264 1 \u2192 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 a \u2022 x \u2208 s", "start": [163, 1], "end": [164, 50], "kind": "commanddeclaration"}, {"full_name": "Balanced.smul_mem", "code": "alias \u27e8Balanced.smul_mem, _\u27e9 := balanced_iff_smul_mem", "start": [167, 1], "end": [167, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "balanced_empty", "code": "@[simp]\ntheorem balanced_empty : Balanced \ud835\udd5c (\u2205 : Set E)", "start": [170, 1], "end": [171, 85], "kind": "commanddeclaration"}, {"full_name": "balanced_univ", "code": "@[simp]\ntheorem balanced_univ : Balanced \ud835\udd5c (univ : Set E)", "start": [174, 1], "end": [175, 81], "kind": "commanddeclaration"}, {"full_name": "Balanced.union", "code": "theorem Balanced.union (hA : Balanced \ud835\udd5c A) (hB : Balanced \ud835\udd5c B) : Balanced \ud835\udd5c (A \u222a B)", "start": [178, 1], "end": [179, 73], "kind": "commanddeclaration"}, {"full_name": "Balanced.inter", "code": "theorem Balanced.inter (hA : Balanced \ud835\udd5c A) (hB : Balanced \ud835\udd5c B) : Balanced \ud835\udd5c (A \u2229 B)", "start": [182, 1], "end": [183, 73], "kind": "commanddeclaration"}, {"full_name": "balanced_iUnion", "code": "theorem balanced_iUnion {f : \u03b9 \u2192 Set E} (h : \u2200 i, Balanced \ud835\udd5c (f i)) : Balanced \ud835\udd5c (\u22c3 i, f i)", "start": [186, 1], "end": [187, 83], "kind": "commanddeclaration"}, {"full_name": "balanced_iUnion\u2082", "code": "theorem balanced_iUnion\u2082 {f : \u2200 i, \u03ba i \u2192 Set E} (h : \u2200 i j, Balanced \ud835\udd5c (f i j)) :\n    Balanced \ud835\udd5c (\u22c3 (i) (j), f i j)", "start": [190, 1], "end": [192, 50], "kind": "commanddeclaration"}, {"full_name": "balanced_iInter", "code": "theorem balanced_iInter {f : \u03b9 \u2192 Set E} (h : \u2200 i, Balanced \ud835\udd5c (f i)) : Balanced \ud835\udd5c (\u22c2 i, f i)", "start": [195, 1], "end": [196, 83], "kind": "commanddeclaration"}, {"full_name": "balanced_iInter\u2082", "code": "theorem balanced_iInter\u2082 {f : \u2200 i, \u03ba i \u2192 Set E} (h : \u2200 i j, Balanced \ud835\udd5c (f i j)) :\n    Balanced \ud835\udd5c (\u22c2 (i) (j), f i j)", "start": [199, 1], "end": [201, 50], "kind": "commanddeclaration"}, {"full_name": "Balanced.smul", "code": "theorem Balanced.smul (a : \ud835\udd5d) (hs : Balanced \ud835\udd5c s) : Balanced \ud835\udd5c (a \u2022 s)", "start": [206, 1], "end": [207, 61], "kind": "commanddeclaration"}, {"full_name": "Absorbs.neg", "code": "theorem Absorbs.neg : Absorbs \ud835\udd5c s t \u2192 Absorbs \ud835\udd5c (-s) (-t)", "start": [216, 1], "end": [218, 101], "kind": "commanddeclaration"}, {"full_name": "Balanced.neg", "code": "theorem Balanced.neg : Balanced \ud835\udd5c s \u2192 Balanced \ud835\udd5c (-s)", "start": [221, 1], "end": [222, 81], "kind": "commanddeclaration"}, {"full_name": "Absorbs.add", "code": "theorem Absorbs.add : Absorbs \ud835\udd5c s\u2081 t\u2081 \u2192 Absorbs \ud835\udd5c s\u2082 t\u2082 \u2192 Absorbs \ud835\udd5c (s\u2081 + s\u2082) (t\u2081 + t\u2082)", "start": [225, 1], "end": [229, 33], "kind": "commanddeclaration"}, {"full_name": "Balanced.add", "code": "theorem Balanced.add (hs : Balanced \ud835\udd5c s) (ht : Balanced \ud835\udd5c t) : Balanced \ud835\udd5c (s + t)", "start": [232, 1], "end": [233, 71], "kind": "commanddeclaration"}, {"full_name": "Absorbs.sub", "code": "theorem Absorbs.sub (h\u2081 : Absorbs \ud835\udd5c s\u2081 t\u2081) (h\u2082 : Absorbs \ud835\udd5c s\u2082 t\u2082) :\n    Absorbs \ud835\udd5c (s\u2081 - s\u2082) (t\u2081 - t\u2082)", "start": [236, 1], "end": [239, 22], "kind": "commanddeclaration"}, {"full_name": "Balanced.sub", "code": "theorem Balanced.sub (hs : Balanced \ud835\udd5c s) (ht : Balanced \ud835\udd5c t) : Balanced \ud835\udd5c (s - t)", "start": [242, 1], "end": [244, 22], "kind": "commanddeclaration"}, {"full_name": "balanced_zero", "code": "theorem balanced_zero : Balanced \ud835\udd5c (0 : Set E)", "start": [247, 1], "end": [247, 85], "kind": "commanddeclaration"}, {"full_name": "Balanced.smul_mono", "code": "theorem Balanced.smul_mono (hs : Balanced \ud835\udd5d s) {a : \ud835\udd5d} {b : \ud835\udd5c} (h : \u2016a\u2016 \u2264 \u2016b\u2016) : a \u2022 s \u2286 b \u2022 s", "start": [259, 1], "end": [272, 43], "kind": "commanddeclaration"}, {"full_name": "Balanced.absorbs_self", "code": "theorem Balanced.absorbs_self (hA : Balanced \ud835\udd5c A) : Absorbs \ud835\udd5c A A", "start": [275, 1], "end": [281, 22], "kind": "commanddeclaration"}, {"full_name": "Balanced.subset_smul", "code": "theorem Balanced.subset_smul (hA : Balanced \ud835\udd5c A) (ha : 1 \u2264 \u2016a\u2016) : A \u2286 a \u2022 A", "start": [284, 1], "end": [290, 24], "kind": "commanddeclaration"}, {"full_name": "Balanced.smul_eq", "code": "theorem Balanced.smul_eq (hA : Balanced \ud835\udd5c A) (ha : \u2016a\u2016 = 1) : a \u2022 A = A", "start": [293, 1], "end": [294, 48], "kind": "commanddeclaration"}, {"full_name": "Balanced.mem_smul_iff", "code": "theorem Balanced.mem_smul_iff (hs : Balanced \ud835\udd5c s) (h : \u2016a\u2016 = \u2016b\u2016) : a \u2022 x \u2208 s \u2194 b \u2022 x \u2208 s", "start": [297, 1], "end": [306, 21], "kind": "commanddeclaration"}, {"full_name": "Balanced.neg_mem_iff", "code": "theorem Balanced.neg_mem_iff (hs : Balanced \ud835\udd5c s) : -x \u2208 s \u2194 x \u2208 s", "start": [309, 1], "end": [311, 37], "kind": "commanddeclaration"}, {"full_name": "Absorbs.inter", "code": "theorem Absorbs.inter (hs : Absorbs \ud835\udd5c s u) (ht : Absorbs \ud835\udd5c t u) : Absorbs \ud835\udd5c (s \u2229 t) u", "start": [314, 1], "end": [320, 84], "kind": "commanddeclaration"}, {"full_name": "absorbs_inter", "code": "@[simp]\ntheorem absorbs_inter : Absorbs \ud835\udd5c (s \u2229 t) u \u2194 Absorbs \ud835\udd5c s u \u2227 Absorbs \ud835\udd5c t u", "start": [323, 1], "end": [326, 19], "kind": "commanddeclaration"}, {"full_name": "absorbent_univ", "code": "theorem absorbent_univ : Absorbent \ud835\udd5c (univ : Set E)", "start": [329, 1], "end": [332, 16], "kind": "commanddeclaration"}, {"full_name": "absorbent_nhds_zero", "code": "theorem absorbent_nhds_zero (hA : A \u2208 \ud835\udcdd (0 : E)) : Absorbent \ud835\udd5c A", "start": [337, 1], "end": [351, 30], "kind": "commanddeclaration"}, {"full_name": "balanced_zero_union_interior", "code": "theorem balanced_zero_union_interior (hA : Balanced \ud835\udd5c A) :\n    Balanced \ud835\udd5c ((0 : Set E) \u222a interior A)", "start": [354, 1], "end": [367, 50], "kind": "commanddeclaration"}, {"full_name": "Balanced.interior", "code": "theorem Balanced.interior (hA : Balanced \ud835\udd5c A) (h : (0 : E) \u2208 interior A) :\n    Balanced \ud835\udd5c (interior A)", "start": [370, 1], "end": [374, 40], "kind": "commanddeclaration"}, {"full_name": "Balanced.closure", "code": "theorem Balanced.closure (hA : Balanced \ud835\udd5c A) : Balanced \ud835\udd5c (closure A)", "start": [377, 1], "end": [379, 28], "kind": "commanddeclaration"}, {"full_name": "absorbs_zero_iff", "code": "theorem absorbs_zero_iff : Absorbs \ud835\udd5c s 0 \u2194 (0 : E) \u2208 s", "start": [388, 1], "end": [394, 45], "kind": "commanddeclaration"}, {"full_name": "Absorbent.zero_mem", "code": "theorem Absorbent.zero_mem (hs : Absorbent \ud835\udd5c s) : (0 : E) \u2208 s", "start": [397, 1], "end": [398, 70], "kind": "commanddeclaration"}, {"full_name": "balanced_convexHull_of_balanced", "code": "theorem balanced_convexHull_of_balanced (hs : Balanced \ud835\udd5c s) : Balanced \ud835\udd5c (convexHull \u211d s)", "start": [403, 1], "end": [410, 60], "kind": "commanddeclaration"}, {"full_name": "balanced_iff_neg_mem", "code": "theorem balanced_iff_neg_mem (hs : Convex \u211d s) : Balanced \u211d s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 -x \u2208 s", "start": [419, 1], "end": [425, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Function.lean", "imports": ["Mathlib/Tactic/GCongr.lean", "Mathlib/Analysis/Convex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexOn", "code": "def ConvexOn : Prop :=\n  Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192\n    f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y", "start": [51, 1], "end": [54, 42], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn", "code": "def ConcaveOn : Prop :=\n  Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192\n    a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)", "start": [57, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn", "code": "def StrictConvexOn : Prop :=\n  Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n    f (a \u2022 x + b \u2022 y) < a \u2022 f x + b \u2022 f y", "start": [63, 1], "end": [66, 42], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn", "code": "def StrictConcaveOn : Prop :=\n  Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n    a \u2022 f x + b \u2022 f y < f (a \u2022 x + b \u2022 y)", "start": [69, 1], "end": [72, 42], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.dual", "code": "theorem ConvexOn.dual (hf : ConvexOn \ud835\udd5c s f) : ConcaveOn \ud835\udd5c s (toDual \u2218 f)", "start": [79, 1], "end": [79, 79], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.dual", "code": "theorem ConcaveOn.dual (hf : ConcaveOn \ud835\udd5c s f) : ConvexOn \ud835\udd5c s (toDual \u2218 f)", "start": [82, 1], "end": [82, 80], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.dual", "code": "theorem StrictConvexOn.dual (hf : StrictConvexOn \ud835\udd5c s f) : StrictConcaveOn \ud835\udd5c s (toDual \u2218 f)", "start": [85, 1], "end": [85, 97], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.dual", "code": "theorem StrictConcaveOn.dual (hf : StrictConcaveOn \ud835\udd5c s f) : StrictConvexOn \ud835\udd5c s (toDual \u2218 f)", "start": [88, 1], "end": [88, 98], "kind": "commanddeclaration"}, {"full_name": "convexOn_id", "code": "theorem convexOn_id {s : Set \u03b2} (hs : Convex \ud835\udd5c s) : ConvexOn \ud835\udd5c s _root_.id", "start": [91, 1], "end": [94, 9], "kind": "commanddeclaration"}, {"full_name": "concaveOn_id", "code": "theorem concaveOn_id {s : Set \u03b2} (hs : Convex \ud835\udd5c s) : ConcaveOn \ud835\udd5c s _root_.id", "start": [97, 1], "end": [100, 9], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.subset", "code": "theorem ConvexOn.subset {t : Set E} (hf : ConvexOn \ud835\udd5c t f) (hst : s \u2286 t) (hs : Convex \ud835\udd5c s) :\n    ConvexOn \ud835\udd5c s f", "start": [103, 1], "end": [105, 48], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.subset", "code": "theorem ConcaveOn.subset {t : Set E} (hf : ConcaveOn \ud835\udd5c t f) (hst : s \u2286 t) (hs : Convex \ud835\udd5c s) :\n    ConcaveOn \ud835\udd5c s f", "start": [108, 1], "end": [110, 48], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.subset", "code": "theorem StrictConvexOn.subset {t : Set E} (hf : StrictConvexOn \ud835\udd5c t f) (hst : s \u2286 t)\n    (hs : Convex \ud835\udd5c s) : StrictConvexOn \ud835\udd5c s f", "start": [113, 1], "end": [115, 48], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.subset", "code": "theorem StrictConcaveOn.subset {t : Set E} (hf : StrictConcaveOn \ud835\udd5c t f) (hst : s \u2286 t)\n    (hs : Convex \ud835\udd5c s) : StrictConcaveOn \ud835\udd5c s f", "start": [118, 1], "end": [120, 48], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.comp", "code": "theorem ConvexOn.comp (hg : ConvexOn \ud835\udd5c (f '' s) g) (hf : ConvexOn \ud835\udd5c s f)\n    (hg' : MonotoneOn g (f '' s)) : ConvexOn \ud835\udd5c s (g \u2218 f)", "start": [123, 1], "end": [129, 70], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.comp", "code": "theorem ConcaveOn.comp (hg : ConcaveOn \ud835\udd5c (f '' s) g) (hf : ConcaveOn \ud835\udd5c s f)\n    (hg' : MonotoneOn g (f '' s)) : ConcaveOn \ud835\udd5c s (g \u2218 f)", "start": [132, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.comp_concaveOn", "code": "theorem ConvexOn.comp_concaveOn (hg : ConvexOn \ud835\udd5c (f '' s) g) (hf : ConcaveOn \ud835\udd5c s f)\n    (hg' : AntitoneOn g (f '' s)) : ConvexOn \ud835\udd5c s (g \u2218 f)", "start": [141, 1], "end": [143, 22], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.comp_convexOn", "code": "theorem ConcaveOn.comp_convexOn (hg : ConcaveOn \ud835\udd5c (f '' s) g) (hf : ConvexOn \ud835\udd5c s f)\n    (hg' : AntitoneOn g (f '' s)) : ConcaveOn \ud835\udd5c s (g \u2218 f)", "start": [146, 1], "end": [148, 22], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.comp", "code": "theorem StrictConvexOn.comp (hg : StrictConvexOn \ud835\udd5c (f '' s) g) (hf : StrictConvexOn \ud835\udd5c s f)\n    (hg' : StrictMonoOn g (f '' s)) (hf' : s.InjOn f) : StrictConvexOn \ud835\udd5c s (g \u2218 f)", "start": [151, 1], "end": [157, 91], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.comp", "code": "theorem StrictConcaveOn.comp (hg : StrictConcaveOn \ud835\udd5c (f '' s) g) (hf : StrictConcaveOn \ud835\udd5c s f)\n    (hg' : StrictMonoOn g (f '' s)) (hf' : s.InjOn f) : StrictConcaveOn \ud835\udd5c s (g \u2218 f)", "start": [160, 1], "end": [166, 34], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.comp_strictConcaveOn", "code": "theorem StrictConvexOn.comp_strictConcaveOn (hg : StrictConvexOn \ud835\udd5c (f '' s) g)\n    (hf : StrictConcaveOn \ud835\udd5c s f) (hg' : StrictAntiOn g (f '' s)) (hf' : s.InjOn f) :\n    StrictConvexOn \ud835\udd5c s (g \u2218 f)", "start": [169, 1], "end": [172, 26], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.comp_strictConvexOn", "code": "theorem StrictConcaveOn.comp_strictConvexOn (hg : StrictConcaveOn \ud835\udd5c (f '' s) g)\n    (hf : StrictConvexOn \ud835\udd5c s f) (hg' : StrictAntiOn g (f '' s)) (hf' : s.InjOn f) :\n    StrictConcaveOn \ud835\udd5c s (g \u2218 f)", "start": [175, 1], "end": [178, 26], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.add", "code": "theorem ConvexOn.add (hf : ConvexOn \ud835\udd5c s f) (hg : ConvexOn \ud835\udd5c s g) : ConvexOn \ud835\udd5c s (f + g)", "start": [187, 1], "end": [193, 8], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.add", "code": "theorem ConcaveOn.add (hf : ConcaveOn \ud835\udd5c s f) (hg : ConcaveOn \ud835\udd5c s g) : ConcaveOn \ud835\udd5c s (f + g)", "start": [196, 1], "end": [197, 17], "kind": "commanddeclaration"}, {"full_name": "convexOn_const", "code": "theorem convexOn_const (c : \u03b2) (hs : Convex \ud835\udd5c s) : ConvexOn \ud835\udd5c s fun _ : E => c", "start": [206, 1], "end": [207, 64], "kind": "commanddeclaration"}, {"full_name": "concaveOn_const", "code": "theorem concaveOn_const (c : \u03b2) (hs : Convex \ud835\udd5c s) : ConcaveOn \ud835\udd5c s fun _ => c", "start": [210, 1], "end": [211, 43], "kind": "commanddeclaration"}, {"full_name": "convexOn_of_convex_epigraph", "code": "theorem convexOn_of_convex_epigraph (h : Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 \u2264 p.2 }) :\n    ConvexOn \ud835\udd5c s f", "start": [214, 1], "end": [217, 101], "kind": "commanddeclaration"}, {"full_name": "concaveOn_of_convex_hypograph", "code": "theorem concaveOn_of_convex_hypograph (h : Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 p.2 \u2264 f p.1 }) :\n    ConcaveOn \ud835\udd5c s f", "start": [220, 1], "end": [222, 55], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.convex_le", "code": "theorem ConvexOn.convex_le (hf : ConvexOn \ud835\udd5c s f) (r : \u03b2) : Convex \ud835\udd5c ({ x \u2208 s | f x \u2264 r })", "start": [231, 1], "end": [238, 8], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.convex_ge", "code": "theorem ConcaveOn.convex_ge (hf : ConcaveOn \ud835\udd5c s f) (r : \u03b2) : Convex \ud835\udd5c ({ x \u2208 s | r \u2264 f x })", "start": [241, 1], "end": [242, 22], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.convex_epigraph", "code": "theorem ConvexOn.convex_epigraph (hf : ConvexOn \ud835\udd5c s f) :\n    Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 \u2264 p.2 }", "start": [245, 1], "end": [251, 35], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.convex_hypograph", "code": "theorem ConcaveOn.convex_hypograph (hf : ConcaveOn \ud835\udd5c s f) :\n    Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 p.2 \u2264 f p.1 }", "start": [254, 1], "end": [256, 26], "kind": "commanddeclaration"}, {"full_name": "convexOn_iff_convex_epigraph", "code": "theorem convexOn_iff_convex_epigraph :\n    ConvexOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 \u2264 p.2 }", "start": [259, 1], "end": [261, 58], "kind": "commanddeclaration"}, {"full_name": "concaveOn_iff_convex_hypograph", "code": "theorem concaveOn_iff_convex_hypograph :\n    ConcaveOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 p.2 \u2264 f p.1 }", "start": [264, 1], "end": [266, 56], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.translate_right", "code": "theorem ConvexOn.translate_right (hf : ConvexOn \ud835\udd5c s f) (c : E) :\n    ConvexOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => c + z)", "start": [275, 1], "end": [283, 8], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.translate_right", "code": "theorem ConcaveOn.translate_right (hf : ConcaveOn \ud835\udd5c s f) (c : E) :\n    ConcaveOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => c + z)", "start": [286, 1], "end": [289, 28], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.translate_left", "code": "theorem ConvexOn.translate_left (hf : ConvexOn \ud835\udd5c s f) (c : E) :\n    ConvexOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => z + c)", "start": [292, 1], "end": [295, 53], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.translate_left", "code": "theorem ConcaveOn.translate_left (hf : ConcaveOn \ud835\udd5c s f) (c : E) :\n    ConcaveOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => z + c)", "start": [298, 1], "end": [301, 27], "kind": "commanddeclaration"}, {"full_name": "convexOn_iff_forall_pos", "code": "theorem convexOn_iff_forall_pos {s : Set E} {f : E \u2192 \u03b2} :\n    ConvexOn \ud835\udd5c s f \u2194 Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192\n      a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y", "start": [310, 1], "end": [324, 28], "kind": "commanddeclaration"}, {"full_name": "concaveOn_iff_forall_pos", "code": "theorem concaveOn_iff_forall_pos {s : Set E} {f : E \u2192 \u03b2} :\n    ConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n        a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)", "start": [327, 1], "end": [331, 49], "kind": "commanddeclaration"}, {"full_name": "convexOn_iff_pairwise_pos", "code": "theorem convexOn_iff_pairwise_pos {s : Set E} {f : E \u2192 \u03b2} :\n    ConvexOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227\n        s.Pairwise fun x y =>\n          \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y", "start": [334, 1], "end": [345, 30], "kind": "commanddeclaration"}, {"full_name": "concaveOn_iff_pairwise_pos", "code": "theorem concaveOn_iff_pairwise_pos {s : Set E} {f : E \u2192 \u03b2} :\n    ConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227\n        s.Pairwise fun x y =>\n          \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)", "start": [348, 1], "end": [353, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.convexOn", "code": "theorem LinearMap.convexOn (f : E \u2192\u2097[\ud835\udd5c] \u03b2) {s : Set E} (hs : Convex \ud835\udd5c s) : ConvexOn \ud835\udd5c s f", "start": [356, 1], "end": [358, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.concaveOn", "code": "theorem LinearMap.concaveOn (f : E \u2192\u2097[\ud835\udd5c] \u03b2) {s : Set E} (hs : Convex \ud835\udd5c s) : ConcaveOn \ud835\udd5c s f", "start": [361, 1], "end": [363, 75], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.convexOn", "code": "theorem StrictConvexOn.convexOn {s : Set E} {f : E \u2192 \u03b2} (hf : StrictConvexOn \ud835\udd5c s f) :\n    ConvexOn \ud835\udd5c s f", "start": [366, 1], "end": [369, 77], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.concaveOn", "code": "theorem StrictConcaveOn.concaveOn {s : Set E} {f : E \u2192 \u03b2} (hf : StrictConcaveOn \ud835\udd5c s f) :\n    ConcaveOn \ud835\udd5c s f", "start": [372, 1], "end": [374, 19], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.convex_lt", "code": "theorem StrictConvexOn.convex_lt (hf : StrictConvexOn \ud835\udd5c s f) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | f x < r })", "start": [381, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.convex_gt", "code": "theorem StrictConcaveOn.convex_gt (hf : StrictConcaveOn \ud835\udd5c s f) (r : \u03b2) :\n    Convex \ud835\udd5c ({ x \u2208 s | r < f x })", "start": [392, 1], "end": [394, 22], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.convexOn_of_lt", "code": "theorem LinearOrder.convexOn_of_lt (hs : Convex \ud835\udd5c s)\n    (hf : \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n      f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y) :\n    ConvexOn \ud835\udd5c s f", "start": [403, 1], "end": [420, 29], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.concaveOn_of_lt", "code": "theorem LinearOrder.concaveOn_of_lt (hs : Convex \ud835\udd5c s)\n    (hf : \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n      a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)) :\n    ConcaveOn \ud835\udd5c s f", "start": [423, 1], "end": [431, 60], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.strictConvexOn_of_lt", "code": "theorem LinearOrder.strictConvexOn_of_lt (hs : Convex \ud835\udd5c s)\n    (hf : \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n      f (a \u2022 x + b \u2022 y) < a \u2022 f x + b \u2022 f y) :\n    StrictConvexOn \ud835\udd5c s f", "start": [434, 1], "end": [450, 29], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.strictConcaveOn_of_lt", "code": "theorem LinearOrder.strictConcaveOn_of_lt (hs : Convex \ud835\udd5c s)\n    (hf : \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x < y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192\n      a \u2022 f x + b \u2022 f y < f (a \u2022 x + b \u2022 y)) :\n    StrictConcaveOn \ud835\udd5c s f", "start": [453, 1], "end": [461, 66], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.comp_linearMap", "code": "theorem ConvexOn.comp_linearMap {f : F \u2192 \u03b2} {s : Set F} (hf : ConvexOn \ud835\udd5c s f) (g : E \u2192\u2097[\ud835\udd5c] F) :\n    ConvexOn \ud835\udd5c (g \u207b\u00b9' s) (f \u2218 g)", "start": [472, 1], "end": [478, 61], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.comp_linearMap", "code": "theorem ConcaveOn.comp_linearMap {f : F \u2192 \u03b2} {s : Set F} (hf : ConcaveOn \ud835\udd5c s f) (g : E \u2192\u2097[\ud835\udd5c] F) :\n    ConcaveOn \ud835\udd5c (g \u207b\u00b9' s) (f \u2218 g)", "start": [481, 1], "end": [484, 27], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.add_convexOn", "code": "theorem StrictConvexOn.add_convexOn (hf : StrictConvexOn \ud835\udd5c s f) (hg : ConvexOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f + g)", "start": [499, 1], "end": [505, 93], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.add_strictConvexOn", "code": "theorem ConvexOn.add_strictConvexOn (hf : ConvexOn \ud835\udd5c s f) (hg : StrictConvexOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f + g)", "start": [508, 1], "end": [510, 36], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.add", "code": "theorem StrictConvexOn.add (hf : StrictConvexOn \ud835\udd5c s f) (hg : StrictConvexOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f + g)", "start": [513, 1], "end": [519, 93], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.add_concaveOn", "code": "theorem StrictConcaveOn.add_concaveOn (hf : StrictConcaveOn \ud835\udd5c s f) (hg : ConcaveOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f + g)", "start": [522, 1], "end": [524, 31], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.add_strictConcaveOn", "code": "theorem ConcaveOn.add_strictConcaveOn (hf : ConcaveOn \ud835\udd5c s f) (hg : StrictConcaveOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f + g)", "start": [527, 1], "end": [529, 37], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.add", "code": "theorem StrictConcaveOn.add (hf : StrictConcaveOn \ud835\udd5c s f) (hg : StrictConcaveOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f + g)", "start": [532, 1], "end": [534, 17], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.convex_lt", "code": "theorem ConvexOn.convex_lt (hf : ConvexOn \ud835\udd5c s f) (r : \u03b2) : Convex \ud835\udd5c ({ x \u2208 s | f x < r })", "start": [543, 1], "end": [551, 42], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.convex_gt", "code": "theorem ConcaveOn.convex_gt (hf : ConcaveOn \ud835\udd5c s f) (r : \u03b2) : Convex \ud835\udd5c ({ x \u2208 s | r < f x })", "start": [554, 1], "end": [555, 22], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.openSegment_subset_strict_epigraph", "code": "theorem ConvexOn.openSegment_subset_strict_epigraph (hf : ConvexOn \ud835\udd5c s f) (p q : E \u00d7 \u03b2)\n    (hp : p.1 \u2208 s \u2227 f p.1 < p.2) (hq : q.1 \u2208 s \u2227 f q.1 \u2264 q.2) :\n    openSegment \ud835\udd5c p q \u2286 { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 < p.2 }", "start": [558, 1], "end": [566, 95], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.openSegment_subset_strict_hypograph", "code": "theorem ConcaveOn.openSegment_subset_strict_hypograph (hf : ConcaveOn \ud835\udd5c s f) (p q : E \u00d7 \u03b2)\n    (hp : p.1 \u2208 s \u2227 p.2 < f p.1) (hq : q.1 \u2208 s \u2227 q.2 \u2264 f q.1) :\n    openSegment \ud835\udd5c p q \u2286 { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 p.2 < f p.1 }", "start": [569, 1], "end": [572, 55], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.convex_strict_epigraph", "code": "theorem ConvexOn.convex_strict_epigraph (hf : ConvexOn \ud835\udd5c s f) :\n    Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 < p.2 }", "start": [575, 1], "end": [578, 65], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.convex_strict_hypograph", "code": "theorem ConcaveOn.convex_strict_hypograph (hf : ConcaveOn \ud835\udd5c s f) :\n    Convex \ud835\udd5c { p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 p.2 < f p.1 }", "start": [581, 1], "end": [583, 33], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.sup", "code": "theorem ConvexOn.sup (hf : ConvexOn \ud835\udd5c s f) (hg : ConvexOn \ud835\udd5c s g) : ConvexOn \ud835\udd5c s (f \u2294 g)", "start": [595, 1], "end": [603, 80], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.inf", "code": "theorem ConcaveOn.inf (hf : ConcaveOn \ud835\udd5c s f) (hg : ConcaveOn \ud835\udd5c s g) : ConcaveOn \ud835\udd5c s (f \u2293 g)", "start": [606, 1], "end": [608, 17], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.sup", "code": "theorem StrictConvexOn.sup (hf : StrictConvexOn \ud835\udd5c s f) (hg : StrictConvexOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f \u2294 g)", "start": [611, 1], "end": [621, 84], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.inf", "code": "theorem StrictConcaveOn.inf (hf : StrictConcaveOn \ud835\udd5c s f) (hg : StrictConcaveOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f \u2293 g)", "start": [624, 1], "end": [627, 17], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_on_segment'", "code": "theorem ConvexOn.le_on_segment' (hf : ConvexOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s) {a b : \ud835\udd5c}\n    (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) : f (a \u2022 x + b \u2022 y) \u2264 max (f x) (f y)", "start": [630, 1], "end": [639, 51], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.ge_on_segment'", "code": "theorem ConcaveOn.ge_on_segment' (hf : ConcaveOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) : min (f x) (f y) \u2264 f (a \u2022 x + b \u2022 y)", "start": [642, 1], "end": [645, 41], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_on_segment", "code": "theorem ConvexOn.le_on_segment (hf : ConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 [x -[\ud835\udd5c] y]) : f z \u2264 max (f x) (f y)", "start": [648, 1], "end": [652, 41], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.ge_on_segment", "code": "theorem ConcaveOn.ge_on_segment (hf : ConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 [x -[\ud835\udd5c] y]) : min (f x) (f y) \u2264 f z", "start": [655, 1], "end": [658, 33], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.lt_on_open_segment'", "code": "theorem StrictConvexOn.lt_on_open_segment' (hf : StrictConvexOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 s) (hxy : x \u2260 y) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    f (a \u2022 x + b \u2022 y) < max (f x) (f y)", "start": [661, 1], "end": [672, 51], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.lt_on_open_segment'", "code": "theorem StrictConcaveOn.lt_on_open_segment' (hf : StrictConcaveOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s)\n    (hy : y \u2208 s) (hxy : x \u2260 y) {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    min (f x) (f y) < f (a \u2022 x + b \u2022 y)", "start": [675, 1], "end": [680, 50], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.lt_on_openSegment", "code": "theorem StrictConvexOn.lt_on_openSegment (hf : StrictConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s)\n    (hy : y \u2208 s) (hxy : x \u2260 y) (hz : z \u2208 openSegment \ud835\udd5c x y) : f z < max (f x) (f y)", "start": [683, 1], "end": [688, 50], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.lt_on_openSegment", "code": "theorem StrictConcaveOn.lt_on_openSegment (hf : StrictConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s)\n    (hy : y \u2208 s) (hxy : x \u2260 y) (hz : z \u2208 openSegment \ud835\udd5c x y) : min (f x) (f y) < f z", "start": [691, 1], "end": [695, 41], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_left_of_right_le'", "code": "theorem ConvexOn.le_left_of_right_le' (hf : ConvexOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) (hfy : f y \u2264 f (a \u2022 x + b \u2022 y)) :\n    f (a \u2022 x + b \u2022 y) \u2264 f x", "start": [708, 1], "end": [717, 57], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.left_le_of_le_right'", "code": "theorem ConcaveOn.left_le_of_le_right' (hf : ConcaveOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 \u2264 b) (hab : a + b = 1) (hfy : f (a \u2022 x + b \u2022 y) \u2264 f y) :\n    f x \u2264 f (a \u2022 x + b \u2022 y)", "start": [720, 1], "end": [723, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_right_of_left_le'", "code": "theorem ConvexOn.le_right_of_left_le' (hf : ConvexOn \ud835\udd5c s f) {x y : E} {a b : \ud835\udd5c} (hx : x \u2208 s)\n    (hy : y \u2208 s) (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) (hfx : f x \u2264 f (a \u2022 x + b \u2022 y)) :\n    f (a \u2022 x + b \u2022 y) \u2264 f y", "start": [726, 1], "end": [730, 52], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.right_le_of_le_left'", "code": "theorem ConcaveOn.right_le_of_le_left' (hf : ConcaveOn \ud835\udd5c s f) {x y : E} {a b : \ud835\udd5c} (hx : x \u2208 s)\n    (hy : y \u2208 s) (ha : 0 \u2264 a) (hb : 0 < b) (hab : a + b = 1) (hfx : f (a \u2022 x + b \u2022 y) \u2264 f x) :\n    f y \u2264 f (a \u2022 x + b \u2022 y)", "start": [733, 1], "end": [736, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_left_of_right_le", "code": "theorem ConvexOn.le_left_of_right_le (hf : ConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hyz : f y \u2264 f z) : f z \u2264 f x", "start": [739, 1], "end": [742, 55], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.left_le_of_le_right", "code": "theorem ConcaveOn.left_le_of_le_right (hf : ConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hyz : f z \u2264 f y) : f x \u2264 f z", "start": [745, 1], "end": [747, 43], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_right_of_left_le", "code": "theorem ConvexOn.le_right_of_left_le (hf : ConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hxz : f x \u2264 f z) : f z \u2264 f y", "start": [750, 1], "end": [753, 55], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.right_le_of_le_left", "code": "theorem ConcaveOn.right_le_of_le_left (hf : ConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hxz : f z \u2264 f x) : f y \u2264 f z", "start": [756, 1], "end": [758, 43], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.lt_left_of_right_lt'", "code": "theorem ConvexOn.lt_left_of_right_lt' (hf : ConvexOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (hfy : f y < f (a \u2022 x + b \u2022 y)) :\n    f (a \u2022 x + b \u2022 y) < f x", "start": [769, 1], "end": [778, 57], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.left_lt_of_lt_right'", "code": "theorem ConcaveOn.left_lt_of_lt_right' (hf : ConcaveOn \ud835\udd5c s f) {x y : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    {a b : \ud835\udd5c} (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (hfy : f (a \u2022 x + b \u2022 y) < f y) :\n    f x < f (a \u2022 x + b \u2022 y)", "start": [781, 1], "end": [784, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.lt_right_of_left_lt'", "code": "theorem ConvexOn.lt_right_of_left_lt' (hf : ConvexOn \ud835\udd5c s f) {x y : E} {a b : \ud835\udd5c} (hx : x \u2208 s)\n    (hy : y \u2208 s) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (hfx : f x < f (a \u2022 x + b \u2022 y)) :\n    f (a \u2022 x + b \u2022 y) < f y", "start": [787, 1], "end": [791, 52], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.lt_right_of_left_lt'", "code": "theorem ConcaveOn.lt_right_of_left_lt' (hf : ConcaveOn \ud835\udd5c s f) {x y : E} {a b : \ud835\udd5c} (hx : x \u2208 s)\n    (hy : y \u2208 s) (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) (hfx : f (a \u2022 x + b \u2022 y) < f x) :\n    f y < f (a \u2022 x + b \u2022 y)", "start": [794, 1], "end": [797, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.lt_left_of_right_lt", "code": "theorem ConvexOn.lt_left_of_right_lt (hf : ConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hyz : f y < f z) : f z < f x", "start": [800, 1], "end": [803, 52], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.left_lt_of_lt_right", "code": "theorem ConcaveOn.left_lt_of_lt_right (hf : ConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hyz : f z < f y) : f x < f z", "start": [806, 1], "end": [808, 43], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.lt_right_of_left_lt", "code": "theorem ConvexOn.lt_right_of_left_lt (hf : ConvexOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hxz : f x < f z) : f z < f y", "start": [811, 1], "end": [814, 52], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.lt_right_of_left_lt", "code": "theorem ConcaveOn.lt_right_of_left_lt (hf : ConcaveOn \ud835\udd5c s f) {x y z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 openSegment \ud835\udd5c x y) (hxz : f z < f x) : f y < f z", "start": [817, 1], "end": [819, 43], "kind": "commanddeclaration"}, {"full_name": "neg_convexOn_iff", "code": "@[simp]\ntheorem neg_convexOn_iff : ConvexOn \ud835\udd5c s (-f) \u2194 ConcaveOn \ud835\udd5c s f", "start": [830, 1], "end": [842, 28], "kind": "commanddeclaration"}, {"full_name": "neg_concaveOn_iff", "code": "@[simp]\ntheorem neg_concaveOn_iff : ConcaveOn \ud835\udd5c s (-f) \u2194 ConvexOn \ud835\udd5c s f", "start": [845, 1], "end": [848, 37], "kind": "commanddeclaration"}, {"full_name": "neg_strictConvexOn_iff", "code": "@[simp]\ntheorem neg_strictConvexOn_iff : StrictConvexOn \ud835\udd5c s (-f) \u2194 StrictConcaveOn \ud835\udd5c s f", "start": [851, 1], "end": [863, 32], "kind": "commanddeclaration"}, {"full_name": "neg_strictConcaveOn_iff", "code": "@[simp]\ntheorem neg_strictConcaveOn_iff : StrictConcaveOn \ud835\udd5c s (-f) \u2194 StrictConvexOn \ud835\udd5c s f", "start": [866, 1], "end": [869, 43], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.neg", "code": "alias \u27e8_, ConcaveOn.neg\u27e9 := neg_convexOn_iff", "start": [872, 1], "end": [872, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ConvexOn.neg", "code": "alias \u27e8_, ConvexOn.neg\u27e9 := neg_concaveOn_iff", "start": [875, 1], "end": [875, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictConcaveOn.neg", "code": "alias \u27e8_, StrictConcaveOn.neg\u27e9 := neg_strictConvexOn_iff", "start": [878, 1], "end": [878, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictConvexOn.neg", "code": "alias \u27e8_, StrictConvexOn.neg\u27e9 := neg_strictConcaveOn_iff", "start": [881, 1], "end": [881, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ConvexOn.sub", "code": "theorem ConvexOn.sub (hf : ConvexOn \ud835\udd5c s f) (hg : ConcaveOn \ud835\udd5c s g) : ConvexOn \ud835\udd5c s (f - g)", "start": [884, 1], "end": [885, 44], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.sub", "code": "theorem ConcaveOn.sub (hf : ConcaveOn \ud835\udd5c s f) (hg : ConvexOn \ud835\udd5c s g) : ConcaveOn \ud835\udd5c s (f - g)", "start": [888, 1], "end": [889, 44], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.sub", "code": "theorem StrictConvexOn.sub (hf : StrictConvexOn \ud835\udd5c s f) (hg : StrictConcaveOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f - g)", "start": [892, 1], "end": [894, 44], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.sub", "code": "theorem StrictConcaveOn.sub (hf : StrictConcaveOn \ud835\udd5c s f) (hg : StrictConvexOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f - g)", "start": [897, 1], "end": [899, 44], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.sub_strictConcaveOn", "code": "theorem ConvexOn.sub_strictConcaveOn (hf : ConvexOn \ud835\udd5c s f) (hg : StrictConcaveOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f - g)", "start": [902, 1], "end": [904, 59], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.sub_strictConvexOn", "code": "theorem ConcaveOn.sub_strictConvexOn (hf : ConcaveOn \ud835\udd5c s f) (hg : StrictConvexOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f - g)", "start": [907, 1], "end": [909, 60], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.sub_concaveOn", "code": "theorem StrictConvexOn.sub_concaveOn (hf : StrictConvexOn \ud835\udd5c s f) (hg : ConcaveOn \ud835\udd5c s g) :\n    StrictConvexOn \ud835\udd5c s (f - g)", "start": [912, 1], "end": [914, 53], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.sub_convexOn", "code": "theorem StrictConcaveOn.sub_convexOn (hf : StrictConcaveOn \ud835\udd5c s f) (hg : ConvexOn \ud835\udd5c s g) :\n    StrictConcaveOn \ud835\udd5c s (f - g)", "start": [917, 1], "end": [919, 54], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.translate_right", "code": "theorem StrictConvexOn.translate_right (hf : StrictConvexOn \ud835\udd5c s f) (c : E) :\n    StrictConvexOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => c + z)", "start": [931, 1], "end": [938, 98], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.translate_right", "code": "theorem StrictConcaveOn.translate_right (hf : StrictConcaveOn \ud835\udd5c s f) (c : E) :\n    StrictConcaveOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => c + z)", "start": [941, 1], "end": [944, 28], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.translate_left", "code": "theorem StrictConvexOn.translate_left (hf : StrictConvexOn \ud835\udd5c s f) (c : E) :\n    StrictConvexOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => z + c)", "start": [947, 1], "end": [950, 51], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.translate_left", "code": "theorem StrictConcaveOn.translate_left (hf : StrictConcaveOn \ud835\udd5c s f) (c : E) :\n    StrictConcaveOn \ud835\udd5c ((fun z => c + z) \u207b\u00b9' s) (f \u2218 fun z => z + c)", "start": [953, 1], "end": [956, 51], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.smul", "code": "theorem ConvexOn.smul {c : \ud835\udd5c} (hc : 0 \u2264 c) (hf : ConvexOn \ud835\udd5c s f) : ConvexOn \ud835\udd5c s fun x => c \u2022 f x", "start": [975, 1], "end": [980, 83], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.smul", "code": "theorem ConcaveOn.smul {c : \ud835\udd5c} (hc : 0 \u2264 c) (hf : ConcaveOn \ud835\udd5c s f) :\n    ConcaveOn \ud835\udd5c s fun x => c \u2022 f x", "start": [983, 1], "end": [985, 18], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.comp_affineMap", "code": "theorem ConvexOn.comp_affineMap {f : F \u2192 \u03b2} (g : E \u2192\u1d43[\ud835\udd5c] F) {s : Set F} (hf : ConvexOn \ud835\udd5c s f) :\n    ConvexOn \ud835\udd5c (g \u207b\u00b9' s) (f \u2218 g)", "start": [1006, 1], "end": [1013, 61], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.comp_affineMap", "code": "theorem ConcaveOn.comp_affineMap {f : F \u2192 \u03b2} (g : E \u2192\u1d43[\ud835\udd5c] F) {s : Set F} (hf : ConcaveOn \ud835\udd5c s f) :\n    ConcaveOn \ud835\udd5c (g \u207b\u00b9' s) (f \u2218 g)", "start": [1016, 1], "end": [1019, 27], "kind": "commanddeclaration"}, {"full_name": "convexOn_iff_div", "code": "theorem convexOn_iff_div {f : E \u2192 \u03b2} :\n    ConvexOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192\n        f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y) \u2264 (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y", "start": [1040, 1], "end": [1049, 50], "kind": "commanddeclaration"}, {"full_name": "concaveOn_iff_div", "code": "theorem concaveOn_iff_div {f : E \u2192 \u03b2} :\n    ConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192\n        (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y \u2264 f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y)", "start": [1052, 1], "end": [1056, 42], "kind": "commanddeclaration"}, {"full_name": "strictConvexOn_iff_div", "code": "theorem strictConvexOn_iff_div {f : E \u2192 \u03b2} :\n    StrictConvexOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192\n        f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y) < (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y", "start": [1059, 1], "end": [1069, 54], "kind": "commanddeclaration"}, {"full_name": "strictConcaveOn_iff_div", "code": "theorem strictConcaveOn_iff_div {f : E \u2192 \u03b2} :\n    StrictConcaveOn \ud835\udd5c s f \u2194\n      Convex \ud835\udd5c s \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 < a \u2192 0 < b \u2192\n        (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y < f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y)", "start": [1072, 1], "end": [1076, 48], "kind": "commanddeclaration"}, {"full_name": "OrderIso.strictConvexOn_symm", "code": "theorem OrderIso.strictConvexOn_symm (f : \u03b1 \u2243o \u03b2) (hf : StrictConcaveOn \ud835\udd5c univ f) :\n    StrictConvexOn \ud835\udd5c univ f.symm", "start": [1090, 1], "end": [1098, 72], "kind": "commanddeclaration"}, {"full_name": "OrderIso.convexOn_symm", "code": "theorem OrderIso.convexOn_symm (f : \u03b1 \u2243o \u03b2) (hf : ConcaveOn \ud835\udd5c univ f) :\n    ConvexOn \ud835\udd5c univ f.symm", "start": [1100, 1], "end": [1107, 67], "kind": "commanddeclaration"}, {"full_name": "OrderIso.strictConcaveOn_symm", "code": "theorem OrderIso.strictConcaveOn_symm (f : \u03b1 \u2243o \u03b2) (hf : StrictConvexOn \ud835\udd5c univ f) :\n    StrictConcaveOn \ud835\udd5c univ f.symm", "start": [1109, 1], "end": [1117, 72], "kind": "commanddeclaration"}, {"full_name": "OrderIso.concaveOn_symm", "code": "theorem OrderIso.concaveOn_symm (f : \u03b1 \u2243o \u03b2) (hf : ConvexOn \ud835\udd5c univ f) :\n    ConcaveOn \ud835\udd5c univ f.symm", "start": [1119, 1], "end": [1126, 67], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_right_of_left_le''", "code": "theorem ConvexOn.le_right_of_left_le'' (hf : ConvexOn \ud835\udd5c s f) (hx : x \u2208 s) (hz : z \u2208 s) (hxy : x < y)\n    (hyz : y \u2264 z) (h : f x \u2264 f y) : f y \u2264 f z", "start": [1135, 1], "end": [1138, 71], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.le_left_of_right_le''", "code": "theorem ConvexOn.le_left_of_right_le'' (hf : ConvexOn \ud835\udd5c s f) (hx : x \u2208 s) (hz : z \u2208 s) (hxy : x \u2264 y)\n    (hyz : y < z) (h : f z \u2264 f y) : f y \u2264 f x", "start": [1141, 1], "end": [1144, 71], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.right_le_of_le_left''", "code": "theorem ConcaveOn.right_le_of_le_left'' (hf : ConcaveOn \ud835\udd5c s f) (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x < y) (hyz : y \u2264 z) (h : f y \u2264 f x) : f z \u2264 f y", "start": [1147, 1], "end": [1149, 48], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.left_le_of_le_right''", "code": "theorem ConcaveOn.left_le_of_le_right'' (hf : ConcaveOn \ud835\udd5c s f) (hx : x \u2208 s) (hz : z \u2208 s)\n    (hxy : x \u2264 y) (hyz : y < z) (h : f y \u2264 f z) : f x \u2264 f y", "start": [1152, 1], "end": [1154, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean", "Mathlib/Analysis/Normed/Group/Basic.lean", "Mathlib/LinearAlgebra/AffineSpace/Midpoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NormedAddTorsor", "code": "class NormedAddTorsor (V : outParam <| Type*) (P : Type*) [outParam <| SeminormedAddCommGroup V]\n  [PseudoMetricSpace P] extends AddTorsor V P where\n  dist_eq_norm' : \u2200 x y : P, dist x y = \u2016(x -\u1d65 y : V)\u2016", "start": [27, 1], "end": [35, 55], "kind": "commanddeclaration"}, {"full_name": "NormedAddTorsor.toAddTorsor'", "code": "instance (priority := 100) NormedAddTorsor.toAddTorsor' {V P : Type*} [NormedAddCommGroup V]\n    [MetricSpace P] [NormedAddTorsor V P] : AddTorsor V P :=\n  NormedAddTorsor.toAddTorsor", "start": [38, 1], "end": [41, 30], "kind": "commanddeclaration"}, {"full_name": "NormedAddTorsor.to_isometricVAdd", "code": "instance (priority := 100) NormedAddTorsor.to_isometricVAdd : IsometricVAdd V P :=\n  \u27e8fun c => Isometry.of_dist_eq fun x y => by\n    rw [NormedAddTorsor.dist_eq_norm', NormedAddTorsor.dist_eq_norm', vadd_vsub_vadd_cancel_left]\u27e9", "start": [47, 1], "end": [50, 99], "kind": "commanddeclaration"}, {"full_name": "SeminormedAddCommGroup.toNormedAddTorsor", "code": "instance (priority := 100) SeminormedAddCommGroup.toNormedAddTorsor : NormedAddTorsor V V where\n  dist_eq_norm' := dist_eq_norm", "start": [53, 1], "end": [55, 32], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.toNormedAddTorsor", "code": "instance AffineSubspace.toNormedAddTorsor {R : Type*} [Ring R] [Module R V]\n    (s : AffineSubspace R P) [Nonempty s] : NormedAddTorsor s.direction s :=\n  { AffineSubspace.toAddTorsor s with\n    dist_eq_norm' := fun x y => NormedAddTorsor.dist_eq_norm' x.val y.val }", "start": [59, 1], "end": [63, 76], "kind": "commanddeclaration"}, {"full_name": "dist_eq_norm_vsub", "code": "theorem dist_eq_norm_vsub (x y : P) : dist x y = \u2016x -\u1d65 y\u2016", "start": [70, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "nndist_eq_nnnorm_vsub", "code": "theorem nndist_eq_nnnorm_vsub (x y : P) : nndist x y = \u2016x -\u1d65 y\u2016\u208a", "start": [77, 1], "end": [78, 39], "kind": "commanddeclaration"}, {"full_name": "dist_eq_norm_vsub'", "code": "theorem dist_eq_norm_vsub' (x y : P) : dist x y = \u2016y -\u1d65 x\u2016", "start": [82, 1], "end": [86, 50], "kind": "commanddeclaration"}, {"full_name": "nndist_eq_nnnorm_vsub'", "code": "theorem nndist_eq_nnnorm_vsub' (x y : P) : nndist x y = \u2016y -\u1d65 x\u2016\u208a", "start": [89, 1], "end": [90, 40], "kind": "commanddeclaration"}, {"full_name": "dist_vadd_cancel_left", "code": "theorem dist_vadd_cancel_left (v : V) (x y : P) : dist (v +\u1d65 x) (v +\u1d65 y) = dist x y", "start": [95, 1], "end": [96, 18], "kind": "commanddeclaration"}, {"full_name": "nndist_vadd_cancel_left", "code": "theorem nndist_vadd_cancel_left (v : V) (x y : P) : nndist (v +\u1d65 x) (v +\u1d65 y) = nndist x y", "start": [100, 1], "end": [101, 43], "kind": "commanddeclaration"}, {"full_name": "dist_vadd_cancel_right", "code": "@[simp]\ntheorem dist_vadd_cancel_right (v\u2081 v\u2082 : V) (x : P) : dist (v\u2081 +\u1d65 x) (v\u2082 +\u1d65 x) = dist v\u2081 v\u2082", "start": [103, 1], "end": [105, 70], "kind": "commanddeclaration"}, {"full_name": "nndist_vadd_cancel_right", "code": "@[simp]\ntheorem nndist_vadd_cancel_right (v\u2081 v\u2082 : V) (x : P) : nndist (v\u2081 +\u1d65 x) (v\u2082 +\u1d65 x) = nndist v\u2081 v\u2082", "start": [108, 1], "end": [110, 44], "kind": "commanddeclaration"}, {"full_name": "dist_vadd_left", "code": "@[simp]\ntheorem dist_vadd_left (v : V) (x : P) : dist (v +\u1d65 x) x = \u2016v\u2016", "start": [113, 1], "end": [116, 42], "kind": "commanddeclaration"}, {"full_name": "nndist_vadd_left", "code": "@[simp]\ntheorem nndist_vadd_left (v : V) (x : P) : nndist (v +\u1d65 x) x = \u2016v\u2016\u208a", "start": [119, 1], "end": [121, 34], "kind": "commanddeclaration"}, {"full_name": "dist_vadd_right", "code": "@[simp]\ntheorem dist_vadd_right (v : V) (x : P) : dist x (v +\u1d65 x) = \u2016v\u2016", "start": [124, 1], "end": [125, 101], "kind": "commanddeclaration"}, {"full_name": "nndist_vadd_right", "code": "@[simp]\ntheorem nndist_vadd_right (v : V) (x : P) : nndist x (v +\u1d65 x) = \u2016v\u2016\u208a", "start": [128, 1], "end": [130, 35], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.vaddConst", "code": "@[simps!]\ndef IsometryEquiv.vaddConst (x : P) : V \u2243\u1d62 P where\n  toEquiv := Equiv.vaddConst x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vadd_cancel_right _ _ _", "start": [133, 1], "end": [138, 80], "kind": "commanddeclaration"}, {"full_name": "dist_vsub_cancel_left", "code": "@[simp]\ntheorem dist_vsub_cancel_left (x y z : P) : dist (x -\u1d65 y) (x -\u1d65 z) = dist y z", "start": [141, 1], "end": [143, 79], "kind": "commanddeclaration"}, {"full_name": "nndist_vsub_cancel_left", "code": "@[simp]\ntheorem nndist_vsub_cancel_left (x y z : P) : nndist (x -\u1d65 y) (x -\u1d65 z) = nndist y z", "start": [147, 1], "end": [149, 43], "kind": "commanddeclaration"}, {"full_name": "IsometryEquiv.constVSub", "code": "@[simps!]\ndef IsometryEquiv.constVSub (x : P) : P \u2243\u1d62 V where\n  toEquiv := Equiv.constVSub x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vsub_cancel_left _ _ _", "start": [151, 1], "end": [156, 79], "kind": "commanddeclaration"}, {"full_name": "dist_vsub_cancel_right", "code": "@[simp]\ntheorem dist_vsub_cancel_right (x y z : P) : dist (x -\u1d65 z) (y -\u1d65 z) = dist x y", "start": [159, 1], "end": [161, 47], "kind": "commanddeclaration"}, {"full_name": "nndist_vsub_cancel_right", "code": "@[simp]\ntheorem nndist_vsub_cancel_right (x y z : P) : nndist (x -\u1d65 z) (y -\u1d65 z) = nndist x y", "start": [164, 1], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "dist_vadd_vadd_le", "code": "theorem dist_vadd_vadd_le (v v' : V) (p p' : P) :\n    dist (v +\u1d65 p) (v' +\u1d65 p') \u2264 dist v v' + dist p p'", "start": [169, 1], "end": [172, 85], "kind": "commanddeclaration"}, {"full_name": "nndist_vadd_vadd_le", "code": "theorem nndist_vadd_vadd_le (v v' : V) (p p' : P) :\n    nndist (v +\u1d65 p) (v' +\u1d65 p') \u2264 nndist v v' + nndist p p'", "start": [175, 1], "end": [177, 28], "kind": "commanddeclaration"}, {"full_name": "dist_vsub_vsub_le", "code": "theorem dist_vsub_vsub_le (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    dist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 dist p\u2081 p\u2083 + dist p\u2082 p\u2084", "start": [180, 1], "end": [183, 24], "kind": "commanddeclaration"}, {"full_name": "nndist_vsub_vsub_le", "code": "theorem nndist_vsub_vsub_le (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    nndist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084", "start": [186, 1], "end": [189, 86], "kind": "commanddeclaration"}, {"full_name": "edist_vadd_vadd_le", "code": "theorem edist_vadd_vadd_le (v v' : V) (p p' : P) :\n    edist (v +\u1d65 p) (v' +\u1d65 p') \u2264 edist v v' + edist p p'", "start": [192, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "edist_vsub_vsub_le", "code": "theorem edist_vsub_vsub_le (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    edist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 edist p\u2081 p\u2083 + edist p\u2082 p\u2084", "start": [199, 1], "end": [203, 26], "kind": "commanddeclaration"}, {"full_name": "pseudoMetricSpaceOfNormedAddCommGroupOfAddTorsor", "code": "def pseudoMetricSpaceOfNormedAddCommGroupOfAddTorsor (V P : Type*) [SeminormedAddCommGroup V]\n    [AddTorsor V P] : PseudoMetricSpace P where\n  dist x y := \u2016(x -\u1d65 y : V)\u2016\n  edist_dist _ _ := by simp only [\u2190ENNReal.ofReal_eq_coe_nnreal]\n  dist_self x := by simp\n  dist_comm x y := by simp only [\u2190 neg_vsub_eq_vsub_rev y x, norm_neg]\n  dist_triangle x y z := by\n    change \u2016x -\u1d65 z\u2016 \u2264 \u2016x -\u1d65 y\u2016 + \u2016y -\u1d65 z\u2016\n    rw [\u2190 vsub_add_vsub_cancel]\n    apply norm_add_le", "start": [206, 1], "end": [218, 22], "kind": "commanddeclaration"}, {"full_name": "metricSpaceOfNormedAddCommGroupOfAddTorsor", "code": "def metricSpaceOfNormedAddCommGroupOfAddTorsor (V P : Type*) [NormedAddCommGroup V]\n    [AddTorsor V P] : MetricSpace P where\n  dist x y := \u2016(x -\u1d65 y : V)\u2016\n  edist_dist _ _ := by simp only; rw [ENNReal.ofReal_eq_coe_nnreal]\n  dist_self x := by simp\n  eq_of_dist_eq_zero h := by simpa using h\n  dist_comm x y := by simp only [\u2190 neg_vsub_eq_vsub_rev y x, norm_neg]\n  dist_triangle x y z := by\n    change \u2016x -\u1d65 z\u2016 \u2264 \u2016x -\u1d65 y\u2016 + \u2016y -\u1d65 z\u2016\n    rw [\u2190 vsub_add_vsub_cancel]\n    apply norm_add_le", "start": [221, 1], "end": [233, 22], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.vadd", "code": "theorem LipschitzWith.vadd [PseudoEMetricSpace \u03b1] {f : \u03b1 \u2192 V} {g : \u03b1 \u2192 P} {Kf Kg : \u211d\u22650}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f +\u1d65 g)", "start": [236, 1], "end": [243, 54], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.vsub", "code": "theorem LipschitzWith.vsub [PseudoEMetricSpace \u03b1] {f g : \u03b1 \u2192 P} {Kf Kg : \u211d\u22650}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f -\u1d65 g)", "start": [246, 1], "end": [253, 54], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_vadd", "code": "theorem uniformContinuous_vadd : UniformContinuous fun x : V \u00d7 P => x.1 +\u1d65 x.2", "start": [256, 1], "end": [257, 73], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_vsub", "code": "theorem uniformContinuous_vsub : UniformContinuous fun x : P \u00d7 P => x.1 -\u1d65 x.2", "start": [260, 1], "end": [261, 73], "kind": "commanddeclaration"}, {"full_name": "NormedAddTorsor.to_continuousVAdd", "code": "instance (priority := 100) NormedAddTorsor.to_continuousVAdd : ContinuousVAdd V P where\n  continuous_vadd := uniformContinuous_vadd.continuous", "start": [264, 1], "end": [265, 55], "kind": "commanddeclaration"}, {"full_name": "continuous_vsub", "code": "theorem continuous_vsub : Continuous fun x : P \u00d7 P => x.1 -\u1d65 x.2", "start": [268, 1], "end": [269, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.vsub", "code": "theorem Filter.Tendsto.vsub {l : Filter \u03b1} {f g : \u03b1 \u2192 P} {x y : P} (hf : Tendsto f l (\ud835\udcdd x))\n    (hg : Tendsto g l (\ud835\udcdd y)) : Tendsto (f -\u1d65 g) l (\ud835\udcdd (x -\u1d65 y))", "start": [272, 1], "end": [274, 61], "kind": "commanddeclaration"}, {"full_name": "Continuous.vsub", "code": "theorem Continuous.vsub {f g : \u03b1 \u2192 P} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (f -\u1d65 g)", "start": [281, 1], "end": [283, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.vsub", "code": "nonrec theorem ContinuousAt.vsub {f g : \u03b1 \u2192 P} {x : \u03b1} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) :\n    ContinuousAt (f -\u1d65 g) x", "start": [286, 1], "end": [289, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.vsub", "code": "nonrec theorem ContinuousWithinAt.vsub {f g : \u03b1 \u2192 P} {x : \u03b1} {s : Set \u03b1}\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (f -\u1d65 g) s x", "start": [292, 1], "end": [295, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.vsub", "code": "theorem ContinuousOn.vsub {f g : \u03b1 \u2192 P} {s : Set \u03b1} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) : ContinuousOn (f -\u1d65 g) s", "start": [298, 1], "end": [300, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.lineMap", "code": "theorem Filter.Tendsto.lineMap {l : Filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 P} {g : \u03b1 \u2192 R} {p\u2081 p\u2082 : P} {c : R}\n    (h\u2081 : Tendsto f\u2081 l (\ud835\udcdd p\u2081)) (h\u2082 : Tendsto f\u2082 l (\ud835\udcdd p\u2082)) (hg : Tendsto g l (\ud835\udcdd c)) :\n    Tendsto (fun x => AffineMap.lineMap (f\u2081 x) (f\u2082 x) (g x)) l (\ud835\udcdd <| AffineMap.lineMap p\u2081 p\u2082 c)", "start": [308, 1], "end": [311, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.midpoint", "code": "theorem Filter.Tendsto.midpoint [Invertible (2 : R)] {l : Filter \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 P} {p\u2081 p\u2082 : P}\n    (h\u2081 : Tendsto f\u2081 l (\ud835\udcdd p\u2081)) (h\u2082 : Tendsto f\u2082 l (\ud835\udcdd p\u2082)) :\n    Tendsto (fun x => midpoint R (f\u2081 x) (f\u2082 x)) l (\ud835\udcdd <| midpoint R p\u2081 p\u2082)", "start": [314, 1], "end": [317, 35], "kind": "commanddeclaration"}, {"full_name": "IsClosed.vadd_right_of_isCompact", "code": "theorem IsClosed.vadd_right_of_isCompact {s : Set V} {t : Set P} (hs : IsClosed s)\n    (ht : IsCompact t) : IsClosed (s +\u1d65 t)", "start": [326, 1], "end": [336, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "imports": ["Mathlib/LinearAlgebra/AffineSpace/Combination.lean", "Mathlib/Data/Sign.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Basis/VectorSpace.lean", "Mathlib/LinearAlgebra/AffineSpace/AffineEquiv.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "AffineIndependent", "code": "def AffineIndependent (p : \u03b9 \u2192 P) : Prop :=\n  \u2200 (s : Finset \u03b9) (w : \u03b9 \u2192 k),\n    \u2211 i in s, w i = 0 \u2192 s.weightedVSub p w = (0 : V) \u2192 \u2200 i \u2208 s, w i = 0", "start": [50, 1], "end": [55, 72], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_def", "code": "theorem affineIndependent_def (p : \u03b9 \u2192 P) :\n    AffineIndependent k p \u2194\n      \u2200 (s : Finset \u03b9) (w : \u03b9 \u2192 k),\n        \u2211 i in s, w i = 0 \u2192 s.weightedVSub p w = (0 : V) \u2192 \u2200 i \u2208 s, w i = 0", "start": [58, 1], "end": [63, 10], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_of_subsingleton", "code": "theorem affineIndependent_of_subsingleton [Subsingleton \u03b9] (p : \u03b9 \u2192 P) : AffineIndependent k p", "start": [66, 1], "end": [68, 66], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_iff_of_fintype", "code": "theorem affineIndependent_iff_of_fintype [Fintype \u03b9] (p : \u03b9 \u2192 P) :\n    AffineIndependent k p \u2194\n      \u2200 w : \u03b9 \u2192 k, \u2211 i, w i = 0 \u2192 Finset.univ.weightedVSub p w = (0 : V) \u2192 \u2200 i, w i = 0", "start": [71, 1], "end": [83, 23], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_iff_linearIndependent_vsub", "code": "theorem affineIndependent_iff_linearIndependent_vsub (p : \u03b9 \u2192 P) (i1 : \u03b9) :\n    AffineIndependent k p \u2194 LinearIndependent k fun i : { x // x \u2260 i1 } => (p i -\u1d65 p i1 : V)", "start": [86, 1], "end": [136, 54], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_set_iff_linearIndependent_vsub", "code": "theorem affineIndependent_set_iff_linearIndependent_vsub {s : Set P} {p\u2081 : P} (hp\u2081 : p\u2081 \u2208 s) :\n    AffineIndependent k (fun p => p : s \u2192 P) \u2194\n      LinearIndependent k (fun v => v : (fun p => (p -\u1d65 p\u2081 : V)) '' (s \\ {p\u2081}) \u2192 V)", "start": [139, 1], "end": [160, 76], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_set_iff_affineIndependent_vadd_union_singleton", "code": "theorem linearIndependent_set_iff_affineIndependent_vadd_union_singleton {s : Set V}\n    (hs : \u2200 v \u2208 s, v \u2260 (0 : V)) (p\u2081 : P) : LinearIndependent k (fun v => v : s \u2192 V) \u2194\n    AffineIndependent k (fun p => p : ({p\u2081} \u222a (fun v => v +\u1d65 p\u2081) '' s : Set P) \u2192 P)", "start": [163, 1], "end": [175, 9], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_iff_indicator_eq_of_affineCombination_eq", "code": "theorem affineIndependent_iff_indicator_eq_of_affineCombination_eq (p : \u03b9 \u2192 P) :\n    AffineIndependent k p \u2194\n      \u2200 (s1 s2 : Finset \u03b9) (w1 w2 : \u03b9 \u2192 k),\n        \u2211 i in s1, w1 i = 1 \u2192\n          \u2211 i in s2, w2 i = 1 \u2192\n            s1.affineCombination k p w1 = s2.affineCombination k p w2 \u2192\n              Set.indicator (\u2191s1) w1 = Set.indicator (\u2191s2) w2", "start": [178, 1], "end": [231, 22], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_iff_eq_of_fintype_affineCombination_eq", "code": "theorem affineIndependent_iff_eq_of_fintype_affineCombination_eq [Fintype \u03b9] (p : \u03b9 \u2192 P) :\n    AffineIndependent k p \u2194 \u2200 w1 w2 : \u03b9 \u2192 k, \u2211 i, w1 i = 1 \u2192 \u2211 i, w2 i = 1 \u2192\n    Finset.univ.affineCombination k p w1 = Finset.univ.affineCombination k p w2 \u2192 w1 = w2", "start": [234, 1], "end": [250, 31], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.units_lineMap", "code": "theorem AffineIndependent.units_lineMap {p : \u03b9 \u2192 P} (hp : AffineIndependent k p) (j : \u03b9)\n    (w : \u03b9 \u2192 Units k) : AffineIndependent k fun i => AffineMap.lineMap (p j) (p i) (w i : k)", "start": [255, 1], "end": [264, 35], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.indicator_eq_of_affineCombination_eq", "code": "theorem AffineIndependent.indicator_eq_of_affineCombination_eq {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) (s\u2081 s\u2082 : Finset \u03b9) (w\u2081 w\u2082 : \u03b9 \u2192 k) (hw\u2081 : \u2211 i in s\u2081, w\u2081 i = 1)\n    (hw\u2082 : \u2211 i in s\u2082, w\u2082 i = 1) (h : s\u2081.affineCombination k p w\u2081 = s\u2082.affineCombination k p w\u2082) :\n    Set.indicator (\u2191s\u2081) w\u2081 = Set.indicator (\u2191s\u2082) w\u2082", "start": [267, 1], "end": [271, 94], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.injective", "code": "protected theorem AffineIndependent.injective [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) : Function.Injective p", "start": [274, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.comp_embedding", "code": "theorem AffineIndependent.comp_embedding {\u03b92 : Type*} (f : \u03b92 \u21aa \u03b9) {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) : AffineIndependent k (p \u2218 f)", "start": [285, 1], "end": [306, 70], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.subtype", "code": "protected theorem AffineIndependent.subtype {p : \u03b9 \u2192 P} (ha : AffineIndependent k p) (s : Set \u03b9) :\n    AffineIndependent k fun i : s => p i", "start": [309, 1], "end": [313, 42], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.range", "code": "protected theorem AffineIndependent.range {p : \u03b9 \u2192 P} (ha : AffineIndependent k p) :\n    AffineIndependent k (fun x => x : Set.range p \u2192 P)", "start": [316, 1], "end": [325, 12], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_equiv", "code": "theorem affineIndependent_equiv {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') {p : \u03b9' \u2192 P} :\n    AffineIndependent k (p \u2218 e) \u2194 AffineIndependent k p", "start": [328, 1], "end": [336, 44], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.mono", "code": "protected theorem AffineIndependent.mono {s t : Set P}\n    (ha : AffineIndependent k (fun x => x : t \u2192 P)) (hs : s \u2286 t) :\n    AffineIndependent k (fun x => x : s \u2192 P)", "start": [339, 1], "end": [343, 47], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.of_set_of_injective", "code": "theorem AffineIndependent.of_set_of_injective {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k (fun x => x : Set.range p \u2192 P)) (hi : Function.Injective p) :\n    AffineIndependent k p", "start": [346, 1], "end": [353, 23], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.of_comp", "code": "theorem AffineIndependent.of_comp {p : \u03b9 \u2192 P} (f : P \u2192\u1d43[k] P\u2082) (hai : AffineIndependent k (f \u2218 p)) :\n    AffineIndependent k p", "start": [360, 1], "end": [371, 47], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.map'", "code": "theorem AffineIndependent.map' {p : \u03b9 \u2192 P} (hai : AffineIndependent k p) (f : P \u2192\u1d43[k] P\u2082)\n    (hf : Function.Injective f) : AffineIndependent k (f \u2218 p)", "start": [374, 1], "end": [386, 48], "kind": "commanddeclaration"}, {"full_name": "AffineMap.affineIndependent_iff", "code": "theorem AffineMap.affineIndependent_iff {p : \u03b9 \u2192 P} (f : P \u2192\u1d43[k] P\u2082) (hf : Function.Injective f) :\n    AffineIndependent k (f \u2218 p) \u2194 AffineIndependent k p", "start": [389, 1], "end": [392, 76], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.affineIndependent_iff", "code": "theorem AffineEquiv.affineIndependent_iff {p : \u03b9 \u2192 P} (e : P \u2243\u1d43[k] P\u2082) :\n    AffineIndependent k (e \u2218 p) \u2194 AffineIndependent k p", "start": [395, 1], "end": [398, 58], "kind": "commanddeclaration"}, {"full_name": "AffineEquiv.affineIndependent_set_of_eq_iff", "code": "theorem AffineEquiv.affineIndependent_set_of_eq_iff {s : Set P} (e : P \u2243\u1d43[k] P\u2082) :\n    AffineIndependent k ((\u2191) : e '' s \u2192 P\u2082) \u2194 AffineIndependent k ((\u2191) : s \u2192 P)", "start": [401, 1], "end": [406, 65], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan", "code": "theorem AffineIndependent.exists_mem_inter_of_exists_mem_inter_affineSpan [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) {s1 s2 : Set \u03b9} {p0 : P} (hp0s1 : p0 \u2208 affineSpan k (p '' s1))\n    (hp0s2 : p0 \u2208 affineSpan k (p '' s2)) : \u2203 i : \u03b9, i \u2208 s1 \u2229 s2", "start": [411, 1], "end": [429, 49], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.affineSpan_disjoint_of_disjoint", "code": "theorem AffineIndependent.affineSpan_disjoint_of_disjoint [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) {s1 s2 : Set \u03b9} (hd : Disjoint s1 s2) :\n    Disjoint (affineSpan k (p '' s1) : Set P) (affineSpan k (p '' s2))", "start": [432, 1], "end": [440, 33], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.mem_affineSpan_iff", "code": "@[simp]\nprotected theorem AffineIndependent.mem_affineSpan_iff [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) (i : \u03b9) (s : Set \u03b9) : p i \u2208 affineSpan k (p '' s) \u2194 i \u2208 s", "start": [443, 1], "end": [456, 63], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.not_mem_affineSpan_diff", "code": "theorem AffineIndependent.not_mem_affineSpan_diff [Nontrivial k] {p : \u03b9 \u2192 P}\n    (ha : AffineIndependent k p) (i : \u03b9) (s : Set \u03b9) : p i \u2209 affineSpan k (p '' (s \\ {i}))", "start": [459, 1], "end": [464, 12], "kind": "commanddeclaration"}, {"full_name": "exists_nontrivial_relation_sum_zero_of_not_affine_ind", "code": "theorem exists_nontrivial_relation_sum_zero_of_not_affine_ind {t : Finset V}\n    (h : \u00acAffineIndependent k ((\u2191) : t \u2192 V)) :\n    \u2203 f : V \u2192 k, \u2211 e in t, f e \u2022 e = 0 \u2227 \u2211 e in t, f e = 0 \u2227 \u2203 x \u2208 t, f x \u2260 0", "start": [467, 1], "end": [483, 79], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_iff", "code": "theorem affineIndependent_iff {\u03b9} {p : \u03b9 \u2192 V} :\n    AffineIndependent k p \u2194\n      \u2200 (s : Finset \u03b9) (w : \u03b9 \u2192 k), s.sum w = 0 \u2192 \u2211 e in s, w e \u2022 p e = 0 \u2192 \u2200 e \u2208 s, w e = 0", "start": [486, 1], "end": [491, 80], "kind": "commanddeclaration"}, {"full_name": "weightedVSub_mem_vectorSpan_pair", "code": "theorem weightedVSub_mem_vectorSpan_pair {p : \u03b9 \u2192 P} (h : AffineIndependent k p) {w w\u2081 w\u2082 : \u03b9 \u2192 k}\n    {s : Finset \u03b9} (hw : \u2211 i in s, w i = 0) (hw\u2081 : \u2211 i in s, w\u2081 i = 1)\n    (hw\u2082 : \u2211 i in s, w\u2082 i = 1) :\n    s.weightedVSub p w \u2208\n        vectorSpan k ({s.affineCombination k p w\u2081, s.affineCombination k p w\u2082} : Set P) \u2194\n      \u2203 r : k, \u2200 i \u2208 s, w i = r * (w\u2081 i - w\u2082 i)", "start": [494, 1], "end": [520, 10], "kind": "commanddeclaration"}, {"full_name": "affineCombination_mem_affineSpan_pair", "code": "theorem affineCombination_mem_affineSpan_pair {p : \u03b9 \u2192 P} (h : AffineIndependent k p)\n    {w w\u2081 w\u2082 : \u03b9 \u2192 k} {s : Finset \u03b9} (_ : \u2211 i in s, w i = 1) (hw\u2081 : \u2211 i in s, w\u2081 i = 1)\n    (hw\u2082 : \u2211 i in s, w\u2082 i = 1) :\n    s.affineCombination k p w \u2208 line[k, s.affineCombination k p w\u2081, s.affineCombination k p w\u2082] \u2194\n      \u2203 r : k, \u2200 i \u2208 s, w i = r * (w\u2082 i - w\u2081 i) + w\u2081 i", "start": [523, 1], "end": [537, 67], "kind": "commanddeclaration"}, {"full_name": "exists_subset_affineIndependent_affineSpan_eq_top", "code": "theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}\n    (h : AffineIndependent k (fun p => p : s \u2192 P)) :\n    \u2203 t : Set P, s \u2286 t \u2227 AffineIndependent k (fun p => p : t \u2192 P) \u2227 affineSpan k t = \u22a4", "start": [548, 1], "end": [580, 74], "kind": "commanddeclaration"}, {"full_name": "exists_affineIndependent", "code": "theorem exists_affineIndependent (s : Set P) :\n    \u2203 (t : _) (_ : t \u2286 s), affineSpan k t = affineSpan k s \u2227 AffineIndependent k ((\u2191) : t \u2192 P)", "start": [585, 1], "end": [606, 81], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_of_ne", "code": "theorem affineIndependent_of_ne {p\u2081 p\u2082 : P} (h : p\u2081 \u2260 p\u2082) : AffineIndependent k ![p\u2081, p\u2082]", "start": [611, 1], "end": [624, 21], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.affineIndependent_of_not_mem_span", "code": "theorem AffineIndependent.affineIndependent_of_not_mem_span {p : \u03b9 \u2192 P} {i : \u03b9}\n    (ha : AffineIndependent k fun x : { y // y \u2260 i } => p x)\n    (hi : p i \u2209 affineSpan k (p '' { x | x \u2260 i })) : AffineIndependent k p", "start": [629, 1], "end": [673, 66], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_of_ne_of_mem_of_mem_of_not_mem", "code": "theorem affineIndependent_of_ne_of_mem_of_mem_of_not_mem {s : AffineSubspace k P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2209 s) :\n    AffineIndependent k ![p\u2081, p\u2082, p\u2083]", "start": [676, 1], "end": [691, 34], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_of_ne_of_mem_of_not_mem_of_mem", "code": "theorem affineIndependent_of_ne_of_mem_of_not_mem_of_mem {s : AffineSubspace k P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2209 s) (hp\u2083 : p\u2083 \u2208 s) :\n    AffineIndependent k ![p\u2081, p\u2082, p\u2083]", "start": [694, 1], "end": [702, 22], "kind": "commanddeclaration"}, {"full_name": "affineIndependent_of_ne_of_not_mem_of_mem_of_mem", "code": "theorem affineIndependent_of_ne_of_not_mem_of_mem_of_mem {s : AffineSubspace k P} {p\u2081 p\u2082 p\u2083 : P}\n    (hp\u2082p\u2083 : p\u2082 \u2260 p\u2083) (hp\u2081 : p\u2081 \u2209 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083 : p\u2083 \u2208 s) :\n    AffineIndependent k ![p\u2081, p\u2082, p\u2083]", "start": [705, 1], "end": [713, 22], "kind": "commanddeclaration"}, {"full_name": "sign_eq_of_affineCombination_mem_affineSpan_pair", "code": "theorem sign_eq_of_affineCombination_mem_affineSpan_pair {p : \u03b9 \u2192 P} (h : AffineIndependent k p)\n    {w w\u2081 w\u2082 : \u03b9 \u2192 k} {s : Finset \u03b9} (hw : \u2211 i in s, w i = 1) (hw\u2081 : \u2211 i in s, w\u2081 i = 1)\n    (hw\u2082 : \u2211 i in s, w\u2082 i = 1)\n    (hs :\n      s.affineCombination k p w \u2208 line[k, s.affineCombination k p w\u2081, s.affineCombination k p w\u2082])\n    {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s) (hi0 : w\u2081 i = 0) (hj0 : w\u2081 j = 0)\n    (hij : SignType.sign (w\u2082 i) = SignType.sign (w\u2082 j)) :\n    SignType.sign (w i) = SignType.sign (w j)", "start": [726, 1], "end": [741, 99], "kind": "commanddeclaration"}, {"full_name": "sign_eq_of_affineCombination_mem_affineSpan_single_lineMap", "code": "theorem sign_eq_of_affineCombination_mem_affineSpan_single_lineMap {p : \u03b9 \u2192 P}\n    (h : AffineIndependent k p) {w : \u03b9 \u2192 k} {s : Finset \u03b9} (hw : \u2211 i in s, w i = 1) {i\u2081 i\u2082 i\u2083 : \u03b9}\n    (h\u2081 : i\u2081 \u2208 s) (h\u2082 : i\u2082 \u2208 s) (h\u2083 : i\u2083 \u2208 s) (h\u2081\u2082 : i\u2081 \u2260 i\u2082) (h\u2081\u2083 : i\u2081 \u2260 i\u2083) (h\u2082\u2083 : i\u2082 \u2260 i\u2083)\n    {c : k} (hc0 : 0 < c) (hc1 : c < 1)\n    (hs : s.affineCombination k p w \u2208 line[k, p i\u2081, AffineMap.lineMap (p i\u2082) (p i\u2083) c]) :\n    SignType.sign (w i\u2082) = SignType.sign (w i\u2083)", "start": [744, 1], "end": [765, 38], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex", "code": "structure Simplex (n : \u2115) where\n  points : Fin (n + 1) \u2192 P\n  Independent : AffineIndependent k points", "start": [776, 1], "end": [780, 43], "kind": "commanddeclaration"}, {"full_name": "Affine.Triangle", "code": "abbrev Triangle :=\n  Simplex k P 2", "start": [783, 1], "end": [785, 16], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mkOfPoint", "code": "def mkOfPoint (p : P) : Simplex k P 0 :=\n  have : Subsingleton (Fin (1 + 0)) := by rw [add_zero]; infer_instance\n  \u27e8fun _ => p, affineIndependent_of_subsingleton k _\u27e9", "start": [792, 1], "end": [795, 54], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mkOfPoint_points", "code": "@[simp]\ntheorem mkOfPoint_points (p : P) (i : Fin 1) : (mkOfPoint k p).points i = p", "start": [798, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.nonempty", "code": "instance nonempty : Nonempty (Simplex k P 0) :=\n  \u27e8mkOfPoint k <| AddTorsor.Nonempty.some\u27e9", "start": [807, 1], "end": [808, 43], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.ext", "code": "@[ext]\ntheorem ext {n : \u2115} {s1 s2 : Simplex k P n} (h : \u2200 i, s1.points i = s2.points i) : s1 = s2", "start": [813, 1], "end": [819, 12], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.ext_iff", "code": "theorem ext_iff {n : \u2115} (s1 s2 : Simplex k P n) : s1 = s2 \u2194 \u2200 i, s1.points i = s2.points i", "start": [822, 1], "end": [824, 28], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face", "code": "def face {n : \u2115} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : \u2115} (h : fs.card = m + 1) :\n    Simplex k P m :=\n  \u27e8s.points \u2218 fs.orderEmbOfFin h, s.Independent.comp_embedding (fs.orderEmbOfFin h).toEmbedding\u27e9", "start": [827, 1], "end": [831, 97], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face_points", "code": "theorem face_points {n : \u2115} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : \u2115}\n    (h : fs.card = m + 1) (i : Fin (m + 1)) :\n    (s.face h).points i = s.points (fs.orderEmbOfFin h i)", "start": [834, 1], "end": [838, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face_points'", "code": "theorem face_points' {n : \u2115} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : \u2115}\n    (h : fs.card = m + 1) : (s.face h).points = s.points \u2218 fs.orderEmbOfFin h", "start": [841, 1], "end": [844, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face_eq_mkOfPoint", "code": "@[simp]\ntheorem face_eq_mkOfPoint {n : \u2115} (s : Simplex k P n) (i : Fin (n + 1)) :\n    s.face (Finset.card_singleton i) = mkOfPoint k (s.points i)", "start": [847, 1], "end": [855, 38], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.range_face_points", "code": "@[simp]\ntheorem range_face_points {n : \u2115} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : \u2115}\n    (h : fs.card = m + 1) : Set.range (s.face h).points = s.points '' \u2191fs", "start": [858, 1], "end": [862, 64], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex", "code": "@[simps]\ndef reindex {m n : \u2115} (s : Simplex k P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) : Simplex k P n :=\n  \u27e8s.points \u2218 e.symm, (affineIndependent_equiv e.symm).2 s.Independent\u27e9", "start": [865, 1], "end": [868, 72], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex_refl", "code": "@[simp]\ntheorem reindex_refl {n : \u2115} (s : Simplex k P n) : s.reindex (Equiv.refl (Fin (n + 1))) = s", "start": [871, 1], "end": [874, 19], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex_trans", "code": "@[simp]\ntheorem reindex_trans {n\u2081 n\u2082 n\u2083 : \u2115} (e\u2081\u2082 : Fin (n\u2081 + 1) \u2243 Fin (n\u2082 + 1))\n    (e\u2082\u2083 : Fin (n\u2082 + 1) \u2243 Fin (n\u2083 + 1)) (s : Simplex k P n\u2081) :\n    s.reindex (e\u2081\u2082.trans e\u2082\u2083) = (s.reindex e\u2081\u2082).reindex e\u2082\u2083", "start": [877, 1], "end": [882, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex_reindex_symm", "code": "@[simp]\ntheorem reindex_reindex_symm {m n : \u2115} (s : Simplex k P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) :\n    (s.reindex e).reindex e.symm = s", "start": [885, 1], "end": [888, 101], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex_symm_reindex", "code": "@[simp]\ntheorem reindex_symm_reindex {m n : \u2115} (s : Simplex k P m) (e : Fin (n + 1) \u2243 Fin (m + 1)) :\n    (s.reindex e.symm).reindex e = s", "start": [891, 1], "end": [894, 101], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reindex_range_points", "code": "@[simp]\ntheorem reindex_range_points {m n : \u2115} (s : Simplex k P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) :\n    Set.range (s.reindex e).points = Set.range s.points", "start": [897, 1], "end": [901, 68], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face_centroid_eq_centroid", "code": "@[simp]\ntheorem face_centroid_eq_centroid {n : \u2115} (s : Simplex k P n) {fs : Finset (Fin (n + 1))} {m : \u2115}\n    (h : fs.card = m + 1) : Finset.univ.centroid k (s.face h).points = fs.centroid k s.points", "start": [915, 1], "end": [922, 7], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.centroid_eq_iff", "code": "@[simp]\ntheorem centroid_eq_iff [CharZero k] {n : \u2115} (s : Simplex k P n) {fs\u2081 fs\u2082 : Finset (Fin (n + 1))}\n    {m\u2081 m\u2082 : \u2115} (h\u2081 : fs\u2081.card = m\u2081 + 1) (h\u2082 : fs\u2082.card = m\u2082 + 1) :\n    fs\u2081.centroid k s.points = fs\u2082.centroid k s.points \u2194 fs\u2081 = fs\u2082", "start": [925, 1], "end": [949, 39], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.face_centroid_eq_iff", "code": "theorem face_centroid_eq_iff [CharZero k] {n : \u2115} (s : Simplex k P n)\n    {fs\u2081 fs\u2082 : Finset (Fin (n + 1))} {m\u2081 m\u2082 : \u2115} (h\u2081 : fs\u2081.card = m\u2081 + 1) (h\u2082 : fs\u2082.card = m\u2082 + 1) :\n    Finset.univ.centroid k (s.face h\u2081).points = Finset.univ.centroid k (s.face h\u2082).points \u2194\n      fs\u2081 = fs\u2082", "start": [952, 1], "end": [960, 32], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.centroid_eq_of_range_eq", "code": "theorem centroid_eq_of_range_eq {n : \u2115} {s\u2081 s\u2082 : Simplex k P n}\n    (h : Set.range s\u2081.points = Set.range s\u2082.points) :\n    Finset.univ.centroid k s\u2081.points = Finset.univ.centroid k s\u2082.points", "start": [963, 1], "end": [971, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "imports": ["Mathlib/Topology/LocalHomeomorph.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean"], "premises": [{"full_name": "Asymptotics.IsBigOWith", "code": "irreducible_def IsBigOWith (c : \u211d) (l : Filter \u03b1) (f : \u03b1 \u2192 E) (g : \u03b1 \u2192 F) : Prop :=\n  \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [84, 1], "end": [89, 31], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Asymptotics.isBigOWith_iff", "code": "theorem isBigOWith_iff : IsBigOWith c l f g \u2194 \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [92, 1], "end": [93, 101], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.bound", "code": "alias \u27e8IsBigOWith.bound, IsBigOWith.of_bound\u27e9 := isBigOWith_iff", "start": [96, 1], "end": [96, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.of_bound", "code": "alias \u27e8IsBigOWith.bound, IsBigOWith.of_bound\u27e9 := isBigOWith_iff", "start": [96, 1], "end": [96, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO", "code": "irreducible_def IsBigO (l : Filter \u03b1) (f : \u03b1 \u2192 E) (g : \u03b1 \u2192 F) : Prop :=\n  \u2203 c : \u211d, IsBigOWith c l f g", "start": [100, 1], "end": [105, 30], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Asymptotics.isBigO_iff_isBigOWith", "code": "theorem isBigO_iff_isBigOWith : f =O[l] g \u2194 \u2203 c : \u211d, IsBigOWith c l f g", "start": [111, 1], "end": [113, 94], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff", "code": "theorem isBigO_iff : f =O[l] g \u2194 \u2203 c : \u211d, \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [116, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff'", "code": "theorem isBigO_iff' {g : \u03b1 \u2192 E'''} :\n    f =O[l] g \u2194 \u2203 c > 0, \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [121, 1], "end": [136, 18], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff''", "code": "theorem isBigO_iff'' {g : \u03b1 \u2192 E'''} :\n    f =O[l] g \u2194 \u2203 c > 0, \u2200\u1da0 x in l, c * \u2016f x\u2016 \u2264 \u2016g x\u2016", "start": [138, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_bound", "code": "theorem IsBigO.of_bound (c : \u211d) (h : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : f =O[l] g", "start": [155, 1], "end": [156, 22], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_bound'", "code": "theorem IsBigO.of_bound' (h : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 \u2016g x\u2016) : f =O[l] g", "start": [159, 1], "end": [162, 12], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.bound", "code": "theorem IsBigO.bound : f =O[l] g \u2192 \u2203 c : \u211d, \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [165, 1], "end": [166, 15], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO", "code": "irreducible_def IsLittleO (l : Filter \u03b1) (f : \u03b1 \u2192 E) (g : \u03b1 \u2192 F) : Prop :=\n  \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c l f g", "start": [169, 1], "end": [174, 40], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Asymptotics.isLittleO_iff_forall_isBigOWith", "code": "theorem isLittleO_iff_forall_isBigOWith : f =o[l] g \u2194 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 IsBigOWith c l f g", "start": [180, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.forall_isBigOWith", "code": "alias \u27e8IsLittleO.forall_isBigOWith, IsLittleO.of_isBigOWith\u27e9 := isLittleO_iff_forall_isBigOWith", "start": [185, 1], "end": [185, 96], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.of_isBigOWith", "code": "alias \u27e8IsLittleO.forall_isBigOWith, IsLittleO.of_isBigOWith\u27e9 := isLittleO_iff_forall_isBigOWith", "start": [185, 1], "end": [185, 96], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_iff", "code": "theorem isLittleO_iff : f =o[l] g \u2194 \u2200 \u2983c : \u211d\u2984, 0 < c \u2192 \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [189, 1], "end": [191, 44], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.bound", "code": "alias \u27e8IsLittleO.bound, IsLittleO.of_bound\u27e9 := isLittleO_iff", "start": [194, 1], "end": [194, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.of_bound", "code": "alias \u27e8IsLittleO.bound, IsLittleO.of_bound\u27e9 := isLittleO_iff", "start": [194, 1], "end": [194, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.def", "code": "theorem IsLittleO.def (h : f =o[l] g) (hc : 0 < c) : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [198, 1], "end": [199, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.def'", "code": "theorem IsLittleO.def' (h : f =o[l] g) (hc : 0 < c) : IsBigOWith c l f g", "start": [202, 1], "end": [203, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.eventuallyLE", "code": "theorem IsLittleO.eventuallyLE (h : f =o[l] g) : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 \u2016g x\u2016", "start": [206, 1], "end": [207, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.isBigO", "code": "theorem IsBigOWith.isBigO (h : IsBigOWith c l f g) : f =O[l] g", "start": [214, 1], "end": [214, 99], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.isBigOWith", "code": "theorem IsLittleO.isBigOWith (hgf : f =o[l] g) : IsBigOWith 1 l f g", "start": [217, 1], "end": [218, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.isBigO", "code": "theorem IsLittleO.isBigO (hgf : f =o[l] g) : f =O[l] g", "start": [221, 1], "end": [222, 24], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.isBigOWith", "code": "theorem IsBigO.isBigOWith : f =O[l] g \u2192 \u2203 c : \u211d, IsBigOWith c l f g", "start": [225, 1], "end": [226, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.weaken", "code": "theorem IsBigOWith.weaken (h : IsBigOWith c l f g') (hc : c \u2264 c') : IsBigOWith c' l f g'", "start": [229, 1], "end": [234, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.exists_pos", "code": "theorem IsBigOWith.exists_pos (h : IsBigOWith c l f g') :\n    \u2203 (c' : _) (_H : 0 < c'), IsBigOWith c' l f g'", "start": [237, 1], "end": [239, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.exists_pos", "code": "theorem IsBigO.exists_pos (h : f =O[l] g') : \u2203 (c : _) (_H : 0 < c), IsBigOWith c l f g'", "start": [242, 1], "end": [244, 16], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.exists_nonneg", "code": "theorem IsBigOWith.exists_nonneg (h : IsBigOWith c l f g') :\n    \u2203 (c' : _) (_H : 0 \u2264 c'), IsBigOWith c' l f g'", "start": [247, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.exists_nonneg", "code": "theorem IsBigO.exists_nonneg (h : f =O[l] g') : \u2203 (c : _) (_H : 0 \u2264 c), IsBigOWith c l f g'", "start": [253, 1], "end": [255, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff_eventually_isBigOWith", "code": "theorem isBigO_iff_eventually_isBigOWith : f =O[l] g' \u2194 \u2200\u1da0 c in atTop, IsBigOWith c l f g'", "start": [258, 1], "end": [261, 91], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff_eventually", "code": "theorem isBigO_iff_eventually : f =O[l] g' \u2194 \u2200\u1da0 c in atTop, \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 c * \u2016g' x\u2016", "start": [264, 1], "end": [266, 74], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.exists_mem_basis", "code": "theorem IsBigO.exists_mem_basis {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : f =O[l] g')\n    (hb : l.HasBasis p s) :\n    \u2203 (c : \u211d) (_hc : 0 < c) (i : \u03b9) (_hi : p i), \u2200 x \u2208 s i, \u2016f x\u2016 \u2264 c * \u2016g' x\u2016", "start": [269, 1], "end": [273, 72], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_inv", "code": "theorem isBigOWith_inv (hc : 0 < c) : IsBigOWith c\u207b\u00b9 l f g \u2194 \u2200\u1da0 x in l, c * \u2016f x\u2016 \u2264 \u2016g x\u2016", "start": [276, 1], "end": [277, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_iff_nat_mul_le_aux", "code": "theorem isLittleO_iff_nat_mul_le_aux (h\u2080 : (\u2200 x, 0 \u2264 \u2016f x\u2016) \u2228 \u2200 x, 0 \u2264 \u2016g x\u2016) :\n    f =o[l] g \u2194 \u2200 n : \u2115, \u2200\u1da0 x in l, \u2191n * \u2016f x\u2016 \u2264 \u2016g x\u2016", "start": [281, 1], "end": [297, 24], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_iff_nat_mul_le", "code": "theorem isLittleO_iff_nat_mul_le : f =o[l] g' \u2194 \u2200 n : \u2115, \u2200\u1da0 x in l, \u2191n * \u2016f x\u2016 \u2264 \u2016g' x\u2016", "start": [300, 1], "end": [301, 64], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_iff_nat_mul_le'", "code": "theorem isLittleO_iff_nat_mul_le' : f' =o[l] g \u2194 \u2200 n : \u2115, \u2200\u1da0 x in l, \u2191n * \u2016f' x\u2016 \u2264 \u2016g x\u2016", "start": [304, 1], "end": [305, 64], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_of_subsingleton", "code": "@[nontriviality]\ntheorem isLittleO_of_subsingleton [Subsingleton E'] : f' =o[l] g'", "start": [311, 1], "end": [313, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_of_subsingleton", "code": "@[nontriviality]\ntheorem isBigO_of_subsingleton [Subsingleton E'] : f' =O[l] g'", "start": [316, 1], "end": [318, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_congr", "code": "theorem isBigOWith_congr (hc : c\u2081 = c\u2082) (hf : f\u2081 =\u1da0[l] f\u2082) (hg : g\u2081 =\u1da0[l] g\u2082) :\n    IsBigOWith c\u2081 l f\u2081 g\u2081 \u2194 IsBigOWith c\u2082 l f\u2082 g\u2082", "start": [328, 1], "end": [334, 14], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.congr'", "code": "theorem IsBigOWith.congr' (h : IsBigOWith c\u2081 l f\u2081 g\u2081) (hc : c\u2081 = c\u2082) (hf : f\u2081 =\u1da0[l] f\u2082)\n    (hg : g\u2081 =\u1da0[l] g\u2082) : IsBigOWith c\u2082 l f\u2082 g\u2082", "start": [337, 1], "end": [339, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.congr", "code": "theorem IsBigOWith.congr (h : IsBigOWith c\u2081 l f\u2081 g\u2081) (hc : c\u2081 = c\u2082) (hf : \u2200 x, f\u2081 x = f\u2082 x)\n    (hg : \u2200 x, g\u2081 x = g\u2082 x) : IsBigOWith c\u2082 l f\u2082 g\u2082", "start": [342, 1], "end": [344, 44], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.congr_left", "code": "theorem IsBigOWith.congr_left (h : IsBigOWith c l f\u2081 g) (hf : \u2200 x, f\u2081 x = f\u2082 x) :\n    IsBigOWith c l f\u2082 g", "start": [347, 1], "end": [349, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.congr_right", "code": "theorem IsBigOWith.congr_right (h : IsBigOWith c l f g\u2081) (hg : \u2200 x, g\u2081 x = g\u2082 x) :\n    IsBigOWith c l f g\u2082", "start": [352, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.congr_const", "code": "theorem IsBigOWith.congr_const (h : IsBigOWith c\u2081 l f g) (hc : c\u2081 = c\u2082) : IsBigOWith c\u2082 l f g", "start": [357, 1], "end": [358, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_congr", "code": "theorem isBigO_congr (hf : f\u2081 =\u1da0[l] f\u2082) (hg : g\u2081 =\u1da0[l] g\u2082) : f\u2081 =O[l] g\u2081 \u2194 f\u2082 =O[l] g\u2082", "start": [361, 1], "end": [363, 57], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.congr'", "code": "theorem IsBigO.congr' (h : f\u2081 =O[l] g\u2081) (hf : f\u2081 =\u1da0[l] f\u2082) (hg : g\u2081 =\u1da0[l] g\u2082) : f\u2082 =O[l] g\u2082", "start": [366, 1], "end": [367, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.congr", "code": "theorem IsBigO.congr (h : f\u2081 =O[l] g\u2081) (hf : \u2200 x, f\u2081 x = f\u2082 x) (hg : \u2200 x, g\u2081 x = g\u2082 x) :\n    f\u2082 =O[l] g\u2082", "start": [370, 1], "end": [372, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.congr_left", "code": "theorem IsBigO.congr_left (h : f\u2081 =O[l] g) (hf : \u2200 x, f\u2081 x = f\u2082 x) : f\u2082 =O[l] g", "start": [375, 1], "end": [376, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.congr_right", "code": "theorem IsBigO.congr_right (h : f =O[l] g\u2081) (hg : \u2200 x, g\u2081 x = g\u2082 x) : f =O[l] g\u2082", "start": [379, 1], "end": [380, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_congr", "code": "theorem isLittleO_congr (hf : f\u2081 =\u1da0[l] f\u2082) (hg : g\u2081 =\u1da0[l] g\u2082) : f\u2081 =o[l] g\u2081 \u2194 f\u2082 =o[l] g\u2082", "start": [383, 1], "end": [385, 70], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.congr'", "code": "theorem IsLittleO.congr' (h : f\u2081 =o[l] g\u2081) (hf : f\u2081 =\u1da0[l] f\u2082) (hg : g\u2081 =\u1da0[l] g\u2082) : f\u2082 =o[l] g\u2082", "start": [388, 1], "end": [389, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.congr", "code": "theorem IsLittleO.congr (h : f\u2081 =o[l] g\u2081) (hf : \u2200 x, f\u2081 x = f\u2082 x) (hg : \u2200 x, g\u2081 x = g\u2082 x) :\n    f\u2082 =o[l] g\u2082", "start": [392, 1], "end": [394, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.congr_left", "code": "theorem IsLittleO.congr_left (h : f\u2081 =o[l] g) (hf : \u2200 x, f\u2081 x = f\u2082 x) : f\u2082 =o[l] g", "start": [397, 1], "end": [398, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.congr_right", "code": "theorem IsLittleO.congr_right (h : f =o[l] g\u2081) (hg : \u2200 x, g\u2081 x = g\u2082 x) : f =o[l] g\u2082", "start": [401, 1], "end": [402, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans_isBigO", "code": "@[trans]\ntheorem _root_.Filter.EventuallyEq.trans_isBigO {f\u2081 f\u2082 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : f\u2081 =\u1da0[l] f\u2082)\n    (h : f\u2082 =O[l] g) : f\u2081 =O[l] g", "start": [405, 1], "end": [408, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transEventuallyEqIsBigO", "code": "instance transEventuallyEqIsBigO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u00b7 =\u1da0[l] \u00b7) (\u00b7 =O[l] \u00b7) (\u00b7 =O[l] \u00b7) where\n  trans := Filter.EventuallyEq.trans_isBigO", "start": [411, 1], "end": [413, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans_isLittleO", "code": "@[trans]\ntheorem _root_.Filter.EventuallyEq.trans_isLittleO {f\u2081 f\u2082 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : f\u2081 =\u1da0[l] f\u2082)\n    (h : f\u2082 =o[l] g) : f\u2081 =o[l] g", "start": [415, 1], "end": [418, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transEventuallyEqIsLittleO", "code": "instance transEventuallyEqIsLittleO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u00b7 =\u1da0[l] \u00b7) (\u00b7 =o[l] \u00b7) (\u00b7 =o[l] \u00b7) where\n  trans := Filter.EventuallyEq.trans_isLittleO", "start": [421, 1], "end": [423, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_eventuallyEq", "code": "@[trans]\ntheorem IsBigO.trans_eventuallyEq {f : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} (h : f =O[l] g\u2081) (hg : g\u2081 =\u1da0[l] g\u2082) :\n    f =O[l] g\u2082", "start": [425, 1], "end": [428, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsBigOEventuallyEq", "code": "instance transIsBigOEventuallyEq :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u03b1 \u2192 F) (\u00b7 =O[l] \u00b7) (\u00b7 =\u1da0[l] \u00b7) (\u00b7 =O[l] \u00b7) where\n  trans := IsBigO.trans_eventuallyEq", "start": [431, 1], "end": [433, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_eventuallyEq", "code": "@[trans]\ntheorem IsLittleO.trans_eventuallyEq {f : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} (h : f =o[l] g\u2081)\n    (hg : g\u2081 =\u1da0[l] g\u2082) : f =o[l] g\u2082", "start": [435, 1], "end": [438, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsLittleOEventuallyEq", "code": "instance transIsLittleOEventuallyEq :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u03b1 \u2192 F) (\u00b7 =o[l] \u00b7) (\u00b7 =\u1da0[l] \u00b7) (\u00b7 =o[l] \u00b7) where\n  trans := IsLittleO.trans_eventuallyEq", "start": [441, 1], "end": [443, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.comp_tendsto", "code": "theorem IsBigOWith.comp_tendsto (hcfg : IsBigOWith c l f g) {k : \u03b2 \u2192 \u03b1} {l' : Filter \u03b2}\n    (hk : Tendsto k l' l) : IsBigOWith c l' (f \u2218 k) (g \u2218 k)", "start": [450, 1], "end": [452, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.comp_tendsto", "code": "theorem IsBigO.comp_tendsto (hfg : f =O[l] g) {k : \u03b2 \u2192 \u03b1} {l' : Filter \u03b2} (hk : Tendsto k l' l) :\n    (f \u2218 k) =O[l'] (g \u2218 k)", "start": [455, 1], "end": [457, 78], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.comp_tendsto", "code": "theorem IsLittleO.comp_tendsto (hfg : f =o[l] g) {k : \u03b2 \u2192 \u03b1} {l' : Filter \u03b2} (hk : Tendsto k l' l) :\n    (f \u2218 k) =o[l'] (g \u2218 k)", "start": [460, 1], "end": [462, 86], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_map", "code": "@[simp]\ntheorem isBigOWith_map {k : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} :\n    IsBigOWith c (map k l) f g \u2194 IsBigOWith c l (f \u2218 k) (g \u2218 k)", "start": [465, 1], "end": [469, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_map", "code": "@[simp]\ntheorem isBigO_map {k : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} : f =O[map k l] g \u2194 (f \u2218 k) =O[l] (g \u2218 k)", "start": [472, 1], "end": [474, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_map", "code": "@[simp]\ntheorem isLittleO_map {k : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} : f =o[map k l] g \u2194 (f \u2218 k) =o[l] (g \u2218 k)", "start": [477, 1], "end": [479, 44], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.mono", "code": "theorem IsBigOWith.mono (h : IsBigOWith c l' f g) (hl : l \u2264 l') : IsBigOWith c l f g", "start": [482, 1], "end": [483, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.mono", "code": "theorem IsBigO.mono (h : f =O[l'] g) (hl : l \u2264 l') : f =O[l] g", "start": [486, 1], "end": [487, 68], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.mono", "code": "theorem IsLittleO.mono (h : f =o[l'] g) (hl : l \u2264 l') : f =o[l] g", "start": [490, 1], "end": [491, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.trans", "code": "theorem IsBigOWith.trans (hfg : IsBigOWith c l f g) (hgk : IsBigOWith c' l g k) (hc : 0 \u2264 c) :\n    IsBigOWith (c * c') l f k", "start": [494, 1], "end": [501, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans", "code": "@[trans]\ntheorem IsBigO.trans {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (hfg : f =O[l] g) (hgk : g =O[l] k) :\n    f =O[l] k", "start": [504, 1], "end": [509, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsBigOIsBigO", "code": "instance transIsBigOIsBigO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F') (\u03b1 \u2192 G) (\u00b7 =O[l] \u00b7) (\u00b7 =O[l] \u00b7) (\u00b7 =O[l] \u00b7) where\n  trans := IsBigO.trans", "start": [512, 1], "end": [514, 24], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_isBigOWith", "code": "theorem IsLittleO.trans_isBigOWith (hfg : f =o[l] g) (hgk : IsBigOWith c l g k) (hc : 0 < c) :\n    f =o[l] k", "start": [516, 1], "end": [521, 77], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_isBigO", "code": "@[trans]\ntheorem IsLittleO.trans_isBigO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G'} (hfg : f =o[l] g)\n    (hgk : g =O[l] k) : f =o[l] k", "start": [524, 1], "end": [528, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsLittleOIsBigO", "code": "instance transIsLittleOIsBigO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u03b1 \u2192 G') (\u00b7 =o[l] \u00b7) (\u00b7 =O[l] \u00b7) (\u00b7 =o[l] \u00b7) where\n  trans := IsLittleO.trans_isBigO", "start": [531, 1], "end": [533, 34], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.trans_isLittleO", "code": "theorem IsBigOWith.trans_isLittleO (hfg : IsBigOWith c l f g) (hgk : g =o[l] k) (hc : 0 < c) :\n    f =o[l] k", "start": [535, 1], "end": [540, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_isLittleO", "code": "@[trans]\ntheorem IsBigO.trans_isLittleO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (hfg : f =O[l] g)\n    (hgk : g =o[l] k) : f =o[l] k", "start": [543, 1], "end": [547, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsBigOIsLittleO", "code": "instance transIsBigOIsLittleO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F') (\u03b1 \u2192 G) (\u00b7 =O[l] \u00b7) (\u00b7 =o[l] \u00b7) (\u00b7 =o[l] \u00b7) where\n  trans := IsBigO.trans_isLittleO", "start": [550, 1], "end": [552, 34], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans", "code": "@[trans]\ntheorem IsLittleO.trans {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G} (hfg : f =o[l] g) (hgk : g =o[l] k) :\n    f =o[l] k", "start": [554, 1], "end": [557, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.transIsLittleOIsLittleO", "code": "instance transIsLittleOIsLittleO :\n    @Trans (\u03b1 \u2192 E) (\u03b1 \u2192 F) (\u03b1 \u2192 G) (\u00b7 =o[l] \u00b7) (\u00b7 =o[l] \u00b7) (\u00b7 =o[l] \u00b7) where\n  trans := IsLittleO.trans", "start": [560, 1], "end": [562, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.trans_isBigO", "code": "theorem _root_.Filter.Eventually.trans_isBigO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G}\n    (hfg : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 \u2016g x\u2016) (hgk : g =O[l] k) : f =O[l] k", "start": [564, 1], "end": [566, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.isBigO", "code": "theorem _root_.Filter.Eventually.isBigO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 \u211d} {l : Filter \u03b1}\n    (hfg : \u2200\u1da0 x in l, \u2016f x\u2016 \u2264 g x) : f =O[l] g", "start": [569, 1], "end": [571, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_of_le'", "code": "theorem isBigOWith_of_le' (hfg : \u2200 x, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : IsBigOWith c l f g", "start": [578, 1], "end": [579, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_of_le", "code": "theorem isBigOWith_of_le (hfg : \u2200 x, \u2016f x\u2016 \u2264 \u2016g x\u2016) : IsBigOWith 1 l f g", "start": [582, 1], "end": [585, 16], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_of_le'", "code": "theorem isBigO_of_le' (hfg : \u2200 x, \u2016f x\u2016 \u2264 c * \u2016g x\u2016) : f =O[l] g", "start": [588, 1], "end": [589, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_of_le", "code": "theorem isBigO_of_le (hfg : \u2200 x, \u2016f x\u2016 \u2264 \u2016g x\u2016) : f =O[l] g", "start": [592, 1], "end": [593, 34], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_refl", "code": "theorem isBigOWith_refl (f : \u03b1 \u2192 E) (l : Filter \u03b1) : IsBigOWith 1 l f f", "start": [598, 1], "end": [599, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_refl", "code": "theorem isBigO_refl (f : \u03b1 \u2192 E) (l : Filter \u03b1) : f =O[l] f", "start": [602, 1], "end": [603, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.trans_le", "code": "theorem IsBigOWith.trans_le (hfg : IsBigOWith c l f g) (hgk : \u2200 x, \u2016g x\u2016 \u2264 \u2016k x\u2016) (hc : 0 \u2264 c) :\n    IsBigOWith c l f k", "start": [606, 1], "end": [608, 67], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_le", "code": "theorem IsBigO.trans_le (hfg : f =O[l] g') (hgk : \u2200 x, \u2016g' x\u2016 \u2264 \u2016k x\u2016) : f =O[l] k", "start": [611, 1], "end": [612, 33], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_le", "code": "theorem IsLittleO.trans_le (hfg : f =o[l] g) (hgk : \u2200 x, \u2016g x\u2016 \u2264 \u2016k x\u2016) : f =o[l] k", "start": [615, 1], "end": [616, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_irrefl'", "code": "theorem isLittleO_irrefl' (h : \u2203\u1da0 x in l, \u2016f' x\u2016 \u2260 0) : \u00acf' =o[l] f'", "start": [619, 1], "end": [623, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_irrefl", "code": "theorem isLittleO_irrefl (h : \u2203\u1da0 x in l, f'' x \u2260 0) : \u00acf'' =o[l] f''", "start": [626, 1], "end": [627, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.not_isLittleO", "code": "theorem IsBigO.not_isLittleO (h : f'' =O[l] g') (hf : \u2203\u1da0 x in l, f'' x \u2260 0) :\n    \u00acg' =o[l] f''", "start": [630, 1], "end": [632, 45], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.not_isBigO", "code": "theorem IsLittleO.not_isBigO (h : f'' =o[l] g') (hf : \u2203\u1da0 x in l, f'' x \u2260 0) :\n    \u00acg' =O[l] f''", "start": [635, 1], "end": [637, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_bot", "code": "@[simp]\ntheorem isBigOWith_bot : IsBigOWith c \u22a5 f g", "start": [644, 1], "end": [646, 33], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_bot", "code": "@[simp]\ntheorem isBigO_bot : f =O[\u22a5] g", "start": [649, 1], "end": [651, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_bot", "code": "@[simp]\ntheorem isLittleO_bot : f =o[\u22a5] g", "start": [654, 1], "end": [656, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_pure", "code": "@[simp]\ntheorem isBigOWith_pure {x} : IsBigOWith c (pure x) f g \u2194 \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [661, 1], "end": [663, 17], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.sup", "code": "theorem IsBigOWith.sup (h : IsBigOWith c l f g) (h' : IsBigOWith c l' f g) :\n    IsBigOWith c (l \u2294 l') f g", "start": [666, 1], "end": [668, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.sup'", "code": "theorem IsBigOWith.sup' (h : IsBigOWith c l f g') (h' : IsBigOWith c' l' f g') :\n    IsBigOWith (max c c') (l \u2294 l') f g'", "start": [671, 1], "end": [674, 93], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.sup", "code": "theorem IsBigO.sup (h : f =O[l] g') (h' : f =O[l'] g') : f =O[l \u2294 l'] g'", "start": [677, 1], "end": [680, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.sup", "code": "theorem IsLittleO.sup (h : f =o[l] g) (h' : f =o[l'] g) : f =o[l \u2294 l'] g", "start": [683, 1], "end": [684, 100], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_sup", "code": "@[simp]\ntheorem isBigO_sup : f =O[l \u2294 l'] g' \u2194 f =O[l] g' \u2227 f =O[l'] g'", "start": [687, 1], "end": [689, 77], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_sup", "code": "@[simp]\ntheorem isLittleO_sup : f =o[l \u2294 l'] g \u2194 f =o[l] g \u2227 f =o[l'] g", "start": [692, 1], "end": [694, 77], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_insert", "code": "theorem isBigOWith_insert [TopologicalSpace \u03b1] {x : \u03b1} {s : Set \u03b1} {C : \u211d} {g : \u03b1 \u2192 E} {g' : \u03b1 \u2192 F}\n    (h : \u2016g x\u2016 \u2264 C * \u2016g' x\u2016) : IsBigOWith C (\ud835\udcdd[insert x s] x) g g' \u2194\n    IsBigOWith C (\ud835\udcdd[s] x) g g'", "start": [697, 1], "end": [700, 96], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.insert", "code": "protected theorem IsBigOWith.insert [TopologicalSpace \u03b1] {x : \u03b1} {s : Set \u03b1} {C : \u211d} {g : \u03b1 \u2192 E}\n    {g' : \u03b1 \u2192 F} (h1 : IsBigOWith C (\ud835\udcdd[s] x) g g') (h2 : \u2016g x\u2016 \u2264 C * \u2016g' x\u2016) :\n    IsBigOWith C (\ud835\udcdd[insert x s] x) g g'", "start": [703, 1], "end": [706, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_insert", "code": "theorem isLittleO_insert [TopologicalSpace \u03b1] {x : \u03b1} {s : Set \u03b1} {g : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'}\n    (h : g x = 0) : g =o[\ud835\udcdd[insert x s] x] g' \u2194 g =o[\ud835\udcdd[s] x] g'", "start": [709, 1], "end": [715, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.insert", "code": "protected theorem IsLittleO.insert [TopologicalSpace \u03b1] {x : \u03b1} {s : Set \u03b1} {g : \u03b1 \u2192 E'}\n    {g' : \u03b1 \u2192 F'} (h1 : g =o[\ud835\udcdd[s] x] g') (h2 : g x = 0) : g =o[\ud835\udcdd[insert x s] x] g'", "start": [718, 1], "end": [720, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_norm_right", "code": "@[simp]\ntheorem isBigOWith_norm_right : (IsBigOWith c l f fun x => \u2016g' x\u2016) \u2194 IsBigOWith c l f g'", "start": [730, 1], "end": [732, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_abs_right", "code": "@[simp]\ntheorem isBigOWith_abs_right : (IsBigOWith c l f fun x => |u x|) \u2194 IsBigOWith c l f u", "start": [735, 1], "end": [737, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_norm_right", "code": "alias \u27e8IsBigOWith.of_norm_right, IsBigOWith.norm_right\u27e9 := isBigOWith_norm_right", "start": [740, 1], "end": [740, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.norm_right", "code": "alias \u27e8IsBigOWith.of_norm_right, IsBigOWith.norm_right\u27e9 := isBigOWith_norm_right", "start": [740, 1], "end": [740, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.of_abs_right", "code": "alias \u27e8IsBigOWith.of_abs_right, IsBigOWith.abs_right\u27e9 := isBigOWith_abs_right", "start": [744, 1], "end": [744, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.abs_right", "code": "alias \u27e8IsBigOWith.of_abs_right, IsBigOWith.abs_right\u27e9 := isBigOWith_abs_right", "start": [744, 1], "end": [744, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigO_norm_right", "code": "@[simp]\ntheorem isBigO_norm_right : (f =O[l] fun x => \u2016g' x\u2016) \u2194 f =O[l] g'", "start": [748, 1], "end": [751, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_abs_right", "code": "@[simp]\ntheorem isBigO_abs_right : (f =O[l] fun x => |u x|) \u2194 f =O[l] u", "start": [754, 1], "end": [756, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_norm_right", "code": "alias \u27e8IsBigO.of_norm_right, IsBigO.norm_right\u27e9 := isBigO_norm_right", "start": [759, 1], "end": [759, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.norm_right", "code": "alias \u27e8IsBigO.of_norm_right, IsBigO.norm_right\u27e9 := isBigO_norm_right", "start": [759, 1], "end": [759, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.of_abs_right", "code": "alias \u27e8IsBigO.of_abs_right, IsBigO.abs_right\u27e9 := isBigO_abs_right", "start": [763, 1], "end": [763, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.abs_right", "code": "alias \u27e8IsBigO.of_abs_right, IsBigO.abs_right\u27e9 := isBigO_abs_right", "start": [763, 1], "end": [763, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_norm_right", "code": "@[simp]\ntheorem isLittleO_norm_right : (f =o[l] fun x => \u2016g' x\u2016) \u2194 f =o[l] g'", "start": [767, 1], "end": [770, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_abs_right", "code": "@[simp]\ntheorem isLittleO_abs_right : (f =o[l] fun x => |u x|) \u2194 f =o[l] u", "start": [773, 1], "end": [775, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_norm_right", "code": "alias \u27e8IsLittleO.of_norm_right, IsLittleO.norm_right\u27e9 := isLittleO_norm_right", "start": [778, 1], "end": [778, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.norm_right", "code": "alias \u27e8IsLittleO.of_norm_right, IsLittleO.norm_right\u27e9 := isLittleO_norm_right", "start": [778, 1], "end": [778, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.of_abs_right", "code": "alias \u27e8IsLittleO.of_abs_right, IsLittleO.abs_right\u27e9 := isLittleO_abs_right", "start": [782, 1], "end": [782, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.abs_right", "code": "alias \u27e8IsLittleO.of_abs_right, IsLittleO.abs_right\u27e9 := isLittleO_abs_right", "start": [782, 1], "end": [782, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigOWith_norm_left", "code": "@[simp]\ntheorem isBigOWith_norm_left : IsBigOWith c l (fun x => \u2016f' x\u2016) g \u2194 IsBigOWith c l f' g", "start": [786, 1], "end": [788, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_abs_left", "code": "@[simp]\ntheorem isBigOWith_abs_left : IsBigOWith c l (fun x => |u x|) g \u2194 IsBigOWith c l u g", "start": [791, 1], "end": [793, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_norm_left", "code": "alias \u27e8IsBigOWith.of_norm_left, IsBigOWith.norm_left\u27e9 := isBigOWith_norm_left", "start": [796, 1], "end": [796, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.norm_left", "code": "alias \u27e8IsBigOWith.of_norm_left, IsBigOWith.norm_left\u27e9 := isBigOWith_norm_left", "start": [796, 1], "end": [796, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.of_abs_left", "code": "alias \u27e8IsBigOWith.of_abs_left, IsBigOWith.abs_left\u27e9 := isBigOWith_abs_left", "start": [800, 1], "end": [800, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.abs_left", "code": "alias \u27e8IsBigOWith.of_abs_left, IsBigOWith.abs_left\u27e9 := isBigOWith_abs_left", "start": [800, 1], "end": [800, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigO_norm_left", "code": "@[simp]\ntheorem isBigO_norm_left : (fun x => \u2016f' x\u2016) =O[l] g \u2194 f' =O[l] g", "start": [804, 1], "end": [807, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_abs_left", "code": "@[simp]\ntheorem isBigO_abs_left : (fun x => |u x|) =O[l] g \u2194 u =O[l] g", "start": [810, 1], "end": [812, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_norm_left", "code": "alias \u27e8IsBigO.of_norm_left, IsBigO.norm_left\u27e9 := isBigO_norm_left", "start": [815, 1], "end": [815, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.norm_left", "code": "alias \u27e8IsBigO.of_norm_left, IsBigO.norm_left\u27e9 := isBigO_norm_left", "start": [815, 1], "end": [815, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.of_abs_left", "code": "alias \u27e8IsBigO.of_abs_left, IsBigO.abs_left\u27e9 := isBigO_abs_left", "start": [819, 1], "end": [819, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.abs_left", "code": "alias \u27e8IsBigO.of_abs_left, IsBigO.abs_left\u27e9 := isBigO_abs_left", "start": [819, 1], "end": [819, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_norm_left", "code": "@[simp]\ntheorem isLittleO_norm_left : (fun x => \u2016f' x\u2016) =o[l] g \u2194 f' =o[l] g", "start": [823, 1], "end": [826, 54], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_abs_left", "code": "@[simp]\ntheorem isLittleO_abs_left : (fun x => |u x|) =o[l] g \u2194 u =o[l] g", "start": [829, 1], "end": [831, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_norm_left", "code": "alias \u27e8IsLittleO.of_norm_left, IsLittleO.norm_left\u27e9 := isLittleO_norm_left", "start": [834, 1], "end": [834, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.norm_left", "code": "alias \u27e8IsLittleO.of_norm_left, IsLittleO.norm_left\u27e9 := isLittleO_norm_left", "start": [834, 1], "end": [834, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.of_abs_left", "code": "alias \u27e8IsLittleO.of_abs_left, IsLittleO.abs_left\u27e9 := isLittleO_abs_left", "start": [838, 1], "end": [838, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.abs_left", "code": "alias \u27e8IsLittleO.of_abs_left, IsLittleO.abs_left\u27e9 := isLittleO_abs_left", "start": [838, 1], "end": [838, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigOWith_norm_norm", "code": "theorem isBigOWith_norm_norm :\n    (IsBigOWith c l (fun x => \u2016f' x\u2016) fun x => \u2016g' x\u2016) \u2194 IsBigOWith c l f' g'", "start": [842, 1], "end": [844, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_abs_abs", "code": "theorem isBigOWith_abs_abs :\n    (IsBigOWith c l (fun x => |u x|) fun x => |v x|) \u2194 IsBigOWith c l u v", "start": [847, 1], "end": [849, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_norm_norm", "code": "alias \u27e8IsBigOWith.of_norm_norm, IsBigOWith.norm_norm\u27e9 := isBigOWith_norm_norm", "start": [852, 1], "end": [852, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.norm_norm", "code": "alias \u27e8IsBigOWith.of_norm_norm, IsBigOWith.norm_norm\u27e9 := isBigOWith_norm_norm", "start": [852, 1], "end": [852, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.of_abs_abs", "code": "alias \u27e8IsBigOWith.of_abs_abs, IsBigOWith.abs_abs\u27e9 := isBigOWith_abs_abs", "start": [856, 1], "end": [856, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.abs_abs", "code": "alias \u27e8IsBigOWith.of_abs_abs, IsBigOWith.abs_abs\u27e9 := isBigOWith_abs_abs", "start": [856, 1], "end": [856, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigO_norm_norm", "code": "theorem isBigO_norm_norm : ((fun x => \u2016f' x\u2016) =O[l] fun x => \u2016g' x\u2016) \u2194 f' =O[l] g'", "start": [860, 1], "end": [861, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_abs_abs", "code": "theorem isBigO_abs_abs : ((fun x => |u x|) =O[l] fun x => |v x|) \u2194 u =O[l] v", "start": [864, 1], "end": [865, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_norm_norm", "code": "alias \u27e8IsBigO.of_norm_norm, IsBigO.norm_norm\u27e9 := isBigO_norm_norm", "start": [868, 1], "end": [868, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.norm_norm", "code": "alias \u27e8IsBigO.of_norm_norm, IsBigO.norm_norm\u27e9 := isBigO_norm_norm", "start": [868, 1], "end": [868, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.of_abs_abs", "code": "alias \u27e8IsBigO.of_abs_abs, IsBigO.abs_abs\u27e9 := isBigO_abs_abs", "start": [872, 1], "end": [872, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.abs_abs", "code": "alias \u27e8IsBigO.of_abs_abs, IsBigO.abs_abs\u27e9 := isBigO_abs_abs", "start": [872, 1], "end": [872, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_norm_norm", "code": "theorem isLittleO_norm_norm : ((fun x => \u2016f' x\u2016) =o[l] fun x => \u2016g' x\u2016) \u2194 f' =o[l] g'", "start": [876, 1], "end": [877, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_abs_abs", "code": "theorem isLittleO_abs_abs : ((fun x => |u x|) =o[l] fun x => |v x|) \u2194 u =o[l] v", "start": [880, 1], "end": [881, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_norm_norm", "code": "alias \u27e8IsLittleO.of_norm_norm, IsLittleO.norm_norm\u27e9 := isLittleO_norm_norm", "start": [884, 1], "end": [884, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.norm_norm", "code": "alias \u27e8IsLittleO.of_norm_norm, IsLittleO.norm_norm\u27e9 := isLittleO_norm_norm", "start": [884, 1], "end": [884, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.of_abs_abs", "code": "alias \u27e8IsLittleO.of_abs_abs, IsLittleO.abs_abs\u27e9 := isLittleO_abs_abs", "start": [888, 1], "end": [888, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.abs_abs", "code": "alias \u27e8IsLittleO.of_abs_abs, IsLittleO.abs_abs\u27e9 := isLittleO_abs_abs", "start": [888, 1], "end": [888, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigOWith_neg_right", "code": "@[simp]\ntheorem isBigOWith_neg_right : (IsBigOWith c l f fun x => -g' x) \u2194 IsBigOWith c l f g'", "start": [897, 1], "end": [899, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_neg_right", "code": "alias \u27e8IsBigOWith.of_neg_right, IsBigOWith.neg_right\u27e9 := isBigOWith_neg_right", "start": [902, 1], "end": [902, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.neg_right", "code": "alias \u27e8IsBigOWith.of_neg_right, IsBigOWith.neg_right\u27e9 := isBigOWith_neg_right", "start": [902, 1], "end": [902, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigO_neg_right", "code": "@[simp]\ntheorem isBigO_neg_right : (f =O[l] fun x => -g' x) \u2194 f =O[l] g'", "start": [906, 1], "end": [909, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_neg_right", "code": "alias \u27e8IsBigO.of_neg_right, IsBigO.neg_right\u27e9 := isBigO_neg_right", "start": [912, 1], "end": [912, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.neg_right", "code": "alias \u27e8IsBigO.of_neg_right, IsBigO.neg_right\u27e9 := isBigO_neg_right", "start": [912, 1], "end": [912, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_neg_right", "code": "@[simp]\ntheorem isLittleO_neg_right : (f =o[l] fun x => -g' x) \u2194 f =o[l] g'", "start": [916, 1], "end": [919, 54], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_neg_right", "code": "alias \u27e8IsLittleO.of_neg_right, IsLittleO.neg_right\u27e9 := isLittleO_neg_right", "start": [922, 1], "end": [922, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.neg_right", "code": "alias \u27e8IsLittleO.of_neg_right, IsLittleO.neg_right\u27e9 := isLittleO_neg_right", "start": [922, 1], "end": [922, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigOWith_neg_left", "code": "@[simp]\ntheorem isBigOWith_neg_left : IsBigOWith c l (fun x => -f' x) g \u2194 IsBigOWith c l f' g", "start": [926, 1], "end": [928, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_neg_left", "code": "alias \u27e8IsBigOWith.of_neg_left, IsBigOWith.neg_left\u27e9 := isBigOWith_neg_left", "start": [931, 1], "end": [931, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigOWith.neg_left", "code": "alias \u27e8IsBigOWith.of_neg_left, IsBigOWith.neg_left\u27e9 := isBigOWith_neg_left", "start": [931, 1], "end": [931, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigO_neg_left", "code": "@[simp]\ntheorem isBigO_neg_left : (fun x => -f' x) =O[l] g \u2194 f' =O[l] g", "start": [935, 1], "end": [938, 50], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_neg_left", "code": "alias \u27e8IsBigO.of_neg_left, IsBigO.neg_left\u27e9 := isBigO_neg_left", "start": [941, 1], "end": [941, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsBigO.neg_left", "code": "alias \u27e8IsBigO.of_neg_left, IsBigO.neg_left\u27e9 := isBigO_neg_left", "start": [941, 1], "end": [941, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_neg_left", "code": "@[simp]\ntheorem isLittleO_neg_left : (fun x => -f' x) =o[l] g \u2194 f' =o[l] g", "start": [945, 1], "end": [948, 53], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_neg_left", "code": "alias \u27e8IsLittleO.of_neg_left, IsLittleO.neg_left\u27e9 := isLittleO_neg_left", "start": [951, 1], "end": [951, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsLittleO.neg_left", "code": "alias \u27e8IsLittleO.of_neg_left, IsLittleO.neg_left\u27e9 := isLittleO_neg_left", "start": [951, 1], "end": [951, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isBigOWith_fst_prod", "code": "theorem isBigOWith_fst_prod : IsBigOWith 1 l f' fun x => (f' x, g' x)", "start": [958, 1], "end": [959, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_snd_prod", "code": "theorem isBigOWith_snd_prod : IsBigOWith 1 l g' fun x => (f' x, g' x)", "start": [962, 1], "end": [963, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_fst_prod", "code": "theorem isBigO_fst_prod : f' =O[l] fun x => (f' x, g' x)", "start": [966, 1], "end": [967, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_snd_prod", "code": "theorem isBigO_snd_prod : g' =O[l] fun x => (f' x, g' x)", "start": [970, 1], "end": [971, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_fst_prod'", "code": "theorem isBigO_fst_prod' {f' : \u03b1 \u2192 E' \u00d7 F'} : (fun x => (f' x).1) =O[l] f'", "start": [974, 1], "end": [975, 81], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_snd_prod'", "code": "theorem isBigO_snd_prod' {f' : \u03b1 \u2192 E' \u00d7 F'} : (fun x => (f' x).2) =O[l] f'", "start": [978, 1], "end": [979, 81], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_rightl", "code": "theorem IsBigOWith.prod_rightl (h : IsBigOWith c l f g') (hc : 0 \u2264 c) :\n    IsBigOWith c l f fun x => (g' x, k' x)", "start": [986, 1], "end": [988, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.prod_rightl", "code": "theorem IsBigO.prod_rightl (h : f =O[l] g') : f =O[l] fun x => (g' x, k' x)", "start": [991, 1], "end": [993, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.prod_rightl", "code": "theorem IsLittleO.prod_rightl (h : f =o[l] g') : f =o[l] fun x => (g' x, k' x)", "start": [996, 1], "end": [997, 91], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_rightr", "code": "theorem IsBigOWith.prod_rightr (h : IsBigOWith c l f g') (hc : 0 \u2264 c) :\n    IsBigOWith c l f fun x => (f' x, g' x)", "start": [1000, 1], "end": [1002, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.prod_rightr", "code": "theorem IsBigO.prod_rightr (h : f =O[l] g') : f =O[l] fun x => (f' x, g' x)", "start": [1005, 1], "end": [1007, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.prod_rightr", "code": "theorem IsLittleO.prod_rightr (h : f =o[l] g') : f =o[l] fun x => (f' x, g' x)", "start": [1010, 1], "end": [1011, 91], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_left_same", "code": "theorem IsBigOWith.prod_left_same (hf : IsBigOWith c l f' k') (hg : IsBigOWith c l g' k') :\n    IsBigOWith c l (fun x => (f' x, g' x)) k'", "start": [1016, 1], "end": [1018, 72], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_left", "code": "theorem IsBigOWith.prod_left (hf : IsBigOWith c l f' k') (hg : IsBigOWith c' l g' k') :\n    IsBigOWith (max c c') l (fun x => (f' x, g' x)) k'", "start": [1021, 1], "end": [1023, 82], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_left_fst", "code": "theorem IsBigOWith.prod_left_fst (h : IsBigOWith c l (fun x => (f' x, g' x)) k') :\n    IsBigOWith c l f' k'", "start": [1026, 1], "end": [1028, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.prod_left_snd", "code": "theorem IsBigOWith.prod_left_snd (h : IsBigOWith c l (fun x => (f' x, g' x)) k') :\n    IsBigOWith c l g' k'", "start": [1031, 1], "end": [1033, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_prod_left", "code": "theorem isBigOWith_prod_left :\n    IsBigOWith c l (fun x => (f' x, g' x)) k' \u2194 IsBigOWith c l f' k' \u2227 IsBigOWith c l g' k'", "start": [1036, 1], "end": [1038, 81], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.prod_left", "code": "theorem IsBigO.prod_left (hf : f' =O[l] k') (hg : g' =O[l] k') : (fun x => (f' x, g' x)) =O[l] k'", "start": [1041, 1], "end": [1044, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.prod_left_fst", "code": "theorem IsBigO.prod_left_fst : (fun x => (f' x, g' x)) =O[l] k' \u2192 f' =O[l] k'", "start": [1047, 1], "end": [1048, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.prod_left_snd", "code": "theorem IsBigO.prod_left_snd : (fun x => (f' x, g' x)) =O[l] k' \u2192 g' =O[l] k'", "start": [1051, 1], "end": [1052, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_prod_left", "code": "@[simp]\ntheorem isBigO_prod_left : (fun x => (f' x, g' x)) =O[l] k' \u2194 f' =O[l] k' \u2227 g' =O[l] k'", "start": [1055, 1], "end": [1057, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.prod_left", "code": "theorem IsLittleO.prod_left (hf : f' =o[l] k') (hg : g' =o[l] k') :\n    (fun x => (f' x, g' x)) =o[l] k'", "start": [1060, 1], "end": [1063, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.prod_left_fst", "code": "theorem IsLittleO.prod_left_fst : (fun x => (f' x, g' x)) =o[l] k' \u2192 f' =o[l] k'", "start": [1066, 1], "end": [1067, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.prod_left_snd", "code": "theorem IsLittleO.prod_left_snd : (fun x => (f' x, g' x)) =o[l] k' \u2192 g' =o[l] k'", "start": [1070, 1], "end": [1071, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_prod_left", "code": "@[simp]\ntheorem isLittleO_prod_left : (fun x => (f' x, g' x)) =o[l] k' \u2194 f' =o[l] k' \u2227 g' =o[l] k'", "start": [1074, 1], "end": [1076, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.eq_zero_imp", "code": "theorem IsBigOWith.eq_zero_imp (h : IsBigOWith c l f'' g'') : \u2200\u1da0 x in l, g'' x = 0 \u2192 f'' x = 0", "start": [1079, 1], "end": [1080, 86], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.eq_zero_imp", "code": "theorem IsBigO.eq_zero_imp (h : f'' =O[l] g'') : \u2200\u1da0 x in l, g'' x = 0 \u2192 f'' x = 0", "start": [1083, 1], "end": [1085, 17], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.add", "code": "theorem IsBigOWith.add (h\u2081 : IsBigOWith c\u2081 l f\u2081 g) (h\u2082 : IsBigOWith c\u2082 l f\u2082 g) :\n    IsBigOWith (c\u2081 + c\u2082) l (fun x => f\u2081 x + f\u2082 x) g", "start": [1095, 1], "end": [1101, 54], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.add", "code": "theorem IsBigO.add (h\u2081 : f\u2081 =O[l] g) (h\u2082 : f\u2082 =O[l] g) : (fun x => f\u2081 x + f\u2082 x) =O[l] g", "start": [1104, 1], "end": [1107, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.add", "code": "theorem IsLittleO.add (h\u2081 : f\u2081 =o[l] g) (h\u2082 : f\u2082 =o[l] g) : (fun x => f\u2081 x + f\u2082 x) =o[l] g", "start": [1110, 1], "end": [1113, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.add_add", "code": "theorem IsLittleO.add_add (h\u2081 : f\u2081 =o[l] g\u2081) (h\u2082 : f\u2082 =o[l] g\u2082) :\n    (fun x => f\u2081 x + f\u2082 x) =o[l] fun x => \u2016g\u2081 x\u2016 + \u2016g\u2082 x\u2016", "start": [1116, 1], "end": [1118, 92], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.add_isLittleO", "code": "theorem IsBigO.add_isLittleO (h\u2081 : f\u2081 =O[l] g) (h\u2082 : f\u2082 =o[l] g) : (fun x => f\u2081 x + f\u2082 x) =O[l] g", "start": [1121, 1], "end": [1122, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.add_isBigO", "code": "theorem IsLittleO.add_isBigO (h\u2081 : f\u2081 =o[l] g) (h\u2082 : f\u2082 =O[l] g) : (fun x => f\u2081 x + f\u2082 x) =O[l] g", "start": [1125, 1], "end": [1126, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.add_isLittleO", "code": "theorem IsBigOWith.add_isLittleO (h\u2081 : IsBigOWith c\u2081 l f\u2081 g) (h\u2082 : f\u2082 =o[l] g) (hc : c\u2081 < c\u2082) :\n    IsBigOWith c\u2082 l (fun x => f\u2081 x + f\u2082 x) g", "start": [1129, 1], "end": [1131, 89], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.add_isBigOWith", "code": "theorem IsLittleO.add_isBigOWith (h\u2081 : f\u2081 =o[l] g) (h\u2082 : IsBigOWith c\u2081 l f\u2082 g) (hc : c\u2081 < c\u2082) :\n    IsBigOWith c\u2082 l (fun x => f\u2081 x + f\u2082 x) g", "start": [1134, 1], "end": [1136, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.sub", "code": "theorem IsBigOWith.sub (h\u2081 : IsBigOWith c\u2081 l f\u2081 g) (h\u2082 : IsBigOWith c\u2082 l f\u2082 g) :\n    IsBigOWith (c\u2081 + c\u2082) l (fun x => f\u2081 x - f\u2082 x) g", "start": [1139, 1], "end": [1141, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.sub_isLittleO", "code": "theorem IsBigOWith.sub_isLittleO (h\u2081 : IsBigOWith c\u2081 l f\u2081 g) (h\u2082 : f\u2082 =o[l] g) (hc : c\u2081 < c\u2082) :\n    IsBigOWith c\u2082 l (fun x => f\u2081 x - f\u2082 x) g", "start": [1144, 1], "end": [1146, 68], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.sub", "code": "theorem IsBigO.sub (h\u2081 : f\u2081 =O[l] g) (h\u2082 : f\u2082 =O[l] g) : (fun x => f\u2081 x - f\u2082 x) =O[l] g", "start": [1149, 1], "end": [1150, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.sub", "code": "theorem IsLittleO.sub (h\u2081 : f\u2081 =o[l] g) (h\u2082 : f\u2082 =o[l] g) : (fun x => f\u2081 x - f\u2082 x) =o[l] g", "start": [1153, 1], "end": [1154, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.symm", "code": "theorem IsBigOWith.symm (h : IsBigOWith c l (fun x => f\u2081 x - f\u2082 x) g) :\n    IsBigOWith c l (fun x => f\u2082 x - f\u2081 x) g", "start": [1168, 1], "end": [1170, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_comm", "code": "theorem isBigOWith_comm :\n    IsBigOWith c l (fun x => f\u2081 x - f\u2082 x) g \u2194 IsBigOWith c l (fun x => f\u2082 x - f\u2081 x) g", "start": [1173, 1], "end": [1175, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.symm", "code": "theorem IsBigO.symm (h : (fun x => f\u2081 x - f\u2082 x) =O[l] g) : (fun x => f\u2082 x - f\u2081 x) =O[l] g", "start": [1178, 1], "end": [1179, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_comm", "code": "theorem isBigO_comm : (fun x => f\u2081 x - f\u2082 x) =O[l] g \u2194 (fun x => f\u2082 x - f\u2081 x) =O[l] g", "start": [1182, 1], "end": [1183, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.symm", "code": "theorem IsLittleO.symm (h : (fun x => f\u2081 x - f\u2082 x) =o[l] g) : (fun x => f\u2082 x - f\u2081 x) =o[l] g", "start": [1186, 1], "end": [1187, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_comm", "code": "theorem isLittleO_comm : (fun x => f\u2081 x - f\u2082 x) =o[l] g \u2194 (fun x => f\u2082 x - f\u2081 x) =o[l] g", "start": [1190, 1], "end": [1191, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.triangle", "code": "theorem IsBigOWith.triangle (h\u2081 : IsBigOWith c l (fun x => f\u2081 x - f\u2082 x) g)\n    (h\u2082 : IsBigOWith c' l (fun x => f\u2082 x - f\u2083 x) g) :\n    IsBigOWith (c + c') l (fun x => f\u2081 x - f\u2083 x) g", "start": [1194, 1], "end": [1197, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.triangle", "code": "theorem IsBigO.triangle (h\u2081 : (fun x => f\u2081 x - f\u2082 x) =O[l] g)\n    (h\u2082 : (fun x => f\u2082 x - f\u2083 x) =O[l] g) : (fun x => f\u2081 x - f\u2083 x) =O[l] g", "start": [1200, 1], "end": [1202, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.triangle", "code": "theorem IsLittleO.triangle (h\u2081 : (fun x => f\u2081 x - f\u2082 x) =o[l] g)\n    (h\u2082 : (fun x => f\u2082 x - f\u2083 x) =o[l] g) : (fun x => f\u2081 x - f\u2083 x) =o[l] g", "start": [1205, 1], "end": [1207, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.congr_of_sub", "code": "theorem IsBigO.congr_of_sub (h : (fun x => f\u2081 x - f\u2082 x) =O[l] g) : f\u2081 =O[l] g \u2194 f\u2082 =O[l] g", "start": [1210, 1], "end": [1212, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.congr_of_sub", "code": "theorem IsLittleO.congr_of_sub (h : (fun x => f\u2081 x - f\u2082 x) =o[l] g) : f\u2081 =o[l] g \u2194 f\u2082 =o[l] g", "start": [1215, 1], "end": [1217, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_zero", "code": "theorem isLittleO_zero : (fun _x => (0 : E')) =o[l] g'", "start": [1229, 1], "end": [1231, 77], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_zero", "code": "theorem isBigOWith_zero (hc : 0 \u2264 c) : IsBigOWith c l (fun _x => (0 : E')) g'", "start": [1234, 1], "end": [1235, 95], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_zero'", "code": "theorem isBigOWith_zero' : IsBigOWith 0 l (fun _x => (0 : E')) g", "start": [1238, 1], "end": [1239, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_zero", "code": "theorem isBigO_zero : (fun _x => (0 : E')) =O[l] g", "start": [1242, 1], "end": [1243, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_refl_left", "code": "theorem isBigO_refl_left : (fun x => f' x - f' x) =O[l] g'", "start": [1246, 1], "end": [1247, 60], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_refl_left", "code": "theorem isLittleO_refl_left : (fun x => f' x - f' x) =o[l] g'", "start": [1250, 1], "end": [1251, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_zero_right_iff", "code": "@[simp]\ntheorem isBigOWith_zero_right_iff : (IsBigOWith c l f'' fun _x => (0 : F')) \u2194 f'' =\u1da0[l] 0", "start": [1256, 1], "end": [1259, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_zero_right_iff", "code": "@[simp]\ntheorem isBigO_zero_right_iff : (f'' =O[l] fun _x => (0 : F')) \u2194 f'' =\u1da0[l] 0", "start": [1262, 1], "end": [1267, 74], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_zero_right_iff", "code": "@[simp]\ntheorem isLittleO_zero_right_iff : (f'' =o[l] fun _x => (0 : F')) \u2194 f'' =\u1da0[l] 0", "start": [1270, 1], "end": [1273, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_const_const", "code": "theorem isBigOWith_const_const (c : E) {c' : F''} (hc' : c' \u2260 0) (l : Filter \u03b1) :\n    IsBigOWith (\u2016c\u2016 / \u2016c'\u2016) l (fun _x : \u03b1 => c) fun _x => c'", "start": [1276, 1], "end": [1283, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_const", "code": "theorem isBigO_const_const (c : E) {c' : F''} (hc' : c' \u2260 0) (l : Filter \u03b1) :\n    (fun _x : \u03b1 => c) =O[l] fun _x => c'", "start": [1286, 1], "end": [1288, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_const_iff", "code": "@[simp]\ntheorem isBigO_const_const_iff {c : E''} {c' : F''} (l : Filter \u03b1) [l.NeBot] :\n    ((fun _x : \u03b1 => c) =O[l] fun _x => c') \u2194 c' = 0 \u2192 c = 0", "start": [1291, 1], "end": [1296, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_pure", "code": "@[simp]\ntheorem isBigO_pure {x} : f'' =O[pure x] g'' \u2194 g'' x = 0 \u2192 f'' x = 0", "start": [1299, 1], "end": [1303, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_principal", "code": "@[simp]\ntheorem isBigOWith_principal {s : Set \u03b1} : IsBigOWith c (\ud835\udcdf s) f g \u2194 \u2200 x \u2208 s, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [1308, 1], "end": [1310, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_principal", "code": "theorem isBigO_principal {s : Set \u03b1} : f =O[\ud835\udcdf s] g \u2194 \u2203 c, \u2200 x \u2208 s, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [1313, 1], "end": [1314, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_principal", "code": "@[simp]\ntheorem isLittleO_principal {s : Set \u03b1} : f'' =o[\ud835\udcdf s] g' \u2194 \u2200 x \u2208 s, f'' x = 0", "start": [1317, 1], "end": [1328, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_top", "code": "@[simp]\ntheorem isBigOWith_top : IsBigOWith c \u22a4 f g \u2194 \u2200 x, \u2016f x\u2016 \u2264 c * \u2016g x\u2016", "start": [1330, 1], "end": [1331, 100], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_top", "code": "@[simp]\ntheorem isBigO_top : f =O[\u22a4] g \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C * \u2016g x\u2016", "start": [1334, 1], "end": [1335, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_top", "code": "@[simp]\ntheorem isLittleO_top : f'' =o[\u22a4] g' \u2194 \u2200 x, f'' x = 0", "start": [1338, 1], "end": [1340, 80], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_const_one", "code": "theorem isBigOWith_const_one (c : E) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016 l (fun _x : \u03b1 => c) fun _x => (1 : F)", "start": [1348, 1], "end": [1349, 85], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_one", "code": "theorem isBigO_const_one (c : E) (l : Filter \u03b1) : (fun _x : \u03b1 => c) =O[l] fun _x => (1 : F)", "start": [1352, 1], "end": [1353, 38], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_iff_isLittleO_one", "code": "theorem isLittleO_const_iff_isLittleO_one {c : F''} (hc : c \u2260 0) :\n    (f =o[l] fun _x => c) \u2194 f =o[l] fun _x => (1 : F)", "start": [1356, 1], "end": [1359, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_one_iff", "code": "@[simp]\ntheorem isLittleO_one_iff : f' =o[l] (fun _x => 1 : \u03b1 \u2192 F) \u2194 Tendsto f' l (\ud835\udcdd 0)", "start": [1362, 1], "end": [1365, 44], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_one_iff", "code": "@[simp]\ntheorem isBigO_one_iff : f =O[l] (fun _x => 1 : \u03b1 \u2192 F) \u2194\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x\u2016", "start": [1368, 1], "end": [1372, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.isBigO_one", "code": "alias \u27e8_, _root_.Filter.IsBoundedUnder.isBigO_one\u27e9 := isBigO_one_iff", "start": [1375, 1], "end": [1375, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_one_left_iff", "code": "@[simp]\ntheorem isLittleO_one_left_iff : (fun _x => 1 : \u03b1 \u2192 F) =o[l] f \u2194 Tendsto (fun x => \u2016f x\u2016) l atTop", "start": [1378, 1], "end": [1386, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isBigO_one", "code": "theorem _root_.Filter.Tendsto.isBigO_one {c : E'} (h : Tendsto f' l (\ud835\udcdd c)) :\n    f' =O[l] (fun _x => 1 : \u03b1 \u2192 F)", "start": [1389, 1], "end": [1391, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_tendsto_nhds", "code": "theorem IsBigO.trans_tendsto_nhds (hfg : f =O[l] g') {y : F'} (hg : Tendsto g' l (\ud835\udcdd y)) :\n    f =O[l] (fun _x => 1 : \u03b1 \u2192 F)", "start": [1394, 1], "end": [1396, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_iff", "code": "theorem isLittleO_const_iff {c : F''} (hc : c \u2260 0) :\n    (f'' =o[l] fun _x => c) \u2194 Tendsto f'' l (\ud835\udcdd 0)", "start": [1401, 1], "end": [1403, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_id_const", "code": "theorem isLittleO_id_const {c : F''} (hc : c \u2260 0) : (fun x : E'' => x) =o[\ud835\udcdd 0] fun _x => c", "start": [1406, 1], "end": [1407, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBoundedUnder.isBigO_const", "code": "theorem _root_.Filter.IsBoundedUnder.isBigO_const (h : IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f))\n    {c : F''} (hc : c \u2260 0) : f =O[l] fun _x => c", "start": [1410, 1], "end": [1412, 53], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_of_tendsto", "code": "theorem isBigO_const_of_tendsto {y : E''} (h : Tendsto f'' l (\ud835\udcdd y)) {c : F''} (hc : c \u2260 0) :\n    f'' =O[l] fun _x => c", "start": [1415, 1], "end": [1417, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.isBoundedUnder_le", "code": "theorem IsBigO.isBoundedUnder_le {c : F} (h : f =O[l] fun _x => c) :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f)", "start": [1420, 1], "end": [1423, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_of_ne", "code": "theorem isBigO_const_of_ne {c : F''} (hc : c \u2260 0) :\n    (f =O[l] fun _x => c) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f)", "start": [1426, 1], "end": [1428, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_iff", "code": "theorem isBigO_const_iff {c : F''} : (f'' =O[l] fun _x => c) \u2194\n    (c = 0 \u2192 f'' =\u1da0[l] 0) \u2227 IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f'' x\u2016", "start": [1431, 1], "end": [1436, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff_isBoundedUnder_le_div", "code": "theorem isBigO_iff_isBoundedUnder_le_div (h : \u2200\u1da0 x in l, g'' x \u2260 0) :\n    f =O[l] g'' \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x\u2016 / \u2016g'' x\u2016", "start": [1439, 1], "end": [1444, 84], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_left_iff_pos_le_norm", "code": "theorem isBigO_const_left_iff_pos_le_norm {c : E''} (hc : c \u2260 0) :\n    (fun _x => c) =O[l] f' \u2194 \u2203 b, 0 < b \u2227 \u2200\u1da0 x in l, b \u2264 \u2016f' x\u2016", "start": [1447, 1], "end": [1458, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_tendsto", "code": "theorem IsBigO.trans_tendsto (hfg : f'' =O[l] g'') (hg : Tendsto g'' l (\ud835\udcdd 0)) :\n    Tendsto f'' l (\ud835\udcdd 0)", "start": [1467, 1], "end": [1469, 79], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_tendsto", "code": "theorem IsLittleO.trans_tendsto (hfg : f'' =o[l] g'') (hg : Tendsto g'' l (\ud835\udcdd 0)) :\n    Tendsto f'' l (\ud835\udcdd 0)", "start": [1472, 1], "end": [1474, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_const_mul_self", "code": "theorem isBigOWith_const_mul_self (c : R) (f : \u03b1 \u2192 R) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016 l (fun x => c * f x) f", "start": [1480, 1], "end": [1482, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_mul_self", "code": "theorem isBigO_const_mul_self (c : R) (f : \u03b1 \u2192 R) (l : Filter \u03b1) : (fun x => c * f x) =O[l] f", "start": [1485, 1], "end": [1486, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.const_mul_left", "code": "theorem IsBigOWith.const_mul_left {f : \u03b1 \u2192 R} (h : IsBigOWith c l f g) (c' : R) :\n    IsBigOWith (\u2016c'\u2016 * c) l (fun x => c' * f x) g", "start": [1489, 1], "end": [1491, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.const_mul_left", "code": "theorem IsBigO.const_mul_left {f : \u03b1 \u2192 R} (h : f =O[l] g) (c' : R) : (fun x => c' * f x) =O[l] g", "start": [1494, 1], "end": [1496, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_self_const_mul'", "code": "theorem isBigOWith_self_const_mul' (u : R\u02e3) (f : \u03b1 \u2192 R) (l : Filter \u03b1) :\n    IsBigOWith \u2016(\u2191u\u207b\u00b9 : R)\u2016 l f fun x => \u2191u * f x", "start": [1499, 1], "end": [1502, 45], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_self_const_mul", "code": "theorem isBigOWith_self_const_mul (c : \ud835\udd5c) (hc : c \u2260 0) (f : \u03b1 \u2192 \ud835\udd5c) (l : Filter \u03b1) :\n    IsBigOWith \u2016c\u2016\u207b\u00b9 l f fun x => c * f x", "start": [1506, 1], "end": [1508, 78], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_self_const_mul'", "code": "theorem isBigO_self_const_mul' {c : R} (hc : IsUnit c) (f : \u03b1 \u2192 R) (l : Filter \u03b1) :\n    f =O[l] fun x => c * f x", "start": [1511, 1], "end": [1514, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_self_const_mul", "code": "theorem isBigO_self_const_mul (c : \ud835\udd5c) (hc : c \u2260 0) (f : \u03b1 \u2192 \ud835\udd5c) (l : Filter \u03b1) :\n    f =O[l] fun x => c * f x", "start": [1517, 1], "end": [1519, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_mul_left_iff'", "code": "theorem isBigO_const_mul_left_iff' {f : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) :\n    (fun x => c * f x) =O[l] g \u2194 f =O[l] g", "start": [1522, 1], "end": [1524, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_mul_left_iff", "code": "theorem isBigO_const_mul_left_iff {f : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x => c * f x) =O[l] g \u2194 f =O[l] g", "start": [1527, 1], "end": [1529, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.const_mul_left", "code": "theorem IsLittleO.const_mul_left {f : \u03b1 \u2192 R} (h : f =o[l] g) (c : R) : (fun x => c * f x) =o[l] g", "start": [1532, 1], "end": [1533, 50], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_mul_left_iff'", "code": "theorem isLittleO_const_mul_left_iff' {f : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) :\n    (fun x => c * f x) =o[l] g \u2194 f =o[l] g", "start": [1536, 1], "end": [1538, 81], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_mul_left_iff", "code": "theorem isLittleO_const_mul_left_iff {f : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x => c * f x) =o[l] g \u2194 f =o[l] g", "start": [1541, 1], "end": [1543, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_const_mul_right", "code": "theorem IsBigOWith.of_const_mul_right {g : \u03b1 \u2192 R} {c : R} (hc' : 0 \u2264 c')\n    (h : IsBigOWith c' l f fun x => c * g x) : IsBigOWith (c' * \u2016c\u2016) l f g", "start": [1546, 1], "end": [1548, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_const_mul_right", "code": "theorem IsBigO.of_const_mul_right {g : \u03b1 \u2192 R} {c : R} (h : f =O[l] fun x => c * g x) : f =O[l] g", "start": [1551, 1], "end": [1553, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.const_mul_right'", "code": "theorem IsBigOWith.const_mul_right' {g : \u03b1 \u2192 R} {u : R\u02e3} {c' : \u211d} (hc' : 0 \u2264 c')\n    (h : IsBigOWith c' l f g) : IsBigOWith (c' * \u2016(\u2191u\u207b\u00b9 : R)\u2016) l f fun x => \u2191u * g x", "start": [1556, 1], "end": [1558, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.const_mul_right", "code": "theorem IsBigOWith.const_mul_right {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) {c' : \u211d} (hc' : 0 \u2264 c')\n    (h : IsBigOWith c' l f g) : IsBigOWith (c' * \u2016c\u2016\u207b\u00b9) l f fun x => c * g x", "start": [1561, 1], "end": [1563, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.const_mul_right'", "code": "theorem IsBigO.const_mul_right' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) (h : f =O[l] g) :\n    f =O[l] fun x => c * g x", "start": [1566, 1], "end": [1568, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.const_mul_right", "code": "theorem IsBigO.const_mul_right {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) (h : f =O[l] g) :\n    f =O[l] fun x => c * g x", "start": [1571, 1], "end": [1573, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_mul_right_iff'", "code": "theorem isBigO_const_mul_right_iff' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) :\n    (f =O[l] fun x => c * g x) \u2194 f =O[l] g", "start": [1576, 1], "end": [1578, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_mul_right_iff", "code": "theorem isBigO_const_mul_right_iff {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =O[l] fun x => c * g x) \u2194 f =O[l] g", "start": [1581, 1], "end": [1583, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_const_mul_right", "code": "theorem IsLittleO.of_const_mul_right {g : \u03b1 \u2192 R} {c : R} (h : f =o[l] fun x => c * g x) :\n    f =o[l] g", "start": [1586, 1], "end": [1588, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.const_mul_right'", "code": "theorem IsLittleO.const_mul_right' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) (h : f =o[l] g) :\n    f =o[l] fun x => c * g x", "start": [1591, 1], "end": [1593, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.const_mul_right", "code": "theorem IsLittleO.const_mul_right {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) (h : f =o[l] g) :\n    f =o[l] fun x => c * g x", "start": [1596, 1], "end": [1598, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_mul_right_iff'", "code": "theorem isLittleO_const_mul_right_iff' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) :\n    (f =o[l] fun x => c * g x) \u2194 f =o[l] g", "start": [1601, 1], "end": [1603, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_mul_right_iff", "code": "theorem isLittleO_const_mul_right_iff {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =o[l] fun x => c * g x) \u2194 f =o[l] g", "start": [1606, 1], "end": [1608, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.mul", "code": "theorem IsBigOWith.mul {f\u2081 f\u2082 : \u03b1 \u2192 R} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c} {c\u2081 c\u2082 : \u211d} (h\u2081 : IsBigOWith c\u2081 l f\u2081 g\u2081)\n    (h\u2082 : IsBigOWith c\u2082 l f\u2082 g\u2082) :\n    IsBigOWith (c\u2081 * c\u2082) l (fun x => f\u2081 x * f\u2082 x) fun x => g\u2081 x * g\u2082 x", "start": [1614, 1], "end": [1621, 34], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.mul", "code": "theorem IsBigO.mul {f\u2081 f\u2082 : \u03b1 \u2192 R} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c} (h\u2081 : f\u2081 =O[l] g\u2081) (h\u2082 : f\u2082 =O[l] g\u2082) :\n    (fun x => f\u2081 x * f\u2082 x) =O[l] fun x => g\u2081 x * g\u2082 x", "start": [1624, 1], "end": [1628, 22], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.mul_isLittleO", "code": "theorem IsBigO.mul_isLittleO {f\u2081 f\u2082 : \u03b1 \u2192 R} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c} (h\u2081 : f\u2081 =O[l] g\u2081) (h\u2082 : f\u2082 =o[l] g\u2082) :\n    (fun x => f\u2081 x * f\u2082 x) =o[l] fun x => g\u2081 x * g\u2082 x", "start": [1631, 1], "end": [1636, 93], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.mul_isBigO", "code": "theorem IsLittleO.mul_isBigO {f\u2081 f\u2082 : \u03b1 \u2192 R} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c} (h\u2081 : f\u2081 =o[l] g\u2081) (h\u2082 : f\u2082 =O[l] g\u2082) :\n    (fun x => f\u2081 x * f\u2082 x) =o[l] fun x => g\u2081 x * g\u2082 x", "start": [1639, 1], "end": [1644, 92], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.mul", "code": "theorem IsLittleO.mul {f\u2081 f\u2082 : \u03b1 \u2192 R} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c} (h\u2081 : f\u2081 =o[l] g\u2081) (h\u2082 : f\u2082 =o[l] g\u2082) :\n    (fun x => f\u2081 x * f\u2082 x) =o[l] fun x => g\u2081 x * g\u2082 x", "start": [1647, 1], "end": [1649, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.pow'", "code": "theorem IsBigOWith.pow' {f : \u03b1 \u2192 R} {g : \u03b1 \u2192 \ud835\udd5c} (h : IsBigOWith c l f g) :\n    \u2200 n : \u2115, IsBigOWith (Nat.casesOn n \u2016(1 : R)\u2016 fun n => c ^ (n + 1))\n      l (fun x => f x ^ n) fun x => g x ^ n", "start": [1652, 1], "end": [1657, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.pow", "code": "theorem IsBigOWith.pow [NormOneClass R] {f : \u03b1 \u2192 R} {g : \u03b1 \u2192 \ud835\udd5c} (h : IsBigOWith c l f g) :\n    \u2200 n : \u2115, IsBigOWith (c ^ n) l (fun x => f x ^ n) fun x => g x ^ n", "start": [1660, 1], "end": [1663, 28], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.of_pow", "code": "theorem IsBigOWith.of_pow {n : \u2115} {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 R} (h : IsBigOWith c l (f ^ n) (g ^ n))\n    (hn : n \u2260 0) (hc : c \u2264 c' ^ n) (hc' : 0 \u2264 c') : IsBigOWith c' l f g", "start": [1666, 1], "end": [1675, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.pow", "code": "theorem IsBigO.pow {f : \u03b1 \u2192 R} {g : \u03b1 \u2192 \ud835\udd5c} (h : f =O[l] g) (n : \u2115) :\n    (fun x => f x ^ n) =O[l] fun x => g x ^ n", "start": [1678, 1], "end": [1681, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.of_pow", "code": "theorem IsBigO.of_pow {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 R} {n : \u2115} (hn : n \u2260 0) (h : (f ^ n) =O[l] (g ^ n)) :\n    f =O[l] g", "start": [1684, 1], "end": [1689, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.pow", "code": "theorem IsLittleO.pow {f : \u03b1 \u2192 R} {g : \u03b1 \u2192 \ud835\udd5c} (h : f =o[l] g) {n : \u2115} (hn : 0 < n) :\n    (fun x => f x ^ n) =o[l] fun x => g x ^ n", "start": [1692, 1], "end": [1697, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.of_pow", "code": "theorem IsLittleO.of_pow {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 R} {n : \u2115} (h : (f ^ n) =o[l] (g ^ n)) (hn : n \u2260 0) :\n    f =o[l] g", "start": [1700, 1], "end": [1702, 87], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.inv_rev", "code": "theorem IsBigOWith.inv_rev {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : IsBigOWith c l f g)\n    (h\u2080 : \u2200\u1da0 x in l, f x = 0 \u2192 g x = 0) : IsBigOWith c l (fun x => (g x)\u207b\u00b9) fun x => (f x)\u207b\u00b9", "start": [1708, 1], "end": [1715, 78], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.inv_rev", "code": "theorem IsBigO.inv_rev {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =O[l] g)\n    (h\u2080 : \u2200\u1da0 x in l, f x = 0 \u2192 g x = 0) : (fun x => (g x)\u207b\u00b9) =O[l] fun x => (f x)\u207b\u00b9", "start": [1718, 1], "end": [1721, 25], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.inv_rev", "code": "theorem IsLittleO.inv_rev {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =o[l] g)\n    (h\u2080 : \u2200\u1da0 x in l, f x = 0 \u2192 g x = 0) : (fun x => (g x)\u207b\u00b9) =o[l] fun x => (f x)\u207b\u00b9", "start": [1724, 1], "end": [1726, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.const_smul_left", "code": "theorem IsBigOWith.const_smul_left (h : IsBigOWith c l f' g) (c' : \ud835\udd5c) :\n    IsBigOWith (\u2016c'\u2016 * c) l (fun x => c' \u2022 f' x) g", "start": [1736, 1], "end": [1739, 83], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.const_smul_left", "code": "theorem IsBigO.const_smul_left (h : f' =O[l] g) (c : \ud835\udd5c) : (c \u2022 f') =O[l] g", "start": [1744, 1], "end": [1746, 32], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.const_smul_left", "code": "theorem IsLittleO.const_smul_left (h : f' =o[l] g) (c : \ud835\udd5c) : (c \u2022 f') =o[l] g", "start": [1749, 1], "end": [1750, 93], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_smul_left", "code": "theorem isBigO_const_smul_left {c : \ud835\udd5c} (hc : c \u2260 0) : (fun x => c \u2022 f' x) =O[l] g \u2194 f' =O[l] g", "start": [1753, 1], "end": [1757, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_smul_left", "code": "theorem isLittleO_const_smul_left {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x => c \u2022 f' x) =o[l] g \u2194 f' =o[l] g", "start": [1760, 1], "end": [1765, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_const_smul_right", "code": "theorem isBigO_const_smul_right {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =O[l] fun x => c \u2022 f' x) \u2194 f =O[l] f'", "start": [1768, 1], "end": [1773, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_smul_right", "code": "theorem isLittleO_const_smul_right {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =o[l] fun x => c \u2022 f' x) \u2194 f =o[l] f'", "start": [1776, 1], "end": [1781, 64], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.smul", "code": "theorem IsBigOWith.smul (h\u2081 : IsBigOWith c l k\u2081 k\u2082) (h\u2082 : IsBigOWith c' l f' g') :\n    IsBigOWith (c * c') l (fun x => k\u2081 x \u2022 f' x) fun x => k\u2082 x \u2022 g' x", "start": [1790, 1], "end": [1793, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.smul", "code": "theorem IsBigO.smul (h\u2081 : k\u2081 =O[l] k\u2082) (h\u2082 : f' =O[l] g') :\n    (fun x => k\u2081 x \u2022 f' x) =O[l] fun x => k\u2082 x \u2022 g' x", "start": [1796, 1], "end": [1799, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.smul_isLittleO", "code": "theorem IsBigO.smul_isLittleO (h\u2081 : k\u2081 =O[l] k\u2082) (h\u2082 : f' =o[l] g') :\n    (fun x => k\u2081 x \u2022 f' x) =o[l] fun x => k\u2082 x \u2022 g' x", "start": [1802, 1], "end": [1805, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.smul_isBigO", "code": "theorem IsLittleO.smul_isBigO (h\u2081 : k\u2081 =o[l] k\u2082) (h\u2082 : f' =O[l] g') :\n    (fun x => k\u2081 x \u2022 f' x) =o[l] fun x => k\u2082 x \u2022 g' x", "start": [1808, 1], "end": [1811, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.smul", "code": "theorem IsLittleO.smul (h\u2081 : k\u2081 =o[l] k\u2082) (h\u2082 : f' =o[l] g') :\n    (fun x => k\u2081 x \u2022 f' x) =o[l] fun x => k\u2082 x \u2022 g' x", "start": [1814, 1], "end": [1817, 36], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.sum", "code": "theorem IsBigOWith.sum (h : \u2200 i \u2208 s, IsBigOWith (C i) l (A i) g) :\n    IsBigOWith (\u2211 i in s, C i) l (fun x => \u2211 i in s, A i x) g", "start": [1829, 1], "end": [1834, 100], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.sum", "code": "theorem IsBigO.sum (h : \u2200 i \u2208 s, A i =O[l] g) : (fun x => \u2211 i in s, A i x) =O[l] g", "start": [1837, 1], "end": [1840, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.sum", "code": "theorem IsLittleO.sum (h : \u2200 i \u2208 s, A i =o[l] g') : (fun x => \u2211 i in s, A i x) =o[l] g'", "start": [1843, 1], "end": [1847, 100], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.tendsto_div_nhds_zero", "code": "theorem IsLittleO.tendsto_div_nhds_zero {f g : \u03b1 \u2192 \ud835\udd5c} (h : f =o[l] g) :\n    Tendsto (fun x => f x / g x) l (\ud835\udcdd 0)", "start": [1855, 1], "end": [1861, 85], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.tendsto_inv_smul_nhds_zero", "code": "theorem IsLittleO.tendsto_inv_smul_nhds_zero [NormedSpace \ud835\udd5c E'] {f : \u03b1 \u2192 E'} {g : \u03b1 \u2192 \ud835\udd5c}\n    {l : Filter \u03b1} (h : f =o[l] g) : Tendsto (fun x => (g x)\u207b\u00b9 \u2022 f x) l (\ud835\udcdd 0)", "start": [1864, 1], "end": [1867, 38], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_iff_tendsto'", "code": "theorem isLittleO_iff_tendsto' {f g : \u03b1 \u2192 \ud835\udd5c} (hgf : \u2200\u1da0 x in l, g x = 0 \u2192 f x = 0) :\n    f =o[l] g \u2194 Tendsto (fun x => f x / g x) l (\ud835\udcdd 0)", "start": [1870, 1], "end": [1874, 93], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_iff_tendsto", "code": "theorem isLittleO_iff_tendsto {f g : \u03b1 \u2192 \ud835\udd5c} (hgf : \u2200 x, g x = 0 \u2192 f x = 0) :\n    f =o[l] g \u2194 Tendsto (fun x => f x / g x) l (\ud835\udcdd 0)", "start": [1877, 1], "end": [1879, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_of_tendsto'", "code": "alias \u27e8_, isLittleO_of_tendsto'\u27e9 := isLittleO_iff_tendsto'", "start": [1882, 1], "end": [1882, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_of_tendsto", "code": "alias \u27e8_, isLittleO_of_tendsto\u27e9 := isLittleO_iff_tendsto", "start": [1885, 1], "end": [1885, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_const_left_of_ne", "code": "theorem isLittleO_const_left_of_ne {c : E''} (hc : c \u2260 0) :\n    (fun _x => c) =o[l] g \u2194 Tendsto (fun x => \u2016g x\u2016) l atTop", "start": [1888, 1], "end": [1892, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_left", "code": "@[simp]\ntheorem isLittleO_const_left {c : E''} :\n    (fun _x => c) =o[l] g'' \u2194 c = 0 \u2228 Tendsto (norm \u2218 g'') l atTop", "start": [1895, 1], "end": [1900, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_const_iff", "code": "@[simp 1001] theorem isLittleO_const_const_iff [NeBot l] {d : E''} {c : F''} :\n    ((fun _x => d) =o[l] fun _x => c) \u2194 d = 0", "start": [1903, 1], "end": [1909, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pure", "code": "@[simp]\ntheorem isLittleO_pure {x} : f'' =o[pure x] g'' \u2194 f'' x = 0", "start": [1912, 1], "end": [1916, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_id_comap_norm_atTop", "code": "theorem isLittleO_const_id_comap_norm_atTop (c : F'') :\n    (fun _x : E'' => c) =o[comap norm atTop] id", "start": [1919, 1], "end": [1921, 49], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_id_atTop", "code": "theorem isLittleO_const_id_atTop (c : E'') : (fun _x : \u211d => c) =o[atTop] id", "start": [1924, 1], "end": [1925, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_const_id_atBot", "code": "theorem isLittleO_const_id_atBot (c : E'') : (fun _x : \u211d => c) =o[atBot] id", "start": [1928, 1], "end": [1929, 59], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.eventually_mul_div_cancel", "code": "theorem IsBigOWith.eventually_mul_div_cancel (h : IsBigOWith c l u v) : u / v * v =\u1da0[l] u", "start": [1944, 1], "end": [1945, 93], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.eventually_mul_div_cancel", "code": "theorem IsBigO.eventually_mul_div_cancel (h : u =O[l] v) : u / v * v =\u1da0[l] u", "start": [1948, 1], "end": [1951, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.eventually_mul_div_cancel", "code": "theorem IsLittleO.eventually_mul_div_cancel (h : u =o[l] v) : u / v * v =\u1da0[l] u", "start": [1954, 1], "end": [1956, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_of_eq_mul", "code": "theorem isBigOWith_of_eq_mul (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (h\u03c6 : \u2200\u1da0 x in l, \u2016\u03c6 x\u2016 \u2264 c) (h : u =\u1da0[l] \u03c6 * v) :\n    IsBigOWith c l u v", "start": [1968, 1], "end": [1976, 9], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_iff_exists_eq_mul", "code": "theorem isBigOWith_iff_exists_eq_mul (hc : 0 \u2264 c) :\n    IsBigOWith c l u v \u2194 \u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (_h\u03c6 : \u2200\u1da0 x in l, \u2016\u03c6 x\u2016 \u2264 c), u =\u1da0[l] \u03c6 * v", "start": [1979, 1], "end": [1987, 38], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.exists_eq_mul", "code": "theorem IsBigOWith.exists_eq_mul (h : IsBigOWith c l u v) (hc : 0 \u2264 c) :\n    \u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (_h\u03c6 : \u2200\u1da0 x in l, \u2016\u03c6 x\u2016 \u2264 c), u =\u1da0[l] \u03c6 * v", "start": [1990, 1], "end": [1992, 41], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff_exists_eq_mul", "code": "theorem isBigO_iff_exists_eq_mul :\n    u =O[l] v \u2194 \u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (_h\u03c6 : l.IsBoundedUnder (\u00b7 \u2264 \u00b7) (norm \u2218 \u03c6)), u =\u1da0[l] \u03c6 * v", "start": [1995, 1], "end": [2003, 70], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.exists_eq_mul", "code": "alias \u27e8IsBigO.exists_eq_mul, _\u27e9 := isBigO_iff_exists_eq_mul", "start": [2006, 1], "end": [2006, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isLittleO_iff_exists_eq_mul", "code": "theorem isLittleO_iff_exists_eq_mul :\n    u =o[l] v \u2194 \u2203 (\u03c6 : \u03b1 \u2192 \ud835\udd5c) (_h\u03c6 : Tendsto \u03c6 l (\ud835\udcdd 0)), u =\u1da0[l] \u03c6 * v", "start": [2009, 1], "end": [2016, 75], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.exists_eq_mul", "code": "alias \u27e8IsLittleO.exists_eq_mul, _\u27e9 := isLittleO_iff_exists_eq_mul", "start": [2019, 1], "end": [2019, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.div_isBoundedUnder_of_isBigO", "code": "theorem div_isBoundedUnder_of_isBigO {\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c} (h : f =O[l] g) :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x / g x\u2016", "start": [2027, 1], "end": [2032, 57], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_iff_div_isBoundedUnder", "code": "theorem isBigO_iff_div_isBoundedUnder {\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c}\n    (hgf : \u2200\u1da0 x in l, g x = 0 \u2192 f x = 0) :\n    f =O[l] g \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x / g x\u2016", "start": [2035, 1], "end": [2044, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_of_div_tendsto_nhds", "code": "theorem isBigO_of_div_tendsto_nhds {\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c}\n    (hgf : \u2200\u1da0 x in l, g x = 0 \u2192 f x = 0) (c : \ud835\udd5c) (H : Filter.Tendsto (f / g) l (\ud835\udcdd c)) :\n    f =O[l] g", "start": [2047, 1], "end": [2050, 68], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.tendsto_zero_of_tendsto", "code": "theorem IsLittleO.tendsto_zero_of_tendsto {\u03b1 E \ud835\udd5c : Type*} [NormedAddCommGroup E] [NormedField \ud835\udd5c]\n    {u : \u03b1 \u2192 E} {v : \u03b1 \u2192 \ud835\udd5c} {l : Filter \u03b1} {y : \ud835\udd5c} (huv : u =o[l] v) (hv : Tendsto v l (\ud835\udcdd y)) :\n    Tendsto u l (\ud835\udcdd 0)", "start": [2053, 1], "end": [2058, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pow_pow", "code": "theorem isLittleO_pow_pow {m n : \u2115} (h : m < n) : (fun x : \ud835\udd5c => x ^ n) =o[\ud835\udcdd 0] fun x => x ^ m", "start": [2061, 1], "end": [2066, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_norm_pow_norm_pow", "code": "theorem isLittleO_norm_pow_norm_pow {m n : \u2115} (h : m < n) :\n    (fun x : E' => \u2016x\u2016 ^ n) =o[\ud835\udcdd 0] fun x => \u2016x\u2016 ^ m", "start": [2069, 1], "end": [2071, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pow_id", "code": "theorem isLittleO_pow_id {n : \u2115} (h : 1 < n) : (fun x : \ud835\udd5c => x ^ n) =o[\ud835\udcdd 0] fun x => x", "start": [2074, 1], "end": [2076, 22], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_norm_pow_id", "code": "theorem isLittleO_norm_pow_id {n : \u2115} (h : 1 < n) :\n    (fun x : E' => \u2016x\u2016 ^ n) =o[\ud835\udcdd 0] fun x => x", "start": [2079, 1], "end": [2083, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.eq_zero_of_norm_pow_within", "code": "theorem IsBigO.eq_zero_of_norm_pow_within {f : E'' \u2192 F''} {s : Set E''} {x\u2080 : E''} {n : \u2115}\n    (h : f =O[\ud835\udcdd[s] x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n) (hx\u2080 : x\u2080 \u2208 s) (hn : 0 < n) : f x\u2080 = 0", "start": [2086, 1], "end": [2088, 91], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.eq_zero_of_norm_pow", "code": "theorem IsBigO.eq_zero_of_norm_pow {f : E'' \u2192 F''} {x\u2080 : E''} {n : \u2115}\n    (h : f =O[\ud835\udcdd x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n) (hn : 0 < n) : f x\u2080 = 0", "start": [2091, 1], "end": [2094, 53], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pow_sub_pow_sub", "code": "theorem isLittleO_pow_sub_pow_sub (x\u2080 : E') {n m : \u2115} (h : n < m) :\n    (fun x => \u2016x - x\u2080\u2016 ^ m) =o[\ud835\udcdd x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n", "start": [2097, 1], "end": [2103, 42], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pow_sub_sub", "code": "theorem isLittleO_pow_sub_sub (x\u2080 : E') {m : \u2115} (h : 1 < m) :\n    (fun x => \u2016x - x\u2080\u2016 ^ m) =o[\ud835\udcdd x\u2080] fun x => x - x\u2080", "start": [2106, 1], "end": [2108, 82], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.right_le_sub_of_lt_1", "code": "theorem IsBigOWith.right_le_sub_of_lt_1 {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h : IsBigOWith c l f\u2081 f\u2082) (hc : c < 1) :\n    IsBigOWith (1 / (1 - c)) l f\u2082 fun x => f\u2082 x - f\u2081 x", "start": [2111, 1], "end": [2118, 27], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigOWith.right_le_add_of_lt_1", "code": "theorem IsBigOWith.right_le_add_of_lt_1 {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h : IsBigOWith c l f\u2081 f\u2082) (hc : c < 1) :\n    IsBigOWith (1 / (1 - c)) l f\u2082 fun x => f\u2081 x + f\u2082 x", "start": [2121, 1], "end": [2124, 33], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.right_isBigO_sub", "code": "theorem IsLittleO.right_isBigO_sub {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h : f\u2081 =o[l] f\u2082) :\n    f\u2082 =O[l] fun x => f\u2082 x - f\u2081 x", "start": [2127, 1], "end": [2129, 70], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.right_isBigO_add", "code": "theorem IsLittleO.right_isBigO_add {f\u2081 f\u2082 : \u03b1 \u2192 E'} (h : f\u2081 =o[l] f\u2082) :\n    f\u2082 =O[l] fun x => f\u2081 x + f\u2082 x", "start": [2132, 1], "end": [2134, 70], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.bound_of_isBigO_cofinite", "code": "theorem bound_of_isBigO_cofinite (h : f =O[cofinite] g'') :\n    \u2203 C > 0, \u2200 \u2983x\u2984, g'' x \u2260 0 \u2192 \u2016f x\u2016 \u2264 C * \u2016g'' x\u2016", "start": [2137, 1], "end": [2147, 65], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_cofinite_iff", "code": "theorem isBigO_cofinite_iff (h : \u2200 x, g'' x = 0 \u2192 f'' x = 0) :\n    f'' =O[cofinite] g'' \u2194 \u2203 C, \u2200 x, \u2016f'' x\u2016 \u2264 C * \u2016g'' x\u2016", "start": [2150, 1], "end": [2155, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.bound_of_isBigO_nat_atTop", "code": "theorem bound_of_isBigO_nat_atTop {f : \u2115 \u2192 E} {g'' : \u2115 \u2192 E''} (h : f =O[atTop] g'') :\n    \u2203 C > 0, \u2200 \u2983x\u2984, g'' x \u2260 0 \u2192 \u2016f x\u2016 \u2264 C * \u2016g'' x\u2016", "start": [2158, 1], "end": [2160, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_nat_atTop_iff", "code": "theorem isBigO_nat_atTop_iff {f : \u2115 \u2192 E''} {g : \u2115 \u2192 F''} (h : \u2200 x, g x = 0 \u2192 f x = 0) :\n    f =O[atTop] g \u2194 \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C * \u2016g x\u2016", "start": [2163, 1], "end": [2165, 54], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_one_nat_atTop_iff", "code": "theorem isBigO_one_nat_atTop_iff {f : \u2115 \u2192 E''} :\n    f =O[atTop] (fun _n => 1 : \u2115 \u2192 \u211d) \u2194 \u2203 C, \u2200 n, \u2016f n\u2016 \u2264 C", "start": [2168, 1], "end": [2171, 34], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigOWith_pi", "code": "theorem isBigOWith_pi {\u03b9 : Type*} [Fintype \u03b9] {E' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E' i)]\n    {f : \u03b1 \u2192 \u2200 i, E' i} {C : \u211d} (hC : 0 \u2264 C) :\n    IsBigOWith C l f g' \u2194 \u2200 i, IsBigOWith C l (fun x => f x i) g'", "start": [2174, 1], "end": [2178, 80], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_pi", "code": "@[simp]\ntheorem isBigO_pi {\u03b9 : Type*} [Fintype \u03b9] {E' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E' i)]\n    {f : \u03b1 \u2192 \u2200 i, E' i} : f =O[l] g' \u2194 \u2200 i, (fun x => f x i) =O[l] g'", "start": [2181, 1], "end": [2185, 74], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isLittleO_pi", "code": "@[simp]\ntheorem isLittleO_pi {\u03b9 : Type*} [Fintype \u03b9] {E' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E' i)]\n    {f : \u03b1 \u2192 \u2200 i, E' i} : f =o[l] g' \u2194 \u2200 i, (fun x => f x i) =o[l] g'", "start": [2188, 1], "end": [2192, 57], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.nat_cast_atTop", "code": "theorem IsBigO.nat_cast_atTop {R : Type*} [StrictOrderedSemiring R] [Archimedean R]\n    {f : R \u2192 E} {g : R \u2192 F} (h : f =O[atTop] g) :\n    (fun (n:\u2115) => f n) =O[atTop] (fun n => g n)", "start": [2195, 1], "end": [2198, 53], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.nat_cast_atTop", "code": "theorem IsLittleO.nat_cast_atTop {R : Type*} [StrictOrderedSemiring R] [Archimedean R]\n    {f : R \u2192 E} {g : R \u2192 F} (h : f =o[atTop] g) :\n    (fun (n:\u2115) => f n) =o[atTop] (fun n => g n)", "start": [2200, 1], "end": [2203, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_atTop_iff_eventually_exists", "code": "theorem isBigO_atTop_iff_eventually_exists {\u03b1 : Type*} [SemilatticeSup \u03b1] [Nonempty \u03b1]\n    {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} : f =O[atTop] g \u2194 \u2200\u1da0 n\u2080 in atTop, \u2203 c, \u2200 n \u2265 n\u2080, \u2016f n\u2016 \u2264 c * \u2016g n\u2016", "start": [2205, 1], "end": [2207, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isBigO_atTop_iff_eventually_exists_pos", "code": "theorem isBigO_atTop_iff_eventually_exists_pos {\u03b1 : Type*}\n    [SemilatticeSup \u03b1] [Nonempty \u03b1] {f : \u03b1 \u2192 G} {g : \u03b1 \u2192 G'} :\n    f =O[atTop] g \u2194 \u2200\u1da0 n\u2080 in atTop, \u2203 c > 0, \u2200 n \u2265 n\u2080, c * \u2016f n\u2016 \u2264 \u2016g n\u2016", "start": [2209, 1], "end": [2212, 82], "kind": "commanddeclaration"}, {"full_name": "summable_of_isBigO", "code": "theorem summable_of_isBigO {\u03b9 E} [NormedAddCommGroup E] [CompleteSpace E] {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d}\n    (hg : Summable g) (h : f =O[cofinite] g) : Summable f", "start": [2218, 1], "end": [2221, 88], "kind": "commanddeclaration"}, {"full_name": "summable_of_isBigO_nat", "code": "theorem summable_of_isBigO_nat {E} [NormedAddCommGroup E] [CompleteSpace E] {f : \u2115 \u2192 E} {g : \u2115 \u2192 \u211d}\n    (hg : Summable g) (h : f =O[atTop] g) : Summable f", "start": [2225, 1], "end": [2227, 58], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.isBigOWith_congr", "code": "theorem isBigOWith_congr (e : LocalHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E}\n    {g : \u03b2 \u2192 F} {C : \u211d} : IsBigOWith C (\ud835\udcdd b) f g \u2194 IsBigOWith C (\ud835\udcdd (e.symm b)) (f \u2218 e) (g \u2218 e)", "start": [2237, 1], "end": [2247, 73], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.isBigO_congr", "code": "theorem isBigO_congr (e : LocalHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n    f =O[\ud835\udcdd b] g \u2194 (f \u2218 e) =O[\ud835\udcdd (e.symm b)] (g \u2218 e)", "start": [2251, 1], "end": [2255, 52], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.isLittleO_congr", "code": "theorem isLittleO_congr (e : LocalHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E}\n    {g : \u03b2 \u2192 F} : f =o[\ud835\udcdd b] g \u2194 (f \u2218 e) =o[\ud835\udcdd (e.symm b)] (g \u2218 e)", "start": [2259, 1], "end": [2263, 57], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isBigOWith_congr", "code": "theorem isBigOWith_congr (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} {C : \u211d} :\n    IsBigOWith C (\ud835\udcdd b) f g \u2194 IsBigOWith C (\ud835\udcdd (e.symm b)) (f \u2218 e) (g \u2218 e)", "start": [2277, 1], "end": [2280, 47], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isBigO_congr", "code": "theorem isBigO_congr (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n    f =O[\ud835\udcdd b] g \u2194 (f \u2218 e) =O[\ud835\udcdd (e.symm b)] (g \u2218 e)", "start": [2284, 1], "end": [2288, 49], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isLittleO_congr", "code": "theorem isLittleO_congr (e : \u03b1 \u2243\u209c \u03b2) {b : \u03b2} {f : \u03b2 \u2192 E} {g : \u03b2 \u2192 F} :\n    f =o[\ud835\udcdd b] g \u2194 (f \u2218 e) =o[\ud835\udcdd (e.symm b)] (g \u2218 e)", "start": [2292, 1], "end": [2296, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Order.lean", "imports": ["Mathlib/Data/Complex/Module.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.partialOrder", "code": "protected def partialOrder : PartialOrder \u2102 where\n  le z w := z.re \u2264 w.re \u2227 z.im = w.im\n  lt z w := z.re < w.re \u2227 z.im = w.im\n  lt_iff_le_not_le z w := by\n    dsimp\n    rw [lt_iff_le_not_le]\n    tauto\n  le_refl x := \u27e8le_rfl, rfl\u27e9\n  le_trans x y z h\u2081 h\u2082 := \u27e8h\u2081.1.trans h\u2082.1, h\u2081.2.trans h\u2082.2\u27e9\n  le_antisymm z w h\u2081 h\u2082 := ext (h\u2081.1.antisymm h\u2082.1) h\u2081.2", "start": [31, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.le_def", "code": "theorem le_def {z w : \u2102} : z \u2264 w \u2194 z.re \u2264 w.re \u2227 z.im = w.im", "start": [55, 1], "end": [56, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.lt_def", "code": "theorem lt_def {z w : \u2102} : z < w \u2194 z.re < w.re \u2227 z.im = w.im", "start": [59, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.real_le_real", "code": "@[simp, norm_cast]\ntheorem real_le_real {x y : \u211d} : (x : \u2102) \u2264 (y : \u2102) \u2194 x \u2264 y", "start": [64, 1], "end": [65, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.real_lt_real", "code": "@[simp, norm_cast]\ntheorem real_lt_real {x y : \u211d} : (x : \u2102) < (y : \u2102) \u2194 x < y", "start": [68, 1], "end": [69, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_le_real", "code": "@[simp, norm_cast]\ntheorem zero_le_real {x : \u211d} : (0 : \u2102) \u2264 (x : \u2102) \u2194 0 \u2264 x", "start": [73, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.zero_lt_real", "code": "@[simp, norm_cast]\ntheorem zero_lt_real {x : \u211d} : (0 : \u2102) < (x : \u2102) \u2194 0 < x", "start": [78, 1], "end": [80, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.not_le_iff", "code": "theorem not_le_iff {z w : \u2102} : \u00acz \u2264 w \u2194 w.re < z.re \u2228 z.im \u2260 w.im", "start": [83, 1], "end": [84, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.not_lt_iff", "code": "theorem not_lt_iff {z w : \u2102} : \u00acz < w \u2194 w.re \u2264 z.re \u2228 z.im \u2260 w.im", "start": [87, 1], "end": [88, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.not_le_zero_iff", "code": "theorem not_le_zero_iff {z : \u2102} : \u00acz \u2264 0 \u2194 0 < z.re \u2228 z.im \u2260 0", "start": [91, 1], "end": [92, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.not_lt_zero_iff", "code": "theorem not_lt_zero_iff {z : \u2102} : \u00acz < 0 \u2194 0 \u2264 z.re \u2228 z.im \u2260 0", "start": [95, 1], "end": [96, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.eq_re_ofReal_le", "code": "theorem eq_re_ofReal_le {r : \u211d} {z : \u2102} (hz : (r : \u2102) \u2264 z) : z = z.re", "start": [99, 1], "end": [102, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Exponential.lean", "imports": ["Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Algebra/GeomSum.lean", "Mathlib/Data/Complex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isCauSeq_of_decreasing_bounded", "code": "theorem isCauSeq_of_decreasing_bounded (f : \u2115 \u2192 \u03b1) {a : \u03b1} {m : \u2115} (ham : \u2200 n \u2265 m, |f n| \u2264 a)\n    (hnm : \u2200 n \u2265 m, f n.succ \u2264 f n) : IsCauSeq abs f", "start": [37, 1], "end": [68, 64], "kind": "commanddeclaration"}, {"full_name": "isCauSeq_of_mono_bounded", "code": "theorem isCauSeq_of_mono_bounded (f : \u2115 \u2192 \u03b1) {a : \u03b1} {m : \u2115} (ham : \u2200 n \u2265 m, |f n| \u2264 a)\n    (hnm : \u2200 n \u2265 m, f n \u2264 f n.succ) : IsCauSeq abs f", "start": [71, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "isCauSeq_series_of_abv_le_of_isCauSeq", "code": "theorem isCauSeq_series_of_abv_le_of_isCauSeq {f : \u2115 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} (n : \u2115) :\n    (\u2200 m, n \u2264 m \u2192 abv (f m) \u2264 g m) \u2192\n      (IsCauSeq abs fun n => \u2211 i in range n, g i) \u2192 IsCauSeq abv fun n => \u2211 i in range n, f i", "start": [88, 1], "end": [114, 91], "kind": "commanddeclaration"}, {"full_name": "isCauSeq_series_of_abv_isCauSeq", "code": "theorem isCauSeq_series_of_abv_isCauSeq {f : \u2115 \u2192 \u03b2} :\n    (IsCauSeq abs fun m => \u2211 n in range m, abv (f n)) \u2192 IsCauSeq abv fun m => \u2211 n in range m, f n", "start": [117, 1], "end": [119, 60], "kind": "commanddeclaration"}, {"full_name": "isCauSeq_geo_series", "code": "theorem isCauSeq_geo_series {\u03b2 : Type*} [Ring \u03b2] [Nontrivial \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]\n    (x : \u03b2) (hx1 : abv x < 1) : IsCauSeq abv fun n => \u2211 m in range n, x ^ m", "start": [128, 1], "end": [145, 16], "kind": "commanddeclaration"}, {"full_name": "isCauSeq_geo_series_const", "code": "theorem isCauSeq_geo_series_const (a : \u03b1) {x : \u03b1} (hx1 : |x| < 1) :\n    IsCauSeq abs fun m => \u2211 n in range m, (a * x ^ n)", "start": [148, 1], "end": [153, 29], "kind": "commanddeclaration"}, {"full_name": "series_ratio_test", "code": "theorem series_ratio_test {f : \u2115 \u2192 \u03b2} (n : \u2115) (r : \u03b1) (hr0 : 0 \u2264 r) (hr1 : r < 1)\n    (h : \u2200 m, n \u2264 m \u2192 abv (f m.succ) \u2264 r * abv (f m)) :\n    IsCauSeq abv fun m => \u2211 n in range m, f n", "start": [158, 1], "end": [182, 33], "kind": "commanddeclaration"}, {"full_name": "sum_range_diag_flip", "code": "theorem sum_range_diag_flip {\u03b1 : Type*} [AddCommMonoid \u03b1] (n : \u2115) (f : \u2115 \u2192 \u2115 \u2192 \u03b1) :\n    (\u2211 m in range n, \u2211 k in range (m + 1), f k (m - k)) =\n      \u2211 m in range n, \u2211 k in range (n - m), f m k", "start": [185, 1], "end": [213, 81], "kind": "commanddeclaration"}, {"full_name": "abv_sum_le_sum_abv", "code": "theorem abv_sum_le_sum_abv {\u03b3 : Type*} (f : \u03b3 \u2192 \u03b2) (s : Finset \u03b3) :\n    abv (\u2211 k in s, f k) \u2264 \u2211 k in s, abv (f k)", "start": [226, 1], "end": [230, 97], "kind": "commanddeclaration"}, {"full_name": "cauchy_product", "code": "theorem cauchy_product {a b : \u2115 \u2192 \u03b2} (ha : IsCauSeq abs fun m => \u2211 n in range m, abv (a n))\n    (hb : IsCauSeq abv fun m => \u2211 n in range m, b n) (\u03b5 : \u03b1) (\u03b50 : 0 < \u03b5) :\n    \u2203 i : \u2115,\n      \u2200 j \u2265 i,\n        abv\n            (((\u2211 k in range j, a k) * \u2211 k in range j, b k) -\n              \u2211 n in range j, \u2211 m in range (n + 1), a m * b (n - m)) <\n          \u03b5", "start": [239, 1], "end": [336, 8], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_abs_exp", "code": "theorem isCauSeq_abs_exp (z : \u2102) :\n    IsCauSeq Abs.abs fun n => \u2211 m in range n, abs (z ^ m / m.factorial)", "start": [351, 1], "end": [360, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.isCauSeq_exp", "code": "theorem isCauSeq_exp (z : \u2102) : IsCauSeq abs fun n => \u2211 m in range n, z ^ m / m.factorial", "start": [365, 1], "end": [366, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.exp'", "code": "def exp' (z : \u2102) : CauSeq \u2102 Complex.abs :=\n  \u27e8fun n => \u2211 m in range n, z ^ m / m.factorial, isCauSeq_exp z\u27e9", "start": [369, 1], "end": [373, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.exp", "code": "def exp (z : \u2102) : \u2102 :=\n  CauSeq.lim (exp' z)", "start": [376, 1], "end": [380, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.sin", "code": "def sin (z : \u2102) : \u2102 :=\n  (exp (-z * I) - exp (z * I)) * I / 2", "start": [383, 1], "end": [386, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.cos", "code": "def cos (z : \u2102) : \u2102 :=\n  (exp (z * I) + exp (-z * I)) / 2", "start": [389, 1], "end": [392, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.tan", "code": "def tan (z : \u2102) : \u2102 :=\n  sin z / cos z", "start": [395, 1], "end": [398, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh", "code": "def sinh (z : \u2102) : \u2102 :=\n  (exp z - exp (-z)) / 2", "start": [401, 1], "end": [404, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh", "code": "def cosh (z : \u2102) : \u2102 :=\n  (exp z + exp (-z)) / 2", "start": [407, 1], "end": [410, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh", "code": "def tanh (z : \u2102) : \u2102 :=\n  sinh z / cosh z", "start": [413, 1], "end": [416, 18], "kind": "commanddeclaration"}, {"full_name": "Real.exp", "code": "nonrec def exp (x : \u211d) : \u211d :=\n  (exp x).re", "start": [432, 1], "end": [435, 13], "kind": "commanddeclaration"}, {"full_name": "Real.sin", "code": "nonrec def sin (x : \u211d) : \u211d :=\n  (sin x).re", "start": [438, 1], "end": [441, 13], "kind": "commanddeclaration"}, {"full_name": "Real.cos", "code": "nonrec def cos (x : \u211d) : \u211d :=\n  (cos x).re", "start": [444, 1], "end": [447, 13], "kind": "commanddeclaration"}, {"full_name": "Real.tan", "code": "nonrec def tan (x : \u211d) : \u211d :=\n  (tan x).re", "start": [450, 1], "end": [453, 13], "kind": "commanddeclaration"}, {"full_name": "Real.sinh", "code": "nonrec def sinh (x : \u211d) : \u211d :=\n  (sinh x).re", "start": [456, 1], "end": [459, 14], "kind": "commanddeclaration"}, {"full_name": "Real.cosh", "code": "nonrec def cosh (x : \u211d) : \u211d :=\n  (cosh x).re", "start": [462, 1], "end": [465, 14], "kind": "commanddeclaration"}, {"full_name": "Real.tanh", "code": "nonrec def tanh (x : \u211d) : \u211d :=\n  (tanh x).re", "start": [468, 1], "end": [472, 14], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_zero", "code": "@[simp]\ntheorem exp_zero : exp 0 = 1", "start": [486, 1], "end": [498, 11], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_add", "code": "theorem exp_add : exp (x + y) = exp x * exp y", "start": [501, 1], "end": [520, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.expMonoidHom", "code": "noncomputable def expMonoidHom : MonoidHom (Multiplicative \u2102) \u2102 :=\n  { toFun := fun z => exp (Multiplicative.toAdd z),\n    map_one' := by simp,\n    map_mul' := by simp [exp_add] }", "start": [524, 1], "end": [528, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_list_sum", "code": "theorem exp_list_sum (l : List \u2102) : exp l.sum = (l.map exp).prod", "start": [530, 1], "end": [531, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_multiset_sum", "code": "theorem exp_multiset_sum (s : Multiset \u2102) : exp s.sum = (s.map exp).prod", "start": [534, 1], "end": [535, 71], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_sum", "code": "theorem exp_sum {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2102) :\n    exp (\u2211 x in s, f x) = \u220f x in s, exp (f x)", "start": [538, 1], "end": [540, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_nat_mul", "code": "theorem exp_nat_mul (x : \u2102) : \u2200 n : \u2115, exp (n * x) = exp x ^ n", "start": [543, 1], "end": [545, 100], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_ne_zero", "code": "theorem exp_ne_zero : exp x \u2260 0", "start": [548, 1], "end": [549, 72], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_neg", "code": "theorem exp_neg : exp (-x) = (exp x)\u207b\u00b9", "start": [552, 1], "end": [553, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_sub", "code": "theorem exp_sub : exp (x - y) = exp x / exp y", "start": [556, 1], "end": [557, 58], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_int_mul", "code": "theorem exp_int_mul (z : \u2102) (n : \u2124) : Complex.exp (n * z) = Complex.exp z ^ n", "start": [560, 1], "end": [563, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_conj", "code": "@[simp]\ntheorem exp_conj : exp (conj x) = conj (exp x)", "start": [566, 1], "end": [574, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_exp_ofReal_re", "code": "@[simp]\ntheorem ofReal_exp_ofReal_re (x : \u211d) : ((exp x).re : \u2102) = exp x", "start": [577, 1], "end": [579, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_exp", "code": "@[simp, norm_cast]\ntheorem ofReal_exp (x : \u211d) : (Real.exp x : \u2102) = exp x", "start": [582, 1], "end": [584, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_ofReal_im", "code": "@[simp]\ntheorem exp_ofReal_im (x : \u211d) : (exp x).im = 0", "start": [587, 1], "end": [588, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_ofReal_re", "code": "theorem exp_ofReal_re (x : \u211d) : (exp x).re = Real.exp x", "start": [591, 1], "end": [592, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.two_sinh", "code": "theorem two_sinh : 2 * sinh x = exp x - exp (-x)", "start": [595, 1], "end": [596, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.two_cosh", "code": "theorem two_cosh : 2 * cosh x = exp x + exp (-x)", "start": [599, 1], "end": [600, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_zero", "code": "@[simp]\ntheorem sinh_zero : sinh 0 = 0", "start": [603, 1], "end": [604, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_neg", "code": "@[simp]\ntheorem sinh_neg : sinh (-x) = -sinh x", "start": [607, 1], "end": [608, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_add_aux", "code": "private theorem sinh_add_aux {a b c d : \u2102} :\n    (a - b) * (c + d) + (a + b) * (c - d) = 2 * (a * c - b * d)", "start": [611, 1], "end": [612, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_add", "code": "theorem sinh_add : sinh (x + y) = sinh x * cosh y + cosh x * sinh y", "start": [614, 1], "end": [618, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_zero", "code": "@[simp]\ntheorem cosh_zero : cosh 0 = 1", "start": [621, 1], "end": [622, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_neg", "code": "@[simp]\ntheorem cosh_neg : cosh (-x) = cosh x", "start": [625, 1], "end": [626, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_add_aux", "code": "private theorem cosh_add_aux {a b c d : \u2102} :\n    (a + b) * (c + d) + (a - b) * (c - d) = 2 * (a * c + b * d)", "start": [629, 1], "end": [630, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_add", "code": "theorem cosh_add : cosh (x + y) = cosh x * cosh y + sinh x * sinh y", "start": [632, 1], "end": [636, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_sub", "code": "theorem sinh_sub : sinh (x - y) = sinh x * cosh y - cosh x * sinh y", "start": [639, 1], "end": [640, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_sub", "code": "theorem cosh_sub : cosh (x - y) = cosh x * cosh y - sinh x * sinh y", "start": [643, 1], "end": [644, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_conj", "code": "theorem sinh_conj : sinh (conj x) = conj (sinh x)", "start": [647, 1], "end": [650, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sinh_ofReal_re", "code": "@[simp]\ntheorem ofReal_sinh_ofReal_re (x : \u211d) : ((sinh x).re : \u2102) = sinh x", "start": [653, 1], "end": [655, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sinh", "code": "@[simp, norm_cast]\ntheorem ofReal_sinh (x : \u211d) : (Real.sinh x : \u2102) = sinh x", "start": [658, 1], "end": [660, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_ofReal_im", "code": "@[simp]\ntheorem sinh_ofReal_im (x : \u211d) : (sinh x).im = 0", "start": [663, 1], "end": [664, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_ofReal_re", "code": "theorem sinh_ofReal_re (x : \u211d) : (sinh x).re = Real.sinh x", "start": [667, 1], "end": [668, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_conj", "code": "theorem cosh_conj : cosh (conj x) = conj (cosh x)", "start": [671, 1], "end": [674, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cosh_ofReal_re", "code": "theorem ofReal_cosh_ofReal_re (x : \u211d) : ((cosh x).re : \u2102) = cosh x", "start": [677, 1], "end": [678, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cosh", "code": "@[simp, norm_cast]\ntheorem ofReal_cosh (x : \u211d) : (Real.cosh x : \u2102) = cosh x", "start": [681, 1], "end": [683, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_ofReal_im", "code": "@[simp]\ntheorem cosh_ofReal_im (x : \u211d) : (cosh x).im = 0", "start": [686, 1], "end": [687, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_ofReal_re", "code": "@[simp]\ntheorem cosh_ofReal_re (x : \u211d) : (cosh x).re = Real.cosh x", "start": [690, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_eq_sinh_div_cosh", "code": "theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x", "start": [695, 1], "end": [696, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_zero", "code": "@[simp]\ntheorem tanh_zero : tanh 0 = 0", "start": [699, 1], "end": [700, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_neg", "code": "@[simp]\ntheorem tanh_neg : tanh (-x) = -tanh x", "start": [703, 1], "end": [704, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_conj", "code": "theorem tanh_conj : tanh (conj x) = conj (tanh x)", "start": [707, 1], "end": [708, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_tanh_ofReal_re", "code": "@[simp]\ntheorem ofReal_tanh_ofReal_re (x : \u211d) : ((tanh x).re : \u2102) = tanh x", "start": [711, 1], "end": [713, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_tanh", "code": "@[simp, norm_cast]\ntheorem ofReal_tanh (x : \u211d) : (Real.tanh x : \u2102) = tanh x", "start": [716, 1], "end": [718, 26], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_ofReal_im", "code": "@[simp]\ntheorem tanh_ofReal_im (x : \u211d) : (tanh x).im = 0", "start": [721, 1], "end": [722, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_ofReal_re", "code": "theorem tanh_ofReal_re (x : \u211d) : (tanh x).re = Real.tanh x", "start": [725, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_add_sinh", "code": "@[simp]\ntheorem cosh_add_sinh : cosh x + sinh x = exp x", "start": [729, 1], "end": [731, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_add_cosh", "code": "@[simp]\ntheorem sinh_add_cosh : sinh x + cosh x = exp x", "start": [734, 1], "end": [735, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_sub_cosh", "code": "@[simp]\ntheorem exp_sub_cosh : exp x - cosh x = sinh x", "start": [738, 1], "end": [740, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_sub_sinh", "code": "@[simp]\ntheorem exp_sub_sinh : exp x - sinh x = cosh x", "start": [743, 1], "end": [745, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_sub_sinh", "code": "@[simp]\ntheorem cosh_sub_sinh : cosh x - sinh x = exp (-x)", "start": [748, 1], "end": [750, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_sub_cosh", "code": "@[simp]\ntheorem sinh_sub_cosh : sinh x - cosh x = -exp (-x)", "start": [753, 1], "end": [754, 88], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_sq_sub_sinh_sq", "code": "@[simp]\ntheorem cosh_sq_sub_sinh_sq : cosh x ^ 2 - sinh x ^ 2 = 1", "start": [757, 1], "end": [759, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_sq", "code": "theorem cosh_sq : cosh x ^ 2 = sinh x ^ 2 + 1", "start": [762, 1], "end": [764, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_sq", "code": "theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1", "start": [767, 1], "end": [769, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_two_mul", "code": "theorem cosh_two_mul : cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2", "start": [772, 1], "end": [772, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_two_mul", "code": "theorem sinh_two_mul : sinh (2 * x) = 2 * sinh x * cosh x", "start": [775, 1], "end": [777, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_three_mul", "code": "theorem cosh_three_mul : cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x", "start": [780, 1], "end": [786, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_three_mul", "code": "theorem sinh_three_mul : sinh (3 * x) = 4 * sinh x ^ 3 + 3 * sinh x", "start": [789, 1], "end": [795, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_zero", "code": "@[simp]\ntheorem sin_zero : sin 0 = 0", "start": [798, 1], "end": [799, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_neg", "code": "@[simp]\ntheorem sin_neg : sin (-x) = -sin x", "start": [802, 1], "end": [804, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.two_sin", "code": "theorem two_sin : 2 * sin x = (exp (-x * I) - exp (x * I)) * I", "start": [807, 1], "end": [808, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.two_cos", "code": "theorem two_cos : 2 * cos x = exp (x * I) + exp (-x * I)", "start": [811, 1], "end": [812, 32], "kind": "commanddeclaration"}, {"full_name": "Complex.sinh_mul_I", "code": "theorem sinh_mul_I : sinh (x * I) = sin x * I", "start": [815, 1], "end": [817, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.cosh_mul_I", "code": "theorem cosh_mul_I : cosh (x * I) = cos x", "start": [821, 1], "end": [822, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.tanh_mul_I", "code": "theorem tanh_mul_I : tanh (x * I) = tan x * I", "start": [826, 1], "end": [827, 78], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_mul_I", "code": "theorem cos_mul_I : cos (x * I) = cosh x", "start": [831, 1], "end": [831, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_mul_I", "code": "theorem sin_mul_I : sin (x * I) = sinh x * I", "start": [835, 1], "end": [841, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_mul_I", "code": "theorem tan_mul_I : tan (x * I) = tanh x * I", "start": [845, 1], "end": [846, 76], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add", "code": "theorem sin_add : sin (x + y) = sin x * cos y + cos x * sin y", "start": [850, 1], "end": [852, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_zero", "code": "@[simp]\ntheorem cos_zero : cos 0 = 1", "start": [855, 1], "end": [856, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_neg", "code": "@[simp]\ntheorem cos_neg : cos (-x) = cos x", "start": [859, 1], "end": [860, 87], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_aux", "code": "private theorem cos_add_aux {a b c d : \u2102} :\n    (a + b) * (c + d) - (b - a) * (d - c) * -1 = 2 * (a * c + b * d)", "start": [863, 1], "end": [864, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add", "code": "theorem cos_add : cos (x + y) = cos x * cos y - sin x * sin y", "start": [866, 1], "end": [868, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub", "code": "theorem sin_sub : sin (x - y) = sin x * cos y - cos x * sin y", "start": [871, 1], "end": [872, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub", "code": "theorem cos_sub : cos (x - y) = cos x * cos y + sin x * sin y", "start": [875, 1], "end": [876, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_add_mul_I", "code": "theorem sin_add_mul_I (x y : \u2102) : sin (x + y * I) = sin x * cosh y + cos x * sinh y * I", "start": [879, 1], "end": [880, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_eq", "code": "theorem sin_eq (z : \u2102) : sin z = sin z.re * cosh z.im + cos z.re * sinh z.im * I", "start": [884, 1], "end": [885, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_mul_I", "code": "theorem cos_add_mul_I (x y : \u2102) : cos (x + y * I) = cos x * cosh y - sin x * sinh y * I", "start": [888, 1], "end": [889, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_eq", "code": "theorem cos_eq (z : \u2102) : cos z = cos z.re * cosh z.im - sin z.re * sinh z.im * I", "start": [893, 1], "end": [894, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sub_sin", "code": "theorem sin_sub_sin : sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)", "start": [897, 1], "end": [903, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_cos", "code": "theorem cos_sub_cos : cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)", "start": [906, 1], "end": [912, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_cos", "code": "theorem cos_add_cos : cos x + cos y = 2 * cos ((x + y) / 2) * cos ((x - y) / 2)", "start": [915, 1], "end": [926, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_conj", "code": "theorem sin_conj : sin (conj x) = conj (sin x)", "start": [929, 1], "end": [931, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sin_ofReal_re", "code": "@[simp]\ntheorem ofReal_sin_ofReal_re (x : \u211d) : ((sin x).re : \u2102) = sin x", "start": [934, 1], "end": [936, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_sin", "code": "@[simp, norm_cast]\ntheorem ofReal_sin (x : \u211d) : (Real.sin x : \u2102) = sin x", "start": [939, 1], "end": [941, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_ofReal_im", "code": "@[simp]\ntheorem sin_ofReal_im (x : \u211d) : (sin x).im = 0", "start": [944, 1], "end": [945, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_ofReal_re", "code": "theorem sin_ofReal_re (x : \u211d) : (sin x).re = Real.sin x", "start": [948, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_conj", "code": "theorem cos_conj : cos (conj x) = conj (cos x)", "start": [952, 1], "end": [953, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cos_ofReal_re", "code": "@[simp]\ntheorem ofReal_cos_ofReal_re (x : \u211d) : ((cos x).re : \u2102) = cos x", "start": [956, 1], "end": [958, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_cos", "code": "@[simp, norm_cast]\ntheorem ofReal_cos (x : \u211d) : (Real.cos x : \u2102) = cos x", "start": [961, 1], "end": [963, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_ofReal_im", "code": "@[simp]\ntheorem cos_ofReal_im (x : \u211d) : (cos x).im = 0", "start": [966, 1], "end": [967, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_ofReal_re", "code": "theorem cos_ofReal_re (x : \u211d) : (cos x).re = Real.cos x", "start": [970, 1], "end": [971, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_zero", "code": "@[simp]\ntheorem tan_zero : tan 0 = 0", "start": [974, 1], "end": [975, 46], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_eq_sin_div_cos", "code": "theorem tan_eq_sin_div_cos : tan x = sin x / cos x", "start": [978, 1], "end": [979, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_mul_cos", "code": "theorem tan_mul_cos {x : \u2102} (hx : cos x \u2260 0) : tan x * cos x = sin x", "start": [982, 1], "end": [983, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_neg", "code": "@[simp]\ntheorem tan_neg : tan (-x) = -tan x", "start": [986, 1], "end": [987, 62], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_conj", "code": "theorem tan_conj : tan (conj x) = conj (tan x)", "start": [990, 1], "end": [990, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_tan_ofReal_re", "code": "@[simp]\ntheorem ofReal_tan_ofReal_re (x : \u211d) : ((tan x).re : \u2102) = tan x", "start": [993, 1], "end": [995, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_tan", "code": "@[simp, norm_cast]\ntheorem ofReal_tan (x : \u211d) : (Real.tan x : \u2102) = tan x", "start": [998, 1], "end": [1000, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_ofReal_im", "code": "@[simp]\ntheorem tan_ofReal_im (x : \u211d) : (tan x).im = 0", "start": [1003, 1], "end": [1004, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_ofReal_re", "code": "theorem tan_ofReal_re (x : \u211d) : (tan x).re = Real.tan x", "start": [1007, 1], "end": [1008, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_sin_I", "code": "theorem cos_add_sin_I : cos x + sin x * I = exp (x * I)", "start": [1011, 1], "end": [1012, 47], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sub_sin_I", "code": "theorem cos_sub_sin_I : cos x - sin x * I = exp (-x * I)", "start": [1016, 1], "end": [1017, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sq_add_cos_sq", "code": "@[simp]\ntheorem sin_sq_add_cos_sq : sin x ^ 2 + cos x ^ 2 = 1", "start": [1021, 1], "end": [1024, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sq_add_sin_sq", "code": "@[simp]\ntheorem cos_sq_add_sin_sq : cos x ^ 2 + sin x ^ 2 = 1", "start": [1027, 1], "end": [1028, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_two_mul'", "code": "theorem cos_two_mul' : cos (2 * x) = cos x ^ 2 - sin x ^ 2", "start": [1031, 1], "end": [1031, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_two_mul", "code": "theorem cos_two_mul : cos (2 * x) = 2 * cos x ^ 2 - 1", "start": [1034, 1], "end": [1036, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_two_mul", "code": "theorem sin_two_mul : sin (2 * x) = 2 * sin x * cos x", "start": [1039, 1], "end": [1040, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sq", "code": "theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2", "start": [1043, 1], "end": [1044, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_sq'", "code": "theorem cos_sq' : cos x ^ 2 = 1 - sin x ^ 2", "start": [1047, 1], "end": [1047, 94], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_sq", "code": "theorem sin_sq : sin x ^ 2 = 1 - cos x ^ 2", "start": [1050, 1], "end": [1050, 92], "kind": "commanddeclaration"}, {"full_name": "Complex.inv_one_add_tan_sq", "code": "theorem inv_one_add_tan_sq {x : \u2102} (hx : cos x \u2260 0) : (1 + tan x ^ 2)\u207b\u00b9 = cos x ^ 2", "start": [1053, 1], "end": [1055, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.tan_sq_div_one_add_tan_sq", "code": "theorem tan_sq_div_one_add_tan_sq {x : \u2102} (hx : cos x \u2260 0) :\n    tan x ^ 2 / (1 + tan x ^ 2) = sin x ^ 2", "start": [1058, 1], "end": [1060, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_three_mul", "code": "theorem cos_three_mul : cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x", "start": [1063, 1], "end": [1069, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_three_mul", "code": "theorem sin_three_mul : sin (3 * x) = 3 * sin x - 4 * sin x ^ 3", "start": [1072, 1], "end": [1078, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_mul_I", "code": "theorem exp_mul_I : exp (x * I) = cos x + sin x * I", "start": [1081, 1], "end": [1082, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_add_mul_I", "code": "theorem exp_add_mul_I : exp (x + y * I) = exp x * (cos y + sin y * I)", "start": [1086, 1], "end": [1086, 100], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_eq_exp_re_mul_sin_add_cos", "code": "theorem exp_eq_exp_re_mul_sin_add_cos : exp x = exp x.re * (cos x.im + sin x.im * I)", "start": [1090, 1], "end": [1091, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_re", "code": "theorem exp_re : (exp x).re = Real.exp x.re * Real.cos x.im", "start": [1094, 1], "end": [1096, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_im", "code": "theorem exp_im : (exp x).im = Real.exp x.re * Real.sin x.im", "start": [1099, 1], "end": [1101, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_ofReal_mul_I_re", "code": "@[simp]\ntheorem exp_ofReal_mul_I_re (x : \u211d) : (exp (x * I)).re = Real.cos x", "start": [1104, 1], "end": [1106, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_ofReal_mul_I_im", "code": "@[simp]\ntheorem exp_ofReal_mul_I_im (x : \u211d) : (exp (x * I)).im = Real.sin x", "start": [1110, 1], "end": [1112, 34], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_add_sin_mul_I_pow", "code": "theorem cos_add_sin_mul_I_pow (n : \u2115) (z : \u2102) :\n    (cos z + sin z * I) ^ n = cos (\u2191n * z) + sin (\u2191n * z) * I", "start": [1116, 1], "end": [1122, 74], "kind": "commanddeclaration"}, {"full_name": "Real.exp_zero", "code": "@[simp]\ntheorem exp_zero : exp 0 = 1", "start": [1134, 1], "end": [1135, 51], "kind": "commanddeclaration"}, {"full_name": "Real.exp_add", "code": "nonrec theorem exp_add : exp (x + y) = exp x * exp y", "start": [1138, 1], "end": [1138, 79], "kind": "commanddeclaration"}, {"full_name": "Real.expMonoidHom", "code": "noncomputable def expMonoidHom : MonoidHom (Multiplicative \u211d) \u211d :=\n  { toFun := fun x => exp (Multiplicative.toAdd x),\n    map_one' := by simp,\n    map_mul' := by simp [exp_add] }", "start": [1142, 1], "end": [1146, 36], "kind": "commanddeclaration"}, {"full_name": "Real.exp_list_sum", "code": "theorem exp_list_sum (l : List \u211d) : exp l.sum = (l.map exp).prod", "start": [1148, 1], "end": [1149, 67], "kind": "commanddeclaration"}, {"full_name": "Real.exp_multiset_sum", "code": "theorem exp_multiset_sum (s : Multiset \u211d) : exp s.sum = (s.map exp).prod", "start": [1152, 1], "end": [1153, 71], "kind": "commanddeclaration"}, {"full_name": "Real.exp_sum", "code": "theorem exp_sum {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) :\n    exp (\u2211 x in s, f x) = \u220f x in s, exp (f x)", "start": [1156, 1], "end": [1158, 60], "kind": "commanddeclaration"}, {"full_name": "Real.exp_nat_mul", "code": "nonrec theorem exp_nat_mul (x : \u211d) (n : \u2115) : exp (n * x) = exp x ^ n", "start": [1161, 1], "end": [1162, 43], "kind": "commanddeclaration"}, {"full_name": "Real.exp_ne_zero", "code": "nonrec theorem exp_ne_zero : exp x \u2260 0", "start": [1165, 1], "end": [1166, 60], "kind": "commanddeclaration"}, {"full_name": "Real.exp_neg", "code": "nonrec theorem exp_neg : exp (-x) = (exp x)\u207b\u00b9", "start": [1169, 1], "end": [1170, 40], "kind": "commanddeclaration"}, {"full_name": "Real.exp_sub", "code": "theorem exp_sub : exp (x - y) = exp x / exp y", "start": [1173, 1], "end": [1174, 58], "kind": "commanddeclaration"}, {"full_name": "Real.sin_zero", "code": "@[simp]\ntheorem sin_zero : sin 0 = 0", "start": [1177, 1], "end": [1178, 46], "kind": "commanddeclaration"}, {"full_name": "Real.sin_neg", "code": "@[simp]\ntheorem sin_neg : sin (-x) = -sin x", "start": [1181, 1], "end": [1182, 91], "kind": "commanddeclaration"}, {"full_name": "Real.sin_add", "code": "nonrec theorem sin_add : sin (x + y) = sin x * cos y + cos x * sin y", "start": [1185, 1], "end": [1186, 40], "kind": "commanddeclaration"}, {"full_name": "Real.cos_zero", "code": "@[simp]\ntheorem cos_zero : cos 0 = 1", "start": [1189, 1], "end": [1190, 46], "kind": "commanddeclaration"}, {"full_name": "Real.cos_neg", "code": "@[simp]\ntheorem cos_neg : cos (-x) = cos x", "start": [1193, 1], "end": [1194, 61], "kind": "commanddeclaration"}, {"full_name": "Real.cos_abs", "code": "@[simp]\ntheorem cos_abs : cos |x| = cos x", "start": [1197, 1], "end": [1199, 85], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add", "code": "nonrec theorem cos_add : cos (x + y) = cos x * cos y - sin x * sin y", "start": [1202, 1], "end": [1203, 40], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub", "code": "theorem sin_sub : sin (x - y) = sin x * cos y - cos x * sin y", "start": [1206, 1], "end": [1207, 51], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub", "code": "theorem cos_sub : cos (x - y) = cos x * cos y + sin x * sin y", "start": [1210, 1], "end": [1211, 51], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sub_sin", "code": "nonrec theorem sin_sub_sin : sin x - sin y = 2 * sin ((x - y) / 2) * cos ((x + y) / 2)", "start": [1214, 1], "end": [1215, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sub_cos", "code": "nonrec theorem cos_sub_cos : cos x - cos y = -2 * sin ((x + y) / 2) * sin ((x - y) / 2)", "start": [1218, 1], "end": [1219, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_add_cos", "code": "nonrec theorem cos_add_cos : cos x + cos y = 2 * cos ((x + y) / 2) * cos ((x - y) / 2)", "start": [1222, 1], "end": [1223, 44], "kind": "commanddeclaration"}, {"full_name": "Real.tan_eq_sin_div_cos", "code": "nonrec theorem tan_eq_sin_div_cos : tan x = sin x / cos x", "start": [1226, 1], "end": [1227, 51], "kind": "commanddeclaration"}, {"full_name": "Real.tan_mul_cos", "code": "theorem tan_mul_cos {x : \u211d} (hx : cos x \u2260 0) : tan x * cos x = sin x", "start": [1230, 1], "end": [1231, 47], "kind": "commanddeclaration"}, {"full_name": "Real.tan_zero", "code": "@[simp]\ntheorem tan_zero : tan 0 = 0", "start": [1234, 1], "end": [1235, 46], "kind": "commanddeclaration"}, {"full_name": "Real.tan_neg", "code": "@[simp]\ntheorem tan_neg : tan (-x) = -tan x", "start": [1238, 1], "end": [1239, 62], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sq_add_cos_sq", "code": "@[simp]\nnonrec theorem sin_sq_add_cos_sq : sin x ^ 2 + cos x ^ 2 = 1", "start": [1242, 1], "end": [1244, 49], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sq_add_sin_sq", "code": "@[simp]\ntheorem cos_sq_add_sin_sq : cos x ^ 2 + sin x ^ 2 = 1", "start": [1247, 1], "end": [1248, 93], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sq_le_one", "code": "theorem sin_sq_le_one : sin x ^ 2 \u2264 1", "start": [1251, 1], "end": [1252, 73], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sq_le_one", "code": "theorem cos_sq_le_one : cos x ^ 2 \u2264 1", "start": [1255, 1], "end": [1256, 72], "kind": "commanddeclaration"}, {"full_name": "Real.abs_sin_le_one", "code": "theorem abs_sin_le_one : |sin x| \u2264 1", "start": [1259, 1], "end": [1260, 73], "kind": "commanddeclaration"}, {"full_name": "Real.abs_cos_le_one", "code": "theorem abs_cos_le_one : |cos x| \u2264 1", "start": [1263, 1], "end": [1264, 73], "kind": "commanddeclaration"}, {"full_name": "Real.sin_le_one", "code": "theorem sin_le_one : sin x \u2264 1", "start": [1267, 1], "end": [1268, 34], "kind": "commanddeclaration"}, {"full_name": "Real.cos_le_one", "code": "theorem cos_le_one : cos x \u2264 1", "start": [1271, 1], "end": [1272, 34], "kind": "commanddeclaration"}, {"full_name": "Real.neg_one_le_sin", "code": "theorem neg_one_le_sin : -1 \u2264 sin x", "start": [1275, 1], "end": [1276, 34], "kind": "commanddeclaration"}, {"full_name": "Real.neg_one_le_cos", "code": "theorem neg_one_le_cos : -1 \u2264 cos x", "start": [1279, 1], "end": [1280, 34], "kind": "commanddeclaration"}, {"full_name": "Real.cos_two_mul", "code": "nonrec theorem cos_two_mul : cos (2 * x) = 2 * cos x ^ 2 - 1", "start": [1283, 1], "end": [1284, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_two_mul'", "code": "nonrec theorem cos_two_mul' : cos (2 * x) = cos x ^ 2 - sin x ^ 2", "start": [1287, 1], "end": [1288, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sin_two_mul", "code": "nonrec theorem sin_two_mul : sin (2 * x) = 2 * sin x * cos x", "start": [1291, 1], "end": [1292, 44], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sq", "code": "nonrec theorem cos_sq : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2", "start": [1295, 1], "end": [1296, 39], "kind": "commanddeclaration"}, {"full_name": "Real.cos_sq'", "code": "theorem cos_sq' : cos x ^ 2 = 1 - sin x ^ 2", "start": [1299, 1], "end": [1299, 94], "kind": "commanddeclaration"}, {"full_name": "Real.sin_sq", "code": "theorem sin_sq : sin x ^ 2 = 1 - cos x ^ 2", "start": [1302, 1], "end": [1303, 45], "kind": "commanddeclaration"}, {"full_name": "Real.abs_sin_eq_sqrt_one_sub_cos_sq", "code": "theorem abs_sin_eq_sqrt_one_sub_cos_sq (x : \u211d) : |sin x| = sqrt (1 - cos x ^ 2)", "start": [1306, 1], "end": [1307, 32], "kind": "commanddeclaration"}, {"full_name": "Real.abs_cos_eq_sqrt_one_sub_sin_sq", "code": "theorem abs_cos_eq_sqrt_one_sub_sin_sq (x : \u211d) : |cos x| = sqrt (1 - sin x ^ 2)", "start": [1310, 1], "end": [1311, 33], "kind": "commanddeclaration"}, {"full_name": "Real.inv_one_add_tan_sq", "code": "theorem inv_one_add_tan_sq {x : \u211d} (hx : cos x \u2260 0) : (1 + tan x ^ 2)\u207b\u00b9 = cos x ^ 2", "start": [1314, 1], "end": [1316, 65], "kind": "commanddeclaration"}, {"full_name": "Real.tan_sq_div_one_add_tan_sq", "code": "theorem tan_sq_div_one_add_tan_sq {x : \u211d} (hx : cos x \u2260 0) :\n    tan x ^ 2 / (1 + tan x ^ 2) = sin x ^ 2", "start": [1319, 1], "end": [1321, 90], "kind": "commanddeclaration"}, {"full_name": "Real.inv_sqrt_one_add_tan_sq", "code": "theorem inv_sqrt_one_add_tan_sq {x : \u211d} (hx : 0 < cos x) : (sqrt (1 + tan x ^ 2))\u207b\u00b9 = cos x", "start": [1324, 1], "end": [1325, 62], "kind": "commanddeclaration"}, {"full_name": "Real.tan_div_sqrt_one_add_tan_sq", "code": "theorem tan_div_sqrt_one_add_tan_sq {x : \u211d} (hx : 0 < cos x) :\n    tan x / sqrt (1 + tan x ^ 2) = sin x", "start": [1328, 1], "end": [1330, 74], "kind": "commanddeclaration"}, {"full_name": "Real.cos_three_mul", "code": "nonrec theorem cos_three_mul : cos (3 * x) = 4 * cos x ^ 3 - 3 * cos x", "start": [1333, 1], "end": [1334, 42], "kind": "commanddeclaration"}, {"full_name": "Real.sin_three_mul", "code": "nonrec theorem sin_three_mul : sin (3 * x) = 3 * sin x - 4 * sin x ^ 3", "start": [1337, 1], "end": [1338, 42], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_eq", "code": "nonrec theorem sinh_eq (x : \u211d) : sinh x = (exp x - exp (-x)) / 2", "start": [1341, 1], "end": [1343, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_zero", "code": "@[simp]\ntheorem sinh_zero : sinh 0 = 0", "start": [1346, 1], "end": [1347, 49], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_neg", "code": "@[simp]\ntheorem sinh_neg : sinh (-x) = -sinh x", "start": [1350, 1], "end": [1351, 95], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_add", "code": "nonrec theorem sinh_add : sinh (x + y) = sinh x * cosh y + cosh x * sinh y", "start": [1354, 1], "end": [1355, 37], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_eq", "code": "theorem cosh_eq (x : \u211d) : cosh x = (exp x + exp (-x)) / 2", "start": [1358, 1], "end": [1362, 57], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_zero", "code": "@[simp]\ntheorem cosh_zero : cosh 0 = 1", "start": [1365, 1], "end": [1366, 49], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_neg", "code": "@[simp]\ntheorem cosh_neg : cosh (-x) = cosh x", "start": [1369, 1], "end": [1371, 26], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_abs", "code": "@[simp]\ntheorem cosh_abs : cosh |x| = cosh x", "start": [1374, 1], "end": [1376, 71], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_add", "code": "nonrec theorem cosh_add : cosh (x + y) = cosh x * cosh y + sinh x * sinh y", "start": [1379, 1], "end": [1380, 37], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_sub", "code": "theorem sinh_sub : sinh (x - y) = sinh x * cosh y - cosh x * sinh y", "start": [1383, 1], "end": [1384, 54], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_sub", "code": "theorem cosh_sub : cosh (x - y) = cosh x * cosh y - sinh x * sinh y", "start": [1387, 1], "end": [1388, 54], "kind": "commanddeclaration"}, {"full_name": "Real.tanh_eq_sinh_div_cosh", "code": "nonrec theorem tanh_eq_sinh_div_cosh : tanh x = sinh x / cosh x", "start": [1391, 1], "end": [1392, 50], "kind": "commanddeclaration"}, {"full_name": "Real.tanh_zero", "code": "@[simp]\ntheorem tanh_zero : tanh 0 = 0", "start": [1395, 1], "end": [1396, 49], "kind": "commanddeclaration"}, {"full_name": "Real.tanh_neg", "code": "@[simp]\ntheorem tanh_neg : tanh (-x) = -tanh x", "start": [1399, 1], "end": [1400, 66], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_add_sinh", "code": "@[simp]\ntheorem cosh_add_sinh : cosh x + sinh x = exp x", "start": [1403, 1], "end": [1404, 78], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_add_cosh", "code": "@[simp]\ntheorem sinh_add_cosh : sinh x + cosh x = exp x", "start": [1407, 1], "end": [1408, 83], "kind": "commanddeclaration"}, {"full_name": "Real.exp_sub_cosh", "code": "@[simp]\ntheorem exp_sub_cosh : exp x - cosh x = sinh x", "start": [1411, 1], "end": [1413, 45], "kind": "commanddeclaration"}, {"full_name": "Real.exp_sub_sinh", "code": "@[simp]\ntheorem exp_sub_sinh : exp x - sinh x = cosh x", "start": [1416, 1], "end": [1418, 45], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_sub_sinh", "code": "@[simp]\ntheorem cosh_sub_sinh : cosh x - sinh x = exp (-x)", "start": [1421, 1], "end": [1424, 7], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_sub_cosh", "code": "@[simp]\ntheorem sinh_sub_cosh : sinh x - cosh x = -exp (-x)", "start": [1427, 1], "end": [1428, 88], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_sq_sub_sinh_sq", "code": "@[simp]\ntheorem cosh_sq_sub_sinh_sq (x : \u211d) : cosh x ^ 2 - sinh x ^ 2 = 1", "start": [1431, 1], "end": [1432, 96], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_sq", "code": "nonrec theorem cosh_sq : cosh x ^ 2 = sinh x ^ 2 + 1", "start": [1435, 1], "end": [1435, 93], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_sq'", "code": "theorem cosh_sq' : cosh x ^ 2 = 1 + sinh x ^ 2", "start": [1438, 1], "end": [1439, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_sq", "code": "nonrec theorem sinh_sq : sinh x ^ 2 = cosh x ^ 2 - 1", "start": [1442, 1], "end": [1442, 93], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_two_mul", "code": "nonrec theorem cosh_two_mul : cosh (2 * x) = cosh x ^ 2 + sinh x ^ 2", "start": [1445, 1], "end": [1446, 41], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_two_mul", "code": "nonrec theorem sinh_two_mul : sinh (2 * x) = 2 * sinh x * cosh x", "start": [1449, 1], "end": [1450, 41], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_three_mul", "code": "nonrec theorem cosh_three_mul : cosh (3 * x) = 4 * cosh x ^ 3 - 3 * cosh x", "start": [1453, 1], "end": [1454, 43], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_three_mul", "code": "nonrec theorem sinh_three_mul : sinh (3 * x) = 4 * sinh x ^ 3 + 3 * sinh x", "start": [1457, 1], "end": [1458, 43], "kind": "commanddeclaration"}, {"full_name": "Real.sum_le_exp_of_nonneg", "code": "theorem sum_le_exp_of_nonneg {x : \u211d} (hx : 0 \u2264 x) (n : \u2115) : \u2211 i in range n, x ^ i / i ! \u2264 exp x", "start": [1463, 1], "end": [1471, 62], "kind": "commanddeclaration"}, {"full_name": "Real.quadratic_le_exp_of_nonneg", "code": "theorem quadratic_le_exp_of_nonneg {x : \u211d} (hx : 0 \u2264 x) : 1 + x + x ^ 2 / 2 \u2264 exp x", "start": [1474, 1], "end": [1481, 43], "kind": "commanddeclaration"}, {"full_name": "Real.add_one_lt_exp_of_pos", "code": "theorem add_one_lt_exp_of_pos {x : \u211d} (hx : 0 < x) : x + 1 < exp x", "start": [1484, 1], "end": [1485, 89], "kind": "commanddeclaration"}, {"full_name": "Real.add_one_le_exp_of_nonneg", "code": "theorem add_one_le_exp_of_nonneg {x : \u211d} (hx : 0 \u2264 x) : x + 1 \u2264 exp x", "start": [1488, 1], "end": [1493, 37], "kind": "commanddeclaration"}, {"full_name": "Real.one_le_exp", "code": "theorem one_le_exp {x : \u211d} (hx : 0 \u2264 x) : 1 \u2264 exp x", "start": [1496, 1], "end": [1496, 97], "kind": "commanddeclaration"}, {"full_name": "Real.exp_pos", "code": "theorem exp_pos (x : \u211d) : 0 < exp x", "start": [1499, 1], "end": [1502, 79], "kind": "commanddeclaration"}, {"full_name": "Real.abs_exp", "code": "@[simp]\ntheorem abs_exp (x : \u211d) : |exp x| = exp x", "start": [1505, 1], "end": [1507, 25], "kind": "commanddeclaration"}, {"full_name": "Real.exp_strictMono", "code": "@[mono]\ntheorem exp_strictMono : StrictMono exp", "start": [1510, 1], "end": [1514, 78], "kind": "commanddeclaration"}, {"full_name": "Real.exp_lt_exp_of_lt", "code": "@[gcongr]\ntheorem exp_lt_exp_of_lt {x y : \u211d} (h : x < y) : exp x < exp y", "start": [1517, 1], "end": [1518, 83], "kind": "commanddeclaration"}, {"full_name": "Real.exp_monotone", "code": "@[mono]\ntheorem exp_monotone : Monotone exp", "start": [1520, 1], "end": [1522, 26], "kind": "commanddeclaration"}, {"full_name": "Real.exp_le_exp_of_le", "code": "@[gcongr]\ntheorem exp_le_exp_of_le {x y : \u211d} (h : x \u2264 y) : exp x \u2264 exp y", "start": [1525, 1], "end": [1526, 81], "kind": "commanddeclaration"}, {"full_name": "Real.exp_lt_exp", "code": "@[simp]\ntheorem exp_lt_exp {x y : \u211d} : exp x < exp y \u2194 x < y", "start": [1528, 1], "end": [1530, 27], "kind": "commanddeclaration"}, {"full_name": "Real.exp_le_exp", "code": "@[simp]\ntheorem exp_le_exp {x y : \u211d} : exp x \u2264 exp y \u2194 x \u2264 y", "start": [1533, 1], "end": [1535, 27], "kind": "commanddeclaration"}, {"full_name": "Real.exp_injective", "code": "theorem exp_injective : Function.Injective exp", "start": [1538, 1], "end": [1539, 27], "kind": "commanddeclaration"}, {"full_name": "Real.exp_eq_exp", "code": "@[simp]\ntheorem exp_eq_exp {x y : \u211d} : exp x = exp y \u2194 x = y", "start": [1542, 1], "end": [1544, 23], "kind": "commanddeclaration"}, {"full_name": "Real.exp_eq_one_iff", "code": "@[simp]\ntheorem exp_eq_one_iff : exp x = 1 \u2194 x = 0", "start": [1547, 1], "end": [1549, 33], "kind": "commanddeclaration"}, {"full_name": "Real.one_lt_exp_iff", "code": "@[simp]\ntheorem one_lt_exp_iff {x : \u211d} : 1 < exp x \u2194 0 < x", "start": [1552, 1], "end": [1553, 85], "kind": "commanddeclaration"}, {"full_name": "Real.exp_lt_one_iff", "code": "@[simp]\ntheorem exp_lt_one_iff {x : \u211d} : exp x < 1 \u2194 x < 0", "start": [1556, 1], "end": [1557, 85], "kind": "commanddeclaration"}, {"full_name": "Real.exp_le_one_iff", "code": "@[simp]\ntheorem exp_le_one_iff {x : \u211d} : exp x \u2264 1 \u2194 x \u2264 0", "start": [1560, 1], "end": [1562, 24], "kind": "commanddeclaration"}, {"full_name": "Real.one_le_exp_iff", "code": "@[simp]\ntheorem one_le_exp_iff {x : \u211d} : 1 \u2264 exp x \u2194 0 \u2264 x", "start": [1565, 1], "end": [1567, 24], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_pos", "code": "theorem cosh_pos (x : \u211d) : 0 < Real.cosh x", "start": [1570, 1], "end": [1572, 67], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_lt_cosh", "code": "theorem sinh_lt_cosh : sinh x < cosh x", "start": [1575, 1], "end": [1576, 72], "kind": "commanddeclaration"}, {"full_name": "Complex.sum_div_factorial_le", "code": "theorem sum_div_factorial_le {\u03b1 : Type*} [LinearOrderedField \u03b1] (n j : \u2115) (hn : 0 < n) :\n    (\u2211 m in filter (fun k => n \u2264 k) (range j),\n      (1 / m.factorial : \u03b1)) \u2264 n.succ / (n.factorial * n)", "start": [1583, 1], "end": [1618, 83], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_bound", "code": "theorem exp_bound {x : \u2102} (hx : abs x \u2264 1) {n : \u2115} (hn : 0 < n) :\n    abs (exp x - \u2211 m in range n, x ^ m / m.factorial) \u2264\n      abs x ^ n * ((n.succ : \u211d) * (n.factorial * n : \u211d)\u207b\u00b9)", "start": [1621, 1], "end": [1650, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_bound'", "code": "theorem exp_bound' {x : \u2102} {n : \u2115} (hx : abs x / n.succ \u2264 1 / 2) :\n    abs (exp x - \u2211 m in range n, x ^ m / m.factorial) \u2264 abs x ^ n / n.factorial * 2", "start": [1653, 1], "end": [1686, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_sub_one_le", "code": "theorem abs_exp_sub_one_le {x : \u2102} (hx : abs x \u2264 1) : abs (exp x - 1) \u2264 2 * abs x", "start": [1689, 1], "end": [1694, 91], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_sub_one_sub_id_le", "code": "theorem abs_exp_sub_one_sub_id_le {x : \u2102} (hx : abs x \u2264 1) : abs (exp x - 1 - x) \u2264 abs x ^ 2", "start": [1697, 1], "end": [1704, 37], "kind": "commanddeclaration"}, {"full_name": "Real.exp_bound", "code": "nonrec theorem exp_bound {x : \u211d} (hx : |x| \u2264 1) {n : \u2115} (hn : 0 < n) :\n    |exp x - \u2211 m in range n, x ^ m / m.factorial| \u2264 |x| ^ n * (n.succ / (n.factorial * n))", "start": [1713, 1], "end": [1719, 37], "kind": "commanddeclaration"}, {"full_name": "Real.exp_bound'", "code": "theorem exp_bound' {x : \u211d} (h1 : 0 \u2264 x) (h2 : x \u2264 1) {n : \u2115} (hn : 0 < n) :\n    Real.exp x \u2264 (\u2211 m in Finset.range n, x ^ m / m.factorial) +\n      x ^ n * (n + 1) / (n.factorial * n)", "start": [1722, 1], "end": [1731, 32], "kind": "commanddeclaration"}, {"full_name": "Real.abs_exp_sub_one_le", "code": "theorem abs_exp_sub_one_le {x : \u211d} (hx : |x| \u2264 1) : |exp x - 1| \u2264 2 * |x|", "start": [1734, 1], "end": [1740, 13], "kind": "commanddeclaration"}, {"full_name": "Real.abs_exp_sub_one_sub_id_le", "code": "theorem abs_exp_sub_one_sub_id_le {x : \u211d} (hx : |x| \u2264 1) : |exp x - 1 - x| \u2264 x ^ 2", "start": [1743, 1], "end": [1750, 13], "kind": "commanddeclaration"}, {"full_name": "Real.expNear", "code": "noncomputable def expNear (n : \u2115) (x r : \u211d) : \u211d :=\n  (\u2211 m in range n, x ^ m / m.factorial) + x ^ n / n.factorial * r", "start": [1753, 1], "end": [1758, 66], "kind": "commanddeclaration"}, {"full_name": "Real.expNear_zero", "code": "@[simp]\ntheorem expNear_zero (x r) : expNear 0 x r = r", "start": [1761, 1], "end": [1762, 68], "kind": "commanddeclaration"}, {"full_name": "Real.expNear_succ", "code": "@[simp]\ntheorem expNear_succ (n x r) : expNear (n + 1) x r = expNear n x (1 + x / (n + 1) * r)", "start": [1765, 1], "end": [1769, 9], "kind": "commanddeclaration"}, {"full_name": "Real.expNear_sub", "code": "theorem expNear_sub (n x r\u2081 r\u2082) : expNear n x r\u2081 -\n    expNear n x r\u2082 = x ^ n / n.factorial * (r\u2081 - r\u2082)", "start": [1772, 1], "end": [1774, 26], "kind": "commanddeclaration"}, {"full_name": "Real.exp_approx_end", "code": "theorem exp_approx_end (n m : \u2115) (x : \u211d) (e\u2081 : n + 1 = m) (h : |x| \u2264 1) :\n    |exp x - expNear m x 0| \u2264 |x| ^ m / m.factorial * ((m + 1) / m)", "start": [1777, 1], "end": [1782, 11], "kind": "commanddeclaration"}, {"full_name": "Real.exp_approx_succ", "code": "theorem exp_approx_succ {n} {x a\u2081 b\u2081 : \u211d} (m : \u2115) (e\u2081 : n + 1 = m) (a\u2082 b\u2082 : \u211d)\n    (e : |1 + x / m * a\u2082 - a\u2081| \u2264 b\u2081 - |x| / m * b\u2082)\n    (h : |exp x - expNear m x a\u2082| \u2264 |x| ^ m / m.factorial * b\u2082) :\n    |exp x - expNear n x a\u2081| \u2264 |x| ^ n / n.factorial * b\u2081", "start": [1785, 1], "end": [1795, 34], "kind": "commanddeclaration"}, {"full_name": "Real.exp_approx_end'", "code": "theorem exp_approx_end' {n} {x a b : \u211d} (m : \u2115) (e\u2081 : n + 1 = m) (rm : \u211d) (er : \u2191m = rm)\n    (h : |x| \u2264 1) (e : |1 - a| \u2264 b - |x| / rm * ((rm + 1) / rm)) :\n    |exp x - expNear n x a| \u2264 |x| ^ n / n.factorial * b", "start": [1798, 1], "end": [1802, 80], "kind": "commanddeclaration"}, {"full_name": "Real.exp_1_approx_succ_eq", "code": "theorem exp_1_approx_succ_eq {n} {a\u2081 b\u2081 : \u211d} {m : \u2115} (en : n + 1 = m) {rm : \u211d} (er : \u2191m = rm)\n    (h : |exp 1 - expNear m 1 ((a\u2081 - 1) * rm)| \u2264 |1| ^ m / m.factorial * (b\u2081 * rm)) :\n    |exp 1 - expNear n 1 a\u2081| \u2264 |1| ^ n / n.factorial * b\u2081", "start": [1805, 1], "end": [1810, 55], "kind": "commanddeclaration"}, {"full_name": "Real.exp_approx_start", "code": "theorem exp_approx_start (x a b : \u211d) (h : |exp x - expNear 0 x a| \u2264 |x| ^ 0 / Nat.factorial 0 * b) :\n    |exp x - a| \u2264 b", "start": [1813, 1], "end": [1814, 40], "kind": "commanddeclaration"}, {"full_name": "Real.cos_bound", "code": "theorem cos_bound {x : \u211d} (hx : |x| \u2264 1) : |cos x - (1 - x ^ 2 / 2)| \u2264 |x| ^ 4 * (5 / 96)", "start": [1817, 1], "end": [1846, 58], "kind": "commanddeclaration"}, {"full_name": "Real.sin_bound", "code": "theorem sin_bound {x : \u211d} (hx : |x| \u2264 1) : |sin x - (x - x ^ 3 / 6)| \u2264 |x| ^ 4 * (5 / 96)", "start": [1849, 1], "end": [1878, 58], "kind": "commanddeclaration"}, {"full_name": "Real.cos_pos_of_le_one", "code": "theorem cos_pos_of_le_one {x : \u211d} (hx : |x| \u2264 1) : 0 < cos x", "start": [1881, 1], "end": [1892, 67], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pos_of_pos_of_le_one", "code": "theorem sin_pos_of_pos_of_le_one {x : \u211d} (hx0 : 0 < x) (hx : x \u2264 1) : 0 < sin x", "start": [1895, 1], "end": [1911, 100], "kind": "commanddeclaration"}, {"full_name": "Real.sin_pos_of_pos_of_le_two", "code": "theorem sin_pos_of_pos_of_le_two {x : \u211d} (hx0 : 0 < x) (hx : x \u2264 2) : 0 < sin x", "start": [1914, 1], "end": [1920, 60], "kind": "commanddeclaration"}, {"full_name": "Real.cos_one_le", "code": "theorem cos_one_le : cos 1 \u2264 2 / 3", "start": [1923, 1], "end": [1927, 29], "kind": "commanddeclaration"}, {"full_name": "Real.cos_one_pos", "code": "theorem cos_one_pos : 0 < cos 1", "start": [1930, 1], "end": [1931, 39], "kind": "commanddeclaration"}, {"full_name": "Real.cos_two_neg", "code": "theorem cos_two_neg : cos 2 < 0", "start": [1934, 1], "end": [1941, 25], "kind": "commanddeclaration"}, {"full_name": "Real.exp_bound_div_one_sub_of_interval'", "code": "theorem exp_bound_div_one_sub_of_interval' {x : \u211d} (h1 : 0 < x) (h2 : x < 1) :\n    Real.exp x < 1 / (1 - x)", "start": [1944, 1], "end": [1959, 56], "kind": "commanddeclaration"}, {"full_name": "Real.exp_bound_div_one_sub_of_interval", "code": "theorem exp_bound_div_one_sub_of_interval {x : \u211d} (h1 : 0 \u2264 x) (h2 : x < 1) :\n    Real.exp x \u2264 1 / (1 - x)", "start": [1962, 1], "end": [1966, 56], "kind": "commanddeclaration"}, {"full_name": "Real.one_sub_lt_exp_minus_of_pos", "code": "theorem one_sub_lt_exp_minus_of_pos {y : \u211d} (h : 0 < y) : 1 - y < Real.exp (-y)", "start": [1969, 1], "end": [1974, 13], "kind": "commanddeclaration"}, {"full_name": "Real.one_sub_le_exp_minus_of_nonneg", "code": "theorem one_sub_le_exp_minus_of_nonneg {y : \u211d} (h : 0 \u2264 y) : 1 - y \u2264 Real.exp (-y)", "start": [1977, 1], "end": [1980, 45], "kind": "commanddeclaration"}, {"full_name": "Real.add_one_lt_exp_of_neg", "code": "theorem add_one_lt_exp_of_neg {x : \u211d} (h : x < 0) : x + 1 < Real.exp x", "start": [1983, 1], "end": [1985, 56], "kind": "commanddeclaration"}, {"full_name": "Real.add_one_lt_exp_of_nonzero", "code": "theorem add_one_lt_exp_of_nonzero {x : \u211d} (hx : x \u2260 0) : x + 1 < Real.exp x", "start": [1988, 1], "end": [1991, 32], "kind": "commanddeclaration"}, {"full_name": "Real.add_one_le_exp", "code": "theorem add_one_le_exp (x : \u211d) : x + 1 \u2264 Real.exp x", "start": [1994, 1], "end": [1997, 37], "kind": "commanddeclaration"}, {"full_name": "Real.one_sub_div_pow_le_exp_neg", "code": "theorem one_sub_div_pow_le_exp_neg {n : \u2115} {t : \u211d} (ht' : t \u2264 n) : (1 - t / n) ^ n \u2264 exp (-t)", "start": [2000, 1], "end": [2011, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalExp", "code": "@[positivity Real.exp _]\ndef evalExp : PositivityExt where eval {_ _} _ _ e := do\n  let (.app _ (a : Q(\u211d))) \u2190 withReducible (whnf e) | throwError \"not Real.exp\"\n  pure (.positive (q(Real.exp_pos $a) : Lean.Expr))", "start": [2019, 1], "end": [2023, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_cos_add_sin_mul_I", "code": "@[simp]\ntheorem abs_cos_add_sin_mul_I (x : \u211d) : abs (cos x + sin x * I) = 1", "start": [2029, 1], "end": [2032, 77], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_ofReal", "code": "@[simp]\ntheorem abs_exp_ofReal (x : \u211d) : abs (exp x) = Real.exp x", "start": [2036, 1], "end": [2039, 50], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_ofReal_mul_I", "code": "@[simp]\ntheorem abs_exp_ofReal_mul_I (x : \u211d) : abs (exp (x * I)) = 1", "start": [2042, 1], "end": [2044, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp", "code": "theorem abs_exp (z : \u2102) : abs (exp z) = Real.exp z.re", "start": [2048, 1], "end": [2049, 94], "kind": "commanddeclaration"}, {"full_name": "Complex.abs_exp_eq_iff_re_eq", "code": "theorem abs_exp_eq_iff_re_eq {x y : \u2102} : abs (exp x) = abs (exp y) \u2194 x.re = y.re", "start": [2052, 1], "end": [2053, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasSum.smul_const", "code": "theorem HasSum.smul_const {r : R} (hf : HasSum f r) (a : M) : HasSum (fun z => f z \u2022 a) (r \u2022 a)", "start": [21, 1], "end": [22, 73], "kind": "commanddeclaration"}, {"full_name": "Summable.smul_const", "code": "theorem Summable.smul_const (hf : Summable f) (a : M) : Summable fun z => f z \u2022 a", "start": [25, 1], "end": [26, 36], "kind": "commanddeclaration"}, {"full_name": "tsum_smul_const", "code": "theorem tsum_smul_const [T2Space M] (hf : Summable f) (a : M) : \u2211' z, f z \u2022 a = (\u2211' z, f z) \u2022 a", "start": [29, 1], "end": [30, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasSum", "code": "protected theorem ContinuousLinearMap.hasSum {f : \u03b9 \u2192 M} (\u03c6 : M \u2192SL[\u03c3] M\u2082) {x : M}\n    (hf : HasSum f x) : HasSum (fun b : \u03b9 => \u03c6 (f b)) (\u03c6 x)", "start": [43, 1], "end": [46, 68], "kind": "commanddeclaration"}, {"full_name": "HasSum.mapL", "code": "alias HasSum.mapL := ContinuousLinearMap.hasSum", "start": [49, 1], "end": [49, 48], "kind": "stdtacticaliasalias"}, {"full_name": "ContinuousLinearMap.summable", "code": "protected theorem ContinuousLinearMap.summable {f : \u03b9 \u2192 M} (\u03c6 : M \u2192SL[\u03c3] M\u2082) (hf : Summable f) :\n    Summable fun b : \u03b9 => \u03c6 (f b)", "start": [53, 1], "end": [55, 30], "kind": "commanddeclaration"}, {"full_name": "Summable.mapL", "code": "alias Summable.mapL := ContinuousLinearMap.summable", "start": [58, 1], "end": [58, 52], "kind": "stdtacticaliasalias"}, {"full_name": "ContinuousLinearMap.map_tsum", "code": "protected theorem ContinuousLinearMap.map_tsum [T2Space M\u2082] {f : \u03b9 \u2192 M} (\u03c6 : M \u2192SL[\u03c3] M\u2082)\n    (hf : Summable f) : \u03c6 (\u2211' z, f z) = \u2211' z, \u03c6 (f z)", "start": [62, 1], "end": [64, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.hasSum", "code": "protected theorem ContinuousLinearEquiv.hasSum {f : \u03b9 \u2192 M} (e : M \u2243SL[\u03c3] M\u2082) {y : M\u2082} :\n    HasSum (fun b : \u03b9 => e (f b)) y \u2194 HasSum f (e.symm y)", "start": [67, 1], "end": [71, 93], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.hasSum'", "code": "protected theorem ContinuousLinearEquiv.hasSum' {f : \u03b9 \u2192 M} (e : M \u2243SL[\u03c3] M\u2082) {x : M} :\n    HasSum (fun b : \u03b9 => e (f b)) (e x) \u2194 HasSum f x", "start": [74, 1], "end": [77, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.summable", "code": "protected theorem ContinuousLinearEquiv.summable {f : \u03b9 \u2192 M} (e : M \u2243SL[\u03c3] M\u2082) :\n    (Summable fun b : \u03b9 => e (f b)) \u2194 Summable f", "start": [80, 1], "end": [82, 74], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.tsum_eq_iff", "code": "theorem ContinuousLinearEquiv.tsum_eq_iff [T2Space M] [T2Space M\u2082] {f : \u03b9 \u2192 M} (e : M \u2243SL[\u03c3] M\u2082)\n    {y : M\u2082} : (\u2211' z, e (f z)) = y \u2194 \u2211' z, f z = e.symm y", "start": [85, 1], "end": [96, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.map_tsum", "code": "protected theorem ContinuousLinearEquiv.map_tsum [T2Space M] [T2Space M\u2082] {f : \u03b9 \u2192 M}\n    (e : M \u2243SL[\u03c3] M\u2082) : e (\u2211' z, f z) = \u2211' z, e (f z)", "start": [99, 1], "end": [102, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/IsROrC/Basic.lean", "imports": ["Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/Analysis/NormedSpace/ContinuousLinearMap.lean", "Mathlib/Data/Real/Sqrt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsROrC", "code": "class IsROrC (K : semiOutParam (Type*)) extends DenselyNormedField K, StarRing K,\n    NormedAlgebra \u211d K, CompleteSpace K where\n  re : K \u2192+ \u211d\n  im : K \u2192+ \u211d\n  \n  I : K\n  I_re_ax : re I = 0\n  I_mul_I_ax : I = 0 \u2228 I * I = -1\n  re_add_im_ax : \u2200 z : K, \ud835\udcda (re z) + \ud835\udcda (im z) * I = z\n  ofReal_re_ax : \u2200 r : \u211d, re (\ud835\udcda r) = r\n  ofReal_im_ax : \u2200 r : \u211d, im (\ud835\udcda r) = 0\n  mul_re_ax : \u2200 z w : K, re (z * w) = re z * re w - im z * im w\n  mul_im_ax : \u2200 z w : K, im (z * w) = re z * im w + im z * re w\n  conj_re_ax : \u2200 z : K, re (conj z) = re z\n  conj_im_ax : \u2200 z : K, im (conj z) = -im z\n  conj_I_ax : conj I = -I\n  norm_sq_eq_def_ax : \u2200 z : K, \u2016z\u2016 ^ 2 = re z * re z + im z * im z\n  mul_im_I_ax : \u2200 z : K, im z * im I = im z\n  \n  [toPartialOrder : PartialOrder K]\n  le_iff_re_im : z \u2264 w \u2194 re z \u2264 re w \u2227 im z = im w\n  [toDecidableEq : DecidableEq K]", "start": [53, 1], "end": [78, 34], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal", "code": "@[coe] abbrev ofReal : \u211d \u2192 K := Algebra.cast", "start": [92, 1], "end": [93, 45], "kind": "commanddeclaration"}, {"full_name": "IsROrC.algebraMapCoe", "code": "noncomputable instance (priority := 900) algebraMapCoe : CoeTC \u211d K :=\n  \u27e8ofReal\u27e9", "start": [97, 1], "end": [98, 11], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_alg", "code": "theorem ofReal_alg (x : \u211d) : (x : K) = x \u2022 (1 : K)", "start": [101, 1], "end": [102, 35], "kind": "commanddeclaration"}, {"full_name": "IsROrC.real_smul_eq_coe_mul", "code": "theorem real_smul_eq_coe_mul (r : \u211d) (z : K) : r \u2022 z = (r : K) * z", "start": [105, 1], "end": [106, 23], "kind": "commanddeclaration"}, {"full_name": "IsROrC.real_smul_eq_coe_smul", "code": "theorem real_smul_eq_coe_smul [AddCommGroup E] [Module K E] [Module \u211d E] [IsScalarTower \u211d K E]\n    (r : \u211d) (x : E) : r \u2022 x = (r : K) \u2022 x", "start": [109, 1], "end": [110, 86], "kind": "commanddeclaration"}, {"full_name": "IsROrC.algebraMap_eq_ofReal", "code": "theorem algebraMap_eq_ofReal : \u21d1(algebraMap \u211d K) = ofReal", "start": [113, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_add_im", "code": "@[simp, isROrC_simps]\ntheorem re_add_im (z : K) : (re z : K) + im z * I = z", "start": [117, 1], "end": [119, 24], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_re", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_re : \u2200 r : \u211d, re (r : K) = r", "start": [122, 1], "end": [124, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_im", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_im : \u2200 r : \u211d, im (r : K) = 0", "start": [127, 1], "end": [129, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.mul_re", "code": "@[simp, isROrC_simps]\ntheorem mul_re : \u2200 z w : K, re (z * w) = re z * re w - im z * im w", "start": [132, 1], "end": [134, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.mul_im", "code": "@[simp, isROrC_simps]\ntheorem mul_im : \u2200 z w : K, im (z * w) = re z * im w + im z * re w", "start": [137, 1], "end": [139, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ext_iff", "code": "theorem ext_iff {z w : K} : z = w \u2194 re z = re w \u2227 im z = im w", "start": [142, 1], "end": [143, 87], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ext", "code": "theorem ext {z w : K} (hre : re z = re w) (him : im z = im w) : z = w", "start": [146, 1], "end": [147, 23], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_zero", "code": "@[norm_cast]\ntheorem ofReal_zero : ((0 : \u211d) : K) = 0", "start": [150, 1], "end": [152, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.zero_re'", "code": "@[isROrC_simps]\ntheorem zero_re' : re (0 : K) = (0 : \u211d)", "start": [155, 1], "end": [157, 14], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_one", "code": "@[norm_cast]\ntheorem ofReal_one : ((1 : \u211d) : K) = 1", "start": [160, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.one_re", "code": "@[simp, isROrC_simps]\ntheorem one_re : re (1 : K) = 1", "start": [165, 1], "end": [166, 67], "kind": "commanddeclaration"}, {"full_name": "IsROrC.one_im", "code": "@[simp, isROrC_simps]\ntheorem one_im : im (1 : K) = 0", "start": [169, 1], "end": [170, 67], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_injective", "code": "theorem ofReal_injective : Function.Injective ((\u2191) : \u211d \u2192 K)", "start": [173, 1], "end": [174, 29], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_inj", "code": "@[norm_cast]\ntheorem ofReal_inj {z w : \u211d} : (z : K) = (w : K) \u2194 z = w", "start": [177, 1], "end": [179, 21], "kind": "commanddeclaration"}, {"full_name": "IsROrC.bit0_re", "code": "@[deprecated, isROrC_simps] theorem bit0_re (z : K) : re (bit0 z) = bit0 (re z)", "start": [183, 1], "end": [185, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.bit1_re", "code": "@[deprecated, simp, isROrC_simps]\ntheorem bit1_re (z : K) : re (bit1 z) = bit1 (re z)", "start": [189, 1], "end": [190, 101], "kind": "commanddeclaration"}, {"full_name": "IsROrC.bit0_im", "code": "@[deprecated, isROrC_simps] theorem bit0_im (z : K) : im (bit0 z) = bit0 (im z)", "start": [194, 1], "end": [196, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.bit1_im", "code": "@[deprecated, simp, isROrC_simps]\ntheorem bit1_im (z : K) : im (bit1 z) = bit0 (im z)", "start": [200, 1], "end": [202, 55], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_eq_zero", "code": "theorem ofReal_eq_zero {x : \u211d} : (x : K) = 0 \u2194 x = 0", "start": [205, 1], "end": [206, 36], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_ne_zero", "code": "theorem ofReal_ne_zero {x : \u211d} : (x : K) \u2260 0 \u2194 x \u2260 0", "start": [209, 1], "end": [210, 21], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_add", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_add (r s : \u211d) : ((r + s : \u211d) : K) = r + s", "start": [213, 1], "end": [215, 25], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_bit0", "code": "@[deprecated, simp, isROrC_simps, norm_cast]\ntheorem ofReal_bit0 (r : \u211d) : ((bit0 r : \u211d) : K) = bit0 (r : K)", "start": [219, 1], "end": [221, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_bit1", "code": "@[deprecated, simp, isROrC_simps, norm_cast]\ntheorem ofReal_bit1 (r : \u211d) : ((bit1 r : \u211d) : K) = bit1 (r : K)", "start": [225, 1], "end": [227, 30], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_neg", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_neg (r : \u211d) : ((-r : \u211d) : K) = -r", "start": [230, 1], "end": [232, 23], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_sub", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_sub (r s : \u211d) : ((r - s : \u211d) : K) = r - s", "start": [235, 1], "end": [237, 31], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_sum", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_sum {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) :\n    ((\u2211 i in s, f i : \u211d) : K) = \u2211 i in s, (f i : K)", "start": [240, 1], "end": [243, 31], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_finsupp_sum", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_finsupp_sum {\u03b1 M : Type*} [Zero M] (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 \u211d) :\n    ((f.sum fun a b => g a b : \u211d) : K) = f.sum fun a b => (g a b : K)", "start": [246, 1], "end": [249, 39], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_mul", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_mul (r s : \u211d) : ((r * s : \u211d) : K) = r * s", "start": [252, 1], "end": [254, 25], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_pow", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_pow (r : \u211d) (n : \u2115) : ((r ^ n : \u211d) : K) = (r : K) ^ n", "start": [257, 1], "end": [259, 31], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_prod", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_prod {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) :\n    ((\u220f i in s, f i : \u211d) : K) = \u220f i in s, (f i : K)", "start": [262, 1], "end": [265, 32], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_finsupp_prod", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_finsupp_prod {\u03b1 M : Type*} [Zero M] (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 \u211d) :\n    ((f.prod fun a b => g a b : \u211d) : K) = f.prod fun a b => (g a b : K)", "start": [268, 1], "end": [271, 25], "kind": "commanddeclaration"}, {"full_name": "IsROrC.real_smul_ofReal", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem real_smul_ofReal (r x : \u211d) : r \u2022 (x : K) = (r : K) * (x : K)", "start": [274, 1], "end": [276, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_mul_re", "code": "@[isROrC_simps]\ntheorem ofReal_mul_re (r : \u211d) (z : K) : re (\u2191r * z) = r * re z", "start": [279, 1], "end": [281, 63], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_mul_im", "code": "@[isROrC_simps]\ntheorem ofReal_mul_im (r : \u211d) (z : K) : im (\u2191r * z) = r * im z", "start": [284, 1], "end": [286, 63], "kind": "commanddeclaration"}, {"full_name": "IsROrC.smul_re", "code": "@[isROrC_simps]\ntheorem smul_re (r : \u211d) (z : K) : re (r \u2022 z) = r * re z", "start": [289, 1], "end": [291, 43], "kind": "commanddeclaration"}, {"full_name": "IsROrC.smul_im", "code": "@[isROrC_simps]\ntheorem smul_im (r : \u211d) (z : K) : im (r \u2022 z) = r * im z", "start": [294, 1], "end": [296, 43], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_ofReal", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem norm_ofReal (r : \u211d) : \u2016(r : K)\u2016 = |r|", "start": [299, 1], "end": [301, 23], "kind": "commanddeclaration"}, {"full_name": "IsROrC.charZero_isROrC", "code": "instance (priority := 100) charZero_isROrC : CharZero K :=\n  (RingHom.charZero_iff (algebraMap \u211d K).injective).1 inferInstance", "start": [307, 1], "end": [309, 68], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_re", "code": "@[simp, isROrC_simps]\ntheorem I_re : re (I : K) = 0", "start": [315, 1], "end": [318, 10], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_im", "code": "@[simp, isROrC_simps]\ntheorem I_im (z : K) : im z * im (I : K) = im z", "start": [322, 1], "end": [324, 16], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_im'", "code": "@[simp, isROrC_simps]\ntheorem I_im' (z : K) : im (I : K) * im z = im z", "start": [328, 1], "end": [329, 75], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_mul_re", "code": "@[isROrC_simps] theorem I_mul_re (z : K) : re (I * z) = -im z", "start": [333, 1], "end": [335, 54], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_mul_I", "code": "theorem I_mul_I : (I : K) = 0 \u2228 (I : K) * I = -1", "start": [339, 1], "end": [340, 13], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_re", "code": "@[simp, isROrC_simps]\ntheorem conj_re (z : K) : re (conj z) = re z", "start": [344, 1], "end": [346, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_im", "code": "@[simp, isROrC_simps]\ntheorem conj_im (z : K) : im (conj z) = -im z", "start": [349, 1], "end": [351, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_I", "code": "@[simp, isROrC_simps]\ntheorem conj_I : conj (I : K) = -I", "start": [354, 1], "end": [356, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_ofReal", "code": "@[simp, isROrC_simps]\ntheorem conj_ofReal (r : \u211d) : conj (r : K) = (r : K)", "start": [360, 1], "end": [363, 84], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_bit0", "code": "@[deprecated, isROrC_simps] theorem conj_bit0 (z : K) : conj (bit0 z) = bit0 (conj z)", "start": [367, 1], "end": [369, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_bit1", "code": "@[deprecated, isROrC_simps] theorem conj_bit1 (z : K) : conj (bit1 z) = bit1 (conj z)", "start": [373, 1], "end": [375, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_neg_I", "code": "@[isROrC_simps] theorem conj_neg_I : conj (-I) = (I : K)", "start": [378, 1], "end": [379, 77], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_eq_re_sub_im", "code": "theorem conj_eq_re_sub_im (z : K) : conj z = re z - im z * I", "start": [383, 1], "end": [385, 85], "kind": "commanddeclaration"}, {"full_name": "IsROrC.sub_conj", "code": "theorem sub_conj (z : K) : z - conj z = 2 * im z * I", "start": [388, 1], "end": [391, 73], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_smul", "code": "@[isROrC_simps]\ntheorem conj_smul (r : \u211d) (z : K) : conj (r \u2022 z) = r \u2022 conj z", "start": [394, 1], "end": [397, 56], "kind": "commanddeclaration"}, {"full_name": "IsROrC.add_conj", "code": "theorem add_conj (z : K) : z + conj z = 2 * re z", "start": [400, 1], "end": [403, 56], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_eq_add_conj", "code": "theorem re_eq_add_conj (z : K) : \u2191(re z) = (z + conj z) / 2", "start": [406, 1], "end": [407, 60], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_eq_conj_sub", "code": "theorem im_eq_conj_sub (z : K) : \u2191(im z) = I * (conj z - z) / 2", "start": [410, 1], "end": [412, 47], "kind": "commanddeclaration"}, {"full_name": "IsROrC.is_real_TFAE", "code": "theorem is_real_TFAE (z : K) : TFAE [conj z = z, \u2203 r : \u211d, (r : K) = z, \u2191(re z) = z, im z = 0]", "start": [416, 1], "end": [427, 14], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_eq_iff_real", "code": "theorem conj_eq_iff_real {z : K} : conj z = z \u2194 \u2203 r : \u211d, z = (r : K)", "start": [430, 1], "end": [431, 61], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_eq_iff_re", "code": "theorem conj_eq_iff_re {z : K} : conj z = z \u2194 (re z : K) = z", "start": [434, 1], "end": [435, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_eq_iff_im", "code": "theorem conj_eq_iff_im {z : K} : conj z = z \u2194 im z = 0", "start": [438, 1], "end": [439, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.star_def", "code": "@[simp]\ntheorem star_def : (Star.star : K \u2192 K) = conj", "start": [442, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjToRingEquiv", "code": "abbrev conjToRingEquiv : K \u2243+* K\u1d50\u1d52\u1d56 :=\n  starRingEquiv", "start": [449, 1], "end": [452, 16], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq", "code": "def normSq : K \u2192*\u2080 \u211d where\n  toFun z := re z * re z + im z * im z\n  map_zero' := by simp only [add_zero, mul_zero, map_zero]\n  map_one' := by simp only [one_im, add_zero, mul_one, one_re, mul_zero]\n  map_mul' z w := by\n    simp only [mul_im, mul_re]\n    ring", "start": [457, 1], "end": [464, 9], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_apply", "code": "theorem normSq_apply (z : K) : normSq z = re z * re z + im z * im z", "start": [467, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_sq_eq_def", "code": "theorem norm_sq_eq_def {z : K} : \u2016z\u2016 ^ 2 = re z * re z + im z * im z", "start": [471, 1], "end": [472, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_eq_def'", "code": "theorem normSq_eq_def' (z : K) : normSq z = \u2016z\u2016 ^ 2", "start": [475, 1], "end": [476, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_zero", "code": "@[isROrC_simps]\ntheorem normSq_zero : normSq (0 : K) = 0", "start": [479, 1], "end": [481, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_one", "code": "@[isROrC_simps]\ntheorem normSq_one : normSq (1 : K) = 1", "start": [484, 1], "end": [486, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_nonneg", "code": "theorem normSq_nonneg (z : K) : 0 \u2264 normSq z", "start": [489, 1], "end": [490, 53], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_eq_zero", "code": "@[isROrC_simps] theorem normSq_eq_zero {z : K} : normSq z = 0 \u2194 z = 0", "start": [493, 1], "end": [495, 16], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_pos", "code": "@[simp, isROrC_simps]\ntheorem normSq_pos {z : K} : 0 < normSq z \u2194 z \u2260 0", "start": [498, 1], "end": [500, 59], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_neg", "code": "@[simp, isROrC_simps]\ntheorem normSq_neg (z : K) : normSq (-z) = normSq z", "start": [503, 1], "end": [504, 95], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_conj", "code": "@[simp, isROrC_simps]\ntheorem normSq_conj (z : K) : normSq (conj z) = normSq z", "start": [507, 1], "end": [509, 68], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_mul", "code": "@[isROrC_simps] theorem normSq_mul (z w : K) : normSq (z * w) = normSq z * normSq w", "start": [512, 1], "end": [514, 16], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_add", "code": "theorem normSq_add (z w : K) : normSq (z + w) = normSq z + normSq w + 2 * re (z * conj w)", "start": [517, 1], "end": [519, 7], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_sq_le_normSq", "code": "theorem re_sq_le_normSq (z : K) : re z * re z \u2264 normSq z", "start": [522, 1], "end": [523, 45], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_sq_le_normSq", "code": "theorem im_sq_le_normSq (z : K) : im z * im z \u2264 normSq z", "start": [526, 1], "end": [527, 44], "kind": "commanddeclaration"}, {"full_name": "IsROrC.mul_conj", "code": "theorem mul_conj (z : K) : z * conj z = (normSq z : K)", "start": [530, 1], "end": [531, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_mul", "code": "theorem conj_mul (x : K) : conj x * x = (normSq x : K)", "start": [534, 1], "end": [534, 85], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_sub", "code": "theorem normSq_sub (z w : K) : normSq (z - w) = normSq z + normSq w - 2 * re (z * conj w)", "start": [537, 1], "end": [538, 80], "kind": "commanddeclaration"}, {"full_name": "IsROrC.sqrt_normSq_eq_norm", "code": "theorem sqrt_normSq_eq_norm {z : K} : Real.sqrt (normSq z) = \u2016z\u2016", "start": [541, 1], "end": [542, 52], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_inv", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_inv (r : \u211d) : ((r\u207b\u00b9 : \u211d) : K) = (r : K)\u207b\u00b9", "start": [547, 1], "end": [549, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.inv_def", "code": "theorem inv_def (z : K) : z\u207b\u00b9 = conj z * ((\u2016z\u2016 ^ 2)\u207b\u00b9 : \u211d)", "start": [552, 1], "end": [557, 49], "kind": "commanddeclaration"}, {"full_name": "IsROrC.inv_re", "code": "@[simp, isROrC_simps]\ntheorem inv_re (z : K) : re z\u207b\u00b9 = re z / normSq z", "start": [560, 1], "end": [562, 81], "kind": "commanddeclaration"}, {"full_name": "IsROrC.inv_im", "code": "@[simp, isROrC_simps]\ntheorem inv_im (z : K) : im z\u207b\u00b9 = -im z / normSq z", "start": [565, 1], "end": [567, 81], "kind": "commanddeclaration"}, {"full_name": "IsROrC.div_re", "code": "theorem div_re (z w : K) : re (z / w) = re z * re w / normSq w + im z * im w / normSq w", "start": [570, 1], "end": [572, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.div_im", "code": "theorem div_im (z w : K) : im (z / w) = im z * re w / normSq w - re z * im w / normSq w", "start": [575, 1], "end": [577, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_inv", "code": "@[isROrC_simps] theorem conj_inv (x : K) : conj x\u207b\u00b9 = (conj x)\u207b\u00b9", "start": [580, 1], "end": [582, 14], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_div", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_div (r s : \u211d) : ((r / s : \u211d) : K) = r / s", "start": [585, 1], "end": [587, 32], "kind": "commanddeclaration"}, {"full_name": "IsROrC.div_re_ofReal", "code": "theorem div_re_ofReal {z : K} {r : \u211d} : re (z / r) = re z / r", "start": [590, 1], "end": [591, 67], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_zpow", "code": "@[simp, norm_cast, isROrC_simps]\ntheorem ofReal_zpow (r : \u211d) (n : \u2124) : ((r ^ n : \u211d) : K) = (r : K) ^ n", "start": [594, 1], "end": [596, 33], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_mul_I_of_nonzero", "code": "theorem I_mul_I_of_nonzero : (I : K) \u2260 0 \u2192 (I : K) * I = -1", "start": [599, 1], "end": [600, 26], "kind": "commanddeclaration"}, {"full_name": "IsROrC.inv_I", "code": "@[simp, isROrC_simps]\ntheorem inv_I : (I : K)\u207b\u00b9 = -I", "start": [604, 1], "end": [608, 38], "kind": "commanddeclaration"}, {"full_name": "IsROrC.div_I", "code": "@[simp, isROrC_simps]\ntheorem div_I (z : K) : z / I = -(z * I)", "start": [612, 1], "end": [613, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_inv", "code": "@[isROrC_simps] theorem normSq_inv (z : K) : normSq z\u207b\u00b9 = (normSq z)\u207b\u00b9", "start": [617, 1], "end": [619, 20], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_div", "code": "@[isROrC_simps] theorem normSq_div (z w : K) : normSq (z / w) = normSq z / normSq w", "start": [622, 1], "end": [624, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_conj", "code": "@[isROrC_simps] theorem norm_conj {z : K} : \u2016conj z\u2016 = \u2016z\u2016", "start": [627, 1], "end": [628, 96], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_natCast", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_natCast (n : \u2115) : ((n : \u211d) : K) = n", "start": [636, 1], "end": [638, 33], "kind": "commanddeclaration"}, {"full_name": "IsROrC.natCast_re", "code": "@[simp, isROrC_simps] theorem natCast_re (n : \u2115) : re (n : K) = n", "start": [641, 1], "end": [642, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.natCast_im", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem natCast_im (n : \u2115) : im (n : K) = 0", "start": [645, 1], "end": [646, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofNat_re", "code": "@[simp, isROrC_simps]\ntheorem ofNat_re (n : \u2115) [n.AtLeastTwo] : re (no_index (OfNat.ofNat n) : K) = OfNat.ofNat n", "start": [649, 1], "end": [651, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofNat_im", "code": "@[simp, isROrC_simps]\ntheorem ofNat_im (n : \u2115) [n.AtLeastTwo] : im (no_index (OfNat.ofNat n) : K) = 0", "start": [653, 1], "end": [655, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_ofNat", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ((no_index (OfNat.ofNat n) : \u211d) : K) = OfNat.ofNat n", "start": [657, 1], "end": [660, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofNat_mul_re", "code": "theorem ofNat_mul_re (n : \u2115) [n.AtLeastTwo] (z : K) :\n    re (OfNat.ofNat n * z) = OfNat.ofNat n * re z", "start": [662, 1], "end": [664, 37], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofNat_mul_im", "code": "theorem ofNat_mul_im (n : \u2115) [n.AtLeastTwo] (z : K) :\n    im (OfNat.ofNat n * z) = OfNat.ofNat n * im z", "start": [666, 1], "end": [668, 37], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_intCast", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_intCast (n : \u2124) : ((n : \u211d) : K) = n", "start": [670, 1], "end": [672, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.intCast_re", "code": "@[simp, isROrC_simps] theorem intCast_re (n : \u2124) : re (n : K) = n", "start": [675, 1], "end": [676, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.intCast_im", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem intCast_im (n : \u2124) : im (n : K) = 0", "start": [679, 1], "end": [680, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_ratCast", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ofReal_ratCast (n : \u211a) : ((n : \u211d) : K) = n", "start": [683, 1], "end": [685, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ratCast_re", "code": "@[simp, isROrC_simps] theorem ratCast_re (q : \u211a) : re (q : K) = q", "start": [688, 1], "end": [689, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ratCast_im", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem ratCast_im (q : \u211a) : im (q : K) = 0", "start": [692, 1], "end": [693, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_of_nonneg", "code": "theorem norm_of_nonneg {r : \u211d} (h : 0 \u2264 r) : \u2016(r : K)\u2016 = r", "start": [698, 1], "end": [699, 42], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_natCast", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem norm_natCast (n : \u2115) : \u2016(n : K)\u2016 = n", "start": [702, 1], "end": [705, 43], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_ofNat", "code": "@[simp, isROrC_simps]\ntheorem norm_ofNat (n : \u2115) [n.AtLeastTwo] : \u2016(no_index (OfNat.ofNat n) : K)\u2016 = OfNat.ofNat n", "start": [708, 1], "end": [710, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.mul_self_norm", "code": "theorem mul_self_norm (z : K) : \u2016z\u2016 * \u2016z\u2016 = normSq z", "start": [712, 1], "end": [712, 83], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_two", "code": "theorem norm_two : \u2016(2 : K)\u2016 = 2", "start": [718, 1], "end": [718, 49], "kind": "commanddeclaration"}, {"full_name": "IsROrC.abs_re_le_norm", "code": "theorem abs_re_le_norm (z : K) : |re z| \u2264 \u2016z\u2016", "start": [721, 1], "end": [723, 24], "kind": "commanddeclaration"}, {"full_name": "IsROrC.abs_im_le_norm", "code": "theorem abs_im_le_norm (z : K) : |im z| \u2264 \u2016z\u2016", "start": [726, 1], "end": [728, 24], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_re_le_norm", "code": "theorem norm_re_le_norm (z : K) : \u2016re z\u2016 \u2264 \u2016z\u2016", "start": [731, 1], "end": [732, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_im_le_norm", "code": "theorem norm_im_le_norm (z : K) : \u2016im z\u2016 \u2264 \u2016z\u2016", "start": [735, 1], "end": [736, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_le_norm", "code": "theorem re_le_norm (z : K) : re z \u2264 \u2016z\u2016", "start": [739, 1], "end": [740, 34], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_le_norm", "code": "theorem im_le_norm (z : K) : im z \u2264 \u2016z\u2016", "start": [743, 1], "end": [744, 34], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_eq_zero_of_le", "code": "theorem im_eq_zero_of_le {a : K} (h : \u2016a\u2016 \u2264 re a) : im a = 0", "start": [747, 1], "end": [749, 65], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_eq_self_of_le", "code": "theorem re_eq_self_of_le {a : K} (h : \u2016a\u2016 \u2264 re a) : (re a : K) = a", "start": [752, 1], "end": [753, 60], "kind": "commanddeclaration"}, {"full_name": "IsROrC.abs_re_div_norm_le_one", "code": "theorem abs_re_div_norm_le_one (z : K) : |re z / \u2016z\u2016| \u2264 1", "start": [758, 1], "end": [760, 60], "kind": "commanddeclaration"}, {"full_name": "IsROrC.abs_im_div_norm_le_one", "code": "theorem abs_im_div_norm_le_one (z : K) : |im z / \u2016z\u2016| \u2264 1", "start": [763, 1], "end": [765, 60], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_I_of_ne_zero", "code": "theorem norm_I_of_ne_zero (hI : (I : K) \u2260 0) : \u2016(I : K)\u2016 = 1", "start": [768, 1], "end": [770, 47], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_eq_norm_of_mul_conj", "code": "theorem re_eq_norm_of_mul_conj (x : K) : re (x * conj x) = \u2016x * conj x\u2016", "start": [774, 1], "end": [775, 73], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_sq_re_add_conj", "code": "theorem norm_sq_re_add_conj (x : K) : \u2016x + conj x\u2016 ^ 2 = re (x + conj x) ^ 2", "start": [778, 1], "end": [779, 78], "kind": "commanddeclaration"}, {"full_name": "IsROrC.norm_sq_re_conj_add", "code": "theorem norm_sq_re_conj_add (x : K) : \u2016conj x + x\u2016 ^ 2 = re (conj x + x) ^ 2", "start": [782, 1], "end": [783, 37], "kind": "commanddeclaration"}, {"full_name": "IsROrC.isCauSeq_re", "code": "theorem isCauSeq_re (f : CauSeq K norm) : IsCauSeq abs fun n => re (f n)", "start": [788, 1], "end": [790, 87], "kind": "commanddeclaration"}, {"full_name": "IsROrC.isCauSeq_im", "code": "theorem isCauSeq_im (f : CauSeq K norm) : IsCauSeq abs fun n => im (f n)", "start": [793, 1], "end": [795, 87], "kind": "commanddeclaration"}, {"full_name": "IsROrC.cauSeqRe", "code": "noncomputable def cauSeqRe (f : CauSeq K norm) : CauSeq \u211d abs :=\n  \u27e8_, isCauSeq_re f\u27e9", "start": [798, 1], "end": [800, 21], "kind": "commanddeclaration"}, {"full_name": "IsROrC.cauSeqIm", "code": "noncomputable def cauSeqIm (f : CauSeq K norm) : CauSeq \u211d abs :=\n  \u27e8_, isCauSeq_im f\u27e9", "start": [803, 1], "end": [805, 21], "kind": "commanddeclaration"}, {"full_name": "IsROrC.isCauSeq_norm", "code": "theorem isCauSeq_norm {f : \u2115 \u2192 K} (hf : IsCauSeq norm f) : IsCauSeq abs (norm \u2218 f)", "start": [808, 1], "end": [810, 71], "kind": "commanddeclaration"}, {"full_name": "Real.isROrC", "code": "noncomputable instance Real.isROrC : IsROrC \u211d where\n  re := AddMonoidHom.id \u211d\n  im := 0\n  I := 0\n  I_re_ax := by simp only [AddMonoidHom.map_zero]\n  I_mul_I_ax := Or.intro_left _ rfl\n  re_add_im_ax z := by\n    simp only [add_zero, mul_zero, Algebra.id.map_eq_id, RingHom.id_apply, AddMonoidHom.id_apply]\n  ofReal_re_ax f := rfl\n  ofReal_im_ax r := rfl\n  mul_re_ax z w := by simp only [sub_zero, mul_zero, AddMonoidHom.zero_apply, AddMonoidHom.id_apply]\n  mul_im_ax z w := by simp only [add_zero, zero_mul, mul_zero, AddMonoidHom.zero_apply]\n  conj_re_ax z := by simp only [starRingEnd_apply, star_id_of_comm]\n  conj_im_ax z := by simp only [neg_zero, AddMonoidHom.zero_apply]\n  conj_I_ax := by simp only [RingHom.map_zero, neg_zero]\n  norm_sq_eq_def_ax z := by simp only [sq, Real.norm_eq_abs, \u2190 abs_mul, abs_mul_self z, add_zero,\n    mul_zero, AddMonoidHom.zero_apply, AddMonoidHom.id_apply]\n  mul_im_I_ax z := by simp only [mul_zero, AddMonoidHom.zero_apply]\n  le_iff_re_im := (and_iff_left rfl).symm", "start": [817, 1], "end": [835, 42], "kind": "commanddeclaration"}, {"full_name": "IsROrC.lt_iff_re_im", "code": "theorem lt_iff_re_im {z w : K} : z < w \u2194 re z < re w \u2227 im z = im w", "start": [846, 1], "end": [852, 43], "kind": "commanddeclaration"}, {"full_name": "IsROrC.nonneg_iff", "code": "theorem nonneg_iff {z : K} : 0 \u2264 z \u2194 0 \u2264 re z \u2227 im z = 0", "start": [854, 1], "end": [855, 70], "kind": "commanddeclaration"}, {"full_name": "IsROrC.pos_iff", "code": "theorem pos_iff {z : K} : 0 < z \u2194 0 < re z \u2227 im z = 0", "start": [857, 1], "end": [858, 70], "kind": "commanddeclaration"}, {"full_name": "IsROrC.nonpos_iff", "code": "theorem nonpos_iff {z : K} : z \u2264 0 \u2194 re z \u2264 0 \u2227 im z = 0", "start": [860, 1], "end": [861, 61], "kind": "commanddeclaration"}, {"full_name": "IsROrC.neg_iff", "code": "theorem neg_iff {z : K} : z < 0 \u2194 re z < 0 \u2227 im z = 0", "start": [863, 1], "end": [864, 61], "kind": "commanddeclaration"}, {"full_name": "IsROrC.toStarOrderedRing", "code": "def toStarOrderedRing : StarOrderedRing K :=\n  StarOrderedRing.ofNonnegIff'\n    (h_add := fun {x y} hxy z => by\n      rw [IsROrC.le_iff_re_im] at *\n      simpa [map_add, add_le_add_iff_left, add_right_inj] using hxy)\n    (h_nonneg_iff := fun x => by\n      rw [IsROrC.le_iff_re_im, map_zero, map_zero, IsROrC.star_def, eq_comm]\n      constructor\n      \u00b7 rintro \u27e8hr, hi\u27e9\n        refine \u27e8Real.sqrt (IsROrC.re x), ?_\u27e9\n        have := (IsROrC.is_real_TFAE x).out 2 3\n        rw [IsROrC.conj_ofReal, \u2190 IsROrC.ofReal_mul, Real.mul_self_sqrt hr, eq_comm, this, hi]\n      \u00b7 rintro \u27e8s, rfl\u27e9\n        simp only [IsROrC.star_def, IsROrC.conj_mul]\n        rw [IsROrC.ofReal_re, IsROrC.ofReal_im, eq_self, and_true]\n        apply IsROrC.normSq_nonneg)", "start": [866, 1], "end": [885, 36], "kind": "commanddeclaration"}, {"full_name": "IsROrC.toStrictOrderedCommRing", "code": "def toStrictOrderedCommRing : StrictOrderedCommRing K where\n  zero_le_one := by simp [@IsROrC.le_iff_re_im K]\n  add_le_add_left _ _ := add_le_add_left\n  mul_pos z w hz hw := by\n    rw [lt_iff_re_im, map_zero] at hz hw \u22a2\n    simp [mul_re, mul_im, \u2190 hz.2, \u2190 hw.2, mul_pos hz.1 hw.1]\n  mul_comm := by intros; apply ext <;> ring_nf", "start": [889, 1], "end": [898, 47], "kind": "commanddeclaration"}, {"full_name": "IsROrC.toOrderedSMul", "code": "theorem toOrderedSMul : OrderedSMul \u211d K", "start": [902, 1], "end": [907, 77], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_to_real", "code": "@[simp, isROrC_simps]\ntheorem re_to_real {x : \u211d} : reR x = x", "start": [922, 1], "end": [924, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_to_real", "code": "@[simp, isROrC_simps]\ntheorem im_to_real {x : \u211d} : imR x = 0", "start": [927, 1], "end": [929, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_to_real", "code": "@[simp, isROrC_simps]\ntheorem conj_to_real {x : \u211d} : conj x = x", "start": [932, 1], "end": [934, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_to_real", "code": "@[simp, isROrC_simps]\ntheorem I_to_real : IR = 0", "start": [937, 1], "end": [939, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_to_real", "code": "@[simp, isROrC_simps]\ntheorem normSq_to_real {x : \u211d} : normSq x = x * x", "start": [943, 1], "end": [944, 77], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_real_eq_id", "code": "@[simp]\ntheorem ofReal_real_eq_id : @ofReal \u211d _ = id", "start": [947, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.reLm", "code": "def reLm : K \u2192\u2097[\u211d] \u211d :=\n  { re with map_smul' := smul_re }", "start": [956, 1], "end": [958, 35], "kind": "commanddeclaration"}, {"full_name": "IsROrC.reLm_coe", "code": "@[simp, isROrC_simps]\ntheorem reLm_coe : (reLm : K \u2192 \u211d) = re", "start": [961, 1], "end": [963, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.reClm", "code": "noncomputable def reClm : K \u2192L[\u211d] \u211d :=\n  reLm.mkContinuous 1 fun x => by\n    rw [one_mul]\n    exact abs_re_le_norm x", "start": [966, 1], "end": [970, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.reClm_coe", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem reClm_coe : ((reClm : K \u2192L[\u211d] \u211d) : K \u2192\u2097[\u211d] \u211d) = reLm", "start": [973, 1], "end": [975, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.reClm_apply", "code": "@[simp, isROrC_simps]\ntheorem reClm_apply : ((reClm : K \u2192L[\u211d] \u211d) : K \u2192 \u211d) = re", "start": [978, 1], "end": [980, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.continuous_re", "code": "@[continuity]\ntheorem continuous_re : Continuous (re : K \u2192 \u211d)", "start": [983, 1], "end": [985, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.imLm", "code": "def imLm : K \u2192\u2097[\u211d] \u211d :=\n  { im with map_smul' := smul_im }", "start": [988, 1], "end": [990, 35], "kind": "commanddeclaration"}, {"full_name": "IsROrC.imLm_coe", "code": "@[simp, isROrC_simps]\ntheorem imLm_coe : (imLm : K \u2192 \u211d) = im", "start": [993, 1], "end": [995, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.imClm", "code": "noncomputable def imClm : K \u2192L[\u211d] \u211d :=\n  imLm.mkContinuous 1 fun x => by\n    rw [one_mul]\n    exact abs_im_le_norm x", "start": [998, 1], "end": [1002, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.imClm_coe", "code": "@[simp, isROrC_simps, norm_cast]\ntheorem imClm_coe : ((imClm : K \u2192L[\u211d] \u211d) : K \u2192\u2097[\u211d] \u211d) = imLm", "start": [1005, 1], "end": [1007, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.imClm_apply", "code": "@[simp, isROrC_simps]\ntheorem imClm_apply : ((imClm : K \u2192L[\u211d] \u211d) : K \u2192 \u211d) = im", "start": [1010, 1], "end": [1012, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.continuous_im", "code": "@[continuity]\ntheorem continuous_im : Continuous (im : K \u2192 \u211d)", "start": [1015, 1], "end": [1017, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjAe", "code": "def conjAe : K \u2243\u2090[\u211d] K :=\n  { conj with\n    invFun := conj\n    left_inv := conj_conj\n    right_inv := conj_conj\n    commutes' := conj_ofReal }", "start": [1020, 1], "end": [1026, 31], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjAe_coe", "code": "@[simp, isROrC_simps]\ntheorem conjAe_coe : (conjAe : K \u2192 K) = conj", "start": [1029, 1], "end": [1031, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjLie", "code": "noncomputable def conjLie : K \u2243\u2097\u1d62[\u211d] K :=\n  \u27e8conjAe.toLinearEquiv, fun _ => norm_conj\u27e9", "start": [1034, 1], "end": [1036, 45], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjLie_apply", "code": "@[simp, isROrC_simps]\ntheorem conjLie_apply : (conjLie : K \u2192 K) = conj", "start": [1039, 1], "end": [1041, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjCle", "code": "noncomputable def conjCle : K \u2243L[\u211d] K :=\n  @conjLie K _", "start": [1044, 1], "end": [1046, 15], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjCle_coe", "code": "@[simp, isROrC_simps]\ntheorem conjCle_coe : (@conjCle K _).toLinearEquiv = conjAe.toLinearEquiv", "start": [1049, 1], "end": [1051, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conjCle_apply", "code": "@[simp, isROrC_simps]\ntheorem conjCle_apply : (conjCle : K \u2192 K) = conj", "start": [1054, 1], "end": [1056, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.continuous_conj", "code": "@[continuity]\ntheorem continuous_conj : Continuous (conj : K \u2192 K)", "start": [1062, 1], "end": [1064, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealAm", "code": "noncomputable def ofRealAm : \u211d \u2192\u2090[\u211d] K :=\n  Algebra.ofId \u211d K", "start": [1067, 1], "end": [1069, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealAm_coe", "code": "@[simp, isROrC_simps]\ntheorem ofRealAm_coe : (ofRealAm : \u211d \u2192 K) = ofReal", "start": [1072, 1], "end": [1074, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealLi", "code": "noncomputable def ofRealLi : \u211d \u2192\u2097\u1d62[\u211d] K where\n  toLinearMap := ofRealAm.toLinearMap\n  norm_map' := norm_ofReal", "start": [1077, 1], "end": [1080, 27], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealLi_apply", "code": "@[simp, isROrC_simps]\ntheorem ofRealLi_apply : (ofRealLi : \u211d \u2192 K) = ofReal", "start": [1083, 1], "end": [1085, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealClm", "code": "noncomputable def ofRealClm : \u211d \u2192L[\u211d] K :=\n  ofRealLi.toContinuousLinearMap", "start": [1088, 1], "end": [1090, 33], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealClm_coe", "code": "@[simp, isROrC_simps]\ntheorem ofRealClm_coe : (@ofRealClm K _ : \u211d \u2192\u2097[\u211d] K) = ofRealAm.toLinearMap", "start": [1093, 1], "end": [1095, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofRealClm_apply", "code": "@[simp, isROrC_simps]\ntheorem ofRealClm_apply : (ofRealClm : \u211d \u2192 K) = ofReal", "start": [1098, 1], "end": [1100, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.continuous_ofReal", "code": "@[continuity]\ntheorem continuous_ofReal : Continuous (ofReal : \u211d \u2192 K)", "start": [1103, 1], "end": [1105, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.continuous_normSq", "code": "@[continuity]\ntheorem continuous_normSq : Continuous (normSq : K \u2192 \u211d)", "start": [1108, 1], "end": [1110, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/RealVectorSpace.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Instances/Rat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "map_real_smul", "code": "theorem map_real_smul {G} [AddMonoidHomClass G E F] (f : G) (hf : Continuous f) (c : \u211d) (x : E) :\n    f (c \u2022 x) = c \u2022 f x", "start": [22, 1], "end": [27, 88], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toRealLinearMap", "code": "def toRealLinearMap (f : E \u2192+ F) (hf : Continuous f) : E \u2192L[\u211d] F :=\n  \u27e8{  toFun := f\n      map_add' := f.map_add\n      map_smul' := map_real_smul f hf }, hf\u27e9", "start": [32, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toRealLinearMap", "code": "@[simp]\ntheorem coe_toRealLinearMap (f : E \u2192+ F) (hf : Continuous f) : \u21d1(f.toRealLinearMap hf) = f", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toRealLinearEquiv", "code": "def AddEquiv.toRealLinearEquiv (e : E \u2243+ F) (h\u2081 : Continuous e) (h\u2082 : Continuous e.symm) :\n    E \u2243L[\u211d] F :=\n  { e, e.toAddMonoidHom.toRealLinearMap h\u2081 with }", "start": [47, 1], "end": [51, 50], "kind": "commanddeclaration"}, {"full_name": "Real.isScalarTower", "code": "instance (priority := 900) Real.isScalarTower [T2Space E] {A : Type*} [TopologicalSpace A] [Ring A]\n    [Algebra \u211d A] [Module A E] [ContinuousSMul \u211d A] [ContinuousSMul A E] : IsScalarTower \u211d A E :=\n  \u27e8fun r x y => map_real_smul ((smulAddHom A E).flip y) (continuous_id.smul continuous_const) r x\u27e9", "start": [54, 1], "end": [59, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/SuccPred.lean", "imports": ["Mathlib/Data/Nat/SuccPred.lean", "Mathlib/Data/Int/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.succ_eq_succ", "code": "@[simp]\ntheorem succ_eq_succ : Order.succ = succ", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Int.pred_eq_pred", "code": "@[simp]\ntheorem pred_eq_pred : Order.pred = pred", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Int.pos_iff_one_le", "code": "theorem pos_iff_one_le {a : \u2124} : 0 < a \u2194 1 \u2264 a", "start": [46, 1], "end": [47, 25], "kind": "commanddeclaration"}, {"full_name": "Int.succ_iterate", "code": "theorem succ_iterate (a : \u2124) : \u2200 n, succ^[n] a = a + n", "start": [50, 1], "end": [54, 41], "kind": "commanddeclaration"}, {"full_name": "Int.pred_iterate", "code": "theorem pred_iterate (a : \u2124) : \u2200 n, pred^[n] a = a - n", "start": [57, 1], "end": [61, 41], "kind": "commanddeclaration"}, {"full_name": "Int.covby_iff_succ_eq", "code": "protected theorem covby_iff_succ_eq {m n : \u2124} : m \u22d6 n \u2194 m + 1 = n", "start": [76, 1], "end": [77, 25], "kind": "commanddeclaration"}, {"full_name": "Int.sub_one_covby", "code": "@[simp]\ntheorem sub_one_covby (z : \u2124) : z - 1 \u22d6 z", "start": [80, 1], "end": [81, 91], "kind": "commanddeclaration"}, {"full_name": "Int.covby_add_one", "code": "@[simp]\ntheorem covby_add_one (z : \u2124) : z \u22d6 z + 1", "start": [84, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_int_covby_iff", "code": "@[simp, norm_cast]\ntheorem Nat.cast_int_covby_iff {a b : \u2115} : (a : \u2124) \u22d6 b \u2194 a \u22d6 b", "start": [91, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "Covby.cast_int", "code": "alias \u27e8_, Covby.cast_int\u27e9 := Nat.cast_int_covby_iff", "start": [97, 1], "end": [97, 52], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Algebra/ModEq.lean", "imports": ["Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCommGroup.ModEq", "code": "def ModEq (p a b : \u03b1) : Prop :=\n  \u2203 z : \u2124, b - a = z \u2022 p", "start": [41, 1], "end": [47, 25], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_refl", "code": "@[refl, simp]\ntheorem modEq_refl (a : \u03b1) : a \u2261 a [PMOD p]", "start": [52, 1], "end": [54, 15], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_rfl", "code": "theorem modEq_rfl : a \u2261 a [PMOD p]", "start": [57, 1], "end": [58, 15], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_comm", "code": "theorem modEq_comm : a \u2261 b [PMOD p] \u2194 b \u2261 a [PMOD p]", "start": [61, 1], "end": [62, 80], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.symm", "code": "alias \u27e8ModEq.symm, _\u27e9 := modEq_comm", "start": [65, 1], "end": [65, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.trans", "code": "@[trans]\ntheorem ModEq.trans : a \u2261 b [PMOD p] \u2192 b \u2261 c [PMOD p] \u2192 a \u2261 c [PMOD p]", "start": [70, 1], "end": [72, 42], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.neg_modEq_neg", "code": "@[simp]\ntheorem neg_modEq_neg : -a \u2261 -b [PMOD p] \u2194 a \u2261 b [PMOD p]", "start": [78, 1], "end": [80, 54], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.of_neg", "code": "alias \u27e8ModEq.of_neg, ModEq.neg\u27e9 := neg_modEq_neg", "start": [83, 1], "end": [83, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.neg", "code": "alias \u27e8ModEq.of_neg, ModEq.neg\u27e9 := neg_modEq_neg", "start": [83, 1], "end": [83, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.modEq_neg", "code": "@[simp]\ntheorem modEq_neg : a \u2261 b [PMOD -p] \u2194 a \u2261 b [PMOD p]", "start": [87, 1], "end": [89, 59], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.of_neg'", "code": "alias \u27e8ModEq.of_neg', ModEq.neg'\u27e9 := modEq_neg", "start": [92, 1], "end": [92, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.neg'", "code": "alias \u27e8ModEq.of_neg', ModEq.neg'\u27e9 := modEq_neg", "start": [92, 1], "end": [92, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.modEq_sub", "code": "theorem modEq_sub (a b : \u03b1) : a \u2261 b [PMOD b - a]", "start": [96, 1], "end": [97, 27], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_zero", "code": "@[simp]\ntheorem modEq_zero : a \u2261 b [PMOD 0] \u2194 a = b", "start": [100, 1], "end": [101, 85], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.self_modEq_zero", "code": "@[simp]\ntheorem self_modEq_zero : p \u2261 0 [PMOD p]", "start": [104, 1], "end": [106, 16], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.zsmul_modEq_zero", "code": "@[simp]\ntheorem zsmul_modEq_zero (z : \u2124) : z \u2022 p \u2261 0 [PMOD p]", "start": [109, 1], "end": [111, 16], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.add_zsmul_modEq", "code": "theorem add_zsmul_modEq (z : \u2124) : a + z \u2022 p \u2261 a [PMOD p]", "start": [114, 1], "end": [115, 16], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.zsmul_add_modEq", "code": "theorem zsmul_add_modEq (z : \u2124) : z \u2022 p + a \u2261 a [PMOD p]", "start": [118, 1], "end": [119, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.add_nsmul_modEq", "code": "theorem add_nsmul_modEq (n : \u2115) : a + n \u2022 p \u2261 a [PMOD p]", "start": [122, 1], "end": [123, 16], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.nsmul_add_modEq", "code": "theorem nsmul_add_modEq (n : \u2115) : n \u2022 p + a \u2261 a [PMOD p]", "start": [126, 1], "end": [127, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_zsmul", "code": "protected theorem add_zsmul (z : \u2124) : a \u2261 b [PMOD p] \u2192 a + z \u2022 p \u2261 b [PMOD p]", "start": [132, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.zsmul_add", "code": "protected theorem zsmul_add (z : \u2124) : a \u2261 b [PMOD p] \u2192 z \u2022 p + a \u2261 b [PMOD p]", "start": [136, 1], "end": [137, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_nsmul", "code": "protected theorem add_nsmul (n : \u2115) : a \u2261 b [PMOD p] \u2192 a + n \u2022 p \u2261 b [PMOD p]", "start": [140, 1], "end": [141, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.nsmul_add", "code": "protected theorem nsmul_add (n : \u2115) : a \u2261 b [PMOD p] \u2192 n \u2022 p + a \u2261 b [PMOD p]", "start": [144, 1], "end": [145, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.of_zsmul", "code": "protected theorem of_zsmul : a \u2261 b [PMOD z \u2022 p] \u2192 a \u2261 b [PMOD p]", "start": [148, 1], "end": [149, 29], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.of_nsmul", "code": "protected theorem of_nsmul : a \u2261 b [PMOD n \u2022 p] \u2192 a \u2261 b [PMOD p]", "start": [152, 1], "end": [153, 44], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.zsmul", "code": "protected theorem zsmul : a \u2261 b [PMOD p] \u2192 z \u2022 a \u2261 z \u2022 b [PMOD z \u2022 p]", "start": [156, 1], "end": [157, 59], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.nsmul", "code": "protected theorem nsmul : a \u2261 b [PMOD p] \u2192 n \u2022 a \u2261 n \u2022 b [PMOD n \u2022 p]", "start": [160, 1], "end": [161, 59], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.zsmul_modEq_zsmul", "code": "@[simp]\ntheorem zsmul_modEq_zsmul [NoZeroSMulDivisors \u2124 \u03b1] (hn : z \u2260 0) :\n    z \u2022 a \u2261 z \u2022 b [PMOD z \u2022 p] \u2194 a \u2261 b [PMOD p]", "start": [166, 1], "end": [169, 73], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.nsmul_modEq_nsmul", "code": "@[simp]\ntheorem nsmul_modEq_nsmul [NoZeroSMulDivisors \u2115 \u03b1] (hn : n \u2260 0) :\n    n \u2022 a \u2261 n \u2022 b [PMOD n \u2022 p] \u2194 a \u2261 b [PMOD p]", "start": [172, 1], "end": [175, 73], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.zsmul_cancel", "code": "alias \u27e8ModEq.zsmul_cancel, _\u27e9 := zsmul_modEq_zsmul", "start": [178, 1], "end": [178, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.nsmul_cancel", "code": "alias \u27e8ModEq.nsmul_cancel, _\u27e9 := nsmul_modEq_nsmul", "start": [181, 1], "end": [181, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.add_iff_left", "code": "@[simp]\nprotected theorem add_iff_left :\n    a\u2081 \u2261 b\u2081 [PMOD p] \u2192 (a\u2081 + a\u2082 \u2261 b\u2081 + b\u2082 [PMOD p] \u2194 a\u2082 \u2261 b\u2082 [PMOD p])", "start": [186, 1], "end": [189, 100], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_iff_right", "code": "@[simp]\nprotected theorem add_iff_right :\n    a\u2082 \u2261 b\u2082 [PMOD p] \u2192 (a\u2081 + a\u2082 \u2261 b\u2081 + b\u2082 [PMOD p] \u2194 a\u2081 \u2261 b\u2081 [PMOD p])", "start": [192, 1], "end": [195, 101], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_iff_left", "code": "@[simp]\nprotected theorem sub_iff_left :\n    a\u2081 \u2261 b\u2081 [PMOD p] \u2192 (a\u2081 - a\u2082 \u2261 b\u2081 - b\u2082 [PMOD p] \u2194 a\u2082 \u2261 b\u2082 [PMOD p])", "start": [198, 1], "end": [201, 100], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_iff_right", "code": "@[simp]\nprotected theorem sub_iff_right :\n    a\u2082 \u2261 b\u2082 [PMOD p] \u2192 (a\u2081 - a\u2082 \u2261 b\u2081 - b\u2082 [PMOD p] \u2194 a\u2081 \u2261 b\u2081 [PMOD p])", "start": [204, 1], "end": [207, 101], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_left_cancel", "code": "alias \u27e8add_left_cancel, add\u27e9 := ModEq.add_iff_left", "start": [210, 1], "end": [210, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.add", "code": "alias \u27e8add_left_cancel, add\u27e9 := ModEq.add_iff_left", "start": [210, 1], "end": [210, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.add_right_cancel", "code": "alias \u27e8add_right_cancel, _\u27e9 := ModEq.add_iff_right", "start": [214, 1], "end": [214, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.sub_left_cancel", "code": "alias \u27e8sub_left_cancel, sub\u27e9 := ModEq.sub_iff_left", "start": [217, 1], "end": [217, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.sub", "code": "alias \u27e8sub_left_cancel, sub\u27e9 := ModEq.sub_iff_left", "start": [217, 1], "end": [217, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.sub_right_cancel", "code": "alias \u27e8sub_right_cancel, _\u27e9 := ModEq.sub_iff_right", "start": [221, 1], "end": [221, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.add_left", "code": "protected theorem add_left (c : \u03b1) (h : a \u2261 b [PMOD p]) : c + a \u2261 c + b [PMOD p]", "start": [227, 1], "end": [228, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_left", "code": "protected theorem sub_left (c : \u03b1) (h : a \u2261 b [PMOD p]) : c - a \u2261 c - b [PMOD p]", "start": [231, 1], "end": [232, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_right", "code": "protected theorem add_right (c : \u03b1) (h : a \u2261 b [PMOD p]) : a + c \u2261 b + c [PMOD p]", "start": [235, 1], "end": [236, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_right", "code": "protected theorem sub_right (c : \u03b1) (h : a \u2261 b [PMOD p]) : a - c \u2261 b - c [PMOD p]", "start": [239, 1], "end": [240, 18], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_left_cancel'", "code": "protected theorem add_left_cancel' (c : \u03b1) : c + a \u2261 c + b [PMOD p] \u2192 a \u2261 b [PMOD p]", "start": [243, 1], "end": [244, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.add_right_cancel'", "code": "protected theorem add_right_cancel' (c : \u03b1) : a + c \u2261 b + c [PMOD p] \u2192 a \u2261 b [PMOD p]", "start": [247, 1], "end": [248, 29], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_left_cancel'", "code": "protected theorem sub_left_cancel' (c : \u03b1) : c - a \u2261 c - b [PMOD p] \u2192 a \u2261 b [PMOD p]", "start": [251, 1], "end": [252, 28], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.sub_right_cancel'", "code": "protected theorem sub_right_cancel' (c : \u03b1) : a - c \u2261 b - c [PMOD p] \u2192 a \u2261 b [PMOD p]", "start": [255, 1], "end": [256, 29], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_sub_iff_add_modEq'", "code": "theorem modEq_sub_iff_add_modEq' : a \u2261 b - c [PMOD p] \u2194 c + a \u2261 b [PMOD p]", "start": [261, 1], "end": [262, 24], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_sub_iff_add_modEq", "code": "theorem modEq_sub_iff_add_modEq : a \u2261 b - c [PMOD p] \u2194 a + c \u2261 b [PMOD p]", "start": [265, 1], "end": [266, 53], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.sub_modEq_iff_modEq_add'", "code": "theorem sub_modEq_iff_modEq_add' : a - b \u2261 c [PMOD p] \u2194 a \u2261 b + c [PMOD p]", "start": [269, 1], "end": [270, 64], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.sub_modEq_iff_modEq_add", "code": "theorem sub_modEq_iff_modEq_add : a - b \u2261 c [PMOD p] \u2194 a \u2261 c + b [PMOD p]", "start": [273, 1], "end": [274, 63], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.sub_modEq_zero", "code": "@[simp]\ntheorem sub_modEq_zero : a - b \u2261 0 [PMOD p] \u2194 a \u2261 b [PMOD p]", "start": [277, 1], "end": [278, 98], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.add_modEq_left", "code": "@[simp]\ntheorem add_modEq_left : a + b \u2261 a [PMOD p] \u2194 b \u2261 0 [PMOD p]", "start": [281, 1], "end": [282, 101], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.add_modEq_right", "code": "@[simp]\ntheorem add_modEq_right : a + b \u2261 b [PMOD p] \u2194 a \u2261 0 [PMOD p]", "start": [285, 1], "end": [286, 101], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_eq_add_zsmul", "code": "theorem modEq_iff_eq_add_zsmul : a \u2261 b [PMOD p] \u2194 \u2203 z : \u2124, b = a + z \u2022 p", "start": [289, 1], "end": [290, 38], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.not_modEq_iff_ne_add_zsmul", "code": "theorem not_modEq_iff_ne_add_zsmul : \u00aca \u2261 b [PMOD p] \u2194 \u2200 z : \u2124, b \u2260 a + z \u2022 p", "start": [293, 1], "end": [294, 42], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_eq_mod_zmultiples", "code": "theorem modEq_iff_eq_mod_zmultiples : a \u2261 b [PMOD p] \u2194 (b : \u03b1 \u29f8 AddSubgroup.zmultiples p) = a", "start": [297, 1], "end": [299, 33], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.not_modEq_iff_ne_mod_zmultiples", "code": "theorem not_modEq_iff_ne_mod_zmultiples :\n    \u00aca \u2261 b [PMOD p] \u2194 (b : \u03b1 \u29f8 AddSubgroup.zmultiples p) \u2260 a", "start": [302, 1], "end": [304, 34], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_int_modEq", "code": "@[simp]\ntheorem modEq_iff_int_modEq {a b z : \u2124} : a \u2261 b [PMOD z] \u2194 a \u2261 b [ZMOD z]", "start": [309, 1], "end": [311, 62], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.int_cast_modEq_int_cast", "code": "@[simp, norm_cast]\ntheorem int_cast_modEq_int_cast {a b z : \u2124} : a \u2261 b [PMOD (z : \u03b1)] \u2194 a \u2261 b [PMOD z]", "start": [318, 1], "end": [321, 12], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.nat_cast_modEq_nat_cast", "code": "@[simp, norm_cast]\ntheorem nat_cast_modEq_nat_cast {a b n : \u2115} : a \u2261 b [PMOD (n : \u03b1)] \u2194 a \u2261 b [MOD n]", "start": [324, 1], "end": [327, 20], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.of_int_cast", "code": "alias \u27e8ModEq.of_int_cast, ModEq.int_cast\u27e9 := int_cast_modEq_int_cast", "start": [330, 1], "end": [330, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.int_cast", "code": "alias \u27e8ModEq.of_int_cast, ModEq.int_cast\u27e9 := int_cast_modEq_int_cast", "start": [330, 1], "end": [330, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.ModEq.of_nat_cast", "code": "alias \u27e8_root_.Nat.ModEq.of_nat_cast, ModEq.nat_cast\u27e9 := nat_cast_modEq_nat_cast", "start": [334, 1], "end": [334, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.nat_cast", "code": "alias \u27e8_root_.Nat.ModEq.of_nat_cast, ModEq.nat_cast\u27e9 := nat_cast_modEq_nat_cast", "start": [334, 1], "end": [334, 80], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Order/Circular.lean", "imports": ["Mathlib/Data/Set/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Btw", "code": "class Btw (\u03b1 : Type*) where\n  \n  btw : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [90, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "SBtw", "code": "class SBtw (\u03b1 : Type*) where\n  \n  sbtw : \u03b1 \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop", "start": [99, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "CircularPreorder", "code": "class CircularPreorder (\u03b1 : Type*) extends Btw \u03b1, SBtw \u03b1 where\n  \n  btw_refl (a : \u03b1) : btw a a a\n  \n  btw_cyclic_left {a b c : \u03b1} : btw a b c \u2192 btw b c a\n  sbtw := fun a b c => btw a b c \u2227 \u00acbtw c b a\n  \n  sbtw_iff_btw_not_btw {a b c : \u03b1} : sbtw a b c \u2194 btw a b c \u2227 \u00acbtw c b a := by intros; rfl\n  \n  sbtw_trans_left {a b c d : \u03b1} : sbtw a b c \u2192 sbtw b d c \u2192 sbtw a d c", "start": [108, 1], "end": [127, 71], "kind": "commanddeclaration"}, {"full_name": "CircularPartialOrder", "code": "class CircularPartialOrder (\u03b1 : Type*) extends CircularPreorder \u03b1 where\n  \n  btw_antisymm {a b c : \u03b1} : btw a b c \u2192 btw c b a \u2192 a = b \u2228 b = c \u2228 c = a", "start": [132, 1], "end": [138, 75], "kind": "commanddeclaration"}, {"full_name": "CircularOrder", "code": "class CircularOrder (\u03b1 : Type*) extends CircularPartialOrder \u03b1 where\n  \n  btw_total : \u2200 a b c : \u03b1, btw a b c \u2228 btw c b a", "start": [143, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "btw_rfl", "code": "theorem btw_rfl {a : \u03b1} : btw a a a", "start": [160, 1], "end": [161, 13], "kind": "commanddeclaration"}, {"full_name": "Btw.btw.cyclic_left", "code": "theorem Btw.btw.cyclic_left {a b c : \u03b1} (h : btw a b c) : btw b c a", "start": [166, 1], "end": [167, 20], "kind": "commanddeclaration"}, {"full_name": "btw_cyclic_right", "code": "theorem btw_cyclic_right {a b c : \u03b1} (h : btw a b c) : btw c a b", "start": [170, 1], "end": [171, 28], "kind": "commanddeclaration"}, {"full_name": "Btw.btw.cyclic_right", "code": "alias Btw.btw.cyclic_right := btw_cyclic_right", "start": [174, 1], "end": [174, 47], "kind": "stdtacticaliasalias"}, {"full_name": "btw_cyclic", "code": "theorem btw_cyclic {a b c : \u03b1} : btw a b c \u2194 btw c a b", "start": [177, 1], "end": [180, 38], "kind": "commanddeclaration"}, {"full_name": "sbtw_iff_btw_not_btw", "code": "theorem sbtw_iff_btw_not_btw {a b c : \u03b1} : sbtw a b c \u2194 btw a b c \u2227 \u00acbtw c b a", "start": [183, 1], "end": [184, 40], "kind": "commanddeclaration"}, {"full_name": "btw_of_sbtw", "code": "theorem btw_of_sbtw {a b c : \u03b1} (h : sbtw a b c) : btw a b c", "start": [187, 1], "end": [188, 31], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.btw", "code": "alias SBtw.sbtw.btw := btw_of_sbtw", "start": [191, 1], "end": [191, 35], "kind": "stdtacticaliasalias"}, {"full_name": "not_btw_of_sbtw", "code": "theorem not_btw_of_sbtw {a b c : \u03b1} (h : sbtw a b c) : \u00acbtw c b a", "start": [194, 1], "end": [195, 31], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.not_btw", "code": "alias SBtw.sbtw.not_btw := not_btw_of_sbtw", "start": [198, 1], "end": [198, 43], "kind": "stdtacticaliasalias"}, {"full_name": "not_sbtw_of_btw", "code": "theorem not_sbtw_of_btw {a b c : \u03b1} (h : btw a b c) : \u00acsbtw c b a", "start": [201, 1], "end": [201, 92], "kind": "commanddeclaration"}, {"full_name": "Btw.btw.not_sbtw", "code": "alias Btw.btw.not_sbtw := not_sbtw_of_btw", "start": [204, 1], "end": [204, 42], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_of_btw_not_btw", "code": "theorem sbtw_of_btw_not_btw {a b c : \u03b1} (habc : btw a b c) (hcba : \u00acbtw c b a) : sbtw a b c", "start": [207, 1], "end": [208, 38], "kind": "commanddeclaration"}, {"full_name": "Btw.btw.sbtw_of_not_btw", "code": "alias Btw.btw.sbtw_of_not_btw := sbtw_of_btw_not_btw", "start": [211, 1], "end": [211, 53], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_cyclic_left", "code": "theorem sbtw_cyclic_left {a b c : \u03b1} (h : sbtw a b c) : sbtw b c a", "start": [214, 1], "end": [215, 71], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.cyclic_left", "code": "alias SBtw.sbtw.cyclic_left := sbtw_cyclic_left", "start": [218, 1], "end": [218, 48], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_cyclic_right", "code": "theorem sbtw_cyclic_right {a b c : \u03b1} (h : sbtw a b c) : sbtw c a b", "start": [221, 1], "end": [222, 28], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.cyclic_right", "code": "alias SBtw.sbtw.cyclic_right := sbtw_cyclic_right", "start": [225, 1], "end": [225, 50], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_cyclic", "code": "theorem sbtw_cyclic {a b c : \u03b1} : sbtw a b c \u2194 sbtw c a b", "start": [228, 1], "end": [231, 40], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.trans_left", "code": "theorem SBtw.sbtw.trans_left {a b c d : \u03b1} (h : sbtw a b c) : sbtw b d c \u2192 sbtw a d c", "start": [236, 1], "end": [237, 20], "kind": "commanddeclaration"}, {"full_name": "sbtw_trans_right", "code": "theorem sbtw_trans_right {a b c d : \u03b1} (hbc : sbtw a b c) (hcd : sbtw a c d) : sbtw a b d", "start": [240, 1], "end": [241, 60], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.trans_right", "code": "alias SBtw.sbtw.trans_right := sbtw_trans_right", "start": [244, 1], "end": [244, 48], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_asymm", "code": "theorem sbtw_asymm {a b c : \u03b1} (h : sbtw a b c) : \u00acsbtw c b a", "start": [247, 1], "end": [248, 17], "kind": "commanddeclaration"}, {"full_name": "SBtw.sbtw.not_sbtw", "code": "alias SBtw.sbtw.not_sbtw := sbtw_asymm", "start": [251, 1], "end": [251, 39], "kind": "stdtacticaliasalias"}, {"full_name": "sbtw_irrefl_left_right", "code": "theorem sbtw_irrefl_left_right {a b : \u03b1} : \u00acsbtw a b a", "start": [254, 1], "end": [254, 83], "kind": "commanddeclaration"}, {"full_name": "sbtw_irrefl_left", "code": "theorem sbtw_irrefl_left {a b : \u03b1} : \u00acsbtw a a b", "start": [257, 1], "end": [257, 98], "kind": "commanddeclaration"}, {"full_name": "sbtw_irrefl_right", "code": "theorem sbtw_irrefl_right {a b : \u03b1} : \u00acsbtw a b b", "start": [260, 1], "end": [260, 100], "kind": "commanddeclaration"}, {"full_name": "sbtw_irrefl", "code": "theorem sbtw_irrefl (a : \u03b1) : \u00acsbtw a a a", "start": [263, 1], "end": [264, 25], "kind": "commanddeclaration"}, {"full_name": "Btw.btw.antisymm", "code": "theorem Btw.btw.antisymm {a b c : \u03b1} (h : btw a b c) : btw c b a \u2192 a = b \u2228 b = c \u2228 c = a", "start": [278, 1], "end": [279, 17], "kind": "commanddeclaration"}, {"full_name": "btw_refl_left_right", "code": "theorem btw_refl_left_right (a b : \u03b1) : btw a b a", "start": [291, 1], "end": [292, 38], "kind": "commanddeclaration"}, {"full_name": "btw_rfl_left_right", "code": "theorem btw_rfl_left_right {a b : \u03b1} : btw a b a", "start": [295, 1], "end": [296, 26], "kind": "commanddeclaration"}, {"full_name": "btw_refl_left", "code": "theorem btw_refl_left (a b : \u03b1) : btw a a b", "start": [299, 1], "end": [300, 34], "kind": "commanddeclaration"}, {"full_name": "btw_rfl_left", "code": "theorem btw_rfl_left {a b : \u03b1} : btw a a b", "start": [303, 1], "end": [304, 20], "kind": "commanddeclaration"}, {"full_name": "btw_refl_right", "code": "theorem btw_refl_right (a b : \u03b1) : btw a b b", "start": [307, 1], "end": [308, 33], "kind": "commanddeclaration"}, {"full_name": "btw_rfl_right", "code": "theorem btw_rfl_right {a b : \u03b1} : btw a b b", "start": [311, 1], "end": [312, 21], "kind": "commanddeclaration"}, {"full_name": "sbtw_iff_not_btw", "code": "theorem sbtw_iff_not_btw {a b c : \u03b1} : sbtw a b c \u2194 \u00acbtw c b a", "start": [315, 1], "end": [317, 60], "kind": "commanddeclaration"}, {"full_name": "btw_iff_not_sbtw", "code": "theorem btw_iff_not_sbtw {a b c : \u03b1} : btw a b c \u2194 \u00acsbtw c b a", "start": [320, 1], "end": [321, 34], "kind": "commanddeclaration"}, {"full_name": "Set.cIcc", "code": "def cIcc (a b : \u03b1) : Set \u03b1 :=\n  { x | btw a x b }", "start": [335, 1], "end": [337, 20], "kind": "commanddeclaration"}, {"full_name": "Set.cIoo", "code": "def cIoo (a b : \u03b1) : Set \u03b1 :=\n  { x | sbtw a x b }", "start": [340, 1], "end": [342, 21], "kind": "commanddeclaration"}, {"full_name": "Set.mem_cIcc", "code": "@[simp]\ntheorem mem_cIcc {a b x : \u03b1} : x \u2208 cIcc a b \u2194 btw a x b", "start": [345, 1], "end": [347, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_cIoo", "code": "@[simp]\ntheorem mem_cIoo {a b x : \u03b1} : x \u2208 cIoo a b \u2194 sbtw a x b", "start": [350, 1], "end": [352, 10], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_cIcc", "code": "theorem left_mem_cIcc (a b : \u03b1) : a \u2208 cIcc a b", "start": [361, 1], "end": [362, 15], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_cIcc", "code": "theorem right_mem_cIcc (a b : \u03b1) : b \u2208 cIcc a b", "start": [365, 1], "end": [366, 16], "kind": "commanddeclaration"}, {"full_name": "Set.compl_cIcc", "code": "theorem compl_cIcc {a b : \u03b1} : (cIcc a b)\u1d9c = cIoo b a", "start": [369, 1], "end": [371, 70], "kind": "commanddeclaration"}, {"full_name": "Set.compl_cIoo", "code": "theorem compl_cIoo {a b : \u03b1} : (cIoo a b)\u1d9c = cIcc b a", "start": [374, 1], "end": [376, 70], "kind": "commanddeclaration"}, {"full_name": "LE.toBtw", "code": "@[reducible]\ndef LE.toBtw (\u03b1 : Type*) [LE \u03b1] : Btw \u03b1 where\n  btw a b c := a \u2264 b \u2227 b \u2264 c \u2228 b \u2264 c \u2227 c \u2264 a \u2228 c \u2264 a \u2227 a \u2264 b", "start": [386, 1], "end": [390, 61], "kind": "commanddeclaration"}, {"full_name": "LT.toSBtw", "code": "@[reducible]\ndef LT.toSBtw (\u03b1 : Type*) [LT \u03b1] : SBtw \u03b1 where\n  sbtw a b c := a < b \u2227 b < c \u2228 b < c \u2227 c < a \u2228 c < a \u2227 a < b", "start": [393, 1], "end": [397, 62], "kind": "commanddeclaration"}, {"full_name": "Preorder.toCircularPreorder", "code": "@[reducible]\ndef Preorder.toCircularPreorder (\u03b1 : Type*) [Preorder \u03b1] : CircularPreorder \u03b1 where\n  btw a b c := a \u2264 b \u2227 b \u2264 c \u2228 b \u2264 c \u2227 c \u2264 a \u2228 c \u2264 a \u2227 a \u2264 b\n  sbtw a b c := a < b \u2227 b < c \u2228 b < c \u2227 c < a \u2228 c < a \u2227 a < b\n  btw_refl a := Or.inl \u27e8le_rfl, le_rfl\u27e9\n  btw_cyclic_left {a b c} h := by\n    dsimp\n    rwa [\u2190 or_assoc, or_comm]\n  sbtw_trans_left {a b c d} := by\n    rintro (\u27e8hab, hbc\u27e9 | \u27e8hbc, hca\u27e9 | \u27e8hca, hab\u27e9) (\u27e8hbd, hdc\u27e9 | \u27e8hdc, hcb\u27e9 | \u27e8hcb, hbd\u27e9)\n    \u00b7 exact Or.inl \u27e8hab.trans hbd, hdc\u27e9\n    \u00b7 exact (hbc.not_lt hcb).elim\n    \u00b7 exact (hbc.not_lt hcb).elim\n    \u00b7 exact Or.inr (Or.inl \u27e8hdc, hca\u27e9)\n    \u00b7 exact Or.inr (Or.inl \u27e8hdc, hca\u27e9)\n    \u00b7 exact (hbc.not_lt hcb).elim\n    \u00b7 exact Or.inr (Or.inl \u27e8hdc, hca\u27e9)\n    \u00b7 exact Or.inr (Or.inl \u27e8hdc, hca\u27e9)\n    \u00b7 exact Or.inr (Or.inr \u27e8hca, hab.trans hbd\u27e9)\n  sbtw_iff_btw_not_btw {a b c} := by\n    simp_rw [lt_iff_le_not_le]\n    have h1 := le_trans a b c\n    have h2 := le_trans b c a\n    have h3 := le_trans c a b\n    revert h1 h2 h3\n    generalize (a \u2264 b) = p1\n    generalize (b \u2264 a) = p2\n    generalize (a \u2264 c) = p3\n    generalize (c \u2264 a) = p4\n    generalize (b \u2264 c) = p5\n    by_cases p1 <;> by_cases p2 <;> by_cases p3 <;> by_cases p4 <;> by_cases p5 <;> simp [*]", "start": [400, 1], "end": [433, 93], "kind": "commanddeclaration"}, {"full_name": "PartialOrder.toCircularPartialOrder", "code": "@[reducible]\ndef PartialOrder.toCircularPartialOrder (\u03b1 : Type*) [PartialOrder \u03b1] : CircularPartialOrder \u03b1 :=\n  { Preorder.toCircularPreorder \u03b1 with\n    btw_antisymm := fun {a b c} => by\n      rintro (\u27e8hab, hbc\u27e9 | \u27e8hbc, hca\u27e9 | \u27e8hca, hab\u27e9) (\u27e8hcb, hba\u27e9 | \u27e8hba, hac\u27e9 | \u27e8hac, hcb\u27e9)\n      \u00b7 exact Or.inl (hab.antisymm hba)\n      \u00b7 exact Or.inl (hab.antisymm hba)\n      \u00b7 exact Or.inr (Or.inl <| hbc.antisymm hcb)\n      \u00b7 exact Or.inr (Or.inl <| hbc.antisymm hcb)\n      \u00b7 exact Or.inr (Or.inr <| hca.antisymm hac)\n      \u00b7 exact Or.inr (Or.inl <| hbc.antisymm hcb)\n      \u00b7 exact Or.inl (hab.antisymm hba)\n      \u00b7 exact Or.inl (hab.antisymm hba)\n      \u00b7 exact Or.inr (Or.inr <| hca.antisymm hac) }", "start": [436, 1], "end": [451, 52], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.toCircularOrder", "code": "@[reducible]\ndef LinearOrder.toCircularOrder (\u03b1 : Type*) [LinearOrder \u03b1] : CircularOrder \u03b1 :=\n  { PartialOrder.toCircularPartialOrder \u03b1 with\n    btw_total := fun a b c => by\n      cases' le_total a b with hab hba <;> cases' le_total b c with hbc hcb <;>\n        cases' le_total c a with hca hac\n      \u00b7 exact Or.inl (Or.inl \u27e8hab, hbc\u27e9)\n      \u00b7 exact Or.inl (Or.inl \u27e8hab, hbc\u27e9)\n      \u00b7 exact Or.inl (Or.inr <| Or.inr \u27e8hca, hab\u27e9)\n      \u00b7 exact Or.inr (Or.inr <| Or.inr \u27e8hac, hcb\u27e9)\n      \u00b7 exact Or.inl (Or.inr <| Or.inl \u27e8hbc, hca\u27e9)\n      \u00b7 exact Or.inr (Or.inr <| Or.inl \u27e8hba, hac\u27e9)\n      \u00b7 exact Or.inr (Or.inl \u27e8hcb, hba\u27e9)\n      \u00b7 exact Or.inr (Or.inr <| Or.inl \u27e8hba, hac\u27e9) }", "start": [454, 1], "end": [469, 53], "kind": "commanddeclaration"}, {"full_name": "OrderDual.btw", "code": "instance btw (\u03b1 : Type*) [Btw \u03b1] : Btw \u03b1\u1d52\u1d48 :=\n  \u27e8fun a b c : \u03b1 => Btw.btw c b a\u27e9", "start": [477, 1], "end": [478, 35], "kind": "commanddeclaration"}, {"full_name": "OrderDual.sbtw", "code": "instance sbtw (\u03b1 : Type*) [SBtw \u03b1] : SBtw \u03b1\u1d52\u1d48 :=\n  \u27e8fun a b c : \u03b1 => SBtw.sbtw c b a\u27e9", "start": [480, 1], "end": [481, 37], "kind": "commanddeclaration"}, {"full_name": "OrderDual.circularPreorder", "code": "instance circularPreorder (\u03b1 : Type*) [CircularPreorder \u03b1] : CircularPreorder \u03b1\u1d52\u1d48 :=\n  { OrderDual.btw \u03b1,\n    OrderDual.sbtw \u03b1 with\n    btw_refl := fun _ => @btw_refl \u03b1 _ _\n    btw_cyclic_left := fun {_ _ _} => @btw_cyclic_right \u03b1 _ _ _ _\n    sbtw_trans_left := fun {_ _ _ _} habc hbdc => hbdc.trans_right habc\n    sbtw_iff_btw_not_btw := fun {a b c} => @sbtw_iff_btw_not_btw \u03b1 _ c b a }", "start": [483, 1], "end": [489, 77], "kind": "commanddeclaration"}, {"full_name": "OrderDual.circularPartialOrder", "code": "instance circularPartialOrder (\u03b1 : Type*) [CircularPartialOrder \u03b1] : CircularPartialOrder \u03b1\u1d52\u1d48 :=\n  { OrderDual.circularPreorder \u03b1 with\n    btw_antisymm := fun {_ _ _} habc hcba => @btw_antisymm \u03b1 _ _ _ _ hcba habc }", "start": [491, 1], "end": [493, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UnitInterval.lean", "imports": ["Mathlib/Topology/Instances/Real.lean", "Mathlib/Topology/Algebra/Field.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/ProjIcc.lean", "Mathlib/Data/Set/Intervals/Instances.lean"], "premises": [{"full_name": "unitInterval", "code": "abbrev unitInterval : Set \u211d :=\n  Set.Icc 0 1", "start": [33, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "unitInterval.zero_mem", "code": "theorem zero_mem : (0 : \u211d) \u2208 I", "start": [43, 1], "end": [44, 24], "kind": "commanddeclaration"}, {"full_name": "unitInterval.one_mem", "code": "theorem one_mem : (1 : \u211d) \u2208 I", "start": [47, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "unitInterval.mul_mem", "code": "theorem mul_mem {x y : \u211d} (hx : x \u2208 I) (hy : y \u2208 I) : x * y \u2208 I", "start": [51, 1], "end": [52, 88], "kind": "commanddeclaration"}, {"full_name": "unitInterval.div_mem", "code": "theorem div_mem {x y : \u211d} (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hxy : x \u2264 y) : x / y \u2208 I", "start": [55, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "unitInterval.fract_mem", "code": "theorem fract_mem (x : \u211d) : fract x \u2208 I", "start": [59, 1], "end": [60, 40], "kind": "commanddeclaration"}, {"full_name": "unitInterval.mem_iff_one_sub_mem", "code": "theorem mem_iff_one_sub_mem {t : \u211d} : t \u2208 I \u2194 1 - t \u2208 I", "start": [63, 1], "end": [65, 53], "kind": "commanddeclaration"}, {"full_name": "unitInterval.hasZero", "code": "instance hasZero : Zero I :=\n  \u27e8\u27e80, zero_mem\u27e9\u27e9", "start": [68, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "unitInterval.hasOne", "code": "instance hasOne : One I :=\n  \u27e8\u27e81, by constructor <;> norm_num\u27e9\u27e9", "start": [72, 1], "end": [73, 37], "kind": "commanddeclaration"}, {"full_name": "unitInterval.coe_ne_zero", "code": "theorem coe_ne_zero {x : I} : (x : \u211d) \u2260 0 \u2194 x \u2260 0", "start": [76, 1], "end": [77, 30], "kind": "commanddeclaration"}, {"full_name": "unitInterval.coe_ne_one", "code": "theorem coe_ne_one {x : I} : (x : \u211d) \u2260 1 \u2194 x \u2260 1", "start": [80, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "unitInterval.mul_le_left", "code": "theorem mul_le_left {x y : I} : x * y \u2264 x", "start": [91, 1], "end": [92, 91], "kind": "commanddeclaration"}, {"full_name": "unitInterval.mul_le_right", "code": "theorem mul_le_right {x y : I} : x * y \u2264 y", "start": [95, 1], "end": [96, 92], "kind": "commanddeclaration"}, {"full_name": "unitInterval.symm", "code": "def symm : I \u2192 I := fun t => \u27e81 - t, mem_iff_one_sub_mem.mp t.prop\u27e9", "start": [99, 1], "end": [100, 68], "kind": "commanddeclaration"}, {"full_name": "unitInterval.symm_zero", "code": "@[simp]\ntheorem symm_zero : \u03c3 0 = 1", "start": [106, 1], "end": [108, 32], "kind": "commanddeclaration"}, {"full_name": "unitInterval.symm_one", "code": "@[simp]\ntheorem symm_one : \u03c3 1 = 0", "start": [111, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "unitInterval.symm_symm", "code": "@[simp]\ntheorem symm_symm (x : I) : \u03c3 (\u03c3 x) = x", "start": [116, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "unitInterval.coe_symm_eq", "code": "@[simp]\ntheorem coe_symm_eq (x : I) : (\u03c3 x : \u211d) = 1 - x", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "unitInterval.continuous_symm", "code": "@[continuity]\ntheorem continuous_symm : Continuous \u03c3", "start": [127, 1], "end": [129, 65], "kind": "commanddeclaration"}, {"full_name": "unitInterval.nonneg", "code": "theorem nonneg (x : I) : 0 \u2264 (x : \u211d)", "start": [138, 1], "end": [139, 8], "kind": "commanddeclaration"}, {"full_name": "unitInterval.one_minus_nonneg", "code": "theorem one_minus_nonneg (x : I) : 0 \u2264 1 - (x : \u211d)", "start": [142, 1], "end": [142, 75], "kind": "commanddeclaration"}, {"full_name": "unitInterval.le_one", "code": "theorem le_one (x : I) : (x : \u211d) \u2264 1", "start": [145, 1], "end": [146, 8], "kind": "commanddeclaration"}, {"full_name": "unitInterval.one_minus_le_one", "code": "theorem one_minus_le_one (x : I) : 1 - (x : \u211d) \u2264 1", "start": [149, 1], "end": [149, 75], "kind": "commanddeclaration"}, {"full_name": "unitInterval.add_pos", "code": "theorem add_pos {t : I} {x : \u211d} (hx : 0 < x) : 0 < (x + t : \u211d)", "start": [152, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "unitInterval.nonneg'", "code": "theorem nonneg' {t : I} : 0 \u2264 t", "start": [156, 1], "end": [158, 8], "kind": "commanddeclaration"}, {"full_name": "unitInterval.le_one'", "code": "theorem le_one' {t : I} : t \u2264 1", "start": [161, 1], "end": [163, 8], "kind": "commanddeclaration"}, {"full_name": "unitInterval.mul_pos_mem_iff", "code": "theorem mul_pos_mem_iff {a t : \u211d} (ha : 0 < a) : a * t \u2208 I \u2194 t \u2208 Set.Icc (0 : \u211d) (1 / a)", "start": [166, 1], "end": [171, 40], "kind": "commanddeclaration"}, {"full_name": "unitInterval.two_mul_sub_one_mem_iff", "code": "theorem two_mul_sub_one_mem_iff {t : \u211d} : 2 * t - 1 \u2208 I \u2194 t \u2208 Set.Icc (1 / 2 : \u211d) 1", "start": [174, 1], "end": [175, 63], "kind": "commanddeclaration"}, {"full_name": "projIcc_eq_zero", "code": "@[simp]\ntheorem projIcc_eq_zero {x : \u211d} : projIcc (0 : \u211d) 1 zero_le_one x = 0 \u2194 x \u2264 0", "start": [180, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "projIcc_eq_one", "code": "@[simp]\ntheorem projIcc_eq_one {x : \u211d} : projIcc (0 : \u211d) 1 zero_le_one x = 1 \u2194 1 \u2264 x", "start": [185, 1], "end": [187, 31], "kind": "commanddeclaration"}, {"full_name": "affineHomeomorph_image_I", "code": "theorem affineHomeomorph_image_I (a b : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne.symm '' Set.Icc 0 1 = Set.Icc b (a + b)", "start": [212, 1], "end": [215, 85], "kind": "commanddeclaration"}, {"full_name": "iccHomeoI", "code": "def iccHomeoI (a b : \ud835\udd5c) (h : a < b) : Set.Icc a b \u2243\u209c Set.Icc (0 : \ud835\udd5c) (1 : \ud835\udd5c) := by\n  let e := Homeomorph.image (affineHomeomorph (b - a) a (sub_pos.mpr h).ne.symm) (Set.Icc 0 1)\n  refine' (e.trans _).symm\n  apply Homeomorph.setCongr\n  rw [affineHomeomorph_image_I _ _ (sub_pos.2 h)]\n  simp", "start": [219, 1], "end": [226, 7], "kind": "commanddeclaration"}, {"full_name": "iccHomeoI_apply_coe", "code": "@[simp]\ntheorem iccHomeoI_apply_coe (a b : \ud835\udd5c) (h : a < b) (x : Set.Icc a b) :\n    ((iccHomeoI a b h) x : \ud835\udd5c) = (x - a) / (b - a)", "start": [230, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "iccHomeoI_symm_apply_coe", "code": "@[simp]\ntheorem iccHomeoI_symm_apply_coe (a b : \ud835\udd5c) (h : a < b) (x : Set.Icc (0 : \ud835\udd5c) (1 : \ud835\udd5c)) :\n    ((iccHomeoI a b h).symm x : \ud835\udd5c) = (b - a) * x + a", "start": [237, 1], "end": [240, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/ProjIcc.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Data/Set/Intervals/ProjIcc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.Tendsto.IccExtend", "code": "protected theorem Filter.Tendsto.IccExtend (f : \u03b3 \u2192 Icc a b \u2192 \u03b2) {la : Filter \u03b1} {lb : Filter \u03b2}\n    {lc : Filter \u03b3} (hf : Tendsto (\u21bff) (lc \u00d7\u02e2 la.map (projIcc a b h)) lb) :\n    Tendsto (\u21bf(IccExtend h \u2218 f)) (lc \u00d7\u02e2 la) lb", "start": [24, 1], "end": [27, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.IccExtend'", "code": "@[deprecated Filter.Tendsto.IccExtend]\ntheorem Filter.Tendsto.IccExtend' (f : \u03b3 \u2192 Icc a b \u2192 \u03b2) {z : \u03b3} {l : Filter \u03b1} {l' : Filter \u03b2}\n    (hf : Tendsto (\u21bff) (\ud835\udcdd z \u00d7\u02e2 l.map (projIcc a b h)) l') :\n    Tendsto (\u21bf(IccExtend h \u2218 f)) (\ud835\udcdd z \u00d7\u02e2 l) l'", "start": [29, 1], "end": [33, 17], "kind": "commanddeclaration"}, {"full_name": "continuous_projIcc", "code": "@[continuity]\ntheorem continuous_projIcc : Continuous (projIcc a b h)", "start": [38, 1], "end": [40, 76], "kind": "commanddeclaration"}, {"full_name": "quotientMap_projIcc", "code": "theorem quotientMap_projIcc : QuotientMap (projIcc a b h)", "start": [43, 1], "end": [45, 81], "kind": "commanddeclaration"}, {"full_name": "continuous_IccExtend_iff", "code": "@[simp]\ntheorem continuous_IccExtend_iff {f : Icc a b \u2192 \u03b2} : Continuous (IccExtend h f) \u2194 Continuous f", "start": [48, 1], "end": [50, 42], "kind": "commanddeclaration"}, {"full_name": "Continuous.IccExtend", "code": "protected theorem Continuous.IccExtend {f : \u03b3 \u2192 Icc a b \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (hf : Continuous \u21bff)\n    (hg : Continuous g) : Continuous fun a => IccExtend h (f a) (g a)", "start": [53, 1], "end": [57, 70], "kind": "commanddeclaration"}, {"full_name": "Continuous.Icc_extend'", "code": "@[continuity]\nprotected theorem Continuous.Icc_extend' {f : Icc a b \u2192 \u03b2} (hf : Continuous f) :\n    Continuous (IccExtend h f)", "start": [60, 1], "end": [64, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.IccExtend", "code": "theorem ContinuousAt.IccExtend {x : \u03b3} (f : \u03b3 \u2192 Icc a b \u2192 \u03b2) {g : \u03b3 \u2192 \u03b1}\n    (hf : ContinuousAt (\u21bff) (x, projIcc a b h (g x))) (hg : ContinuousAt g x) :\n    ContinuousAt (fun a => IccExtend h (f a) (g a)) x", "start": [67, 1], "end": [71, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/CompactOpen.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.CompactOpen.gen", "code": "def CompactOpen.gen (s : Set \u03b1) (u : Set \u03b2) : Set C(\u03b1, \u03b2) :=\n  { f | f '' s \u2286 u }", "start": [47, 1], "end": [49, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.gen_empty", "code": "@[simp]\ntheorem gen_empty (u : Set \u03b2) : CompactOpen.gen (\u2205 : Set \u03b1) u = Set.univ", "start": [52, 1], "end": [54, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.gen_univ", "code": "@[simp]\ntheorem gen_univ (s : Set \u03b1) : CompactOpen.gen s (Set.univ : Set \u03b2) = Set.univ", "start": [57, 1], "end": [59, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.gen_inter", "code": "@[simp]\ntheorem gen_inter (s : Set \u03b1) (u v : Set \u03b2) :\n    CompactOpen.gen s (u \u2229 v) = CompactOpen.gen s u \u2229 CompactOpen.gen s v", "start": [62, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.gen_union", "code": "@[simp]\ntheorem gen_union (s t : Set \u03b1) (u : Set \u03b2) :\n    CompactOpen.gen (s \u222a t) u = CompactOpen.gen s u \u2229 CompactOpen.gen t u", "start": [68, 1], "end": [71, 94], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.gen_empty_right", "code": "theorem gen_empty_right {s : Set \u03b1} (h : s.Nonempty) : CompactOpen.gen s (\u2205 : Set \u03b2) = \u2205", "start": [74, 1], "end": [75, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactOpen", "code": "instance compactOpen : TopologicalSpace C(\u03b1, \u03b2) :=\n  TopologicalSpace.generateFrom\n    { m | \u2203 (s : Set \u03b1) (_ : IsCompact s) (u : Set \u03b2) (_ : IsOpen u), m = CompactOpen.gen s u }", "start": [79, 1], "end": [81, 96], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactOpen_eq", "code": "theorem compactOpen_eq : @compactOpen \u03b1 \u03b2 _ _ =\n    .generateFrom (Set.image2 CompactOpen.gen {s | IsCompact s} {t | IsOpen t})", "start": [84, 1], "end": [87, 79], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.isOpen_gen", "code": "protected theorem isOpen_gen {s : Set \u03b1} (hs : IsCompact s) {u : Set \u03b2} (hu : IsOpen u) :\n    IsOpen (CompactOpen.gen s u)", "start": [89, 1], "end": [91, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.preimage_gen", "code": "private theorem preimage_gen {s : Set \u03b1} {u : Set \u03b3} :\n    ContinuousMap.comp g \u207b\u00b9' CompactOpen.gen s u = CompactOpen.gen s (g \u207b\u00b9' u)", "start": [98, 1], "end": [102, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_comp", "code": "theorem continuous_comp : Continuous (ContinuousMap.comp g : C(\u03b1, \u03b2) \u2192 C(\u03b1, \u03b3))", "start": [104, 1], "end": [107, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.inducing_comp", "code": "theorem inducing_comp (hg : Inducing g) : Inducing (g.comp : C(\u03b1, \u03b2) \u2192 C(\u03b1, \u03b3)) where", "start": [110, 1], "end": [115, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.embedding_comp", "code": "theorem embedding_comp (hg : Embedding g) : Embedding (g.comp : C(\u03b1, \u03b2) \u2192 C(\u03b1, \u03b3))", "start": [117, 1], "end": [120, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.image_gen", "code": "private theorem image_gen {s : Set \u03b1} (_ : IsCompact s) {u : Set \u03b3} (_ : IsOpen u) :\n    (fun g : C(\u03b2, \u03b3) => g.comp f) \u207b\u00b9' CompactOpen.gen s u = CompactOpen.gen (f '' s) u", "start": [124, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_comp_left", "code": "theorem continuous_comp_left : Continuous (fun g => g.comp f : C(\u03b2, \u03b3) \u2192 C(\u03b1, \u03b3))", "start": [130, 1], "end": [134, 53], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_comp'", "code": "theorem continuous_comp' [LocallyCompactSpace \u03b2] :\n    Continuous fun x : C(\u03b1, \u03b2) \u00d7 C(\u03b2, \u03b3) => x.2.comp x.1", "start": [137, 1], "end": [158, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous.comp'", "code": "theorem continuous.comp' {X : Type*} [TopologicalSpace X] [LocallyCompactSpace \u03b2] {f : X \u2192 C(\u03b1, \u03b2)}\n    {g : X \u2192 C(\u03b2, \u03b3)} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (g x).comp (f x)", "start": [161, 1], "end": [164, 73], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_eval'", "code": "theorem continuous_eval' [LocallyCompactSpace \u03b1] : Continuous fun p : C(\u03b1, \u03b2) \u00d7 \u03b1 => p.1 p.2", "start": [171, 1], "end": [193, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_eval_const", "code": "@[continuity]\ntheorem continuous_eval_const (a : \u03b1) :\n    Continuous fun f : C(\u03b1, \u03b2) => f a", "start": [196, 1], "end": [205, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_coe", "code": "theorem continuous_coe : Continuous ((\u21d1) : C(\u03b1, \u03b2) \u2192 (\u03b1 \u2192 \u03b2))", "start": [209, 1], "end": [214, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactOpen_le_induced", "code": "theorem compactOpen_le_induced (s : Set \u03b1) :\n    (ContinuousMap.compactOpen : TopologicalSpace C(\u03b1, \u03b2)) \u2264\n      TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen", "start": [231, 1], "end": [240, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.compactOpen_eq_sInf_induced", "code": "theorem compactOpen_eq_sInf_induced :\n    (ContinuousMap.compactOpen : TopologicalSpace C(\u03b1, \u03b2)) =\n      \u2a05 (s : Set \u03b1) (_ : IsCompact s),\n        TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen", "start": [243, 1], "end": [261, 7], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_restrict", "code": "theorem continuous_restrict (s : Set \u03b1) : Continuous fun F : C(\u03b1, \u03b2) => F.restrict s", "start": [264, 1], "end": [268, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.nhds_compactOpen_eq_sInf_nhds_induced", "code": "theorem nhds_compactOpen_eq_sInf_nhds_induced (f : C(\u03b1, \u03b2)) :\n    \ud835\udcdd f = \u2a05 (s) (hs : IsCompact s), (\ud835\udcdd (f.restrict s)).comap (ContinuousMap.restrict s)", "start": [271, 1], "end": [274, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_compactOpen_restrict", "code": "theorem tendsto_compactOpen_restrict {\u03b9 : Type*} {l : Filter \u03b9} {F : \u03b9 \u2192 C(\u03b1, \u03b2)} {f : C(\u03b1, \u03b2)}\n    (hFf : Filter.Tendsto F l (\ud835\udcdd f)) (s : Set \u03b1) :\n    Filter.Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd (f.restrict s))", "start": [277, 1], "end": [280, 56], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.tendsto_compactOpen_iff_forall", "code": "theorem tendsto_compactOpen_iff_forall {\u03b9 : Type*} {l : Filter \u03b9} (F : \u03b9 \u2192 C(\u03b1, \u03b2)) (f : C(\u03b1, \u03b2)) :\n    Filter.Tendsto F l (\ud835\udcdd f) \u2194\n    \u2200 (s) (hs : IsCompact s), Filter.Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd (f.restrict s))", "start": [283, 1], "end": [287, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.exists_tendsto_compactOpen_iff_forall", "code": "theorem exists_tendsto_compactOpen_iff_forall [WeaklyLocallyCompactSpace \u03b1] [T2Space \u03b2]\n    {\u03b9 : Type*} {l : Filter \u03b9} [Filter.NeBot l] (F : \u03b9 \u2192 C(\u03b1, \u03b2)) :\n    (\u2203 f, Filter.Tendsto F l (\ud835\udcdd f)) \u2194\n    \u2200 (s : Set \u03b1) (hs : IsCompact s), \u2203 f, Filter.Tendsto (fun i => (F i).restrict s) l (\ud835\udcdd f)", "start": [290, 1], "end": [318, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coev", "code": "def coev (b : \u03b2) : C(\u03b1, \u03b2 \u00d7 \u03b1) :=\n  { toFun := Prod.mk b }", "start": [327, 1], "end": [330, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.image_coev", "code": "theorem image_coev {y : \u03b2} (s : Set \u03b1) : coev \u03b1 \u03b2 y '' s = ({y} : Set \u03b2) \u00d7\u02e2 s", "start": [335, 1], "end": [336, 8], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_coev", "code": "theorem continuous_coev : Continuous (coev \u03b1 \u03b2)", "start": [340, 1], "end": [354, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.curry'", "code": "def curry' (f : C(\u03b1 \u00d7 \u03b2, \u03b3)) (a : \u03b1) : C(\u03b2, \u03b3) :=\n  \u27e8Function.curry f a, Continuous.comp f.2 (continuous_const.prod_mk continuous_id)\u27e9", "start": [361, 1], "end": [363, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_curry'", "code": "theorem continuous_curry' (f : C(\u03b1 \u00d7 \u03b2, \u03b3)) : Continuous (curry' f)", "start": [367, 1], "end": [370, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_of_continuous_uncurry", "code": "theorem continuous_of_continuous_uncurry (f : \u03b1 \u2192 C(\u03b2, \u03b3))\n    (h : Continuous (Function.uncurry fun x y => f x y)) : Continuous f", "start": [373, 1], "end": [377, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.curry", "code": "def curry (f : C(\u03b1 \u00d7 \u03b2, \u03b3)) : C(\u03b1, C(\u03b2, \u03b3)) :=\n  \u27e8_, continuous_curry' f\u27e9", "start": [380, 1], "end": [384, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.curry_apply", "code": "@[simp]\ntheorem curry_apply (f : C(\u03b1 \u00d7 \u03b2, \u03b3)) (a : \u03b1) (b : \u03b2) : f.curry a b = f (a, b)", "start": [387, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_curry", "code": "theorem continuous_curry [LocallyCompactSpace (\u03b1 \u00d7 \u03b2)] :\n    Continuous (curry : C(\u03b1 \u00d7 \u03b2, \u03b3) \u2192 C(\u03b1, C(\u03b2, \u03b3)))", "start": [392, 1], "end": [398, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_uncurry_of_continuous", "code": "theorem continuous_uncurry_of_continuous [LocallyCompactSpace \u03b2] (f : C(\u03b1, C(\u03b2, \u03b3))) :\n    Continuous (Function.uncurry fun x y => f x y)", "start": [401, 1], "end": [404, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.uncurry", "code": "@[simps]\ndef uncurry [LocallyCompactSpace \u03b2] (f : C(\u03b1, C(\u03b2, \u03b3))) : C(\u03b1 \u00d7 \u03b2, \u03b3) :=\n  \u27e8_, continuous_uncurry_of_continuous f\u27e9", "start": [407, 1], "end": [412, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_uncurry", "code": "theorem continuous_uncurry [LocallyCompactSpace \u03b1] [LocallyCompactSpace \u03b2] :\n    Continuous (uncurry : C(\u03b1, C(\u03b2, \u03b3)) \u2192 C(\u03b1 \u00d7 \u03b2, \u03b3))", "start": [415, 1], "end": [420, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.const'", "code": "def const' : C(\u03b2, C(\u03b1, \u03b2)) :=\n  curry ContinuousMap.fst", "start": [423, 1], "end": [425, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_const'", "code": "@[simp]\ntheorem coe_const' : (const' : \u03b2 \u2192 C(\u03b1, \u03b2)) = const \u03b1", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_const'", "code": "theorem continuous_const' : Continuous (const \u03b1 : \u03b2 \u2192 C(\u03b1, \u03b2))", "start": [433, 1], "end": [434, 20], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.curry", "code": "def curry [LocallyCompactSpace \u03b1] [LocallyCompactSpace \u03b2] : C(\u03b1 \u00d7 \u03b2, \u03b3) \u2243\u209c C(\u03b1, C(\u03b2, \u03b3)) :=\n  \u27e8\u27e8ContinuousMap.curry, uncurry, by intro; ext; rfl, by intro; ext; rfl\u27e9,\n    continuous_curry, continuous_uncurry\u27e9", "start": [451, 1], "end": [454, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.continuousMapOfUnique", "code": "def continuousMapOfUnique [Unique \u03b1] : \u03b2 \u2243\u209c C(\u03b1, \u03b2) where\n  toFun := const \u03b1\n  invFun f := f default\n  left_inv a := rfl\n  right_inv f := by\n    ext a\n    rw [Unique.eq_default a]\n    rfl\n  continuous_toFun := continuous_const'\n  continuous_invFun := continuous_eval_const _", "start": [457, 1], "end": [467, 47], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.continuousMapOfUnique_apply", "code": "@[simp]\ntheorem continuousMapOfUnique_apply [Unique \u03b1] (b : \u03b2) (a : \u03b1) : continuousMapOfUnique b a = b", "start": [470, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.continuousMapOfUnique_symm_apply", "code": "@[simp]\ntheorem continuousMapOfUnique_symm_apply [Unique \u03b1] (f : C(\u03b1, \u03b2)) :\n    continuousMapOfUnique.symm f = f default", "start": [475, 1], "end": [478, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.continuous_lift_prod_left", "code": "theorem QuotientMap.continuous_lift_prod_left (hf : QuotientMap f) {g : X \u00d7 Y \u2192 Z}\n    (hg : Continuous fun p : X\u2080 \u00d7 Y => g (f p.1, p.2)) : Continuous g", "start": [488, 1], "end": [499, 65], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.continuous_lift_prod_right", "code": "theorem QuotientMap.continuous_lift_prod_right (hf : QuotientMap f) {g : Y \u00d7 X \u2192 Z}\n    (hg : Continuous fun p : Y \u00d7 X\u2080 => g (p.1, f p.2)) : Continuous g", "start": [502, 1], "end": [507, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Two.lean", "imports": ["Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CharTwo.two_eq_zero", "code": "theorem two_eq_zero : (2 : R) = 0", "start": [28, 1], "end": [28, 80], "kind": "commanddeclaration"}, {"full_name": "CharTwo.add_self_eq_zero", "code": "@[simp]\ntheorem add_self_eq_zero (x : R) : x + x = 0", "start": [31, 1], "end": [32, 95], "kind": "commanddeclaration"}, {"full_name": "CharTwo.bit0_eq_zero", "code": "@[simp]\ntheorem bit0_eq_zero : (bit0 : R \u2192 R) = 0", "start": [36, 1], "end": [39, 27], "kind": "commanddeclaration"}, {"full_name": "CharTwo.bit0_apply_eq_zero", "code": "theorem bit0_apply_eq_zero (x : R) : (bit0 x : R) = 0", "start": [43, 1], "end": [43, 65], "kind": "commanddeclaration"}, {"full_name": "CharTwo.bit1_eq_one", "code": "@[simp]\ntheorem bit1_eq_one : (bit1 : R \u2192 R) = 1", "start": [47, 1], "end": [50, 14], "kind": "commanddeclaration"}, {"full_name": "CharTwo.bit1_apply_eq_one", "code": "theorem bit1_apply_eq_one (x : R) : (bit1 x : R) = 1", "start": [54, 1], "end": [54, 64], "kind": "commanddeclaration"}, {"full_name": "CharTwo.neg_eq", "code": "@[simp]\ntheorem neg_eq (x : R) : -x = x", "start": [63, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "CharTwo.neg_eq'", "code": "theorem neg_eq' : Neg.neg = (id : R \u2192 R)", "start": [68, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "CharTwo.sub_eq_add", "code": "@[simp]\ntheorem sub_eq_add (x y : R) : x - y = x + y", "start": [72, 1], "end": [73, 79], "kind": "commanddeclaration"}, {"full_name": "CharTwo.sub_eq_add'", "code": "theorem sub_eq_add' : Sub.sub = ((\u00b7 + \u00b7) : R \u2192 R \u2192 R)", "start": [76, 1], "end": [77, 49], "kind": "commanddeclaration"}, {"full_name": "CharTwo.add_sq", "code": "theorem add_sq (x y : R) : (x + y) ^ 2 = x ^ 2 + y ^ 2", "start": [86, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "CharTwo.add_mul_self", "code": "theorem add_mul_self (x y : R) : (x + y) * (x + y) = x * x + y * y", "start": [90, 1], "end": [91, 47], "kind": "commanddeclaration"}, {"full_name": "CharTwo.list_sum_sq", "code": "theorem list_sum_sq (l : List R) : l.sum ^ 2 = (l.map (\u00b7 ^ 2)).sum", "start": [96, 1], "end": [97, 24], "kind": "commanddeclaration"}, {"full_name": "CharTwo.list_sum_mul_self", "code": "theorem list_sum_mul_self (l : List R) : l.sum * l.sum = (List.map (fun x => x * x) l).sum", "start": [100, 1], "end": [101, 35], "kind": "commanddeclaration"}, {"full_name": "CharTwo.multiset_sum_sq", "code": "theorem multiset_sum_sq (l : Multiset R) : l.sum ^ 2 = (l.map (\u00b7 ^ 2)).sum", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "CharTwo.multiset_sum_mul_self", "code": "theorem multiset_sum_mul_self (l : Multiset R) :\n    l.sum * l.sum = (Multiset.map (fun x => x * x) l).sum", "start": [108, 1], "end": [109, 101], "kind": "commanddeclaration"}, {"full_name": "CharTwo.sum_sq", "code": "theorem sum_sq (s : Finset \u03b9) (f : \u03b9 \u2192 R) : (\u2211 i in s, f i) ^ 2 = \u2211 i in s, f i ^ 2", "start": [112, 1], "end": [113, 21], "kind": "commanddeclaration"}, {"full_name": "CharTwo.sum_mul_self", "code": "theorem sum_mul_self (s : Finset \u03b9) (f : \u03b9 \u2192 R) :\n    ((\u2211 i in s, f i) * \u2211 i in s, f i) = \u2211 i in s, f i * f i", "start": [116, 1], "end": [117, 94], "kind": "commanddeclaration"}, {"full_name": "neg_one_eq_one_iff", "code": "theorem neg_one_eq_one_iff [Nontrivial R] : (-1 : R) = 1 \u2194 ringChar R = 2", "start": [128, 1], "end": [131, 95], "kind": "commanddeclaration"}, {"full_name": "orderOf_neg_one", "code": "@[simp]\ntheorem orderOf_neg_one [Nontrivial R] : orderOf (-1 : R) = if ringChar R = 2 then 1 else 2", "start": [134, 1], "end": [140, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ZMod/Basic.lean", "imports": ["Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/Data/Fintype/Units.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "ZMod.charZero", "code": "instance charZero : CharZero (ZMod 0) :=\n  (by infer_instance : CharZero \u2124)", "start": [38, 1], "end": [39, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.val", "code": "def val : \u2200 {n : \u2115}, ZMod n \u2192 \u2115\n  | 0 => Int.natAbs\n  | n + 1 => ((\u2191) : Fin (n + 1) \u2192 \u2115)", "start": [41, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_lt", "code": "theorem val_lt {n : \u2115} [NeZero n] (a : ZMod n) : a.val < n", "start": [52, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_le", "code": "theorem val_le {n : \u2115} [NeZero n] (a : ZMod n) : a.val \u2264 n", "start": [58, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_zero", "code": "@[simp]\ntheorem val_zero : \u2200 {n}, (0 : ZMod n).val = 0", "start": [62, 1], "end": [65, 17], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_one'", "code": "@[simp]\ntheorem val_one' : (1 : ZMod 0).val = 1", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_neg'", "code": "@[simp]\ntheorem val_neg' {n : ZMod 0} : (-n).val = n.val", "start": [73, 1], "end": [75, 19], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_mul'", "code": "@[simp]\ntheorem val_mul' {m n : ZMod 0} : (m * n).val = m.val * n.val", "start": [78, 1], "end": [80, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_nat_cast", "code": "theorem val_nat_cast {n : \u2115} (a : \u2115) : (a : ZMod n).val = a % n", "start": [83, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_nat_cast_of_lt", "code": "theorem val_nat_cast_of_lt {n a : \u2115} (h : a < n) : (a : ZMod n).val = a", "start": [91, 1], "end": [92, 39], "kind": "commanddeclaration"}, {"full_name": "ZMod.charP", "code": "instance charP (n : \u2115) : CharP (ZMod n) n where\n    cast_eq_zero_iff' := by\n      intro k\n      cases' n with n\n      \u00b7 simp [zero_dvd_iff, Int.coe_nat_eq_zero, Nat.zero_eq]\n      rw [Fin.eq_iff_veq]\n      show (k : ZMod (n + 1)).val = (0 : ZMod (n + 1)).val \u2194 _\n      rw [val_nat_cast, val_zero, Nat.dvd_iff_mod_eq_zero]", "start": [94, 1], "end": [101, 59], "kind": "commanddeclaration"}, {"full_name": "ZMod.addOrderOf_one", "code": "@[simp]\ntheorem addOrderOf_one (n : \u2115) : addOrderOf (1 : ZMod n) = n", "start": [103, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "ZMod.addOrderOf_coe", "code": "@[simp]\ntheorem addOrderOf_coe (a : \u2115) {n : \u2115} (n0 : n \u2260 0) : addOrderOf (a : ZMod n) = n / n.gcd a", "start": [108, 1], "end": [115, 86], "kind": "commanddeclaration"}, {"full_name": "ZMod.addOrderOf_coe'", "code": "@[simp]\ntheorem addOrderOf_coe' {a : \u2115} (n : \u2115) (a0 : a \u2260 0) : addOrderOf (a : ZMod n) = n / n.gcd a", "start": [118, 1], "end": [122, 74], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringChar_zmod_n", "code": "theorem ringChar_zmod_n (n : \u2115) : ringChar (ZMod n) = n", "start": [125, 1], "end": [128, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_self", "code": "theorem nat_cast_self (n : \u2115) : (n : ZMod n) = 0", "start": [132, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_self'", "code": "@[simp]\ntheorem nat_cast_self' (n : \u2115) : (n + 1 : ZMod (n + 1)) = 0", "start": [136, 1], "end": [138, 49], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast", "code": "@[coe] def cast : \u2200 {n : \u2115}, ZMod n \u2192 R\n  | 0 => Int.cast\n  | _ + 1 => fun i => i.val", "start": [149, 1], "end": [154, 28], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_zero", "code": "@[simp]\ntheorem cast_zero : ((0 : ZMod n) : R) = 0", "start": [161, 1], "end": [166, 9], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_eq_val", "code": "theorem cast_eq_val [NeZero n] (a : ZMod n) : (a : R) = a.val", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_zmod_cast", "code": "@[simp]\ntheorem _root_.Prod.fst_zmod_cast (a : ZMod n) : (a : R \u00d7 S).fst = a", "start": [177, 1], "end": [181, 21], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_zmod_cast", "code": "@[simp]\ntheorem _root_.Prod.snd_zmod_cast (a : ZMod n) : (a : R \u00d7 S).snd = a", "start": [184, 1], "end": [188, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_zmod_val", "code": "theorem nat_cast_zmod_val {n : \u2115} [NeZero n] (a : ZMod n) : (a.val : ZMod n) = a", "start": [193, 1], "end": [198, 31], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_rightInverse", "code": "theorem nat_cast_rightInverse [NeZero n] : Function.RightInverse val ((\u2191) : \u2115 \u2192 ZMod n)", "start": [201, 1], "end": [202, 20], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_zmod_surjective", "code": "theorem nat_cast_zmod_surjective [NeZero n] : Function.Surjective ((\u2191) : \u2115 \u2192 ZMod n)", "start": [205, 1], "end": [206, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_zmod_cast", "code": "@[norm_cast]\ntheorem int_cast_zmod_cast (a : ZMod n) : ((a : \u2124) : ZMod n) = a", "start": [209, 1], "end": [216, 47], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_rightInverse", "code": "theorem int_cast_rightInverse : Function.RightInverse ((\u2191) : ZMod n \u2192 \u2124) ((\u2191) : \u2124 \u2192 ZMod n)", "start": [219, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_surjective", "code": "theorem int_cast_surjective : Function.Surjective ((\u2191) : \u2124 \u2192 ZMod n)", "start": [223, 1], "end": [224, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_id", "code": "@[norm_cast]\ntheorem cast_id : \u2200 (n) (i : ZMod n), (ZMod.cast i : ZMod n) = i", "start": [227, 1], "end": [230, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_id'", "code": "@[simp]\ntheorem cast_id' : (ZMod.cast : ZMod n \u2192 ZMod n) = id", "start": [233, 1], "end": [235, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_comp_val", "code": "@[simp]\ntheorem nat_cast_comp_val [NeZero n] : ((\u2191) : \u2115 \u2192 R) \u2218 (val : ZMod n \u2192 \u2115) = (\u2191)", "start": [240, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_comp_cast", "code": "@[simp]\ntheorem int_cast_comp_cast : ((\u2191) : \u2124 \u2192 R) \u2218 ((\u2191) : ZMod n \u2192 \u2124) = (\u2191)", "start": [248, 1], "end": [254, 27], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_val", "code": "@[simp]\ntheorem nat_cast_val [NeZero n] (i : ZMod n) : (i.val : R) = i", "start": [259, 1], "end": [261, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_cast", "code": "@[simp]\ntheorem int_cast_cast (i : ZMod n) : ((i : \u2124) : R) = i", "start": [264, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.coe_add_eq_ite", "code": "theorem coe_add_eq_ite {n : \u2115} (a b : ZMod n) :\n    (\u2191(a + b) : \u2124) = if (n : \u2124) \u2264 a + b then (a : \u2124) + b - n else a + b", "start": [269, 1], "end": [280, 8], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_one", "code": "@[simp]\ntheorem cast_one (h : m \u2223 n) : ((1 : ZMod n) : R) = 1", "start": [290, 1], "end": [301, 34], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_add", "code": "theorem cast_add (h : m \u2223 n) (a b : ZMod n) : ((a + b : ZMod n) : R) = a + b", "start": [304, 1], "end": [311, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_mul", "code": "theorem cast_mul (h : m \u2223 n) (a b : ZMod n) : ((a * b : ZMod n) : R) = a * b", "start": [314, 1], "end": [321, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.castHom", "code": "def castHom (h : m \u2223 n) (R : Type*) [Ring R] [CharP R m] : ZMod n \u2192+* R where\n  toFun := (\u2191)\n  map_zero' := cast_zero\n  map_one' := cast_one h\n  map_add' := cast_add h\n  map_mul' := cast_mul h", "start": [324, 1], "end": [333, 25], "kind": "commanddeclaration"}, {"full_name": "ZMod.castHom_apply", "code": "@[simp]\ntheorem castHom_apply {h : m \u2223 n} (i : ZMod n) : castHom h R i = i", "start": [336, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_sub", "code": "@[simp, norm_cast]\ntheorem cast_sub (h : m \u2223 n) (a b : ZMod n) : ((a - b : ZMod n) : R) = (a : R) - b", "start": [341, 1], "end": [343, 28], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_neg", "code": "@[simp, norm_cast]\ntheorem cast_neg (h : m \u2223 n) (a : ZMod n) : ((-a : ZMod n) : R) = -(a : R)", "start": [346, 1], "end": [348, 26], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_pow", "code": "@[simp, norm_cast]\ntheorem cast_pow (h : m \u2223 n) (a : ZMod n) (k : \u2115) : ((a ^ k : ZMod n) : R) = (a : R) ^ k", "start": [351, 1], "end": [353, 28], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_nat_cast", "code": "@[simp, norm_cast]\ntheorem cast_nat_cast (h : m \u2223 n) (k : \u2115) : ((k : ZMod n) : R) = k", "start": [356, 1], "end": [358, 30], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_int_cast", "code": "@[simp, norm_cast]\ntheorem cast_int_cast (h : m \u2223 n) (k : \u2124) : ((k : ZMod n) : R) = k", "start": [361, 1], "end": [363, 30], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_one'", "code": "@[simp]\ntheorem cast_one' : ((1 : ZMod n) : R) = 1", "start": [375, 1], "end": [377, 19], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_add'", "code": "@[simp]\ntheorem cast_add' (a b : ZMod n) : ((a + b : ZMod n) : R) = a + b", "start": [380, 1], "end": [382, 23], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_mul'", "code": "@[simp]\ntheorem cast_mul' (a b : ZMod n) : ((a * b : ZMod n) : R) = a * b", "start": [385, 1], "end": [387, 23], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_sub'", "code": "@[simp]\ntheorem cast_sub' (a b : ZMod n) : ((a - b : ZMod n) : R) = a - b", "start": [390, 1], "end": [392, 23], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_pow'", "code": "@[simp]\ntheorem cast_pow' (a : ZMod n) (k : \u2115) : ((a ^ k : ZMod n) : R) = (a : R) ^ k", "start": [395, 1], "end": [397, 23], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_nat_cast'", "code": "@[simp, norm_cast]\ntheorem cast_nat_cast' (k : \u2115) : ((k : ZMod n) : R) = k", "start": [400, 1], "end": [402, 26], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_int_cast'", "code": "@[simp, norm_cast]\ntheorem cast_int_cast' (k : \u2124) : ((k : ZMod n) : R) = k", "start": [405, 1], "end": [407, 26], "kind": "commanddeclaration"}, {"full_name": "ZMod.castHom_injective", "code": "theorem castHom_injective : Function.Injective (ZMod.castHom (dvd_refl n) R)", "start": [412, 1], "end": [417, 11], "kind": "commanddeclaration"}, {"full_name": "ZMod.castHom_bijective", "code": "theorem castHom_bijective [Fintype R] (h : Fintype.card R = n) :\n    Function.Bijective (ZMod.castHom (dvd_refl n) R)", "start": [420, 1], "end": [428, 31], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringEquiv", "code": "noncomputable def ringEquiv [Fintype R] (h : Fintype.card R = n) : ZMod n \u2243+* R :=\n  RingEquiv.ofBijective _ (ZMod.castHom_bijective R h)", "start": [431, 1], "end": [434, 55], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringEquivCongr", "code": "def ringEquivCongr {m n : \u2115} (h : m = n) : ZMod m \u2243+* ZMod n := by\n  cases' m with m <;> cases' n with n\n  \u00b7 exact RingEquiv.refl _\n  \u00b7 exfalso\n    exact n.succ_ne_zero h.symm\n  \u00b7 exfalso\n    exact m.succ_ne_zero h\n  \u00b7 exact\n      { Fin.castIso h with\n        map_mul' := fun a b => by\n          dsimp [ZMod]\n          ext\n          rw [Fin.coe_cast, Fin.coe_mul, Fin.coe_mul, Fin.coe_cast, Fin.coe_cast, \u2190 h]\n        map_add' := fun a b => by\n          dsimp [ZMod]\n          ext\n          rw [Fin.coe_cast, Fin.val_add, Fin.val_add, Fin.coe_cast, Fin.coe_cast, \u2190 h] }", "start": [437, 1], "end": [454, 89], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_eq_int_cast_iff", "code": "theorem int_cast_eq_int_cast_iff (a b : \u2124) (c : \u2115) : (a : ZMod c) = (b : ZMod c) \u2194 a \u2261 b [ZMOD c]", "start": [461, 1], "end": [462, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_eq_int_cast_iff'", "code": "theorem int_cast_eq_int_cast_iff' (a b : \u2124) (c : \u2115) : (a : ZMod c) = (b : ZMod c) \u2194 a % c = b % c", "start": [465, 1], "end": [466, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_eq_nat_cast_iff", "code": "theorem nat_cast_eq_nat_cast_iff (a b c : \u2115) : (a : ZMod c) = (b : ZMod c) \u2194 a \u2261 b [MOD c]", "start": [469, 1], "end": [470, 74], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_eq_nat_cast_iff'", "code": "theorem nat_cast_eq_nat_cast_iff' (a b c : \u2115) : (a : ZMod c) = (b : ZMod c) \u2194 a % c = b % c", "start": [473, 1], "end": [474, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_zmod_eq_zero_iff_dvd", "code": "theorem int_cast_zmod_eq_zero_iff_dvd (a : \u2124) (b : \u2115) : (a : ZMod b) = 0 \u2194 (b : \u2124) \u2223 a", "start": [477, 1], "end": [478, 78], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_eq_int_cast_iff_dvd_sub", "code": "theorem int_cast_eq_int_cast_iff_dvd_sub (a b : \u2124) (c : \u2115) : (a : ZMod c) = \u2191b \u2194 \u2191c \u2223 b - a", "start": [481, 1], "end": [482, 56], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_zmod_eq_zero_iff_dvd", "code": "theorem nat_cast_zmod_eq_zero_iff_dvd (a b : \u2115) : (a : ZMod b) = 0 \u2194 b \u2223 a", "start": [485, 1], "end": [486, 78], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_int_cast", "code": "theorem val_int_cast {n : \u2115} (a : \u2124) [NeZero n] : \u2191(a : ZMod n).val = a % n", "start": [489, 1], "end": [493, 89], "kind": "commanddeclaration"}, {"full_name": "ZMod.coe_int_cast", "code": "theorem coe_int_cast {n : \u2115} (a : \u2124) : \u2191(a : ZMod n) = a % n", "start": [496, 1], "end": [499, 34], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_neg_one", "code": "@[simp]\ntheorem val_neg_one (n : \u2115) : (-1 : ZMod n.succ).val = n", "start": [502, 1], "end": [508, 25], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_neg_one", "code": "theorem cast_neg_one {R : Type*} [Ring R] (n : \u2115) : \u2191(-1 : ZMod n) = (n - 1 : R)", "start": [511, 1], "end": [515, 68], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_sub_one", "code": "theorem cast_sub_one {R : Type*} [Ring R] {n : \u2115} (k : ZMod n) :\n    ((k - 1 : ZMod n) : R) = (if k = 0 then (n : R) else k) - 1", "start": [518, 1], "end": [529, 17], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_coe_zmod_eq_iff", "code": "theorem nat_coe_zmod_eq_iff (p : \u2115) (n : \u2115) (z : ZMod p) [NeZero p] :\n    \u2191n = z \u2194 \u2203 k, n = z.val + p * k", "start": [532, 1], "end": [540, 16], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_coe_zmod_eq_iff", "code": "theorem int_coe_zmod_eq_iff (p : \u2115) (n : \u2124) (z : ZMod p) [NeZero p] :\n    \u2191n = z \u2194 \u2203 k, n = z.val + p * k", "start": [543, 1], "end": [551, 55], "kind": "commanddeclaration"}, {"full_name": "ZMod.int_cast_mod", "code": "@[push_cast, simp]\ntheorem int_cast_mod (a : \u2124) (b : \u2115) : ((a % b : \u2124) : ZMod b) = (a : ZMod b)", "start": [554, 1], "end": [557, 22], "kind": "commanddeclaration"}, {"full_name": "ZMod.ker_int_castAddHom", "code": "theorem ker_int_castAddHom (n : \u2115) :\n    (Int.castAddHom (ZMod n)).ker = AddSubgroup.zmultiples (n : \u2124)", "start": [560, 1], "end": [564, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.ker_int_castRingHom", "code": "theorem ker_int_castRingHom (n : \u2115) :\n    RingHom.ker (Int.castRingHom (ZMod n)) = Ideal.span ({(n : \u2124)} : Set \u2124)", "start": [567, 1], "end": [570, 101], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_injective_of_lt", "code": "theorem cast_injective_of_lt {m n : \u2115} [nzm : NeZero m] (h : m < n) :\n    Function.Injective (@cast (ZMod n) _ m)", "start": [573, 1], "end": [582, 12], "kind": "commanddeclaration"}, {"full_name": "ZMod.cast_zmod_eq_zero_iff_of_lt", "code": "theorem cast_zmod_eq_zero_iff_of_lt {m n : \u2115} [NeZero m] (h : m < n) (a : ZMod m) :\n    (a : ZMod n) = 0 \u2194 a = 0", "start": [584, 1], "end": [587, 55], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_toNat", "code": "@[simp]\ntheorem nat_cast_toNat (p : \u2115) : \u2200 {z : \u2124} (_h : 0 \u2264 z), (z.toNat : ZMod p) = z", "start": [592, 1], "end": [595, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_injective", "code": "theorem val_injective (n : \u2115) [NeZero n] : Function.Injective (val : ZMod n \u2192 \u2115)", "start": [598, 1], "end": [604, 10], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_one_eq_one_mod", "code": "theorem val_one_eq_one_mod (n : \u2115) : (1 : ZMod n).val = 1 % n", "start": [607, 1], "end": [608, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_one", "code": "theorem val_one (n : \u2115) [Fact (1 < n)] : (1 : ZMod n).val = 1", "start": [611, 1], "end": [613, 34], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_add", "code": "theorem val_add {n : \u2115} [NeZero n] (a b : ZMod n) : (a + b).val = (a.val + b.val) % n", "start": [616, 1], "end": [619, 22], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_add_of_lt", "code": "theorem val_add_of_lt {n : \u2115} {a b : ZMod n} (h : a.val + b.val < n) :\n    (a + b).val = a.val + b.val", "start": [622, 1], "end": [625, 40], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_add_val_of_le", "code": "theorem val_add_val_of_le {n : \u2115} [NeZero n] {a b : ZMod n} (h : n \u2264 a.val + b.val) :\n    a.val + b.val = (a + b).val + n", "start": [627, 1], "end": [631, 65], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_add_of_le", "code": "theorem val_add_of_le {n : \u2115} [NeZero n] {a b : ZMod n} (h : n \u2264 a.val + b.val) :\n    (a + b).val = a.val + b.val - n", "start": [633, 1], "end": [636, 30], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_add_le", "code": "theorem val_add_le {n : \u2115} (a b : ZMod n) : (a + b).val \u2264 a.val + b.val", "start": [638, 1], "end": [641, 42], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_mul", "code": "theorem val_mul {n : \u2115} (a b : ZMod n) : (a * b).val = a.val * b.val % n", "start": [643, 1], "end": [647, 22], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_mul_le", "code": "theorem val_mul_le {n : \u2115} (a b : ZMod n) : (a * b).val \u2264 a.val * b.val", "start": [650, 1], "end": [652, 19], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_mul_of_lt", "code": "theorem val_mul_of_lt {n : \u2115} {a b : ZMod n} (h : a.val * b.val < n) :\n    (a * b).val = a.val * b.val", "start": [654, 1], "end": [657, 27], "kind": "commanddeclaration"}, {"full_name": "ZMod.nontrivial", "code": "instance nontrivial (n : \u2115) [Fact (1 < n)] : Nontrivial (ZMod n) :=\n  \u27e8\u27e80, 1, fun h =>\n      zero_ne_one <|\n        calc\n          0 = (0 : ZMod n).val := by rw [val_zero]\n          _ = (1 : ZMod n).val := (congr_arg ZMod.val h)\n          _ = 1 := val_one n\n          \u27e9\u27e9", "start": [659, 1], "end": [666, 13], "kind": "commanddeclaration"}, {"full_name": "ZMod.nontrivial'", "code": "instance nontrivial' : Nontrivial (ZMod 0) :=\n  by delta ZMod; infer_instance", "start": [669, 1], "end": [670, 32], "kind": "commanddeclaration"}, {"full_name": "ZMod.inv", "code": "def inv : \u2200 n : \u2115, ZMod n \u2192 ZMod n\n  | 0, i => Int.sign i\n  | n + 1, i => Nat.gcdA i.val (n + 1)", "start": [673, 1], "end": [678, 39], "kind": "commanddeclaration"}, {"full_name": "ZMod.inv_zero", "code": "@[nolint unusedHavesSuffices]\ntheorem inv_zero : \u2200 n : \u2115, (0 : ZMod n)\u207b\u00b9 = 0", "start": [684, 1], "end": [691, 10], "kind": "commanddeclaration"}, {"full_name": "ZMod.mul_inv_eq_gcd", "code": "theorem mul_inv_eq_gcd {n : \u2115} (a : ZMod n) : a * a\u207b\u00b9 = Nat.gcd a.val n", "start": [694, 1], "end": [708, 80], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_mod", "code": "@[simp]\ntheorem nat_cast_mod (a : \u2115) (n : \u2115) : ((a % n : \u2115) : ZMod n) = a", "start": [711, 1], "end": [716, 7], "kind": "commanddeclaration"}, {"full_name": "ZMod.eq_iff_modEq_nat", "code": "theorem eq_iff_modEq_nat (n : \u2115) {a b : \u2115} : (a : ZMod n) = b \u2194 a \u2261 b [MOD n]", "start": [719, 1], "end": [723, 18], "kind": "commanddeclaration"}, {"full_name": "ZMod.coe_mul_inv_eq_one", "code": "theorem coe_mul_inv_eq_one {n : \u2115} (x : \u2115) (h : Nat.Coprime x n) :\n    ((x : ZMod n) * (x : ZMod n)\u207b\u00b9) = 1", "start": [726, 1], "end": [729, 53], "kind": "commanddeclaration"}, {"full_name": "ZMod.unitOfCoprime", "code": "def unitOfCoprime {n : \u2115} (x : \u2115) (h : Nat.Coprime x n) : (ZMod n)\u02e3 :=\n  \u27e8x, x\u207b\u00b9, coe_mul_inv_eq_one x h, by rw [mul_comm, coe_mul_inv_eq_one x h]\u27e9", "start": [732, 1], "end": [735, 77], "kind": "commanddeclaration"}, {"full_name": "ZMod.coe_unitOfCoprime", "code": "@[simp]\ntheorem coe_unitOfCoprime {n : \u2115} (x : \u2115) (h : Nat.Coprime x n) :\n    (unitOfCoprime x h : ZMod n) = x", "start": [738, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_coe_unit_coprime", "code": "theorem val_coe_unit_coprime {n : \u2115} (u : (ZMod n)\u02e3) : Nat.Coprime (u : ZMod n).val n", "start": [744, 1], "end": [752, 44], "kind": "commanddeclaration"}, {"full_name": "ZMod.inv_coe_unit", "code": "@[simp]\ntheorem inv_coe_unit {n : \u2115} (u : (ZMod n)\u02e3) : (u : ZMod n)\u207b\u00b9 = (u\u207b\u00b9 : (ZMod n)\u02e3)", "start": [755, 1], "end": [764, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.mul_inv_of_unit", "code": "theorem mul_inv_of_unit {n : \u2115} (a : ZMod n) (h : IsUnit a) : a * a\u207b\u00b9 = 1", "start": [767, 1], "end": [769, 31], "kind": "commanddeclaration"}, {"full_name": "ZMod.inv_mul_of_unit", "code": "theorem inv_mul_of_unit {n : \u2115} (a : ZMod n) (h : IsUnit a) : a\u207b\u00b9 * a = 1", "start": [772, 1], "end": [773, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.unitsEquivCoprime", "code": "def unitsEquivCoprime {n : \u2115} [NeZero n] : (ZMod n)\u02e3 \u2243 { x : ZMod n // Nat.Coprime x.val n }\n    where\n  toFun x := \u27e8x, val_coe_unit_coprime x\u27e9\n  invFun x := unitOfCoprime x.1.val x.2\n  left_inv := fun \u27e8_, _, _, _\u27e9 => Units.ext (nat_cast_zmod_val _)\n  right_inv := fun \u27e8_, _\u27e9 => by simp", "start": [777, 1], "end": [784, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.chineseRemainder", "code": "def chineseRemainder {m n : \u2115} (h : m.Coprime n) : ZMod (m * n) \u2243+* ZMod m \u00d7 ZMod n :=\n  let to_fun : ZMod (m * n) \u2192 ZMod m \u00d7 ZMod n :=\n    ZMod.castHom (show m.lcm n \u2223 m * n by simp [Nat.lcm_dvd_iff]) (ZMod m \u00d7 ZMod n)\n  let inv_fun : ZMod m \u00d7 ZMod n \u2192 ZMod (m * n) := fun x =>\n    if m * n = 0 then if m = 1 then RingHom.snd _ _ x else RingHom.fst _ _ x\n    else Nat.chineseRemainder h x.1.val x.2.val\n  have inv : Function.LeftInverse inv_fun to_fun \u2227 Function.RightInverse inv_fun to_fun :=\n    if hmn0 : m * n = 0 then by\n      rcases h.eq_of_mul_eq_zero hmn0 with (\u27e8rfl, rfl\u27e9 | \u27e8rfl, rfl\u27e9)\n      \u00b7 constructor\n        \u00b7 intro x; rfl\n        \u00b7 rintro \u27e8x, y\u27e9\n          fin_cases y\n          simp [castHom, Prod.ext_iff]\n      \u00b7 constructor\n        \u00b7 intro x; rfl\n        \u00b7 rintro \u27e8x, y\u27e9\n          fin_cases x\n          simp [castHom, Prod.ext_iff]\n    else by\n      haveI : NeZero (m * n) := \u27e8hmn0\u27e9\n      haveI : NeZero m := \u27e8left_ne_zero_of_mul hmn0\u27e9\n      haveI : NeZero n := \u27e8right_ne_zero_of_mul hmn0\u27e9\n      have left_inv : Function.LeftInverse inv_fun to_fun := by\n        intro x\n        dsimp only [dvd_mul_left, dvd_mul_right, ZMod.castHom_apply]\n        conv_rhs => rw [\u2190 ZMod.nat_cast_zmod_val x]\n        rw [if_neg hmn0, ZMod.eq_iff_modEq_nat, \u2190 Nat.modEq_and_modEq_iff_modEq_mul h,\n          Prod.fst_zmod_cast, Prod.snd_zmod_cast]\n        refine'\n          \u27e8(Nat.chineseRemainder h (x : ZMod m).val (x : ZMod n).val).2.left.trans _,\n            (Nat.chineseRemainder h (x : ZMod m).val (x : ZMod n).val).2.right.trans _\u27e9\n        \u00b7 rw [\u2190 ZMod.eq_iff_modEq_nat, ZMod.nat_cast_zmod_val, ZMod.nat_cast_val]\n        \u00b7 rw [\u2190 ZMod.eq_iff_modEq_nat, ZMod.nat_cast_zmod_val, ZMod.nat_cast_val]\n      exact \u27e8left_inv, left_inv.rightInverse_of_card_le (by simp)\u27e9\n  { toFun := to_fun,\n    invFun := inv_fun,\n    map_mul' := RingHom.map_mul _\n    map_add' := RingHom.map_add _\n    left_inv := inv.1\n    right_inv := inv.2 }", "start": [787, 1], "end": [833, 25], "kind": "commanddeclaration"}, {"full_name": "ZMod.subsingleton_units", "code": "instance subsingleton_units : Subsingleton (ZMod 2)\u02e3 :=\n  \u27e8by decide\u27e9", "start": [837, 1], "end": [838, 14], "kind": "commanddeclaration"}, {"full_name": "ZMod.add_self_eq_zero_iff_eq_zero", "code": "@[simp]\ntheorem add_self_eq_zero_iff_eq_zero {n : \u2115} (hn : Odd n) {a : ZMod n} :\n    a + a = 0 \u2194 a = 0", "start": [841, 1], "end": [845, 95], "kind": "commanddeclaration"}, {"full_name": "ZMod.ne_neg_self", "code": "theorem ne_neg_self {n : \u2115} (hn : Odd n) {a : ZMod n} (ha : a \u2260 0) : a \u2260 -a", "start": [847, 1], "end": [848, 68], "kind": "commanddeclaration"}, {"full_name": "ZMod.neg_one_ne_one", "code": "theorem neg_one_ne_one {n : \u2115} [Fact (2 < n)] : (-1 : ZMod n) \u2260 1", "start": [851, 1], "end": [852, 34], "kind": "commanddeclaration"}, {"full_name": "ZMod.neg_eq_self_mod_two", "code": "theorem neg_eq_self_mod_two (a : ZMod 2) : -a = a", "start": [855, 1], "end": [856, 67], "kind": "commanddeclaration"}, {"full_name": "ZMod.natAbs_mod_two", "code": "@[simp]\ntheorem natAbs_mod_two (a : \u2124) : (a.natAbs : ZMod 2) = a", "start": [859, 1], "end": [863, 81], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_eq_zero", "code": "@[simp]\ntheorem val_eq_zero : \u2200 {n : \u2115} (a : ZMod n), a.val = 0 \u2194 a = 0", "start": [866, 1], "end": [871, 18], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_ne_zero", "code": "theorem val_ne_zero {n : \u2115} (a : ZMod n) : a.val \u2260 0 \u2194 a \u2260 0", "start": [874, 1], "end": [875, 22], "kind": "commanddeclaration"}, {"full_name": "ZMod.neg_eq_self_iff", "code": "theorem neg_eq_self_iff {n : \u2115} (a : ZMod n) : -a = a \u2194 a = 0 \u2228 2 * a.val = n", "start": [877, 1], "end": [902, 13], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_cast_of_lt", "code": "theorem val_cast_of_lt {n : \u2115} {a : \u2115} (h : a < n) : (a : ZMod n).val = a", "start": [905, 1], "end": [906, 40], "kind": "commanddeclaration"}, {"full_name": "ZMod.neg_val'", "code": "theorem neg_val' {n : \u2115} [NeZero n] (a : ZMod n) : (-a).val = (n - a.val) % n", "start": [909, 1], "end": [916, 23], "kind": "commanddeclaration"}, {"full_name": "ZMod.neg_val", "code": "theorem neg_val {n : \u2115} [NeZero n] (a : ZMod n) : (-a).val = if a = 0 then 0 else n - a.val", "start": [919, 1], "end": [926, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_neg_of_ne_zero", "code": "theorem val_neg_of_ne_zero {n : \u2115} [nz : NeZero n] (a : ZMod n) [na : NeZero a] :\n    (- a).val = n - a.val", "start": [929, 1], "end": [930, 61], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_sub", "code": "theorem val_sub {n : \u2115} [NeZero n] {a b : ZMod n} (h : b.val \u2264 a.val) :\n    (a - b).val = a.val - b.val", "start": [932, 1], "end": [939, 54], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_cast_eq_val_of_lt", "code": "theorem val_cast_eq_val_of_lt {m n : \u2115} [nzm : NeZero m] {a : ZMod m}\n    (h : a.val < n) : (a.cast : ZMod n).val = a.val", "start": [941, 1], "end": [949, 43], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs", "code": "def valMinAbs : \u2200 {n : \u2115}, ZMod n \u2192 \u2124\n  | 0, x => x\n  | n@(_ + 1), x => if x.val \u2264 n / 2 then x.val else (x.val : \u2124) - n", "start": [951, 1], "end": [955, 69], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_def_zero", "code": "@[simp]\ntheorem valMinAbs_def_zero (x : ZMod 0) : valMinAbs x = x", "start": [958, 1], "end": [960, 6], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_def_pos", "code": "theorem valMinAbs_def_pos {n : \u2115} [NeZero n] (x : ZMod n) :\n    valMinAbs x = if x.val \u2264 n / 2 then (x.val : \u2124) else x.val - n", "start": [963, 1], "end": [967, 8], "kind": "commanddeclaration"}, {"full_name": "ZMod.coe_valMinAbs", "code": "@[simp, norm_cast]\ntheorem coe_valMinAbs : \u2200 {n : \u2115} (x : ZMod n), (x.valMinAbs : ZMod n) = x", "start": [970, 1], "end": [977, 100], "kind": "commanddeclaration"}, {"full_name": "ZMod.injective_valMinAbs", "code": "theorem injective_valMinAbs {n : \u2115} : (valMinAbs : ZMod n \u2192 \u2124).Injective", "start": [980, 1], "end": [981, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.le_div_two_iff_mul_two_le", "code": "theorem _root_.Nat.le_div_two_iff_mul_two_le {n m : \u2115} : m \u2264 n / 2 \u2194 (m : \u2124) * 2 \u2264 n", "start": [984, 1], "end": [985, 86], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_nonneg_iff", "code": "theorem valMinAbs_nonneg_iff {n : \u2115} [NeZero n] (x : ZMod n) : 0 \u2264 x.valMinAbs \u2194 x.val \u2264 n / 2", "start": [988, 1], "end": [991, 75], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_mul_two_eq_iff", "code": "theorem valMinAbs_mul_two_eq_iff {n : \u2115} (a : ZMod n) : a.valMinAbs * 2 = n \u2194 2 * a.val = n", "start": [994, 1], "end": [1005, 62], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_mem_Ioc", "code": "theorem valMinAbs_mem_Ioc {n : \u2115} [NeZero n] (x : ZMod n) :\n    x.valMinAbs * 2 \u2208 Set.Ioc (-n : \u2124) n", "start": [1008, 1], "end": [1016, 24], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_spec", "code": "theorem valMinAbs_spec {n : \u2115} [NeZero n] (x : ZMod n) (y : \u2124) :\n    x.valMinAbs = y \u2194 x = y \u2227 y * 2 \u2208 Set.Ioc (-n : \u2124) n", "start": [1019, 1], "end": [1031, 100], "kind": "commanddeclaration"}, {"full_name": "ZMod.natAbs_valMinAbs_le", "code": "theorem natAbs_valMinAbs_le {n : \u2115} [NeZero n] (x : ZMod n) : x.valMinAbs.natAbs \u2264 n / 2", "start": [1034, 1], "end": [1040, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_zero", "code": "@[simp]\ntheorem valMinAbs_zero : \u2200 n, (0 : ZMod n).valMinAbs = 0", "start": [1043, 1], "end": [1046, 90], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_eq_zero", "code": "@[simp]\ntheorem valMinAbs_eq_zero {n : \u2115} (x : ZMod n) : x.valMinAbs = 0 \u2194 x = 0", "start": [1049, 1], "end": [1054, 35], "kind": "commanddeclaration"}, {"full_name": "ZMod.nat_cast_natAbs_valMinAbs", "code": "theorem nat_cast_natAbs_valMinAbs {n : \u2115} [NeZero n] (a : ZMod n) :\n    (a.valMinAbs.natAbs : ZMod n) = if a.val \u2264 (n : \u2115) / 2 then a else -a", "start": [1057, 1], "end": [1066, 82], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_neg_of_ne_half", "code": "theorem valMinAbs_neg_of_ne_half {n : \u2115} {a : ZMod n} (ha : 2 * a.val \u2260 n) :\n    (-a).valMinAbs = -a.valMinAbs", "start": [1069, 1], "end": [1078, 42], "kind": "commanddeclaration"}, {"full_name": "ZMod.natAbs_valMinAbs_neg", "code": "@[simp]\ntheorem natAbs_valMinAbs_neg {n : \u2115} (a : ZMod n) : (-a).valMinAbs.natAbs = a.valMinAbs.natAbs", "start": [1081, 1], "end": [1085, 54], "kind": "commanddeclaration"}, {"full_name": "ZMod.val_eq_ite_valMinAbs", "code": "theorem val_eq_ite_valMinAbs {n : \u2115} [NeZero n] (a : ZMod n) :\n    (a.val : \u2124) = a.valMinAbs + if a.val \u2264 n / 2 then 0 else n", "start": [1088, 1], "end": [1091, 48], "kind": "commanddeclaration"}, {"full_name": "ZMod.prime_ne_zero", "code": "theorem prime_ne_zero (p q : \u2115) [hp : Fact p.Prime] [hq : Fact q.Prime] (hpq : p \u2260 q) :\n    (q : ZMod p) \u2260 0", "start": [1094, 1], "end": [1097, 60], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_natAbs_eq_min", "code": "theorem valMinAbs_natAbs_eq_min {n : \u2115} [hpos : NeZero n] (a : ZMod n) :\n    a.valMinAbs.natAbs = min a.val (n - a.val)", "start": [1102, 1], "end": [1118, 27], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_natCast_of_le_half", "code": "theorem valMinAbs_natCast_of_le_half (ha : a \u2264 n / 2) : (a : ZMod n).valMinAbs = a", "start": [1121, 1], "end": [1125, 10], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_natCast_of_half_lt", "code": "theorem valMinAbs_natCast_of_half_lt (ha : n / 2 < a) (ha' : a < n) :\n    (a : ZMod n).valMinAbs = a - n", "start": [1128, 1], "end": [1132, 76], "kind": "commanddeclaration"}, {"full_name": "ZMod.valMinAbs_natCast_eq_self", "code": "@[simp]\ntheorem valMinAbs_natCast_eq_self [NeZero n] : (a : ZMod n).valMinAbs = a \u2194 a \u2264 n / 2", "start": [1136, 1], "end": [1140, 30], "kind": "commanddeclaration"}, {"full_name": "ZMod.natAbs_min_of_le_div_two", "code": "theorem natAbs_min_of_le_div_two (n : \u2115) (x y : \u2124) (he : (x : ZMod n) = y) (hl : x.natAbs \u2264 n / 2) :\n    x.natAbs \u2264 y.natAbs", "start": [1143, 1], "end": [1156, 44], "kind": "commanddeclaration"}, {"full_name": "ZMod.natAbs_valMinAbs_add_le", "code": "theorem natAbs_valMinAbs_add_le {n : \u2115} (a b : ZMod n) :\n    (a + b).valMinAbs.natAbs \u2264 (a.valMinAbs + b.valMinAbs).natAbs", "start": [1159, 1], "end": [1165, 30], "kind": "commanddeclaration"}, {"full_name": "ZMod.mul_inv_cancel_aux", "code": "private theorem mul_inv_cancel_aux (a : ZMod p) (h : a \u2260 0) : a * a\u207b\u00b9 = 1", "start": [1170, 1], "end": [1174, 82], "kind": "commanddeclaration"}, {"full_name": "RingHom.ext_zmod", "code": "theorem RingHom.ext_zmod {n : \u2115} {R : Type*} [Semiring R] (f g : ZMod n \u2192+* R) : f = g", "start": [1192, 1], "end": [1198, 19], "kind": "commanddeclaration"}, {"full_name": "ZMod.subsingleton_ringHom", "code": "instance subsingleton_ringHom [Semiring R] : Subsingleton (ZMod n \u2192+* R) :=\n  \u27e8RingHom.ext_zmod\u27e9", "start": [1205, 1], "end": [1206, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.subsingleton_ringEquiv", "code": "instance subsingleton_ringEquiv [Semiring R] : Subsingleton (ZMod n \u2243+* R) :=\n  \u27e8fun f g => by\n    rw [RingEquiv.coe_ringHom_inj_iff]\n    apply RingHom.ext_zmod _ _\u27e9", "start": [1209, 1], "end": [1212, 32], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringHom_map_cast", "code": "@[simp]\ntheorem ringHom_map_cast [Ring R] (f : R \u2192+* ZMod n) (k : ZMod n) : f k = k", "start": [1215, 1], "end": [1220, 44], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringHom_rightInverse", "code": "theorem ringHom_rightInverse [Ring R] (f : R \u2192+* ZMod n) :\n    Function.RightInverse ((\u2191) : ZMod n \u2192 R) f", "start": [1223, 1], "end": [1225, 21], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringHom_surjective", "code": "theorem ringHom_surjective [Ring R] (f : R \u2192+* ZMod n) : Function.Surjective f", "start": [1228, 1], "end": [1229, 38], "kind": "commanddeclaration"}, {"full_name": "ZMod.ringHom_eq_of_ker_eq", "code": "theorem ringHom_eq_of_ker_eq [CommRing R] (f g : R \u2192+* ZMod n)\n    (h : RingHom.ker f = RingHom.ker g) : f = g", "start": [1232, 1], "end": [1236, 85], "kind": "commanddeclaration"}, {"full_name": "ZMod.castHom_self", "code": "@[simp]\nlemma castHom_self : ZMod.castHom dvd_rfl (ZMod n) = RingHom.id (ZMod n) :=\n  Subsingleton.elim _ _", "start": [1239, 1], "end": [1241, 24], "kind": "mathlibtacticlemma"}, {"full_name": "ZMod.castHom_comp", "code": "@[simp]\nlemma castHom_comp {m d : \u2115} (hm : n \u2223 m) (hd : m \u2223 d) :\n    (castHom hm (ZMod n)).comp (castHom hd (ZMod m)) = castHom (dvd_trans hm hd) (ZMod n) :=\n  RingHom.ext_zmod _ _", "start": [1243, 1], "end": [1246, 23], "kind": "mathlibtacticlemma"}, {"full_name": "ZMod.lift", "code": "def lift : { f : \u2124 \u2192+ A // f n = 0 } \u2243 (ZMod n \u2192+ A) :=\n  (Equiv.subtypeEquivRight <| by\n        intro f\n        rw [ker_int_castAddHom]\n        constructor\n        \u00b7 rintro hf _ \u27e8x, rfl\u27e9\n          simp only [f.map_zsmul, zsmul_zero, f.mem_ker, hf]\n        \u00b7 intro h\n          refine' h (AddSubgroup.mem_zmultiples _)).trans <|\n    (Int.castAddHom (ZMod n)).liftOfRightInverse (\u2191) int_cast_zmod_cast", "start": [1252, 1], "end": [1263, 72], "kind": "commanddeclaration"}, {"full_name": "ZMod.lift_coe", "code": "@[simp]\ntheorem lift_coe (x : \u2124) : lift n f (x : ZMod n) = f.val x", "start": [1268, 1], "end": [1270, 85], "kind": "commanddeclaration"}, {"full_name": "ZMod.lift_castAddHom", "code": "theorem lift_castAddHom (x : \u2124) : lift n f (Int.castAddHom (ZMod n) x) = f.1 x", "start": [1273, 1], "end": [1274, 85], "kind": "commanddeclaration"}, {"full_name": "ZMod.lift_comp_coe", "code": "@[simp]\ntheorem lift_comp_coe : ZMod.lift n f \u2218 ((\u2191) : \u2124 \u2192 _) = f", "start": [1277, 1], "end": [1279, 25], "kind": "commanddeclaration"}, {"full_name": "ZMod.lift_comp_castAddHom", "code": "@[simp]\ntheorem lift_comp_castAddHom : (ZMod.lift n f).comp (Int.castAddHom (ZMod n)) = f", "start": [1282, 1], "end": [1284, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Factorization/Basic.lean", "imports": ["Mathlib/Data/Nat/PrimeFin.lean", "Mathlib/Tactic/IntervalCases.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/Padics/PadicVal.lean", "Mathlib/Data/Finsupp/Multiset.lean", "Mathlib/Data/Nat/Interval.lean"], "premises": [{"full_name": "Nat.factorization", "code": "def factorization (n : \u2115) : \u2115 \u2192\u2080 \u2115 where\n  support := n.factors.toFinset\n  toFun p := if p.Prime then padicValNat p n else 0\n  mem_support_toFun := by\n    rcases eq_or_ne n 0 with (rfl | hn0)\n    \u00b7 simp\n    simp only [mem_factors hn0, mem_toFinset, Ne.def, ite_eq_right_iff, not_forall, exists_prop,\n      and_congr_right_iff]\n    rintro p hp\n    haveI := fact_iff.mpr hp\n    exact dvd_iff_padicValNat_ne_zero hn0", "start": [51, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_def", "code": "theorem factorization_def (n : \u2115) {p : \u2115} (pp : p.Prime) : n.factorization p = padicValNat p n", "start": [66, 1], "end": [67, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_count_eq", "code": "@[simp]\ntheorem factors_count_eq {n p : \u2115} : n.factors.count p = n.factorization p", "start": [70, 1], "end": [83, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_factors_multiset", "code": "theorem factorization_eq_factors_multiset (n : \u2115) :\n    n.factorization = Multiset.toFinsupp (n.factors : Multiset \u2115)", "start": [86, 1], "end": [89, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.multiplicity_eq_factorization", "code": "theorem multiplicity_eq_factorization {n p : \u2115} (pp : p.Prime) (hn : n \u2260 0) :\n    multiplicity p n = n.factorization p", "start": [92, 1], "end": [94, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_prod_pow_eq_self", "code": "@[simp]\ntheorem factorization_prod_pow_eq_self {n : \u2115} (hn : n \u2260 0) : n.factorization.prod (\u00b7 ^ \u00b7) = n", "start": [100, 1], "end": [104, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_factorization_eq", "code": "theorem eq_of_factorization_eq {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : \u2200 p : \u2115, a.factorization p = b.factorization p) : a = b", "start": [107, 1], "end": [109, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_inj", "code": "theorem factorization_inj : Set.InjOn factorization { x : \u2115 | x \u2260 0 }", "start": [112, 1], "end": [114, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_zero", "code": "@[simp]\ntheorem factorization_zero : factorization 0 = 0", "start": [117, 1], "end": [118, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_one", "code": "@[simp]\ntheorem factorization_one : factorization 1 = 0", "start": [121, 1], "end": [122, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.support_factorization", "code": "@[simp]\ntheorem support_factorization {n : \u2115} : n.factorization.support = n.factors.toFinset", "start": [125, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.factor_iff_mem_factorization", "code": "theorem factor_iff_mem_factorization {n p : \u2115} : p \u2208 n.factorization.support \u2194 p \u2208 n.factors", "start": [131, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_of_mem_factorization", "code": "theorem prime_of_mem_factorization {n p : \u2115} (hp : p \u2208 n.factorization.support) : p.Prime", "start": [135, 1], "end": [136, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_mem_factorization", "code": "theorem pos_of_mem_factorization {n p : \u2115} (hp : p \u2208 n.factorization.support) : 0 < p", "start": [139, 1], "end": [140, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_mem_factorization", "code": "theorem le_of_mem_factorization {n p : \u2115} (h : p \u2208 n.factorization.support) : p \u2264 n", "start": [143, 1], "end": [144, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_iff", "code": "theorem factorization_eq_zero_iff (n p : \u2115) :\n    n.factorization p = 0 \u2194 \u00acp.Prime \u2228 \u00acp \u2223 n \u2228 n = 0", "start": [150, 1], "end": [155, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_of_non_prime", "code": "@[simp]\ntheorem factorization_eq_zero_of_non_prime (n : \u2115) {p : \u2115} (hp : \u00acp.Prime) :\n    n.factorization p = 0", "start": [158, 1], "end": [160, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_of_not_dvd", "code": "theorem factorization_eq_zero_of_not_dvd {n p : \u2115} (h : \u00acp \u2223 n) : n.factorization p = 0", "start": [163, 1], "end": [164, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_of_lt", "code": "theorem factorization_eq_zero_of_lt {n p : \u2115} (h : n < p) : n.factorization p = 0", "start": [167, 1], "end": [168, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_zero_right", "code": "@[simp]\ntheorem factorization_zero_right (n : \u2115) : n.factorization 0 = 0", "start": [171, 1], "end": [173, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_one_right", "code": "@[simp]\ntheorem factorization_one_right (n : \u2115) : n.factorization 1 = 0", "start": [176, 1], "end": [178, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_factorization_pos", "code": "theorem dvd_of_factorization_pos {n p : \u2115} (hn : n.factorization p \u2260 0) : p \u2223 n", "start": [181, 1], "end": [182, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.factorization_pos_of_dvd", "code": "theorem Prime.factorization_pos_of_dvd {n p : \u2115} (hp : p.Prime) (hn : n \u2260 0) (h : p \u2223 n) :\n    0 < n.factorization p", "start": [185, 1], "end": [187, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_of_remainder", "code": "theorem factorization_eq_zero_of_remainder {p r : \u2115} (i : \u2115) (hr : \u00acp \u2223 r) :\n    (p * i + r).factorization p = 0", "start": [190, 1], "end": [193, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_iff_remainder", "code": "theorem factorization_eq_zero_iff_remainder {p r : \u2115} (i : \u2115) (pp : p.Prime) (hr0 : r \u2260 0) :\n    \u00acp \u2223 r \u2194 (p * i + r).factorization p = 0", "start": [196, 1], "end": [204, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_zero_iff'", "code": "theorem factorization_eq_zero_iff' (n : \u2115) : n.factorization = 0 \u2194 n = 0 \u2228 n = 1", "start": [207, 1], "end": [210, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_mul", "code": "@[simp]\ntheorem factorization_mul {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a * b).factorization = a.factorization + b.factorization", "start": [216, 1], "end": [222, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_mul_support", "code": "theorem factorization_mul_support {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a * b).factorization.support = a.factorization.support \u222a b.factorization.support", "start": [225, 1], "end": [229, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_factorization_eq_prod_factors", "code": "theorem prod_factorization_eq_prod_factors {n : \u2115} {\u03b2 : Type*} [CommMonoid \u03b2] (f : \u2115 \u2192 \u03b2) :\n    (n.factorization.prod fun p _ => f p) = \u220f p in n.factors.toFinset, f p", "start": [232, 1], "end": [237, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_prod", "code": "theorem factorization_prod {\u03b1 : Type*} {S : Finset \u03b1} {g : \u03b1 \u2192 \u2115} (hS : \u2200 x \u2208 S, g x \u2260 0) :\n    (S.prod g).factorization = S.sum fun x => (g x).factorization", "start": [240, 1], "end": [251, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_pow", "code": "@[simp]\ntheorem factorization_pow (n k : \u2115) : factorization (n ^ k) = k \u2022 n.factorization", "start": [254, 1], "end": [261, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.factorization", "code": "@[simp]\ntheorem Prime.factorization {p : \u2115} (hp : Prime p) : p.factorization = single p 1", "start": [267, 1], "end": [272, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.factorization_self", "code": "@[simp]\ntheorem Prime.factorization_self {p : \u2115} (hp : Prime p) : p.factorization p = 1", "start": [275, 1], "end": [277, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.factorization_pow", "code": "theorem Prime.factorization_pow {p k : \u2115} (hp : Prime p) : (p ^ k).factorization = single p k", "start": [280, 1], "end": [282, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_pow_of_factorization_eq_single", "code": "theorem eq_pow_of_factorization_eq_single {n p k : \u2115} (hn : n \u2260 0)\n    (h : n.factorization = Finsupp.single p k) : n = p ^ k", "start": [285, 1], "end": [290, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.eq_of_factorization_pos", "code": "theorem Prime.eq_of_factorization_pos {p q : \u2115} (hp : Prime p) (h : p.factorization q \u2260 0) :\n    p = q", "start": [293, 1], "end": [295, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_pow_factorization_eq_self", "code": "theorem prod_pow_factorization_eq_self {f : \u2115 \u2192\u2080 \u2115} (hf : \u2200 p : \u2115, p \u2208 f.support \u2192 Prime p) :\n    (f.prod (\u00b7 ^ \u00b7)).factorization = f", "start": [301, 1], "end": [311, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_factorization_iff", "code": "theorem eq_factorization_iff {n : \u2115} {f : \u2115 \u2192\u2080 \u2115} (hn : n \u2260 0) (hf : \u2200 p \u2208 f.support, Prime p) :\n    f = n.factorization \u2194 f.prod (\u00b7 ^ \u00b7) = n", "start": [314, 1], "end": [317, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.factorizationEquiv", "code": "def factorizationEquiv : \u2115+ \u2243 { f : \u2115 \u2192\u2080 \u2115 | \u2200 p \u2208 f.support, Prime p } where\n  toFun := fun \u27e8n, _\u27e9 => \u27e8n.factorization, fun _ => prime_of_mem_factorization\u27e9\n  invFun := fun \u27e8f, hf\u27e9 =>\n    \u27e8f.prod _, prod_pow_pos_of_zero_not_mem_support fun H => not_prime_zero (hf 0 H)\u27e9\n  left_inv := fun \u27e8_, hx\u27e9 => Subtype.ext <| factorization_prod_pow_eq_self hx.ne.symm\n  right_inv := fun \u27e8_, hf\u27e9 => Subtype.ext <| prod_pow_factorization_eq_self hf", "start": [320, 1], "end": [326, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.factorizationEquiv_apply", "code": "theorem factorizationEquiv_apply (n : \u2115+) : (factorizationEquiv n).1 = n.1.factorization", "start": [329, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.factorizationEquiv_inv_apply", "code": "theorem factorizationEquiv_inv_apply {f : \u2115 \u2192\u2080 \u2115} (hf : \u2200 p \u2208 f.support, Prime p) :\n    (factorizationEquiv.symm \u27e8f, hf\u27e9).1 = f.prod (\u00b7 ^ \u00b7)", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_of_not_prime", "code": "@[simp]\ntheorem ord_proj_of_not_prime (n p : \u2115) (hp : \u00acp.Prime) : ord_proj[p] n = 1", "start": [354, 1], "end": [356, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_of_not_prime", "code": "@[simp]\ntheorem ord_compl_of_not_prime (n p : \u2115) (hp : \u00acp.Prime) : ord_compl[p] n = n", "start": [359, 1], "end": [361, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_dvd", "code": "theorem ord_proj_dvd (n p : \u2115) : ord_proj[p] n \u2223 n", "start": [364, 1], "end": [371, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_dvd", "code": "theorem ord_compl_dvd (n p : \u2115) : ord_compl[p] n \u2223 n", "start": [374, 1], "end": [375, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_pos", "code": "theorem ord_proj_pos (n p : \u2115) : 0 < ord_proj[p] n", "start": [378, 1], "end": [381, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_le", "code": "theorem ord_proj_le {n : \u2115} (p : \u2115) (hn : n \u2260 0) : ord_proj[p] n \u2264 n", "start": [384, 1], "end": [385, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_pos", "code": "theorem ord_compl_pos {n : \u2115} (p : \u2115) (hn : n \u2260 0) : 0 < ord_compl[p] n", "start": [388, 1], "end": [391, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_le", "code": "theorem ord_compl_le (n p : \u2115) : ord_compl[p] n \u2264 n", "start": [394, 1], "end": [395, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_mul_ord_compl_eq_self", "code": "theorem ord_proj_mul_ord_compl_eq_self (n p : \u2115) : ord_proj[p] n * ord_compl[p] n = n", "start": [398, 1], "end": [399, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_mul", "code": "theorem ord_proj_mul {a b : \u2115} (p : \u2115) (ha : a \u2260 0) (hb : b \u2260 0) :\n    ord_proj[p] (a * b) = ord_proj[p] a * ord_proj[p] b", "start": [402, 1], "end": [404, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_mul", "code": "theorem ord_compl_mul (a b p : \u2115) : ord_compl[p] (a * b) = ord_compl[p] a * ord_compl[p] b", "start": [407, 1], "end": [413, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_mem_factorization", "code": "theorem dvd_of_mem_factorization {n p : \u2115} (h : p \u2208 n.factorization.support) : p \u2223 n", "start": [419, 1], "end": [422, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_lt", "code": "theorem factorization_lt {n : \u2115} (p : \u2115) (hn : n \u2260 0) : n.factorization p < n", "start": [425, 1], "end": [433, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_le_of_le_pow", "code": "theorem factorization_le_of_le_pow {n p b : \u2115} (hb : n \u2264 p ^ b) : n.factorization p \u2264 b", "start": [436, 1], "end": [442, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_le_iff_dvd", "code": "theorem factorization_le_iff_dvd {d n : \u2115} (hd : d \u2260 0) (hn : n \u2260 0) :\n    d.factorization \u2264 n.factorization \u2194 d \u2223 n", "start": [445, 1], "end": [455, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_prime_le_iff_dvd", "code": "theorem factorization_prime_le_iff_dvd {d n : \u2115} (hd : d \u2260 0) (hn : n \u2260 0) :\n    (\u2200 p : \u2115, p.Prime \u2192 d.factorization p \u2264 n.factorization p) \u2194 d \u2223 n", "start": [458, 1], "end": [462, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_succ_factorization_not_dvd", "code": "theorem pow_succ_factorization_not_dvd {n p : \u2115} (hn : n \u2260 0) (hp : p.Prime) :\n    \u00acp ^ (n.factorization p + 1) \u2223 n", "start": [465, 1], "end": [469, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_le_factorization_mul_left", "code": "theorem factorization_le_factorization_mul_left {a b : \u2115} (hb : b \u2260 0) :\n    a.factorization \u2264 (a * b).factorization", "start": [472, 1], "end": [477, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_le_factorization_mul_right", "code": "theorem factorization_le_factorization_mul_right {a b : \u2115} (ha : a \u2260 0) :\n    b.factorization \u2264 (a * b).factorization", "start": [480, 1], "end": [483, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_dvd_iff_le_factorization", "code": "theorem Prime.pow_dvd_iff_le_factorization {p k n : \u2115} (pp : Prime p) (hn : n \u2260 0) :\n    p ^ k \u2223 n \u2194 k \u2264 n.factorization p", "start": [486, 1], "end": [488, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_dvd_iff_dvd_ord_proj", "code": "theorem Prime.pow_dvd_iff_dvd_ord_proj {p k n : \u2115} (pp : Prime p) (hn : n \u2260 0) :\n    p ^ k \u2223 n \u2194 p ^ k \u2223 ord_proj[p] n", "start": [491, 1], "end": [493, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_iff_one_le_factorization", "code": "theorem Prime.dvd_iff_one_le_factorization {p n : \u2115} (pp : Prime p) (hn : n \u2260 0) :\n    p \u2223 n \u2194 1 \u2264 n.factorization p", "start": [496, 1], "end": [498, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_factorization_lt_of_lt", "code": "theorem exists_factorization_lt_of_lt {a b : \u2115} (ha : a \u2260 0) (hab : a < b) :\n    \u2203 p : \u2115, a.factorization p < b.factorization p", "start": [501, 1], "end": [506, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_div", "code": "@[simp]\ntheorem factorization_div {d n : \u2115} (h : d \u2223 n) :\n    (n / d).factorization = n.factorization - d.factorization", "start": [509, 1], "end": [518, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_ord_proj_of_dvd", "code": "theorem dvd_ord_proj_of_dvd {n p : \u2115} (hn : n \u2260 0) (pp : p.Prime) (h : p \u2223 n) : p \u2223 ord_proj[p] n", "start": [521, 1], "end": [522, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.not_dvd_ord_compl", "code": "theorem not_dvd_ord_compl {n p : \u2115} (hp : Prime p) (hn : n \u2260 0) : \u00acp \u2223 ord_compl[p] n", "start": [525, 1], "end": [528, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_ord_compl", "code": "theorem coprime_ord_compl {n p : \u2115} (hp : Prime p) (hn : n \u2260 0) : Coprime p (ord_compl[p] n)", "start": [531, 1], "end": [532, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_ord_compl", "code": "theorem factorization_ord_compl (n p : \u2115) :\n    (ord_compl[p] n).factorization = n.factorization.erase p", "start": [535, 1], "end": [549, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_ord_compl_of_dvd_not_dvd", "code": "theorem dvd_ord_compl_of_dvd_not_dvd {p d n : \u2115} (hdn : d \u2223 n) (hpd : \u00acp \u2223 d) :\n    d \u2223 ord_compl[p] n", "start": [553, 1], "end": [562, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_eq_pow_mul_and_not_dvd", "code": "theorem exists_eq_pow_mul_and_not_dvd {n : \u2115} (hn : n \u2260 0) (p : \u2115) (hp : p \u2260 1) :\n    \u2203 e n' : \u2115, \u00acp \u2223 n' \u2227 n = p ^ e * n'", "start": [565, 1], "end": [572, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_div_factorization_eq_tsub", "code": "theorem dvd_iff_div_factorization_eq_tsub {d n : \u2115} (hd : d \u2260 0) (hdn : d \u2264 n) :\n    d \u2223 n \u2194 (n / d).factorization = n.factorization - d.factorization", "start": [575, 1], "end": [585, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_dvd_ord_proj_of_dvd", "code": "theorem ord_proj_dvd_ord_proj_of_dvd {a b : \u2115} (hb0 : b \u2260 0) (hab : a \u2223 b) (p : \u2115) :\n    ord_proj[p] a \u2223 ord_proj[p] b", "start": [588, 1], "end": [593, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_proj_dvd_ord_proj_iff_dvd", "code": "theorem ord_proj_dvd_ord_proj_iff_dvd {a b : \u2115} (ha0 : a \u2260 0) (hb0 : b \u2260 0) :\n    (\u2200 p : \u2115, ord_proj[p] a \u2223 ord_proj[p] b) \u2194 a \u2223 b", "start": [596, 1], "end": [603, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_dvd_ord_compl_of_dvd", "code": "theorem ord_compl_dvd_ord_compl_of_dvd {a b : \u2115} (hab : a \u2223 b) (p : \u2115) :\n    ord_compl[p] a \u2223 ord_compl[p] b", "start": [606, 1], "end": [621, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.ord_compl_dvd_ord_compl_iff_dvd", "code": "theorem ord_compl_dvd_ord_compl_iff_dvd (a b : \u2115) :\n    (\u2200 p : \u2115, ord_compl[p] a \u2223 ord_compl[p] b) \u2194 a \u2223 b", "start": [624, 1], "end": [637, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_prime_pow_dvd_dvd", "code": "theorem dvd_iff_prime_pow_dvd_dvd (n d : \u2115) :\n    d \u2223 n \u2194 \u2200 p k : \u2115, Prime p \u2192 p ^ k \u2223 d \u2192 p ^ k \u2223 n", "start": [640, 1], "end": [651, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_prime_factors_dvd", "code": "theorem prod_prime_factors_dvd (n : \u2115) : (\u220f p : \u2115 in n.factors.toFinset, p) \u2223 n", "start": [654, 1], "end": [658, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_gcd", "code": "theorem factorization_gcd {a b : \u2115} (ha_pos : a \u2260 0) (hb_pos : b \u2260 0) :\n    (gcd a b).factorization = a.factorization \u2293 b.factorization", "start": [661, 1], "end": [683, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_lcm", "code": "theorem factorization_lcm {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a.lcm b).factorization = a.factorization \u2294 b.factorization", "start": [686, 1], "end": [692, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_factors_gcd_mul_prod_factors_mul", "code": "@[to_additive sum_factors_gcd_add_sum_factors_mul]\ntheorem prod_factors_gcd_mul_prod_factors_mul {\u03b2 : Type*} [CommMonoid \u03b2] (m n : \u2115) (f : \u2115 \u2192 \u03b2) :\n    (m.gcd n).factors.toFinset.prod f * (m * n).factors.toFinset.prod f =\n      m.factors.toFinset.prod f * n.factors.toFinset.prod f", "start": [695, 1], "end": [706, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.setOf_pow_dvd_eq_Icc_factorization", "code": "theorem setOf_pow_dvd_eq_Icc_factorization {n p : \u2115} (pp : p.Prime) (hn : n \u2260 0) :\n    { i : \u2115 | i \u2260 0 \u2227 p ^ i \u2223 n } = Set.Icc 1 (n.factorization p)", "start": [710, 1], "end": [713, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.Icc_factorization_eq_pow_dvd", "code": "theorem Icc_factorization_eq_pow_dvd (n : \u2115) {p : \u2115} (pp : Prime p) :\n    Icc 1 (n.factorization p) = (Ico 1 n).filter fun i : \u2115 => p ^ i \u2223 n", "start": [716, 1], "end": [725, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_card_pow_dvd", "code": "theorem factorization_eq_card_pow_dvd (n : \u2115) {p : \u2115} (pp : p.Prime) :\n    n.factorization p = ((Ico 1 n).filter fun i => p ^ i \u2223 n).card", "start": [728, 1], "end": [730, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_filter_pow_dvd_eq", "code": "theorem Ico_filter_pow_dvd_eq {n p b : \u2115} (pp : p.Prime) (hn : n \u2260 0) (hb : n \u2264 p ^ b) :\n    ((Ico 1 n).filter fun i => p ^ i \u2223 n) = (Icc 1 b).filter fun i => p ^ i \u2223 n", "start": [733, 1], "end": [739, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_mul_apply_of_coprime", "code": "theorem factorization_mul_apply_of_coprime {p a b : \u2115} (hab : Coprime a b) :\n    (a * b).factorization p = a.factorization p + b.factorization p", "start": [745, 1], "end": [748, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_mul_of_coprime", "code": "theorem factorization_mul_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    (a * b).factorization = a.factorization + b.factorization", "start": [751, 1], "end": [755, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_of_coprime_left", "code": "theorem factorization_eq_of_coprime_left {p a b : \u2115} (hab : Coprime a b) (hpa : p \u2208 a.factors) :\n    (a * b).factorization p = a.factorization p", "start": [758, 1], "end": [763, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_eq_of_coprime_right", "code": "theorem factorization_eq_of_coprime_right {p a b : \u2115} (hab : Coprime a b) (hpb : p \u2208 b.factors) :\n    (a * b).factorization p = b.factorization p", "start": [766, 1], "end": [771, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_disjoint_of_coprime", "code": "theorem factorization_disjoint_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    Disjoint a.factorization.support b.factorization.support", "start": [774, 1], "end": [778, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.factorization_mul_support_of_coprime", "code": "theorem factorization_mul_support_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    (a * b).factorization.support = a.factorization.support \u222a b.factorization.support", "start": [781, 1], "end": [785, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.recOnPrimePow", "code": "@[elab_as_elim]\ndef recOnPrimePow {P : \u2115 \u2192 Sort*} (h0 : P 0) (h1 : P 1)\n    (h : \u2200 a p n : \u2115, p.Prime \u2192 \u00acp \u2223 a \u2192 0 < n \u2192 P a \u2192 P (p ^ n * a)) : \u2200 a : \u2115, P a := fun a =>\n  Nat.strongRecOn a fun n =>\n    match n with\n    | 0 => fun _ => h0\n    | 1 => fun _ => h1\n    | k + 2 => fun hk => by\n      letI p := (k + 2).minFac\n      haveI hp : Prime p := minFac_prime (succ_succ_ne_one k)\n      letI t := (k + 2).factorization p\n      haveI hpt : p ^ t \u2223 k + 2 := ord_proj_dvd _ _\n      haveI htp : 0 < t := hp.factorization_pos_of_dvd (k + 1).succ_ne_zero (k + 2).minFac_dvd\n      convert h ((k + 2) / p ^ t) p t hp _ htp (hk _ (Nat.div_lt_of_lt_mul _)) using 1\n      \u00b7 rw [Nat.mul_div_cancel' hpt]\n      \u00b7 rw [Nat.dvd_div_iff hpt, \u2190 pow_succ]\n        exact pow_succ_factorization_not_dvd (k + 1).succ_ne_zero hp\n      \u00b7 rw [lt_mul_iff_one_lt_left Nat.succ_pos', one_lt_pow_iff htp.ne]\n        exact hp.one_lt", "start": [791, 1], "end": [811, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.recOnPosPrimePosCoprime", "code": "@[elab_as_elim]\ndef recOnPosPrimePosCoprime {P : \u2115 \u2192 Sort*} (hp : \u2200 p n : \u2115, Prime p \u2192 0 < n \u2192 P (p ^ n))\n    (h0 : P 0) (h1 : P 1) (h : \u2200 a b, 1 < a \u2192 1 < b \u2192 Coprime a b \u2192 P a \u2192 P b \u2192 P (a * b)) :\n    \u2200 a, P a :=\n  recOnPrimePow h0 h1 <| by\n    intro a p n hp' hpa hn hPa\n    by_cases ha1 : a = 1\n    \u00b7 rw [ha1, mul_one]\n      exact hp p n hp' hn\n    refine' h (p ^ n) a (hp'.one_lt.trans_le (le_self_pow hn.ne' _)) _ _ (hp _ _ hp' hn) hPa\n    \u00b7 contrapose! hpa\n      simp [lt_one_iff.1 (lt_of_le_of_ne hpa ha1)]\n    simpa [hn, Prime.coprime_iff_not_dvd hp']", "start": [816, 1], "end": [830, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.recOnPrimeCoprime", "code": "@[elab_as_elim]\ndef recOnPrimeCoprime {P : \u2115 \u2192 Sort*} (h0 : P 0) (hp : \u2200 p n : \u2115, Prime p \u2192 P (p ^ n))\n    (h : \u2200 a b, 1 < a \u2192 1 < b \u2192 Coprime a b \u2192 P a \u2192 P b \u2192 P (a * b)) : \u2200 a, P a :=\n  recOnPosPrimePosCoprime (fun p n h _ => hp p n h) h0 (hp 2 0 prime_two) h", "start": [833, 1], "end": [838, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.recOnMul", "code": "@[elab_as_elim]\ndef recOnMul {P : \u2115 \u2192 Sort*} (h0 : P 0) (h1 : P 1) (hp : \u2200 p, Prime p \u2192 P p)\n    (h : \u2200 a b, P a \u2192 P b \u2192 P (a * b)) : \u2200 a, P a :=\n  let hp : \u2200 p n : \u2115, Prime p \u2192 P (p ^ n) := fun p n hp' =>\n    n.recOn h1 (fun n hn => by rw [pow_succ]; apply h _ _ hn (hp p hp'))\n    recOnPrimeCoprime h0 hp fun a b _ _ _ => h a b", "start": [841, 1], "end": [852, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.multiplicative_factorization", "code": "theorem multiplicative_factorization {\u03b2 : Type*} [CommMonoid \u03b2] (f : \u2115 \u2192 \u03b2)\n    (h_mult : \u2200 x y : \u2115, Coprime x y \u2192 f (x * y) = f x * f y) (hf : f 1 = 1) :\n    \u2200 {n : \u2115}, n \u2260 0 \u2192 f n = n.factorization.prod fun p k => f (p ^ k)", "start": [855, 1], "end": [872, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.multiplicative_factorization'", "code": "theorem multiplicative_factorization' {\u03b2 : Type*} [CommMonoid \u03b2] (f : \u2115 \u2192 \u03b2)\n    (h_mult : \u2200 x y : \u2115, Coprime x y \u2192 f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) :\n    \u2200 {n : \u2115}, f n = n.factorization.prod fun p k => f (p ^ k)", "start": [875, 1], "end": [890, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_iff_prime_padicValNat_eq", "code": "theorem eq_iff_prime_padicValNat_eq (a b : \u2115) (ha : a \u2260 0) (hb : b \u2260 0) :\n    a = b \u2194 \u2200 p : \u2115, p.Prime \u2192 padicValNat p a = padicValNat p b", "start": [893, 1], "end": [903, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_pow_prime_padicValNat", "code": "theorem prod_pow_prime_padicValNat (n : Nat) (hn : n \u2260 0) (m : Nat) (pr : n < m) :\n    (\u220f p in Finset.filter Nat.Prime (Finset.range m), p ^ padicValNat p n) = n", "start": [906, 1], "end": [923, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.card_multiples", "code": "theorem card_multiples (n p : \u2115) : card ((Finset.range n).filter fun e => p \u2223 e + 1) = n / p", "start": [930, 1], "end": [935, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.Ioc_filter_dvd_card_eq_div", "code": "theorem Ioc_filter_dvd_card_eq_div (n p : \u2115) : ((Ioc 0 n).filter fun x => p \u2223 x).card = n / p", "start": [938, 1], "end": [948, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Periodic.lean", "imports": ["Mathlib/Data/Nat/Interval.lean", "Mathlib/Algebra/Periodic.lean", "Mathlib/Data/Nat/Count.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.periodic_gcd", "code": "theorem periodic_gcd (a : \u2115) : Periodic (gcd a) a", "start": [24, 1], "end": [25, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.periodic_coprime", "code": "theorem periodic_coprime (a : \u2115) : Periodic (Coprime a) a", "start": [28, 1], "end": [29, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.periodic_mod", "code": "theorem periodic_mod (a : \u2115) : Periodic (fun n => n % a) a", "start": [32, 1], "end": [33, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.map_mod_nat", "code": "theorem _root_.Function.Periodic.map_mod_nat {\u03b1 : Type*} {f : \u2115 \u2192 \u03b1} {a : \u2115} (hf : Periodic f a) :\n    \u2200 n, f (n % a) = f n", "start": [36, 1], "end": [38, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_multiset_Ico_card_eq_of_periodic", "code": "theorem filter_multiset_Ico_card_eq_of_periodic (n a : \u2115) (p : \u2115 \u2192 Prop) [DecidablePred p]\n    (pp : Periodic p a) : card (filter p (Ico n (n + a))) = a.count p", "start": [45, 1], "end": [53, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_Ico_card_eq_of_periodic", "code": "theorem filter_Ico_card_eq_of_periodic (n a : \u2115) (p : \u2115 \u2192 Prop) [DecidablePred p]\n    (pp : Periodic p a) : ((Ico n (n + a)).filter p).card = a.count p", "start": [62, 1], "end": [66, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Cones.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/CategoryTheory/Functor/Const.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/CategoryTheory/Yoneda.lean"], "premises": [{"full_name": "CategoryTheory.Functor.cones", "code": "@[simps!]\ndef cones : C\u1d52\u1d56 \u2964 Type max u\u2081 v\u2083 :=\n  (const J).op \u22d9 yoneda.obj F", "start": [66, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.cocones", "code": "@[simps!]\ndef cocones : C \u2964 Type max u\u2081 v\u2083 :=\n  const J \u22d9 coyoneda.obj (op F)", "start": [75, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cones", "code": "@[simps!]\ndef cones : (J \u2964 C) \u2964 C\u1d52\u1d56 \u2964 Type max u\u2081 v\u2083 where\n  obj := Functor.cones\n  map f := whiskerLeft (const J).op (yoneda.map f)", "start": [90, 1], "end": [96, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cocones", "code": "@[simps!]\ndef cocones : (J \u2964 C)\u1d52\u1d56 \u2964 C \u2964 Type max u\u2081 v\u2083 where\n  obj F := Functor.cocones (unop F)\n  map f := whiskerLeft (const J) (coyoneda.map f)", "start": [99, 1], "end": [105, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone", "code": "structure Cone (F : J \u2964 C) where\n  \n  pt : C\n  \n  \u03c0 : (const J).obj pt \u27f6 F", "start": [114, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inhabitedCone", "code": "instance inhabitedCone (F : Discrete PUnit \u2964 C) : Inhabited (Cone F) :=\n  \u27e8{  pt := F.obj \u27e8\u27e8\u27e9\u27e9\n      \u03c0 := { app := fun \u27e8\u27e8\u27e9\u27e9 => \ud835\udfd9 _\n             naturality := by\n              intro X Y f\n              match X, Y, f with\n              | .mk A, .mk B, .up g =>\n                aesop_cat\n           }\n  }\u27e9", "start": [133, 1], "end": [142, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.w", "code": "@[reassoc (attr := simp)]\ntheorem Cone.w {F : J \u2964 C} (c : Cone F) {j j' : J} (f : j \u27f6 j') :\n    c.\u03c0.app j \u226b F.map f = c.\u03c0.app j'", "start": [145, 1], "end": [149, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone", "code": "structure Cocone (F : J \u2964 C) where\n  \n  pt : C\n  \n  \u03b9 : F \u27f6 (const J).obj pt", "start": [152, 1], "end": [166, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inhabitedCocone", "code": "instance inhabitedCocone (F : Discrete PUnit \u2964 C) : Inhabited (Cocone F) :=\n  \u27e8{  pt := F.obj \u27e8\u27e8\u27e9\u27e9\n      \u03b9 := { app := fun \u27e8\u27e8\u27e9\u27e9 => \ud835\udfd9 _\n             naturality := by\n              intro X Y f\n              match X, Y, f with\n              | .mk A, .mk B, .up g =>\n                aesop_cat\n           }\n  }\u27e9", "start": [171, 1], "end": [180, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.w", "code": "@[reassoc] theorem Cocone.w {F : J \u2964 C} (c : Cocone F) {j j' : J} (f : j \u27f6 j') :\n    F.map f \u226b c.\u03b9.app j' = c.\u03b9.app j", "start": [183, 1], "end": [187, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.equiv", "code": "@[simps!]\ndef equiv (F : J \u2964 C) : Cone F \u2245 \u03a3X, F.cones.obj X where\n  hom c := \u27e8op c.pt, c.\u03c0\u27e9\n  inv c :=\n    { pt := c.1.unop\n      \u03c0 := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl", "start": [198, 1], "end": [212, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.extensions", "code": "@[simps]\ndef extensions (c : Cone F) : yoneda.obj c.pt \u22d9 uliftFunctor.{u\u2081} \u27f6 F.cones where\n  app X f := (const J).map f.down \u226b c.\u03c0", "start": [215, 1], "end": [218, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.extend", "code": "@[simps]\ndef extend (c : Cone F) {X : C} (f : X \u27f6 c.pt) : Cone F :=\n  { pt := X\n    \u03c0 := c.extensions.app (op X) \u27e8f\u27e9 }", "start": [221, 1], "end": [225, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.whisker", "code": "@[simps]\ndef whisker (E : K \u2964 J) (c : Cone F) : Cone (E \u22d9 F) where\n  pt := c.pt\n  \u03c0 := whiskerLeft E c.\u03c0", "start": [228, 1], "end": [232, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.equiv", "code": "def equiv (F : J \u2964 C) : Cocone F \u2245 \u03a3X, F.cocones.obj X where\n  hom c := \u27e8c.pt, c.\u03b9\u27e9\n  inv c :=\n    { pt := c.1\n      \u03b9 := c.2 }\n  hom_inv_id := by\n    funext X\n    cases X\n    rfl\n  inv_hom_id := by\n    funext X\n    cases X\n    rfl", "start": [239, 1], "end": [252, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.extensions", "code": "@[simps]\ndef extensions (c : Cocone F) : coyoneda.obj (op c.pt) \u22d9 uliftFunctor.{u\u2081} \u27f6 F.cocones where\n  app X f := c.\u03b9 \u226b (const J).map f.down", "start": [255, 1], "end": [258, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.extend", "code": "@[simps]\ndef extend (c : Cocone F) {Y : C} (f : c.pt \u27f6 Y) : Cocone F where\n  pt := Y\n  \u03b9 := c.extensions.app Y \u27e8f\u27e9", "start": [261, 1], "end": [265, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.whisker", "code": "@[simps]\ndef whisker (E : K \u2964 J) (c : Cocone F) : Cocone (E \u22d9 F) where\n  pt := c.pt\n  \u03b9 := whiskerLeft E c.\u03b9", "start": [268, 1], "end": [274, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ConeMorphism", "code": "structure ConeMorphism (A B : Cone F) where\n  \n  hom : A.pt \u27f6 B.pt\n  \n  w : \u2200 j : J, hom \u226b B.\u03c0.app j = A.\u03c0.app j := by aesop_cat", "start": [279, 1], "end": [285, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inhabitedConeMorphism", "code": "instance inhabitedConeMorphism (A : Cone F) : Inhabited (ConeMorphism A A) :=\n  \u27e8{ hom := \ud835\udfd9 _ }\u27e9", "start": [291, 1], "end": [292, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.category", "code": "@[simps]\ninstance Cone.category : Category (Cone F) where\n  Hom A B := ConeMorphism A B\n  comp f g := { hom := f.hom \u226b g.hom }\n  id B := { hom := \ud835\udfd9 B.pt }", "start": [295, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.ConeMorphism.ext", "code": "@[ext]\ntheorem ConeMorphism.ext {c c' : Cone F} (f g : c \u27f6 c') (w : f.hom = g.hom) : f = g", "start": [306, 1], "end": [310, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.ext", "code": "@[aesop apply safe (rule_sets [CategoryTheory]), simps]\ndef ext {c c' : Cone F} (\u03c6 : c.pt \u2245 c'.pt)\n    (w : \u2200 j, c.\u03c0.app j = \u03c6.hom \u226b c'.\u03c0.app j := by aesop_cat) : c \u2245 c' where\n  hom := { hom := \u03c6.hom }\n  inv :=\n    { hom := \u03c6.inv\n      w := fun j => \u03c6.inv_comp_eq.mpr (w j) }", "start": [314, 1], "end": [324, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.eta", "code": "@[simps!]\ndef eta (c : Cone F) : c \u2245 \u27e8c.pt, c.\u03c0\u27e9 :=\n  Cones.ext (Iso.refl _)", "start": [327, 1], "end": [330, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.cone_iso_of_hom_iso", "code": "theorem cone_iso_of_hom_iso {K : J \u2964 C} {c d : Cone K} (f : c \u27f6 d) [i : IsIso f.hom] : IsIso f", "start": [333, 1], "end": [338, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.postcompose", "code": "@[simps]\ndef postcompose {G : J \u2964 C} (\u03b1 : F \u27f6 G) : Cone F \u2964 Cone G where\n  obj c :=\n    { pt := c.pt\n      \u03c0 := c.\u03c0 \u226b \u03b1 }\n  map f := { hom := f.hom }", "start": [341, 1], "end": [349, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.postcomposeComp", "code": "@[simps!]\ndef postcomposeComp {G H : J \u2964 C} (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) :\n    postcompose (\u03b1 \u226b \u03b2) \u2245 postcompose \u03b1 \u22d9 postcompose \u03b2 :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)", "start": [352, 1], "end": [357, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.postcomposeId", "code": "@[simps!]\ndef postcomposeId : postcompose (\ud835\udfd9 F) \u2245 \ud835\udfed (Cone F) :=\n  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)", "start": [360, 1], "end": [363, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.postcomposeEquivalence", "code": "@[simps]\ndef postcomposeEquivalence {G : J \u2964 C} (\u03b1 : F \u2245 G) : Cone F \u224c Cone G where\n  functor := postcompose \u03b1.hom\n  inverse := postcompose \u03b1.inv\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)", "start": [366, 1], "end": [374, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.whiskering", "code": "@[simps]\ndef whiskering (E : K \u2964 J) : Cone F \u2964 Cone (E \u22d9 F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }", "start": [377, 1], "end": [382, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.whiskeringEquivalence", "code": "@[simps]\ndef whiskeringEquivalence (e : K \u224c J) : Cone F \u224c Cone (e.functor \u22d9 F) where\n  functor := whiskering e.functor\n  inverse := whiskering e.inverse \u22d9 postcompose (e.invFunIdAssoc F).hom\n  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)\n  counitIso :=\n    NatIso.ofComponents\n      fun s =>\n        Cones.ext (Iso.refl _)\n          (by\n            intro k\n            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))", "start": [385, 1], "end": [398, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.equivalenceOfReindexing", "code": "@[simps! functor inverse unitIso counitIso]\ndef equivalenceOfReindexing {G : K \u2964 C} (e : K \u224c J) (\u03b1 : e.functor \u22d9 F \u2245 G) : Cone F \u224c Cone G :=\n  (whiskeringEquivalence e).trans (postcomposeEquivalence \u03b1)", "start": [401, 1], "end": [406, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.forget", "code": "@[simps]\ndef forget : Cone F \u2964 C where\n  obj t := t.pt\n  map f := f.hom", "start": [413, 1], "end": [417, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.functoriality", "code": "@[simps]\ndef functoriality : Cone F \u2964 Cone (F \u22d9 G) where\n  obj A :=\n    { pt := G.obj A.pt\n      \u03c0 :=\n        { app := fun j => G.map (A.\u03c0.app j)\n          naturality := by intros; erw [\u2190 G.map_comp]; aesop_cat } }\n  map f :=\n    { hom := G.map f.hom\n      w := fun j => by simp [-ConeMorphism.w, \u2190 f.w j] }", "start": [422, 1], "end": [432, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.functorialityFull", "code": "instance functorialityFull [Full G] [Faithful G] : Full (functoriality F G) where\n  preimage t :=\n    { hom := G.preimage t.hom\n      w := fun j => G.map_injective (by simpa using t.w j) }", "start": [435, 1], "end": [438, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.functorialityFaithful", "code": "instance functorialityFaithful [Faithful G] : Faithful (Cones.functoriality F G) where\n  map_injective {c} {c'} f g e := by\n    apply ConeMorphism.ext f g\n    let f := ConeMorphism.mk.inj e\n    apply G.map_injective f", "start": [441, 1], "end": [445, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.functorialityEquivalence", "code": "@[simps]\ndef functorialityEquivalence (e : C \u224c D) : Cone F \u224c Cone (F \u22d9 e.functor) :=\n  let f : (F \u22d9 e.functor) \u22d9 e.inverse \u2245 F :=\n    Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft _ e.unitIso.symm \u226a\u226b Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F \u22d9 e.functor) e.inverse \u22d9 (postcomposeEquivalence f).functor\n    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)\n    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _)\n  }", "start": [448, 1], "end": [459, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cones.reflects_cone_isomorphism", "code": "instance reflects_cone_isomorphism (F : C \u2964 D) [ReflectsIsomorphisms F] (K : J \u2964 C) :\n    ReflectsIsomorphisms (Cones.functoriality K F) := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cones.forget (K \u22d9 F)).map_isIso ((Cones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cone_iso_of_hom_iso", "start": [462, 1], "end": [472, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CoconeMorphism", "code": "structure CoconeMorphism (A B : Cocone F) where\n  \n  hom : A.pt \u27f6 B.pt\n  \n  w : \u2200 j : J, A.\u03b9.app j \u226b hom = B.\u03b9.app j := by aesop_cat", "start": [479, 1], "end": [485, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.inhabitedCoconeMorphism", "code": "instance inhabitedCoconeMorphism (A : Cocone F) : Inhabited (CoconeMorphism A A) :=\n  \u27e8{ hom := \ud835\udfd9 _ }\u27e9", "start": [489, 1], "end": [490, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.category", "code": "@[simps]\ninstance Cocone.category : Category (Cocone F) where\n  Hom A B := CoconeMorphism A B\n  comp f g := { hom := f.hom \u226b g.hom }\n  id B := { hom := \ud835\udfd9 B.pt }", "start": [495, 1], "end": [499, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.CoconeMorphism.ext", "code": "@[ext]\ntheorem CoconeMorphism.ext {c c' : Cocone F} (f g : c \u27f6 c') (w : f.hom = g.hom) : f = g", "start": [505, 1], "end": [509, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.ext", "code": "@[aesop apply safe (rule_sets [CategoryTheory]), simps]\ndef ext {c c' : Cocone F} (\u03c6 : c.pt \u2245 c'.pt)\n    (w : \u2200 j, c.\u03b9.app j \u226b \u03c6.hom = c'.\u03b9.app j := by aesop_cat) : c \u2245 c' where\n  hom := { hom := \u03c6.hom }\n  inv :=\n    { hom := \u03c6.inv\n      w := fun j => \u03c6.comp_inv_eq.mpr (w j).symm }", "start": [513, 1], "end": [523, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.eta", "code": "@[simps!]\ndef eta (c : Cocone F) : c \u2245 \u27e8c.pt, c.\u03b9\u27e9 :=\n  Cocones.ext (Iso.refl _)", "start": [526, 1], "end": [529, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.cocone_iso_of_hom_iso", "code": "theorem cocone_iso_of_hom_iso {K : J \u2964 C} {c d : Cocone K} (f : c \u27f6 d) [i : IsIso f.hom] :\n    IsIso f", "start": [532, 1], "end": [538, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.precompose", "code": "@[simps]\ndef precompose {G : J \u2964 C} (\u03b1 : G \u27f6 F) : Cocone F \u2964 Cocone G where\n  obj c :=\n    { pt := c.pt\n      \u03b9 := \u03b1 \u226b c.\u03b9 }\n  map f := { hom := f.hom }", "start": [541, 1], "end": [548, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.precomposeComp", "code": "def precomposeComp {G H : J \u2964 C} (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) :\n    precompose (\u03b1 \u226b \u03b2) \u2245 precompose \u03b2 \u22d9 precompose \u03b1 :=\n  NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)", "start": [551, 1], "end": [555, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.precomposeId", "code": "def precomposeId : precompose (\ud835\udfd9 F) \u2245 \ud835\udfed (Cocone F) :=\n  NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)", "start": [558, 1], "end": [560, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.precomposeEquivalence", "code": "@[simps]\ndef precomposeEquivalence {G : J \u2964 C} (\u03b1 : G \u2245 F) : Cocone F \u224c Cocone G where\n  functor := precompose \u03b1.hom\n  inverse := precompose \u03b1.inv\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)", "start": [563, 1], "end": [571, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.whiskering", "code": "@[simps]\ndef whiskering (E : K \u2964 J) : Cocone F \u2964 Cocone (E \u22d9 F) where\n  obj c := c.whisker E\n  map f := { hom := f.hom }", "start": [574, 1], "end": [579, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.whiskeringEquivalence", "code": "@[simps]\ndef whiskeringEquivalence (e : K \u224c J) : Cocone F \u224c Cocone (e.functor \u22d9 F) where\n  functor := whiskering e.functor\n  inverse :=\n    whiskering e.inverse \u22d9\n      precompose\n        ((Functor.leftUnitor F).inv \u226b\n          whiskerRight e.counitIso.inv F \u226b (Functor.associator _ _ _).inv)\n  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)\n  counitIso := NatIso.ofComponents fun s =>\n    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)", "start": [582, 1], "end": [594, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.equivalenceOfReindexing", "code": "@[simps! functor_obj]\ndef equivalenceOfReindexing {G : K \u2964 C} (e : K \u224c J) (\u03b1 : e.functor \u22d9 F \u2245 G) : Cocone F \u224c Cocone G :=\n  (whiskeringEquivalence e).trans (precomposeEquivalence \u03b1.symm)", "start": [597, 1], "end": [603, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.forget", "code": "@[simps]\ndef forget : Cocone F \u2964 C where\n  obj t := t.pt\n  map f := f.hom", "start": [610, 1], "end": [614, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.functoriality", "code": "@[simps]\ndef functoriality : Cocone F \u2964 Cocone (F \u22d9 G) where\n  obj A :=\n    { pt := G.obj A.pt\n      \u03b9 :=\n        { app := fun j => G.map (A.\u03b9.app j)\n          naturality := by intros; erw [\u2190 G.map_comp]; aesop_cat } }\n  map f :=\n    { hom := G.map f.hom\n      w := by intros; rw [\u2190 Functor.map_comp, CoconeMorphism.w] }", "start": [619, 1], "end": [629, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.functorialityFull", "code": "instance functorialityFull [Full G] [Faithful G] : Full (functoriality F G) where\n  preimage t :=\n    { hom := G.preimage t.hom\n      w := fun j => G.map_injective (by simpa using t.w j) }", "start": [632, 1], "end": [635, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.functoriality_faithful", "code": "instance functoriality_faithful [Faithful G] : Faithful (functoriality F G) where\n  map_injective {X} {Y} f g e := by\n    apply CoconeMorphism.ext\n    let h := CoconeMorphism.mk.inj e\n    apply G.map_injective h", "start": [638, 1], "end": [642, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.functorialityEquivalence", "code": "@[simps]\ndef functorialityEquivalence (e : C \u224c D) : Cocone F \u224c Cocone (F \u22d9 e.functor) :=\n  let f : (F \u22d9 e.functor) \u22d9 e.inverse \u2245 F :=\n    Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft _ e.unitIso.symm \u226a\u226b Functor.rightUnitor _\n  { functor := functoriality F e.functor\n    inverse := functoriality (F \u22d9 e.functor) e.inverse \u22d9 (precomposeEquivalence f.symm).functor\n    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)\n    counitIso :=\n      NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _)\n        (fun j =>\n          by simp [\u2190 Equivalence.counitInv_app_functor]) }", "start": [645, 1], "end": [660, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocones.reflects_cocone_isomorphism", "code": "instance reflects_cocone_isomorphism (F : C \u2964 D) [ReflectsIsomorphisms F] (K : J \u2964 C) :\n    ReflectsIsomorphisms (Cocones.functoriality K F) := by\n  constructor\n  intro A B f _\n  haveI : IsIso (F.map f.hom) :=\n    (Cocones.forget (K \u22d9 F)).map_isIso ((Cocones.functoriality K F).map f)\n  haveI := ReflectsIsomorphisms.reflects F f.hom\n  apply cocone_iso_of_hom_iso", "start": [663, 1], "end": [673, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCone", "code": "@[simps!, pp_dot]\ndef mapCone (c : Cone F) : Cone (F \u22d9 H) :=\n  (Cones.functoriality F H).obj c", "start": [688, 1], "end": [691, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCocone", "code": "@[simps!, pp_dot]\ndef mapCocone (c : Cocone F) : Cocone (F \u22d9 H) :=\n  (Cocones.functoriality F H).obj c", "start": [694, 1], "end": [697, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeMorphism", "code": "def mapConeMorphism {c c' : Cone F} (f : c \u27f6 c') : H.mapCone c \u27f6 H.mapCone c' :=\n  (Cones.functoriality F H).map f", "start": [700, 1], "end": [702, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeMorphism", "code": "def mapCoconeMorphism {c c' : Cocone F} (f : c \u27f6 c') : H.mapCocone c \u27f6 H.mapCocone c' :=\n  (Cocones.functoriality F H).map f", "start": [705, 1], "end": [708, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeInv", "code": "def mapConeInv [IsEquivalence H] (c : Cone (F \u22d9 H)) : Cone F :=\n  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).inverse.obj c", "start": [711, 1], "end": [714, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeMapConeInv", "code": "def mapConeMapConeInv {F : J \u2964 D} (H : D \u2964 C) [IsEquivalence H] (c : Cone (F \u22d9 H)) :\n    mapCone H (mapConeInv H c) \u2245 c :=\n  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).counitIso.app c", "start": [717, 1], "end": [720, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeInvMapCone", "code": "def mapConeInvMapCone {F : J \u2964 D} (H : D \u2964 C) [IsEquivalence H] (c : Cone F) :\n    mapConeInv H (mapCone H c) \u2245 c :=\n  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).unitIso.symm.app c", "start": [723, 1], "end": [726, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeInv", "code": "def mapCoconeInv [IsEquivalence H] (c : Cocone (F \u22d9 H)) : Cocone F :=\n  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).inverse.obj c", "start": [729, 1], "end": [732, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeMapCoconeInv", "code": "def mapCoconeMapCoconeInv {F : J \u2964 D} (H : D \u2964 C) [IsEquivalence H] (c : Cocone (F \u22d9 H)) :\n    mapCocone H (mapCoconeInv H c) \u2245 c :=\n  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).counitIso.app c", "start": [735, 1], "end": [738, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeInvMapCocone", "code": "def mapCoconeInvMapCocone {F : J \u2964 D} (H : D \u2964 C) [IsEquivalence H] (c : Cocone F) :\n    mapCoconeInv H (mapCocone H c) \u2245 c :=\n  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).unitIso.symm.app c", "start": [741, 1], "end": [744, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.functorialityCompPostcompose", "code": "@[simps!]\ndef functorialityCompPostcompose {H H' : C \u2964 D} (\u03b1 : H \u2245 H') :\n    Cones.functoriality F H \u22d9 Cones.postcompose (whiskerLeft F \u03b1.hom) \u2245 Cones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cones.ext (\u03b1.app _)", "start": [747, 1], "end": [751, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.postcomposeWhiskerLeftMapCone", "code": "@[simps!]\ndef postcomposeWhiskerLeftMapCone {H H' : C \u2964 D} (\u03b1 : H \u2245 H') (c : Cone F) :\n    (Cones.postcompose (whiskerLeft F \u03b1.hom : _)).obj (mapCone H c) \u2245 mapCone H' c :=\n  (functorialityCompPostcompose \u03b1).app c", "start": [754, 1], "end": [761, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConePostcompose", "code": "@[simps!]\ndef mapConePostcompose {\u03b1 : F \u27f6 G} {c} :\n    mapCone H ((Cones.postcompose \u03b1).obj c) \u2245\n      (Cones.postcompose (whiskerRight \u03b1 H : _)).obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)", "start": [764, 1], "end": [773, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConePostcomposeEquivalenceFunctor", "code": "@[simps!]\ndef mapConePostcomposeEquivalenceFunctor {\u03b1 : F \u2245 G} {c} :\n    mapCone H ((Cones.postcomposeEquivalence \u03b1).functor.obj c) \u2245\n      (Cones.postcomposeEquivalence (isoWhiskerRight \u03b1 H : _)).functor.obj (mapCone H c) :=\n  Cones.ext (Iso.refl _)", "start": [776, 1], "end": [782, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.functorialityCompPrecompose", "code": "@[simps!]\ndef functorialityCompPrecompose {H H' : C \u2964 D} (\u03b1 : H \u2245 H') :\n    Cocones.functoriality F H \u22d9 Cocones.precompose (whiskerLeft F \u03b1.inv) \u2245\n      Cocones.functoriality F H' :=\n  NatIso.ofComponents fun c => Cocones.ext (\u03b1.app _)", "start": [785, 1], "end": [790, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.precomposeWhiskerLeftMapCocone", "code": "@[simps!]\ndef precomposeWhiskerLeftMapCocone {H H' : C \u2964 D} (\u03b1 : H \u2245 H') (c : Cocone F) :\n    (Cocones.precompose (whiskerLeft F \u03b1.inv : _)).obj (mapCocone H c) \u2245 mapCocone H' c :=\n  (functorialityCompPrecompose \u03b1).app c", "start": [793, 1], "end": [801, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconePrecompose", "code": "@[simps!]\ndef mapCoconePrecompose {\u03b1 : F \u27f6 G} {c} :\n    mapCocone H ((Cocones.precompose \u03b1).obj c) \u2245\n      (Cocones.precompose (whiskerRight \u03b1 H : _)).obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)", "start": [804, 1], "end": [812, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconePrecomposeEquivalenceFunctor", "code": "@[simps!]\ndef mapCoconePrecomposeEquivalenceFunctor {\u03b1 : F \u2245 G} {c} :\n    mapCocone H ((Cocones.precomposeEquivalence \u03b1).functor.obj c) \u2245\n      (Cocones.precomposeEquivalence (isoWhiskerRight \u03b1 H : _)).functor.obj (mapCocone H c) :=\n  Cocones.ext (Iso.refl _)", "start": [815, 1], "end": [821, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeWhisker", "code": "@[simps!]\ndef mapConeWhisker {E : K \u2964 J} {c : Cone F} : mapCone H (c.whisker E) \u2245 (mapCone H c).whisker E :=\n  Cones.ext (Iso.refl _)", "start": [824, 1], "end": [828, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeWhisker", "code": "@[simps!]\ndef mapCoconeWhisker {E : K \u2964 J} {c : Cocone F} :\n    mapCocone H (c.whisker E) \u2245 (mapCocone H c).whisker E :=\n  Cocones.ext (Iso.refl _)", "start": [831, 1], "end": [836, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.op", "code": "@[simps]\ndef Cocone.op (c : Cocone F) : Cone F.op where\n  pt := Opposite.op c.pt\n  \u03c0 := NatTrans.op c.\u03b9", "start": [849, 1], "end": [853, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.op", "code": "@[simps]\ndef Cone.op (c : Cone F) : Cocone F.op where\n  pt := Opposite.op c.pt\n  \u03b9 := NatTrans.op c.\u03c0", "start": [856, 1], "end": [860, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.unop", "code": "@[simps]\ndef Cocone.unop (c : Cocone F.op) : Cone F where\n  pt := Opposite.unop c.pt\n  \u03c0 := NatTrans.removeOp c.\u03b9", "start": [863, 1], "end": [867, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.unop", "code": "@[simps]\ndef Cone.unop (c : Cone F.op) : Cocone F where\n  pt := Opposite.unop c.pt\n  \u03b9 := NatTrans.removeOp c.\u03c0", "start": [870, 1], "end": [874, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeEquivalenceOpConeOp", "code": "def coconeEquivalenceOpConeOp : Cocone F \u224c (Cone F.op)\u1d52\u1d56 where\n  functor :=\n    { obj := fun c => op (Cocone.op c)\n      map := fun {X} {Y} f =>\n        Quiver.Hom.op\n          { hom := f.hom.op\n            w := fun j => by\n              apply Quiver.Hom.unop_inj\n              dsimp\n              apply CoconeMorphism.w } }\n  inverse :=\n    { obj := fun c => Cone.unop (unop c)\n      map := fun {X} {Y} f =>\n        { hom := f.unop.hom.unop\n          w := fun j => by\n            apply Quiver.Hom.op_inj\n            dsimp\n            apply ConeMorphism.w } }\n  unitIso := NatIso.ofComponents (fun c => Cocones.ext (Iso.refl _))\n  counitIso :=\n    NatIso.ofComponents\n      (fun c => by\n        induction c\n        apply Iso.op\n        exact Cones.ext (Iso.refl _))\n      fun {X} {Y} f =>\n      Quiver.Hom.unop_inj (ConeMorphism.ext _ _ (by simp))\n  functor_unitIso_comp c := by\n    apply Quiver.Hom.unop_inj\n    apply ConeMorphism.ext\n    dsimp\n    apply comp_id", "start": [879, 1], "end": [914, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfCoconeLeftOp", "code": "@[simps!]\ndef coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where\n  pt := op c.pt\n  \u03c0 := NatTrans.removeLeftOp c.\u03b9", "start": [925, 1], "end": [929, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeLeftOpOfCone", "code": "@[simps!]\ndef coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where\n  pt := unop c.pt\n  \u03b9 := NatTrans.leftOp c.\u03c0", "start": [932, 1], "end": [936, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfConeLeftOp", "code": "@[simps pt]\ndef coconeOfConeLeftOp (c : Cone F.leftOp) : Cocone F where\n  pt := op c.pt\n  \u03b9 := NatTrans.removeLeftOp c.\u03c0", "start": [942, 1], "end": [946, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfConeLeftOp_\u03b9_app", "code": "@[simp]\ntheorem coconeOfConeLeftOp_\u03b9_app (c : Cone F.leftOp) (j) :\n    (coconeOfConeLeftOp c).\u03b9.app j = (c.\u03c0.app (op j)).op", "start": [949, 1], "end": [953, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneLeftOpOfCocone", "code": "@[simps!]\ndef coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where\n  pt := unop c.pt\n  \u03c0 := NatTrans.leftOp c.\u03b9", "start": [956, 1], "end": [960, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfCoconeRightOp", "code": "@[simps]\ndef coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where\n  pt := unop c.pt\n  \u03c0 := NatTrans.removeRightOp c.\u03b9", "start": [969, 1], "end": [973, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeRightOpOfCone", "code": "@[simps]\ndef coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where\n  pt := op c.pt\n  \u03b9 := NatTrans.rightOp c.\u03c0", "start": [976, 1], "end": [980, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfConeRightOp", "code": "@[simps]\ndef coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where\n  pt := unop c.pt\n  \u03b9 := NatTrans.removeRightOp c.\u03c0", "start": [983, 1], "end": [987, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneRightOpOfCocone", "code": "@[simps]\ndef coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where\n  pt := op c.pt\n  \u03c0 := NatTrans.rightOp c.\u03b9", "start": [990, 1], "end": [994, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneOfCoconeUnop", "code": "@[simps]\ndef coneOfCoconeUnop (c : Cocone F.unop) : Cone F where\n  pt := op c.pt\n  \u03c0 := NatTrans.removeUnop c.\u03b9", "start": [1003, 1], "end": [1007, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeUnopOfCone", "code": "@[simps]\ndef coconeUnopOfCone (c : Cone F) : Cocone F.unop where\n  pt := unop c.pt\n  \u03b9 := NatTrans.unop c.\u03c0", "start": [1010, 1], "end": [1014, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coconeOfConeUnop", "code": "@[simps]\ndef coconeOfConeUnop (c : Cone F.unop) : Cocone F where\n  pt := op c.pt\n  \u03b9 := NatTrans.removeUnop c.\u03c0", "start": [1017, 1], "end": [1021, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.coneUnopOfCocone", "code": "@[simps]\ndef coneUnopOfCocone (c : Cocone F) : Cone F.unop where\n  pt := unop c.pt\n  \u03c0 := NatTrans.unop c.\u03b9", "start": [1024, 1], "end": [1028, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapConeOp", "code": "@[simps!]\ndef mapConeOp (t : Cone F) : (mapCone G t).op \u2245 mapCocone G.op t.op :=\n  Cocones.ext (Iso.refl _)", "start": [1045, 1], "end": [1049, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapCoconeOp", "code": "@[simps!]\ndef mapCoconeOp {t : Cocone F} : (mapCocone G t).op \u2245 mapCone G.op t.op :=\n  Cones.ext (Iso.refl _)", "start": [1052, 1], "end": [1056, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/Cat.lean", "imports": ["Mathlib/CategoryTheory/DiscreteCategory.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/ConcreteCategory/Bundled.lean", "Mathlib/CategoryTheory/Bicategory/Strict.lean"], "premises": [{"full_name": "CategoryTheory.Cat", "code": "@[nolint checkUnivs]\ndef Cat :=\n  Bundled Category.{v, u}", "start": [32, 1], "end": [35, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.str", "code": "instance str (C : Cat.{v, u}) : Category.{v, u} C :=\n  Bundled.str C", "start": [48, 1], "end": [49, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.of", "code": "def of (C : Type u) [Category.{v} C] : Cat.{v, u} :=\n  Bundled.of C", "start": [53, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.bicategory", "code": "instance bicategory : Bicategory.{max v u, max v u} Cat.{v, u}\n    where\n  Hom C D := C \u2964 D\n  id C := \ud835\udfed C\n  comp F G := F \u22d9 G\n  homCategory := fun _ _ => Functor.category\n  whiskerLeft {C} {D} {E} F G H \u03b7 := whiskerLeft F \u03b7\n  whiskerRight {C} {D} {E} F G \u03b7 H := whiskerRight \u03b7 H\n  associator {A} {B} {C} D := Functor.associator\n  leftUnitor {A} B := Functor.leftUnitor\n  rightUnitor {A} B := Functor.rightUnitor\n  pentagon := fun {A} {B} {C} {D} {E}=> Functor.pentagon\n  triangle {A} {B} {C} := Functor.triangle", "start": [59, 1], "end": [72, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.bicategory.strict", "code": "instance bicategory.strict : Bicategory.Strict Cat.{v, u} where\n  id_comp {C} {D} F := by cases F; rfl\n  comp_id {C} {D} F := by cases F; rfl\n  assoc := by intros; rfl", "start": [76, 1], "end": [80, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.category", "code": "instance category : LargeCategory.{max v u} Cat.{v, u} :=\n  StrictBicategory.category Cat.{v, u}", "start": [84, 1], "end": [86, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.id_map", "code": "@[simp]\ntheorem id_map {C : Cat} {X Y : C} (f : X \u27f6 Y) : (\ud835\udfd9 C : C \u2964 C).map f = f", "start": [90, 1], "end": [92, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.comp_obj", "code": "@[simp]\ntheorem comp_obj {C D E : Cat} (F : C \u27f6 D) (G : D \u27f6 E) (X : C) : (F \u226b G).obj X = G.obj (F.obj X)", "start": [96, 1], "end": [98, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.comp_map", "code": "@[simp]\ntheorem comp_map {C D E : Cat} (F : C \u27f6 D) (G : D \u27f6 E) {X Y : C} (f : X \u27f6 Y) :\n    (F \u226b G).map f = G.map (F.map f)", "start": [102, 1], "end": [105, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.objects", "code": "def objects : Cat.{v, u} \u2964 Type u where\n  obj C := C\n  map F := F.obj", "start": [109, 1], "end": [113, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cat.equivOfIso", "code": "def equivOfIso {C D : Cat} (\u03b3 : C \u2245 D) : C \u224c D\n    where\n  functor := \u03b3.hom\n  inverse := \u03b3.inv\n  unitIso := eqToIso <| Eq.symm \u03b3.hom_inv_id\n  counitIso := eqToIso \u03b3.inv_hom_id", "start": [124, 1], "end": [130, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.typeToCat", "code": "@[simps]\ndef typeToCat : Type u \u2964 Cat where\n  obj X := Cat.of (Discrete X)\n  map := fun {X} {Y} f => by\n    dsimp\n    exact Discrete.functor (Discrete.mk \u2218 f)\n  map_id X := by\n    apply Functor.ext\n    \u00b7 intro X Y f\n      cases f\n      simp only [id_eq, eqToHom_refl, Cat.id_map, Category.comp_id, Category.id_comp]\n      apply ULift.ext\n      aesop_cat\n    \u00b7 aesop_cat\n  map_comp f g := by apply Functor.ext; aesop_cat", "start": [138, 1], "end": [156, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Fin.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/GroupTheory/Perm/Cycle/Type.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Equiv/Fintype.lean", "Mathlib/GroupTheory/Perm/Option.lean"], "premises": [{"full_name": "Equiv.Perm.decomposeFin", "code": "def Equiv.Perm.decomposeFin {n : \u2115} : Perm (Fin n.succ) \u2243 Fin n.succ \u00d7 Perm (Fin n) :=\n  ((Equiv.permCongr <| finSuccEquiv n).trans Equiv.Perm.decomposeOption).trans\n    (Equiv.prodCongr (finSuccEquiv n).symm (Equiv.refl _))", "start": [20, 1], "end": [25, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin_symm_of_refl", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_of_refl {n : \u2115} (p : Fin (n + 1)) :\n    Equiv.Perm.decomposeFin.symm (p, Equiv.refl _) = swap 0 p", "start": [28, 1], "end": [31, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin_symm_of_one", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_of_one {n : \u2115} (p : Fin (n + 1)) :\n    Equiv.Perm.decomposeFin.symm (p, 1) = swap 0 p", "start": [34, 1], "end": [37, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin_symm_apply_zero", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_zero {n : \u2115} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 0 = p", "start": [40, 1], "end": [42, 83], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin_symm_apply_succ", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_succ {n : \u2115} (e : Perm (Fin n)) (p : Fin (n + 1))\n    (x : Fin n) : Equiv.Perm.decomposeFin.symm (p, e) x.succ = swap 0 p (e x).succ", "start": [45, 1], "end": [54, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin_symm_apply_one", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin_symm_apply_one {n : \u2115} (e : Perm (Fin (n + 1))) (p : Fin (n + 2)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 1 = swap 0 p (e 0).succ", "start": [57, 1], "end": [60, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.decomposeFin.symm_sign", "code": "@[simp]\ntheorem Equiv.Perm.decomposeFin.symm_sign {n : \u2115} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Perm.sign (Equiv.Perm.decomposeFin.symm (p, e)) = ite (p = 0) 1 (-1) * Perm.sign e", "start": [63, 1], "end": [66, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_perm_fin_succ", "code": "theorem Finset.univ_perm_fin_succ {n : \u2115} :\n    @Finset.univ (Perm <| Fin n.succ) _ =\n      (Finset.univ : Finset <| Fin n.succ \u00d7 Perm (Fin n)).map\n        Equiv.Perm.decomposeFin.symm.toEmbedding", "start": [69, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "finRotate_succ_eq_decomposeFin", "code": "theorem finRotate_succ_eq_decomposeFin {n : \u2115} :\n    finRotate n.succ = decomposeFin.symm (1, finRotate n)", "start": [89, 1], "end": [100, 76], "kind": "commanddeclaration"}, {"full_name": "sign_finRotate", "code": "@[simp]\ntheorem sign_finRotate (n : \u2115) : Perm.sign (finRotate (n + 1)) = (-1) ^ n", "start": [103, 1], "end": [108, 24], "kind": "commanddeclaration"}, {"full_name": "support_finRotate", "code": "@[simp]\ntheorem support_finRotate {n : \u2115} : support (finRotate (n + 2)) = Finset.univ", "start": [111, 1], "end": [114, 7], "kind": "commanddeclaration"}, {"full_name": "support_finRotate_of_le", "code": "theorem support_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : support (finRotate n) = Finset.univ", "start": [117, 1], "end": [119, 35], "kind": "commanddeclaration"}, {"full_name": "isCycle_finRotate", "code": "theorem isCycle_finRotate {n : \u2115} : IsCycle (finRotate (n + 2))", "start": [122, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "isCycle_finRotate_of_le", "code": "theorem isCycle_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : IsCycle (finRotate n)", "start": [133, 1], "end": [136, 26], "kind": "commanddeclaration"}, {"full_name": "cycleType_finRotate", "code": "@[simp]\ntheorem cycleType_finRotate {n : \u2115} : cycleType (finRotate (n + 2)) = {n + 2}", "start": [139, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "cycleType_finRotate_of_le", "code": "theorem cycleType_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : cycleType (finRotate n) = {n}", "start": [145, 1], "end": [147, 37], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange", "code": "def cycleRange {n : \u2115} (i : Fin n) : Perm (Fin n) :=\n  (finRotate (i + 1)).extendDomain\n    (Equiv.ofLeftInverse' (Fin.castLEEmb (Nat.succ_le_of_lt i.is_lt)).toEmbedding (\u2191)\n      (by\n        intro x\n        ext\n        simp))", "start": [152, 1], "end": [159, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_of_gt", "code": "theorem cycleRange_of_gt {n : \u2115} {i j : Fin n.succ} (h : i < j) : cycleRange i j = j", "start": [162, 1], "end": [166, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_of_le", "code": "theorem cycleRange_of_le {n : \u2115} {i j : Fin n.succ} (h : j \u2264 i) :\n    cycleRange i j = if j = i then 0 else j + 1", "start": [169, 1], "end": [184, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_cycleRange_of_le", "code": "theorem coe_cycleRange_of_le {n : \u2115} {i j : Fin n.succ} (h : j \u2264 i) :\n    (cycleRange i j : \u2115) = if j = i then 0 else (j : \u2115) + 1", "start": [187, 1], "end": [196, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_of_lt", "code": "theorem cycleRange_of_lt {n : \u2115} {i j : Fin n.succ} (h : j < i) : cycleRange i j = j + 1", "start": [199, 1], "end": [200, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_cycleRange_of_lt", "code": "theorem coe_cycleRange_of_lt {n : \u2115} {i j : Fin n.succ} (h : j < i) :\n    (cycleRange i j : \u2115) = j + 1", "start": [203, 1], "end": [204, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_of_eq", "code": "theorem cycleRange_of_eq {n : \u2115} {i j : Fin n.succ} (h : j = i) : cycleRange i j = 0", "start": [207, 1], "end": [208, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_self", "code": "@[simp]\ntheorem cycleRange_self {n : \u2115} (i : Fin n.succ) : cycleRange i i = 0", "start": [211, 1], "end": [213, 23], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_apply", "code": "theorem cycleRange_apply {n : \u2115} (i j : Fin n.succ) :\n    cycleRange i j = if j < i then j + 1 else if j = i then 0 else j", "start": [216, 1], "end": [221, 75], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_zero", "code": "@[simp]\ntheorem cycleRange_zero (n : \u2115) : cycleRange (0 : Fin n.succ) = 1", "start": [224, 1], "end": [229, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_last", "code": "@[simp]\ntheorem cycleRange_last (n : \u2115) : cycleRange (last n) = finRotate (n + 1)", "start": [232, 1], "end": [235, 55], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_zero'", "code": "@[simp]\ntheorem cycleRange_zero' {n : \u2115} (h : 0 < n) : cycleRange \u27e80, h\u27e9 = 1", "start": [238, 1], "end": [242, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.sign_cycleRange", "code": "@[simp]\ntheorem sign_cycleRange {n : \u2115} (i : Fin n) : Perm.sign (cycleRange i) = (-1) ^ (i : \u2115)", "start": [245, 1], "end": [247, 20], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_cycleRange", "code": "@[simp]\ntheorem succAbove_cycleRange {n : \u2115} (i j : Fin n) :\n    i.succ.succAbove (i.cycleRange j) = swap 0 i.succ j.succ", "start": [250, 1], "end": [270, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_succAbove", "code": "@[simp]\ntheorem cycleRange_succAbove {n : \u2115} (i : Fin (n + 1)) (j : Fin n) :\n    i.cycleRange (i.succAbove j) = j.succ", "start": [273, 1], "end": [278, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_symm_zero", "code": "@[simp]\ntheorem cycleRange_symm_zero {n : \u2115} (i : Fin (n + 1)) : i.cycleRange.symm 0 = i", "start": [281, 1], "end": [283, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleRange_symm_succ", "code": "@[simp]\ntheorem cycleRange_symm_succ {n : \u2115} (i : Fin (n + 1)) (j : Fin n) :\n    i.cycleRange.symm j.succ = i.succAbove j", "start": [286, 1], "end": [289, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.isCycle_cycleRange", "code": "theorem isCycle_cycleRange {n : \u2115} {i : Fin (n + 1)} (h0 : i \u2260 0) : IsCycle (cycleRange i)", "start": [292, 1], "end": [296, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.cycleType_cycleRange", "code": "@[simp]\ntheorem cycleType_cycleRange {n : \u2115} {i : Fin (n + 1)} (h0 : i \u2260 0) :\n    cycleType (cycleRange i) = {(i + 1 : \u2115)}", "start": [299, 1], "end": [306, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.isThreeCycle_cycleRange_two", "code": "theorem isThreeCycle_cycleRange_two {n : \u2115} : IsThreeCycle (cycleRange 2 : Perm (Fin (n + 3)))", "start": [309, 1], "end": [310, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Alternating/Basic.lean", "imports": ["Mathlib/LinearAlgebra/Multilinear/Basis.lean", "Mathlib/Data/Fintype/Perm.lean", "Mathlib/GroupTheory/Perm/Sign.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlternatingMap", "code": "structure AlternatingMap extends MultilinearMap R (fun _ : \u03b9 => M) N where\n  \n  map_eq_zero_of_eq' : \u2200 (v : \u03b9 \u2192 M) (i j : \u03b9), v i = v j \u2192 i \u2260 j \u2192 toFun v = 0", "start": [67, 1], "end": [71, 80], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.funLike", "code": "instance funLike : FunLike (AlternatingMap R M N \u03b9) (\u03b9 \u2192 M) (fun _ => N) where\n  coe f := f.toFun\n  coe_injective' := fun f g h \u21a6 by\n    rcases f with \u27e8\u27e8_, _, _\u27e9, _\u27e9\n    rcases g with \u27e8\u27e8_, _, _\u27e9, _\u27e9\n    congr", "start": [96, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coeFun", "code": "instance coeFun : CoeFun (AlternatingMap R M N \u03b9) fun _ => (\u03b9 \u2192 M) \u2192 N :=\n  \u27e8FunLike.coe\u27e9", "start": [105, 1], "end": [106, 16], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe : f.toFun = f", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : MultilinearMap R (fun _ : \u03b9 => M) N) (h) :\n    \u21d1(\u27e8f, h\u27e9 : AlternatingMap R M N \u03b9) = f", "start": [117, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.congr_fun", "code": "theorem congr_fun {f g : AlternatingMap R M N \u03b9} (h : f = g) (x : \u03b9 \u2192 M) : f x = g x", "start": [123, 1], "end": [124, 54], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.congr_arg", "code": "theorem congr_arg (f : AlternatingMap R M N \u03b9) {x y : \u03b9 \u2192 M} (h : x = y) : f x = f y", "start": [127, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : AlternatingMap R M N \u03b9 \u2192 (\u03b9 \u2192 M) \u2192 N)", "start": [131, 1], "end": [132, 24], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_inj", "code": "@[norm_cast] theorem coe_inj {f g : AlternatingMap R M N \u03b9} : (f : (\u03b9 \u2192 M) \u2192 N) = g \u2194 f = g", "start": [135, 1], "end": [137, 23], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.ext", "code": "@[ext]\ntheorem ext {f f' : AlternatingMap R M N \u03b9} (H : \u2200 x, f x = f' x) : f = f'", "start": [140, 1], "end": [142, 20], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.ext_iff", "code": "theorem ext_iff {f g : AlternatingMap R M N \u03b9} : f = g \u2194 \u2200 x, f x = g x", "start": [145, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe", "code": "instance coe : Coe (AlternatingMap R M N \u03b9) (MultilinearMap R (fun _ : \u03b9 => M) N) :=\n  \u27e8fun x => x.toMultilinearMap\u27e9", "start": [151, 1], "end": [152, 32], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_multilinearMap", "code": "@[simp, norm_cast]\ntheorem coe_multilinearMap : \u21d1(f : MultilinearMap R (fun _ : \u03b9 => M) N) = f", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_multilinearMap_injective", "code": "theorem coe_multilinearMap_injective :\n    Function.Injective ((\u2191) : AlternatingMap R M N \u03b9 \u2192 MultilinearMap R (fun _ : \u03b9 => M) N)", "start": [160, 1], "end": [162, 49], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_multilinearMap_mk", "code": "theorem coe_multilinearMap_mk (f : (\u03b9 \u2192 M) \u2192 N) (h\u2081 h\u2082 h\u2083) :\n    ((\u27e8\u27e8f, h\u2081, h\u2082\u27e9, h\u2083\u27e9 : AlternatingMap R M N \u03b9) : MultilinearMap R (fun _ : \u03b9 => M) N) =\n      \u27e8f, @h\u2081, @h\u2082\u27e9", "start": [170, 1], "end": [173, 10], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_add", "code": "@[simp]\ntheorem map_add [DecidableEq \u03b9] (i : \u03b9) (x y : M) :\n    f (update v i (x + y)) = f (update v i x) + f (update v i y)", "start": [185, 1], "end": [188, 38], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_sub", "code": "@[simp]\ntheorem map_sub [DecidableEq \u03b9] (i : \u03b9) (x y : M') :\n    g' (update v' i (x - y)) = g' (update v' i x) - g' (update v' i y)", "start": [191, 1], "end": [194, 39], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_neg", "code": "@[simp]\ntheorem map_neg [DecidableEq \u03b9] (i : \u03b9) (x : M') : g' (update v' i (-x)) = -g' (update v' i x)", "start": [197, 1], "end": [199, 37], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_smul", "code": "@[simp]\ntheorem map_smul [DecidableEq \u03b9] (i : \u03b9) (r : R) (x : M) :\n    f (update v i (r \u2022 x)) = r \u2022 f (update v i x)", "start": [202, 1], "end": [205, 39], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_eq_zero_of_eq", "code": "@[simp]\ntheorem map_eq_zero_of_eq (v : \u03b9 \u2192 M) {i j : \u03b9} (h : v i = v j) (hij : i \u2260 j) : f v = 0", "start": [208, 1], "end": [210, 35], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_coord_zero", "code": "theorem map_coord_zero {m : \u03b9 \u2192 M} (i : \u03b9) (h : m i = 0) : f m = 0", "start": [213, 1], "end": [214, 40], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_update_zero", "code": "@[simp]\ntheorem map_update_zero [DecidableEq \u03b9] (m : \u03b9 \u2192 M) (i : \u03b9) : f (update m i 0) = 0", "start": [217, 1], "end": [219, 41], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_zero", "code": "@[simp]\ntheorem map_zero [Nonempty \u03b9] : f 0 = 0", "start": [222, 1], "end": [224, 30], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_eq_zero_of_not_injective", "code": "theorem map_eq_zero_of_not_injective (v : \u03b9 \u2192 M) (hv : \u00acFunction.Injective v) : f v = 0", "start": [227, 1], "end": [231, 38], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.smul", "code": "instance smul : SMul S (AlternatingMap R M N \u03b9) :=\n  \u27e8fun c f =>\n    { c \u2022 (f : MultilinearMap R (fun _ : \u03b9 => M) N) with\n      map_eq_zero_of_eq' := fun v i j h hij => by simp [f.map_eq_zero_of_eq v h hij] }\u27e9", "start": [246, 1], "end": [249, 88], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.smul_apply", "code": "@[simp]\ntheorem smul_apply (c : S) (m : \u03b9 \u2192 M) : (c \u2022 f) m = c \u2022 f m", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_smul", "code": "@[norm_cast]\ntheorem coe_smul (c : S) : (c \u2022 f : MultilinearMap R (fun _ : \u03b9 => M) N) =\n    c \u2022 (f : MultilinearMap R (fun _ : \u03b9 => M) N)", "start": [257, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coeFn_smul", "code": "theorem coeFn_smul (c : S) (f : AlternatingMap R M N \u03b9) : \u21d1(c \u2022 f) = c \u2022 \u21d1f", "start": [263, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.isCentralScalar", "code": "instance isCentralScalar [DistribMulAction S\u1d50\u1d52\u1d56 N] [IsCentralScalar S N] :\n    IsCentralScalar S (AlternatingMap R M N \u03b9) :=\n  \u27e8fun _ _ => ext fun _ => op_smul_eq_smul _ _\u27e9", "start": [267, 1], "end": [269, 48], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.prod", "code": "@[simps!]\ndef prod (f : AlternatingMap R M N \u03b9) (g : AlternatingMap R M P \u03b9) : AlternatingMap R M (N \u00d7 P) \u03b9 :=\n  { f.toMultilinearMap.prod g.toMultilinearMap with\n    map_eq_zero_of_eq' := fun _ _ _ h hne =>\n      Prod.ext (f.map_eq_zero_of_eq _ h hne) (g.map_eq_zero_of_eq _ h hne) }", "start": [274, 1], "end": [279, 77], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_prod", "code": "@[simp]\ntheorem coe_prod (f : AlternatingMap R M N \u03b9) (g : AlternatingMap R M P \u03b9) :\n    (f.prod g : MultilinearMap R (fun _ : \u03b9 => M) (N \u00d7 P)) = MultilinearMap.prod f g", "start": [283, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.pi", "code": "@[simps!]\ndef pi {\u03b9' : Type*} {N : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]\n    (f : \u2200 i, AlternatingMap R M (N i) \u03b9) : AlternatingMap R M (\u2200 i, N i) \u03b9 :=\n  { MultilinearMap.pi fun a => (f a).toMultilinearMap with\n    map_eq_zero_of_eq' := fun _ _ _ h hne => funext fun a => (f a).map_eq_zero_of_eq _ h hne }", "start": [289, 1], "end": [295, 95], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_pi", "code": "@[simp]\ntheorem coe_pi {\u03b9' : Type*} {N : \u03b9' \u2192 Type*} [\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]\n    (f : \u2200 i, AlternatingMap R M (N i) \u03b9) :\n    (pi f : MultilinearMap R (fun _ : \u03b9 => M) (\u2200 i, N i)) = MultilinearMap.pi fun a => f a", "start": [299, 1], "end": [303, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.smulRight", "code": "@[simps!]\ndef smulRight {R M\u2081 M\u2082 \u03b9 : Type*} [CommSemiring R] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]\n    [Module R M\u2081] [Module R M\u2082] (f : AlternatingMap R M\u2081 R \u03b9) (z : M\u2082) : AlternatingMap R M\u2081 M\u2082 \u03b9 :=\n  { f.toMultilinearMap.smulRight z with\n    map_eq_zero_of_eq' := fun v i j h hne => by simp [f.map_eq_zero_of_eq v h hne] }", "start": [306, 1], "end": [312, 85], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_smulRight", "code": "@[simp]\ntheorem coe_smulRight {R M\u2081 M\u2082 \u03b9 : Type*} [CommSemiring R] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]\n    [Module R M\u2081] [Module R M\u2082] (f : AlternatingMap R M\u2081 R \u03b9) (z : M\u2082) :\n    (f.smulRight z : MultilinearMap R (fun _ : \u03b9 => M\u2081) M\u2082) = MultilinearMap.smulRight f z", "start": [316, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.add", "code": "instance add : Add (AlternatingMap R M N \u03b9) :=\n  \u27e8fun a b =>\n    { (a + b : MultilinearMap R (fun _ : \u03b9 => M) N) with\n      map_eq_zero_of_eq' := fun v i j h hij => by\n        simp [a.map_eq_zero_of_eq v h hij, b.map_eq_zero_of_eq v h hij] }\u27e9", "start": [323, 1], "end": [327, 75], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.add_apply", "code": "@[simp]\ntheorem add_apply : (f + f') v = f v + f' v", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_add", "code": "@[norm_cast]\ntheorem coe_add : (\u2191(f + f') : MultilinearMap R (fun _ : \u03b9 => M) N) = f + f'", "start": [335, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.zero", "code": "instance zero : Zero (AlternatingMap R M N \u03b9) :=\n  \u27e8{ (0 : MultilinearMap R (fun _ : \u03b9 => M) N) with\n      map_eq_zero_of_eq' := fun v i j _ _ => by simp }\u27e9", "start": [340, 1], "end": [342, 56], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.zero_apply", "code": "@[simp]\ntheorem zero_apply : (0 : AlternatingMap R M N \u03b9) v = 0", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_zero", "code": "@[norm_cast]\ntheorem coe_zero : ((0 : AlternatingMap R M N \u03b9) : MultilinearMap R (fun _ : \u03b9 => M) N) = 0", "start": [350, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.mk_zero", "code": "@[simp]\ntheorem mk_zero :\n    mk (0 : MultilinearMap R (fun _ : \u03b9 \u21a6 M) N) (0 : AlternatingMap R M N \u03b9).2 = 0", "start": [355, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.inhabited", "code": "instance inhabited : Inhabited (AlternatingMap R M N \u03b9) :=\n  \u27e80\u27e9", "start": [360, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (AlternatingMap R M N \u03b9) :=\n  coe_injective.addCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => coeFn_smul _ _", "start": [364, 1], "end": [365, 79], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.neg", "code": "instance neg : Neg (AlternatingMap R M N' \u03b9) :=\n  \u27e8fun f =>\n    { -(f : MultilinearMap R (fun _ : \u03b9 => M) N') with\n      map_eq_zero_of_eq' := fun v i j h hij => by simp [f.map_eq_zero_of_eq v h hij] }\u27e9", "start": [368, 1], "end": [371, 88], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (m : \u03b9 \u2192 M) : (-g) m = -g m", "start": [374, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_neg", "code": "@[norm_cast]\ntheorem coe_neg : ((-g : AlternatingMap R M N' \u03b9) : MultilinearMap R (fun _ : \u03b9 => M) N') = -g", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.sub", "code": "instance sub : Sub (AlternatingMap R M N' \u03b9) :=\n  \u27e8fun f g =>\n    { (f - g : MultilinearMap R (fun _ : \u03b9 => M) N') with\n      map_eq_zero_of_eq' := fun v i j h hij => by\n        simp [f.map_eq_zero_of_eq v h hij, g.map_eq_zero_of_eq v h hij] }\u27e9", "start": [384, 1], "end": [388, 75], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.sub_apply", "code": "@[simp]\ntheorem sub_apply (m : \u03b9 \u2192 M) : (g - g\u2082) m = g m - g\u2082 m", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_sub", "code": "@[norm_cast]\ntheorem coe_sub : (\u2191(g - g\u2082) : MultilinearMap R (fun _ : \u03b9 => M) N') = g - g\u2082", "start": [396, 1], "end": [398, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.addCommGroup", "code": "instance addCommGroup : AddCommGroup (AlternatingMap R M N' \u03b9) :=\n  coe_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => coeFn_smul _ _) fun _ _ => coeFn_smul _ _", "start": [401, 1], "end": [403, 58], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.distribMulAction", "code": "instance distribMulAction : DistribMulAction S (AlternatingMap R M N \u03b9) where\n  one_smul _ := ext fun _ => one_smul _ _\n  mul_smul _ _ _ := ext fun _ => mul_smul _ _ _\n  smul_zero _ := ext fun _ => smul_zero _\n  smul_add _ _ _ := ext fun _ => smul_add _ _ _", "start": [409, 1], "end": [413, 48], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.module", "code": "instance module : Module S (AlternatingMap R M N \u03b9) where\n  add_smul _ _ _ := ext fun _ => add_smul _ _ _\n  zero_smul _ := ext fun _ => zero_smul _ _", "start": [422, 1], "end": [426, 44], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors [NoZeroSMulDivisors S N] :\n    NoZeroSMulDivisors S (AlternatingMap R M N \u03b9) :=\n  coe_injective.noZeroSMulDivisors _ rfl coeFn_smul", "start": [429, 1], "end": [431, 52], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.ofSubsingleton", "code": "@[simps]\ndef ofSubsingleton [Subsingleton \u03b9] (i : \u03b9) : AlternatingMap R M M \u03b9 :=\n  { MultilinearMap.ofSubsingleton R M i with\n    toFun := Function.eval i\n    map_eq_zero_of_eq' := fun _ _ _ _ hij => (hij <| Subsingleton.elim _ _).elim }", "start": [440, 1], "end": [446, 83], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.constOfIsEmpty", "code": "@[simps (config := { fullyApplied := false })]\ndef constOfIsEmpty [IsEmpty \u03b9] (m : N) : AlternatingMap R M N \u03b9 :=\n  { MultilinearMap.constOfIsEmpty R _ m with\n    toFun := Function.const _ m\n    map_eq_zero_of_eq' := fun _ => isEmptyElim }", "start": [452, 1], "end": [457, 49], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.codRestrict", "code": "@[simps]\ndef codRestrict (f : AlternatingMap R M N \u03b9) (p : Submodule R N) (h : \u2200 v, f v \u2208 p) :\n    AlternatingMap R M p \u03b9 :=\n  { f.toMultilinearMap.codRestrict p h with\n    toFun := fun v => \u27e8f v, h v\u27e9\n    map_eq_zero_of_eq' := fun _ _ _ hv hij => Subtype.ext <| map_eq_zero_of_eq _ _ hv hij }", "start": [463, 1], "end": [469, 92], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compAlternatingMap", "code": "def compAlternatingMap (g : N \u2192\u2097[R] N\u2082) : AlternatingMap R M N \u03b9 \u2192+ AlternatingMap R M N\u2082 \u03b9 where\n  toFun f :=\n    { g.compMultilinearMap (f : MultilinearMap R (fun _ : \u03b9 => M) N) with\n      map_eq_zero_of_eq' := fun v i j h hij => by simp [f.map_eq_zero_of_eq v h hij] }\n  map_zero' := by\n    ext\n    simp\n  map_add' a b := by\n    ext\n    simp", "start": [484, 1], "end": [494, 9], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_compAlternatingMap", "code": "@[simp]\ntheorem coe_compAlternatingMap (g : N \u2192\u2097[R] N\u2082) (f : AlternatingMap R M N \u03b9) :\n    \u21d1(g.compAlternatingMap f) = g \u2218 f", "start": [497, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compAlternatingMap_apply", "code": "@[simp]\ntheorem compAlternatingMap_apply (g : N \u2192\u2097[R] N\u2082) (f : AlternatingMap R M N \u03b9) (m : \u03b9 \u2192 M) :\n    g.compAlternatingMap f m = g (f m)", "start": [503, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smulRight_eq_comp", "code": "theorem smulRight_eq_comp {R M\u2081 M\u2082 \u03b9 : Type*} [CommSemiring R] [AddCommMonoid M\u2081]\n    [AddCommMonoid M\u2082] [Module R M\u2081] [Module R M\u2082] (f : AlternatingMap R M\u2081 R \u03b9) (z : M\u2082) :\n    f.smulRight z = (LinearMap.id.smulRight z).compAlternatingMap f", "start": [509, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.subtype_compAlternatingMap_codRestrict", "code": "@[simp]\ntheorem subtype_compAlternatingMap_codRestrict (f : AlternatingMap R M N \u03b9) (p : Submodule R N)\n    (h) : p.subtype.compAlternatingMap (f.codRestrict p h) = f", "start": [515, 1], "end": [518, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compAlternatingMap_codRestrict", "code": "@[simp]\ntheorem compAlternatingMap_codRestrict (g : N \u2192\u2097[R] N\u2082) (f : AlternatingMap R M N \u03b9)\n    (p : Submodule R N\u2082) (h) :\n    (g.codRestrict p h).compAlternatingMap f =\n      (g.compAlternatingMap f).codRestrict p fun v => h (f v)", "start": [521, 1], "end": [526, 34], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap", "code": "def compLinearMap (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) : AlternatingMap R M\u2082 N \u03b9 :=\n  { (f : MultilinearMap R (fun _ : \u03b9 => M) N).compLinearMap fun _ => g with\n    map_eq_zero_of_eq' := fun _ _ _ h hij => f.map_eq_zero_of_eq _ (LinearMap.congr_arg h) hij }", "start": [537, 1], "end": [541, 97], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_compLinearMap", "code": "theorem coe_compLinearMap (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) :\n    \u21d1(f.compLinearMap g) = f \u2218 (\u00b7 \u2218 \u00b7) g", "start": [544, 1], "end": [546, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_apply", "code": "@[simp]\ntheorem compLinearMap_apply (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) (v : \u03b9 \u2192 M\u2082) :\n    f.compLinearMap g v = f fun i => g (v i)", "start": [549, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_assoc", "code": "theorem compLinearMap_assoc (f : AlternatingMap R M N \u03b9) (g\u2081 : M\u2082 \u2192\u2097[R] M) (g\u2082 : M\u2083 \u2192\u2097[R] M\u2082) :\n    (f.compLinearMap g\u2081).compLinearMap g\u2082 = f.compLinearMap (g\u2081 \u2218\u2097 g\u2082)", "start": [555, 1], "end": [559, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.zero_compLinearMap", "code": "@[simp]\ntheorem zero_compLinearMap (g : M\u2082 \u2192\u2097[R] M) : (0 : AlternatingMap R M N \u03b9).compLinearMap g = 0", "start": [562, 1], "end": [565, 46], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.add_compLinearMap", "code": "@[simp]\ntheorem add_compLinearMap (f\u2081 f\u2082 : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) :\n    (f\u2081 + f\u2082).compLinearMap g = f\u2081.compLinearMap g + f\u2082.compLinearMap g", "start": [568, 1], "end": [572, 45], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_zero", "code": "@[simp]\ntheorem compLinearMap_zero [Nonempty \u03b9] (f : AlternatingMap R M N \u03b9) :\n    f.compLinearMap (0 : M\u2082 \u2192\u2097[R] M) = 0", "start": [575, 1], "end": [581, 19], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_id", "code": "@[simp]\ntheorem compLinearMap_id (f : AlternatingMap R M N \u03b9) : f.compLinearMap LinearMap.id = f", "start": [584, 1], "end": [587, 19], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_injective", "code": "theorem compLinearMap_injective (f : M\u2082 \u2192\u2097[R] M) (hf : Function.Surjective f) :\n    Function.Injective fun g : AlternatingMap R M N \u03b9 => g.compLinearMap f", "start": [590, 1], "end": [593, 94], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearMap_inj", "code": "theorem compLinearMap_inj (f : M\u2082 \u2192\u2097[R] M) (hf : Function.Surjective f)\n    (g\u2081 g\u2082 : AlternatingMap R M N \u03b9) : g\u2081.compLinearMap f = g\u2082.compLinearMap f \u2194 g\u2081 = g\u2082", "start": [596, 1], "end": [598, 40], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domLCongr", "code": "@[simps apply]\ndef domLCongr (e : M \u2243\u2097[R] M\u2082) : AlternatingMap R M N \u03b9 \u2243\u2097[S] AlternatingMap R M\u2082 N \u03b9 where\n  toFun f := f.compLinearMap e.symm\n  invFun g := g.compLinearMap e\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv f := AlternatingMap.ext fun _ => f.congr_arg <| funext fun _ => e.symm_apply_apply _\n  right_inv f := AlternatingMap.ext fun _ => f.congr_arg <| funext fun _ => e.apply_symm_apply _", "start": [606, 1], "end": [614, 97], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domLCongr_refl", "code": "@[simp]\ntheorem domLCongr_refl : domLCongr R N \u03b9 S (LinearEquiv.refl R M) = LinearEquiv.refl S _", "start": [618, 1], "end": [620, 59], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domLCongr_symm", "code": "@[simp]\ntheorem domLCongr_symm (e : M \u2243\u2097[R] M\u2082) : (domLCongr R N \u03b9 S e).symm = domLCongr R N \u03b9 S e.symm", "start": [623, 1], "end": [625, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domLCongr_trans", "code": "theorem domLCongr_trans (e : M \u2243\u2097[R] M\u2082) (f : M\u2082 \u2243\u2097[R] M\u2083) :\n    (domLCongr R N \u03b9 S e).trans (domLCongr R N \u03b9 S f) = domLCongr R N \u03b9 S (e.trans f)", "start": [628, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.compLinearEquiv_eq_zero_iff", "code": "@[simp]\ntheorem compLinearEquiv_eq_zero_iff (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2243\u2097[R] M) :\n    f.compLinearMap (g : M\u2082 \u2192\u2097[R] M) = 0 \u2194 f = 0", "start": [635, 1], "end": [640, 45], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_update_sum", "code": "theorem map_update_sum {\u03b1 : Type*} [DecidableEq \u03b9] (t : Finset \u03b1) (i : \u03b9) (g : \u03b1 \u2192 M) (m : \u03b9 \u2192 M) :\n    f (update m i (\u2211 a in t, g a)) = \u2211 a in t, f (update m i (g a))", "start": [662, 1], "end": [664, 44], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_update_self", "code": "theorem map_update_self [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) :\n    f (Function.update v i (v j)) = 0", "start": [677, 1], "end": [679, 91], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_update_update", "code": "theorem map_update_update [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) (m : M) :\n    f (Function.update (Function.update v i m) j m) = 0", "start": [682, 1], "end": [685, 88], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_swap_add", "code": "theorem map_swap_add [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) :\n    f (v \u2218 Equiv.swap i j) + f v = 0", "start": [688, 1], "end": [693, 95], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_add_swap", "code": "theorem map_add_swap [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) :\n    f v + f (v \u2218 Equiv.swap i j) = 0", "start": [696, 1], "end": [699, 29], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_swap", "code": "theorem map_swap [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) : g (v \u2218 Equiv.swap i j) = -g v", "start": [702, 1], "end": [703, 53], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_perm", "code": "theorem map_perm [DecidableEq \u03b9] [Fintype \u03b9] (v : \u03b9 \u2192 M) (\u03c3 : Equiv.Perm \u03b9) :\n    g (v \u2218 \u03c3) = Equiv.Perm.sign \u03c3 \u2022 g v", "start": [706, 1], "end": [713, 65], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_congr_perm", "code": "theorem map_congr_perm [DecidableEq \u03b9] [Fintype \u03b9] (\u03c3 : Equiv.Perm \u03b9) :\n    g v = Equiv.Perm.sign \u03c3 \u2022 g (v \u2218 \u03c3)", "start": [716, 1], "end": [719, 7], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr", "code": "@[simps]\ndef domDomCongr (\u03c3 : \u03b9 \u2243 \u03b9') (f : AlternatingMap R M N \u03b9) : AlternatingMap R M N \u03b9' :=\n  { f.toMultilinearMap.domDomCongr \u03c3 with\n    toFun := fun v => f (v \u2218 \u03c3)\n    map_eq_zero_of_eq' := fun v i j hv hij =>\n      f.map_eq_zero_of_eq (v \u2218 \u03c3) (i := \u03c3.symm i) (j := \u03c3.symm j)\n        (by simpa using hv) (\u03c3.symm.injective.ne hij) }", "start": [724, 1], "end": [733, 56], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_refl", "code": "@[simp]\ntheorem domDomCongr_refl (f : AlternatingMap R M N \u03b9) : f.domDomCongr (Equiv.refl \u03b9) = f", "start": [737, 1], "end": [738, 96], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_trans", "code": "theorem domDomCongr_trans (\u03c3\u2081 : \u03b9 \u2243 \u03b9') (\u03c3\u2082 : \u03b9' \u2243 \u03b9'') (f : AlternatingMap R M N \u03b9) :\n    f.domDomCongr (\u03c3\u2081.trans \u03c3\u2082) = (f.domDomCongr \u03c3\u2081).domDomCongr \u03c3\u2082", "start": [741, 1], "end": [743, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_zero", "code": "@[simp]\ntheorem domDomCongr_zero (\u03c3 : \u03b9 \u2243 \u03b9') : (0 : AlternatingMap R M N \u03b9).domDomCongr \u03c3 = 0", "start": [746, 1], "end": [748, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_add", "code": "@[simp]\ntheorem domDomCongr_add (\u03c3 : \u03b9 \u2243 \u03b9') (f g : AlternatingMap R M N \u03b9) :\n    (f + g).domDomCongr \u03c3 = f.domDomCongr \u03c3 + g.domDomCongr \u03c3", "start": [751, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_smul", "code": "@[simp]\ntheorem domDomCongr_smul {S : Type*} [Monoid S] [DistribMulAction S N] [SMulCommClass R S N]\n    (\u03c3 : \u03b9 \u2243 \u03b9') (c : S) (f : AlternatingMap R M N \u03b9) :\n    (c \u2022 f).domDomCongr \u03c3 = c \u2022 f.domDomCongr \u03c3", "start": [757, 1], "end": [761, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongrEquiv", "code": "@[simps apply symm_apply]\ndef domDomCongrEquiv (\u03c3 : \u03b9 \u2243 \u03b9') : AlternatingMap R M N \u03b9 \u2243+ AlternatingMap R M N \u03b9' where\n  toFun := domDomCongr \u03c3\n  invFun := domDomCongr \u03c3.symm\n  left_inv f := by\n    ext\n    simp [Function.comp]\n  right_inv m := by\n    ext\n    simp [Function.comp]\n  map_add' := domDomCongr_add \u03c3", "start": [764, 1], "end": [777, 32], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomLcongr", "code": "@[simps apply symm_apply]\ndef domDomLcongr (\u03c3 : \u03b9 \u2243 \u03b9') : AlternatingMap R M N \u03b9 \u2243\u2097[S] AlternatingMap R M N \u03b9' where\n  toFun := domDomCongr \u03c3\n  invFun := domDomCongr \u03c3.symm\n  left_inv f := by ext; simp [Function.comp]\n  right_inv m := by ext; simp [Function.comp]\n  map_add' := domDomCongr_add \u03c3\n  map_smul' := domDomCongr_smul \u03c3", "start": [786, 1], "end": [794, 34], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomLcongr_refl", "code": "@[simp]\ntheorem domDomLcongr_refl :\n    (domDomLcongr S (Equiv.refl \u03b9) : AlternatingMap R M N \u03b9 \u2243\u2097[S] AlternatingMap R M N \u03b9) =\n      LinearEquiv.refl _ _", "start": [797, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomLcongr_toAddEquiv", "code": "@[simp]\ntheorem domDomLcongr_toAddEquiv (\u03c3 : \u03b9 \u2243 \u03b9') :\n    (\u2191(domDomLcongr S \u03c3 : AlternatingMap R M N \u03b9 \u2243\u2097[S] _) : AlternatingMap R M N \u03b9 \u2243+ _) =\n      domDomCongrEquiv \u03c3", "start": [804, 1], "end": [808, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_eq_iff", "code": "@[simp]\ntheorem domDomCongr_eq_iff (\u03c3 : \u03b9 \u2243 \u03b9') (f g : AlternatingMap R M N \u03b9) :\n    f.domDomCongr \u03c3 = g.domDomCongr \u03c3 \u2194 f = g", "start": [813, 1], "end": [817, 70], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_eq_zero_iff", "code": "@[simp]\ntheorem domDomCongr_eq_zero_iff (\u03c3 : \u03b9 \u2243 \u03b9') (f : AlternatingMap R M N \u03b9) :\n    f.domDomCongr \u03c3 = 0 \u2194 f = 0", "start": [820, 1], "end": [823, 91], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.domDomCongr_perm", "code": "theorem domDomCongr_perm [Fintype \u03b9] [DecidableEq \u03b9] (\u03c3 : Equiv.Perm \u03b9) :\n    g.domDomCongr \u03c3 = Equiv.Perm.sign \u03c3 \u2022 g", "start": [826, 1], "end": [828, 45], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_domDomCongr", "code": "@[norm_cast]\ntheorem coe_domDomCongr (\u03c3 : \u03b9 \u2243 \u03b9') :\n    \u2191(f.domDomCongr \u03c3) = (f : MultilinearMap R (fun _ : \u03b9 => M) N).domDomCongr \u03c3", "start": [831, 1], "end": [834, 34], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_linearDependent", "code": "theorem map_linearDependent {K : Type*} [Ring K] {M : Type*} [AddCommGroup M] [Module K M]\n    {N : Type*} [AddCommGroup N] [Module K N] [NoZeroSMulDivisors K N] (f : AlternatingMap K M N \u03b9)\n    (v : \u03b9 \u2192 M) (h : \u00acLinearIndependent K v) : f v = 0", "start": [839, 1], "end": [855, 59], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_vecCons_add", "code": "theorem map_vecCons_add {n : \u2115} (f : AlternatingMap R M N (Fin n.succ)) (m : Fin n \u2192 M) (x y : M) :\n    f (Matrix.vecCons (x + y) m) = f (Matrix.vecCons x m) + f (Matrix.vecCons y m)", "start": [862, 1], "end": [865, 36], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.map_vecCons_smul", "code": "theorem map_vecCons_smul {n : \u2115} (f : AlternatingMap R M N (Fin n.succ)) (m : Fin n \u2192 M) (c : R)\n    (x : M) : f (Matrix.vecCons (c \u2022 x) m) = c \u2022 f (Matrix.vecCons x m)", "start": [868, 1], "end": [871, 37], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.alternization_map_eq_zero_of_eq_aux", "code": "private theorem alternization_map_eq_zero_of_eq_aux (m : MultilinearMap R (fun _ : \u03b9 => M) N')\n    (v : \u03b9 \u2192 M) (i j : \u03b9) (i_ne_j : i \u2260 j) (hv : v i = v j) :\n    (\u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3) v = 0", "start": [886, 1], "end": [895, 43], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.alternatization", "code": "def alternatization : MultilinearMap R (fun _ : \u03b9 => M) N' \u2192+ AlternatingMap R M N' \u03b9 where\n  toFun m :=\n    { \u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3 with\n      toFun := \u21d1(\u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3)\n      map_eq_zero_of_eq' := fun v i j hvij hij =>\n        alternization_map_eq_zero_of_eq_aux m v i j hij hvij }\n  map_add' a b := by\n    ext\n    simp only [mk_coe, AlternatingMap.coe_mk, sum_apply, smul_apply, domDomCongr_apply, add_apply,\n      smul_add, Finset.sum_add_distrib, AlternatingMap.add_apply]\n  map_zero' := by\n    ext\n    simp only [mk_coe, AlternatingMap.coe_mk, sum_apply, smul_apply, domDomCongr_apply,\n      zero_apply, smul_zero, Finset.sum_const_zero, AlternatingMap.zero_apply]", "start": [897, 1], "end": [912, 79], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.alternatization_def", "code": "theorem alternatization_def (m : MultilinearMap R (fun _ : \u03b9 => M) N') :\n    \u21d1(alternatization m) = (\u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3 : _)", "start": [915, 1], "end": [917, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.alternatization_coe", "code": "theorem alternatization_coe (m : MultilinearMap R (fun _ : \u03b9 => M) N') :\n    \u2191(alternatization m) = (\u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3 : _)", "start": [920, 1], "end": [922, 20], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.alternatization_apply", "code": "theorem alternatization_apply (m : MultilinearMap R (fun _ : \u03b9 => M) N') (v : \u03b9 \u2192 M) :\n    alternatization m v = \u2211 \u03c3 : Perm \u03b9, Equiv.Perm.sign \u03c3 \u2022 m.domDomCongr \u03c3 v", "start": [925, 1], "end": [927, 57], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.coe_alternatization", "code": "theorem coe_alternatization [DecidableEq \u03b9] [Fintype \u03b9] (a : AlternatingMap R M N' \u03b9) :\n    MultilinearMap.alternatization (a : MultilinearMap R (fun _ => M) N')\n    = Nat.factorial (Fintype.card \u03b9) \u2022 a", "start": [934, 1], "end": [942, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compMultilinearMap_alternatization", "code": "theorem compMultilinearMap_alternatization (g : N' \u2192\u2097[R] N'\u2082)\n    (f : MultilinearMap R (fun _ : \u03b9 => M) N') :\n    MultilinearMap.alternatization (g.compMultilinearMap f)\n      = g.compAlternatingMap (MultilinearMap.alternatization f)", "start": [951, 1], "end": [957, 44], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_alternating", "code": "theorem Basis.ext_alternating {f g : AlternatingMap R' N\u2081 N\u2082 \u03b9} (e : Basis \u03b9\u2081 R' N\u2081)\n    (h : \u2200 v : \u03b9 \u2192 \u03b9\u2081, Function.Injective v \u2192 (f fun i => e (v i)) = g fun i => e (v i)) :\n    f = g", "start": [972, 1], "end": [983, 47], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft", "code": "@[simps]\ndef curryLeft {n : \u2115} (f : AlternatingMap R' M'' N'' (Fin n.succ)) :\n    M'' \u2192\u2097[R'] AlternatingMap R' M'' N'' (Fin n) where\n  toFun m :=\n    { f.toMultilinearMap.curryLeft m with\n      toFun := fun v => f (Matrix.vecCons m v)\n      map_eq_zero_of_eq' := fun v i j hv hij =>\n        f.map_eq_zero_of_eq _ (by\n          rwa [Matrix.cons_val_succ, Matrix.cons_val_succ]) ((Fin.succ_injective _).ne hij) }\n  map_add' m\u2081 m\u2082 := ext fun v => f.map_vecCons_add _ _ _\n  map_smul' r m := ext fun v => f.map_vecCons_smul _ _ _", "start": [999, 1], "end": [1015, 57], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_zero", "code": "@[simp]\ntheorem curryLeft_zero {n : \u2115} : curryLeft (0 : AlternatingMap R' M'' N'' (Fin n.succ)) = 0", "start": [1019, 1], "end": [1021, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_add", "code": "@[simp]\ntheorem curryLeft_add {n : \u2115} (f g : AlternatingMap R' M'' N'' (Fin n.succ)) :\n    curryLeft (f + g) = curryLeft f + curryLeft g", "start": [1024, 1], "end": [1027, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_smul", "code": "@[simp]\ntheorem curryLeft_smul {n : \u2115} (r : R') (f : AlternatingMap R' M'' N'' (Fin n.succ)) :\n    curryLeft (r \u2022 f) = r \u2022 curryLeft f", "start": [1030, 1], "end": [1033, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeftLinearMap", "code": "@[simps]\ndef curryLeftLinearMap {n : \u2115} :\n    AlternatingMap R' M'' N'' (Fin n.succ) \u2192\u2097[R'] M'' \u2192\u2097[R'] AlternatingMap R' M'' N'' (Fin n) where\n  toFun f := f.curryLeft\n  map_add' := curryLeft_add\n  map_smul' := curryLeft_smul", "start": [1036, 1], "end": [1043, 30], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_same", "code": "@[simp]\ntheorem curryLeft_same {n : \u2115} (f : AlternatingMap R' M'' N'' (Fin n.succ.succ)) (m : M'') :\n    (f.curryLeft m).curryLeft m = 0", "start": [1047, 1], "end": [1051, 63], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_compAlternatingMap", "code": "@[simp]\ntheorem curryLeft_compAlternatingMap {n : \u2115} (g : N'' \u2192\u2097[R'] N\u2082'')\n    (f : AlternatingMap R' M'' N'' (Fin n.succ)) (m : M'') :\n    (g.compAlternatingMap f).curryLeft m = g.compAlternatingMap (f.curryLeft m)", "start": [1054, 1], "end": [1058, 6], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.curryLeft_compLinearMap", "code": "@[simp]\ntheorem curryLeft_compLinearMap {n : \u2115} (g : M\u2082'' \u2192\u2097[R'] M'')\n    (f : AlternatingMap R' M'' N'' (Fin n.succ)) (m : M\u2082'') :\n    (f.compLinearMap g).curryLeft m = (f.curryLeft (g m)).compLinearMap g", "start": [1061, 1], "end": [1068, 11], "kind": "commanddeclaration"}, {"full_name": "AlternatingMap.constLinearEquivOfIsEmpty", "code": "@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty \u03b9] : N'' \u2243\u2097[R'] AlternatingMap R' M'' N'' \u03b9 where\n  toFun := AlternatingMap.constOfIsEmpty R' M'' \u03b9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => AlternatingMap.congr_arg f <| Subsingleton.elim _ _", "start": [1071, 1], "end": [1080, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/PEquiv.lean", "imports": ["Mathlib/Data/PEquiv.lean", "Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PEquiv.toMatrix", "code": "def toMatrix [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243. n) : Matrix m n \u03b1 :=\n  of fun i j => if j \u2208 f i then (1 : \u03b1) else 0", "start": [50, 1], "end": [53, 47], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_apply", "code": "@[simp]\ntheorem toMatrix_apply [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243. n) (i j) :\n    toMatrix f i j = if j \u2208 f i then (1 : \u03b1) else 0", "start": [57, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mul_matrix_apply", "code": "theorem mul_matrix_apply [Fintype m] [DecidableEq m] [Semiring \u03b1] (f : l \u2243. m) (M : Matrix m n \u03b1)\n    (i j) : (f.toMatrix * M :) i j = Option.casesOn (f i) 0 fun fi => M fi j", "start": [63, 1], "end": [68, 90], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_symm", "code": "theorem toMatrix_symm [DecidableEq m] [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243. n) :\n    (f.symm.toMatrix : Matrix n m \u03b1) = f.toMatrix\u1d40", "start": [71, 1], "end": [75, 8], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_refl", "code": "@[simp]\ntheorem toMatrix_refl [DecidableEq n] [Zero \u03b1] [One \u03b1] :\n    ((PEquiv.refl n).toMatrix : Matrix n n \u03b1) = 1", "start": [78, 1], "end": [82, 35], "kind": "commanddeclaration"}, {"full_name": "PEquiv.matrix_mul_apply", "code": "theorem matrix_mul_apply [Fintype m] [Semiring \u03b1] [DecidableEq n] (M : Matrix l m \u03b1) (f : m \u2243. n)\n    (i j) : (M * f.toMatrix :) i j = Option.casesOn (f.symm j) 0 fun fj => M i fj", "start": [85, 1], "end": [94, 11], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toPEquiv_mul_matrix", "code": "theorem toPEquiv_mul_matrix [Fintype m] [DecidableEq m] [Semiring \u03b1] (f : m \u2243 m)\n    (M : Matrix m n \u03b1) : f.toPEquiv.toMatrix * M = fun i => M (f i)", "start": [97, 1], "end": [100, 46], "kind": "commanddeclaration"}, {"full_name": "PEquiv.mul_toPEquiv_toMatrix", "code": "theorem mul_toPEquiv_toMatrix {m n \u03b1 : Type*} [Fintype n] [DecidableEq n] [Semiring \u03b1] (f : n \u2243 n)\n    (M : Matrix m n \u03b1) : M * f.toPEquiv.toMatrix = M.submatrix id f.symm", "start": [103, 1], "end": [107, 38], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_trans", "code": "theorem toMatrix_trans [Fintype m] [DecidableEq m] [DecidableEq n] [Semiring \u03b1] (f : l \u2243. m)\n    (g : m \u2243. n) : ((f.trans g).toMatrix : Matrix l n \u03b1) = f.toMatrix * g.toMatrix", "start": [110, 1], "end": [115, 21], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_bot", "code": "@[simp]\ntheorem toMatrix_bot [DecidableEq n] [Zero \u03b1] [One \u03b1] :\n    ((\u22a5 : PEquiv m n).toMatrix : Matrix m n \u03b1) = 0", "start": [118, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_injective", "code": "theorem toMatrix_injective [DecidableEq n] [MonoidWithZero \u03b1] [Nontrivial \u03b1] :\n    Function.Injective (@toMatrix m n \u03b1 _ _ _)", "start": [124, 1], "end": [140, 33], "kind": "commanddeclaration"}, {"full_name": "PEquiv.toMatrix_swap", "code": "theorem toMatrix_swap [DecidableEq n] [Ring \u03b1] (i j : n) :\n    (Equiv.swap i j).toPEquiv.toMatrix =\n      (1 : Matrix n n \u03b1) - (single i i).toMatrix - (single j j).toMatrix + (single i j).toMatrix +\n        (single j i).toMatrix", "start": [143, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_mul_single", "code": "@[simp]\ntheorem single_mul_single [Fintype n] [DecidableEq k] [DecidableEq m] [DecidableEq n] [Semiring \u03b1]\n    (a : m) (b : n) (c : k) :\n    ((single a b).toMatrix : Matrix _ _ \u03b1) * (single b c).toMatrix = (single a c).toMatrix", "start": [152, 1], "end": [156, 45], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_mul_single_of_ne", "code": "theorem single_mul_single_of_ne [Fintype n] [DecidableEq n] [DecidableEq k] [DecidableEq m]\n    [Semiring \u03b1] {b\u2081 b\u2082 : n} (hb : b\u2081 \u2260 b\u2082) (a : m) (c : k) :\n    (single a b\u2081).toMatrix * (single b\u2082 c).toMatrix = (0 : Matrix _ _ \u03b1)", "start": [159, 1], "end": [162, 68], "kind": "commanddeclaration"}, {"full_name": "PEquiv.single_mul_single_right", "code": "@[simp]\ntheorem single_mul_single_right [Fintype n] [Fintype k] [DecidableEq n] [DecidableEq k]\n    [DecidableEq m] [Semiring \u03b1] (a : m) (b : n) (c : k) (M : Matrix k l \u03b1) :\n    (single a b).toMatrix * ((single b c).toMatrix * M) = (single a c).toMatrix * M", "start": [165, 1], "end": [171, 45], "kind": "commanddeclaration"}, {"full_name": "PEquiv.equiv_toPEquiv_toMatrix", "code": "theorem equiv_toPEquiv_toMatrix [DecidableEq n] [Zero \u03b1] [One \u03b1] (\u03c3 : Equiv n n) (i j : n) :\n    \u03c3.toPEquiv.toMatrix i j = (1 : Matrix n n \u03b1) (\u03c3 i) j", "start": [174, 1], "end": [177, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Variables.lean", "imports": ["Mathlib/Algebra/MonoidAlgebra/Degree.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Data/MvPolynomial/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.degrees", "code": "def degrees (p : MvPolynomial \u03c3 R) : Multiset \u03c3 :=\n  letI := Classical.decEq \u03c3\n  p.support.sup fun s : \u03c3 \u2192\u2080 \u2115 => toMultiset s", "start": [83, 1], "end": [89, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_def", "code": "theorem degrees_def [DecidableEq \u03c3] (p : MvPolynomial \u03c3 R) :\n    p.degrees = p.support.sup fun s : \u03c3 \u2192\u2080 \u2115 => Finsupp.toMultiset s", "start": [92, 1], "end": [93, 101], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_monomial", "code": "theorem degrees_monomial (s : \u03c3 \u2192\u2080 \u2115) (a : R) : degrees (monomial s a) \u2264 toMultiset s", "start": [96, 1], "end": [101, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_monomial_eq", "code": "theorem degrees_monomial_eq (s : \u03c3 \u2192\u2080 \u2115) (a : R) (ha : a \u2260 0) :\n    degrees (monomial s a) = toMultiset s", "start": [104, 1], "end": [108, 59], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_C", "code": "theorem degrees_C (a : R) : degrees (C a : MvPolynomial \u03c3 R) = 0", "start": [111, 1], "end": [112, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_X'", "code": "theorem degrees_X' (n : \u03c3) : degrees (X n : MvPolynomial \u03c3 R) \u2264 {n}", "start": [116, 1], "end": [117, 71], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_X", "code": "@[simp]\ntheorem degrees_X [Nontrivial R] (n : \u03c3) : degrees (X n : MvPolynomial \u03c3 R) = {n}", "start": [121, 1], "end": [123, 76], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_zero", "code": "@[simp]\ntheorem degrees_zero : degrees (0 : MvPolynomial \u03c3 R) = 0", "start": [127, 1], "end": [130, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_one", "code": "@[simp]\ntheorem degrees_one : degrees (1 : MvPolynomial \u03c3 R) = 0", "start": [133, 1], "end": [135, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_add", "code": "theorem degrees_add [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    (p + q).degrees \u2264 p.degrees \u2294 q.degrees", "start": [138, 1], "end": [146, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_sum", "code": "theorem degrees_sum {\u03b9 : Type*} [DecidableEq \u03c3] (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (\u2211 i in s, f i).degrees \u2264 s.sup fun i => (f i).degrees", "start": [149, 1], "end": [157, 60], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_mul", "code": "theorem degrees_mul (p q : MvPolynomial \u03c3 R) : (p * q).degrees \u2264 p.degrees + q.degrees", "start": [160, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_prod", "code": "theorem degrees_prod {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (\u220f i in s, f i).degrees \u2264 \u2211 i in s, (f i).degrees", "start": [170, 1], "end": [177, 60], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_pow", "code": "theorem degrees_pow (p : MvPolynomial \u03c3 R) : \u2200 n : \u2115, (p ^ n).degrees \u2264 n \u2022 p.degrees", "start": [180, 1], "end": [184, 75], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_degrees", "code": "theorem mem_degrees {p : MvPolynomial \u03c3 R} {i : \u03c3} :\n    i \u2208 p.degrees \u2194 \u2203 d, p.coeff d \u2260 0 \u2227 i \u2208 d.support", "start": [187, 1], "end": [190, 100], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.le_degrees_add", "code": "theorem le_degrees_add {p q : MvPolynomial \u03c3 R} (h : p.degrees.Disjoint q.degrees) :\n    p.degrees \u2264 (p + q).degrees", "start": [193, 1], "end": [213, 63], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_add_of_disjoint", "code": "theorem degrees_add_of_disjoint [DecidableEq \u03c3] {p q : MvPolynomial \u03c3 R}\n    (h : Multiset.Disjoint p.degrees q.degrees) : (p + q).degrees = p.degrees \u222a q.degrees", "start": [216, 1], "end": [223, 34], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_map", "code": "theorem degrees_map [CommSemiring S] (p : MvPolynomial \u03c3 R) (f : R \u2192+* S) :\n    (map f p).degrees \u2286 p.degrees", "start": [226, 1], "end": [232, 40], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_rename", "code": "theorem degrees_rename (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) :\n    (rename f \u03c6).degrees \u2286 \u03c6.degrees.map f", "start": [235, 1], "end": [249, 39], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_map_of_injective", "code": "theorem degrees_map_of_injective [CommSemiring S] (p : MvPolynomial \u03c3 R) {f : R \u2192+* S}\n    (hf : Injective f) : (map f p).degrees = p.degrees", "start": [252, 1], "end": [254, 66], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degrees_rename_of_injective", "code": "theorem degrees_rename_of_injective {p : MvPolynomial \u03c3 R} {f : \u03c3 \u2192 \u03c4} (h : Function.Injective f) :\n    degrees (rename f p) = (degrees p).map f", "start": [257, 1], "end": [263, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars", "code": "def vars (p : MvPolynomial \u03c3 R) : Finset \u03c3 :=\n  letI := Classical.decEq \u03c3\n  p.degrees.toFinset", "start": [273, 1], "end": [276, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_def", "code": "theorem vars_def [DecidableEq \u03c3] (p : MvPolynomial \u03c3 R) : p.vars = p.degrees.toFinset", "start": [279, 1], "end": [281, 14], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_0", "code": "@[simp]\ntheorem vars_0 : (0 : MvPolynomial \u03c3 R).vars = \u2205", "start": [284, 1], "end": [286, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_monomial", "code": "@[simp]\ntheorem vars_monomial (h : r \u2260 0) : (monomial s r).vars = s.support", "start": [289, 1], "end": [291, 82], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_C", "code": "@[simp]\ntheorem vars_C : (C r : MvPolynomial \u03c3 R).vars = \u2205", "start": [294, 1], "end": [296, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_X", "code": "@[simp]\ntheorem vars_X [Nontrivial R] : (X n : MvPolynomial \u03c3 R).vars = {n}", "start": [300, 1], "end": [302, 92], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_vars", "code": "theorem mem_vars (i : \u03c3) : i \u2208 p.vars \u2194 \u2203 (d : \u03c3 \u2192\u2080 \u2115) (_ : d \u2208 p.support), i \u2208 d.support", "start": [306, 1], "end": [307, 99], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_support_not_mem_vars_zero", "code": "theorem mem_support_not_mem_vars_zero {f : MvPolynomial \u03c3 R} {x : \u03c3 \u2192\u2080 \u2115} (H : x \u2208 f.support)\n    {v : \u03c3} (h : v \u2209 vars f) : x v = 0", "start": [310, 1], "end": [321, 58], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_add_subset", "code": "theorem vars_add_subset [DecidableEq \u03c3] (p q : MvPolynomial \u03c3 R) :\n    (p + q).vars \u2286 p.vars \u222a q.vars", "start": [324, 1], "end": [328, 54], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_add_of_disjoint", "code": "theorem vars_add_of_disjoint [DecidableEq \u03c3] (h : Disjoint p.vars q.vars) :\n    (p + q).vars = p.vars \u222a q.vars", "start": [331, 1], "end": [337, 11], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_mul", "code": "theorem vars_mul [DecidableEq \u03c3] (\u03c6 \u03c8 : MvPolynomial \u03c3 R) : (\u03c6 * \u03c8).vars \u2286 \u03c6.vars \u222a \u03c8.vars", "start": [342, 1], "end": [362, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_one", "code": "@[simp]\ntheorem vars_one : (1 : MvPolynomial \u03c3 R).vars = \u2205", "start": [365, 1], "end": [367, 9], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_pow", "code": "theorem vars_pow (\u03c6 : MvPolynomial \u03c3 R) (n : \u2115) : (\u03c6 ^ n).vars \u2286 \u03c6.vars", "start": [370, 1], "end": [376, 56], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_prod", "code": "theorem vars_prod {\u03b9 : Type*} [DecidableEq \u03c3] {s : Finset \u03b9} (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (\u220f i in s, f i).vars \u2286 s.biUnion fun i => (f i).vars", "start": [379, 1], "end": [390, 64], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_C_mul", "code": "theorem vars_C_mul (a : A) (ha : a \u2260 0) (\u03c6 : MvPolynomial \u03c3 A) :\n    (C a * \u03c6 : MvPolynomial \u03c3 A).vars = \u03c6.vars", "start": [397, 1], "end": [404, 62], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_sum_subset", "code": "theorem vars_sum_subset [DecidableEq \u03c3] :\n    (\u2211 i in t, \u03c6 i).vars \u2286 Finset.biUnion t fun i => (\u03c6 i).vars", "start": [416, 1], "end": [425, 15], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_sum_of_disjoint", "code": "theorem vars_sum_of_disjoint [DecidableEq \u03c3] (h : Pairwise <| (Disjoint on fun i => (\u03c6 i).vars)) :\n    (\u2211 i in t, \u03c6 i).vars = Finset.biUnion t fun i => (\u03c6 i).vars", "start": [428, 1], "end": [443, 18], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_map", "code": "theorem vars_map : (map f p).vars \u2286 p.vars", "start": [454, 1], "end": [454, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_map_of_injective", "code": "theorem vars_map_of_injective (hf : Injective f) : (map f p).vars = p.vars", "start": [459, 1], "end": [460, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_monomial_single", "code": "theorem vars_monomial_single (i : \u03c3) {e : \u2115} {r : R} (he : e \u2260 0) (hr : r \u2260 0) :\n    (monomial (Finsupp.single i e) r).vars = {i}", "start": [463, 1], "end": [465, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_eq_support_biUnion_support", "code": "theorem vars_eq_support_biUnion_support [DecidableEq \u03c3] :\n    p.vars = p.support.biUnion Finsupp.support", "start": [468, 1], "end": [472, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf", "code": "def degreeOf (n : \u03c3) (p : MvPolynomial \u03c3 R) : \u2115 :=\n  letI := Classical.decEq \u03c3\n  p.degrees.count n", "start": [484, 1], "end": [487, 20], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_def", "code": "theorem degreeOf_def [DecidableEq \u03c3] (n : \u03c3) (p : MvPolynomial \u03c3 R) :\n    p.degreeOf n = p.degrees.count n", "start": [490, 1], "end": [491, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_eq_sup", "code": "theorem degreeOf_eq_sup (n : \u03c3) (f : MvPolynomial \u03c3 R) :\n    degreeOf n f = f.support.sup fun m => m n", "start": [494, 1], "end": [500, 7], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_lt_iff", "code": "theorem degreeOf_lt_iff {n : \u03c3} {f : MvPolynomial \u03c3 R} {d : \u2115} (h : 0 < d) :\n    degreeOf n f < d \u2194 \u2200 m : \u03c3 \u2192\u2080 \u2115, m \u2208 f.support \u2192 m n < d", "start": [503, 1], "end": [505, 47], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_zero", "code": "@[simp]\ntheorem degreeOf_zero (n : \u03c3) : degreeOf n (0 : MvPolynomial \u03c3 R) = 0", "start": [508, 1], "end": [510, 72], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_C", "code": "@[simp]\ntheorem degreeOf_C (a : R) (x : \u03c3) : degreeOf x (C a : MvPolynomial \u03c3 R) = 0", "start": [513, 1], "end": [515, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_X", "code": "theorem degreeOf_X [DecidableEq \u03c3] (i j : \u03c3) [Nontrivial R] :\n    degreeOf i (X j : MvPolynomial \u03c3 R) = if i = j then 1 else 0", "start": [519, 1], "end": [524, 46], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_add_le", "code": "theorem degreeOf_add_le (n : \u03c3) (f g : MvPolynomial \u03c3 R) :\n    degreeOf n (f + g) \u2264 max (degreeOf n f) (degreeOf n g)", "start": [528, 1], "end": [534, 28], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.monomial_le_degreeOf", "code": "theorem monomial_le_degreeOf (i : \u03c3) {f : MvPolynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} (h_m : m \u2208 f.support) :\n    m i \u2264 degreeOf i f", "start": [537, 1], "end": [540, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_mul_le", "code": "theorem degreeOf_mul_le (i : \u03c3) (f g : MvPolynomial \u03c3 R) :\n    degreeOf i (f * g) \u2264 degreeOf i f + degreeOf i g", "start": [544, 1], "end": [549, 26], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_mul_X_ne", "code": "theorem degreeOf_mul_X_ne {i j : \u03c3} (f : MvPolynomial \u03c3 R) (h : i \u2260 j) :\n    degreeOf i (f * X j) = degreeOf i f", "start": [552, 1], "end": [561, 87], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_mul_X_eq", "code": "theorem degreeOf_mul_X_eq (j : \u03c3) (f : MvPolynomial \u03c3 R) :\n    degreeOf j (f * X j) \u2264 degreeOf j f + 1", "start": [566, 1], "end": [573, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.degreeOf_rename_of_injective", "code": "theorem degreeOf_rename_of_injective {p : MvPolynomial \u03c3 R} {f : \u03c3 \u2192 \u03c4} (h : Function.Injective f)\n    (i : \u03c3) : degreeOf (f i) (rename f p) = degreeOf i p", "start": [577, 1], "end": [580, 98], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree", "code": "def totalDegree (p : MvPolynomial \u03c3 R) : \u2115 :=\n  p.support.sup fun s => s.sum fun _ e => e", "start": [590, 1], "end": [592, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_eq", "code": "theorem totalDegree_eq (p : MvPolynomial \u03c3 R) :\n    p.totalDegree = p.support.sup fun m => Multiset.card (toMultiset m)", "start": [595, 1], "end": [599, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.le_totalDegree", "code": "theorem le_totalDegree {p : MvPolynomial \u03c3 R} {s : \u03c3 \u2192\u2080 \u2115} (h : s \u2208 p.support) :\n    (s.sum fun _ e => e) \u2264 totalDegree p", "start": [602, 1], "end": [604, 62], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_le_degrees_card", "code": "theorem totalDegree_le_degrees_card (p : MvPolynomial \u03c3 R) :\n    p.totalDegree \u2264 Multiset.card p.degrees", "start": [606, 1], "end": [610, 77], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_C", "code": "@[simp]\ntheorem totalDegree_C (a : R) : (C a : MvPolynomial \u03c3 R).totalDegree = 0", "start": [613, 1], "end": [620, 19], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_zero", "code": "@[simp]\ntheorem totalDegree_zero : (0 : MvPolynomial \u03c3 R).totalDegree = 0", "start": [624, 1], "end": [626, 42], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_one", "code": "@[simp]\ntheorem totalDegree_one : (1 : MvPolynomial \u03c3 R).totalDegree = 0", "start": [629, 1], "end": [631, 24], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_X", "code": "@[simp]\ntheorem totalDegree_X {R} [CommSemiring R] [Nontrivial R] (s : \u03c3) :\n    (X s : MvPolynomial \u03c3 R).totalDegree = 1", "start": [634, 1], "end": [638, 86], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_add", "code": "theorem totalDegree_add (a b : MvPolynomial \u03c3 R) :\n    (a + b).totalDegree \u2264 max a.totalDegree b.totalDegree", "start": [642, 1], "end": [644, 44], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_add_eq_left_of_totalDegree_lt", "code": "theorem totalDegree_add_eq_left_of_totalDegree_lt {p q : MvPolynomial \u03c3 R}\n    (h : q.totalDegree < p.totalDegree) : (p + q).totalDegree = p.totalDegree", "start": [647, 1], "end": [667, 81], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_add_eq_right_of_totalDegree_lt", "code": "theorem totalDegree_add_eq_right_of_totalDegree_lt {p q : MvPolynomial \u03c3 R}\n    (h : q.totalDegree < p.totalDegree) : (q + p).totalDegree = p.totalDegree", "start": [670, 1], "end": [672, 61], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_mul", "code": "theorem totalDegree_mul (a b : MvPolynomial \u03c3 R) :\n    (a * b).totalDegree \u2264 a.totalDegree + b.totalDegree", "start": [675, 1], "end": [678, 81], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_smul_le", "code": "theorem totalDegree_smul_le [CommSemiring S] [DistribMulAction R S] (a : R) (f : MvPolynomial \u03c3 S) :\n    (a \u2022 f).totalDegree \u2264 f.totalDegree", "start": [681, 1], "end": [683, 31], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_pow", "code": "theorem totalDegree_pow (a : MvPolynomial \u03c3 R) (n : \u2115) :\n    (a ^ n).totalDegree \u2264 n * a.totalDegree", "start": [686, 1], "end": [694, 70], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_monomial", "code": "@[simp]\ntheorem totalDegree_monomial (s : \u03c3 \u2192\u2080 \u2115) {c : R} (hc : c \u2260 0) :\n    (monomial s c : MvPolynomial \u03c3 R).totalDegree = s.sum fun _ e => e", "start": [697, 1], "end": [700, 60], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_X_pow", "code": "@[simp]\ntheorem totalDegree_X_pow [Nontrivial R] (s : \u03c3) (n : \u2115) :\n    (X s ^ n : MvPolynomial \u03c3 R).totalDegree = n", "start": [703, 1], "end": [705, 93], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_list_prod", "code": "theorem totalDegree_list_prod :\n    \u2200 s : List (MvPolynomial \u03c3 R), s.prod.totalDegree \u2264 (s.map MvPolynomial.totalDegree).sum", "start": [710, 1], "end": [715, 88], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_multiset_prod", "code": "theorem totalDegree_multiset_prod (s : Multiset (MvPolynomial \u03c3 R)) :\n    s.prod.totalDegree \u2264 (s.map MvPolynomial.totalDegree).sum", "start": [718, 1], "end": [722, 32], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_finset_prod", "code": "theorem totalDegree_finset_prod {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (s.prod f).totalDegree \u2264 \u2211 i in s, (f i).totalDegree", "start": [725, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_finset_sum", "code": "theorem totalDegree_finset_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 MvPolynomial \u03c3 R) :\n    (s.sum f).totalDegree \u2264 Finset.sup s fun i => (f i).totalDegree", "start": [732, 1], "end": [737, 76], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_degree_lt", "code": "theorem exists_degree_lt [Fintype \u03c3] (f : MvPolynomial \u03c3 R) (n : \u2115)\n    (h : f.totalDegree < n * Fintype.card \u03c3) {d : \u03c3 \u2192\u2080 \u2115} (hd : d \u2208 f.support) : \u2203 i, d i < n", "start": [740, 1], "end": [751, 43], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.coeff_eq_zero_of_totalDegree_lt", "code": "theorem coeff_eq_zero_of_totalDegree_lt {f : MvPolynomial \u03c3 R} {d : \u03c3 \u2192\u2080 \u2115}\n    (h : f.totalDegree < \u2211 i in d.support, d i) : coeff d f = 0", "start": [754, 1], "end": [762, 45], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.totalDegree_rename_le", "code": "theorem totalDegree_rename_le (f : \u03c3 \u2192 \u03c4) (p : MvPolynomial \u03c3 R) :\n    (rename f p).totalDegree \u2264 p.totalDegree", "start": [765, 1], "end": [777, 27], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_eq_constantCoeff_of_vars", "code": "theorem eval\u2082Hom_eq_constantCoeff_of_vars (f : R \u2192+* S) {g : \u03c3 \u2192 S} {p : MvPolynomial \u03c3 R}\n    (hp : \u2200 i \u2208 p.vars, g i = 0) : eval\u2082Hom f g p = f (constantCoeff p)", "start": [789, 1], "end": [815, 22], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.aeval_eq_constantCoeff_of_vars", "code": "theorem aeval_eq_constantCoeff_of_vars [Algebra R S] {g : \u03c3 \u2192 S} {p : MvPolynomial \u03c3 R}\n    (hp : \u2200 i \u2208 p.vars, g i = 0) : aeval g p = algebraMap _ _ (constantCoeff p)", "start": [818, 1], "end": [820, 41], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.eval\u2082Hom_congr'", "code": "theorem eval\u2082Hom_congr' {f\u2081 f\u2082 : R \u2192+* S} {g\u2081 g\u2082 : \u03c3 \u2192 S} {p\u2081 p\u2082 : MvPolynomial \u03c3 R} :\n    f\u2081 = f\u2082 \u2192\n      (\u2200 i, i \u2208 p\u2081.vars \u2192 i \u2208 p\u2082.vars \u2192 g\u2081 i = g\u2082 i) \u2192\n        p\u2081 = p\u2082 \u2192 eval\u2082Hom f\u2081 g\u2081 p\u2081 = eval\u2082Hom f\u2082 g\u2082 p\u2082", "start": [823, 1], "end": [839, 21], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.hom_congr_vars", "code": "theorem hom_congr_vars {f\u2081 f\u2082 : MvPolynomial \u03c3 R \u2192+* S} {p\u2081 p\u2082 : MvPolynomial \u03c3 R}\n    (hC : f\u2081.comp C = f\u2082.comp C) (hv : \u2200 i, i \u2208 p\u2081.vars \u2192 i \u2208 p\u2082.vars \u2192 f\u2081 (X i) = f\u2082 (X i))\n    (hp : p\u2081 = p\u2082) : f\u2081 p\u2081 = f\u2082 p\u2082", "start": [842, 1], "end": [851, 55], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.exists_rename_eq_of_vars_subset_range", "code": "theorem exists_rename_eq_of_vars_subset_range (p : MvPolynomial \u03c3 R) (f : \u03c4 \u2192 \u03c3) (hfi : Injective f)\n    (hf : \u2191p.vars \u2286 Set.range f) : \u2203 q : MvPolynomial \u03c4 R, rename f q = p", "start": [854, 1], "end": [865, 13], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.vars_rename", "code": "theorem vars_rename [DecidableEq \u03c4] (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) :\n    (rename f \u03c6).vars \u2286 \u03c6.vars.image f", "start": [868, 1], "end": [873, 60], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.mem_vars_rename", "code": "theorem mem_vars_rename (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) {j : \u03c4} (h : j \u2208 (rename f \u03c6).vars) :\n    \u2203 i : \u03c3, i \u2208 \u03c6.vars \u2227 f i = j", "start": [876, 1], "end": [879, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GCDMonoid/Finset.lean", "imports": ["Mathlib/Data/Finset/Fold.lean", "Mathlib/Algebra/GCDMonoid/Multiset.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.lcm", "code": "def lcm (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  s.fold GCDMonoid.lcm 1 f", "start": [45, 1], "end": [47, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_def", "code": "theorem lcm_def : s.lcm f = (s.1.map f).lcm", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_empty", "code": "@[simp]\ntheorem lcm_empty : (\u2205 : Finset \u03b2).lcm f = 1", "start": [56, 1], "end": [58, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_dvd_iff", "code": "@[simp]\ntheorem lcm_dvd_iff {a : \u03b1} : s.lcm f \u2223 a \u2194 \u2200 b \u2208 s, f b \u2223 a", "start": [61, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_dvd", "code": "theorem lcm_dvd {a : \u03b1} : (\u2200 b \u2208 s, f b \u2223 a) \u2192 s.lcm f \u2223 a", "start": [68, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.dvd_lcm", "code": "theorem dvd_lcm {b : \u03b2} (hb : b \u2208 s) : f b \u2223 s.lcm f", "start": [72, 1], "end": [73, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_insert", "code": "@[simp]\ntheorem lcm_insert [DecidableEq \u03b2] {b : \u03b2} :\n    (insert b s : Finset \u03b2).lcm f = GCDMonoid.lcm (f b) (s.lcm f)", "start": [76, 1], "end": [82, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_singleton", "code": "@[simp]\ntheorem lcm_singleton {b : \u03b2} : ({b} : Finset \u03b2).lcm f = normalize (f b)", "start": [85, 1], "end": [87, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.normalize_lcm", "code": "@[simp 1100]\ntheorem normalize_lcm : normalize (s.lcm f) = s.lcm f", "start": [91, 1], "end": [92, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_union", "code": "theorem lcm_union [DecidableEq \u03b2] : (s\u2081 \u222a s\u2082).lcm f = GCDMonoid.lcm (s\u2081.lcm f) (s\u2082.lcm f)", "start": [95, 1], "end": [97, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_congr", "code": "theorem lcm_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.lcm f = s\u2082.lcm g", "start": [100, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_mono_fun", "code": "theorem lcm_mono_fun {g : \u03b2 \u2192 \u03b1} (h : \u2200 b \u2208 s, f b \u2223 g b) : s.lcm f \u2223 s.lcm g", "start": [106, 1], "end": [107, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_mono", "code": "theorem lcm_mono (h : s\u2081 \u2286 s\u2082) : s\u2081.lcm f \u2223 s\u2082.lcm f", "start": [110, 1], "end": [111, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_image", "code": "theorem lcm_image [DecidableEq \u03b2] {g : \u03b3 \u2192 \u03b2} (s : Finset \u03b3) : (s.image g).lcm f = s.lcm (f \u2218 g)", "start": [114, 1], "end": [115, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_eq_lcm_image", "code": "theorem lcm_eq_lcm_image [DecidableEq \u03b1] : s.lcm f = (s.image f).lcm id", "start": [118, 1], "end": [119, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.lcm_eq_zero_iff", "code": "theorem lcm_eq_zero_iff [Nontrivial \u03b1] : s.lcm f = 0 \u2194 0 \u2208 f '' s", "start": [122, 1], "end": [124, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd", "code": "def gcd (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  s.fold GCDMonoid.gcd 0 f", "start": [134, 1], "end": [136, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_def", "code": "theorem gcd_def : s.gcd f = (s.1.map f).gcd", "start": [141, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_empty", "code": "@[simp]\ntheorem gcd_empty : (\u2205 : Finset \u03b2).gcd f = 0", "start": [145, 1], "end": [147, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.dvd_gcd_iff", "code": "theorem dvd_gcd_iff {a : \u03b1} : a \u2223 s.gcd f \u2194 \u2200 b \u2208 s, a \u2223 f b", "start": [150, 1], "end": [153, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_dvd", "code": "theorem gcd_dvd {b : \u03b2} (hb : b \u2208 s) : s.gcd f \u2223 f b", "start": [156, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.dvd_gcd", "code": "theorem dvd_gcd {a : \u03b1} : (\u2200 b \u2208 s, a \u2223 f b) \u2192 a \u2223 s.gcd f", "start": [160, 1], "end": [161, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_insert", "code": "@[simp]\ntheorem gcd_insert [DecidableEq \u03b2] {b : \u03b2} :\n    (insert b s : Finset \u03b2).gcd f = GCDMonoid.gcd (f b) (s.gcd f)", "start": [164, 1], "end": [170, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_singleton", "code": "@[simp]\ntheorem gcd_singleton {b : \u03b2} : ({b} : Finset \u03b2).gcd f = normalize (f b)", "start": [173, 1], "end": [175, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.normalize_gcd", "code": "@[simp 1100]\ntheorem normalize_gcd : normalize (s.gcd f) = s.gcd f", "start": [179, 1], "end": [180, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_union", "code": "theorem gcd_union [DecidableEq \u03b2] : (s\u2081 \u222a s\u2082).gcd f = GCDMonoid.gcd (s\u2081.gcd f) (s\u2082.gcd f)", "start": [183, 1], "end": [185, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_congr", "code": "theorem gcd_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.gcd f = s\u2082.gcd g", "start": [188, 1], "end": [191, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_mono_fun", "code": "theorem gcd_mono_fun {g : \u03b2 \u2192 \u03b1} (h : \u2200 b \u2208 s, f b \u2223 g b) : s.gcd f \u2223 s.gcd g", "start": [194, 1], "end": [195, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_mono", "code": "theorem gcd_mono (h : s\u2081 \u2286 s\u2082) : s\u2082.gcd f \u2223 s\u2081.gcd f", "start": [198, 1], "end": [199, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_image", "code": "theorem gcd_image [DecidableEq \u03b2] {g : \u03b3 \u2192 \u03b2} (s : Finset \u03b3) : (s.image g).gcd f = s.gcd (f \u2218 g)", "start": [202, 1], "end": [203, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_eq_gcd_image", "code": "theorem gcd_eq_gcd_image [DecidableEq \u03b1] : s.gcd f = (s.image f).gcd id", "start": [206, 1], "end": [207, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_eq_zero_iff", "code": "theorem gcd_eq_zero_iff : s.gcd f = 0 \u2194 \u2200 x : \u03b2, x \u2208 s \u2192 f x = 0", "start": [210, 1], "end": [221, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_eq_gcd_filter_ne_zero", "code": "theorem gcd_eq_gcd_filter_ne_zero [DecidablePred fun x : \u03b2 \u21a6 f x = 0] :\n    s.gcd f = (s.filter fun x \u21a6 f x \u2260 0).gcd f", "start": [226, 1], "end": [239, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_mul_left", "code": "nonrec theorem gcd_mul_left {a : \u03b1} : (s.gcd fun x \u21a6 a * f x) = normalize a * s.gcd f", "start": [242, 1], "end": [248, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_mul_right", "code": "nonrec theorem gcd_mul_right {a : \u03b1} : (s.gcd fun x \u21a6 f x * a) = s.gcd f * normalize a", "start": [251, 1], "end": [257, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.extract_gcd'", "code": "theorem extract_gcd' (f g : \u03b2 \u2192 \u03b1) (hs : \u2203 x, x \u2208 s \u2227 f x \u2260 0)\n    (hg : \u2200 b \u2208 s, f b = s.gcd f * g b) : s.gcd g = 1", "start": [260, 1], "end": [265, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.extract_gcd", "code": "theorem extract_gcd (f : \u03b2 \u2192 \u03b1) (hs : s.Nonempty) :\n    \u2203 g : \u03b2 \u2192 \u03b1, (\u2200 b \u2208 s, f b = s.gcd f * g b) \u2227 s.gcd g = 1", "start": [268, 1], "end": [279, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.gcd_eq_of_dvd_sub", "code": "theorem gcd_eq_of_dvd_sub {s : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : \u2200 x : \u03b2, x \u2208 s \u2192 a \u2223 f x - g x) :\n    GCDMonoid.gcd a (s.gcd f) = GCDMonoid.gcd a (s.gcd g)", "start": [292, 1], "end": [303, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/CancelLeads.lean", "imports": ["Mathlib/Data/Polynomial/Degree/Lemmas.lean", "Mathlib/Tactic/ComputeDegree.lean", "Mathlib/Data/Polynomial/Degree/Definitions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.cancelLeads", "code": "def cancelLeads : R[X] :=\n  C p.leadingCoeff * X ^ (p.natDegree - q.natDegree) * q -\n    C q.leadingCoeff * X ^ (q.natDegree - p.natDegree) * p", "start": [38, 1], "end": [42, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.neg_cancelLeads", "code": "@[simp]\ntheorem neg_cancelLeads : -p.cancelLeads q = q.cancelLeads p", "start": [47, 1], "end": [49, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_cancelLeads_lt_of_natDegree_le_natDegree_of_comm", "code": "theorem natDegree_cancelLeads_lt_of_natDegree_le_natDegree_of_comm\n    (comm : p.leadingCoeff * q.leadingCoeff = q.leadingCoeff * p.leadingCoeff)\n    (h : p.natDegree \u2264 q.natDegree) (hq : 0 < q.natDegree) :\n    (p.cancelLeads q).natDegree < q.natDegree", "start": [52, 1], "end": [71, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_cancelLeads_of_dvd_of_dvd", "code": "theorem dvd_cancelLeads_of_dvd_of_dvd {r : R[X]} (pq : p \u2223 q) (pr : p \u2223 r) : p \u2223 q.cancelLeads r", "start": [80, 1], "end": [81, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_cancelLeads_lt_of_natDegree_le_natDegree", "code": "theorem natDegree_cancelLeads_lt_of_natDegree_le_natDegree (h : p.natDegree \u2264 q.natDegree)\n    (hq : 0 < q.natDegree) : (p.cancelLeads q).natDegree < q.natDegree", "start": [84, 1], "end": [86, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/FieldDivision.lean", "imports": ["Mathlib/RingTheory/EuclideanDomain.lean", "Mathlib/Data/Polynomial/RingDivision.lean", "Mathlib/Data/Polynomial/Derivative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.derivative_rootMultiplicity_of_root", "code": "theorem derivative_rootMultiplicity_of_root [CharZero R] {p : R[X]} {t : R} (hpt : p.IsRoot t) :\n    p.derivative.rootMultiplicity t = p.rootMultiplicity t - 1", "start": [34, 1], "end": [57, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootMultiplicity_sub_one_le_derivative_rootMultiplicity", "code": "theorem rootMultiplicity_sub_one_le_derivative_rootMultiplicity [CharZero R] (p : R[X]) (t : R) :\n    p.rootMultiplicity t - 1 \u2264 p.derivative.rootMultiplicity t", "start": [60, 1], "end": [65, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.instNormalizationMonoid", "code": "instance instNormalizationMonoid : NormalizationMonoid R[X] where\n  normUnit p :=\n    \u27e8C \u2191(normUnit p.leadingCoeff), C \u2191(normUnit p.leadingCoeff)\u207b\u00b9, by\n      rw [\u2190 RingHom.map_mul, Units.mul_inv, C_1], by rw [\u2190 RingHom.map_mul, Units.inv_mul, C_1]\u27e9\n  normUnit_zero := Units.ext (by simp)\n  normUnit_mul hp0 hq0 :=\n    Units.ext\n      (by\n        dsimp\n        rw [Ne.def, \u2190 leadingCoeff_eq_zero] at *\n        rw [leadingCoeff_mul, normUnit_mul hp0 hq0, Units.val_mul, C_mul])\n  normUnit_coe_units u :=\n    Units.ext\n      (by\n        dsimp\n        rw [\u2190 mul_one u\u207b\u00b9, Units.val_mul, Units.eq_inv_mul_iff_mul_eq]\n        rcases Polynomial.isUnit_iff.1 \u27e8u, rfl\u27e9 with \u27e8_, \u27e8w, rfl\u27e9, h2\u27e9\n        rw [\u2190 h2, leadingCoeff_C, normUnit_coe_units, \u2190 C_mul, Units.mul_inv, C_1]\n        rfl)", "start": [72, 1], "end": [90, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_normUnit", "code": "@[simp]\ntheorem coe_normUnit {p : R[X]} : (normUnit p : R[X]) = C \u2191(normUnit p.leadingCoeff)", "start": [92, 1], "end": [94, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_normalize", "code": "theorem leadingCoeff_normalize (p : R[X]) :\n    leadingCoeff (normalize p) = normalize (leadingCoeff p)", "start": [97, 1], "end": [98, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Monic.normalize_eq_self", "code": "theorem Monic.normalize_eq_self {p : R[X]} (hp : p.Monic) : normalize p = p", "start": [101, 1], "end": [103, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.roots_normalize", "code": "theorem roots_normalize {p : R[X]} : (normalize p).roots = p.roots", "start": [106, 1], "end": [107, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_of_ne_zero_of_nonunit", "code": "theorem degree_pos_of_ne_zero_of_nonunit (hp0 : p \u2260 0) (hp : \u00acIsUnit p) : 0 < degree p", "start": [118, 1], "end": [121, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_mul_leadingCoeff_inv", "code": "theorem monic_mul_leadingCoeff_inv (h : p \u2260 0) : Monic (p * C (leadingCoeff p)\u207b\u00b9)", "start": [124, 1], "end": [126, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_mul_leadingCoeff_inv", "code": "theorem degree_mul_leadingCoeff_inv (p : R[X]) (h : q \u2260 0) :\n    degree (p * C (leadingCoeff q)\u207b\u00b9) = degree p", "start": [129, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_eq_zero", "code": "@[simp]\ntheorem map_eq_zero [Semiring S] [Nontrivial S] (f : R \u2192+* S) : p.map f = 0 \u2194 p = 0", "start": [135, 1], "end": [139, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_ne_zero", "code": "theorem map_ne_zero [Semiring S] [Nontrivial S] {f : R \u2192+* S} (hp : p \u2260 0) : p.map f \u2260 0", "start": [142, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_map", "code": "@[simp]\ntheorem degree_map [Semiring S] [Nontrivial S] (p : R[X]) (f : R \u2192+* S) :\n    degree (p.map f) = degree p", "start": [146, 1], "end": [149, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_map", "code": "@[simp]\ntheorem natDegree_map [Semiring S] [Nontrivial S] (f : R \u2192+* S) :\n    natDegree (p.map f) = natDegree p", "start": [152, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_map", "code": "@[simp]\ntheorem leadingCoeff_map [Semiring S] [Nontrivial S] (f : R \u2192+* S) :\n    leadingCoeff (p.map f) = f (leadingCoeff p)", "start": [158, 1], "end": [161, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_map_iff", "code": "theorem monic_map_iff [Semiring S] [Nontrivial S] {f : R \u2192+* S} {p : R[X]} :\n    (p.map f).Monic \u2194 p.Monic", "start": [164, 1], "end": [166, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_iff_degree_eq_zero", "code": "theorem isUnit_iff_degree_eq_zero : IsUnit p \u2194 degree p = 0", "start": [175, 1], "end": [183, 54], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div", "code": "def div (p q : R[X]) :=\n  C (leadingCoeff q)\u207b\u00b9 * (p /\u2098 (q * C (leadingCoeff q)\u207b\u00b9))", "start": [186, 1], "end": [188, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mod", "code": "def mod (p q : R[X]) :=\n  p %\u2098 (q * C (leadingCoeff q)\u207b\u00b9)", "start": [191, 1], "end": [193, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.quotient_mul_add_remainder_eq_aux", "code": "private theorem quotient_mul_add_remainder_eq_aux (p q : R[X]) : q * div p q + mod p q = p", "start": [196, 1], "end": [202, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.remainder_lt_aux", "code": "private theorem remainder_lt_aux (p : R[X]) (hq : q \u2260 0) : degree (mod p q) < degree q", "start": [204, 1], "end": [206, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_def", "code": "theorem div_def : p / q = C (leadingCoeff q)\u207b\u00b9 * (p /\u2098 (q * C (leadingCoeff q)\u207b\u00b9))", "start": [214, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mod_def", "code": "theorem mod_def : p % q = p %\u2098 (q * C (leadingCoeff q)\u207b\u00b9)", "start": [218, 1], "end": [218, 65], "kind": "commanddeclaration"}, {"full_name": "Polynomial.modByMonic_eq_mod", "code": "theorem modByMonic_eq_mod (p : R[X]) (hq : Monic q) : p %\u2098 q = p % q", "start": [221, 1], "end": [222, 101], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_eq_div", "code": "theorem divByMonic_eq_div (p : R[X]) (hq : Monic q) : p /\u2098 q = p / q", "start": [225, 1], "end": [227, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mod_X_sub_C_eq_C_eval", "code": "theorem mod_X_sub_C_eq_C_eval (p : R[X]) (a : R) : p % (X - C a) = C (p.eval a)", "start": [230, 1], "end": [231, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_div_eq_iff_isRoot", "code": "theorem mul_div_eq_iff_isRoot : (X - C a) * (p / (X - C a)) = p \u2194 IsRoot p a", "start": [235, 1], "end": [236, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mod_eq_self_iff", "code": "theorem mod_eq_self_iff (hq0 : q \u2260 0) : p % q = p \u2194 degree p < degree q", "start": [251, 1], "end": [259, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_eq_zero_iff", "code": "theorem div_eq_zero_iff (hq0 : q \u2260 0) : p / q = 0 \u2194 degree p < degree q", "start": [262, 1], "end": [270, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_add_div", "code": "theorem degree_add_div (hq0 : q \u2260 0) (hpq : degree q \u2264 degree p) :\n    degree q + degree (p / q) = degree p", "start": [273, 1], "end": [281, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_div_le", "code": "theorem degree_div_le (p q : R[X]) : degree (p / q) \u2264 degree p", "start": [284, 1], "end": [287, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_div_lt", "code": "theorem degree_div_lt (hp : p \u2260 0) (hq : 0 < degree q) : degree (p / q) < degree p", "start": [290, 1], "end": [295, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isUnit_map", "code": "theorem isUnit_map [Field k] (f : R \u2192+* k) : IsUnit (p.map f) \u2194 IsUnit p", "start": [298, 1], "end": [299, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_div", "code": "theorem map_div [Field k] (f : R \u2192+* k) : (p / q).map f = p.map f / q.map f", "start": [302, 1], "end": [306, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_mod", "code": "theorem map_mod [Field k] (f : R \u2192+* k) : (p % q).map f = p.map f % q.map f", "start": [309, 1], "end": [313, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.gcd_map", "code": "theorem gcd_map [Field k] [DecidableEq R] [DecidableEq k] (f : R \u2192+* k) :\n    gcd (p.map f) (q.map f) = (gcd p q).map f", "start": [320, 1], "end": [323, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval\u2082_gcd_eq_zero", "code": "theorem eval\u2082_gcd_eq_zero [CommSemiring k] [DecidableEq R]\n    {\u03d5 : R \u2192+* k} {f g : R[X]} {\u03b1 : k} (hf : f.eval\u2082 \u03d5 \u03b1 = 0)\n    (hg : g.eval\u2082 \u03d5 \u03b1 = 0) : (EuclideanDomain.gcd f g).eval\u2082 \u03d5 \u03b1 = 0", "start": [328, 1], "end": [332, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eval_gcd_eq_zero", "code": "theorem eval_gcd_eq_zero [DecidableEq R] {f g : R[X]} {\u03b1 : R}\n    (hf : f.eval \u03b1 = 0) (hg : g.eval \u03b1 = 0) : (EuclideanDomain.gcd f g).eval \u03b1 = 0", "start": [335, 1], "end": [337, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_left_of_root_gcd", "code": "theorem root_left_of_root_gcd [CommSemiring k] [DecidableEq R] {\u03d5 : R \u2192+* k} {f g : R[X]} {\u03b1 : k}\n    (h\u03b1 : (EuclideanDomain.gcd f g).eval\u2082 \u03d5 \u03b1 = 0) : f.eval\u2082 \u03d5 \u03b1 = 0", "start": [340, 1], "end": [343, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_right_of_root_gcd", "code": "theorem root_right_of_root_gcd [CommSemiring k] [DecidableEq R] {\u03d5 : R \u2192+* k} {f g : R[X]} {\u03b1 : k}\n    (h\u03b1 : (EuclideanDomain.gcd f g).eval\u2082 \u03d5 \u03b1 = 0) : g.eval\u2082 \u03d5 \u03b1 = 0", "start": [346, 1], "end": [349, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.root_gcd_iff_root_left_right", "code": "theorem root_gcd_iff_root_left_right [CommSemiring k] [DecidableEq R]\n    {\u03d5 : R \u2192+* k} {f g : R[X]} {\u03b1 : k} :\n    (EuclideanDomain.gcd f g).eval\u2082 \u03d5 \u03b1 = 0 \u2194 f.eval\u2082 \u03d5 \u03b1 = 0 \u2227 g.eval\u2082 \u03d5 \u03b1 = 0", "start": [352, 1], "end": [355, 101], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isRoot_gcd_iff_isRoot_left_right", "code": "theorem isRoot_gcd_iff_isRoot_left_right [DecidableEq R] {f g : R[X]} {\u03b1 : R} :\n    (EuclideanDomain.gcd f g).IsRoot \u03b1 \u2194 f.IsRoot \u03b1 \u2227 g.IsRoot \u03b1", "start": [358, 1], "end": [360, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isCoprime_map", "code": "theorem isCoprime_map [Field k] (f : R \u2192+* k) : IsCoprime (p.map f) (q.map f) \u2194 IsCoprime p q", "start": [363, 1], "end": [365, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_roots_map", "code": "theorem mem_roots_map [CommRing k] [IsDomain k] {f : R \u2192+* k} {x : k} (hp : p \u2260 0) :\n    x \u2208 (p.map f).roots \u2194 p.eval\u2082 f x = 0", "start": [368, 1], "end": [370, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_monomial", "code": "theorem rootSet_monomial [CommRing S] [IsDomain S] [Algebra R S] {n : \u2115} (hn : n \u2260 0) {a : R}\n    (ha : a \u2260 0) : (monomial n a).rootSet S = {0}", "start": [373, 1], "end": [377, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_C_mul_X_pow", "code": "theorem rootSet_C_mul_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : \u2115} (hn : n \u2260 0) {a : R}\n    (ha : a \u2260 0) : rootSet (C a * X ^ n) S = {0}", "start": [380, 1], "end": [382, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_X_pow", "code": "theorem rootSet_X_pow [CommRing S] [IsDomain S] [Algebra R S] {n : \u2115} (hn : n \u2260 0) :\n    (X ^ n : R[X]).rootSet S = {0}", "start": [386, 1], "end": [389, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rootSet_prod", "code": "theorem rootSet_prod [CommRing S] [IsDomain S] [Algebra R S] {\u03b9 : Type*} (f : \u03b9 \u2192 R[X])\n    (s : Finset \u03b9) (h : s.prod f \u2260 0) : (s.prod f).rootSet S = \u22c3 i \u2208 s, (f i).rootSet S", "start": [393, 1], "end": [398, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_root_of_degree_eq_one", "code": "theorem exists_root_of_degree_eq_one (h : degree p = 1) : \u2203 x, IsRoot p x", "start": [401, 1], "end": [408, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_inv_units", "code": "theorem coeff_inv_units (u : R[X]\u02e3) (n : \u2115) : ((\u2191u : R[X]).coeff n)\u207b\u00b9 = (\u2191u\u207b\u00b9 : R[X]).coeff n", "start": [411, 1], "end": [418, 9], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monic_normalize", "code": "theorem monic_normalize [DecidableEq R] (hp0 : p \u2260 0) : Monic (normalize p)", "start": [421, 1], "end": [424, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.leadingCoeff_div", "code": "theorem leadingCoeff_div (hpq : q.degree \u2264 p.degree) :\n    (p / q).leadingCoeff = p.leadingCoeff / q.leadingCoeff", "start": [427, 1], "end": [434, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.div_C_mul", "code": "theorem div_C_mul : p / (C a * q) = C a\u207b\u00b9 * (p / q)", "start": [437, 1], "end": [442, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_dvd", "code": "theorem C_mul_dvd (ha : a \u2260 0) : C a * p \u2223 q \u2194 p \u2223 q", "start": [446, 1], "end": [450, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.dvd_C_mul", "code": "theorem dvd_C_mul (ha : a \u2260 0) : p \u2223 Polynomial.C a * q \u2194 p \u2223 q", "start": [454, 1], "end": [459, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coe_normUnit_of_ne_zero", "code": "theorem coe_normUnit_of_ne_zero [DecidableEq R] (hp : p \u2260 0) :\n    (normUnit p : R[X]) = C p.leadingCoeff\u207b\u00b9", "start": [463, 1], "end": [466, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.normalize_monic", "code": "theorem normalize_monic [DecidableEq R] (h : Monic p) : normalize p = p", "start": [469, 1], "end": [469, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.map_dvd_map'", "code": "theorem map_dvd_map' [Field k] (f : R \u2192+* k) {x y : R[X]} : x.map f \u2223 y.map f \u2194 x \u2223 y", "start": [472, 1], "end": [479, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_normalize", "code": "theorem degree_normalize [DecidableEq R] : degree (normalize p) = degree p", "start": [482, 1], "end": [482, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.prime_of_degree_eq_one", "code": "theorem prime_of_degree_eq_one (hp1 : degree p = 1) : Prime p", "start": [485, 1], "end": [490, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.irreducible_of_degree_eq_one", "code": "theorem irreducible_of_degree_eq_one (hp1 : degree p = 1) : Irreducible p", "start": [493, 1], "end": [494, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_irreducible_C", "code": "theorem not_irreducible_C (x : R) : \u00acIrreducible (C x)", "start": [497, 1], "end": [501, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.degree_pos_of_irreducible", "code": "theorem degree_pos_of_irreducible (hp : Irreducible p) : 0 < p.degree", "start": [505, 1], "end": [508, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_sub_C_mul_divByMonic_eq_sub_modByMonic", "code": "theorem X_sub_C_mul_divByMonic_eq_sub_modByMonic {K : Type*} [Field K] (f : K[X]) (a : K) :\n    (X - C a) * (f /\u2098 (X - C a)) = f - f %\u2098 (X - C a)", "start": [513, 1], "end": [516, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative", "code": "theorem divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative\n    {K : Type*} [Field K] (f : K[X]) (a : K) :\n    f /\u2098 (X - C a) + (X - C a) * derivative (f /\u2098 (X - C a)) = derivative f", "start": [520, 1], "end": [528, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_sub_C_dvd_derivative_of_X_sub_C_dvd_divByMonic", "code": "theorem X_sub_C_dvd_derivative_of_X_sub_C_dvd_divByMonic {K : Type*} [Field K] (f : K[X]) {a : K}\n    (hf : (X - C a) \u2223 f /\u2098 (X - C a)) : X - C a \u2223 derivative f", "start": [532, 1], "end": [537, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isCoprime_of_is_root_of_eval_derivative_ne_zero", "code": "theorem isCoprime_of_is_root_of_eval_derivative_ne_zero {K : Type*} [Field K] (f : K[X]) (a : K)\n    (hf' : f.derivative.eval a \u2260 0) : IsCoprime (X - C a : K[X]) (f /\u2098 (X - C a))", "start": [539, 1], "end": [551, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/MeasurableSpace/Basic.lean", "imports": ["Mathlib/Data/Prod/TProd.lean", "Mathlib/GroupTheory/Coset.lean", "Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Logic/Lemmas.lean", "Mathlib/Order/Filter/CountableSeparatingOn.lean", "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean", "Mathlib/Order/LiminfLimsup.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/UnionLift.lean", "Mathlib/Order/Filter/SmallSets.lean"], "premises": [{"full_name": "MeasurableSpace.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (m : MeasurableSpace \u03b1) : MeasurableSpace \u03b2 where\n  MeasurableSet' s := MeasurableSet[m] <| f \u207b\u00b9' s\n  measurableSet_empty := m.measurableSet_empty\n  measurableSet_compl s hs := m.measurableSet_compl _ hs\n  measurableSet_iUnion f hf := by simpa only [preimage_iUnion] using m.measurableSet_iUnion _ hf", "start": [79, 1], "end": [85, 97], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_def", "code": "lemma map_def {s : Set \u03b2} : MeasurableSet[m.map f] s \u2194 MeasurableSet[m] (f \u207b\u00b9' s) := Iff.rfl", "start": [88, 1], "end": [88, 93], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableSpace.map_id", "code": "@[simp]\ntheorem map_id : m.map id = m", "start": [90, 1], "end": [92, 39], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_comp", "code": "@[simp]\ntheorem map_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} : (m.map f).map g = m.map (g \u2218 f)", "start": [95, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap", "code": "protected def comap (f : \u03b1 \u2192 \u03b2) (m : MeasurableSpace \u03b2) : MeasurableSpace \u03b1 where\n  MeasurableSet' s := \u2203 s', MeasurableSet[m] s' \u2227 f \u207b\u00b9' s' = s\n  measurableSet_empty := \u27e8\u2205, m.measurableSet_empty, rfl\u27e9\n  measurableSet_compl := fun s \u27e8s', h\u2081, h\u2082\u27e9 => \u27e8s'\u1d9c, m.measurableSet_compl _ h\u2081, h\u2082 \u25b8 rfl\u27e9\n  measurableSet_iUnion s hs :=\n    let \u27e8s', hs'\u27e9 := Classical.axiom_of_choice hs\n    \u27e8\u22c3 i, s' i, m.measurableSet_iUnion _ fun i => (hs' i).left, by simp [hs']\u27e9", "start": [100, 1], "end": [108, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_eq_generateFrom", "code": "theorem comap_eq_generateFrom (m : MeasurableSpace \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    m.comap f = generateFrom { t | \u2203 s, MeasurableSet s \u2227 f \u207b\u00b9' s = t }", "start": [111, 1], "end": [113, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_id", "code": "@[simp]\ntheorem comap_id : m.comap id = m", "start": [116, 1], "end": [118, 82], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_comp", "code": "@[simp]\ntheorem comap_comp {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b2} : (m.comap f).comap g = m.comap (f \u2218 g)", "start": [121, 1], "end": [124, 101], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_le_iff_le_map", "code": "theorem comap_le_iff_le_map {f : \u03b1 \u2192 \u03b2} : m'.comap f \u2264 m \u2194 m' \u2264 m.map f", "start": [127, 1], "end": [128, 76], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.gc_comap_map", "code": "theorem gc_comap_map (f : \u03b1 \u2192 \u03b2) :\n    GaloisConnection (MeasurableSpace.comap f) (MeasurableSpace.map f)", "start": [131, 1], "end": [133, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_mono", "code": "theorem map_mono (h : m\u2081 \u2264 m\u2082) : m\u2081.map f \u2264 m\u2082.map f", "start": [136, 1], "end": [137, 32], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.monotone_map", "code": "theorem monotone_map : Monotone (MeasurableSpace.map f)", "start": [140, 1], "end": [140, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_mono", "code": "theorem comap_mono (h : m\u2081 \u2264 m\u2082) : m\u2081.comap g \u2264 m\u2082.comap g", "start": [143, 1], "end": [144, 32], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.monotone_comap", "code": "theorem monotone_comap : Monotone (MeasurableSpace.comap g)", "start": [147, 1], "end": [147, 89], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_bot", "code": "@[simp]\ntheorem comap_bot : (\u22a5 : MeasurableSpace \u03b1).comap g = \u22a5", "start": [150, 1], "end": [152, 25], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_sup", "code": "@[simp]\ntheorem comap_sup : (m\u2081 \u2294 m\u2082).comap g = m\u2081.comap g \u2294 m\u2082.comap g", "start": [155, 1], "end": [157, 25], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_iSup", "code": "@[simp]\ntheorem comap_iSup {m : \u03b9 \u2192 MeasurableSpace \u03b1} : (\u2a06 i, m i).comap g = \u2a06 i, (m i).comap g", "start": [160, 1], "end": [162, 26], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_top", "code": "@[simp]\ntheorem map_top : (\u22a4 : MeasurableSpace \u03b1).map f = \u22a4", "start": [165, 1], "end": [167, 25], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_inf", "code": "@[simp]\ntheorem map_inf : (m\u2081 \u2293 m\u2082).map f = m\u2081.map f \u2293 m\u2082.map f", "start": [170, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_iInf", "code": "@[simp]\ntheorem map_iInf {m : \u03b9 \u2192 MeasurableSpace \u03b1} : (\u2a05 i, m i).map f = \u2a05 i, (m i).map f", "start": [175, 1], "end": [177, 26], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_map_le", "code": "theorem comap_map_le : (m.map f).comap f \u2264 m", "start": [180, 1], "end": [181, 28], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.le_map_comap", "code": "theorem le_map_comap : m \u2264 (m.comap g).map g", "start": [184, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.map_const", "code": "@[simp] theorem map_const {m} (b : \u03b2) : MeasurableSpace.map (fun _a : \u03b1 \u21a6 b) m = \u22a4", "start": [190, 1], "end": [191, 100], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_const", "code": "@[simp] theorem comap_const {m} (b : \u03b2) : MeasurableSpace.comap (fun _a : \u03b1 => b) m = \u22a5", "start": [194, 1], "end": [195, 100], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_generateFrom", "code": "theorem comap_generateFrom {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} :\n    (generateFrom s).comap f = generateFrom (preimage f '' s)", "start": [198, 1], "end": [203, 89], "kind": "commanddeclaration"}, {"full_name": "measurable_iff_le_map", "code": "theorem measurable_iff_le_map {m\u2081 : MeasurableSpace \u03b1} {m\u2082 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    Measurable f \u2194 m\u2082 \u2264 m\u2081.map f", "start": [212, 1], "end": [214, 10], "kind": "commanddeclaration"}, {"full_name": "Measurable.le_map", "code": "alias \u27e8Measurable.le_map, Measurable.of_le_map\u27e9 := measurable_iff_le_map", "start": [217, 1], "end": [217, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Measurable.of_le_map", "code": "alias \u27e8Measurable.le_map, Measurable.of_le_map\u27e9 := measurable_iff_le_map", "start": [217, 1], "end": [217, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "measurable_iff_comap_le", "code": "theorem measurable_iff_comap_le {m\u2081 : MeasurableSpace \u03b1} {m\u2082 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    Measurable f \u2194 m\u2082.comap f \u2264 m\u2081", "start": [221, 1], "end": [223, 27], "kind": "commanddeclaration"}, {"full_name": "Measurable.comap_le", "code": "alias \u27e8Measurable.comap_le, Measurable.of_comap_le\u27e9 := measurable_iff_comap_le", "start": [226, 1], "end": [226, 79], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Measurable.of_comap_le", "code": "alias \u27e8Measurable.comap_le, Measurable.of_comap_le\u27e9 := measurable_iff_comap_le", "start": [226, 1], "end": [226, 79], "kind": "stdtacticaliasaliaslr"}, {"full_name": "comap_measurable", "code": "theorem comap_measurable {m : MeasurableSpace \u03b2} (f : \u03b1 \u2192 \u03b2) : Measurable[m.comap f] f", "start": [230, 1], "end": [231, 27], "kind": "commanddeclaration"}, {"full_name": "Measurable.mono", "code": "theorem Measurable.mono {ma ma' : MeasurableSpace \u03b1} {mb mb' : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hf : @Measurable \u03b1 \u03b2 ma mb f) (ha : ma \u2264 ma') (hb : mb' \u2264 mb) : @Measurable \u03b1 \u03b2 ma' mb' f", "start": [234, 1], "end": [236, 37], "kind": "commanddeclaration"}, {"full_name": "measurable_id''", "code": "theorem measurable_id'' {m m\u03b1 : MeasurableSpace \u03b1} (hm : m \u2264 m\u03b1) : @Measurable \u03b1 \u03b1 m\u03b1 m id", "start": [239, 1], "end": [240, 31], "kind": "commanddeclaration"}, {"full_name": "measurable_from_top", "code": "@[measurability]\ntheorem measurable_from_top [MeasurableSpace \u03b2] {f : \u03b1 \u2192 \u03b2} : Measurable[\u22a4] f", "start": [245, 1], "end": [246, 100], "kind": "commanddeclaration"}, {"full_name": "measurable_generateFrom", "code": "theorem measurable_generateFrom [MeasurableSpace \u03b1] {s : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 t \u2208 s, MeasurableSet (f \u207b\u00b9' t)) : @Measurable _ _ _ (generateFrom s) f", "start": [249, 1], "end": [251, 44], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.measurable", "code": "@[nontriviality, measurability]\ntheorem Subsingleton.measurable [Subsingleton \u03b1] : Measurable f", "start": [260, 1], "end": [262, 38], "kind": "commanddeclaration"}, {"full_name": "measurable_of_subsingleton_codomain", "code": "@[nontriviality, measurability]\ntheorem measurable_of_subsingleton_codomain [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) : Measurable f", "start": [265, 1], "end": [267, 77], "kind": "commanddeclaration"}, {"full_name": "measurable_one", "code": "@[measurability, to_additive]\ntheorem measurable_one [One \u03b1] : Measurable (1 : \u03b2 \u2192 \u03b1)", "start": [270, 1], "end": [272, 30], "kind": "commanddeclaration"}, {"full_name": "measurable_of_empty", "code": "theorem measurable_of_empty [IsEmpty \u03b1] (f : \u03b1 \u2192 \u03b2) : Measurable f", "start": [276, 1], "end": [277, 26], "kind": "commanddeclaration"}, {"full_name": "measurable_of_empty_codomain", "code": "theorem measurable_of_empty_codomain [IsEmpty \u03b2] (f : \u03b1 \u2192 \u03b2) : Measurable f", "start": [280, 1], "end": [281, 40], "kind": "commanddeclaration"}, {"full_name": "measurable_const'", "code": "theorem measurable_const' {f : \u03b2 \u2192 \u03b1} (hf : \u2200 x y, f x = f y) : Measurable f", "start": [284, 1], "end": [290, 11], "kind": "commanddeclaration"}, {"full_name": "measurable_natCast", "code": "@[measurability]\ntheorem measurable_natCast [NatCast \u03b1] (n : \u2115) : Measurable (n : \u03b2 \u2192 \u03b1)", "start": [293, 1], "end": [295, 30], "kind": "commanddeclaration"}, {"full_name": "measurable_intCast", "code": "@[measurability]\ntheorem measurable_intCast [IntCast \u03b1] (n : \u2124) : Measurable (n : \u03b2 \u2192 \u03b1)", "start": [298, 1], "end": [300, 30], "kind": "commanddeclaration"}, {"full_name": "measurable_of_countable", "code": "theorem measurable_of_countable [Countable \u03b1] [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    Measurable f", "start": [303, 1], "end": [305, 39], "kind": "commanddeclaration"}, {"full_name": "measurable_of_finite", "code": "theorem measurable_of_finite [Finite \u03b1] [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 \u03b2) : Measurable f", "start": [308, 1], "end": [309, 28], "kind": "commanddeclaration"}, {"full_name": "Measurable.iterate", "code": "@[measurability]\ntheorem Measurable.iterate {f : \u03b1 \u2192 \u03b1} (hf : Measurable f) : \u2200 n, Measurable f^[n]", "start": [316, 1], "end": [319, 47], "kind": "commanddeclaration"}, {"full_name": "measurableSet_preimage", "code": "@[measurability]\ntheorem measurableSet_preimage {t : Set \u03b2} (hf : Measurable f) (ht : MeasurableSet t) :\n    MeasurableSet (f \u207b\u00b9' t)", "start": [324, 1], "end": [327, 8], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.preimage", "code": "protected theorem MeasurableSet.preimage {t : Set \u03b2} (ht : MeasurableSet t) (hf : Measurable f) :\n    MeasurableSet (f \u207b\u00b9' t)", "start": [331, 1], "end": [333, 8], "kind": "commanddeclaration"}, {"full_name": "Measurable.piecewise", "code": "@[measurability]\nprotected theorem Measurable.piecewise {_ : DecidablePred (\u00b7 \u2208 s)} (hs : MeasurableSet s)\n    (hf : Measurable f) (hg : Measurable g) : Measurable (piecewise s f g)", "start": [335, 1], "end": [340, 31], "kind": "commanddeclaration"}, {"full_name": "Measurable.ite", "code": "theorem Measurable.ite {p : \u03b1 \u2192 Prop} {_ : DecidablePred p} (hp : MeasurableSet { a : \u03b1 | p a })\n    (hf : Measurable f) (hg : Measurable g) : Measurable fun x => ite (p x) (f x) (g x)", "start": [343, 1], "end": [349, 32], "kind": "commanddeclaration"}, {"full_name": "Measurable.indicator", "code": "@[measurability]\ntheorem Measurable.indicator [Zero \u03b2] (hf : Measurable f) (hs : MeasurableSet s) :\n    Measurable (s.indicator f)", "start": [352, 1], "end": [355, 35], "kind": "commanddeclaration"}, {"full_name": "measurable_indicator_const_iff", "code": "lemma measurable_indicator_const_iff [Zero \u03b2] [MeasurableSingletonClass \u03b2] (b : \u03b2) [NeZero b] :\n    Measurable (s.indicator (fun (_ : \u03b1) \u21a6 b)) \u2194 MeasurableSet s := by\n  constructor <;> intro h\n  \u00b7 convert h (MeasurableSet.singleton (0 : \u03b2)).compl\n    ext a\n    simp [NeZero.ne b]\n  \u00b7 exact measurable_const.indicator h", "start": [358, 1], "end": [366, 39], "kind": "mathlibtacticlemma"}, {"full_name": "measurableSet_mulSupport", "code": "@[to_additive (attr := measurability)]\ntheorem measurableSet_mulSupport [One \u03b2] [MeasurableSingletonClass \u03b2] (hf : Measurable f) :\n    MeasurableSet (mulSupport f)", "start": [368, 1], "end": [371, 39], "kind": "commanddeclaration"}, {"full_name": "Measurable.measurable_of_countable_ne", "code": "theorem Measurable.measurable_of_countable_ne [MeasurableSingletonClass \u03b1] (hf : Measurable f)\n    (h : Set.Countable { x | f x \u2260 g x }) : Measurable g", "start": [375, 1], "end": [388, 47], "kind": "commanddeclaration"}, {"full_name": "Empty.instMeasurableSpace", "code": "instance Empty.instMeasurableSpace : MeasurableSpace Empty := \u22a4", "start": [395, 1], "end": [395, 64], "kind": "commanddeclaration"}, {"full_name": "PUnit.instMeasurableSpace", "code": "instance PUnit.instMeasurableSpace : MeasurableSpace PUnit := \u22a4", "start": [397, 1], "end": [397, 64], "kind": "commanddeclaration"}, {"full_name": "Bool.instMeasurableSpace", "code": "instance Bool.instMeasurableSpace : MeasurableSpace Bool := \u22a4", "start": [399, 1], "end": [399, 62], "kind": "commanddeclaration"}, {"full_name": "Prop.instMeasurableSpace", "code": "instance Prop.instMeasurableSpace : MeasurableSpace Prop := \u22a4", "start": [401, 1], "end": [401, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.instMeasurableSpace", "code": "instance Nat.instMeasurableSpace : MeasurableSpace \u2115 := \u22a4", "start": [403, 1], "end": [403, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.instMeasurableSpace", "code": "instance Fin.instMeasurableSpace (n : \u2115) : MeasurableSpace (Fin n) := \u22a4", "start": [405, 1], "end": [405, 72], "kind": "commanddeclaration"}, {"full_name": "Int.instMeasurableSpace", "code": "instance Int.instMeasurableSpace : MeasurableSpace \u2124 := \u22a4", "start": [406, 1], "end": [406, 58], "kind": "commanddeclaration"}, {"full_name": "Rat.instMeasurableSpace", "code": "instance Rat.instMeasurableSpace : MeasurableSpace \u211a := \u22a4", "start": [408, 1], "end": [408, 58], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.measurableSingletonClass", "code": "instance Subsingleton.measurableSingletonClass {\u03b1} [MeasurableSpace \u03b1] [Subsingleton \u03b1] :\n    MeasurableSingletonClass \u03b1 := by\n  refine' \u27e8fun i => _\u27e9\n  convert MeasurableSet.univ\n  simp [Set.eq_univ_iff_forall]", "start": [411, 1], "end": [415, 32], "kind": "commanddeclaration"}, {"full_name": "Bool.instMeasurableSingletonClass", "code": "instance Bool.instMeasurableSingletonClass : MeasurableSingletonClass Bool := \u27e8fun _ => trivial\u27e9", "start": [419, 1], "end": [419, 97], "kind": "commanddeclaration"}, {"full_name": "Prop.instMeasurableSingletonClass", "code": "instance Prop.instMeasurableSingletonClass : MeasurableSingletonClass Prop := \u27e8fun _ => trivial\u27e9", "start": [421, 1], "end": [421, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.instMeasurableSingletonClass", "code": "instance Nat.instMeasurableSingletonClass : MeasurableSingletonClass \u2115 := \u27e8fun _ => trivial\u27e9", "start": [423, 1], "end": [423, 93], "kind": "commanddeclaration"}, {"full_name": "Fin.instMeasurableSingletonClass", "code": "instance Fin.instMeasurableSingletonClass (n : \u2115) : MeasurableSingletonClass (Fin n) :=\n  \u27e8fun _ => trivial\u27e9", "start": [425, 1], "end": [426, 21], "kind": "commanddeclaration"}, {"full_name": "Int.instMeasurableSingletonClass", "code": "instance Int.instMeasurableSingletonClass : MeasurableSingletonClass \u2124 := \u27e8fun _ => trivial\u27e9", "start": [427, 1], "end": [427, 93], "kind": "commanddeclaration"}, {"full_name": "Rat.instMeasurableSingletonClass", "code": "instance Rat.instMeasurableSingletonClass : MeasurableSingletonClass \u211a := \u27e8fun _ => trivial\u27e9", "start": [429, 1], "end": [429, 93], "kind": "commanddeclaration"}, {"full_name": "measurable_to_countable", "code": "theorem measurable_to_countable [MeasurableSpace \u03b1] [Countable \u03b1] [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (h : \u2200 y, MeasurableSet (f \u207b\u00b9' {f y})) : Measurable f", "start": [432, 1], "end": [439, 71], "kind": "commanddeclaration"}, {"full_name": "measurable_to_countable'", "code": "theorem measurable_to_countable' [MeasurableSpace \u03b1] [Countable \u03b1] [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (h : \u2200 x, MeasurableSet (f \u207b\u00b9' {x})) : Measurable f", "start": [442, 1], "end": [444, 43], "kind": "commanddeclaration"}, {"full_name": "measurable_unit", "code": "@[measurability]\ntheorem measurable_unit [MeasurableSpace \u03b1] (f : Unit \u2192 \u03b1) : Measurable f", "start": [447, 1], "end": [449, 22], "kind": "commanddeclaration"}, {"full_name": "measurable_from_nat", "code": "@[measurability]\ntheorem measurable_from_nat {f : \u2115 \u2192 \u03b1} : Measurable f", "start": [456, 1], "end": [458, 22], "kind": "commanddeclaration"}, {"full_name": "measurable_to_nat", "code": "theorem measurable_to_nat {f : \u03b1 \u2192 \u2115} : (\u2200 y, MeasurableSet (f \u207b\u00b9' {f y})) \u2192 Measurable f", "start": [461, 1], "end": [462, 26], "kind": "commanddeclaration"}, {"full_name": "measurable_to_bool", "code": "theorem measurable_to_bool {f : \u03b1 \u2192 Bool} (h : MeasurableSet (f \u207b\u00b9' {true})) : Measurable f", "start": [465, 1], "end": [470, 10], "kind": "commanddeclaration"}, {"full_name": "measurable_to_prop", "code": "theorem measurable_to_prop {f : \u03b1 \u2192 Prop} (h : MeasurableSet (f \u207b\u00b9' {True})) : Measurable f", "start": [473, 1], "end": [478, 20], "kind": "commanddeclaration"}, {"full_name": "measurable_findGreatest'", "code": "theorem measurable_findGreatest' {p : \u03b1 \u2192 \u2115 \u2192 Prop} [\u2200 x, DecidablePred (p x)] {N : \u2115}\n    (hN : \u2200 k \u2264 N, MeasurableSet { x | Nat.findGreatest (p x) N = k }) :\n    Measurable fun x => Nat.findGreatest (p x) N", "start": [481, 1], "end": [484, 52], "kind": "commanddeclaration"}, {"full_name": "measurable_findGreatest", "code": "theorem measurable_findGreatest {p : \u03b1 \u2192 \u2115 \u2192 Prop} [\u2200 x, DecidablePred (p x)] {N}\n    (hN : \u2200 k \u2264 N, MeasurableSet { x | p x k }) : Measurable fun x => Nat.findGreatest (p x) N", "start": [487, 1], "end": [492, 44], "kind": "commanddeclaration"}, {"full_name": "measurable_find", "code": "theorem measurable_find {p : \u03b1 \u2192 \u2115 \u2192 Prop} [\u2200 x, DecidablePred (p x)] (hp : \u2200 x, \u2203 N, p x N)\n    (hm : \u2200 k, MeasurableSet { x | p x k }) : Measurable fun x => Nat.find (hp x)", "start": [495, 1], "end": [499, 38], "kind": "commanddeclaration"}, {"full_name": "Quot.instMeasurableSpace", "code": "instance Quot.instMeasurableSpace {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [m : MeasurableSpace \u03b1] :\n    MeasurableSpace (Quot r) :=\n  m.map (Quot.mk r)", "start": [508, 1], "end": [510, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.instMeasurableSpace", "code": "instance Quotient.instMeasurableSpace {\u03b1} {s : Setoid \u03b1} [m : MeasurableSpace \u03b1] :\n    MeasurableSpace (Quotient s) :=\n  m.map Quotient.mk''", "start": [513, 1], "end": [515, 22], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.measurableSpace", "code": "@[to_additive]\ninstance QuotientGroup.measurableSpace {G} [Group G] [MeasurableSpace G] (S : Subgroup G) :\n    MeasurableSpace (G \u29f8 S) :=\n  Quotient.instMeasurableSpace", "start": [518, 1], "end": [521, 31], "kind": "commanddeclaration"}, {"full_name": "measurableSet_quotient", "code": "theorem measurableSet_quotient {s : Setoid \u03b1} {t : Set (Quotient s)} :\n    MeasurableSet t \u2194 MeasurableSet (Quotient.mk'' \u207b\u00b9' t)", "start": [525, 1], "end": [527, 10], "kind": "commanddeclaration"}, {"full_name": "measurable_from_quotient", "code": "theorem measurable_from_quotient {s : Setoid \u03b1} {f : Quotient s \u2192 \u03b2} :\n    Measurable f \u2194 Measurable (f \u2218 Quotient.mk'')", "start": [530, 1], "end": [532, 10], "kind": "commanddeclaration"}, {"full_name": "measurable_quotient_mk'", "code": "@[measurability]\ntheorem measurable_quotient_mk' [s : Setoid \u03b1] : Measurable (Quotient.mk' : \u03b1 \u2192 Quotient s)", "start": [535, 1], "end": [537, 14], "kind": "commanddeclaration"}, {"full_name": "measurable_quotient_mk''", "code": "@[measurability]\ntheorem measurable_quotient_mk'' {s : Setoid \u03b1} : Measurable (Quotient.mk'' : \u03b1 \u2192 Quotient s)", "start": [540, 1], "end": [542, 14], "kind": "commanddeclaration"}, {"full_name": "measurable_quot_mk", "code": "@[measurability]\ntheorem measurable_quot_mk {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : Measurable (Quot.mk r)", "start": [545, 1], "end": [546, 86], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.measurable_coe", "code": "@[to_additive (attr := measurability)]\ntheorem QuotientGroup.measurable_coe {G} [Group G] [MeasurableSpace G] {S : Subgroup G} :\n    Measurable ((\u2191) : G \u2192 G \u29f8 S)", "start": [549, 1], "end": [552, 27], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.measurable_from_quotient", "code": "@[to_additive]\nnonrec theorem QuotientGroup.measurable_from_quotient {G} [Group G] [MeasurableSpace G]\n    {S : Subgroup G} {f : G \u29f8 S \u2192 \u03b1} : Measurable f \u2194 Measurable (f \u2218 ((\u2191) : G \u2192 G \u29f8 S))", "start": [556, 1], "end": [559, 27], "kind": "commanddeclaration"}, {"full_name": "Subtype.instMeasurableSpace", "code": "instance Subtype.instMeasurableSpace {\u03b1} {p : \u03b1 \u2192 Prop} [m : MeasurableSpace \u03b1] :\n    MeasurableSpace (Subtype p) :=\n  m.comap ((\u2191) : _ \u2192 \u03b1)", "start": [567, 1], "end": [569, 24], "kind": "commanddeclaration"}, {"full_name": "measurable_subtype_coe", "code": "@[measurability]\ntheorem measurable_subtype_coe {p : \u03b1 \u2192 Prop} : Measurable ((\u2191) : Subtype p \u2192 \u03b1)", "start": [576, 1], "end": [578, 31], "kind": "commanddeclaration"}, {"full_name": "Subtype.instMeasurableSingletonClass", "code": "instance Subtype.instMeasurableSingletonClass {p : \u03b1 \u2192 Prop} [MeasurableSingletonClass \u03b1] :\n    MeasurableSingletonClass (Subtype p) where\n  measurableSet_singleton x :=\n    \u27e8{(x : \u03b1)}, measurableSet_singleton (x : \u03b1), by\n      rw [\u2190 image_singleton, preimage_image_eq _ Subtype.val_injective]\u27e9", "start": [581, 1], "end": [585, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.of_subtype_image", "code": "theorem MeasurableSet.of_subtype_image {s : Set \u03b1} {t : Set s}\n    (h : MeasurableSet (Subtype.val '' t)) : MeasurableSet t", "start": [592, 1], "end": [594, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.subtype_image", "code": "theorem MeasurableSet.subtype_image {s : Set \u03b1} {t : Set s} (hs : MeasurableSet s) :\n    MeasurableSet t \u2192 MeasurableSet (((\u2191) : s \u2192 \u03b1) '' t)", "start": [596, 1], "end": [600, 20], "kind": "commanddeclaration"}, {"full_name": "Measurable.subtype_coe", "code": "@[measurability]\ntheorem Measurable.subtype_coe {p : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 Subtype p} (hf : Measurable f) :\n    Measurable fun a : \u03b1 => (f a : \u03b2)", "start": [603, 1], "end": [606, 33], "kind": "commanddeclaration"}, {"full_name": "Measurable.subtype_val", "code": "alias Measurable.subtype_val := Measurable.subtype_coe", "start": [609, 1], "end": [609, 55], "kind": "stdtacticaliasalias"}, {"full_name": "Measurable.subtype_mk", "code": "@[measurability]\ntheorem Measurable.subtype_mk {p : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) {h : \u2200 x, p (f x)} :\n    Measurable fun x => (\u27e8f x, h x\u27e9 : Subtype p)", "start": [611, 1], "end": [614, 74], "kind": "commanddeclaration"}, {"full_name": "Measurable.rangeFactorization", "code": "@[measurability]\nprotected theorem Measurable.rangeFactorization {f : \u03b1 \u2192 \u03b2} (hf : Measurable f) :\n    Measurable (rangeFactorization f)", "start": [617, 1], "end": [620, 16], "kind": "commanddeclaration"}, {"full_name": "Measurable.subtype_map", "code": "theorem Measurable.subtype_map {f : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (hf : Measurable f)\n    (hpq : \u2200 x, p x \u2192 q (f x)) : Measurable (Subtype.map f hpq)", "start": [622, 1], "end": [624, 46], "kind": "commanddeclaration"}, {"full_name": "measurable_inclusion", "code": "theorem measurable_inclusion {s t : Set \u03b1} (h : s \u2286 t) : Measurable (inclusion h)", "start": [626, 1], "end": [627, 30], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.image_inclusion'", "code": "theorem MeasurableSet.image_inclusion' {s t : Set \u03b1} (h : s \u2286 t) {u : Set s}\n    (hs : MeasurableSet (Subtype.val \u207b\u00b9' s : Set t)) (hu : MeasurableSet u) :\n    MeasurableSet (inclusion h '' u)", "start": [629, 1], "end": [635, 45], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.image_inclusion", "code": "theorem MeasurableSet.image_inclusion {s t : Set \u03b1} (h : s \u2286 t) {u : Set s}\n    (hs : MeasurableSet s) (hu : MeasurableSet u) :\n    MeasurableSet (inclusion h '' u)", "start": [637, 1], "end": [640, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.of_union_cover", "code": "theorem MeasurableSet.of_union_cover {s t u : Set \u03b1} (hs : MeasurableSet s) (ht : MeasurableSet t)\n    (h : univ \u2286 s \u222a t) (hsu : MeasurableSet (((\u2191) : s \u2192 \u03b1) \u207b\u00b9' u))\n    (htu : MeasurableSet (((\u2191) : t \u2192 \u03b1) \u207b\u00b9' u)) : MeasurableSet u", "start": [642, 1], "end": [646, 82], "kind": "commanddeclaration"}, {"full_name": "measurable_of_measurable_union_cover", "code": "theorem measurable_of_measurable_union_cover {f : \u03b1 \u2192 \u03b2} (s t : Set \u03b1) (hs : MeasurableSet s)\n    (ht : MeasurableSet t) (h : univ \u2286 s \u222a t) (hc : Measurable fun a : s => f a)\n    (hd : Measurable fun a : t => f a) : Measurable f", "start": [648, 1], "end": [651, 42], "kind": "commanddeclaration"}, {"full_name": "measurable_of_restrict_of_restrict_compl", "code": "theorem measurable_of_restrict_of_restrict_compl {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : MeasurableSet s)\n    (h\u2081 : Measurable (s.restrict f)) (h\u2082 : Measurable (s\u1d9c.restrict f)) : Measurable f", "start": [654, 1], "end": [656, 86], "kind": "commanddeclaration"}, {"full_name": "Measurable.dite", "code": "theorem Measurable.dite [\u2200 x, Decidable (x \u2208 s)] {f : s \u2192 \u03b2} (hf : Measurable f)\n    {g : (s\u1d9c : Set \u03b1) \u2192 \u03b2} (hg : Measurable g) (hs : MeasurableSet s) :\n    Measurable fun x => if hx : x \u2208 s then f \u27e8x, hx\u27e9 else g \u27e8x, hx\u27e9", "start": [659, 1], "end": [662, 68], "kind": "commanddeclaration"}, {"full_name": "measurable_of_measurable_on_compl_finite", "code": "theorem measurable_of_measurable_on_compl_finite [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (s : Set \u03b1) (hs : s.Finite) (hf : Measurable (s\u1d9c.restrict f)) : Measurable f", "start": [665, 1], "end": [668, 88], "kind": "commanddeclaration"}, {"full_name": "measurable_of_measurable_on_compl_singleton", "code": "theorem measurable_of_measurable_on_compl_singleton [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 \u03b2} (a : \u03b1)\n    (hf : Measurable ({ x | x \u2260 a }.restrict f)) : Measurable f", "start": [671, 1], "end": [673, 71], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.prod", "code": "def MeasurableSpace.prod {\u03b1 \u03b2} (m\u2081 : MeasurableSpace \u03b1) (m\u2082 : MeasurableSpace \u03b2) :\n    MeasurableSpace (\u03b1 \u00d7 \u03b2) :=\n  m\u2081.comap Prod.fst \u2294 m\u2082.comap Prod.snd", "start": [680, 1], "end": [683, 40], "kind": "commanddeclaration"}, {"full_name": "Prod.instMeasurableSpace", "code": "instance Prod.instMeasurableSpace {\u03b1 \u03b2} [m\u2081 : MeasurableSpace \u03b1] [m\u2082 : MeasurableSpace \u03b2] :\n    MeasurableSpace (\u03b1 \u00d7 \u03b2) :=\n  m\u2081.prod m\u2082", "start": [686, 1], "end": [688, 13], "kind": "commanddeclaration"}, {"full_name": "measurable_fst", "code": "@[measurability]\ntheorem measurable_fst {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2} :\n    Measurable (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1)", "start": [691, 1], "end": [694, 37], "kind": "commanddeclaration"}, {"full_name": "measurable_snd", "code": "@[measurability]\ntheorem measurable_snd {_ : MeasurableSpace \u03b1} {_ : MeasurableSpace \u03b2} :\n    Measurable (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2)", "start": [697, 1], "end": [700, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.fst", "code": "theorem Measurable.fst {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf : Measurable f) : Measurable fun a : \u03b1 => (f a).1", "start": [705, 1], "end": [706, 25], "kind": "commanddeclaration"}, {"full_name": "Measurable.snd", "code": "theorem Measurable.snd {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf : Measurable f) : Measurable fun a : \u03b1 => (f a).2", "start": [709, 1], "end": [710, 25], "kind": "commanddeclaration"}, {"full_name": "Measurable.prod", "code": "@[measurability]\ntheorem Measurable.prod {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf\u2081 : Measurable fun a => (f a).1)\n    (hf\u2082 : Measurable fun a => (f a).2) : Measurable f", "start": [713, 1], "end": [723, 19], "kind": "commanddeclaration"}, {"full_name": "Measurable.prod_mk", "code": "theorem Measurable.prod_mk {\u03b2 \u03b3} {_ : MeasurableSpace \u03b2} {_ : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b2}\n    {g : \u03b1 \u2192 \u03b3} (hf : Measurable f) (hg : Measurable g) : Measurable fun a : \u03b1 => (f a, g a)", "start": [726, 1], "end": [728, 24], "kind": "commanddeclaration"}, {"full_name": "Measurable.prod_map", "code": "theorem Measurable.prod_map [MeasurableSpace \u03b4] {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Measurable f)\n    (hg : Measurable g) : Measurable (Prod.map f g)", "start": [731, 1], "end": [733, 60], "kind": "commanddeclaration"}, {"full_name": "measurable_prod_mk_left", "code": "theorem measurable_prod_mk_left {x : \u03b1} : Measurable (@Prod.mk _ \u03b2 x)", "start": [736, 1], "end": [737, 41], "kind": "commanddeclaration"}, {"full_name": "measurable_prod_mk_right", "code": "theorem measurable_prod_mk_right {y : \u03b2} : Measurable fun x : \u03b1 => (x, y)", "start": [740, 1], "end": [741, 41], "kind": "commanddeclaration"}, {"full_name": "Measurable.of_uncurry_left", "code": "theorem Measurable.of_uncurry_left {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : Measurable (uncurry f)) {x : \u03b1} :\n    Measurable (f x)", "start": [744, 1], "end": [746, 34], "kind": "commanddeclaration"}, {"full_name": "Measurable.of_uncurry_right", "code": "theorem Measurable.of_uncurry_right {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : Measurable (uncurry f)) {y : \u03b2} :\n    Measurable fun x => f x y", "start": [749, 1], "end": [751, 35], "kind": "commanddeclaration"}, {"full_name": "measurable_prod", "code": "theorem measurable_prod {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} :\n    Measurable f \u2194 (Measurable fun a => (f a).1) \u2227 Measurable fun a => (f a).2", "start": [754, 1], "end": [756, 97], "kind": "commanddeclaration"}, {"full_name": "measurable_swap", "code": "@[measurability]\ntheorem measurable_swap : Measurable (Prod.swap : \u03b1 \u00d7 \u03b2 \u2192 \u03b2 \u00d7 \u03b1)", "start": [759, 1], "end": [761, 48], "kind": "commanddeclaration"}, {"full_name": "measurable_swap_iff", "code": "theorem measurable_swap_iff {_ : MeasurableSpace \u03b3} {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} :\n    Measurable (f \u2218 Prod.swap) \u2194 Measurable f", "start": [764, 1], "end": [766, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.prod", "code": "@[measurability]\nprotected theorem MeasurableSet.prod {s : Set \u03b1} {t : Set \u03b2} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) : MeasurableSet (s \u00d7\u02e2 t)", "start": [769, 1], "end": [772, 62], "kind": "commanddeclaration"}, {"full_name": "measurableSet_prod_of_nonempty", "code": "theorem measurableSet_prod_of_nonempty {s : Set \u03b1} {t : Set \u03b2} (h : (s \u00d7\u02e2 t).Nonempty) :\n    MeasurableSet (s \u00d7\u02e2 t) \u2194 MeasurableSet s \u2227 MeasurableSet t", "start": [775, 1], "end": [781, 11], "kind": "commanddeclaration"}, {"full_name": "measurableSet_prod", "code": "theorem measurableSet_prod {s : Set \u03b1} {t : Set \u03b2} :\n    MeasurableSet (s \u00d7\u02e2 t) \u2194 MeasurableSet s \u2227 MeasurableSet t \u2228 s = \u2205 \u2228 t = \u2205", "start": [784, 1], "end": [788, 97], "kind": "commanddeclaration"}, {"full_name": "measurableSet_swap_iff", "code": "theorem measurableSet_swap_iff {s : Set (\u03b1 \u00d7 \u03b2)} :\n    MeasurableSet (Prod.swap \u207b\u00b9' s) \u2194 MeasurableSet s", "start": [791, 1], "end": [793, 63], "kind": "commanddeclaration"}, {"full_name": "Prod.instMeasurableSingletonClass", "code": "instance Prod.instMeasurableSingletonClass\n    [MeasurableSingletonClass \u03b1] [MeasurableSingletonClass \u03b2] :\n    MeasurableSingletonClass (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun \u27e8a, b\u27e9 => @singleton_prod_singleton _ _ a b \u25b8 .prod (.singleton a) (.singleton b)\u27e9", "start": [796, 1], "end": [799, 90], "kind": "commanddeclaration"}, {"full_name": "measurable_from_prod_countable", "code": "theorem measurable_from_prod_countable [Countable \u03b2] [MeasurableSingletonClass \u03b2]\n    {_ : MeasurableSpace \u03b3} {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (hf : \u2200 y, Measurable fun x => f (x, y)) :\n    Measurable f", "start": [802, 1], "end": [809, 55], "kind": "commanddeclaration"}, {"full_name": "Measurable.find", "code": "@[measurability]\ntheorem Measurable.find {_ : MeasurableSpace \u03b1} {f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {p : \u2115 \u2192 \u03b1 \u2192 Prop}\n    [\u2200 n, DecidablePred (p n)] (hf : \u2200 n, Measurable (f n)) (hp : \u2200 n, MeasurableSet { x | p n x })\n    (h : \u2200 x, \u2203 n, p n x) : Measurable fun x => f (Nat.find (h x)) x", "start": [812, 1], "end": [818, 70], "kind": "commanddeclaration"}, {"full_name": "measurable_iUnionLift", "code": "theorem measurable_iUnionLift [Countable \u03b9] {t : \u03b9 \u2192 Set \u03b1} {f : \u2200 i, t i \u2192 \u03b2}\n    (htf : \u2200 (i j) (x : \u03b1) (hxi : x \u2208 t i) (hxj : x \u2208 t j), f i \u27e8x, hxi\u27e9 = f j \u27e8x, hxj\u27e9)\n    {T : Set \u03b1} (hT : T \u2286 \u22c3 i, t i) (htm : \u2200 i, MeasurableSet (t i)) (hfm : \u2200 i, Measurable (f i)) :\n    Measurable (iUnionLift t f htf T hT)", "start": [821, 1], "end": [829, 100], "kind": "commanddeclaration"}, {"full_name": "measurable_liftCover", "code": "theorem measurable_liftCover [Countable \u03b9] (t : \u03b9 \u2192 Set \u03b1) (htm : \u2200 i, MeasurableSet (t i))\n    (f : \u2200 i, t i \u2192 \u03b2) (hfm : \u2200 i, Measurable (f i))\n    (hf : \u2200 (i j) (x : \u03b1) (hxi : x \u2208 t i) (hxj : x \u2208 t j), f i \u27e8x, hxi\u27e9 = f j \u27e8x, hxj\u27e9)\n    (htU : \u22c3 i, t i = univ) :\n    Measurable (liftCover t f hf htU)", "start": [831, 1], "end": [840, 60], "kind": "commanddeclaration"}, {"full_name": "exists_measurable_piecewise", "code": "theorem exists_measurable_piecewise {\u03b9} [Countable \u03b9] [Nonempty \u03b9] (t : \u03b9 \u2192 Set \u03b1)\n    (t_meas : \u2200 n, MeasurableSet (t n)) (g : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (hg : \u2200 n, Measurable (g n))\n    (ht : Pairwise fun i j => EqOn (g i) (g j) (t i \u2229 t j)) :\n    \u2203 f : \u03b1 \u2192 \u03b2, Measurable f \u2227 \u2200 n, EqOn f (g n) (t n)", "start": [842, 1], "end": [866, 57], "kind": "commanddeclaration"}, {"full_name": "exists_measurable_piecewise_nat", "code": "@[deprecated exists_measurable_piecewise]\ntheorem exists_measurable_piecewise_nat {m : MeasurableSpace \u03b1} (t : \u2115 \u2192 Set \u03b2)\n    (t_meas : \u2200 n, MeasurableSet (t n)) (t_disj : Pairwise (Disjoint on t)) (g : \u2115 \u2192 \u03b2 \u2192 \u03b1)\n    (hg : \u2200 n, Measurable (g n)) : \u2203 f : \u03b2 \u2192 \u03b1, Measurable f \u2227 \u2200 n x, x \u2208 t n \u2192 f x = g n x", "start": [868, 1], "end": [875, 39], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.pi", "code": "instance MeasurableSpace.pi [m : \u2200 a, MeasurableSpace (\u03c0 a)] : MeasurableSpace (\u2200 a, \u03c0 a) :=\n  \u2a06 a, (m a).comap fun b => b a", "start": [884, 1], "end": [885, 32], "kind": "commanddeclaration"}, {"full_name": "measurable_pi_iff", "code": "theorem measurable_pi_iff {g : \u03b1 \u2192 \u2200 a, \u03c0 a} : Measurable g \u2194 \u2200 a, Measurable fun x => g x a", "start": [890, 1], "end": [892, 60], "kind": "commanddeclaration"}, {"full_name": "measurable_pi_apply", "code": "@[aesop safe 100 apply (rule_sets [Measurable])]\ntheorem measurable_pi_apply (a : \u03b4) : Measurable fun f : \u2200 a, \u03c0 a => f a", "start": [895, 1], "end": [897, 38], "kind": "commanddeclaration"}, {"full_name": "Measurable.eval", "code": "@[aesop safe 100 apply (rule_sets [Measurable])]\ntheorem Measurable.eval {a : \u03b4} {g : \u03b1 \u2192 \u2200 a, \u03c0 a} (hg : Measurable g) :\n    Measurable fun x => g x a", "start": [900, 1], "end": [903, 34], "kind": "commanddeclaration"}, {"full_name": "measurable_pi_lambda", "code": "@[aesop safe 100 apply (rule_sets [Measurable])]\ntheorem measurable_pi_lambda (f : \u03b1 \u2192 \u2200 a, \u03c0 a) (hf : \u2200 a, Measurable fun c => f c a) :\n    Measurable f", "start": [906, 1], "end": [909, 27], "kind": "commanddeclaration"}, {"full_name": "measurable_update'", "code": "theorem measurable_update'  {a : \u03b4} [DecidableEq \u03b4] :\n    Measurable (fun p : (\u2200 i, \u03c0 i) \u00d7 \u03c0 a \u21a6 update p.1 a p.2)", "start": [912, 1], "end": [922, 47], "kind": "commanddeclaration"}, {"full_name": "measurable_update", "code": "@[measurability]\ntheorem measurable_update (f : \u2200 a : \u03b4, \u03c0 a) {a : \u03b4} [DecidableEq \u03b4] : Measurable (update f a)", "start": [924, 1], "end": [929, 50], "kind": "commanddeclaration"}, {"full_name": "measurable_update_left", "code": "theorem measurable_update_left {a : \u03b4} [DecidableEq \u03b4] {x : \u03c0 a} :\n    Measurable (update \u00b7 a x)", "start": [932, 1], "end": [934, 51], "kind": "commanddeclaration"}, {"full_name": "measurable_eq_mp", "code": "theorem measurable_eq_mp {i i' : \u03b4} (h : i = i') : Measurable (congr_arg \u03c0 h).mp", "start": [937, 1], "end": [939, 22], "kind": "commanddeclaration"}, {"full_name": "Measurable.eq_mp", "code": "theorem Measurable.eq_mp {\u03b2} [MeasurableSpace \u03b2] {i i' : \u03b4} (h : i = i') {f : \u03b2 \u2192 \u03c0 i}\n    (hf : Measurable f) : Measurable fun x => (congr_arg \u03c0 h).mp (f x)", "start": [942, 1], "end": [944, 33], "kind": "commanddeclaration"}, {"full_name": "measurable_piCongrLeft", "code": "theorem measurable_piCongrLeft (f : \u03b4' \u2243 \u03b4) : Measurable (piCongrLeft \u03c0 f)", "start": [946, 1], "end": [950, 85], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.pi", "code": "@[measurability]\nprotected theorem MeasurableSet.pi {s : Set \u03b4} {t : \u2200 i : \u03b4, Set (\u03c0 i)} (hs : s.Countable)\n    (ht : \u2200 i \u2208 s, MeasurableSet (t i)) : MeasurableSet (s.pi t)", "start": [954, 1], "end": [958, 77], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.univ_pi", "code": "protected theorem MeasurableSet.univ_pi [Countable \u03b4] {t : \u2200 i : \u03b4, Set (\u03c0 i)}\n    (ht : \u2200 i, MeasurableSet (t i)) : MeasurableSet (pi univ t)", "start": [961, 1], "end": [963, 52], "kind": "commanddeclaration"}, {"full_name": "measurableSet_pi_of_nonempty", "code": "theorem measurableSet_pi_of_nonempty {s : Set \u03b4} {t : \u2200 i, Set (\u03c0 i)} (hs : s.Countable)\n    (h : (pi s t).Nonempty) : MeasurableSet (pi s t) \u2194 \u2200 i \u2208 s, MeasurableSet (t i)", "start": [966, 1], "end": [973, 32], "kind": "commanddeclaration"}, {"full_name": "measurableSet_pi", "code": "theorem measurableSet_pi {s : Set \u03b4} {t : \u2200 i, Set (\u03c0 i)} (hs : s.Countable) :\n    MeasurableSet (pi s t) \u2194 (\u2200 i \u2208 s, MeasurableSet (t i)) \u2228 pi s t = \u2205", "start": [976, 1], "end": [980, 75], "kind": "commanddeclaration"}, {"full_name": "Pi.instMeasurableSingletonClass", "code": "instance Pi.instMeasurableSingletonClass [Countable \u03b4] [\u2200 a, MeasurableSingletonClass (\u03c0 a)] :\n    MeasurableSingletonClass (\u2200 a, \u03c0 a) :=\n  \u27e8fun f => univ_pi_singleton f \u25b8 MeasurableSet.univ_pi fun t => measurableSet_singleton (f t)\u27e9", "start": [983, 1], "end": [985, 96], "kind": "commanddeclaration"}, {"full_name": "measurable_piEquivPiSubtypeProd_symm", "code": "@[measurability]\ntheorem measurable_piEquivPiSubtypeProd_symm (p : \u03b4 \u2192 Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p \u03c0).symm", "start": [990, 1], "end": [1002, 46], "kind": "commanddeclaration"}, {"full_name": "measurable_piEquivPiSubtypeProd", "code": "@[measurability]\ntheorem measurable_piEquivPiSubtypeProd (p : \u03b4 \u2192 Prop) [DecidablePred p] :\n    Measurable (Equiv.piEquivPiSubtypeProd p \u03c0)", "start": [1005, 1], "end": [1009, 57], "kind": "commanddeclaration"}, {"full_name": "TProd.instMeasurableSpace", "code": "instance TProd.instMeasurableSpace (\u03c0 : \u03b4 \u2192 Type*) [\u2200 x, MeasurableSpace (\u03c0 x)] :\n    \u2200 l : List \u03b4, MeasurableSpace (List.TProd \u03c0 l)\n  | [] => PUnit.instMeasurableSpace\n  | _::is => @Prod.instMeasurableSpace _ _ _ (TProd.instMeasurableSpace \u03c0 is)", "start": [1014, 1], "end": [1017, 78], "kind": "commanddeclaration"}, {"full_name": "measurable_tProd_mk", "code": "theorem measurable_tProd_mk (l : List \u03b4) : Measurable (@TProd.mk \u03b4 \u03c0 l)", "start": [1026, 1], "end": [1029, 45], "kind": "commanddeclaration"}, {"full_name": "measurable_tProd_elim", "code": "theorem measurable_tProd_elim [DecidableEq \u03b4] :\n    \u2200 {l : List \u03b4} {i : \u03b4} (hi : i \u2208 l), Measurable fun v : TProd \u03c0 l => v.elim hi", "start": [1032, 1], "end": [1040, 78], "kind": "commanddeclaration"}, {"full_name": "measurable_tProd_elim'", "code": "theorem measurable_tProd_elim' [DecidableEq \u03b4] {l : List \u03b4} (h : \u2200 i, i \u2208 l) :\n    Measurable (TProd.elim' h : TProd \u03c0 l \u2192 \u2200 i, \u03c0 i)", "start": [1043, 1], "end": [1045, 62], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.tProd", "code": "theorem MeasurableSet.tProd (l : List \u03b4) {s : \u2200 i, Set (\u03c0 i)} (hs : \u2200 i, MeasurableSet (s i)) :\n    MeasurableSet (Set.tprod l s)", "start": [1048, 1], "end": [1052, 23], "kind": "commanddeclaration"}, {"full_name": "Sum.instMeasurableSpace", "code": "instance Sum.instMeasurableSpace {\u03b1 \u03b2} [m\u2081 : MeasurableSpace \u03b1] [m\u2082 : MeasurableSpace \u03b2] :\n    MeasurableSpace (\u03b1 \u2295 \u03b2) :=\n  m\u2081.map Sum.inl \u2293 m\u2082.map Sum.inr", "start": [1057, 1], "end": [1059, 34], "kind": "commanddeclaration"}, {"full_name": "measurable_inl", "code": "@[measurability]\ntheorem measurable_inl [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] : Measurable (@Sum.inl \u03b1 \u03b2)", "start": [1064, 1], "end": [1066, 35], "kind": "commanddeclaration"}, {"full_name": "measurable_inr", "code": "@[measurability]\ntheorem measurable_inr [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] : Measurable (@Sum.inr \u03b1 \u03b2)", "start": [1069, 1], "end": [1071, 36], "kind": "commanddeclaration"}, {"full_name": "measurableSet_sum_iff", "code": "theorem measurableSet_sum_iff {s : Set (\u03b1 \u2295 \u03b2)} :\n    MeasurableSet s \u2194 MeasurableSet (Sum.inl \u207b\u00b9' s) \u2227 MeasurableSet (Sum.inr \u207b\u00b9' s)", "start": [1077, 1], "end": [1079, 10], "kind": "commanddeclaration"}, {"full_name": "measurable_sum", "code": "theorem measurable_sum {_ : MeasurableSpace \u03b3} {f : \u03b1 \u2295 \u03b2 \u2192 \u03b3} (hl : Measurable (f \u2218 Sum.inl))\n    (hr : Measurable (f \u2218 Sum.inr)) : Measurable f", "start": [1081, 1], "end": [1085, 52], "kind": "commanddeclaration"}, {"full_name": "Measurable.sumElim", "code": "@[measurability]\ntheorem Measurable.sumElim {_ : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (hf : Measurable f)\n    (hg : Measurable g) : Measurable (Sum.elim f g)", "start": [1088, 1], "end": [1091, 23], "kind": "commanddeclaration"}, {"full_name": "Measurable.sumMap", "code": "theorem Measurable.sumMap {_ : MeasurableSpace \u03b3} {_ : MeasurableSpace \u03b4} {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4}\n    (hf : Measurable f) (hg : Measurable g) : Measurable (Sum.map f g)", "start": [1094, 1], "end": [1096, 60], "kind": "commanddeclaration"}, {"full_name": "measurableSet_inl_image", "code": "@[simp] theorem measurableSet_inl_image {s : Set \u03b1} :\n    MeasurableSet (Sum.inl '' s : Set (\u03b1 \u2295 \u03b2)) \u2194 MeasurableSet s", "start": [1099, 1], "end": [1101, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.inl_image", "code": "alias \u27e8_, MeasurableSet.inl_image\u27e9 := measurableSet_inl_image", "start": [1103, 1], "end": [1103, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "measurableSet_inr_image", "code": "@[simp] theorem measurableSet_inr_image {s : Set \u03b2} :\n    MeasurableSet (Sum.inr '' s : Set (\u03b1 \u2295 \u03b2)) \u2194 MeasurableSet s", "start": [1107, 1], "end": [1109, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.inr_image", "code": "alias \u27e8_, MeasurableSet.inr_image\u27e9 := measurableSet_inr_image", "start": [1111, 1], "end": [1111, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "measurableSet_range_inl", "code": "theorem measurableSet_range_inl [MeasurableSpace \u03b1] :\n    MeasurableSet (range Sum.inl : Set (\u03b1 \u2295 \u03b2))", "start": [1114, 1], "end": [1117, 37], "kind": "commanddeclaration"}, {"full_name": "measurableSet_range_inr", "code": "theorem measurableSet_range_inr [MeasurableSpace \u03b1] :\n    MeasurableSet (range Sum.inr : Set (\u03b1 \u2295 \u03b2))", "start": [1120, 1], "end": [1123, 37], "kind": "commanddeclaration"}, {"full_name": "Sigma.instMeasurableSpace", "code": "instance Sigma.instMeasurableSpace {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} [m : \u2200 a, MeasurableSpace (\u03b2 a)] :\n    MeasurableSpace (Sigma \u03b2) :=\n  \u2a05 a, (m a).map (Sigma.mk a)", "start": [1128, 1], "end": [1130, 30], "kind": "commanddeclaration"}, {"full_name": "measurableSet_setOf", "code": "@[simp] theorem measurableSet_setOf : MeasurableSet {a | p a} \u2194 Measurable p", "start": [1136, 1], "end": [1138, 50], "kind": "commanddeclaration"}, {"full_name": "measurable_mem", "code": "@[simp] theorem measurable_mem : Measurable (\u00b7 \u2208 s) \u2194 MeasurableSet s", "start": [1141, 1], "end": [1141, 98], "kind": "commanddeclaration"}, {"full_name": "Measurable.setOf", "code": "alias \u27e8_, Measurable.setOf\u27e9 := measurableSet_setOf", "start": [1144, 1], "end": [1144, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasurableSet.mem", "code": "alias \u27e8_, MeasurableSet.mem\u27e9 := measurable_mem", "start": [1147, 1], "end": [1147, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MeasurableSpace.generateFrom_singleton", "code": "@[simp] theorem generateFrom_singleton (s : Set \u03b1) :\n    generateFrom {s} = MeasurableSpace.comap (\u00b7 \u2208 s) \u22a4", "start": [1155, 1], "end": [1162, 94], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding", "code": "structure MeasurableEmbedding {\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  protected injective : Injective f\n  \n  protected measurable : Measurable f\n  \n  protected measurableSet_image' : \u2200 \u2983s\u2984, MeasurableSet s \u2192 MeasurableSet (f '' s)", "start": [1167, 1], "end": [1185, 83], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurableSet_image", "code": "theorem measurableSet_image (hf : MeasurableEmbedding f) {s : Set \u03b1} :\n    MeasurableSet (f '' s) \u2194 MeasurableSet s", "start": [1192, 1], "end": [1195, 31], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.id", "code": "theorem id : MeasurableEmbedding (id : \u03b1 \u2192 \u03b1)", "start": [1198, 1], "end": [1199, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.comp", "code": "theorem comp (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) :\n    MeasurableEmbedding (g \u2218 f)", "start": [1202, 1], "end": [1205, 70], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.subtype_coe", "code": "theorem subtype_coe {s : Set \u03b1} (hs : MeasurableSet s) : MeasurableEmbedding ((\u2191) : s \u2192 \u03b1) where", "start": [1208, 1], "end": [1211, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurableSet_range", "code": "theorem measurableSet_range (hf : MeasurableEmbedding f) : MeasurableSet (range f)", "start": [1214, 1], "end": [1216, 51], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurableSet_preimage", "code": "theorem measurableSet_preimage (hf : MeasurableEmbedding f) {s : Set \u03b2} :\n    MeasurableSet (f \u207b\u00b9' s) \u2194 MeasurableSet (s \u2229 range f)", "start": [1219, 1], "end": [1221, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurable_rangeSplitting", "code": "theorem measurable_rangeSplitting (hf : MeasurableEmbedding f) :\n    Measurable (rangeSplitting f)", "start": [1224, 1], "end": [1228, 57], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurable_extend", "code": "theorem measurable_extend (hf : MeasurableEmbedding f) {g : \u03b1 \u2192 \u03b3} {g' : \u03b2 \u2192 \u03b3} (hg : Measurable g)\n    (hg' : Measurable g') : Measurable (extend f g g')", "start": [1231, 1], "end": [1237, 42], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.exists_measurable_extend", "code": "theorem exists_measurable_extend (hf : MeasurableEmbedding f) {g : \u03b1 \u2192 \u03b3} (hg : Measurable g)\n    (hne : \u03b2 \u2192 Nonempty \u03b3) : \u2203 g' : \u03b2 \u2192 \u03b3, Measurable g' \u2227 g' \u2218 f = g", "start": [1240, 1], "end": [1244, 53], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.measurable_comp_iff", "code": "theorem measurable_comp_iff (hg : MeasurableEmbedding g) : Measurable (g \u2218 f) \u2194 Measurable f", "start": [1247, 1], "end": [1251, 55], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.exists_measurable_proj", "code": "theorem MeasurableSet.exists_measurable_proj {_ : MeasurableSpace \u03b1} {s : Set \u03b1}\n    (hs : MeasurableSet s) (hne : s.Nonempty) : \u2203 f : \u03b1 \u2192 s, Measurable f \u2227 \u2200 x : s, f x = x", "start": [1256, 1], "end": [1261, 25], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv", "code": "structure MeasurableEquiv (\u03b1 \u03b2 : Type*) [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] extends \u03b1 \u2243 \u03b2 where\n  \n  measurable_toFun : Measurable toEquiv\n  \n  measurable_invFun : Measurable toEquiv.symm", "start": [1264, 1], "end": [1270, 46], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Injective (toEquiv : \u03b1 \u2243\u1d50 \u03b2 \u2192 \u03b1 \u2243 \u03b2)", "start": [1280, 1], "end": [1282, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.instEquivLike", "code": "instance instEquivLike : EquivLike (\u03b1 \u2243\u1d50 \u03b2) \u03b1 \u03b2 where\n  coe e := e.toEquiv\n  inv e := e.toEquiv.symm\n  left_inv e := e.toEquiv.left_inv\n  right_inv e := e.toEquiv.right_inv\n  coe_injective' _ _ he _ := toEquiv_injective <| FunLike.ext' he", "start": [1285, 1], "end": [1290, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (e : \u03b1 \u2243\u1d50 \u03b2) : (e.toEquiv : \u03b1 \u2192 \u03b2) = e", "start": [1292, 1], "end": [1294, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.measurable", "code": "@[measurability]\nprotected theorem measurable (e : \u03b1 \u2243\u1d50 \u03b2) : Measurable (e : \u03b1 \u2192 \u03b2)", "start": [1297, 1], "end": [1299, 21], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (e : \u03b1 \u2243 \u03b2) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    ((\u27e8e, h1, h2\u27e9 : \u03b1 \u2243\u1d50 \u03b2) : \u03b1 \u2192 \u03b2) = e", "start": [1302, 1], "end": [1305, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.refl", "code": "def refl (\u03b1 : Type*) [MeasurableSpace \u03b1] : \u03b1 \u2243\u1d50 \u03b1 where\n  toEquiv := Equiv.refl \u03b1\n  measurable_toFun := measurable_id\n  measurable_invFun := measurable_id", "start": [1308, 1], "end": [1312, 37], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.instInhabited", "code": "instance instInhabited : Inhabited (\u03b1 \u2243\u1d50 \u03b1) := \u27e8refl \u03b1\u27e9", "start": [1315, 1], "end": [1315, 56], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.trans", "code": "def trans (ab : \u03b1 \u2243\u1d50 \u03b2) (bc : \u03b2 \u2243\u1d50 \u03b3) : \u03b1 \u2243\u1d50 \u03b3 where\n  toEquiv := ab.toEquiv.trans bc.toEquiv\n  measurable_toFun := bc.measurable_toFun.comp ab.measurable_toFun\n  measurable_invFun := ab.measurable_invFun.comp bc.measurable_invFun", "start": [1317, 1], "end": [1321, 70], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm", "code": "def symm (ab : \u03b1 \u2243\u1d50 \u03b2) : \u03b2 \u2243\u1d50 \u03b1 where\n  toEquiv := ab.toEquiv.symm\n  measurable_toFun := ab.measurable_invFun\n  measurable_invFun := ab.measurable_toFun", "start": [1324, 1], "end": [1328, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_toEquiv_symm", "code": "@[simp]\ntheorem coe_toEquiv_symm (e : \u03b1 \u2243\u1d50 \u03b2) : (e.toEquiv.symm : \u03b2 \u2192 \u03b1) = e.symm", "start": [1331, 1], "end": [1333, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Simps.apply", "code": "def Simps.apply (h : \u03b1 \u2243\u1d50 \u03b2) : \u03b1 \u2192 \u03b2 := h", "start": [1336, 1], "end": [1338, 42], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (h : \u03b1 \u2243\u1d50 \u03b2) : \u03b2 \u2192 \u03b1 := h.symm", "start": [1341, 1], "end": [1342, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ext", "code": "@[ext] theorem ext {e\u2081 e\u2082 : \u03b1 \u2243\u1d50 \u03b2} (h : (e\u2081 : \u03b1 \u2192 \u03b2) = e\u2082) : e\u2081 = e\u2082", "start": [1347, 1], "end": [1347, 88], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_mk", "code": "@[simp]\ntheorem symm_mk (e : \u03b1 \u2243 \u03b2) (h1 : Measurable e) (h2 : Measurable e.symm) :\n    (\u27e8e, h1, h2\u27e9 : \u03b1 \u2243\u1d50 \u03b2).symm = \u27e8e.symm, h2, h1\u27e9", "start": [1350, 1], "end": [1353, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : \u03b1 \u2243\u1d50 \u03b2) : e.symm.symm = e", "start": [1358, 1], "end": [1359, 56], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_refl", "code": "@[simp]\ntheorem symm_refl (\u03b1 : Type*) [MeasurableSpace \u03b1] : (refl \u03b1).symm = refl \u03b1", "start": [1361, 1], "end": [1363, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_comp_self", "code": "@[simp]\ntheorem symm_comp_self (e : \u03b1 \u2243\u1d50 \u03b2) : e.symm \u2218 e = id", "start": [1366, 1], "end": [1368, 20], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.self_comp_symm", "code": "@[simp]\ntheorem self_comp_symm (e : \u03b1 \u2243\u1d50 \u03b2) : e \u2218 e.symm = id", "start": [1371, 1], "end": [1373, 21], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : \u03b1 \u2243\u1d50 \u03b2) (y : \u03b2) : e (e.symm y) = y", "start": [1376, 1], "end": [1378, 16], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : \u03b1 \u2243\u1d50 \u03b2) (x : \u03b1) : e.symm (e x) = x", "start": [1381, 1], "end": [1383, 15], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : \u03b1 \u2243\u1d50 \u03b2) : e.symm.trans e = refl \u03b2", "start": [1386, 1], "end": [1388, 23], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : \u03b1 \u2243\u1d50 \u03b2) : e.trans e.symm = refl \u03b1", "start": [1391, 1], "end": [1393, 23], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.surjective", "code": "protected theorem surjective (e : \u03b1 \u2243\u1d50 \u03b2) : Surjective e", "start": [1396, 1], "end": [1397, 23], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.bijective", "code": "protected theorem bijective (e : \u03b1 \u2243\u1d50 \u03b2) : Bijective e", "start": [1400, 1], "end": [1401, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.injective", "code": "protected theorem injective (e : \u03b1 \u2243\u1d50 \u03b2) : Injective e", "start": [1404, 1], "end": [1405, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.symm_preimage_preimage", "code": "@[simp]\ntheorem symm_preimage_preimage (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) : e.symm \u207b\u00b9' (e \u207b\u00b9' s) = s", "start": [1408, 1], "end": [1410, 37], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.image_eq_preimage", "code": "theorem image_eq_preimage (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b1) : e '' s = e.symm \u207b\u00b9' s", "start": [1413, 1], "end": [1414, 32], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.preimage_symm", "code": "lemma preimage_symm (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b1) : e.symm \u207b\u00b9' s = e '' s := (image_eq_preimage _ _).symm", "start": [1417, 1], "end": [1417, 101], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.image_symm", "code": "lemma image_symm (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) : e.symm '' s = e \u207b\u00b9' s := by\n  rw [\u2190 symm_symm e, preimage_symm, symm_symm]", "start": [1419, 1], "end": [1420, 47], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.eq_image_iff_symm_image_eq", "code": "lemma eq_image_iff_symm_image_eq (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) (t : Set \u03b1) :\n    s = e '' t \u2194 e.symm '' s = t := by\n  rw [\u2190 coe_toEquiv, Equiv.eq_image_iff_symm_image_eq, coe_toEquiv_symm]", "start": [1422, 1], "end": [1424, 73], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.image_preimage", "code": "@[simp]\nlemma image_preimage (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b2) : e '' (e \u207b\u00b9' s) = s := by\n  rw [\u2190 coe_toEquiv, Equiv.image_preimage]", "start": [1426, 1], "end": [1428, 43], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.preimage_image", "code": "@[simp]\nlemma preimage_image (e : \u03b1 \u2243\u1d50 \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e '' s) = s := by\n  rw [\u2190 coe_toEquiv, Equiv.preimage_image]", "start": [1430, 1], "end": [1432, 43], "kind": "mathlibtacticlemma"}, {"full_name": "MeasurableEquiv.measurableSet_preimage", "code": "@[simp]\ntheorem measurableSet_preimage (e : \u03b1 \u2243\u1d50 \u03b2) {s : Set \u03b2} :\n    MeasurableSet (e \u207b\u00b9' s) \u2194 MeasurableSet s", "start": [1434, 1], "end": [1438, 20], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.measurableSet_image", "code": "@[simp]\ntheorem measurableSet_image (e : \u03b1 \u2243\u1d50 \u03b2) {s : Set \u03b1} : MeasurableSet (e '' s) \u2194 MeasurableSet s", "start": [1441, 1], "end": [1443, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.map_eq", "code": "@[simp] theorem map_eq (e : \u03b1 \u2243\u1d50 \u03b2) : MeasurableSpace.map e \u2039_\u203a = \u2039_\u203a", "start": [1446, 1], "end": [1447, 68], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.measurableEmbedding", "code": "protected theorem measurableEmbedding (e : \u03b1 \u2243\u1d50 \u03b2) : MeasurableEmbedding e where", "start": [1450, 1], "end": [1454, 59], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.cast", "code": "protected def cast {\u03b1 \u03b2} [i\u2081 : MeasurableSpace \u03b1] [i\u2082 : MeasurableSpace \u03b2] (h : \u03b1 = \u03b2)\n    (hi : HEq i\u2081 i\u2082) : \u03b1 \u2243\u1d50 \u03b2 where\n  toEquiv := Equiv.cast h\n  measurable_toFun := by\n    subst h\n    subst hi\n    exact measurable_id\n  measurable_invFun := by\n    subst h\n    subst hi\n    exact measurable_id", "start": [1457, 1], "end": [1468, 24], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.measurable_comp_iff", "code": "protected theorem measurable_comp_iff {f : \u03b2 \u2192 \u03b3} (e : \u03b1 \u2243\u1d50 \u03b2) :\n    Measurable (f \u2218 e) \u2194 Measurable f", "start": [1471, 1], "end": [1477, 33], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ofUniqueOfUnique", "code": "def ofUniqueOfUnique (\u03b1 \u03b2 : Type*) [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [Unique \u03b1] [Unique \u03b2] :\n    \u03b1 \u2243\u1d50 \u03b2 where\n  toEquiv := equivOfUnique \u03b1 \u03b2\n  measurable_toFun := Subsingleton.measurable\n  measurable_invFun := Subsingleton.measurable", "start": [1480, 1], "end": [1485, 47], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.prodCongr", "code": "def prodCongr (ab : \u03b1 \u2243\u1d50 \u03b2) (cd : \u03b3 \u2243\u1d50 \u03b4) : \u03b1 \u00d7 \u03b3 \u2243\u1d50 \u03b2 \u00d7 \u03b4 where\n  toEquiv := .prodCongr ab.toEquiv cd.toEquiv\n  measurable_toFun :=\n    (ab.measurable_toFun.comp measurable_id.fst).prod_mk\n      (cd.measurable_toFun.comp measurable_id.snd)\n  measurable_invFun :=\n    (ab.measurable_invFun.comp measurable_id.fst).prod_mk\n      (cd.measurable_invFun.comp measurable_id.snd)", "start": [1488, 1], "end": [1496, 52], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.prodComm", "code": "def prodComm : \u03b1 \u00d7 \u03b2 \u2243\u1d50 \u03b2 \u00d7 \u03b1 where\n  toEquiv := .prodComm \u03b1 \u03b2\n  measurable_toFun := measurable_id.snd.prod_mk measurable_id.fst\n  measurable_invFun := measurable_id.snd.prod_mk measurable_id.fst", "start": [1499, 1], "end": [1503, 67], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.prodAssoc", "code": "def prodAssoc : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u2243\u1d50 \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 where\n  toEquiv := .prodAssoc \u03b1 \u03b2 \u03b3\n  measurable_toFun := measurable_fst.fst.prod_mk <| measurable_fst.snd.prod_mk measurable_snd\n  measurable_invFun := (measurable_fst.prod_mk measurable_snd.fst).prod_mk measurable_snd.snd", "start": [1506, 1], "end": [1510, 94], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sumCongr", "code": "def sumCongr (ab : \u03b1 \u2243\u1d50 \u03b2) (cd : \u03b3 \u2243\u1d50 \u03b4) : Sum \u03b1 \u03b3 \u2243\u1d50 Sum \u03b2 \u03b4 where\n  toEquiv := .sumCongr ab.toEquiv cd.toEquiv\n  measurable_toFun := ab.measurable.sumMap cd.measurable\n  measurable_invFun := ab.symm.measurable.sumMap cd.symm.measurable", "start": [1513, 1], "end": [1517, 68], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Set.prod", "code": "def Set.prod (s : Set \u03b1) (t : Set \u03b2) : \u21a5(s \u00d7\u02e2 t) \u2243\u1d50 s \u00d7 t where\n  toEquiv := Equiv.Set.prod s t\n  measurable_toFun :=\n    measurable_id.subtype_val.fst.subtype_mk.prod_mk measurable_id.subtype_val.snd.subtype_mk\n  measurable_invFun :=\n    Measurable.subtype_mk <| measurable_id.fst.subtype_val.prod_mk measurable_id.snd.subtype_val", "start": [1520, 1], "end": [1526, 97], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Set.univ", "code": "def Set.univ (\u03b1 : Type*) [MeasurableSpace \u03b1] : (univ : Set \u03b1) \u2243\u1d50 \u03b1 where\n  toEquiv := Equiv.Set.univ \u03b1\n  measurable_toFun := measurable_id.subtype_val\n  measurable_invFun := measurable_id.subtype_mk", "start": [1529, 1], "end": [1533, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Set.singleton", "code": "def Set.singleton (a : \u03b1) : ({a} : Set \u03b1) \u2243\u1d50 Unit where\n  toEquiv := Equiv.Set.singleton a\n  measurable_toFun := measurable_const\n  measurable_invFun := measurable_const", "start": [1536, 1], "end": [1540, 40], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Set.rangeInl", "code": "def Set.rangeInl : (range Sum.inl : Set (\u03b1 \u2295 \u03b2)) \u2243\u1d50 \u03b1 where\n  toEquiv := Equiv.Set.rangeInl \u03b1 \u03b2\n  measurable_toFun s (hs : MeasurableSet s) := by\n    refine' \u27e8_, hs.inl_image, Set.ext _\u27e9\n    rintro \u27e8ab, a, rfl\u27e9\n    simp [Set.range_inl]\n  measurable_invFun := Measurable.subtype_mk measurable_inl", "start": [1543, 1], "end": [1550, 60], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.Set.rangeInr", "code": "def Set.rangeInr : (range Sum.inr : Set (Sum \u03b1 \u03b2)) \u2243\u1d50 \u03b2 where\n  toEquiv := Equiv.Set.rangeInr \u03b1 \u03b2\n  measurable_toFun s (hs : MeasurableSet s) := by\n    refine' \u27e8_, hs.inr_image, Set.ext _\u27e9\n    rintro \u27e8ab, b, rfl\u27e9\n    simp [Set.range_inr]\n  measurable_invFun := Measurable.subtype_mk measurable_inr", "start": [1553, 1], "end": [1560, 60], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sumProdDistrib", "code": "def sumProdDistrib (\u03b1 \u03b2 \u03b3) [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] :\n    (\u03b1 \u2295 \u03b2) \u00d7 \u03b3 \u2243\u1d50 (\u03b1 \u00d7 \u03b3) \u2295 (\u03b2 \u00d7 \u03b3) where\n  toEquiv := .sumProdDistrib \u03b1 \u03b2 \u03b3\n  measurable_toFun := by\n    refine'\n      measurable_of_measurable_union_cover (range Sum.inl \u00d7\u02e2 (univ : Set \u03b3))\n        (range Sum.inr \u00d7\u02e2 (univ : Set \u03b3)) (measurableSet_range_inl.prod MeasurableSet.univ)\n        (measurableSet_range_inr.prod MeasurableSet.univ)\n        (by rintro \u27e8a | b, c\u27e9 <;> simp [Set.prod_eq]) _ _\n    \u00b7 refine' (Set.prod (range Sum.inl) univ).symm.measurable_comp_iff.1 _\n      refine' (prodCongr Set.rangeInl (Set.univ _)).symm.measurable_comp_iff.1 _\n      exact measurable_inl\n    \u00b7 refine' (Set.prod (range Sum.inr) univ).symm.measurable_comp_iff.1 _\n      refine' (prodCongr Set.rangeInr (Set.univ _)).symm.measurable_comp_iff.1 _\n      exact measurable_inr\n  measurable_invFun :=\n    measurable_sum ((measurable_inl.comp measurable_fst).prod_mk measurable_snd)\n      ((measurable_inr.comp measurable_fst).prod_mk measurable_snd)", "start": [1563, 1], "end": [1581, 68], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.prodSumDistrib", "code": "def prodSumDistrib (\u03b1 \u03b2 \u03b3) [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] :\n    \u03b1 \u00d7 (\u03b2 \u2295 \u03b3) \u2243\u1d50 (\u03b1 \u00d7 \u03b2) \u2295 (\u03b1 \u00d7 \u03b3) :=\n  prodComm.trans <| (sumProdDistrib _ _ _).trans <| sumCongr prodComm prodComm", "start": [1584, 1], "end": [1587, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sumProdSum", "code": "def sumProdSum (\u03b1 \u03b2 \u03b3 \u03b4) [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]\n    [MeasurableSpace \u03b4] : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b3 \u2295 \u03b4) \u2243\u1d50 ((\u03b1 \u00d7 \u03b3) \u2295 (\u03b1 \u00d7 \u03b4)) \u2295 ((\u03b2 \u00d7 \u03b3) \u2295 (\u03b2 \u00d7 \u03b4)) :=\n  (sumProdDistrib _ _ _).trans <| sumCongr (prodSumDistrib _ _ _) (prodSumDistrib _ _ _)", "start": [1590, 1], "end": [1593, 89], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piCongrRight", "code": "def piCongrRight (e : \u2200 a, \u03c0 a \u2243\u1d50 \u03c0' a) : (\u2200 a, \u03c0 a) \u2243\u1d50 \u2200 a, \u03c0' a where\n  toEquiv := .piCongrRight fun a => (e a).toEquiv\n  measurable_toFun :=\n    measurable_pi_lambda _ fun i => (e i).measurable_toFun.comp (measurable_pi_apply i)\n  measurable_invFun :=\n    measurable_pi_lambda _ fun i => (e i).measurable_invFun.comp (measurable_pi_apply i)", "start": [1598, 1], "end": [1605, 89], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piCongrLeft", "code": "def piCongrLeft (f : \u03b4 \u2243 \u03b4') : (\u2200 b, \u03c0 (f b)) \u2243\u1d50 \u2200 a, \u03c0 a := by\n  refine' { Equiv.piCongrLeft \u03c0 f with .. }\n  \u00b7 exact measurable_piCongrLeft f\n  simp only [invFun_as_coe, coe_fn_symm_mk]\n  rw [measurable_pi_iff]\n  exact fun i => measurable_pi_apply (f i)", "start": [1609, 1], "end": [1615, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_piCongrLeft", "code": "theorem coe_piCongrLeft (f : \u03b4 \u2243 \u03b4') :\n    \u21d1MeasurableEquiv.piCongrLeft \u03c0 f = f.piCongrLeft \u03c0", "start": [1617, 1], "end": [1618, 65], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piMeasurableEquivTProd", "code": "@[simps! (config := { fullyApplied := false })]\ndef piMeasurableEquivTProd [DecidableEq \u03b4'] {l : List \u03b4'} (hnd : l.Nodup) (h : \u2200 i, i \u2208 l) :\n    (\u2200 i, \u03c0 i) \u2243\u1d50 List.TProd \u03c0 l where\n  toEquiv := List.TProd.piEquivTProd hnd h\n  measurable_toFun := measurable_tProd_mk l\n  measurable_invFun := measurable_tProd_elim' h", "start": [1620, 1], "end": [1626, 48], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.funUnique", "code": "@[simps! (config := { fullyApplied := false })]\ndef funUnique (\u03b1 \u03b2 : Type*) [Unique \u03b1] [MeasurableSpace \u03b2] : (\u03b1 \u2192 \u03b2) \u2243\u1d50 \u03b2 where\n  toEquiv := Equiv.funUnique \u03b1 \u03b2\n  measurable_toFun := measurable_pi_apply _\n  measurable_invFun := measurable_pi_iff.2 fun _ => measurable_id", "start": [1629, 1], "end": [1634, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piFinTwo", "code": "@[simps! (config := { fullyApplied := false })]\ndef piFinTwo (\u03b1 : Fin 2 \u2192 Type*) [\u2200 i, MeasurableSpace (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243\u1d50 \u03b1 0 \u00d7 \u03b1 1 where\n  toEquiv := piFinTwoEquiv \u03b1\n  measurable_toFun := Measurable.prod (measurable_pi_apply _) (measurable_pi_apply _)\n  measurable_invFun := measurable_pi_iff.2 <| Fin.forall_fin_two.2 \u27e8measurable_fst, measurable_snd\u27e9", "start": [1637, 1], "end": [1642, 100], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.finTwoArrow", "code": "@[simps! (config := { fullyApplied := false })]\ndef finTwoArrow : (Fin 2 \u2192 \u03b1) \u2243\u1d50 \u03b1 \u00d7 \u03b1 :=\n  piFinTwo fun _ => \u03b1", "start": [1645, 1], "end": [1648, 22], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piFinSuccAboveEquiv", "code": "@[simps! (config := { fullyApplied := false })]\ndef piFinSuccAboveEquiv {n : \u2115} (\u03b1 : Fin (n + 1) \u2192 Type*) [\u2200 i, MeasurableSpace (\u03b1 i)]\n    (i : Fin (n + 1)) : (\u2200 j, \u03b1 j) \u2243\u1d50 \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toEquiv := .piFinSuccAboveEquiv \u03b1 i\n  measurable_toFun := (measurable_pi_apply i).prod_mk <| measurable_pi_iff.2 fun j =>\n    measurable_pi_apply _\n  measurable_invFun := measurable_pi_iff.2 <| i.forall_iff_succAbove.2\n    \u27e8by simp only [piFinSuccAboveEquiv_symm_apply, Fin.insertNth_apply_same, measurable_fst],\n      fun j => by simpa only [piFinSuccAboveEquiv_symm_apply, Fin.insertNth_apply_succAbove]\n        using (measurable_pi_apply _).comp measurable_snd\u27e9", "start": [1651, 1], "end": [1662, 59], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.piEquivPiSubtypeProd", "code": "@[simps! (config := { fullyApplied := false })]\ndef piEquivPiSubtypeProd (p : \u03b4' \u2192 Prop) [DecidablePred p] :\n    (\u2200 i, \u03c0 i) \u2243\u1d50 (\u2200 i : Subtype p, \u03c0 i) \u00d7 \u2200 i : { i // \u00acp i }, \u03c0 i where\n  toEquiv := .piEquivPiSubtypeProd p \u03c0\n  measurable_toFun := measurable_piEquivPiSubtypeProd \u03c0 p\n  measurable_invFun := measurable_piEquivPiSubtypeProd_symm \u03c0 p", "start": [1667, 1], "end": [1674, 64], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sumPiEquivProdPi", "code": "def sumPiEquivProdPi (\u03b1 : \u03b4 \u2295 \u03b4' \u2192 Type*) [\u2200 i, MeasurableSpace (\u03b1 i)] :\n    (\u2200 i, \u03b1 i) \u2243\u1d50 (\u2200 i, \u03b1 (.inl i)) \u00d7 \u2200 i', \u03b1 (.inr i') := by\n  refine' { Equiv.sumPiEquivProdPi \u03b1 with .. }\n  \u00b7 refine Measurable.prod ?_ ?_ <;>\n      rw [measurable_pi_iff] <;> rintro i <;> apply measurable_pi_apply\n  \u00b7 rw [measurable_pi_iff]; rintro (i|i)\n    exact measurable_pi_iff.1 measurable_fst _\n    exact measurable_pi_iff.1 measurable_snd _", "start": [1677, 1], "end": [1686, 47], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_sumPiEquivProdPi", "code": "theorem coe_sumPiEquivProdPi (\u03b1 : \u03b4 \u2295 \u03b4' \u2192 Type*) [\u2200 i, MeasurableSpace (\u03b1 i)] :\n    \u21d1MeasurableEquiv.sumPiEquivProdPi \u03b1 = Equiv.sumPiEquivProdPi \u03b1", "start": [1688, 1], "end": [1689, 77], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.coe_sumPiEquivProdPi_symm", "code": "theorem coe_sumPiEquivProdPi_symm (\u03b1 : \u03b4 \u2295 \u03b4' \u2192 Type*) [\u2200 i, MeasurableSpace (\u03b1 i)] :\n    \u21d1(MeasurableEquiv.sumPiEquivProdPi \u03b1).symm = (Equiv.sumPiEquivProdPi \u03b1).symm", "start": [1691, 1], "end": [1692, 91], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.sumCompl", "code": "def sumCompl {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] (hs : MeasurableSet s) :\n    s \u2295 (s\u1d9c : Set \u03b1) \u2243\u1d50 \u03b1 where\n  toEquiv := .sumCompl (\u00b7 \u2208 s)\n  measurable_toFun := measurable_subtype_coe.sumElim measurable_subtype_coe\n  measurable_invFun := Measurable.dite measurable_inl measurable_inr hs", "start": [1694, 1], "end": [1700, 72], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ofInvolutive", "code": "@[simps toEquiv]\ndef ofInvolutive (f : \u03b1 \u2192 \u03b1) (hf : Involutive f) (hf' : Measurable f) : \u03b1 \u2243\u1d50 \u03b1 where\n  toEquiv := hf.toPerm\n  measurable_toFun := hf'\n  measurable_invFun := hf'", "start": [1703, 1], "end": [1709, 27], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ofInvolutive_apply", "code": "@[simp] theorem ofInvolutive_apply (f : \u03b1 \u2192 \u03b1) (hf : Involutive f) (hf' : Measurable f) (a : \u03b1) :\n    ofInvolutive f hf hf' a = f a", "start": [1712, 1], "end": [1713, 41], "kind": "commanddeclaration"}, {"full_name": "MeasurableEquiv.ofInvolutive_symm", "code": "@[simp] theorem ofInvolutive_symm (f : \u03b1 \u2192 \u03b1) (hf : Involutive f) (hf' : Measurable f) :\n    (ofInvolutive f hf hf').symm = ofInvolutive f hf hf'", "start": [1716, 1], "end": [1717, 64], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.comap_eq", "code": "@[simp] theorem comap_eq (hf : MeasurableEmbedding f) : MeasurableSpace.comap f \u2039_\u203a = \u2039_\u203a", "start": [1726, 1], "end": [1728, 66], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.iff_comap_eq", "code": "theorem iff_comap_eq :\n    MeasurableEmbedding f \u2194\n      Injective f \u2227 MeasurableSpace.comap f \u2039_\u203a = \u2039_\u203a \u2227 MeasurableSet (range f)", "start": [1731, 1], "end": [1740, 76], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.equivImage", "code": "noncomputable def equivImage (s : Set \u03b1) (hf : MeasurableEmbedding f) : s \u2243\u1d50 f '' s where\n  toEquiv := Equiv.Set.image f s hf.injective\n  measurable_toFun := (hf.measurable.comp measurable_id.subtype_val).subtype_mk\n  measurable_invFun := by\n    rintro t \u27e8u, hu, rfl\u27e9; simp [preimage_preimage, Set.image_symm_preimage hf.injective]\n    exact measurable_subtype_coe (hf.measurableSet_image' hu)", "start": [1743, 1], "end": [1750, 62], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.equivRange", "code": "noncomputable def equivRange (hf : MeasurableEmbedding f) : \u03b1 \u2243\u1d50 range f :=\n  (MeasurableEquiv.Set.univ _).symm.trans <|\n    (hf.equivImage univ).trans <| MeasurableEquiv.cast (by rw [image_univ]) (by rw [image_univ])", "start": [1753, 1], "end": [1757, 97], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.of_measurable_inverse_on_range", "code": "theorem of_measurable_inverse_on_range {g : range f \u2192 \u03b1} (hf\u2081 : Measurable f)\n    (hf\u2082 : MeasurableSet (range f)) (hg : Measurable g) (H : LeftInverse g (rangeFactorization f)) :\n    MeasurableEmbedding f", "start": [1760, 1], "end": [1766, 73], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.of_measurable_inverse", "code": "theorem of_measurable_inverse (hf\u2081 : Measurable f) (hf\u2082 : MeasurableSet (range f))\n    (hg : Measurable g) (H : LeftInverse g f) : MeasurableEmbedding f", "start": [1769, 1], "end": [1771, 76], "kind": "commanddeclaration"}, {"full_name": "MeasurableEmbedding.schroederBernstein", "code": "noncomputable def schroederBernstein {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (hf : MeasurableEmbedding f)\n    (hg : MeasurableEmbedding g) : \u03b1 \u2243\u1d50 \u03b2 := by\n  let F : Set \u03b1 \u2192 Set \u03b1 := fun A => (g '' (f '' A)\u1d9c)\u1d9c\n  suffices \u03a3'A : Set \u03b1, MeasurableSet A \u2227 F A = A by\n    rcases this with \u27e8A, Ameas, Afp\u27e9\n    let B := f '' A\n    have Bmeas : MeasurableSet B := hf.measurableSet_image' Ameas\n    refine'\n      (MeasurableEquiv.sumCompl Ameas).symm.trans\n        (MeasurableEquiv.trans _ (MeasurableEquiv.sumCompl Bmeas))\n    apply MeasurableEquiv.sumCongr (hf.equivImage _)\n    have : A\u1d9c = g '' B\u1d9c := by\n      apply compl_injective\n      rw [\u2190 Afp]\n      simp\n    rw [this]\n    exact (hg.equivImage _).symm\n  have Fmono : \u2200 {A B}, A \u2286 B \u2192 F A \u2286 F B := fun h =>\n    compl_subset_compl.mpr <| Set.image_subset _ <| compl_subset_compl.mpr <| Set.image_subset _ h\n  let X : \u2115 \u2192 Set \u03b1 := fun n => F^[n] univ\n  refine' \u27e8iInter X, _, _\u27e9\n  \u00b7 apply MeasurableSet.iInter\n    intro n\n    induction' n with n ih\n    \u00b7 exact MeasurableSet.univ\n    rw [Function.iterate_succ', Function.comp_apply]\n    exact (hg.measurableSet_image' (hf.measurableSet_image' ih).compl).compl\n  apply subset_antisymm\n  \u00b7 apply subset_iInter\n    intro n\n    cases n\n    \u00b7 exact subset_univ _\n    rw [Function.iterate_succ', Function.comp_apply]\n    exact Fmono (iInter_subset _ _)\n  rintro x hx \u27e8y, hy, rfl\u27e9\n  rw [mem_iInter] at hx\n  apply hy\n  rw [(injOn_of_injective hf.injective _).image_iInter_eq]\n  rw [mem_iInter]\n  intro n\n  specialize hx n.succ\n  rw [Function.iterate_succ', Function.comp_apply] at hx\n  by_contra h\n  apply hx\n  exact \u27e8y, h, rfl\u27e9", "start": [1776, 1], "end": [1826, 20], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_compl", "code": "theorem MeasurableSpace.comap_compl {m' : MeasurableSpace \u03b2} [BooleanAlgebra \u03b2]\n    (h : Measurable (compl : \u03b2 \u2192 \u03b2)) (f : \u03b1 \u2192 \u03b2) :\n    MeasurableSpace.comap (fun a => (f a)\u1d9c) inferInstance =\n      MeasurableSpace.comap f inferInstance", "start": [1831, 1], "end": [1837, 89], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.comap_not", "code": "@[simp] theorem MeasurableSpace.comap_not (p : \u03b1 \u2192 Prop) :\n    MeasurableSpace.comap (fun a \u21a6 \u00acp a) inferInstance = MeasurableSpace.comap p inferInstance", "start": [1840, 1], "end": [1842, 62], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.CountablyGenerated", "code": "class CountablyGenerated [m : MeasurableSpace \u03b1] : Prop where\n  isCountablyGenerated : \u2203 b : Set (Set \u03b1), b.Countable \u2227 m = generateFrom b", "start": [1851, 1], "end": [1854, 77], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.CountablyGenerated.comap", "code": "theorem CountablyGenerated.comap [m : MeasurableSpace \u03b2] [h : CountablyGenerated \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    @CountablyGenerated \u03b1 (.comap f m)", "start": [1859, 1], "end": [1864, 30], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.CountablyGenerated.sup", "code": "theorem CountablyGenerated.sup {m\u2081 m\u2082 : MeasurableSpace \u03b2} (h\u2081 : @CountablyGenerated \u03b2 m\u2081)\n    (h\u2082 : @CountablyGenerated \u03b2 m\u2082) : @CountablyGenerated \u03b2 (m\u2081 \u2294 m\u2082)", "start": [1866, 1], "end": [1870, 74], "kind": "commanddeclaration"}, {"full_name": "MeasurableSpace.measurable_injection_nat_bool_of_countablyGenerated", "code": "theorem measurable_injection_nat_bool_of_countablyGenerated [MeasurableSpace \u03b1]\n    [HasCountableSeparatingOn \u03b1 MeasurableSet univ] :\n    \u2203 f : \u03b1 \u2192 \u2115 \u2192 Bool, Measurable f \u2227 Function.Injective f", "start": [1895, 1], "end": [1905, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.IsMeasurablyGenerated", "code": "class IsMeasurablyGenerated (f : Filter \u03b1) : Prop where\n  exists_measurable_subset : \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2203 t \u2208 f, MeasurableSet t \u2227 t \u2286 s", "start": [1916, 1], "end": [1918, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.isMeasurablyGenerated_bot", "code": "instance isMeasurablyGenerated_bot : IsMeasurablyGenerated (\u22a5 : Filter \u03b1) :=\n  \u27e8fun _ _ => \u27e8\u2205, mem_bot, MeasurableSet.empty, empty_subset _\u27e9\u27e9", "start": [1921, 1], "end": [1922, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.isMeasurablyGenerated_top", "code": "instance isMeasurablyGenerated_top : IsMeasurablyGenerated (\u22a4 : Filter \u03b1) :=\n  \u27e8fun _s hs => \u27e8univ, univ_mem, MeasurableSet.univ, fun x _ => hs x\u27e9\u27e9", "start": [1925, 1], "end": [1926, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_measurable_mem", "code": "theorem Eventually.exists_measurable_mem {f : Filter \u03b1} [IsMeasurablyGenerated f] {p : \u03b1 \u2192 Prop}\n    (h : \u2200\u1da0 x in f, p x) : \u2203 s \u2208 f, MeasurableSet s \u2227 \u2200 x \u2208 s, p x", "start": [1929, 1], "end": [1931, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_measurable_mem_of_smallSets", "code": "theorem Eventually.exists_measurable_mem_of_smallSets {f : Filter \u03b1} [IsMeasurablyGenerated f]\n    {p : Set \u03b1 \u2192 Prop} (h : \u2200\u1da0 s in f.smallSets, p s) : \u2203 s \u2208 f, MeasurableSet s \u2227 p s", "start": [1934, 1], "end": [1938, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_isMeasurablyGenerated", "code": "instance inf_isMeasurablyGenerated (f g : Filter \u03b1) [IsMeasurablyGenerated f]\n    [IsMeasurablyGenerated g] : IsMeasurablyGenerated (f \u2293 g) := by\n  constructor\n  rintro t \u27e8sf, hsf, sg, hsg, rfl\u27e9\n  rcases IsMeasurablyGenerated.exists_measurable_subset hsf with \u27e8s'f, hs'f, hmf, hs'sf\u27e9\n  rcases IsMeasurablyGenerated.exists_measurable_subset hsg with \u27e8s'g, hs'g, hmg, hs'sg\u27e9\n  refine' \u27e8s'f \u2229 s'g, inter_mem_inf hs'f hs'g, hmf.inter hmg, _\u27e9\n  exact inter_subset_inter hs'sf hs'sg", "start": [1941, 1], "end": [1948, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_isMeasurablyGenerated_iff", "code": "theorem principal_isMeasurablyGenerated_iff {s : Set \u03b1} :\n    IsMeasurablyGenerated (\ud835\udcdf s) \u2194 MeasurableSet s", "start": [1951, 1], "end": [1957, 15], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.principal_isMeasurablyGenerated", "code": "alias \u27e8_, _root_.MeasurableSet.principal_isMeasurablyGenerated\u27e9 :=\n  principal_isMeasurablyGenerated_iff", "start": [1960, 1], "end": [1961, 38], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.iInf_isMeasurablyGenerated", "code": "instance iInf_isMeasurablyGenerated {f : \u03b9 \u2192 Filter \u03b1} [\u2200 i, IsMeasurablyGenerated (f i)] :\n    IsMeasurablyGenerated (\u2a05 i, f i) := by\n  refine' \u27e8fun s hs => _\u27e9\n  rw [\u2190 Equiv.plift.surjective.iInf_comp, mem_iInf] at hs\n  rcases hs with \u27e8t, ht, \u27e8V, hVf, rfl\u27e9\u27e9\n  choose U hUf hU using fun i => IsMeasurablyGenerated.exists_measurable_subset (hVf i)\n  refine' \u27e8\u22c2 i : t, U i, _, _, _\u27e9\n  \u00b7 rw [\u2190 Equiv.plift.surjective.iInf_comp, mem_iInf]\n    refine' \u27e8t, ht, U, hUf, rfl\u27e9\n  \u00b7 haveI := ht.countable.toEncodable.countable\n    exact MeasurableSet.iInter fun i => (hU i).1\n  \u00b7 exact iInter_mono fun i => (hU i).2", "start": [1964, 1], "end": [1975, 40], "kind": "commanddeclaration"}, {"full_name": "IsCountablySpanning", "code": "def IsCountablySpanning (C : Set (Set \u03b1)) : Prop :=\n  \u2203 s : \u2115 \u2192 Set \u03b1, (\u2200 n, s n \u2208 C) \u2227 \u22c3 n, s n = univ", "start": [1980, 1], "end": [1985, 52], "kind": "commanddeclaration"}, {"full_name": "isCountablySpanning_measurableSet", "code": "theorem isCountablySpanning_measurableSet [MeasurableSpace \u03b1] :\n    IsCountablySpanning { s : Set \u03b1 | MeasurableSet s }", "start": [1988, 1], "end": [1990, 63], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instMembership", "code": "instance Subtype.instMembership : Membership \u03b1 (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun a s => a \u2208 (s : Set \u03b1)\u27e9", "start": [2002, 1], "end": [2003, 31], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.mem_coe", "code": "@[simp]\ntheorem mem_coe (a : \u03b1) (s : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) : a \u2208 (s : Set \u03b1) \u2194 a \u2208 s", "start": [2006, 1], "end": [2008, 10], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instEmptyCollection", "code": "instance Subtype.instEmptyCollection : EmptyCollection (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8\u27e8\u2205, MeasurableSet.empty\u27e9\u27e9", "start": [2011, 1], "end": [2012, 29], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_empty", "code": "@[simp]\ntheorem coe_empty : \u2191(\u2205 : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) = (\u2205 : Set \u03b1)", "start": [2015, 1], "end": [2017, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instInsert", "code": "instance Subtype.instInsert [MeasurableSingletonClass \u03b1] :\n    Insert \u03b1 (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun a s => \u27e8insert a (s : Set \u03b1), s.prop.insert a\u27e9\u27e9", "start": [2020, 1], "end": [2022, 55], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_insert", "code": "@[simp]\ntheorem coe_insert [MeasurableSingletonClass \u03b1] (a : \u03b1)\n    (s : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :\n    \u2191(Insert.insert a s) = (Insert.insert a s : Set \u03b1)", "start": [2025, 1], "end": [2029, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instSingleton", "code": "instance Subtype.instSingleton [MeasurableSingletonClass \u03b1] :\n    Singleton \u03b1 (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun a => \u27e8{a}, .singleton _\u27e9\u27e9", "start": [2032, 1], "end": [2034, 33], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_singleton", "code": "@[simp] theorem coe_singleton [MeasurableSingletonClass \u03b1] (a : \u03b1) :\n    \u2191({a} : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) = ({a} : Set \u03b1)", "start": [2036, 1], "end": [2038, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instIsLawfulSingleton", "code": "instance Subtype.instIsLawfulSingleton [MeasurableSingletonClass \u03b1] :\n    IsLawfulSingleton \u03b1 (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun _ => Subtype.eq <| insert_emptyc_eq _\u27e9", "start": [2040, 1], "end": [2042, 46], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instHasCompl", "code": "instance Subtype.instHasCompl : HasCompl (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x => \u27e8x\u1d9c, x.prop.compl\u27e9\u27e9", "start": [2044, 1], "end": [2045, 32], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_compl", "code": "@[simp]\ntheorem coe_compl (s : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) : \u2191s\u1d9c = (s\u1d9c : Set \u03b1)", "start": [2048, 1], "end": [2050, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instUnion", "code": "instance Subtype.instUnion : Union (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x y => \u27e8(x : Set \u03b1) \u222a y, x.prop.union y.prop\u27e9\u27e9", "start": [2053, 1], "end": [2054, 54], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_union", "code": "@[simp]\ntheorem coe_union (s t : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) : \u2191(s \u222a t) = (s \u222a t : Set \u03b1)", "start": [2057, 1], "end": [2059, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instSup", "code": "instance Subtype.instSup : Sup (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x y => x \u222a y\u27e9", "start": [2062, 1], "end": [2063, 21], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.sup_eq_union", "code": "@[simp]\nprotected theorem sup_eq_union (s t : {s : Set \u03b1 // MeasurableSet s}) : s \u2294 t = s \u222a t", "start": [2066, 1], "end": [2067, 93], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instInter", "code": "instance Subtype.instInter : Inter (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x y => \u27e8x \u2229 y, x.prop.inter y.prop\u27e9\u27e9", "start": [2069, 1], "end": [2070, 44], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_inter", "code": "@[simp]\ntheorem coe_inter (s t : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) : \u2191(s \u2229 t) = (s \u2229 t : Set \u03b1)", "start": [2073, 1], "end": [2075, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instInf", "code": "instance Subtype.instInf : Inf (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x y => x \u2229 y\u27e9", "start": [2078, 1], "end": [2079, 21], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.inf_eq_inter", "code": "@[simp]\nprotected theorem inf_eq_inter (s t : {s : Set \u03b1 // MeasurableSet s}) : s \u2293 t = s \u2229 t", "start": [2082, 1], "end": [2083, 93], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instSDiff", "code": "instance Subtype.instSDiff : SDiff (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8fun x y => \u27e8x \\ y, x.prop.diff y.prop\u27e9\u27e9", "start": [2085, 1], "end": [2086, 43], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_sdiff", "code": "@[simp]\ntheorem coe_sdiff (s t : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) : \u2191(s \\ t) = (s : Set \u03b1) \\ t", "start": [2089, 1], "end": [2091, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instBot", "code": "instance Subtype.instBot : Bot (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) := \u27e8\u2205\u27e9", "start": [2094, 1], "end": [2094, 79], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_bot", "code": "@[simp]\ntheorem coe_bot : \u2191(\u22a5 : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) = (\u22a5 : Set \u03b1)", "start": [2097, 1], "end": [2099, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instTop", "code": "instance Subtype.instTop : Top (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  \u27e8\u27e8Set.univ, MeasurableSet.univ\u27e9\u27e9", "start": [2102, 1], "end": [2103, 35], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.coe_top", "code": "@[simp]\ntheorem coe_top : \u2191(\u22a4 : Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) = (\u22a4 : Set \u03b1)", "start": [2106, 1], "end": [2108, 6], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.Subtype.instBooleanAlgebra", "code": "instance Subtype.instBooleanAlgebra :\n    BooleanAlgebra (Subtype (MeasurableSet : Set \u03b1 \u2192 Prop)) :=\n  Subtype.coe_injective.booleanAlgebra _ (fun _ _ => rfl) (fun _ _ => rfl) rfl rfl (fun _ => rfl)\n    fun _ _ => rfl", "start": [2111, 1], "end": [2114, 19], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.measurableSet_blimsup", "code": "@[measurability]\ntheorem measurableSet_blimsup {s : \u2115 \u2192 Set \u03b1} {p : \u2115 \u2192 Prop} (h : \u2200 n, p n \u2192 MeasurableSet (s n)) :\n    MeasurableSet <| blimsup s atTop p", "start": [2117, 1], "end": [2121, 69], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.measurableSet_bliminf", "code": "@[measurability]\ntheorem measurableSet_bliminf {s : \u2115 \u2192 Set \u03b1} {p : \u2115 \u2192 Prop} (h : \u2200 n, p n \u2192 MeasurableSet (s n)) :\n    MeasurableSet <| Filter.bliminf s Filter.atTop p", "start": [2124, 1], "end": [2128, 69], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.measurableSet_limsup", "code": "@[measurability]\ntheorem measurableSet_limsup {s : \u2115 \u2192 Set \u03b1} (hs : \u2200 n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.limsup s Filter.atTop", "start": [2131, 1], "end": [2134, 74], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.measurableSet_liminf", "code": "@[measurability]\ntheorem measurableSet_liminf {s : \u2115 \u2192 Set \u03b1} (hs : \u2200 n, MeasurableSet <| s n) :\n    MeasurableSet <| Filter.liminf s Filter.atTop", "start": [2137, 1], "end": [2140, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/NullMeasurable.lean", "imports": ["Mathlib/MeasureTheory/Measure/AEDisjoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.NullMeasurableSpace", "code": "@[nolint unusedArguments]\ndef NullMeasurableSpace (\u03b1 : Type*) [MeasurableSpace \u03b1]\n    (_\u03bc : Measure \u03b1 := by volume_tac) : Type _ :=\n  \u03b1", "start": [65, 1], "end": [69, 4], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSpace.instInhabited", "code": "instance NullMeasurableSpace.instInhabited [h : Inhabited \u03b1] :\n    Inhabited (NullMeasurableSpace \u03b1 \u03bc) :=\n  h", "start": [76, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSpace.instSubsingleton", "code": "instance NullMeasurableSpace.instSubsingleton [h : Subsingleton \u03b1] :\n    Subsingleton (NullMeasurableSpace \u03b1 \u03bc) :=\n  h", "start": [81, 1], "end": [83, 4], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSpace.instMeasurableSpace", "code": "instance NullMeasurableSpace.instMeasurableSpace : MeasurableSpace (NullMeasurableSpace \u03b1 \u03bc) where\n  MeasurableSet' s := \u2203 t, MeasurableSet t \u2227 s =\u1d50[\u03bc] t\n  measurableSet_empty := \u27e8\u2205, MeasurableSet.empty, ae_eq_refl _\u27e9\n  measurableSet_compl := fun s \u27e8t, htm, hts\u27e9 => \u27e8t\u1d9c, htm.compl, hts.compl\u27e9\n  measurableSet_iUnion s hs := by\n    choose t htm hts using hs\n    exact \u27e8\u22c3 i, t i, MeasurableSet.iUnion htm, EventuallyEq.countable_iUnion hts\u27e9", "start": [86, 1], "end": [92, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet", "code": "def NullMeasurableSet [MeasurableSpace \u03b1] (s : Set \u03b1)\n    (\u03bc : Measure \u03b1 := by volume_tac) : Prop :=\n  @MeasurableSet (NullMeasurableSpace \u03b1 \u03bc) _ s", "start": [95, 1], "end": [99, 47], "kind": "commanddeclaration"}, {"full_name": "MeasurableSet.nullMeasurableSet", "code": "@[simp]\ntheorem _root_.MeasurableSet.nullMeasurableSet (h : MeasurableSet s) : NullMeasurableSet s \u03bc", "start": [102, 1], "end": [104, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_empty", "code": "theorem nullMeasurableSet_empty : NullMeasurableSet \u2205 \u03bc", "start": [108, 1], "end": [109, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_univ", "code": "theorem nullMeasurableSet_univ : NullMeasurableSet univ \u03bc", "start": [113, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.of_null", "code": "theorem of_null (h : \u03bc s = 0) : NullMeasurableSet s \u03bc", "start": [119, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.compl", "code": "theorem compl (h : NullMeasurableSet s \u03bc) : NullMeasurableSet s\u1d9c \u03bc", "start": [123, 1], "end": [124, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.of_compl", "code": "theorem of_compl (h : NullMeasurableSet s\u1d9c \u03bc) : NullMeasurableSet s \u03bc", "start": [127, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.compl_iff", "code": "@[simp]\ntheorem compl_iff : NullMeasurableSet s\u1d9c \u03bc \u2194 NullMeasurableSet s \u03bc", "start": [131, 1], "end": [133, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.of_subsingleton", "code": "@[nontriviality]\ntheorem of_subsingleton [Subsingleton \u03b1] : NullMeasurableSet s \u03bc", "start": [136, 1], "end": [138, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.congr", "code": "protected theorem congr (hs : NullMeasurableSet s \u03bc) (h : s =\u1d50[\u03bc] t) : NullMeasurableSet t \u03bc", "start": [141, 1], "end": [143, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.iUnion", "code": "protected theorem iUnion {\u03b9 : Sort*} [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, NullMeasurableSet (s i) \u03bc) : NullMeasurableSet (\u22c3 i, s i) \u03bc", "start": [146, 1], "end": [148, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.biUnion_decode\u2082", "code": "@[deprecated iUnion]\nprotected theorem biUnion_decode\u2082 [Encodable \u03b9] \u2983f : \u03b9 \u2192 Set \u03b1\u2984 (h : \u2200 i, NullMeasurableSet (f i) \u03bc)\n    (n : \u2115) : NullMeasurableSet (\u22c3 b \u2208 Encodable.decode\u2082 \u03b9 n, f b) \u03bc", "start": [151, 1], "end": [154, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.biUnion", "code": "protected theorem biUnion {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c3 b \u2208 s, f b) \u03bc", "start": [157, 1], "end": [159, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.sUnion", "code": "protected theorem sUnion {s : Set (Set \u03b1)} (hs : s.Countable) (h : \u2200 t \u2208 s, NullMeasurableSet t \u03bc) :\n    NullMeasurableSet (\u22c3\u2080 s) \u03bc", "start": [162, 1], "end": [165, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.iInter", "code": "protected theorem iInter {\u03b9 : Sort*} [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, NullMeasurableSet (f i) \u03bc) : NullMeasurableSet (\u22c2 i, f i) \u03bc", "start": [168, 1], "end": [170, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.biInter", "code": "protected theorem biInter {f : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hs : s.Countable)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc", "start": [173, 1], "end": [175, 29], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.sInter", "code": "protected theorem sInter {s : Set (Set \u03b1)} (hs : s.Countable) (h : \u2200 t \u2208 s, NullMeasurableSet t \u03bc) :\n    NullMeasurableSet (\u22c2\u2080 s) \u03bc", "start": [178, 1], "end": [180, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.union", "code": "@[simp]\nprotected theorem union (hs : NullMeasurableSet s \u03bc) (ht : NullMeasurableSet t \u03bc) :\n    NullMeasurableSet (s \u222a t) \u03bc", "start": [183, 1], "end": [186, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.union_null", "code": "protected theorem union_null (hs : NullMeasurableSet s \u03bc) (ht : \u03bc t = 0) :\n    NullMeasurableSet (s \u222a t) \u03bc", "start": [189, 1], "end": [191, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.inter", "code": "@[simp]\nprotected theorem inter (hs : NullMeasurableSet s \u03bc) (ht : NullMeasurableSet t \u03bc) :\n    NullMeasurableSet (s \u2229 t) \u03bc", "start": [194, 1], "end": [197, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.diff", "code": "@[simp]\nprotected theorem diff (hs : NullMeasurableSet s \u03bc) (ht : NullMeasurableSet t \u03bc) :\n    NullMeasurableSet (s \\ t) \u03bc", "start": [200, 1], "end": [203, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.disjointed", "code": "@[simp]\nprotected theorem disjointed {f : \u2115 \u2192 Set \u03b1} (h : \u2200 i, NullMeasurableSet (f i) \u03bc) (n) :\n    NullMeasurableSet (disjointed f n) \u03bc", "start": [206, 1], "end": [209, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.const", "code": "protected theorem const (p : Prop) : NullMeasurableSet { _a : \u03b1 | p } \u03bc", "start": [213, 1], "end": [214, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.instMeasurableSingletonClass", "code": "instance instMeasurableSingletonClass [MeasurableSingletonClass \u03b1] :\n    MeasurableSingletonClass (NullMeasurableSpace \u03b1 \u03bc) :=\n  \u27e8fun x => MeasurableSet.nullMeasurableSet (@measurableSet_singleton \u03b1 _ _ x)\u27e9", "start": [217, 1], "end": [219, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.insert", "code": "protected theorem insert [MeasurableSingletonClass (NullMeasurableSpace \u03b1 \u03bc)]\n    (hs : NullMeasurableSet s \u03bc) (a : \u03b1) : NullMeasurableSet (insert a s) \u03bc", "start": [222, 1], "end": [224, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.exists_measurable_superset_ae_eq", "code": "theorem exists_measurable_superset_ae_eq (h : NullMeasurableSet s \u03bc) :\n    \u2203 t, t \u2287 s \u2227 MeasurableSet t \u2227 t =\u1d50[\u03bc] s", "start": [227, 1], "end": [233, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.toMeasurable_ae_eq", "code": "theorem toMeasurable_ae_eq (h : NullMeasurableSet s \u03bc) : toMeasurable \u03bc s =\u1d50[\u03bc] s", "start": [236, 1], "end": [238, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.compl_toMeasurable_compl_ae_eq", "code": "theorem compl_toMeasurable_compl_ae_eq (h : NullMeasurableSet s \u03bc) : (toMeasurable \u03bc s\u1d9c)\u1d9c =\u1d50[\u03bc] s", "start": [241, 1], "end": [242, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.exists_measurable_subset_ae_eq", "code": "theorem exists_measurable_subset_ae_eq (h : NullMeasurableSet s \u03bc) :\n    \u2203 t, t \u2286 s \u2227 MeasurableSet t \u2227 t =\u1d50[\u03bc] s", "start": [245, 1], "end": [248, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_subordinate_pairwise_disjoint", "code": "theorem exists_subordinate_pairwise_disjoint [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, NullMeasurableSet (s i) \u03bc) (hd : Pairwise (AEDisjoint \u03bc on s)) :\n    \u2203 t : \u03b9 \u2192 Set \u03b1,\n      (\u2200 i, t i \u2286 s i) \u2227\n        (\u2200 i, s i =\u1d50[\u03bc] t i) \u2227 (\u2200 i, MeasurableSet (t i)) \u2227 Pairwise (Disjoint on t)", "start": [255, 1], "end": [269, 86], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion", "code": "theorem measure_iUnion {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1}\n    (hn : Pairwise (Disjoint on f)) (h : \u2200 i, MeasurableSet (f i)) :\n    \u03bc (\u22c3 i, f i) = \u2211' i, \u03bc (f i)", "start": [272, 1], "end": [279, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_iUnion\u2080", "code": "theorem measure_iUnion\u2080 [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} (hd : Pairwise (AEDisjoint \u03bc on f))\n    (h : \u2200 i, NullMeasurableSet (f i) \u03bc) : \u03bc (\u22c3 i, f i) = \u2211' i, \u03bc (f i)", "start": [282, 1], "end": [288, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union\u2080_aux", "code": "theorem measure_union\u2080_aux (hs : NullMeasurableSet s \u03bc) (ht : NullMeasurableSet t \u03bc)\n    (hd : AEDisjoint \u03bc s t) : \u03bc (s \u222a t) = \u03bc s + \u03bc t", "start": [292, 1], "end": [295, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_inter_add_diff\u2080", "code": "theorem measure_inter_add_diff\u2080 (s : Set \u03b1) (ht : NullMeasurableSet t \u03bc) :\n    \u03bc (s \u2229 t) + \u03bc (s \\ t) = \u03bc s", "start": [298, 1], "end": [316, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_add_inter\u2080", "code": "theorem measure_union_add_inter\u2080 (s : Set \u03b1) (ht : NullMeasurableSet t \u03bc) :\n    \u03bc (s \u222a t) + \u03bc (s \u2229 t) = \u03bc s + \u03bc t", "start": [320, 1], "end": [323, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union_add_inter\u2080'", "code": "theorem measure_union_add_inter\u2080' (hs : NullMeasurableSet s \u03bc) (t : Set \u03b1) :\n    \u03bc (s \u222a t) + \u03bc (s \u2229 t) = \u03bc s + \u03bc t", "start": [326, 1], "end": [328, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union\u2080", "code": "theorem measure_union\u2080 (ht : NullMeasurableSet t \u03bc) (hd : AEDisjoint \u03bc s t) :\n    \u03bc (s \u222a t) = \u03bc s + \u03bc t", "start": [331, 1], "end": [332, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_union\u2080'", "code": "theorem measure_union\u2080' (hs : NullMeasurableSet s \u03bc) (hd : AEDisjoint \u03bc s t) :\n    \u03bc (s \u222a t) = \u03bc s + \u03bc t", "start": [335, 1], "end": [336, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measure_add_measure_compl\u2080", "code": "theorem measure_add_measure_compl\u2080 {s : Set \u03b1} (hs : NullMeasurableSet s \u03bc) :\n    \u03bc s + \u03bc s\u1d9c = \u03bc univ", "start": [339, 1], "end": [340, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_singleton", "code": "theorem nullMeasurableSet_singleton (x : \u03b1) : NullMeasurableSet {x} \u03bc", "start": [347, 1], "end": [348, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_insert", "code": "@[simp]\ntheorem nullMeasurableSet_insert {a : \u03b1} {s : Set \u03b1} :\n    NullMeasurableSet (insert a s) \u03bc \u2194 NullMeasurableSet s \u03bc", "start": [351, 1], "end": [354, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_eq", "code": "theorem nullMeasurableSet_eq {a : \u03b1} : NullMeasurableSet { x | x = a } \u03bc", "start": [357, 1], "end": [358, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nullMeasurableSet", "code": "protected theorem _root_.Set.Finite.nullMeasurableSet (hs : s.Finite) : NullMeasurableSet s \u03bc", "start": [361, 1], "end": [362, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.nullMeasurableSet", "code": "protected theorem _root_.Finset.nullMeasurableSet (s : Finset \u03b1) : NullMeasurableSet (\u2191s) \u03bc", "start": [365, 1], "end": [366, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nullMeasurableSet_biUnion", "code": "theorem _root_.Set.Finite.nullMeasurableSet_biUnion {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9} (hs : s.Finite)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c3 b \u2208 s, f b) \u03bc", "start": [371, 1], "end": [373, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.nullMeasurableSet_biUnion", "code": "theorem _root_.Finset.nullMeasurableSet_biUnion {f : \u03b9 \u2192 Set \u03b1} (s : Finset \u03b9)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c3 b \u2208 s, f b) \u03bc", "start": [376, 1], "end": [378, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nullMeasurableSet_sUnion", "code": "theorem _root_.Set.Finite.nullMeasurableSet_sUnion {s : Set (Set \u03b1)} (hs : s.Finite)\n    (h : \u2200 t \u2208 s, NullMeasurableSet t \u03bc) : NullMeasurableSet (\u22c3\u2080 s) \u03bc", "start": [381, 1], "end": [383, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nullMeasurableSet_biInter", "code": "theorem _root_.Set.Finite.nullMeasurableSet_biInter {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9} (hs : s.Finite)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc", "start": [386, 1], "end": [388, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.nullMeasurableSet_biInter", "code": "theorem _root_.Finset.nullMeasurableSet_biInter {f : \u03b9 \u2192 Set \u03b1} (s : Finset \u03b9)\n    (h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc", "start": [391, 1], "end": [393, 45], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nullMeasurableSet_sInter", "code": "theorem _root_.Set.Finite.nullMeasurableSet_sInter {s : Set (Set \u03b1)} (hs : s.Finite)\n    (h : \u2200 t \u2208 s, NullMeasurableSet t \u03bc) : NullMeasurableSet (\u22c2\u2080 s) \u03bc", "start": [396, 1], "end": [398, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.nullMeasurableSet_toMeasurable", "code": "theorem nullMeasurableSet_toMeasurable : NullMeasurableSet (toMeasurable \u03bc s) \u03bc", "start": [401, 1], "end": [402, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable", "code": "def NullMeasurable (f : \u03b1 \u2192 \u03b2) (\u03bc : Measure \u03b1 := by volume_tac) : Prop :=\n  \u2200 \u2983s : Set \u03b2\u2984, MeasurableSet s \u2192 NullMeasurableSet (f \u207b\u00b9' s) \u03bc", "start": [411, 1], "end": [414, 65], "kind": "commanddeclaration"}, {"full_name": "Measurable.nullMeasurable", "code": "protected theorem _root_.Measurable.nullMeasurable (h : Measurable f) : NullMeasurable f \u03bc", "start": [417, 1], "end": [418, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable.measurable'", "code": "protected theorem NullMeasurable.measurable' (h : NullMeasurable f \u03bc) :\n    @Measurable (NullMeasurableSpace \u03b1 \u03bc) \u03b2 _ _ f", "start": [421, 1], "end": [423, 4], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measurable.comp_nullMeasurable", "code": "theorem Measurable.comp_nullMeasurable {g : \u03b2 \u2192 \u03b3} (hg : Measurable g) (hf : NullMeasurable f \u03bc) :\n    NullMeasurable (g \u2218 f) \u03bc", "start": [426, 1], "end": [428, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable.congr", "code": "theorem NullMeasurable.congr {g : \u03b1 \u2192 \u03b2} (hf : NullMeasurable f \u03bc) (hg : f =\u1d50[\u03bc] g) :\n    NullMeasurable g \u03bc", "start": [431, 1], "end": [434, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IsComplete", "code": "class Measure.IsComplete {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : Prop where\n  out' : \u2200 s, \u03bc s = 0 \u2192 MeasurableSet s", "start": [441, 1], "end": [446, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.isComplete_iff", "code": "theorem Measure.isComplete_iff : \u03bc.IsComplete \u2194 \u2200 s, \u03bc s = 0 \u2192 MeasurableSet s", "start": [451, 1], "end": [452, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IsComplete.out", "code": "theorem Measure.IsComplete.out (h : \u03bc.IsComplete) : \u2200 s, \u03bc s = 0 \u2192 MeasurableSet s", "start": [455, 1], "end": [456, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.measurableSet_of_null", "code": "theorem measurableSet_of_null [\u03bc.IsComplete] (hs : \u03bc s = 0) : MeasurableSet s", "start": [459, 1], "end": [460, 45], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurableSet.measurable_of_complete", "code": "theorem NullMeasurableSet.measurable_of_complete (hs : NullMeasurableSet s \u03bc) [\u03bc.IsComplete] :\n    MeasurableSet s", "start": [463, 1], "end": [468, 68], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.NullMeasurable.measurable_of_complete", "code": "theorem NullMeasurable.measurable_of_complete [\u03bc.IsComplete] {_m1 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hf : NullMeasurable f \u03bc) : Measurable f", "start": [471, 1], "end": [472, 92], "kind": "commanddeclaration"}, {"full_name": "Measurable.congr_ae", "code": "theorem _root_.Measurable.congr_ae {\u03b1 \u03b2} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1}\n    [_h\u03bc : \u03bc.IsComplete] {f g : \u03b1 \u2192 \u03b2} (hf : Measurable f) (hfg : f =\u1d50[\u03bc] g) : Measurable g", "start": [475, 1], "end": [477, 85], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.completion", "code": "def completion {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) :\n    @MeasureTheory.Measure (NullMeasurableSpace \u03b1 \u03bc) _ where\n  toOuterMeasure := \u03bc.toOuterMeasure\n  m_iUnion s hs hd := measure_iUnion\u2080 (hd.mono fun i j h => h.aedisjoint) hs\n  trimmed := by\n    refine' le_antisymm (fun s => _)\n      (@OuterMeasure.le_trim (NullMeasurableSpace \u03b1 \u03bc) _ _)\n    rw [@OuterMeasure.trim_eq_iInf (NullMeasurableSpace \u03b1 \u03bc) _];\n    have : \u2200 s, \u03bc.toOuterMeasure s = \u03bc s := by simp only [forall_const]\n    rw [this, measure_eq_iInf]\n    apply iInf\u2082_mono\n    exact fun t _ht => iInf_mono' fun h => \u27e8MeasurableSet.nullMeasurableSet h, le_rfl\u27e9", "start": [482, 1], "end": [494, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.completion.isComplete", "code": "instance completion.isComplete {_m : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u03bc.completion.IsComplete :=\n  \u27e8fun _z hz => NullMeasurableSet.of_null hz\u27e9", "start": [497, 1], "end": [498, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.coe_completion", "code": "@[simp]\ntheorem coe_completion {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u21d1\u03bc.completion = \u03bc", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.completion_apply", "code": "theorem completion_apply {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) (s : Set \u03b1) :\n    \u03bc.completion s = \u03bc s", "start": [506, 1], "end": [508, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.ae_completion", "code": "@[simp]\ntheorem ae_completion {_ : MeasurableSpace \u03b1} (\u03bc : Measure \u03b1) : \u03bc.completion.ae = \u03bc.ae", "start": [511, 1], "end": [512, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "balancedCore", "code": "def balancedCore (s : Set E) :=\n  \u22c3\u2080 { t : Set E | Balanced \ud835\udd5c t \u2227 t \u2286 s }", "start": [56, 1], "end": [58, 42], "kind": "commanddeclaration"}, {"full_name": "balancedCoreAux", "code": "def balancedCoreAux (s : Set E) :=\n  \u22c2 (r : \ud835\udd5c) (_ : 1 \u2264 \u2016r\u2016), r \u2022 s", "start": [61, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "balancedHull", "code": "def balancedHull (s : Set E) :=\n  \u22c3 (r : \ud835\udd5c) (_ : \u2016r\u2016 \u2264 1), r \u2022 s", "start": [66, 1], "end": [68, 33], "kind": "commanddeclaration"}, {"full_name": "balancedCore_subset", "code": "theorem balancedCore_subset (s : Set E) : balancedCore \ud835\udd5c s \u2286 s", "start": [73, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "balancedCore_empty", "code": "theorem balancedCore_empty : balancedCore \ud835\udd5c (\u2205 : Set E) = \u2205", "start": [77, 1], "end": [78, 51], "kind": "commanddeclaration"}, {"full_name": "mem_balancedCore_iff", "code": "theorem mem_balancedCore_iff : x \u2208 balancedCore \ud835\udd5c s \u2194 \u2203 t, Balanced \ud835\udd5c t \u2227 t \u2286 s \u2227 x \u2208 t", "start": [81, 1], "end": [82, 62], "kind": "commanddeclaration"}, {"full_name": "smul_balancedCore_subset", "code": "theorem smul_balancedCore_subset (s : Set E) {a : \ud835\udd5c} (ha : \u2016a\u2016 \u2264 1) :\n    a \u2022 balancedCore \ud835\udd5c s \u2286 balancedCore \ud835\udd5c s", "start": [85, 1], "end": [90, 57], "kind": "commanddeclaration"}, {"full_name": "balancedCore_balanced", "code": "theorem balancedCore_balanced (s : Set E) : Balanced \ud835\udd5c (balancedCore \ud835\udd5c s)", "start": [93, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "Balanced.subset_balancedCore_of_subset", "code": "theorem Balanced.subset_balancedCore_of_subset (hs : Balanced \ud835\udd5c s) (h : s \u2286 t) :\n    s \u2286 balancedCore \ud835\udd5c t", "start": [97, 1], "end": [101, 31], "kind": "commanddeclaration"}, {"full_name": "mem_balancedCoreAux_iff", "code": "theorem mem_balancedCoreAux_iff : x \u2208 balancedCoreAux \ud835\udd5c s \u2194 \u2200 r : \ud835\udd5c, 1 \u2264 \u2016r\u2016 \u2192 x \u2208 r \u2022 s", "start": [104, 1], "end": [105, 14], "kind": "commanddeclaration"}, {"full_name": "mem_balancedHull_iff", "code": "theorem mem_balancedHull_iff : x \u2208 balancedHull \ud835\udd5c s \u2194 \u2203 (r : \ud835\udd5c) (_ : \u2016r\u2016 \u2264 1), x \u2208 r \u2022 s", "start": [108, 1], "end": [109, 14], "kind": "commanddeclaration"}, {"full_name": "Balanced.balancedHull_subset_of_subset", "code": "theorem Balanced.balancedHull_subset_of_subset (ht : Balanced \ud835\udd5c t) (h : s \u2286 t) :\n    balancedHull \ud835\udd5c s \u2286 t", "start": [112, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "balancedCore_zero_mem", "code": "theorem balancedCore_zero_mem (hs : (0 : E) \u2208 s) : (0 : E) \u2208 balancedCore \ud835\udd5c s", "start": [127, 1], "end": [128, 81], "kind": "commanddeclaration"}, {"full_name": "balancedCore_nonempty_iff", "code": "theorem balancedCore_nonempty_iff : (balancedCore \ud835\udd5c s).Nonempty \u2194 (0 : E) \u2208 s", "start": [131, 1], "end": [135, 43], "kind": "commanddeclaration"}, {"full_name": "subset_balancedHull", "code": "theorem subset_balancedHull [NormOneClass \ud835\udd5c] {s : Set E} : s \u2286 balancedHull \ud835\udd5c s", "start": [140, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "balancedHull.balanced", "code": "theorem balancedHull.balanced (s : Set E) : Balanced \ud835\udd5c (balancedHull \ud835\udd5c s)", "start": [146, 1], "end": [151, 92], "kind": "commanddeclaration"}, {"full_name": "balancedCoreAux_empty", "code": "@[simp]\ntheorem balancedCoreAux_empty : balancedCoreAux \ud835\udd5c (\u2205 : Set E) = \u2205", "start": [162, 1], "end": [165, 51], "kind": "commanddeclaration"}, {"full_name": "balancedCoreAux_subset", "code": "theorem balancedCoreAux_subset (s : Set E) : balancedCoreAux \ud835\udd5c s \u2286 s", "start": [168, 1], "end": [169, 73], "kind": "commanddeclaration"}, {"full_name": "balancedCoreAux_balanced", "code": "theorem balancedCoreAux_balanced (h0 : (0 : E) \u2208 balancedCoreAux \ud835\udd5c s) :\n    Balanced \ud835\udd5c (balancedCoreAux \ud835\udd5c s)", "start": [172, 1], "end": [183, 50], "kind": "commanddeclaration"}, {"full_name": "balancedCoreAux_maximal", "code": "theorem balancedCoreAux_maximal (h : t \u2286 s) (ht : Balanced \ud835\udd5c t) : t \u2286 balancedCoreAux \ud835\udd5c s", "start": [186, 1], "end": [191, 22], "kind": "commanddeclaration"}, {"full_name": "balancedCore_subset_balancedCoreAux", "code": "theorem balancedCore_subset_balancedCoreAux : balancedCore \ud835\udd5c s \u2286 balancedCoreAux \ud835\udd5c s", "start": [194, 1], "end": [195, 76], "kind": "commanddeclaration"}, {"full_name": "balancedCore_eq_iInter", "code": "theorem balancedCore_eq_iInter (hs : (0 : E) \u2208 s) :\n    balancedCore \ud835\udd5c s = \u22c2 (r : \ud835\udd5c) (_ : 1 \u2264 \u2016r\u2016), r \u2022 s", "start": [198, 1], "end": [202, 71], "kind": "commanddeclaration"}, {"full_name": "subset_balancedCore", "code": "theorem subset_balancedCore (ht : (0 : E) \u2208 t) (hst : \u2200 (a : \ud835\udd5c) (_ : \u2016a\u2016 \u2264 1), a \u2022 s \u2286 t) :\n    s \u2286 balancedCore \ud835\udd5c t", "start": [205, 1], "end": [212, 22], "kind": "commanddeclaration"}, {"full_name": "IsClosed.balancedCore", "code": "protected theorem IsClosed.balancedCore (hU : IsClosed U) : IsClosed (balancedCore \ud835\udd5c U)", "start": [227, 1], "end": [239, 25], "kind": "commanddeclaration"}, {"full_name": "balancedCore_mem_nhds_zero", "code": "theorem balancedCore_mem_nhds_zero (hU : U \u2208 \ud835\udcdd (0 : E)) : balancedCore \ud835\udd5c U \u2208 \ud835\udcdd (0 : E)", "start": [242, 1], "end": [259, 51], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_balanced", "code": "theorem nhds_basis_balanced :\n    (\ud835\udcdd (0 : E)).HasBasis (fun s : Set E => s \u2208 \ud835\udcdd (0 : E) \u2227 Balanced \ud835\udd5c s) id", "start": [264, 1], "end": [268, 29], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_closed_balanced", "code": "theorem nhds_basis_closed_balanced [RegularSpace E] :\n    (\ud835\udcdd (0 : E)).HasBasis (fun s : Set E => s \u2208 \ud835\udcdd (0 : E) \u2227 IsClosed s \u2227 Balanced \ud835\udd5c s) id", "start": [271, 1], "end": [276, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Seminorm.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Normed/Group/AddTorsor.lean", "Mathlib/Analysis/Convex/Function.lean", "Mathlib/Data/Real/Pointwise.lean"], "premises": [{"full_name": "Seminorm", "code": "structure Seminorm (\ud835\udd5c : Type*) (E : Type*) [SeminormedRing \ud835\udd5c] [AddGroup E] [SMul \ud835\udd5c E] extends\n  AddGroupSeminorm E where\n  \n  smul' : \u2200 (a : \ud835\udd5c) (x : E), toFun (a \u2022 x) = \u2016a\u2016 * toFun x", "start": [47, 1], "end": [53, 59], "kind": "commanddeclaration"}, {"full_name": "SeminormClass", "code": "class SeminormClass (F : Type*) (\ud835\udd5c E : outParam <| Type*) [SeminormedRing \ud835\udd5c] [AddGroup E]\n  [SMul \ud835\udd5c E] extends AddGroupSeminormClass F E \u211d where\n  \n  map_smul_eq_mul (f : F) (a : \ud835\udd5c) (x : E) : f (a \u2022 x) = \u2016a\u2016 * f x", "start": [58, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.of", "code": "def Seminorm.of [SeminormedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] (f : E \u2192 \u211d)\n    (add_le : \u2200 x y : E, f (x + y) \u2264 f x + f y) (smul : \u2200 (a : \ud835\udd5c) (x : E), f (a \u2022 x) = \u2016a\u2016 * f x) :\n    Seminorm \ud835\udd5c E where\n  toFun := f\n  map_zero' := by rw [\u2190 zero_smul \ud835\udd5c (0 : E), smul, norm_zero, zero_mul]\n  add_le' := add_le\n  smul' := smul\n  neg' x := by rw [\u2190 neg_one_smul \ud835\udd5c, smul, norm_neg, \u2190 smul, one_smul]", "start": [75, 1], "end": [84, 71], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ofSMulLE", "code": "def Seminorm.ofSMulLE [NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] (f : E \u2192 \u211d) (map_zero : f 0 = 0)\n    (add_le : \u2200 x y, f (x + y) \u2264 f x + f y) (smul_le : \u2200 (r : \ud835\udd5c) (x), f (r \u2022 x) \u2264 \u2016r\u2016 * f x) :\n    Seminorm \ud835\udd5c E :=\n  Seminorm.of f add_le fun r x => by\n    refine' le_antisymm (smul_le r x) _\n    by_cases h : r = 0\n    \u00b7 simp [h, map_zero]\n    rw [\u2190 mul_le_mul_left (inv_pos.mpr (norm_pos_iff.mpr h))]\n    rw [inv_mul_cancel_left\u2080 (norm_ne_zero_iff.mpr h)]\n    specialize smul_le r\u207b\u00b9 (r \u2022 x)\n    rw [norm_inv] at smul_le\n    convert smul_le\n    simp [h]", "start": [87, 1], "end": [101, 13], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instSeminormClass", "code": "instance instSeminormClass : SeminormClass (Seminorm \ud835\udd5c E) \ud835\udd5c E where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    rcases f with \u27e8\u27e8_\u27e9\u27e9\n    rcases g with \u27e8\u27e8_\u27e9\u27e9\n    congr\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_neg_eq_map f := f.neg'\n  map_smul_eq_mul f := f.smul'", "start": [120, 1], "end": [129, 31], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instCoeFun", "code": "instance instCoeFun : CoeFun (Seminorm \ud835\udd5c E) fun _ => E \u2192 \u211d :=\n  FunLike.hasCoeToFun", "start": [132, 1], "end": [134, 22], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ext", "code": "@[ext]\ntheorem ext {p q : Seminorm \ud835\udd5c E} (h : \u2200 x, (p : E \u2192 \u211d) x = q x) : p = q", "start": [136, 1], "end": [138, 20], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instZero", "code": "instance instZero : Zero (Seminorm \ud835\udd5c E) :=\n  \u27e8{ AddGroupSeminorm.instZeroAddGroupSeminorm.zero with\n    smul' := fun _ _ => (mul_zero _).symm }\u27e9", "start": [141, 1], "end": [143, 45], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : Seminorm \ud835\udd5c E) = 0", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : E) : (0 : Seminorm \ud835\udd5c E) x = 0", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instSMul", "code": "instance instSMul [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] : SMul R (Seminorm \ud835\udd5c E) where\n  smul r p :=\n    { r \u2022 p.toAddGroupSeminorm with\n      toFun := fun x => r \u2022 p x\n      smul' := fun _ _ => by\n        simp only [\u2190 smul_one_smul \u211d\u22650 r (_ : \u211d), NNReal.smul_def, smul_eq_mul]\n        rw [map_smul_eq_mul, mul_left_comm] }", "start": [160, 1], "end": [167, 46], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_smul", "code": "theorem coe_smul [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] (r : R) (p : Seminorm \ud835\udd5c E) :\n    \u21d1(r \u2022 p) = r \u2022 \u21d1p", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_apply", "code": "@[simp]\ntheorem smul_apply [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] (r : R) (p : Seminorm \ud835\udd5c E)\n    (x : E) : (r \u2022 p) x = r \u2022 p x", "start": [179, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instAdd", "code": "instance instAdd : Add (Seminorm \ud835\udd5c E) where\n  add p q :=\n    { p.toAddGroupSeminorm + q.toAddGroupSeminorm with\n      toFun := fun x => p x + q x\n      smul' := fun a x => by simp only [map_smul_eq_mul, map_smul_eq_mul, mul_add] }", "start": [185, 1], "end": [189, 85], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_add", "code": "theorem coe_add (p q : Seminorm \ud835\udd5c E) : \u21d1(p + q) = p + q", "start": [191, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.add_apply", "code": "@[simp]\ntheorem add_apply (p q : Seminorm \ud835\udd5c E) (x : E) : (p + q) x = p x + q x", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instAddMonoid", "code": "instance instAddMonoid : AddMonoid (Seminorm \ud835\udd5c E) :=\n  FunLike.coe_injective.addMonoid _ rfl coe_add fun _ _ => by rfl", "start": [200, 1], "end": [201, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instOrderedCancelAddCommMonoid", "code": "instance instOrderedCancelAddCommMonoid : OrderedCancelAddCommMonoid (Seminorm \ud835\udd5c E) :=\n  FunLike.coe_injective.orderedCancelAddCommMonoid _ rfl coe_add fun _ _ => rfl", "start": [203, 1], "end": [204, 80], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instMulAction", "code": "instance instMulAction [Monoid R] [MulAction R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] :\n    MulAction R (Seminorm \ud835\udd5c E) :=\n  FunLike.coe_injective.mulAction _ (by intros; rfl)", "start": [206, 1], "end": [208, 53], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coeFnAddMonoidHom", "code": "@[simps]\ndef coeFnAddMonoidHom : AddMonoidHom (Seminorm \ud835\udd5c E) (E \u2192 \u211d) where\n  toFun := (\u2191)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [212, 1], "end": [217, 22], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coeFnAddMonoidHom_injective", "code": "theorem coeFnAddMonoidHom_injective : Function.Injective (coeFnAddMonoidHom \ud835\udd5c E)", "start": [220, 1], "end": [221, 81], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instDistribMulAction", "code": "instance instDistribMulAction [Monoid R] [DistribMulAction R \u211d] [SMul R \u211d\u22650]\n    [IsScalarTower R \u211d\u22650 \u211d] : DistribMulAction R (Seminorm \ud835\udd5c E) :=\n  (coeFnAddMonoidHom_injective \ud835\udd5c E).distribMulAction _ (by intros; rfl)", "start": [226, 1], "end": [228, 72], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instModule", "code": "instance instModule [Semiring R] [Module R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] :\n    Module R (Seminorm \ud835\udd5c E) :=\n  (coeFnAddMonoidHom_injective \ud835\udd5c E).module R _ (by intros; rfl)", "start": [230, 1], "end": [232, 64], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instSup", "code": "instance instSup : Sup (Seminorm \ud835\udd5c E) where\n  sup p q :=\n    { p.toAddGroupSeminorm \u2294 q.toAddGroupSeminorm with\n      toFun := p \u2294 q\n      smul' := fun x v =>\n        (congr_arg\u2082 max (map_smul_eq_mul p x v) (map_smul_eq_mul q x v)).trans <|\n          (mul_max_of_nonneg _ _ <| norm_nonneg x).symm }", "start": [234, 1], "end": [240, 58], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_sup", "code": "@[simp]\ntheorem coe_sup (p q : Seminorm \ud835\udd5c E) : \u21d1(p \u2294 q) = (p : E \u2192 \u211d) \u2294 (q : E \u2192 \u211d)", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.sup_apply", "code": "theorem sup_apply (p q : Seminorm \ud835\udd5c E) (x : E) : (p \u2294 q) x = p x \u2294 q x", "start": [247, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_sup", "code": "theorem smul_sup [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] (r : R) (p q : Seminorm \ud835\udd5c E) :\n    r \u2022 (p \u2294 q) = r \u2022 p \u2294 r \u2022 q", "start": [251, 1], "end": [256, 33], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instPartialOrder", "code": "instance instPartialOrder : PartialOrder (Seminorm \ud835\udd5c E) :=\n  PartialOrder.lift _ FunLike.coe_injective", "start": [259, 1], "end": [260, 44], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {p q : Seminorm \ud835\udd5c E} : (p : E \u2192 \u211d) \u2264 q \u2194 p \u2264 q", "start": [262, 1], "end": [264, 10], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe {p q : Seminorm \ud835\udd5c E} : (p : E \u2192 \u211d) < q \u2194 p < q", "start": [267, 1], "end": [269, 10], "kind": "commanddeclaration"}, {"full_name": "Seminorm.le_def", "code": "theorem le_def {p q : Seminorm \ud835\udd5c E} : p \u2264 q \u2194 \u2200 x, p x \u2264 q x", "start": [272, 1], "end": [273, 10], "kind": "commanddeclaration"}, {"full_name": "Seminorm.lt_def", "code": "theorem lt_def {p q : Seminorm \ud835\udd5c E} : p < q \u2194 p \u2264 q \u2227 \u2203 x, p x < q x", "start": [276, 1], "end": [277, 23], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instSemilatticeSup", "code": "instance instSemilatticeSup : SemilatticeSup (Seminorm \ud835\udd5c E) :=\n  Function.Injective.semilatticeSup _ FunLike.coe_injective coe_sup", "start": [280, 1], "end": [281, 68], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_nnreal_real", "code": "noncomputable instance smul_nnreal_real : SMul \u211d\u22650 \u211d := inferInstance", "start": [305, 1], "end": [305, 70], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp", "code": "def comp (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : Seminorm \ud835\udd5c E :=\n  { p.toAddGroupSeminorm.comp f.toAddMonoidHom with\n    toFun := fun x => p (f x)\n    smul' := fun _ _ => by simp only [map_smul\u209b\u2097]; rw [map_smul_eq_mul, RingHomIsometric.is_iso] }", "start": [309, 1], "end": [315, 99], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_comp", "code": "theorem coe_comp (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : \u21d1(p.comp f) = p \u2218 f", "start": [318, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_apply", "code": "@[simp]\ntheorem comp_apply (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (x : E) : (p.comp f) x = p (f x)", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_id", "code": "@[simp]\ntheorem comp_id (p : Seminorm \ud835\udd5c E) : p.comp LinearMap.id = p", "start": [327, 1], "end": [329, 19], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_zero", "code": "@[simp]\ntheorem comp_zero (p : Seminorm \ud835\udd5c\u2082 E\u2082) : p.comp (0 : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) = 0", "start": [332, 1], "end": [334, 26], "kind": "commanddeclaration"}, {"full_name": "Seminorm.zero_comp", "code": "@[simp]\ntheorem zero_comp (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : (0 : Seminorm \ud835\udd5c\u2082 E\u2082).comp f = 0", "start": [337, 1], "end": [339, 19], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_comp", "code": "theorem comp_comp [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] (p : Seminorm \ud835\udd5c\u2083 E\u2083) (g : E\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] E\u2083)\n    (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : p.comp (g.comp f) = (p.comp g).comp f", "start": [342, 1], "end": [344, 19], "kind": "commanddeclaration"}, {"full_name": "Seminorm.add_comp", "code": "theorem add_comp (p q : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) :\n    (p + q).comp f = p.comp f + q.comp f", "start": [347, 1], "end": [349, 19], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_add_le", "code": "theorem comp_add_le (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f g : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) :\n    p.comp (f + g) \u2264 p.comp f + p.comp g", "start": [352, 1], "end": [353, 74], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_comp", "code": "theorem smul_comp (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (c : R) :\n    (c \u2022 p).comp f = c \u2022 p.comp f", "start": [356, 1], "end": [358, 19], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_mono", "code": "theorem comp_mono {p q : Seminorm \ud835\udd5c\u2082 E\u2082} (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (hp : p \u2264 q) : p.comp f \u2264 q.comp f", "start": [361, 1], "end": [362, 16], "kind": "commanddeclaration"}, {"full_name": "Seminorm.pullback", "code": "@[simps]\ndef pullback (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : Seminorm \ud835\udd5c\u2082 E\u2082 \u2192+ Seminorm \ud835\udd5c E where\n  toFun := fun p => p.comp f\n  map_zero' := zero_comp f\n  map_add' := fun p q => add_comp p q f", "start": [365, 1], "end": [370, 40], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instOrderBot", "code": "instance instOrderBot : OrderBot (Seminorm \ud835\udd5c E) where\n  bot := 0\n  bot_le := map_nonneg", "start": [373, 1], "end": [375, 23], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_bot", "code": "@[simp]\ntheorem coe_bot : \u21d1(\u22a5 : Seminorm \ud835\udd5c E) = 0", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.bot_eq_zero", "code": "theorem bot_eq_zero : (\u22a5 : Seminorm \ud835\udd5c E) = 0", "start": [382, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_le_smul", "code": "theorem smul_le_smul {p q : Seminorm \ud835\udd5c E} {a b : \u211d\u22650} (hpq : p \u2264 q) (hab : a \u2264 b) :\n    a \u2022 p \u2264 b \u2022 q", "start": [386, 1], "end": [390, 70], "kind": "commanddeclaration"}, {"full_name": "Seminorm.finset_sup_apply", "code": "theorem finset_sup_apply (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) :\n    s.sup p x = \u2191(s.sup fun i => \u27e8p i x, map_nonneg (p i) x\u27e9 : \u211d\u22650)", "start": [393, 1], "end": [399, 34], "kind": "commanddeclaration"}, {"full_name": "Seminorm.exists_apply_eq_finset_sup", "code": "theorem exists_apply_eq_finset_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) {s : Finset \u03b9} (hs : s.Nonempty) (x : E) :\n    \u2203 i \u2208 s, s.sup p x = p i x", "start": [402, 1], "end": [406, 33], "kind": "commanddeclaration"}, {"full_name": "Seminorm.zero_or_exists_apply_eq_finset_sup", "code": "theorem zero_or_exists_apply_eq_finset_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) :\n    s.sup p x = 0 \u2228 \u2203 i \u2208 s, s.sup p x = p i x", "start": [408, 1], "end": [412, 51], "kind": "commanddeclaration"}, {"full_name": "Seminorm.finset_sup_smul", "code": "theorem finset_sup_smul (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (C : \u211d\u22650) :\n    s.sup (C \u2022 p) = C \u2022 s.sup p", "start": [414, 1], "end": [419, 96], "kind": "commanddeclaration"}, {"full_name": "Seminorm.finset_sup_le_sum", "code": "theorem finset_sup_le_sum (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) : s.sup p \u2264 \u2211 i in s, p i", "start": [421, 1], "end": [426, 15], "kind": "commanddeclaration"}, {"full_name": "Seminorm.finset_sup_apply_le", "code": "theorem finset_sup_apply_le {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {s : Finset \u03b9} {x : E} {a : \u211d} (ha : 0 \u2264 a)\n    (h : \u2200 i, i \u2208 s \u2192 p i x \u2264 a) : s.sup p x \u2264 a", "start": [429, 1], "end": [433, 24], "kind": "commanddeclaration"}, {"full_name": "Seminorm.le_finset_sup_apply", "code": "theorem le_finset_sup_apply {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {s : Finset \u03b9} {x : E} {i : \u03b9}\n    (hi : i \u2208 s) : p i x \u2264 s.sup p x", "start": [436, 1], "end": [438, 39], "kind": "commanddeclaration"}, {"full_name": "Seminorm.finset_sup_apply_lt", "code": "theorem finset_sup_apply_lt {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {s : Finset \u03b9} {x : E} {a : \u211d} (ha : 0 < a)\n    (h : \u2200 i, i \u2208 s \u2192 p i x < a) : s.sup p x < a", "start": [440, 1], "end": [445, 32], "kind": "commanddeclaration"}, {"full_name": "Seminorm.norm_sub_map_le_sub", "code": "theorem norm_sub_map_le_sub (p : Seminorm \ud835\udd5c E) (x y : E) : \u2016p x - p y\u2016 \u2264 p (x - y)", "start": [448, 1], "end": [449, 27], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_smul", "code": "theorem comp_smul (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (c : \ud835\udd5c\u2082) :\n    p.comp (c \u2022 f) = \u2016c\u2016\u208a \u2022 p.comp f", "start": [464, 1], "end": [468, 31], "kind": "commanddeclaration"}, {"full_name": "Seminorm.comp_smul_apply", "code": "theorem comp_smul_apply (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (c : \ud835\udd5c\u2082) (x : E) :\n    p.comp (c \u2022 f) x = \u2016c\u2016 * p (f x)", "start": [471, 1], "end": [473, 24], "kind": "commanddeclaration"}, {"full_name": "Seminorm.bddBelow_range_add", "code": "theorem bddBelow_range_add : BddBelow (range fun u => p u + q (x - u))", "start": [482, 1], "end": [486, 23], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instInf", "code": "noncomputable instance instInf : Inf (Seminorm \ud835\udd5c E) where\n  inf p q :=\n    { p.toAddGroupSeminorm \u2293 q.toAddGroupSeminorm with\n      toFun := fun x => \u2a05 u : E, p u + q (x - u)\n      smul' := by\n        intro a x\n        obtain rfl | ha := eq_or_ne a 0\n        \u00b7 rw [norm_zero, zero_mul, zero_smul]\n          refine'\n            ciInf_eq_of_forall_ge_of_forall_gt_exists_lt\n              (fun i => add_nonneg (map_nonneg _ _) (map_nonneg _ _))\n              fun x hx => \u27e80, by rwa [map_zero, sub_zero, map_zero, add_zero]\u27e9\n        simp_rw [Real.mul_iInf_of_nonneg (norm_nonneg a), mul_add, \u2190 map_smul_eq_mul p, \u2190\n          map_smul_eq_mul q, smul_sub]\n        refine'\n          Function.Surjective.iInf_congr ((a\u207b\u00b9 \u2022 \u00b7) : E \u2192 E)\n            (fun u => \u27e8a \u2022 u, inv_smul_smul\u2080 ha u\u27e9) fun u => _\n        rw [smul_inv_smul\u2080 ha] }", "start": [489, 1], "end": [507, 33], "kind": "commanddeclaration"}, {"full_name": "Seminorm.inf_apply", "code": "@[simp]\ntheorem inf_apply (p q : Seminorm \ud835\udd5c E) (x : E) : (p \u2293 q) x = \u2a05 u : E, p u + q (x - u)", "start": [509, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instLattice", "code": "noncomputable instance instLattice : Lattice (Seminorm \ud835\udd5c E) :=\n  { Seminorm.instSemilatticeSup with\n    inf := (\u00b7 \u2293 \u00b7)\n    inf_le_left := fun p q x =>\n      ciInf_le_of_le bddBelow_range_add x <| by\n        simp only [sub_self, map_zero, add_zero]; rfl\n    inf_le_right := fun p q x =>\n      ciInf_le_of_le bddBelow_range_add 0 <| by\n        simp only [sub_self, map_zero, zero_add, sub_zero]; rfl\n    le_inf := fun a b c hab hac x =>\n      le_ciInf fun u => (le_map_add_map_sub a _ _).trans <| add_le_add (hab _) (hac _) }", "start": [514, 1], "end": [524, 89], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_inf", "code": "theorem smul_inf [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d] (r : R) (p q : Seminorm \ud835\udd5c E) :\n    r \u2022 (p \u2293 q) = r \u2022 p \u2293 r \u2022 q", "start": [526, 1], "end": [530, 73], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instSupSet", "code": "noncomputable instance instSupSet : SupSet (Seminorm \ud835\udd5c E) where\n  sSup s :=\n    if h : BddAbove ((\u2191) '' s : Set (E \u2192 \u211d)) then\n      { toFun := \u2a06 p : s, ((p : Seminorm \ud835\udd5c E) : E \u2192 \u211d)\n        map_zero' := by\n          rw [iSup_apply, \u2190 @Real.ciSup_const_zero s]\n          congr!\n          rename_i _ _ _ i\n          exact map_zero i.1\n        add_le' := fun x y => by\n          rcases h with \u27e8q, hq\u27e9\n          obtain rfl | h := s.eq_empty_or_nonempty\n          \u00b7 simp [Real.ciSup_empty]\n          haveI : Nonempty \u2191s := h.coe_sort\n          simp only [iSup_apply]\n          refine' ciSup_le fun i =>\n            ((i : Seminorm \ud835\udd5c E).add_le' x y).trans <| add_le_add\n              (le_ciSup (f := fun i => (Subtype.val i : Seminorm \ud835\udd5c E).toFun x) \u27e8q x, _\u27e9 i)\n              (le_ciSup (f := fun i => (Subtype.val i : Seminorm \ud835\udd5c E).toFun y) \u27e8q y, _\u27e9 i)\n          <;> rw [mem_upperBounds, forall_range_iff]\n          <;> exact fun j => hq (mem_image_of_mem _ j.2) _\n        neg' := fun x => by\n          simp only [iSup_apply]\n          congr! 2\n          rename_i _ _ _ i\n          exact i.1.neg' _\n        smul' := fun a x => by\n          simp only [iSup_apply]\n          rw [\u2190 smul_eq_mul,\n            Real.smul_iSup_of_nonneg (norm_nonneg a) fun i : s => (i : Seminorm \ud835\udd5c E) x]\n          congr!\n          rename_i _ _ _ i\n          exact i.1.smul' a x }\n    else \u22a5", "start": [537, 1], "end": [588, 11], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_sSup_eq'", "code": "protected theorem coe_sSup_eq' {s : Set <| Seminorm \ud835\udd5c E}\n    (hs : BddAbove ((\u2191) '' s : Set (E \u2192 \u211d))) : \u2191(sSup s) = \u2a06 p : s, ((p : Seminorm \ud835\udd5c E) : E \u2192 \u211d)", "start": [590, 1], "end": [592, 27], "kind": "commanddeclaration"}, {"full_name": "Seminorm.bddAbove_iff", "code": "protected theorem bddAbove_iff {s : Set <| Seminorm \ud835\udd5c E} :\n    BddAbove s \u2194 BddAbove ((\u2191) '' s : Set (E \u2192 \u211d))", "start": [595, 1], "end": [603, 98], "kind": "commanddeclaration"}, {"full_name": "Seminorm.bddAbove_range_iff", "code": "protected theorem bddAbove_range_iff {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} :\n    BddAbove (range p) \u2194 \u2200 x, BddAbove (range fun i \u21a6 p i x)", "start": [606, 1], "end": [608, 67], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_sSup_eq", "code": "protected theorem coe_sSup_eq {s : Set <| Seminorm \ud835\udd5c E} (hs : BddAbove s) :\n    \u2191(sSup s) = \u2a06 p : s, ((p : Seminorm \ud835\udd5c E) : E \u2192 \u211d)", "start": [610, 1], "end": [612, 54], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_iSup_eq", "code": "protected theorem coe_iSup_eq {\u03b9 : Type*} {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} (hp : BddAbove (range p)) :\n    \u2191(\u2a06 i, p i) = \u2a06 i, ((p i : Seminorm \ud835\udd5c E) : E \u2192 \u211d)", "start": [615, 1], "end": [618, 60], "kind": "commanddeclaration"}, {"full_name": "Seminorm.sSup_apply", "code": "protected theorem sSup_apply {s : Set (Seminorm \ud835\udd5c E)} (hp : BddAbove s) {x : E} :\n    (sSup s) x = \u2a06 p : s, (p : E \u2192 \u211d) x", "start": [621, 1], "end": [623, 43], "kind": "commanddeclaration"}, {"full_name": "Seminorm.iSup_apply", "code": "protected theorem iSup_apply {\u03b9 : Type*} {p : \u03b9 \u2192 Seminorm \ud835\udd5c E}\n    (hp : BddAbove (range p)) {x : E} : (\u2a06 i, p i) x = \u2a06 i, p i x", "start": [625, 1], "end": [627, 43], "kind": "commanddeclaration"}, {"full_name": "Seminorm.sSup_empty", "code": "protected theorem sSup_empty : sSup (\u2205 : Set (Seminorm \ud835\udd5c E)) = \u22a5", "start": [629, 1], "end": [632, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.Seminorm.isLUB_sSup", "code": "private theorem Seminorm.isLUB_sSup (s : Set (Seminorm \ud835\udd5c E)) (hs\u2081 : BddAbove s) (hs\u2082 : s.Nonempty) :\n    IsLUB s (sSup s)", "start": [634, 1], "end": [640, 37], "kind": "commanddeclaration"}, {"full_name": "Seminorm.instConditionallyCompleteLattice", "code": "noncomputable instance instConditionallyCompleteLattice :\n    ConditionallyCompleteLattice (Seminorm \ud835\udd5c E) :=\n  conditionallyCompleteLatticeOfLatticeOfsSup (Seminorm \ud835\udd5c E) Seminorm.isLUB_sSup", "start": [642, 1], "end": [651, 81], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball", "code": "def ball (x : E) (r : \u211d) :=\n  { y : E | p (y - x) < r }", "start": [672, 1], "end": [675, 28], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall", "code": "def closedBall (x : E) (r : \u211d) :=\n  { y : E | p (y - x) \u2264 r }", "start": [678, 1], "end": [681, 28], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_ball", "code": "@[simp]\ntheorem mem_ball : y \u2208 ball p x r \u2194 p (y - x) < r", "start": [686, 1], "end": [688, 10], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_closedBall", "code": "@[simp]\ntheorem mem_closedBall : y \u2208 closedBall p x r \u2194 p (y - x) \u2264 r", "start": [691, 1], "end": [693, 10], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_ball_self", "code": "theorem mem_ball_self (hr : 0 < r) : x \u2208 ball p x r", "start": [696, 1], "end": [696, 68], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_closedBall_self", "code": "theorem mem_closedBall_self (hr : 0 \u2264 r) : x \u2208 closedBall p x r", "start": [699, 1], "end": [699, 80], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_ball_zero", "code": "theorem mem_ball_zero : y \u2208 ball p 0 r \u2194 p y < r", "start": [702, 1], "end": [702, 79], "kind": "commanddeclaration"}, {"full_name": "Seminorm.mem_closedBall_zero", "code": "theorem mem_closedBall_zero : y \u2208 closedBall p 0 r \u2194 p y \u2264 r", "start": [705, 1], "end": [705, 97], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_zero_eq", "code": "theorem ball_zero_eq : ball p 0 r = { y : E | p y < r }", "start": [708, 1], "end": [709, 35], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_zero_eq", "code": "theorem closedBall_zero_eq : closedBall p 0 r = { y : E | p y \u2264 r }", "start": [712, 1], "end": [713, 41], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_subset_closedBall", "code": "theorem ball_subset_closedBall (x r) : ball p x r \u2286 closedBall p x r", "start": [716, 1], "end": [717, 48], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_eq_biInter_ball", "code": "theorem closedBall_eq_biInter_ball (x r) : closedBall p x r = \u22c2 \u03c1 > r, ball p x \u03c1", "start": [720, 1], "end": [721, 78], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_zero'", "code": "@[simp]\ntheorem ball_zero' (x : E) (hr : 0 < r) : ball (0 : Seminorm \ud835\udd5c E) x r = Set.univ", "start": [724, 1], "end": [727, 12], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_zero'", "code": "@[simp]\ntheorem closedBall_zero' (x : E) (hr : 0 < r) : closedBall (0 : Seminorm \ud835\udd5c E) x r = Set.univ", "start": [730, 1], "end": [732, 69], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_smul", "code": "theorem ball_smul (p : Seminorm \ud835\udd5c E) {c : NNReal} (hc : 0 < c) (r : \u211d) (x : E) :\n    (c \u2022 p).ball x r = p.ball x (r / c)", "start": [735, 1], "end": [739, 40], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_smul", "code": "theorem closedBall_smul (p : Seminorm \ud835\udd5c E) {c : NNReal} (hc : 0 < c) (r : \u211d) (x : E) :\n    (c \u2022 p).closedBall x r = p.closedBall x (r / c)", "start": [742, 1], "end": [746, 40], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_sup", "code": "theorem ball_sup (p : Seminorm \ud835\udd5c E) (q : Seminorm \ud835\udd5c E) (e : E) (r : \u211d) :\n    ball (p \u2294 q) e r = ball p e r \u2229 ball q e r", "start": [749, 1], "end": [751, 69], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_sup", "code": "theorem closedBall_sup (p : Seminorm \ud835\udd5c E) (q : Seminorm \ud835\udd5c E) (e : E) (r : \u211d) :\n    closedBall (p \u2294 q) e r = closedBall p e r \u2229 closedBall q e r", "start": [754, 1], "end": [756, 75], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_finset_sup'", "code": "theorem ball_finset_sup' (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (H : s.Nonempty) (e : E) (r : \u211d) :\n    ball (s.sup' H p) e r = s.inf' H fun i => ball (p i) e r", "start": [759, 1], "end": [765, 33], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_finset_sup'", "code": "theorem closedBall_finset_sup' (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (H : s.Nonempty) (e : E)\n    (r : \u211d) : closedBall (s.sup' H p) e r = s.inf' H fun i => closedBall (p i) e r", "start": [768, 1], "end": [774, 33], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_mono", "code": "theorem ball_mono {p : Seminorm \ud835\udd5c E} {r\u2081 r\u2082 : \u211d} (h : r\u2081 \u2264 r\u2082) : p.ball x r\u2081 \u2286 p.ball x r\u2082", "start": [777, 1], "end": [778, 38], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_mono", "code": "theorem closedBall_mono {p : Seminorm \ud835\udd5c E} {r\u2081 r\u2082 : \u211d} (h : r\u2081 \u2264 r\u2082) :\n    p.closedBall x r\u2081 \u2286 p.closedBall x r\u2082", "start": [781, 1], "end": [782, 78], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_antitone", "code": "theorem ball_antitone {p q : Seminorm \ud835\udd5c E} (h : q \u2264 p) : p.ball x r \u2286 q.ball x r", "start": [785, 1], "end": [786, 17], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_antitone", "code": "theorem closedBall_antitone {p q : Seminorm \ud835\udd5c E} (h : q \u2264 p) :\n    p.closedBall x r \u2286 q.closedBall x r", "start": [789, 1], "end": [790, 64], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_add_ball_subset", "code": "theorem ball_add_ball_subset (p : Seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) (x\u2081 x\u2082 : E) :\n    p.ball (x\u2081 : E) r\u2081 + p.ball (x\u2082 : E) r\u2082 \u2286 p.ball (x\u2081 + x\u2082) (r\u2081 + r\u2082)", "start": [793, 1], "end": [797, 61], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_add_closedBall_subset", "code": "theorem closedBall_add_closedBall_subset (p : Seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) (x\u2081 x\u2082 : E) :\n    p.closedBall (x\u2081 : E) r\u2081 + p.closedBall (x\u2082 : E) r\u2082 \u2286 p.closedBall (x\u2081 + x\u2082) (r\u2081 + r\u2082)", "start": [800, 1], "end": [804, 58], "kind": "commanddeclaration"}, {"full_name": "Seminorm.sub_mem_ball", "code": "theorem sub_mem_ball (p : Seminorm \ud835\udd5c E) (x\u2081 x\u2082 y : E) (r : \u211d) :\n    x\u2081 - x\u2082 \u2208 p.ball y r \u2194 x\u2081 \u2208 p.ball (x\u2082 + y) r", "start": [807, 1], "end": [808, 84], "kind": "commanddeclaration"}, {"full_name": "Seminorm.vadd_ball", "code": "theorem vadd_ball (p : Seminorm \ud835\udd5c E) : x +\u1d65 p.ball y r = p.ball (x +\u1d65 y) r", "start": [811, 1], "end": [814, 25], "kind": "commanddeclaration"}, {"full_name": "Seminorm.vadd_closedBall", "code": "theorem vadd_closedBall (p : Seminorm \ud835\udd5c E) : x +\u1d65 p.closedBall y r = p.closedBall (x +\u1d65 y) r", "start": [817, 1], "end": [820, 31], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_comp", "code": "theorem ball_comp (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (x : E) (r : \u211d) :\n    (p.comp f).ball x r = f \u207b\u00b9' p.ball (f x) r", "start": [833, 1], "end": [836, 70], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_comp", "code": "theorem closedBall_comp (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (x : E) (r : \u211d) :\n    (p.comp f).closedBall x r = f \u207b\u00b9' p.closedBall (f x) r", "start": [839, 1], "end": [842, 76], "kind": "commanddeclaration"}, {"full_name": "Seminorm.preimage_metric_ball", "code": "theorem preimage_metric_ball {r : \u211d} : p \u207b\u00b9' Metric.ball 0 r = { x | p x < r }", "start": [847, 1], "end": [849, 95], "kind": "commanddeclaration"}, {"full_name": "Seminorm.preimage_metric_closedBall", "code": "theorem preimage_metric_closedBall {r : \u211d} : p \u207b\u00b9' Metric.closedBall 0 r = { x | p x \u2264 r }", "start": [852, 1], "end": [855, 42], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_zero_eq_preimage_ball", "code": "theorem ball_zero_eq_preimage_ball {r : \u211d} : p.ball 0 r = p \u207b\u00b9' Metric.ball 0 r", "start": [858, 1], "end": [859, 42], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_zero_eq_preimage_closedBall", "code": "theorem closedBall_zero_eq_preimage_closedBall {r : \u211d} :\n    p.closedBall 0 r = p \u207b\u00b9' Metric.closedBall 0 r", "start": [862, 1], "end": [864, 54], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_bot", "code": "@[simp]\ntheorem ball_bot {r : \u211d} (x : E) (hr : 0 < r) : ball (\u22a5 : Seminorm \ud835\udd5c E) x r = Set.univ", "start": [867, 1], "end": [869, 18], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_bot", "code": "@[simp]\ntheorem closedBall_bot {r : \u211d} (x : E) (hr : 0 < r) :\n    closedBall (\u22a5 : Seminorm \ud835\udd5c E) x r = Set.univ", "start": [872, 1], "end": [875, 24], "kind": "commanddeclaration"}, {"full_name": "Seminorm.balanced_ball_zero", "code": "theorem balanced_ball_zero (r : \u211d) : Balanced \ud835\udd5c (ball p 0 r)", "start": [878, 1], "end": [884, 42], "kind": "commanddeclaration"}, {"full_name": "Seminorm.balanced_closedBall_zero", "code": "theorem balanced_closedBall_zero (r : \u211d) : Balanced \ud835\udd5c (closedBall p 0 r)", "start": [887, 1], "end": [893, 48], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_finset_sup_eq_iInter", "code": "theorem ball_finset_sup_eq_iInter (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) {r : \u211d}\n    (hr : 0 < r) : ball (s.sup p) x r = \u22c2 i \u2208 s, ball (p i) x r", "start": [896, 1], "end": [900, 73], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_finset_sup_eq_iInter", "code": "theorem closedBall_finset_sup_eq_iInter (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) {r : \u211d}\n    (hr : 0 \u2264 r) : closedBall (s.sup p) x r = \u22c2 i \u2208 s, closedBall (p i) x r", "start": [903, 1], "end": [907, 31], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_finset_sup", "code": "theorem ball_finset_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) {r : \u211d} (hr : 0 < r) :\n    ball (s.sup p) x r = s.inf fun i => ball (p i) x r", "start": [910, 1], "end": [913, 43], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_finset_sup", "code": "theorem closedBall_finset_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    closedBall (s.sup p) x r = s.inf fun i => closedBall (p i) x r", "start": [916, 1], "end": [919, 49], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_smul_ball", "code": "theorem ball_smul_ball (p : Seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) :\n    Metric.ball (0 : \ud835\udd5c) r\u2081 \u2022 p.ball 0 r\u2082 \u2286 p.ball 0 (r\u2081 * r\u2082)", "start": [922, 1], "end": [931, 32], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_smul_closedBall", "code": "theorem closedBall_smul_closedBall (p : Seminorm \ud835\udd5c E) (r\u2081 r\u2082 : \u211d) :\n    Metric.closedBall (0 : \ud835\udd5c) r\u2081 \u2022 p.closedBall 0 r\u2082 \u2286 p.closedBall 0 (r\u2081 * r\u2082)", "start": [934, 1], "end": [944, 38], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_eq_emptyset", "code": "@[simp]\ntheorem ball_eq_emptyset (p : Seminorm \ud835\udd5c E) {x : E} {r : \u211d} (hr : r \u2264 0) : p.ball x r = \u2205", "start": [947, 1], "end": [951, 34], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_eq_emptyset", "code": "@[simp]\ntheorem closedBall_eq_emptyset (p : Seminorm \ud835\udd5c E) {x : E} {r : \u211d} (hr : r < 0) :\n    p.closedBall x r = \u2205", "start": [954, 1], "end": [959, 37], "kind": "commanddeclaration"}, {"full_name": "Seminorm.neg_mem_ball_zero", "code": "theorem neg_mem_ball_zero (r : \u211d) (hx : x \u2208 ball p 0 r) : -x \u2208 ball p 0 r", "start": [963, 1], "end": [964, 54], "kind": "commanddeclaration"}, {"full_name": "Seminorm.neg_ball", "code": "@[simp]\ntheorem neg_ball (p : Seminorm \ud835\udd5c E) (r : \u211d) (x : E) : -ball p x r = ball p (-x) r", "start": [967, 1], "end": [970, 83], "kind": "commanddeclaration"}, {"full_name": "Seminorm.closedBall_iSup", "code": "theorem closedBall_iSup {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} (hp : BddAbove (range p)) (e : E) {r : \u211d}\n    (hr : 0 < r) : closedBall (\u2a06 i, p i) e r = \u22c2 i, closedBall (p i) e r", "start": [984, 1], "end": [991, 86], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_norm_mul_subset", "code": "theorem ball_norm_mul_subset {p : Seminorm \ud835\udd5c E} {k : \ud835\udd5c} {r : \u211d} :\n    p.ball 0 (\u2016k\u2016 * r) \u2286 k \u2022 p.ball 0 r", "start": [993, 1], "end": [1004, 76], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_ball_zero", "code": "theorem smul_ball_zero {p : Seminorm \ud835\udd5c E} {k : \ud835\udd5c} {r : \u211d} (hk : k \u2260 0) :\n    k \u2022 p.ball 0 r = p.ball 0 (\u2016k\u2016 * r)", "start": [1007, 1], "end": [1011, 74], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_closedBall_subset", "code": "theorem smul_closedBall_subset {p : Seminorm \ud835\udd5c E} {k : \ud835\udd5c} {r : \u211d} :\n    k \u2022 p.closedBall 0 r \u2286 p.closedBall 0 (\u2016k\u2016 * r)", "start": [1014, 1], "end": [1019, 9], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_closedBall_zero", "code": "theorem smul_closedBall_zero {p : Seminorm \ud835\udd5c E} {k : \ud835\udd5c} {r : \u211d} (hk : 0 < \u2016k\u2016) :\n    k \u2022 p.closedBall 0 r = p.closedBall 0 (\u2016k\u2016 * r)", "start": [1022, 1], "end": [1030, 92], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_zero_absorbs_ball_zero", "code": "theorem ball_zero_absorbs_ball_zero (p : Seminorm \ud835\udd5c E) {r\u2081 r\u2082 : \u211d} (hr\u2081 : 0 < r\u2081) :\n    Absorbs \ud835\udd5c (p.ball 0 r\u2081) (p.ball 0 r\u2082)", "start": [1033, 1], "end": [1039, 44], "kind": "commanddeclaration"}, {"full_name": "Seminorm.absorbent_ball_zero", "code": "protected theorem absorbent_ball_zero (hr : 0 < r) : Absorbent \ud835\udd5c (ball p (0 : E) r)", "start": [1042, 1], "end": [1046, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.absorbent_closedBall_zero", "code": "protected theorem absorbent_closedBall_zero (hr : 0 < r) : Absorbent \ud835\udd5c (closedBall p (0 : E) r)", "start": [1049, 1], "end": [1051, 67], "kind": "commanddeclaration"}, {"full_name": "Seminorm.absorbent_ball", "code": "protected theorem absorbent_ball (hpr : p x < r) : Absorbent \ud835\udd5c (ball p x r)", "start": [1054, 1], "end": [1058, 84], "kind": "commanddeclaration"}, {"full_name": "Seminorm.absorbent_closedBall", "code": "protected theorem absorbent_closedBall (hpr : p x < r) : Absorbent \ud835\udd5c (closedBall p x r)", "start": [1061, 1], "end": [1065, 87], "kind": "commanddeclaration"}, {"full_name": "Seminorm.smul_ball_preimage", "code": "@[simp]\ntheorem smul_ball_preimage (p : Seminorm \ud835\udd5c E) (y : E) (r : \u211d) (a : \ud835\udd5c) (ha : a \u2260 0) :\n    (\u00b7 \u2022 \u00b7) a \u207b\u00b9' p.ball y r = p.ball (a\u207b\u00b9 \u2022 y) (r / \u2016a\u2016)", "start": [1068, 1], "end": [1073, 54], "kind": "commanddeclaration"}, {"full_name": "Seminorm.convexOn", "code": "protected theorem convexOn : ConvexOn \u211d univ p", "start": [1086, 1], "end": [1095, 32], "kind": "commanddeclaration"}, {"full_name": "Seminorm.convex_ball", "code": "theorem convex_ball : Convex \u211d (ball p x r)", "start": [1104, 1], "end": [1109, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.convex_closedBall", "code": "theorem convex_closedBall : Convex \u211d (closedBall p x r)", "start": [1112, 1], "end": [1115, 52], "kind": "commanddeclaration"}, {"full_name": "Seminorm.restrictScalars", "code": "protected def restrictScalars (p : Seminorm \ud835\udd5c' E) : Seminorm \ud835\udd5c E :=\n  { p with\n    smul' := fun a x => by rw [\u2190 smul_one_smul \ud835\udd5c' a x, p.smul', norm_smul, norm_one, mul_one] }", "start": [1127, 1], "end": [1131, 96], "kind": "commanddeclaration"}, {"full_name": "Seminorm.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (p : Seminorm \ud835\udd5c' E) : (p.restrictScalars \ud835\udd5c : E \u2192 \u211d) = p", "start": [1134, 1], "end": [1136, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.restrictScalars_ball", "code": "@[simp]\ntheorem restrictScalars_ball (p : Seminorm \ud835\udd5c' E) : (p.restrictScalars \ud835\udd5c).ball = p.ball", "start": [1139, 1], "end": [1141, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.restrictScalars_closedBall", "code": "@[simp]\ntheorem restrictScalars_closedBall (p : Seminorm \ud835\udd5c' E) :\n    (p.restrictScalars \ud835\udd5c).closedBall = p.closedBall", "start": [1144, 1], "end": [1147, 6], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuousAt_zero_of_forall'", "code": "theorem continuousAt_zero_of_forall' [TopologicalSpace E] {p : Seminorm \ud835\udd5d E}\n    (hp : \u2200 r > 0, p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    ContinuousAt p 0", "start": [1161, 1], "end": [1168, 79], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuousAt_zero'", "code": "theorem continuousAt_zero' [TopologicalSpace E] [ContinuousConstSMul \ud835\udd5c E] {p : Seminorm \ud835\udd5c E}\n    {r : \u211d} (hp : p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) : ContinuousAt p 0", "start": [1170, 1], "end": [1184, 36], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuousAt_zero_of_forall", "code": "theorem continuousAt_zero_of_forall [TopologicalSpace E] {p : Seminorm \ud835\udd5d E}\n    (hp : \u2200 r > 0, p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    ContinuousAt p 0", "start": [1187, 1], "end": [1194, 82], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuousAt_zero", "code": "theorem continuousAt_zero [TopologicalSpace E] [ContinuousConstSMul \ud835\udd5c E] {p : Seminorm \ud835\udd5c E} {r : \u211d}\n    (hp : p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) : ContinuousAt p 0", "start": [1196, 1], "end": [1198, 81], "kind": "commanddeclaration"}, {"full_name": "Seminorm.uniformContinuous_of_continuousAt_zero", "code": "protected theorem uniformContinuous_of_continuousAt_zero [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : ContinuousAt p 0) : UniformContinuous p", "start": [1201, 1], "end": [1208, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_continuousAt_zero", "code": "protected theorem continuous_of_continuousAt_zero [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : ContinuousAt p 0) : Continuous p", "start": [1211, 1], "end": [1215, 72], "kind": "commanddeclaration"}, {"full_name": "Seminorm.uniformContinuous_of_forall", "code": "protected theorem uniformContinuous_of_forall [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : \u2200 r > 0, p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    UniformContinuous p", "start": [1218, 1], "end": [1224, 83], "kind": "commanddeclaration"}, {"full_name": "Seminorm.uniformContinuous", "code": "protected theorem uniformContinuous [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n    {p : Seminorm \ud835\udd5c E} {r : \u211d} (hp : p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    UniformContinuous p", "start": [1226, 1], "end": [1229, 73], "kind": "commanddeclaration"}, {"full_name": "Seminorm.uniformContinuous_of_forall'", "code": "protected theorem uniformContinuous_of_forall' [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : \u2200 r > 0, p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    UniformContinuous p", "start": [1232, 1], "end": [1238, 84], "kind": "commanddeclaration"}, {"full_name": "Seminorm.uniformContinuous'", "code": "protected theorem uniformContinuous' [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n    {p : Seminorm \ud835\udd5c E} {r : \u211d} (hp : p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    UniformContinuous p", "start": [1240, 1], "end": [1243, 74], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_forall", "code": "protected theorem continuous_of_forall [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : \u2200 r > 0, p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    Continuous p", "start": [1246, 1], "end": [1252, 76], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous", "code": "protected theorem continuous [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n    {p : Seminorm \ud835\udd5c E} {r : \u211d} (hp : p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E)) : Continuous p", "start": [1254, 1], "end": [1256, 66], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_forall'", "code": "protected theorem continuous_of_forall' [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm \ud835\udd5d E} (hp : \u2200 r > 0, p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    Continuous p", "start": [1259, 1], "end": [1265, 77], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous'", "code": "protected theorem continuous' [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul \ud835\udd5c E]\n    {p : Seminorm \ud835\udd5c E} {r : \u211d} (hp : p.closedBall 0 r \u2208 (\ud835\udcdd 0 : Filter E)) :\n    Continuous p", "start": [1267, 1], "end": [1270, 67], "kind": "commanddeclaration"}, {"full_name": "Seminorm.continuous_of_le", "code": "theorem continuous_of_le [TopologicalSpace E] [TopologicalAddGroup E]\n    {p q : Seminorm \ud835\udd5d E} (hq : Continuous q) (hpq : p \u2264 q) : Continuous p", "start": [1273, 1], "end": [1278, 38], "kind": "commanddeclaration"}, {"full_name": "Seminorm.ball_mem_nhds", "code": "lemma ball_mem_nhds [TopologicalSpace E] {p : Seminorm \ud835\udd5d E} (hp : Continuous p) {r : \u211d}\n    (hr : 0 < r) : p.ball 0 r \u2208 (\ud835\udcdd 0 : Filter E) :=\n  have this : Tendsto p (\ud835\udcdd 0) (\ud835\udcdd 0) := map_zero p \u25b8 hp.tendsto 0\n  by simpa only [p.ball_zero_eq] using this (Iio_mem_nhds hr)", "start": [1281, 1], "end": [1284, 62], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.rescale_to_shell_zpow", "code": "lemma rescale_to_shell_zpow (p : Seminorm \ud835\udd5c E) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {\u03b5 : \u211d}\n    (\u03b5pos : 0 < \u03b5) {x : E} (hx : p x \u2260 0) : \u2203 n : \u2124, c^n \u2260 0 \u2227\n    p (c^n \u2022 x) < \u03b5 \u2227 (\u03b5 / \u2016c\u2016 \u2264 p (c^n \u2022 x)) \u2227 (\u2016c^n\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * p x) := by\n  have x\u03b5pos : 0 < (p x)/\u03b5 := div_pos ((Ne.symm hx).le_iff_lt.1 (map_nonneg p x)) \u03b5pos\n  rcases exists_mem_Ico_zpow x\u03b5pos hc with \u27e8n, hn\u27e9\n  have cpos : 0 < \u2016c\u2016 := lt_trans (zero_lt_one : (0 :\u211d) < 1) hc\n  have cnpos : 0 < \u2016c^(n+1)\u2016 := by rw [norm_zpow]; exact lt_trans x\u03b5pos hn.2\n  refine \u27e8-(n+1), ?_, ?_, ?_, ?_\u27e9\n  \u00b7 show c ^ (-(n + 1)) \u2260 0; exact zpow_ne_zero _ (norm_pos_iff.1 cpos)\n  \u00b7 show p ((c ^ (-(n + 1))) \u2022 x) < \u03b5\n    rw [map_smul_eq_mul, zpow_neg, norm_inv, \u2190 div_eq_inv_mul, div_lt_iff cnpos, mul_comm,\n        norm_zpow]\n    exact (div_lt_iff \u03b5pos).1 (hn.2)\n  \u00b7 show \u03b5 / \u2016c\u2016 \u2264 p (c ^ (-(n + 1)) \u2022 x)\n    rw [zpow_neg, div_le_iff cpos, map_smul_eq_mul, norm_inv, norm_zpow, zpow_add\u2080 (ne_of_gt cpos),\n        zpow_one, mul_inv_rev, mul_comm, \u2190 mul_assoc, \u2190 mul_assoc, mul_inv_cancel (ne_of_gt cpos),\n        one_mul, \u2190 div_eq_inv_mul, le_div_iff (zpow_pos_of_pos cpos _), mul_comm]\n    exact (le_div_iff \u03b5pos).1 hn.1\n  \u00b7 show \u2016(c ^ (-(n + 1)))\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * p x\n    have : \u03b5\u207b\u00b9 * \u2016c\u2016 * p x = \u03b5\u207b\u00b9 * p x * \u2016c\u2016 := by ring\n    rw [zpow_neg, norm_inv, inv_inv, norm_zpow, zpow_add\u2080 (ne_of_gt cpos), zpow_one, this,\n        \u2190 div_eq_inv_mul]\n    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _)", "start": [1292, 1], "end": [1318, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.rescale_to_shell", "code": "lemma rescale_to_shell (p : Seminorm \ud835\udd5c E) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5) {x : E}\n    (hx : p x \u2260 0) :\n    \u2203d:\ud835\udd5c, d \u2260 0 \u2227 p (d \u2022 x) < \u03b5 \u2227 (\u03b5/\u2016c\u2016 \u2264 p (d \u2022 x)) \u2227 (\u2016d\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * p x) :=\nlet \u27e8_, hn\u27e9 := p.rescale_to_shell_zpow hc \u03b5pos hx; \u27e8_, hn\u27e9", "start": [1320, 1], "end": [1327, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bound_of_shell", "code": "lemma bound_of_shell\n    (p q : Seminorm \ud835\udd5c E) {\u03b5 C : \u211d} (\u03b5_pos : 0 < \u03b5) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    (hf : \u2200 x, \u03b5 / \u2016c\u2016 \u2264 p x \u2192 p x < \u03b5 \u2192 q x \u2264 C * p x) {x : E} (hx : p x \u2260 0) :\n    q x \u2264 C * p x := by\n  rcases p.rescale_to_shell hc \u03b5_pos hx with \u27e8\u03b4, h\u03b4, \u03b4xle, le\u03b4x, -\u27e9\n  simpa only [map_smul_eq_mul, mul_left_comm C, mul_le_mul_left (norm_pos_iff.2 h\u03b4)]\n    using hf (\u03b4 \u2022 x) le\u03b4x \u03b4xle", "start": [1329, 1], "end": [1338, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bound_of_shell_smul", "code": "lemma bound_of_shell_smul\n    (p q : Seminorm \ud835\udd5c E) {\u03b5 : \u211d} {C : \u211d\u22650} (\u03b5_pos : 0 < \u03b5) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    (hf : \u2200 x, \u03b5 / \u2016c\u2016 \u2264 p x \u2192 p x < \u03b5 \u2192 q x \u2264 (C \u2022 p) x) {x : E} (hx : p x \u2260 0) :\n    q x \u2264 (C \u2022 p) x :=\n  Seminorm.bound_of_shell p q \u03b5_pos hc hf hx", "start": [1340, 1], "end": [1346, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bound_of_shell_sup", "code": "lemma bound_of_shell_sup (p : \u03b9 \u2192 Seminorm \ud835\udd5c E) (s : Finset \u03b9)\n    (q : Seminorm \ud835\udd5c E) {\u03b5 : \u211d} {C : \u211d\u22650} (\u03b5_pos : 0 < \u03b5) {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    (hf : \u2200 x, (\u2200 i \u2208 s, p i x < \u03b5) \u2192 \u2200 j \u2208 s, \u03b5 / \u2016c\u2016 \u2264 p j x \u2192 q x \u2264 (C \u2022 p j) x)\n    {x : E} (hx : \u2203 j, j \u2208 s \u2227 p j x \u2260 0) :\n    q x \u2264 (C \u2022 s.sup p) x := by\n  rcases hx with \u27e8j, hj, hjx\u27e9\n  have : (s.sup p) x \u2260 0 :=\n    ne_of_gt ((hjx.symm.lt_of_le $ map_nonneg _ _).trans_le (le_finset_sup_apply hj))\n  refine (s.sup p).bound_of_shell_smul q \u03b5_pos hc (fun y hle hlt \u21a6 ?_) this\n  rcases exists_apply_eq_finset_sup p \u27e8j, hj\u27e9 y with \u27e8i, hi, hiy\u27e9\n  rw [smul_apply, hiy]\n  exact hf y (fun k hk \u21a6 (le_finset_sup_apply hk).trans_lt hlt) i hi (hiy \u25b8 hle)", "start": [1348, 1], "end": [1359, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Seminorm.bddAbove_of_absorbent", "code": "lemma bddAbove_of_absorbent {p : \u03b9 \u2192 Seminorm \ud835\udd5c E} {s : Set E} (hs : Absorbent \ud835\udd5c s)\n    (h : \u2200 x \u2208 s, BddAbove (range fun i \u21a6 p i x)) :\n    BddAbove (range p) := by\n  rw [Seminorm.bddAbove_range_iff]\n  intro x\n  rcases hs x with \u27e8r, hr, hrx\u27e9\n  rcases exists_lt_norm \ud835\udd5c r with \u27e8k, hk\u27e9\n  have hk0 : k \u2260 0 := norm_pos_iff.mp (hr.trans hk)\n  have : k\u207b\u00b9 \u2022 x \u2208 s := by\n    rw [\u2190 mem_smul_set_iff_inv_smul_mem\u2080 hk0]\n    exact hrx k hk.le\n  rcases h (k\u207b\u00b9 \u2022 x) this with \u27e8M, hM\u27e9\n  refine \u27e8\u2016k\u2016 * M, forall_range_iff.mpr fun i \u21a6 ?_\u27e9\n  have := (forall_range_iff.mp hM) i\n  rwa [map_smul_eq_mul, norm_inv, inv_mul_le_iff (hr.trans hk)] at this", "start": [1367, 1], "end": [1381, 72], "kind": "mathlibtacticlemma"}, {"full_name": "normSeminorm", "code": "def normSeminorm : Seminorm \ud835\udd5c E :=\n  { normAddGroupSeminorm E with smul' := norm_smul }", "start": [1394, 1], "end": [1396, 53], "kind": "commanddeclaration"}, {"full_name": "coe_normSeminorm", "code": "@[simp]\ntheorem coe_normSeminorm : \u21d1(normSeminorm \ud835\udd5c E) = norm", "start": [1399, 1], "end": [1401, 6], "kind": "commanddeclaration"}, {"full_name": "ball_normSeminorm", "code": "@[simp]\ntheorem ball_normSeminorm : (normSeminorm \ud835\udd5c E).ball = Metric.ball", "start": [1404, 1], "end": [1407, 81], "kind": "commanddeclaration"}, {"full_name": "absorbent_ball_zero", "code": "theorem absorbent_ball_zero (hr : 0 < r) : Absorbent \ud835\udd5c (Metric.ball (0 : E) r)", "start": [1412, 1], "end": [1415, 50], "kind": "commanddeclaration"}, {"full_name": "absorbent_ball", "code": "theorem absorbent_ball (hx : \u2016x\u2016 < r) : Absorbent \ud835\udd5c (Metric.ball x r)", "start": [1418, 1], "end": [1421, 45], "kind": "commanddeclaration"}, {"full_name": "balanced_ball_zero", "code": "theorem balanced_ball_zero : Balanced \ud835\udd5c (Metric.ball (0 : E) r)", "start": [1424, 1], "end": [1427, 48], "kind": "commanddeclaration"}, {"full_name": "rescale_to_shell_semi_normed_zpow", "code": "lemma rescale_to_shell_semi_normed_zpow {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5) {x : E}\n    (hx : \u2016x\u2016 \u2260 0) :\n    \u2203 n : \u2124, c^n \u2260 0 \u2227 \u2016c^n \u2022 x\u2016 < \u03b5 \u2227 (\u03b5 / \u2016c\u2016 \u2264 \u2016c^n \u2022 x\u2016) \u2227 (\u2016c^n\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * \u2016x\u2016) :=\n  (normSeminorm \ud835\udd5c E).rescale_to_shell_zpow hc \u03b5pos hx", "start": [1430, 1], "end": [1436, 54], "kind": "mathlibtacticlemma"}, {"full_name": "rescale_to_shell_semi_normed", "code": "lemma rescale_to_shell_semi_normed {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5)\n    {x : E} (hx : \u2016x\u2016 \u2260 0) :\n    \u2203d:\ud835\udd5c, d \u2260 0 \u2227 \u2016d \u2022 x\u2016 < \u03b5 \u2227 (\u03b5/\u2016c\u2016 \u2264 \u2016d \u2022 x\u2016) \u2227 (\u2016d\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * \u2016x\u2016) :=\n  (normSeminorm \ud835\udd5c E).rescale_to_shell hc \u03b5pos hx", "start": [1439, 1], "end": [1445, 49], "kind": "mathlibtacticlemma"}, {"full_name": "rescale_to_shell_zpow", "code": "lemma rescale_to_shell_zpow [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5) {x : F} (hx : x \u2260 0) :\n    \u2203 n : \u2124, c^n \u2260 0 \u2227 \u2016c^n \u2022 x\u2016 < \u03b5 \u2227 (\u03b5 / \u2016c\u2016 \u2264 \u2016c^n \u2022 x\u2016) \u2227 (\u2016c^n\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * \u2016x\u2016) :=\n  rescale_to_shell_semi_normed_zpow hc \u03b5pos (norm_ne_zero_iff.mpr hx)", "start": [1448, 1], "end": [1451, 70], "kind": "mathlibtacticlemma"}, {"full_name": "rescale_to_shell", "code": "lemma rescale_to_shell [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016)\n    {\u03b5 : \u211d} (\u03b5pos : 0 < \u03b5) {x : F} (hx : x \u2260 0) :\n    \u2203d:\ud835\udd5c, d \u2260 0 \u2227 \u2016d \u2022 x\u2016 < \u03b5 \u2227 (\u03b5/\u2016c\u2016 \u2264 \u2016d \u2022 x\u2016) \u2227 (\u2016d\u2016\u207b\u00b9 \u2264 \u03b5\u207b\u00b9 * \u2016c\u2016 * \u2016x\u2016) :=\n  rescale_to_shell_semi_normed hc \u03b5pos (norm_ne_zero_iff.mpr hx)", "start": [1454, 1], "end": [1460, 65], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Basis.lean", "imports": ["Mathlib/LinearAlgebra/Basis.lean", "Mathlib/LinearAlgebra/AffineSpace/Independent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AffineBasis", "code": "structure AffineBasis (\u03b9 : Type u\u2081) (k : Type u\u2082) {V : Type u\u2083} (P : Type u\u2084) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : \u03b9 \u2192 P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = \u22a4", "start": [50, 1], "end": [55, 50], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.funLike", "code": "instance funLike : FunLike (AffineBasis \u03b9 k P) \u03b9 fun _ => P where\n  coe := AffineBasis.toFun\n  coe_injective' f g h := by cases f; cases g; congr", "start": [70, 1], "end": [72, 53], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.ext", "code": "@[ext]\ntheorem ext {b\u2081 b\u2082 : AffineBasis \u03b9 k P} (h : (b\u2081 : \u03b9 \u2192 P) = b\u2082) : b\u2081 = b\u2082", "start": [75, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.ind", "code": "theorem ind : AffineIndependent k b", "start": [80, 1], "end": [81, 9], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.tot", "code": "theorem tot : affineSpan k (range b) = \u22a4", "start": [84, 1], "end": [85, 9], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.nonempty", "code": "protected theorem nonempty : Nonempty \u03b9", "start": [88, 1], "end": [90, 91], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.reindex", "code": "def reindex (e : \u03b9 \u2243 \u03b9') : AffineBasis \u03b9' k P :=\n  \u27e8b \u2218 e.symm, b.ind.comp_embedding e.symm.toEmbedding, by\n    rw [e.symm.surjective.range_comp]\n    exact b.3\u27e9", "start": [93, 1], "end": [97, 15], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coe_reindex", "code": "@[simp, norm_cast]\ntheorem coe_reindex : \u21d1(b.reindex e) = b \u2218 e.symm", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.reindex_apply", "code": "@[simp]\ntheorem reindex_apply (i' : \u03b9') : b.reindex e i' = b (e.symm i')", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.reindex_refl", "code": "@[simp]\ntheorem reindex_refl : b.reindex (Equiv.refl _) = b", "start": [110, 1], "end": [112, 10], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.basisOf", "code": "noncomputable def basisOf (i : \u03b9) : Basis { j : \u03b9 // j \u2260 i } k V :=\n  Basis.mk ((affineIndependent_iff_linearIndependent_vsub k b i).mp b.ind)\n    (by\n      suffices\n        Submodule.span k (range fun j : { x // x \u2260 i } => b \u2191j -\u1d65 b i) = vectorSpan k (range b) by\n        rw [this, \u2190 direction_affineSpan, b.tot, AffineSubspace.direction_top]\n      conv_rhs => rw [\u2190 image_univ]\n      rw [vectorSpan_image_eq_span_vsub_set_right_ne k b (mem_univ i)]\n      congr\n      ext v\n      simp)", "start": [115, 1], "end": [130, 12], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.basisOf_apply", "code": "@[simp]\ntheorem basisOf_apply (i : \u03b9) (j : { j : \u03b9 // j \u2260 i }) : b.basisOf i j = b \u2191j -\u1d65 b i", "start": [133, 1], "end": [135, 17], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.basisOf_reindex", "code": "@[simp]\ntheorem basisOf_reindex (i : \u03b9') :\n    (b.reindex e).basisOf i =\n      (b.basisOf <| e.symm i).reindex (e.subtypeEquiv fun _ => e.eq_symm_apply.not)", "start": [138, 1], "end": [143, 7], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord", "code": "noncomputable def coord (i : \u03b9) : P \u2192\u1d43[k] k where\n  toFun q := 1 - (b.basisOf i).sumCoords (q -\u1d65 b i)\n  linear := -(b.basisOf i).sumCoords\n  map_vadd' q v := by\n    dsimp only\n    rw [vadd_vsub_assoc, LinearMap.map_add, vadd_eq_add, LinearMap.neg_apply,\n      sub_add_eq_sub_sub_swap, add_comm, sub_eq_add_neg]", "start": [146, 1], "end": [153, 57], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.linear_eq_sumCoords", "code": "@[simp]\ntheorem linear_eq_sumCoords (i : \u03b9) : (b.coord i).linear = -(b.basisOf i).sumCoords", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_reindex", "code": "@[simp]\ntheorem coord_reindex (i : \u03b9') : (b.reindex e).coord i = b.coord (e.symm i)", "start": [161, 1], "end": [164, 37], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply_eq", "code": "@[simp]\ntheorem coord_apply_eq (i : \u03b9) : b.coord i (b i) = 1", "start": [167, 1], "end": [170, 57], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply_ne", "code": "@[simp]\ntheorem coord_apply_ne (h : i \u2260 j) : b.coord i (b j) = 0", "start": [173, 1], "end": [179, 42], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply", "code": "theorem coord_apply [DecidableEq \u03b9] (i j : \u03b9) : b.coord i (b j) = if i = j then 1 else 0", "start": [182, 1], "end": [183, 44], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply_combination_of_mem", "code": "@[simp]\ntheorem coord_apply_combination_of_mem (hi : i \u2208 s) {w : \u03b9 \u2192 k} (hw : s.sum w = 1) :\n    b.coord i (s.affineCombination k b w) = w i", "start": [186, 1], "end": [191, 38], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply_combination_of_not_mem", "code": "@[simp]\ntheorem coord_apply_combination_of_not_mem (hi : i \u2209 s) {w : \u03b9 \u2192 k} (hw : s.sum w = 1) :\n    b.coord i (s.affineCombination k b w) = 0", "start": [194, 1], "end": [199, 38], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.sum_coord_apply_eq_one", "code": "@[simp]\ntheorem sum_coord_apply_eq_one [Fintype \u03b9] (q : P) : \u2211 i, b.coord i q = 1", "start": [202, 1], "end": [209, 64], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.affineCombination_coord_eq_self", "code": "@[simp]\ntheorem affineCombination_coord_eq_self [Fintype \u03b9] (q : P) :\n    (Finset.univ.affineCombination k b fun i => b.coord i q) = q", "start": [212, 1], "end": [221, 64], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.linear_combination_coord_eq_self", "code": "@[simp]\ntheorem linear_combination_coord_eq_self [Fintype \u03b9] (b : AffineBasis \u03b9 k V) (v : V) :\n    \u2211 i, b.coord i v \u2022 b i = v", "start": [224, 1], "end": [230, 99], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.ext_elem", "code": "theorem ext_elem [Finite \u03b9] {q\u2081 q\u2082 : P} (h : \u2200 i, b.coord i q\u2081 = b.coord i q\u2082) : q\u2081 = q\u2082", "start": [233, 1], "end": [236, 16], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coe_coord_of_subsingleton_eq_one", "code": "@[simp]\ntheorem coe_coord_of_subsingleton_eq_one [Subsingleton \u03b9] (i : \u03b9) : (b.coord i : P \u2192 k) = 1", "start": [239, 1], "end": [251, 86], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.surjective_coord", "code": "theorem surjective_coord [Nontrivial \u03b9] (i : \u03b9) : Function.Surjective <| b.coord i", "start": [254, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coords", "code": "noncomputable def coords : P \u2192\u1d43[k] \u03b9 \u2192 k where\n  toFun q i := b.coord i q\n  linear :=\n    { toFun := fun v i => -(b.basisOf i).sumCoords v\n      map_add' := fun v w => by\n        ext i\n        simp only [LinearMap.map_add, Pi.add_apply, neg_add]\n      map_smul' := fun t v => by\n        ext i\n        simp only [LinearMap.map_smul, Pi.smul_apply, smul_neg, RingHom.id_apply, mul_neg] }\n  map_vadd' p v := by\n    ext i\n    rw [LinearMap.coe_mk, Pi.vadd_apply']\n    dsimp\n    rw [AffineMap.map_vadd, linear_eq_sumCoords,\n        LinearMap.neg_apply]\n    simp only [ne_eq, Basis.coe_sumCoords, vadd_eq_add]", "start": [267, 1], "end": [289, 56], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coords_apply", "code": "@[simp]\ntheorem coords_apply (q : P) (i : \u03b9) : b.coords q i = b.coord i q", "start": [292, 1], "end": [294, 6], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.coord_apply_centroid", "code": "@[simp]\ntheorem coord_apply_centroid [CharZero k] (b : AffineBasis \u03b9 k P) {s : Finset \u03b9} {i : \u03b9}\n    (hi : i \u2208 s) : b.coord i (s.centroid k b) = (s.card : k)\u207b\u00b9", "start": [303, 1], "end": [308, 50], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.exists_affine_subbasis", "code": "theorem exists_affine_subbasis {t : Set P} (ht : affineSpan k t = \u22a4) :\n    \u2203 (s : _) (_ : s \u2286 t) (b : AffineBasis (\u21a5s) k P), \u21d1b = ((\u2191) : s \u2192 P)", "start": [311, 1], "end": [315, 36], "kind": "commanddeclaration"}, {"full_name": "AffineBasis.exists_affineBasis", "code": "theorem exists_affineBasis : \u2203 (s : Set P) (b : AffineBasis (\u21a5s) k P), \u21d1b = ((\u2191) : s \u2192 P)", "start": [320, 1], "end": [322, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecificLimits/Normed.lean", "imports": ["Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Data/List/TFAE.lean"], "premises": [{"full_name": "tendsto_norm_atTop_atTop", "code": "theorem tendsto_norm_atTop_atTop : Tendsto (norm : \u211d \u2192 \u211d) atTop atTop", "start": [30, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "summable_of_absolute_convergence_real", "code": "theorem summable_of_absolute_convergence_real {f : \u2115 \u2192 \u211d} :\n    (\u2203 r, Tendsto (fun n \u21a6 \u2211 i in range n, |f i|) atTop (\ud835\udcdd r)) \u2192 Summable f", "start": [34, 1], "end": [39, 24], "kind": "commanddeclaration"}, {"full_name": "tendsto_norm_zero'", "code": "theorem tendsto_norm_zero' {\ud835\udd5c : Type*} [NormedAddCommGroup \ud835\udd5c] :\n    Tendsto (norm : \ud835\udd5c \u2192 \u211d) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd[>] 0)", "start": [45, 1], "end": [47, 86], "kind": "commanddeclaration"}, {"full_name": "NormedField.tendsto_norm_inverse_nhdsWithin_0_atTop", "code": "theorem tendsto_norm_inverse_nhdsWithin_0_atTop {\ud835\udd5c : Type*} [NormedField \ud835\udd5c] :\n    Tendsto (fun x : \ud835\udd5c \u21a6 \u2016x\u207b\u00b9\u2016) (\ud835\udcdd[\u2260] 0) atTop", "start": [52, 1], "end": [54, 83], "kind": "commanddeclaration"}, {"full_name": "NormedField.tendsto_norm_zpow_nhdsWithin_0_atTop", "code": "theorem tendsto_norm_zpow_nhdsWithin_0_atTop {\ud835\udd5c : Type*} [NormedField \ud835\udd5c] {m : \u2124} (hm : m < 0) :\n    Tendsto (fun x : \ud835\udd5c \u21a6 \u2016x ^ m\u2016) (\ud835\udcdd[\u2260] 0) atTop", "start": [57, 1], "end": [62, 92], "kind": "commanddeclaration"}, {"full_name": "NormedField.tendsto_zero_smul_of_tendsto_zero_of_bounded", "code": "theorem tendsto_zero_smul_of_tendsto_zero_of_bounded {\u03b9 \ud835\udd5c \ud835\udd38 : Type*} [NormedField \ud835\udd5c]\n    [NormedAddCommGroup \ud835\udd38] [NormedSpace \ud835\udd5c \ud835\udd38] {l : Filter \u03b9} {\u03b5 : \u03b9 \u2192 \ud835\udd5c} {f : \u03b9 \u2192 \ud835\udd38}\n    (h\u03b5 : Tendsto \u03b5 l (\ud835\udcdd 0)) (hf : Filter.IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f)) :\n    Tendsto (\u03b5 \u2022 f) l (\ud835\udcdd 0)", "start": [65, 1], "end": [71, 85], "kind": "commanddeclaration"}, {"full_name": "NormedField.continuousAt_zpow", "code": "@[simp]\ntheorem continuousAt_zpow {\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {m : \u2124} {x : \ud835\udd5c} :\n    ContinuousAt (fun x \u21a6 x ^ m) x \u2194 x \u2260 0 \u2228 0 \u2264 m", "start": [74, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "NormedField.continuousAt_inv", "code": "@[simp]\ntheorem continuousAt_inv {\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} :\n    ContinuousAt Inv.inv x \u2194 x \u2260 0", "start": [83, 1], "end": [86, 70], "kind": "commanddeclaration"}, {"full_name": "isLittleO_pow_pow_of_lt_left", "code": "theorem isLittleO_pow_pow_of_lt_left {r\u2081 r\u2082 : \u211d} (h\u2081 : 0 \u2264 r\u2081) (h\u2082 : r\u2081 < r\u2082) :\n    (fun n : \u2115 \u21a6 r\u2081 ^ n) =o[atTop] fun n \u21a6 r\u2082 ^ n", "start": [91, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "isBigO_pow_pow_of_le_left", "code": "theorem isBigO_pow_pow_of_le_left {r\u2081 r\u2082 : \u211d} (h\u2081 : 0 \u2264 r\u2081) (h\u2082 : r\u2081 \u2264 r\u2082) :\n    (fun n : \u2115 \u21a6 r\u2081 ^ n) =O[atTop] fun n \u21a6 r\u2082 ^ n", "start": [99, 1], "end": [101, 100], "kind": "commanddeclaration"}, {"full_name": "isLittleO_pow_pow_of_abs_lt_left", "code": "theorem isLittleO_pow_pow_of_abs_lt_left {r\u2081 r\u2082 : \u211d} (h : |r\u2081| < |r\u2082|) :\n    (fun n : \u2115 \u21a6 r\u2081 ^ n) =o[atTop] fun n \u21a6 r\u2082 ^ n", "start": [105, 1], "end": [108, 89], "kind": "commanddeclaration"}, {"full_name": "TFAE_exists_lt_isLittleO_pow", "code": "theorem TFAE_exists_lt_isLittleO_pow (f : \u2115 \u2192 \u211d) (R : \u211d) :\n    TFAE\n      [\u2203 a \u2208 Ioo (-R) R, f =o[atTop] (a ^ \u00b7), \u2203 a \u2208 Ioo 0 R, f =o[atTop] (a ^ \u00b7),\n        \u2203 a \u2208 Ioo (-R) R, f =O[atTop] (a ^ \u00b7), \u2203 a \u2208 Ioo 0 R, f =O[atTop] (a ^ \u00b7),\n        \u2203 a < R, \u2203 (C : _) (_ : 0 < C \u2228 0 < R), \u2200 n, |f n| \u2264 C * a ^ n,\n        \u2203 a \u2208 Ioo 0 R, \u2203 C > 0, \u2200 n, |f n| \u2264 C * a ^ n, \u2203 a < R, \u2200\u1da0 n in atTop, |f n| \u2264 a ^ n,\n        \u2203 a \u2208 Ioo 0 R, \u2200\u1da0 n in atTop, |f n| \u2264 a ^ n]", "start": [112, 1], "end": [183, 14], "kind": "commanddeclaration"}, {"full_name": "isLittleO_pow_const_const_pow_of_one_lt", "code": "theorem isLittleO_pow_const_const_pow_of_one_lt {R : Type*} [NormedRing R] (k : \u2115) {r : \u211d}\n    (hr : 1 < r) : (fun n \u21a6 (n : R) ^ k : \u2115 \u2192 R) =o[atTop] fun n \u21a6 r ^ n", "start": [186, 1], "end": [202, 99], "kind": "commanddeclaration"}, {"full_name": "isLittleO_coe_const_pow_of_one_lt", "code": "theorem isLittleO_coe_const_pow_of_one_lt {R : Type*} [NormedRing R] {r : \u211d} (hr : 1 < r) :\n    ((\u2191) : \u2115 \u2192 R) =o[atTop] fun n \u21a6 r ^ n", "start": [205, 1], "end": [208, 81], "kind": "commanddeclaration"}, {"full_name": "isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt", "code": "theorem isLittleO_pow_const_mul_const_pow_const_pow_of_norm_lt {R : Type*} [NormedRing R] (k : \u2115)\n    {r\u2081 : R} {r\u2082 : \u211d} (h : \u2016r\u2081\u2016 < r\u2082) :\n    (fun n \u21a6 (n : R) ^ k * r\u2081 ^ n : \u2115 \u2192 R) =o[atTop] fun n \u21a6 r\u2082 ^ n", "start": [211, 1], "end": [223, 69], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_const_div_const_pow_of_one_lt", "code": "theorem tendsto_pow_const_div_const_pow_of_one_lt (k : \u2115) {r : \u211d} (hr : 1 < r) :\n    Tendsto (fun n \u21a6 (n : \u211d) ^ k / r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [226, 1], "end": [228, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_const_mul_const_pow_of_abs_lt_one", "code": "theorem tendsto_pow_const_mul_const_pow_of_abs_lt_one (k : \u2115) {r : \u211d} (hr : |r| < 1) :\n    Tendsto (fun n \u21a6 (n : \u211d) ^ k * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [231, 1], "end": [239, 79], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_const_mul_const_pow_of_lt_one", "code": "theorem tendsto_pow_const_mul_const_pow_of_lt_one (k : \u2115) {r : \u211d} (hr : 0 \u2264 r) (h'r : r < 1) :\n    Tendsto (fun n \u21a6 (n : \u211d) ^ k * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [242, 1], "end": [247, 96], "kind": "commanddeclaration"}, {"full_name": "tendsto_self_mul_const_pow_of_abs_lt_one", "code": "theorem tendsto_self_mul_const_pow_of_abs_lt_one {r : \u211d} (hr : |r| < 1) :\n    Tendsto (fun n \u21a6 n * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [250, 1], "end": [253, 80], "kind": "commanddeclaration"}, {"full_name": "tendsto_self_mul_const_pow_of_lt_one", "code": "theorem tendsto_self_mul_const_pow_of_lt_one {r : \u211d} (hr : 0 \u2264 r) (h'r : r < 1) :\n    Tendsto (fun n \u21a6 n * r ^ n : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [256, 1], "end": [260, 80], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_nhds_0_of_norm_lt_1", "code": "theorem tendsto_pow_atTop_nhds_0_of_norm_lt_1 {R : Type*} [NormedRing R] {x : R} (h : \u2016x\u2016 < 1) :\n    Tendsto (fun n : \u2115 \u21a6 x ^ n) atTop (\ud835\udcdd 0)", "start": [263, 1], "end": [267, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_atTop_nhds_0_of_abs_lt_1", "code": "theorem tendsto_pow_atTop_nhds_0_of_abs_lt_1 {r : \u211d} (h : |r| < 1) :\n    Tendsto (fun n : \u2115 \u21a6 r ^ n) atTop (\ud835\udcdd 0)", "start": [270, 1], "end": [272, 42], "kind": "commanddeclaration"}, {"full_name": "hasSum_geometric_of_norm_lt_1", "code": "theorem hasSum_geometric_of_norm_lt_1 (h : \u2016\u03be\u2016 < 1) : HasSum (fun n : \u2115 \u21a6 \u03be ^ n) (1 - \u03be)\u207b\u00b9", "start": [282, 1], "end": [290, 66], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_of_norm_lt_1", "code": "theorem summable_geometric_of_norm_lt_1 (h : \u2016\u03be\u2016 < 1) : Summable fun n : \u2115 \u21a6 \u03be ^ n", "start": [293, 1], "end": [294, 39], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_of_norm_lt_1", "code": "theorem tsum_geometric_of_norm_lt_1 (h : \u2016\u03be\u2016 < 1) : \u2211' n : \u2115, \u03be ^ n = (1 - \u03be)\u207b\u00b9", "start": [297, 1], "end": [298, 44], "kind": "commanddeclaration"}, {"full_name": "hasSum_geometric_of_abs_lt_1", "code": "theorem hasSum_geometric_of_abs_lt_1 {r : \u211d} (h : |r| < 1) : HasSum (fun n : \u2115 \u21a6 r ^ n) (1 - r)\u207b\u00b9", "start": [301, 1], "end": [302, 34], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_of_abs_lt_1", "code": "theorem summable_geometric_of_abs_lt_1 {r : \u211d} (h : |r| < 1) : Summable fun n : \u2115 \u21a6 r ^ n", "start": [305, 1], "end": [306, 36], "kind": "commanddeclaration"}, {"full_name": "tsum_geometric_of_abs_lt_1", "code": "theorem tsum_geometric_of_abs_lt_1 {r : \u211d} (h : |r| < 1) : \u2211' n : \u2115, r ^ n = (1 - r)\u207b\u00b9", "start": [309, 1], "end": [310, 32], "kind": "commanddeclaration"}, {"full_name": "summable_geometric_iff_norm_lt_1", "code": "@[simp]\ntheorem summable_geometric_iff_norm_lt_1 : (Summable fun n : \u2115 \u21a6 \u03be ^ n) \u2194 \u2016\u03be\u2016 < 1", "start": [313, 1], "end": [322, 42], "kind": "commanddeclaration"}, {"full_name": "summable_norm_pow_mul_geometric_of_norm_lt_1", "code": "theorem summable_norm_pow_mul_geometric_of_norm_lt_1 {R : Type*} [NormedRing R] (k : \u2115) {r : R}\n    (hr : \u2016r\u2016 < 1) : Summable fun n : \u2115 \u21a6 \u2016((n : R) ^ k * r ^ n : R)\u2016", "start": [329, 1], "end": [333, 85], "kind": "commanddeclaration"}, {"full_name": "summable_pow_mul_geometric_of_norm_lt_1", "code": "theorem summable_pow_mul_geometric_of_norm_lt_1 {R : Type*} [NormedRing R] [CompleteSpace R]\n    (k : \u2115) {r : R} (hr : \u2016r\u2016 < 1) : Summable (fun n \u21a6 (n : R) ^ k * r ^ n : \u2115 \u2192 R)", "start": [336, 1], "end": [338, 81], "kind": "commanddeclaration"}, {"full_name": "hasSum_coe_mul_geometric_of_norm_lt_1", "code": "theorem hasSum_coe_mul_geometric_of_norm_lt_1 {\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] {r : \ud835\udd5c}\n    (hr : \u2016r\u2016 < 1) : HasSum (fun n \u21a6 n * r ^ n : \u2115 \u2192 \ud835\udd5c) (r / (1 - r) ^ 2)", "start": [341, 1], "end": [360, 95], "kind": "commanddeclaration"}, {"full_name": "tsum_coe_mul_geometric_of_norm_lt_1", "code": "theorem tsum_coe_mul_geometric_of_norm_lt_1 {\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] {r : \ud835\udd5c}\n    (hr : \u2016r\u2016 < 1) : (\u2211' n : \u2115, n * r ^ n : \ud835\udd5c) = r / (1 - r) ^ 2", "start": [363, 1], "end": [366, 53], "kind": "commanddeclaration"}, {"full_name": "SeminormedAddCommGroup.cauchySeq_of_le_geometric", "code": "nonrec theorem SeminormedAddCommGroup.cauchySeq_of_le_geometric {C : \u211d} {r : \u211d} (hr : r < 1)\n    {u : \u2115 \u2192 \u03b1} (h : \u2200 n, \u2016u n - u (n + 1)\u2016 \u2264 C * r ^ n) : CauchySeq u", "start": [375, 1], "end": [377, 69], "kind": "commanddeclaration"}, {"full_name": "dist_partial_sum_le_of_le_geometric", "code": "theorem dist_partial_sum_le_of_le_geometric (hf : \u2200 n, \u2016f n\u2016 \u2264 C * r ^ n) (n : \u2115) :\n    dist (\u2211 i in range n, f i) (\u2211 i in range (n + 1), f i) \u2264 C * r ^ n", "start": [380, 1], "end": [383, 13], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_finset_of_geometric_bound", "code": "theorem cauchySeq_finset_of_geometric_bound (hr : r < 1) (hf : \u2200 n, \u2016f n\u2016 \u2264 C * r ^ n) :\n    CauchySeq fun s : Finset \u2115 \u21a6 \u2211 x in s, f x", "start": [386, 1], "end": [391, 89], "kind": "commanddeclaration"}, {"full_name": "norm_sub_le_of_geometric_bound_of_hasSum", "code": "theorem norm_sub_le_of_geometric_bound_of_hasSum (hr : r < 1) (hf : \u2200 n, \u2016f n\u2016 \u2264 C * r ^ n) {a : \u03b1}\n    (ha : HasSum f a) (n : \u2115) : \u2016(\u2211 x in Finset.range n, f x) - a\u2016 \u2264 C * r ^ n / (1 - r)", "start": [394, 1], "end": [401, 27], "kind": "commanddeclaration"}, {"full_name": "dist_partial_sum", "code": "@[simp]\ntheorem dist_partial_sum (u : \u2115 \u2192 \u03b1) (n : \u2115) :\n    dist (\u2211 k in range (n + 1), u k) (\u2211 k in range n, u k) = \u2016u n\u2016", "start": [404, 1], "end": [407, 38], "kind": "commanddeclaration"}, {"full_name": "dist_partial_sum'", "code": "@[simp]\ntheorem dist_partial_sum' (u : \u2115 \u2192 \u03b1) (n : \u2115) :\n    dist (\u2211 k in range n, u k) (\u2211 k in range (n + 1), u k) = \u2016u n\u2016", "start": [410, 1], "end": [413, 39], "kind": "commanddeclaration"}, {"full_name": "cauchy_series_of_le_geometric", "code": "theorem cauchy_series_of_le_geometric {C : \u211d} {u : \u2115 \u2192 \u03b1} {r : \u211d} (hr : r < 1)\n    (h : \u2200 n, \u2016u n\u2016 \u2264 C * r ^ n) : CauchySeq fun n \u21a6 \u2211 k in range n, u k", "start": [416, 1], "end": [418, 49], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.cauchy_series_of_le_geometric'", "code": "theorem NormedAddCommGroup.cauchy_series_of_le_geometric' {C : \u211d} {u : \u2115 \u2192 \u03b1} {r : \u211d} (hr : r < 1)\n    (h : \u2200 n, \u2016u n\u2016 \u2264 C * r ^ n) : CauchySeq fun n \u21a6 \u2211 k in range (n + 1), u k", "start": [421, 1], "end": [423, 79], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.cauchy_series_of_le_geometric''", "code": "theorem NormedAddCommGroup.cauchy_series_of_le_geometric'' {C : \u211d} {u : \u2115 \u2192 \u03b1} {N : \u2115} {r : \u211d}\n    (hr\u2080 : 0 < r) (hr\u2081 : r < 1) (h : \u2200 n \u2265 N, \u2016u n\u2016 \u2264 C * r ^ n) :\n    CauchySeq fun n \u21a6 \u2211 k in range (n + 1), u k", "start": [426, 1], "end": [444, 16], "kind": "commanddeclaration"}, {"full_name": "NormedRing.summable_geometric_of_norm_lt_1", "code": "theorem NormedRing.summable_geometric_of_norm_lt_1 (x : R) (h : \u2016x\u2016 < 1) :\n    Summable fun n : \u2115 \u21a6 x ^ n", "start": [455, 1], "end": [462, 33], "kind": "commanddeclaration"}, {"full_name": "NormedRing.tsum_geometric_of_norm_lt_1", "code": "theorem NormedRing.tsum_geometric_of_norm_lt_1 (x : R) (h : \u2016x\u2016 < 1) :\n    \u2016\u2211' n : \u2115, x ^ n\u2016 \u2264 \u2016(1 : R)\u2016 - 1 + (1 - \u2016x\u2016)\u207b\u00b9", "start": [465, 1], "end": [476, 11], "kind": "commanddeclaration"}, {"full_name": "geom_series_mul_neg", "code": "theorem geom_series_mul_neg (x : R) (h : \u2016x\u2016 < 1) : (\u2211' i : \u2115, x ^ i) * (1 - x) = 1", "start": [479, 1], "end": [485, 42], "kind": "commanddeclaration"}, {"full_name": "mul_neg_geom_series", "code": "theorem mul_neg_geom_series (x : R) (h : \u2016x\u2016 < 1) : ((1 - x) * \u2211' i : \u2115, x ^ i) = 1", "start": [488, 1], "end": [494, 42], "kind": "commanddeclaration"}, {"full_name": "summable_of_ratio_norm_eventually_le", "code": "theorem summable_of_ratio_norm_eventually_le {\u03b1 : Type*} [SeminormedAddCommGroup \u03b1]\n    [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1} {r : \u211d} (hr\u2081 : r < 1)\n    (h : \u2200\u1da0 n in atTop, \u2016f (n + 1)\u2016 \u2264 r * \u2016f n\u2016) : Summable f", "start": [502, 1], "end": [521, 88], "kind": "commanddeclaration"}, {"full_name": "summable_of_ratio_test_tendsto_lt_one", "code": "theorem summable_of_ratio_test_tendsto_lt_one {\u03b1 : Type*} [NormedAddCommGroup \u03b1] [CompleteSpace \u03b1]\n    {f : \u2115 \u2192 \u03b1} {l : \u211d} (hl\u2081 : l < 1) (hf : \u2200\u1da0 n in atTop, f n \u2260 0)\n    (h : Tendsto (fun n \u21a6 \u2016f (n + 1)\u2016 / \u2016f n\u2016) atTop (\ud835\udcdd l)) : Summable f", "start": [524, 1], "end": [530, 43], "kind": "commanddeclaration"}, {"full_name": "not_summable_of_ratio_norm_eventually_ge", "code": "theorem not_summable_of_ratio_norm_eventually_ge {\u03b1 : Type*} [SeminormedAddCommGroup \u03b1] {f : \u2115 \u2192 \u03b1}\n    {r : \u211d} (hr : 1 < r) (hf : \u2203\u1da0 n in atTop, \u2016f n\u2016 \u2260 0)\n    (h : \u2200\u1da0 n in atTop, r * \u2016f n\u2016 \u2264 \u2016f (n + 1)\u2016) : \u00acSummable f", "start": [533, 1], "end": [552, 11], "kind": "commanddeclaration"}, {"full_name": "not_summable_of_ratio_test_tendsto_gt_one", "code": "theorem not_summable_of_ratio_test_tendsto_gt_one {\u03b1 : Type*} [SeminormedAddCommGroup \u03b1]\n    {f : \u2115 \u2192 \u03b1} {l : \u211d} (hl : 1 < l) (h : Tendsto (fun n \u21a6 \u2016f (n + 1)\u2016 / \u2016f n\u2016) atTop (\ud835\udcdd l)) :\n    \u00acSummable f", "start": [555, 1], "end": [565, 62], "kind": "commanddeclaration"}, {"full_name": "Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded", "code": "theorem Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) (hgb : \u2200 n, \u2016\u2211 i in range n, z i\u2016 \u2264 b) :\n    CauchySeq fun n \u21a6 \u2211 i in range (n + 1), f i \u2022 z i", "start": [577, 1], "end": [593, 60], "kind": "commanddeclaration"}, {"full_name": "Antitone.cauchySeq_series_mul_of_tendsto_zero_of_bounded", "code": "theorem Antitone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) (hzb : \u2200 n, \u2016\u2211 i in range n, z i\u2016 \u2264 b) :\n    CauchySeq fun n \u21a6 \u2211 i in range (n + 1), f i \u2022 z i", "start": [596, 1], "end": [606, 7], "kind": "commanddeclaration"}, {"full_name": "norm_sum_neg_one_pow_le", "code": "theorem norm_sum_neg_one_pow_le (n : \u2115) : \u2016\u2211 i in range n, (-1 : \u211d) ^ i\u2016 \u2264 1", "start": [609, 1], "end": [611, 25], "kind": "commanddeclaration"}, {"full_name": "Monotone.cauchySeq_alternating_series_of_tendsto_zero", "code": "theorem Monotone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) : CauchySeq fun n \u21a6 \u2211 i in range (n + 1), (-1) ^ i * f i", "start": [614, 1], "end": [619, 88], "kind": "commanddeclaration"}, {"full_name": "Monotone.tendsto_alternating_series_of_tendsto_zero", "code": "theorem Monotone.tendsto_alternating_series_of_tendsto_zero (hfa : Monotone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) :\n    \u2203 l, Tendsto (fun n \u21a6 \u2211 i in range (n + 1), (-1) ^ i * f i) atTop (\ud835\udcdd l)", "start": [622, 1], "end": [626, 88], "kind": "commanddeclaration"}, {"full_name": "Antitone.cauchySeq_alternating_series_of_tendsto_zero", "code": "theorem Antitone.cauchySeq_alternating_series_of_tendsto_zero (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) : CauchySeq fun n \u21a6 \u2211 i in range (n + 1), (-1) ^ i * f i", "start": [629, 1], "end": [634, 88], "kind": "commanddeclaration"}, {"full_name": "Antitone.tendsto_alternating_series_of_tendsto_zero", "code": "theorem Antitone.tendsto_alternating_series_of_tendsto_zero (hfa : Antitone f)\n    (hf0 : Tendsto f atTop (\ud835\udcdd 0)) :\n    \u2203 l, Tendsto (fun n \u21a6 \u2211 i in range (n + 1), (-1) ^ i * f i) atTop (\ud835\udcdd l)", "start": [637, 1], "end": [641, 88], "kind": "commanddeclaration"}, {"full_name": "Real.summable_pow_div_factorial", "code": "theorem Real.summable_pow_div_factorial (x : \u211d) : Summable (fun n \u21a6 x ^ n / n ! : \u2115 \u2192 \u211d)", "start": [650, 1], "end": [671, 36], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_pow_div_factorial_atTop", "code": "theorem Real.tendsto_pow_div_factorial_atTop (x : \u211d) :\n    Tendsto (fun n \u21a6 x ^ n / n ! : \u2115 \u2192 \u211d) atTop (\ud835\udcdd 0)", "start": [674, 1], "end": [676, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/Basic.lean", "imports": ["Mathlib/Topology/Instances/RealVectorSpace.lean", "Mathlib/Data/IsROrC/Basic.lean", "Mathlib/Topology/Algebra/InfiniteSum/Module.lean", "Mathlib/Data/Complex/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Complex/Order.lean", "Mathlib/Data/Complex/Module.lean"], "premises": [{"full_name": "Complex.norm_eq_abs", "code": "@[simp]\ntheorem norm_eq_abs (z : \u2102) : \u2016z\u2016 = abs z", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_exp_ofReal_mul_I", "code": "theorem norm_exp_ofReal_mul_I (t : \u211d) : \u2016exp (t * I)\u2016 = 1", "start": [55, 1], "end": [56, 48], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.complexToReal", "code": "instance (priority := 900) _root_.NormedSpace.complexToReal : NormedSpace \u211d E :=\n  NormedSpace.restrictScalars \u211d \u2102 E", "start": [84, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_eq", "code": "theorem dist_eq (z w : \u2102) : dist z w = abs (z - w)", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_eq_re_im", "code": "theorem dist_eq_re_im (z w : \u2102) : dist z w = Real.sqrt ((z.re - w.re) ^ 2 + (z.im - w.im) ^ 2)", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_mk", "code": "@[simp]\ntheorem dist_mk (x\u2081 y\u2081 x\u2082 y\u2082 : \u211d) :\n    dist (mk x\u2081 y\u2081) (mk x\u2082 y\u2082) = Real.sqrt ((x\u2081 - x\u2082) ^ 2 + (y\u2081 - y\u2082) ^ 2)", "start": [98, 1], "end": [101, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_of_re_eq", "code": "theorem dist_of_re_eq {z w : \u2102} (h : z.re = w.re) : dist z w = dist z.im w.im", "start": [104, 1], "end": [105, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_of_re_eq", "code": "theorem nndist_of_re_eq {z w : \u2102} (h : z.re = w.re) : nndist z w = nndist z.im w.im", "start": [108, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.edist_of_re_eq", "code": "theorem edist_of_re_eq {z w : \u2102} (h : z.re = w.re) : edist z w = edist z.im w.im", "start": [112, 1], "end": [113, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_of_im_eq", "code": "theorem dist_of_im_eq {z w : \u2102} (h : z.im = w.im) : dist z w = dist z.re w.re", "start": [116, 1], "end": [117, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_of_im_eq", "code": "theorem nndist_of_im_eq {z w : \u2102} (h : z.im = w.im) : nndist z w = nndist z.re w.re", "start": [120, 1], "end": [121, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.edist_of_im_eq", "code": "theorem edist_of_im_eq {z w : \u2102} (h : z.im = w.im) : edist z w = edist z.re w.re", "start": [124, 1], "end": [125, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_conj_self", "code": "theorem dist_conj_self (z : \u2102) : dist (conj z) z = 2 * |z.im|", "start": [128, 1], "end": [130, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_conj_self", "code": "theorem nndist_conj_self (z : \u2102) : nndist (conj z) z = 2 * Real.nnabs z.im", "start": [133, 1], "end": [134, 101], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_self_conj", "code": "theorem dist_self_conj (z : \u2102) : dist z (conj z) = 2 * |z.im|", "start": [137, 1], "end": [137, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_self_conj", "code": "theorem nndist_self_conj (z : \u2102) : nndist z (conj z) = 2 * Real.nnabs z.im", "start": [140, 1], "end": [141, 37], "kind": "commanddeclaration"}, {"full_name": "Complex.comap_abs_nhds_zero", "code": "@[simp 1100]\ntheorem comap_abs_nhds_zero : comap abs (\ud835\udcdd 0) = \ud835\udcdd 0", "start": [144, 1], "end": [146, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_real", "code": "theorem norm_real (r : \u211d) : \u2016(r : \u2102)\u2016 = \u2016r\u2016", "start": [149, 1], "end": [150, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_rat", "code": "@[simp 1100]\ntheorem norm_rat (r : \u211a) : \u2016(r : \u2102)\u2016 = |(r : \u211d)|", "start": [153, 1], "end": [156, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_nat", "code": "@[simp 1100]\ntheorem norm_nat (n : \u2115) : \u2016(n : \u2102)\u2016 = n", "start": [159, 1], "end": [161, 15], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_int", "code": "@[simp 1100]\ntheorem norm_int {n : \u2124} : \u2016(n : \u2102)\u2016 = |(n : \u211d)|", "start": [164, 1], "end": [165, 74], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_int_of_nonneg", "code": "theorem norm_int_of_nonneg {n : \u2124} (hn : 0 \u2264 n) : \u2016(n : \u2102)\u2016 = n", "start": [168, 1], "end": [169, 57], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_abs", "code": "@[continuity]\ntheorem continuous_abs : Continuous abs", "start": [172, 1], "end": [174, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_normSq", "code": "@[continuity]\ntheorem continuous_normSq : Continuous normSq", "start": [177, 1], "end": [179, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.nnnorm_real", "code": "@[simp, norm_cast]\ntheorem nnnorm_real (r : \u211d) : \u2016(r : \u2102)\u2016\u208a = \u2016r\u2016\u208a", "start": [182, 1], "end": [184, 29], "kind": "commanddeclaration"}, {"full_name": "Complex.nnnorm_nat", "code": "@[simp, norm_cast]\ntheorem nnnorm_nat (n : \u2115) : \u2016(n : \u2102)\u2016\u208a = n", "start": [187, 1], "end": [189, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.nnnorm_int", "code": "@[simp, norm_cast]\ntheorem nnnorm_int (n : \u2124) : \u2016(n : \u2102)\u2016\u208a = \u2016n\u2016\u208a", "start": [192, 1], "end": [194, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.nnnorm_eq_one_of_pow_eq_one", "code": "theorem nnnorm_eq_one_of_pow_eq_one {\u03b6 : \u2102} {n : \u2115} (h : \u03b6 ^ n = 1) (hn : n \u2260 0) : \u2016\u03b6\u2016\u208a = 1", "start": [197, 1], "end": [199, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eq_one_of_pow_eq_one", "code": "theorem norm_eq_one_of_pow_eq_one {\u03b6 : \u2102} {n : \u2115} (h : \u03b6 ^ n = 1) (hn : n \u2260 0) : \u2016\u03b6\u2016 = 1", "start": [202, 1], "end": [203, 59], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProd_apply_le", "code": "theorem equivRealProd_apply_le (z : \u2102) : \u2016equivRealProd z\u2016 \u2264 abs z", "start": [206, 1], "end": [207, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProd_apply_le'", "code": "theorem equivRealProd_apply_le' (z : \u2102) : \u2016equivRealProd z\u2016 \u2264 1 * abs z", "start": [210, 1], "end": [211, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.lipschitz_equivRealProd", "code": "theorem lipschitz_equivRealProd : LipschitzWith 1 equivRealProd", "start": [214, 1], "end": [215, 93], "kind": "commanddeclaration"}, {"full_name": "Complex.antilipschitz_equivRealProd", "code": "theorem antilipschitz_equivRealProd : AntilipschitzWith (NNReal.sqrt 2) equivRealProd", "start": [218, 1], "end": [220, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.uniformEmbedding_equivRealProd", "code": "theorem uniformEmbedding_equivRealProd : UniformEmbedding equivRealProd", "start": [223, 1], "end": [224, 89], "kind": "commanddeclaration"}, {"full_name": "Complex.equivRealProdClm", "code": "@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdClm : \u2102 \u2243L[\u211d] \u211d \u00d7 \u211d :=\n  equivRealProdLm.toContinuousLinearEquivOfBounds 1 (Real.sqrt 2) equivRealProd_apply_le' fun p =>\n    abs_le_sqrt_two_mul_max (equivRealProd.symm p)", "start": [230, 1], "end": [234, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_abs_cocompact_atTop", "code": "theorem tendsto_abs_cocompact_atTop : Tendsto abs (cocompact \u2102) atTop", "start": [240, 1], "end": [242, 31], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_normSq_cocompact_atTop", "code": "theorem tendsto_normSq_cocompact_atTop : Tendsto normSq (cocompact \u2102) atTop", "start": [245, 1], "end": [248, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.reClm", "code": "def reClm : \u2102 \u2192L[\u211d] \u211d :=\n  reLm.mkContinuous 1 fun x => by simp [abs_re_le_abs]", "start": [253, 1], "end": [255, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_re", "code": "@[continuity]\ntheorem continuous_re : Continuous re", "start": [258, 1], "end": [260, 19], "kind": "commanddeclaration"}, {"full_name": "Complex.reClm_coe", "code": "@[simp]\ntheorem reClm_coe : (reClm : \u2102 \u2192\u2097[\u211d] \u211d) = reLm", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.reClm_apply", "code": "@[simp]\ntheorem reClm_apply (z : \u2102) : (reClm : \u2102 \u2192 \u211d) z = z.re", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.imClm", "code": "def imClm : \u2102 \u2192L[\u211d] \u211d :=\n  imLm.mkContinuous 1 fun x => by simp [abs_im_le_abs]", "start": [273, 1], "end": [275, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_im", "code": "@[continuity]\ntheorem continuous_im : Continuous im", "start": [278, 1], "end": [280, 19], "kind": "commanddeclaration"}, {"full_name": "Complex.imClm_coe", "code": "@[simp]\ntheorem imClm_coe : (imClm : \u2102 \u2192\u2097[\u211d] \u211d) = imLm", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.imClm_apply", "code": "@[simp]\ntheorem imClm_apply (z : \u2102) : (imClm : \u2102 \u2192 \u211d) z = z.im", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.restrictScalars_one_smulRight'", "code": "theorem restrictScalars_one_smulRight' (x : E) :\n    ContinuousLinearMap.restrictScalars \u211d ((1 : \u2102 \u2192L[\u2102] \u2102).smulRight x : \u2102 \u2192L[\u2102] E) =\n      reClm.smulRight x + I \u2022 imClm.smulRight x", "start": [293, 1], "end": [297, 52], "kind": "commanddeclaration"}, {"full_name": "Complex.restrictScalars_one_smulRight", "code": "theorem restrictScalars_one_smulRight (x : \u2102) :\n    ContinuousLinearMap.restrictScalars \u211d ((1 : \u2102 \u2192L[\u2102] \u2102).smulRight x : \u2102 \u2192L[\u2102] \u2102) =\n    x \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)", "start": [300, 1], "end": [305, 17], "kind": "commanddeclaration"}, {"full_name": "Complex.conjLie", "code": "def conjLie : \u2102 \u2243\u2097\u1d62[\u211d] \u2102 :=\n  \u27e8conjAe.toLinearEquiv, abs_conj\u27e9", "start": [308, 1], "end": [310, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.conjLie_apply", "code": "@[simp]\ntheorem conjLie_apply (z : \u2102) : conjLie z = conj z", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conjLie_symm", "code": "@[simp]\ntheorem conjLie_symm : conjLie.symm = conjLie", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.isometry_conj", "code": "theorem isometry_conj : Isometry (conj : \u2102 \u2192 \u2102)", "start": [323, 1], "end": [324, 19], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_conj_conj", "code": "@[simp]\ntheorem dist_conj_conj (z w : \u2102) : dist (conj z) (conj w) = dist z w", "start": [327, 1], "end": [329, 28], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_conj_conj", "code": "@[simp]\ntheorem nndist_conj_conj (z w : \u2102) : nndist (conj z) (conj w) = nndist z w", "start": [332, 1], "end": [334, 30], "kind": "commanddeclaration"}, {"full_name": "Complex.dist_conj_comm", "code": "theorem dist_conj_comm (z w : \u2102) : dist (conj z) w = dist z (conj w)", "start": [337, 1], "end": [338, 35], "kind": "commanddeclaration"}, {"full_name": "Complex.nndist_conj_comm", "code": "theorem nndist_conj_comm (z w : \u2102) : nndist (conj z) w = nndist z (conj w)", "start": [341, 1], "end": [342, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_conj", "code": "@[continuity]\ntheorem continuous_conj : Continuous (conj : \u2102 \u2192 \u2102)", "start": [348, 1], "end": [350, 18], "kind": "commanddeclaration"}, {"full_name": "Complex.ringHom_eq_id_or_conj_of_continuous", "code": "theorem ringHom_eq_id_or_conj_of_continuous {f : \u2102 \u2192+* \u2102} (hf : Continuous f) :\n    f = RingHom.id \u2102 \u2228 f = conj", "start": [353, 1], "end": [357, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.conjCle", "code": "def conjCle : \u2102 \u2243L[\u211d] \u2102 :=\n  conjLie", "start": [360, 1], "end": [362, 10], "kind": "commanddeclaration"}, {"full_name": "Complex.conjCle_coe", "code": "@[simp]\ntheorem conjCle_coe : conjCle.toLinearEquiv = conjAe.toLinearEquiv", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conjCle_apply", "code": "@[simp]\ntheorem conjCle_apply (z : \u2102) : conjCle z = conj z", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealLi", "code": "def ofRealLi : \u211d \u2192\u2097\u1d62[\u211d] \u2102 :=\n  \u27e8ofRealAm.toLinearMap, norm_real\u27e9", "start": [375, 1], "end": [377, 36], "kind": "commanddeclaration"}, {"full_name": "Complex.isometry_ofReal", "code": "theorem isometry_ofReal : Isometry ((\u2191) : \u211d \u2192 \u2102)", "start": [380, 1], "end": [381, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.continuous_ofReal", "code": "@[continuity]\ntheorem continuous_ofReal : Continuous ((\u2191) : \u211d \u2192 \u2102)", "start": [384, 1], "end": [386, 22], "kind": "commanddeclaration"}, {"full_name": "Complex.ringHom_eq_ofReal_of_continuous", "code": "theorem ringHom_eq_ofReal_of_continuous {f : \u211d \u2192+* \u2102} (h : Continuous f) : f = Complex.ofReal", "start": [389, 1], "end": [392, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealClm", "code": "def ofRealClm : \u211d \u2192L[\u211d] \u2102 :=\n  ofRealLi.toContinuousLinearMap", "start": [395, 1], "end": [397, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealClm_coe", "code": "@[simp]\ntheorem ofRealClm_coe : (ofRealClm : \u211d \u2192\u2097[\u211d] \u2102) = ofRealAm.toLinearMap", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.ofRealClm_apply", "code": "@[simp]\ntheorem ofRealClm_apply (x : \u211d) : ofRealClm x = x", "start": [405, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_eq_complex_re", "code": "theorem _root_.IsROrC.re_eq_complex_re : \u21d1(IsROrC.re : \u2102 \u2192+ \u211d) = Complex.re", "start": [429, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_eq_complex_im", "code": "theorem _root_.IsROrC.im_eq_complex_im : \u21d1(IsROrC.im : \u2102 \u2192+ \u211d) = Complex.im", "start": [433, 1], "end": [434, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.eq_coe_norm_of_nonneg", "code": "theorem eq_coe_norm_of_nonneg {z : \u2102} (hz : 0 \u2264 z) : z = \u2191\u2016z\u2016", "start": [441, 1], "end": [443, 71], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_to_complex", "code": "@[simp]\ntheorem re_to_complex {x : \u2102} : reC x = x.re", "start": [459, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_to_complex", "code": "@[simp]\ntheorem im_to_complex {x : \u2102} : imC x = x.im", "start": [464, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.I_to_complex", "code": "@[simp]\ntheorem I_to_complex : IC = Complex.I", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.normSq_to_complex", "code": "@[simp]\ntheorem normSq_to_complex {x : \u2102} : norm_sqC x = Complex.normSq x", "start": [475, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_conj", "code": "@[simp]\ntheorem hasSum_conj {f : \u03b1 \u2192 \ud835\udd5c} {x : \ud835\udd5c} : HasSum (fun x => conj (f x)) x \u2194 HasSum f (conj x)", "start": [484, 1], "end": [486, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_conj'", "code": "theorem hasSum_conj' {f : \u03b1 \u2192 \ud835\udd5c} {x : \ud835\udd5c} : HasSum (fun x => conj (f x)) (conj x) \u2194 HasSum f x", "start": [489, 1], "end": [490, 18], "kind": "commanddeclaration"}, {"full_name": "IsROrC.summable_conj", "code": "@[simp]\ntheorem summable_conj {f : \u03b1 \u2192 \ud835\udd5c} : (Summable fun x => conj (f x)) \u2194 Summable f", "start": [493, 1], "end": [495, 20], "kind": "commanddeclaration"}, {"full_name": "IsROrC.conj_tsum", "code": "theorem conj_tsum (f : \u03b1 \u2192 \ud835\udd5c) : conj (\u2211' a, f a) = \u2211' a, conj (f a)", "start": [500, 1], "end": [501, 12], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_ofReal", "code": "@[simp, norm_cast]\ntheorem hasSum_ofReal {f : \u03b1 \u2192 \u211d} {x : \u211d} : HasSum (fun x => (f x : \ud835\udd5c)) x \u2194 HasSum f x", "start": [506, 1], "end": [509, 22], "kind": "commanddeclaration"}, {"full_name": "IsROrC.summable_ofReal", "code": "@[simp, norm_cast]\ntheorem summable_ofReal {f : \u03b1 \u2192 \u211d} : (Summable fun x => (f x : \ud835\udd5c)) \u2194 Summable f", "start": [512, 1], "end": [515, 24], "kind": "commanddeclaration"}, {"full_name": "IsROrC.ofReal_tsum", "code": "@[norm_cast]\ntheorem ofReal_tsum (f : \u03b1 \u2192 \u211d) : (\u2191(\u2211' a, f a) : \ud835\udd5c) = \u2211' a, (f a : \ud835\udd5c)", "start": [518, 1], "end": [523, 81], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_re", "code": "theorem hasSum_re {f : \u03b1 \u2192 \ud835\udd5c} {x : \ud835\udd5c} (h : HasSum f x) : HasSum (fun x => re (f x)) (re x)", "start": [526, 1], "end": [527, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_im", "code": "theorem hasSum_im {f : \u03b1 \u2192 \ud835\udd5c} {x : \ud835\udd5c} (h : HasSum f x) : HasSum (fun x => im (f x)) (im x)", "start": [530, 1], "end": [531, 17], "kind": "commanddeclaration"}, {"full_name": "IsROrC.re_tsum", "code": "theorem re_tsum {f : \u03b1 \u2192 \ud835\udd5c} (h : Summable f) : re (\u2211' a, f a) = \u2211' a, re (f a)", "start": [534, 1], "end": [535, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.im_tsum", "code": "theorem im_tsum {f : \u03b1 \u2192 \ud835\udd5c} (h : Summable f) : im (\u2211' a, f a) = \u2211' a, im (f a)", "start": [538, 1], "end": [539, 19], "kind": "commanddeclaration"}, {"full_name": "IsROrC.hasSum_iff", "code": "theorem hasSum_iff (f : \u03b1 \u2192 \ud835\udd5c) (c : \ud835\udd5c) :\n    HasSum f c \u2194 HasSum (fun x => re (f x)) (re c) \u2227 HasSum (fun x => im (f x)) (im c)", "start": [544, 1], "end": [549, 76], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_conj", "code": "theorem hasSum_conj {f : \u03b1 \u2192 \u2102} {x : \u2102} : HasSum (fun x => conj (f x)) x \u2194 HasSum f (conj x)", "start": [574, 1], "end": [575, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_conj'", "code": "theorem hasSum_conj' {f : \u03b1 \u2192 \u2102} {x : \u2102} : HasSum (fun x => conj (f x)) (conj x) \u2194 HasSum f x", "start": [578, 1], "end": [579, 24], "kind": "commanddeclaration"}, {"full_name": "Complex.summable_conj", "code": "theorem summable_conj {f : \u03b1 \u2192 \u2102} : (Summable fun x => conj (f x)) \u2194 Summable f", "start": [583, 1], "end": [584, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_tsum", "code": "theorem conj_tsum (f : \u03b1 \u2192 \u2102) : conj (\u2211' a, f a) = \u2211' a, conj (f a)", "start": [587, 1], "end": [588, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_ofReal", "code": "@[simp, norm_cast]\ntheorem hasSum_ofReal {f : \u03b1 \u2192 \u211d} {x : \u211d} : HasSum (fun x => (f x : \u2102)) x \u2194 HasSum f x", "start": [591, 1], "end": [593, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.summable_ofReal", "code": "@[simp, norm_cast]\ntheorem summable_ofReal {f : \u03b1 \u2192 \u211d} : (Summable fun x => (f x : \u2102)) \u2194 Summable f", "start": [596, 1], "end": [598, 27], "kind": "commanddeclaration"}, {"full_name": "Complex.ofReal_tsum", "code": "@[norm_cast]\ntheorem ofReal_tsum (f : \u03b1 \u2192 \u211d) : (\u2191(\u2211' a, f a) : \u2102) = \u2211' a, \u2191(f a)", "start": [601, 1], "end": [603, 25], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_re", "code": "theorem hasSum_re {f : \u03b1 \u2192 \u2102} {x : \u2102} (h : HasSum f x) : HasSum (fun x => (f x).re) x.re", "start": [606, 1], "end": [607, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_im", "code": "theorem hasSum_im {f : \u03b1 \u2192 \u2102} {x : \u2102} (h : HasSum f x) : HasSum (fun x => (f x).im) x.im", "start": [610, 1], "end": [611, 23], "kind": "commanddeclaration"}, {"full_name": "Complex.re_tsum", "code": "theorem re_tsum {f : \u03b1 \u2192 \u2102} (h : Summable f) : (\u2211' a, f a).re = \u2211' a, (f a).re", "start": [614, 1], "end": [615, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.im_tsum", "code": "theorem im_tsum {f : \u03b1 \u2192 \u2102} (h : Summable f) : (\u2211' a, f a).im = \u2211' a, (f a).im", "start": [618, 1], "end": [619, 21], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_iff", "code": "theorem hasSum_iff (f : \u03b1 \u2192 \u2102) (c : \u2102) :\n    HasSum f c \u2194 HasSum (fun x => (f x).re) c.re \u2227 HasSum (fun x => (f x).im) c.im", "start": [622, 1], "end": [624, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Asymptotics/Theta.lean", "imports": ["Mathlib/Analysis/Asymptotics/Asymptotics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Asymptotics.IsTheta", "code": "def IsTheta (l : Filter \u03b1) (f : \u03b1 \u2192 E) (g : \u03b1 \u2192 F) : Prop :=\n  IsBigO l f g \u2227 IsBigO l g f", "start": [46, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.antisymm", "code": "theorem IsBigO.antisymm (h\u2081 : f =O[l] g) (h\u2082 : g =O[l] f) : f =\u0398[l] g", "start": [54, 1], "end": [55, 11], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isBigO", "code": "lemma IsTheta.isBigO (h : f =\u0398[l] g) : f =O[l] g := h.1", "start": [58, 1], "end": [58, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Asymptotics.IsTheta.isBigO_symm", "code": "lemma IsTheta.isBigO_symm (h : f =\u0398[l] g) : g =O[l] f := h.2", "start": [60, 1], "end": [60, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Asymptotics.isTheta_refl", "code": "@[refl]\ntheorem isTheta_refl (f : \u03b1 \u2192 E) (l : Filter \u03b1) : f =\u0398[l] f", "start": [62, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_rfl", "code": "theorem isTheta_rfl : f =\u0398[l] f", "start": [67, 1], "end": [68, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.symm", "code": "@[symm]\nnonrec theorem IsTheta.symm (h : f =\u0398[l] g) : g =\u0398[l] f", "start": [71, 1], "end": [73, 9], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_comm", "code": "theorem isTheta_comm : f =\u0398[l] g \u2194 g =\u0398[l] f", "start": [76, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.trans", "code": "@[trans]\ntheorem IsTheta.trans {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (h\u2081 : f =\u0398[l] g) (h\u2082 : g =\u0398[l] k) :\n    f =\u0398[l] k", "start": [80, 1], "end": [83, 37], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsBigO.trans_isTheta", "code": "@[trans]\ntheorem IsBigO.trans_isTheta {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (h\u2081 : f =O[l] g)\n    (h\u2082 : g =\u0398[l] k) : f =O[l] k", "start": [90, 1], "end": [93, 16], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.trans_isBigO", "code": "@[trans]\ntheorem IsTheta.trans_isBigO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (h\u2081 : f =\u0398[l] g)\n    (h\u2082 : g =O[l] k) : f =O[l] k", "start": [100, 1], "end": [103, 16], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsLittleO.trans_isTheta", "code": "@[trans]\ntheorem IsLittleO.trans_isTheta {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {k : \u03b1 \u2192 G'} (h\u2081 : f =o[l] g)\n    (h\u2082 : g =\u0398[l] k) : f =o[l] k", "start": [110, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.trans_isLittleO", "code": "@[trans]\ntheorem IsTheta.trans_isLittleO {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F'} {k : \u03b1 \u2192 G} (h\u2081 : f =\u0398[l] g)\n    (h\u2082 : g =o[l] k) : f =o[l] k", "start": [120, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.trans_eventuallyEq", "code": "@[trans]\ntheorem IsTheta.trans_eventuallyEq {f : \u03b1 \u2192 E} {g\u2081 g\u2082 : \u03b1 \u2192 F} (h : f =\u0398[l] g\u2081) (hg : g\u2081 =\u1da0[l] g\u2082) :\n    f =\u0398[l] g\u2082", "start": [130, 1], "end": [133, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans_isTheta", "code": "@[trans]\ntheorem _root_.Filter.EventuallyEq.trans_isTheta {f\u2081 f\u2082 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : f\u2081 =\u1da0[l] f\u2082)\n    (h : f\u2082 =\u0398[l] g) : f\u2081 =\u0398[l] g", "start": [140, 1], "end": [143, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_norm_left", "code": "@[simp]\ntheorem isTheta_norm_left : (fun x \u21a6 \u2016f' x\u2016) =\u0398[l] g \u2194 f' =\u0398[l] g", "start": [150, 1], "end": [151, 87], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_norm_right", "code": "@[simp]\ntheorem isTheta_norm_right : (f =\u0398[l] fun x \u21a6 \u2016g' x\u2016) \u2194 f =\u0398[l] g'", "start": [154, 1], "end": [155, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.of_norm_left", "code": "alias \u27e8IsTheta.of_norm_left, IsTheta.norm_left\u27e9 := isTheta_norm_left", "start": [158, 1], "end": [158, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.norm_left", "code": "alias \u27e8IsTheta.of_norm_left, IsTheta.norm_left\u27e9 := isTheta_norm_left", "start": [158, 1], "end": [158, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.of_norm_right", "code": "alias \u27e8IsTheta.of_norm_right, IsTheta.norm_right\u27e9 := isTheta_norm_right", "start": [162, 1], "end": [162, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.norm_right", "code": "alias \u27e8IsTheta.of_norm_right, IsTheta.norm_right\u27e9 := isTheta_norm_right", "start": [162, 1], "end": [162, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isTheta_of_norm_eventuallyEq", "code": "theorem isTheta_of_norm_eventuallyEq (h : (fun x \u21a6 \u2016f x\u2016) =\u1da0[l] fun x \u21a6 \u2016g x\u2016) : f =\u0398[l] g", "start": [166, 1], "end": [168, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_of_norm_eventuallyEq'", "code": "theorem isTheta_of_norm_eventuallyEq' {g : \u03b1 \u2192 \u211d} (h : (fun x \u21a6 \u2016f' x\u2016) =\u1da0[l] g) : f' =\u0398[l] g", "start": [171, 1], "end": [172, 83], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isLittleO_congr_left", "code": "theorem IsTheta.isLittleO_congr_left (h : f' =\u0398[l] g') : f' =o[l] k \u2194 g' =o[l] k", "start": [175, 1], "end": [176, 46], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isLittleO_congr_right", "code": "theorem IsTheta.isLittleO_congr_right (h : g' =\u0398[l] k') : f =o[l] g' \u2194 f =o[l] k'", "start": [179, 1], "end": [180, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isBigO_congr_left", "code": "theorem IsTheta.isBigO_congr_left (h : f' =\u0398[l] g') : f' =O[l] k \u2194 g' =O[l] k", "start": [183, 1], "end": [184, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isBigO_congr_right", "code": "theorem IsTheta.isBigO_congr_right (h : g' =\u0398[l] k') : f =O[l] g' \u2194 f =O[l] k'", "start": [187, 1], "end": [188, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.mono", "code": "theorem IsTheta.mono (h : f =\u0398[l] g) (hl : l' \u2264 l) : f =\u0398[l'] g", "start": [191, 1], "end": [192, 29], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.sup", "code": "theorem IsTheta.sup (h : f' =\u0398[l] g') (h' : f' =\u0398[l'] g') : f' =\u0398[l \u2294 l'] g'", "start": [195, 1], "end": [196, 31], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_sup", "code": "@[simp]\ntheorem isTheta_sup : f' =\u0398[l \u2294 l'] g' \u2194 f' =\u0398[l] g' \u2227 f' =\u0398[l'] g'", "start": [199, 1], "end": [201, 75], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.eq_zero_iff", "code": "theorem IsTheta.eq_zero_iff (h : f'' =\u0398[l] g'') : \u2200\u1da0 x in l, f'' x = 0 \u2194 g'' x = 0", "start": [204, 1], "end": [205, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.tendsto_zero_iff", "code": "theorem IsTheta.tendsto_zero_iff (h : f'' =\u0398[l] g'') : Tendsto f'' l (\ud835\udcdd 0) \u2194 Tendsto g'' l (\ud835\udcdd 0)", "start": [208, 1], "end": [209, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.tendsto_norm_atTop_iff", "code": "theorem IsTheta.tendsto_norm_atTop_iff (h : f' =\u0398[l] g') :\n    Tendsto (norm \u2218 f') l atTop \u2194 Tendsto (norm \u2218 g') l atTop", "start": [212, 1], "end": [214, 100], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.isBoundedUnder_le_iff", "code": "theorem IsTheta.isBoundedUnder_le_iff (h : f' =\u0398[l] g') :\n    IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 f') \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l (norm \u2218 g')", "start": [217, 1], "end": [219, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.smul", "code": "theorem IsTheta.smul [NormedSpace \ud835\udd5c E'] [NormedSpace \ud835\udd5c' F'] {f\u2081 : \u03b1 \u2192 \ud835\udd5c} {f\u2082 : \u03b1 \u2192 \ud835\udd5c'} {g\u2081 : \u03b1 \u2192 E'}\n    {g\u2082 : \u03b1 \u2192 F'} (hf : f\u2081 =\u0398[l] f\u2082) (hg : g\u2081 =\u0398[l] g\u2082) :\n    (fun x \u21a6 f\u2081 x \u2022 g\u2081 x) =\u0398[l] fun x \u21a6 f\u2082 x \u2022 g\u2082 x", "start": [222, 1], "end": [225, 35], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.mul", "code": "theorem IsTheta.mul {f\u2081 f\u2082 : \u03b1 \u2192 \ud835\udd5c} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c'} (h\u2081 : f\u2081 =\u0398[l] g\u2081) (h\u2082 : f\u2082 =\u0398[l] g\u2082) :\n    (fun x \u21a6 f\u2081 x * f\u2082 x) =\u0398[l] fun x \u21a6 g\u2081 x * g\u2082 x", "start": [228, 1], "end": [230, 13], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.inv", "code": "theorem IsTheta.inv {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =\u0398[l] g) :\n    (fun x \u21a6 (f x)\u207b\u00b9) =\u0398[l] fun x \u21a6 (g x)\u207b\u00b9", "start": [233, 1], "end": [235, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_inv", "code": "@[simp]\ntheorem isTheta_inv {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} :\n    ((fun x \u21a6 (f x)\u207b\u00b9) =\u0398[l] fun x \u21a6 (g x)\u207b\u00b9) \u2194 f =\u0398[l] g", "start": [238, 1], "end": [241, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.div", "code": "theorem IsTheta.div {f\u2081 f\u2082 : \u03b1 \u2192 \ud835\udd5c} {g\u2081 g\u2082 : \u03b1 \u2192 \ud835\udd5c'} (h\u2081 : f\u2081 =\u0398[l] g\u2081) (h\u2082 : f\u2082 =\u0398[l] g\u2082) :\n    (fun x \u21a6 f\u2081 x / f\u2082 x) =\u0398[l] fun x \u21a6 g\u2081 x / g\u2082 x", "start": [244, 1], "end": [246, 50], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.pow", "code": "theorem IsTheta.pow {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =\u0398[l] g) (n : \u2115) :\n    (fun x \u21a6 f x ^ n) =\u0398[l] fun x \u21a6 g x ^ n", "start": [249, 1], "end": [251, 25], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.zpow", "code": "theorem IsTheta.zpow {f : \u03b1 \u2192 \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c'} (h : f =\u0398[l] g) (n : \u2124) :\n    (fun x \u21a6 f x ^ n) =\u0398[l] fun x \u21a6 g x ^ n", "start": [254, 1], "end": [258, 50], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_const_const", "code": "theorem isTheta_const_const {c\u2081 : E''} {c\u2082 : F''} (h\u2081 : c\u2081 \u2260 0) (h\u2082 : c\u2082 \u2260 0) :\n    (fun _ : \u03b1 \u21a6 c\u2081) =\u0398[l] fun _ \u21a6 c\u2082", "start": [261, 1], "end": [263, 57], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_const_const_iff", "code": "@[simp]\ntheorem isTheta_const_const_iff [NeBot l] {c\u2081 : E''} {c\u2082 : F''} :\n    ((fun _ : \u03b1 \u21a6 c\u2081) =\u0398[l] fun _ \u21a6 c\u2082) \u2194 (c\u2081 = 0 \u2194 c\u2082 = 0)", "start": [266, 1], "end": [269, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_zero_left", "code": "@[simp]\ntheorem isTheta_zero_left : (fun _ \u21a6 (0 : E')) =\u0398[l] g'' \u2194 g'' =\u1da0[l] 0", "start": [272, 1], "end": [274, 72], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_zero_right", "code": "@[simp]\ntheorem isTheta_zero_right : (f'' =\u0398[l] fun _ \u21a6 (0 : F')) \u2194 f'' =\u1da0[l] 0", "start": [277, 1], "end": [279, 39], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.isTheta_const_smul_left", "code": "theorem isTheta_const_smul_left [NormedSpace \ud835\udd5c E'] {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x \u21a6 c \u2022 f' x) =\u0398[l] g \u2194 f' =\u0398[l] g", "start": [282, 1], "end": [284, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.of_const_smul_left", "code": "alias \u27e8IsTheta.of_const_smul_left, IsTheta.const_smul_left\u27e9 := isTheta_const_smul_left", "start": [287, 1], "end": [287, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.const_smul_left", "code": "alias \u27e8IsTheta.of_const_smul_left, IsTheta.const_smul_left\u27e9 := isTheta_const_smul_left", "start": [287, 1], "end": [287, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isTheta_const_smul_right", "code": "theorem isTheta_const_smul_right [NormedSpace \ud835\udd5c F'] {c : \ud835\udd5c} (hc : c \u2260 0) :\n    (f =\u0398[l] fun x \u21a6 c \u2022 g' x) \u2194 f =\u0398[l] g'", "start": [291, 1], "end": [293, 69], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.of_const_smul_right", "code": "alias \u27e8IsTheta.of_const_smul_right, IsTheta.const_smul_right\u27e9 := isTheta_const_smul_right", "start": [296, 1], "end": [296, 90], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.const_smul_right", "code": "alias \u27e8IsTheta.of_const_smul_right, IsTheta.const_smul_right\u27e9 := isTheta_const_smul_right", "start": [296, 1], "end": [296, 90], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isTheta_const_mul_left", "code": "theorem isTheta_const_mul_left {c : \ud835\udd5c} {f : \u03b1 \u2192 \ud835\udd5c} (hc : c \u2260 0) :\n    (fun x \u21a6 c * f x) =\u0398[l] g \u2194 f =\u0398[l] g", "start": [300, 1], "end": [302, 62], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.of_const_mul_left", "code": "alias \u27e8IsTheta.of_const_mul_left, IsTheta.const_mul_left\u27e9 := isTheta_const_mul_left", "start": [305, 1], "end": [305, 84], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.const_mul_left", "code": "alias \u27e8IsTheta.of_const_mul_left, IsTheta.const_mul_left\u27e9 := isTheta_const_mul_left", "start": [305, 1], "end": [305, 84], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.isTheta_const_mul_right", "code": "theorem isTheta_const_mul_right {c : \ud835\udd5c} {g : \u03b1 \u2192 \ud835\udd5c} (hc : c \u2260 0) :\n    (f =\u0398[l] fun x \u21a6 c * g x) \u2194 f =\u0398[l] g", "start": [309, 1], "end": [311, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.IsTheta.of_const_mul_right", "code": "alias \u27e8IsTheta.of_const_mul_right, IsTheta.const_mul_right\u27e9 := isTheta_const_mul_right", "start": [314, 1], "end": [314, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.const_mul_right", "code": "alias \u27e8IsTheta.of_const_mul_right, IsTheta.const_mul_right\u27e9 := isTheta_const_mul_right", "start": [314, 1], "end": [314, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Asymptotics.IsTheta.add_isLittleO", "code": "lemma IsTheta.add_isLittleO {f\u2081 f\u2082 : \u03b1 \u2192 E'}\n    (h : f\u2082 =o[l] f\u2081) : (f\u2081 + f\u2082) =\u0398[l] f\u2081 :=\n  \u27e8(isBigO_refl _ _).add_isLittleO h, by rw [add_comm]; exact h.right_isBigO_add\u27e9", "start": [318, 1], "end": [320, 82], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Order/ToIntervalMod.lean", "imports": ["Mathlib/Order/Circular.lean", "Mathlib/Algebra/ModEq.lean", "Mathlib/Data/Int/SuccPred.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Periodic.lean", "Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/Data/List/TFAE.lean", "Mathlib/Algebra/Order/Archimedean.lean"], "premises": [{"full_name": "toIcoDiv", "code": "def toIcoDiv (a b : \u03b1) : \u2124 :=\n  (existsUnique_sub_zsmul_mem_Ico hp b a).choose", "start": [42, 1], "end": [45, 49], "kind": "commanddeclaration"}, {"full_name": "sub_toIcoDiv_zsmul_mem_Ico", "code": "theorem sub_toIcoDiv_zsmul_mem_Ico (a b : \u03b1) : b - toIcoDiv hp a b \u2022 p \u2208 Set.Ico a (a + p)", "start": [48, 1], "end": [49, 56], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_eq_of_sub_zsmul_mem_Ico", "code": "theorem toIcoDiv_eq_of_sub_zsmul_mem_Ico (h : b - n \u2022 p \u2208 Set.Ico a (a + p)) :\n    toIcoDiv hp a b = n", "start": [52, 1], "end": [54, 67], "kind": "commanddeclaration"}, {"full_name": "toIocDiv", "code": "def toIocDiv (a b : \u03b1) : \u2124 :=\n  (existsUnique_sub_zsmul_mem_Ioc hp b a).choose", "start": [57, 1], "end": [60, 49], "kind": "commanddeclaration"}, {"full_name": "sub_toIocDiv_zsmul_mem_Ioc", "code": "theorem sub_toIocDiv_zsmul_mem_Ioc (a b : \u03b1) : b - toIocDiv hp a b \u2022 p \u2208 Set.Ioc a (a + p)", "start": [63, 1], "end": [64, 56], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_eq_of_sub_zsmul_mem_Ioc", "code": "theorem toIocDiv_eq_of_sub_zsmul_mem_Ioc (h : b - n \u2022 p \u2208 Set.Ioc a (a + p)) :\n    toIocDiv hp a b = n", "start": [67, 1], "end": [69, 67], "kind": "commanddeclaration"}, {"full_name": "toIcoMod", "code": "def toIcoMod (a b : \u03b1) : \u03b1 :=\n  b - toIcoDiv hp a b \u2022 p", "start": [72, 1], "end": [74, 26], "kind": "commanddeclaration"}, {"full_name": "toIocMod", "code": "def toIocMod (a b : \u03b1) : \u03b1 :=\n  b - toIocDiv hp a b \u2022 p", "start": [77, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_mem_Ico", "code": "theorem toIcoMod_mem_Ico (a b : \u03b1) : toIcoMod hp a b \u2208 Set.Ico a (a + p)", "start": [82, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_mem_Ico'", "code": "theorem toIcoMod_mem_Ico' (b : \u03b1) : toIcoMod hp 0 b \u2208 Set.Ico 0 p", "start": [86, 1], "end": [88, 26], "kind": "commanddeclaration"}, {"full_name": "toIocMod_mem_Ioc", "code": "theorem toIocMod_mem_Ioc (a b : \u03b1) : toIocMod hp a b \u2208 Set.Ioc a (a + p)", "start": [91, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "left_le_toIcoMod", "code": "theorem left_le_toIcoMod (a b : \u03b1) : a \u2264 toIcoMod hp a b", "start": [95, 1], "end": [96, 46], "kind": "commanddeclaration"}, {"full_name": "left_lt_toIocMod", "code": "theorem left_lt_toIocMod (a b : \u03b1) : a < toIocMod hp a b", "start": [99, 1], "end": [100, 46], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_lt_right", "code": "theorem toIcoMod_lt_right (a b : \u03b1) : toIcoMod hp a b < a + p", "start": [103, 1], "end": [104, 46], "kind": "commanddeclaration"}, {"full_name": "toIocMod_le_right", "code": "theorem toIocMod_le_right (a b : \u03b1) : toIocMod hp a b \u2264 a + p", "start": [107, 1], "end": [108, 46], "kind": "commanddeclaration"}, {"full_name": "self_sub_toIcoDiv_zsmul", "code": "@[simp]\ntheorem self_sub_toIcoDiv_zsmul (a b : \u03b1) : b - toIcoDiv hp a b \u2022 p = toIcoMod hp a b", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "self_sub_toIocDiv_zsmul", "code": "@[simp]\ntheorem self_sub_toIocDiv_zsmul (a b : \u03b1) : b - toIocDiv hp a b \u2022 p = toIocMod hp a b", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_zsmul_sub_self", "code": "@[simp]\ntheorem toIcoDiv_zsmul_sub_self (a b : \u03b1) : toIcoDiv hp a b \u2022 p - b = -toIcoMod hp a b", "start": [121, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_zsmul_sub_self", "code": "@[simp]\ntheorem toIocDiv_zsmul_sub_self (a b : \u03b1) : toIocDiv hp a b \u2022 p - b = -toIocMod hp a b", "start": [126, 1], "end": [128, 25], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub_self", "code": "@[simp]\ntheorem toIcoMod_sub_self (a b : \u03b1) : toIcoMod hp a b - b = -toIcoDiv hp a b \u2022 p", "start": [131, 1], "end": [133, 47], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub_self", "code": "@[simp]\ntheorem toIocMod_sub_self (a b : \u03b1) : toIocMod hp a b - b = -toIocDiv hp a b \u2022 p", "start": [136, 1], "end": [138, 47], "kind": "commanddeclaration"}, {"full_name": "self_sub_toIcoMod", "code": "@[simp]\ntheorem self_sub_toIcoMod (a b : \u03b1) : b - toIcoMod hp a b = toIcoDiv hp a b \u2022 p", "start": [141, 1], "end": [143, 32], "kind": "commanddeclaration"}, {"full_name": "self_sub_toIocMod", "code": "@[simp]\ntheorem self_sub_toIocMod (a b : \u03b1) : b - toIocMod hp a b = toIocDiv hp a b \u2022 p", "start": [146, 1], "end": [148, 32], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_toIcoDiv_zsmul", "code": "@[simp]\ntheorem toIcoMod_add_toIcoDiv_zsmul (a b : \u03b1) : toIcoMod hp a b + toIcoDiv hp a b \u2022 p = b", "start": [151, 1], "end": [153, 32], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_toIocDiv_zsmul", "code": "@[simp]\ntheorem toIocMod_add_toIocDiv_zsmul (a b : \u03b1) : toIocMod hp a b + toIocDiv hp a b \u2022 p = b", "start": [156, 1], "end": [158, 32], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_zsmul_sub_toIcoMod", "code": "@[simp]\ntheorem toIcoDiv_zsmul_sub_toIcoMod (a b : \u03b1) : toIcoDiv hp a b \u2022 p + toIcoMod hp a b = b", "start": [161, 1], "end": [163, 45], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_zsmul_sub_toIocMod", "code": "@[simp]\ntheorem toIocDiv_zsmul_sub_toIocMod (a b : \u03b1) : toIocDiv hp a b \u2022 p + toIocMod hp a b = b", "start": [166, 1], "end": [168, 45], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_iff", "code": "theorem toIcoMod_eq_iff : toIcoMod hp a b = c \u2194 c \u2208 Set.Ico a (a + p) \u2227 \u2203 z : \u2124, b = c + z \u2022 p", "start": [171, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "toIocMod_eq_iff", "code": "theorem toIocMod_eq_iff : toIocMod hp a b = c \u2194 c \u2208 Set.Ioc a (a + p) \u2227 \u2203 z : \u2124, b = c + z \u2022 p", "start": [181, 1], "end": [188, 58], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_apply_left", "code": "@[simp]\ntheorem toIcoDiv_apply_left (a : \u03b1) : toIcoDiv hp a a = 0", "start": [191, 1], "end": [193, 54], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_apply_left", "code": "@[simp]\ntheorem toIocDiv_apply_left (a : \u03b1) : toIocDiv hp a a = -1", "start": [196, 1], "end": [198, 54], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_apply_left", "code": "@[simp]\ntheorem toIcoMod_apply_left (a : \u03b1) : toIcoMod hp a a = a", "start": [201, 1], "end": [204, 47], "kind": "commanddeclaration"}, {"full_name": "toIocMod_apply_left", "code": "@[simp]\ntheorem toIocMod_apply_left (a : \u03b1) : toIocMod hp a a = a + p", "start": [207, 1], "end": [210, 48], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_apply_right", "code": "theorem toIcoDiv_apply_right (a : \u03b1) : toIcoDiv hp a (a + p) = 1", "start": [213, 1], "end": [214, 54], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_apply_right", "code": "theorem toIocDiv_apply_right (a : \u03b1) : toIocDiv hp a (a + p) = 0", "start": [217, 1], "end": [218, 54], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_apply_right", "code": "theorem toIcoMod_apply_right (a : \u03b1) : toIcoMod hp a (a + p) = a", "start": [221, 1], "end": [223, 47], "kind": "commanddeclaration"}, {"full_name": "toIocMod_apply_right", "code": "theorem toIocMod_apply_right (a : \u03b1) : toIocMod hp a (a + p) = a + p", "start": [226, 1], "end": [228, 47], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_zsmul", "code": "@[simp]\ntheorem toIcoDiv_add_zsmul (a b : \u03b1) (m : \u2124) : toIcoDiv hp a (b + m \u2022 p) = toIcoDiv hp a b + m", "start": [231, 1], "end": [234, 92], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_zsmul'", "code": "@[simp]\ntheorem toIcoDiv_add_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIcoDiv hp (a + m \u2022 p) b = toIcoDiv hp a b - m", "start": [237, 1], "end": [242, 48], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_zsmul", "code": "@[simp]\ntheorem toIocDiv_add_zsmul (a b : \u03b1) (m : \u2124) : toIocDiv hp a (b + m \u2022 p) = toIocDiv hp a b + m", "start": [245, 1], "end": [248, 92], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_zsmul'", "code": "@[simp]\ntheorem toIocDiv_add_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIocDiv hp (a + m \u2022 p) b = toIocDiv hp a b - m", "start": [251, 1], "end": [256, 48], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_zsmul_add", "code": "@[simp]\ntheorem toIcoDiv_zsmul_add (a b : \u03b1) (m : \u2124) : toIcoDiv hp a (m \u2022 p + b) = m + toIcoDiv hp a b", "start": [259, 1], "end": [261, 46], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_zsmul_add", "code": "@[simp]\ntheorem toIocDiv_zsmul_add (a b : \u03b1) (m : \u2124) : toIocDiv hp a (m \u2022 p + b) = m + toIocDiv hp a b", "start": [267, 1], "end": [269, 46], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub_zsmul", "code": "@[simp]\ntheorem toIcoDiv_sub_zsmul (a b : \u03b1) (m : \u2124) : toIcoDiv hp a (b - m \u2022 p) = toIcoDiv hp a b - m", "start": [275, 1], "end": [277, 70], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub_zsmul'", "code": "@[simp]\ntheorem toIcoDiv_sub_zsmul' (a b : \u03b1) (m : \u2124) : toIcoDiv hp (a - m \u2022 p) b = toIcoDiv hp a b + m", "start": [280, 1], "end": [282, 74], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub_zsmul", "code": "@[simp]\ntheorem toIocDiv_sub_zsmul (a b : \u03b1) (m : \u2124) : toIocDiv hp a (b - m \u2022 p) = toIocDiv hp a b - m", "start": [285, 1], "end": [287, 70], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub_zsmul'", "code": "@[simp]\ntheorem toIocDiv_sub_zsmul' (a b : \u03b1) (m : \u2124) : toIocDiv hp (a - m \u2022 p) b = toIocDiv hp a b + m", "start": [290, 1], "end": [292, 74], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_right", "code": "@[simp]\ntheorem toIcoDiv_add_right (a b : \u03b1) : toIcoDiv hp a (b + p) = toIcoDiv hp a b + 1", "start": [295, 1], "end": [297, 59], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_right'", "code": "@[simp]\ntheorem toIcoDiv_add_right' (a b : \u03b1) : toIcoDiv hp (a + p) b = toIcoDiv hp a b - 1", "start": [300, 1], "end": [302, 60], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_right", "code": "@[simp]\ntheorem toIocDiv_add_right (a b : \u03b1) : toIocDiv hp a (b + p) = toIocDiv hp a b + 1", "start": [305, 1], "end": [307, 59], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_right'", "code": "@[simp]\ntheorem toIocDiv_add_right' (a b : \u03b1) : toIocDiv hp (a + p) b = toIocDiv hp a b - 1", "start": [310, 1], "end": [312, 60], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_left", "code": "@[simp]\ntheorem toIcoDiv_add_left (a b : \u03b1) : toIcoDiv hp a (p + b) = toIcoDiv hp a b + 1", "start": [315, 1], "end": [317, 36], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_add_left'", "code": "@[simp]\ntheorem toIcoDiv_add_left' (a b : \u03b1) : toIcoDiv hp (p + a) b = toIcoDiv hp a b - 1", "start": [320, 1], "end": [322, 37], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_left", "code": "@[simp]\ntheorem toIocDiv_add_left (a b : \u03b1) : toIocDiv hp a (p + b) = toIocDiv hp a b + 1", "start": [325, 1], "end": [327, 36], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_add_left'", "code": "@[simp]\ntheorem toIocDiv_add_left' (a b : \u03b1) : toIocDiv hp (p + a) b = toIocDiv hp a b - 1", "start": [330, 1], "end": [332, 37], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub", "code": "@[simp]\ntheorem toIcoDiv_sub (a b : \u03b1) : toIcoDiv hp a (b - p) = toIcoDiv hp a b - 1", "start": [335, 1], "end": [337, 59], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub'", "code": "@[simp]\ntheorem toIcoDiv_sub' (a b : \u03b1) : toIcoDiv hp (a - p) b = toIcoDiv hp a b + 1", "start": [340, 1], "end": [342, 60], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub", "code": "@[simp]\ntheorem toIocDiv_sub (a b : \u03b1) : toIocDiv hp a (b - p) = toIocDiv hp a b - 1", "start": [345, 1], "end": [347, 59], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub'", "code": "@[simp]\ntheorem toIocDiv_sub' (a b : \u03b1) : toIocDiv hp (a - p) b = toIocDiv hp a b + 1", "start": [350, 1], "end": [352, 60], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub_eq_toIcoDiv_add", "code": "theorem toIcoDiv_sub_eq_toIcoDiv_add (a b c : \u03b1) :\n    toIcoDiv hp a (b - c) = toIcoDiv hp (a + c) b", "start": [355, 1], "end": [359, 48], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub_eq_toIocDiv_add", "code": "theorem toIocDiv_sub_eq_toIocDiv_add (a b c : \u03b1) :\n    toIocDiv hp a (b - c) = toIocDiv hp (a + c) b", "start": [362, 1], "end": [366, 48], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_sub_eq_toIcoDiv_add'", "code": "theorem toIcoDiv_sub_eq_toIcoDiv_add' (a b c : \u03b1) : toIcoDiv hp (a - c) b = toIcoDiv hp a (b + c)", "start": [369, 1], "end": [370, 73], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_sub_eq_toIocDiv_add'", "code": "theorem toIocDiv_sub_eq_toIocDiv_add' (a b c : \u03b1) : toIocDiv hp (a - c) b = toIocDiv hp a (b + c)", "start": [373, 1], "end": [374, 73], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_neg", "code": "theorem toIcoDiv_neg (a b : \u03b1) : toIcoDiv hp a (-b) = -(toIocDiv hp (-a) b + 1)", "start": [377, 1], "end": [386, 37], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_neg'", "code": "theorem toIcoDiv_neg' (a b : \u03b1) : toIcoDiv hp (-a) b = -(toIocDiv hp a (-b) + 1)", "start": [389, 1], "end": [390, 55], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_neg", "code": "theorem toIocDiv_neg (a b : \u03b1) : toIocDiv hp a (-b) = -(toIcoDiv hp (-a) b + 1)", "start": [393, 1], "end": [394, 86], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_neg'", "code": "theorem toIocDiv_neg' (a b : \u03b1) : toIocDiv hp (-a) b = -(toIcoDiv hp a (-b) + 1)", "start": [397, 1], "end": [398, 55], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_zsmul", "code": "@[simp]\ntheorem toIcoMod_add_zsmul (a b : \u03b1) (m : \u2124) : toIcoMod hp a (b + m \u2022 p) = toIcoMod hp a b", "start": [401, 1], "end": [404, 7], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_zsmul'", "code": "@[simp]\ntheorem toIcoMod_add_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIcoMod hp (a + m \u2022 p) b = toIcoMod hp a b + m \u2022 p", "start": [407, 1], "end": [410, 63], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_zsmul", "code": "@[simp]\ntheorem toIocMod_add_zsmul (a b : \u03b1) (m : \u2124) : toIocMod hp a (b + m \u2022 p) = toIocMod hp a b", "start": [413, 1], "end": [416, 7], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_zsmul'", "code": "@[simp]\ntheorem toIocMod_add_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIocMod hp (a + m \u2022 p) b = toIocMod hp a b + m \u2022 p", "start": [419, 1], "end": [422, 63], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_zsmul_add", "code": "@[simp]\ntheorem toIcoMod_zsmul_add (a b : \u03b1) (m : \u2124) : toIcoMod hp a (m \u2022 p + b) = toIcoMod hp a b", "start": [425, 1], "end": [427, 36], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_zsmul_add'", "code": "@[simp]\ntheorem toIcoMod_zsmul_add' (a b : \u03b1) (m : \u2124) :\n    toIcoMod hp (m \u2022 p + a) b = m \u2022 p + toIcoMod hp a b", "start": [430, 1], "end": [433, 47], "kind": "commanddeclaration"}, {"full_name": "toIocMod_zsmul_add", "code": "@[simp]\ntheorem toIocMod_zsmul_add (a b : \u03b1) (m : \u2124) : toIocMod hp a (m \u2022 p + b) = toIocMod hp a b", "start": [436, 1], "end": [438, 36], "kind": "commanddeclaration"}, {"full_name": "toIocMod_zsmul_add'", "code": "@[simp]\ntheorem toIocMod_zsmul_add' (a b : \u03b1) (m : \u2124) :\n    toIocMod hp (m \u2022 p + a) b = m \u2022 p + toIocMod hp a b", "start": [441, 1], "end": [444, 47], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub_zsmul", "code": "@[simp]\ntheorem toIcoMod_sub_zsmul (a b : \u03b1) (m : \u2124) : toIcoMod hp a (b - m \u2022 p) = toIcoMod hp a b", "start": [447, 1], "end": [449, 54], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub_zsmul'", "code": "@[simp]\ntheorem toIcoMod_sub_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIcoMod hp (a - m \u2022 p) b = toIcoMod hp a b - m \u2022 p", "start": [452, 1], "end": [455, 60], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub_zsmul", "code": "@[simp]\ntheorem toIocMod_sub_zsmul (a b : \u03b1) (m : \u2124) : toIocMod hp a (b - m \u2022 p) = toIocMod hp a b", "start": [458, 1], "end": [460, 54], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub_zsmul'", "code": "@[simp]\ntheorem toIocMod_sub_zsmul' (a b : \u03b1) (m : \u2124) :\n    toIocMod hp (a - m \u2022 p) b = toIocMod hp a b - m \u2022 p", "start": [463, 1], "end": [466, 60], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_right", "code": "@[simp]\ntheorem toIcoMod_add_right (a b : \u03b1) : toIcoMod hp a (b + p) = toIcoMod hp a b", "start": [469, 1], "end": [471, 59], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_right'", "code": "@[simp]\ntheorem toIcoMod_add_right' (a b : \u03b1) : toIcoMod hp (a + p) b = toIcoMod hp a b + p", "start": [474, 1], "end": [476, 60], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_right", "code": "@[simp]\ntheorem toIocMod_add_right (a b : \u03b1) : toIocMod hp a (b + p) = toIocMod hp a b", "start": [479, 1], "end": [481, 59], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_right'", "code": "@[simp]\ntheorem toIocMod_add_right' (a b : \u03b1) : toIocMod hp (a + p) b = toIocMod hp a b + p", "start": [484, 1], "end": [486, 60], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_left", "code": "@[simp]\ntheorem toIcoMod_add_left (a b : \u03b1) : toIcoMod hp a (p + b) = toIcoMod hp a b", "start": [489, 1], "end": [491, 36], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_left'", "code": "@[simp]\ntheorem toIcoMod_add_left' (a b : \u03b1) : toIcoMod hp (p + a) b = p + toIcoMod hp a b", "start": [494, 1], "end": [496, 47], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_left", "code": "@[simp]\ntheorem toIocMod_add_left (a b : \u03b1) : toIocMod hp a (p + b) = toIocMod hp a b", "start": [499, 1], "end": [501, 36], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_left'", "code": "@[simp]\ntheorem toIocMod_add_left' (a b : \u03b1) : toIocMod hp (p + a) b = p + toIocMod hp a b", "start": [504, 1], "end": [506, 47], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub", "code": "@[simp]\ntheorem toIcoMod_sub (a b : \u03b1) : toIcoMod hp a (b - p) = toIcoMod hp a b", "start": [509, 1], "end": [511, 59], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub'", "code": "@[simp]\ntheorem toIcoMod_sub' (a b : \u03b1) : toIcoMod hp (a - p) b = toIcoMod hp a b - p", "start": [514, 1], "end": [516, 60], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub", "code": "@[simp]\ntheorem toIocMod_sub (a b : \u03b1) : toIocMod hp a (b - p) = toIocMod hp a b", "start": [519, 1], "end": [521, 59], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub'", "code": "@[simp]\ntheorem toIocMod_sub' (a b : \u03b1) : toIocMod hp (a - p) b = toIocMod hp a b - p", "start": [524, 1], "end": [526, 60], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_sub_eq_sub", "code": "theorem toIcoMod_sub_eq_sub (a b c : \u03b1) : toIcoMod hp a (b - c) = toIcoMod hp (a + c) b - c", "start": [529, 1], "end": [530, 67], "kind": "commanddeclaration"}, {"full_name": "toIocMod_sub_eq_sub", "code": "theorem toIocMod_sub_eq_sub (a b c : \u03b1) : toIocMod hp a (b - c) = toIocMod hp (a + c) b - c", "start": [533, 1], "end": [534, 67], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_right_eq_add", "code": "theorem toIcoMod_add_right_eq_add (a b c : \u03b1) : toIcoMod hp a (b + c) = toIcoMod hp (a - c) b + c", "start": [537, 1], "end": [538, 75], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_right_eq_add", "code": "theorem toIocMod_add_right_eq_add (a b c : \u03b1) : toIocMod hp a (b + c) = toIocMod hp (a - c) b + c", "start": [541, 1], "end": [542, 75], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_neg", "code": "theorem toIcoMod_neg (a b : \u03b1) : toIcoMod hp a (-b) = p - toIocMod hp (-a) b", "start": [545, 1], "end": [547, 7], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_neg'", "code": "theorem toIcoMod_neg' (a b : \u03b1) : toIcoMod hp (-a) b = p - toIocMod hp a (-b)", "start": [550, 1], "end": [551, 55], "kind": "commanddeclaration"}, {"full_name": "toIocMod_neg", "code": "theorem toIocMod_neg (a b : \u03b1) : toIocMod hp a (-b) = p - toIcoMod hp (-a) b", "start": [554, 1], "end": [556, 7], "kind": "commanddeclaration"}, {"full_name": "toIocMod_neg'", "code": "theorem toIocMod_neg' (a b : \u03b1) : toIocMod hp (-a) b = p - toIcoMod hp a (-b)", "start": [559, 1], "end": [560, 55], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_toIcoMod", "code": "theorem toIcoMod_eq_toIcoMod : toIcoMod hp a b = toIcoMod hp a c \u2194 \u2203 n : \u2124, c - b = n \u2022 p", "start": [563, 1], "end": [570, 32], "kind": "commanddeclaration"}, {"full_name": "toIocMod_eq_toIocMod", "code": "theorem toIocMod_eq_toIocMod : toIocMod hp a b = toIocMod hp a c \u2194 \u2203 n : \u2124, c - b = n \u2022 p", "start": [573, 1], "end": [580, 32], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_toIcoMod_eq_left", "code": "theorem modEq_iff_toIcoMod_eq_left : a \u2261 b [PMOD p] \u2194 toIcoMod hp a b = a", "start": [590, 1], "end": [594, 100], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_toIocMod_eq_right", "code": "theorem modEq_iff_toIocMod_eq_right : a \u2261 b [PMOD p] \u2194 toIocMod hp a b = a + p", "start": [597, 1], "end": [601, 61], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.toIcoMod_eq_left", "code": "alias \u27e8ModEq.toIcoMod_eq_left, _\u27e9 := modEq_iff_toIcoMod_eq_left", "start": [604, 1], "end": [604, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.ModEq.toIcoMod_eq_right", "code": "alias \u27e8ModEq.toIcoMod_eq_right, _\u27e9 := modEq_iff_toIocMod_eq_right", "start": [607, 1], "end": [607, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddCommGroup.tfae_modEq", "code": "theorem tfae_modEq :\n    TFAE\n      [a \u2261 b [PMOD p], \u2200 z : \u2124, b - z \u2022 p \u2209 Set.Ioo a (a + p), toIcoMod hp a b \u2260 toIocMod hp a b,\n        toIcoMod hp a b + p = toIocMod hp a b]", "start": [613, 1], "end": [637, 14], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_not_forall_mem_Ioo_mod", "code": "theorem modEq_iff_not_forall_mem_Ioo_mod :\n    a \u2261 b [PMOD p] \u2194 \u2200 z : \u2124, b - z \u2022 p \u2209 Set.Ioo a (a + p)", "start": [642, 1], "end": [644, 30], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_toIcoMod_ne_toIocMod", "code": "theorem modEq_iff_toIcoMod_ne_toIocMod : a \u2261 b [PMOD p] \u2194 toIcoMod hp a b \u2260 toIocMod hp a b", "start": [647, 1], "end": [648, 30], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_toIcoMod_add_period_eq_toIocMod", "code": "theorem modEq_iff_toIcoMod_add_period_eq_toIocMod :\n    a \u2261 b [PMOD p] \u2194 toIcoMod hp a b + p = toIocMod hp a b", "start": [651, 1], "end": [653, 30], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.not_modEq_iff_toIcoMod_eq_toIocMod", "code": "theorem not_modEq_iff_toIcoMod_eq_toIocMod : \u00aca \u2261 b [PMOD p] \u2194 toIcoMod hp a b = toIocMod hp a b", "start": [656, 1], "end": [657, 46], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.not_modEq_iff_toIcoDiv_eq_toIocDiv", "code": "theorem not_modEq_iff_toIcoDiv_eq_toIocDiv :\n    \u00aca \u2261 b [PMOD p] \u2194 toIcoDiv hp a b = toIocDiv hp a b", "start": [660, 1], "end": [663, 49], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.modEq_iff_toIcoDiv_eq_toIocDiv_add_one", "code": "theorem modEq_iff_toIcoDiv_eq_toIocDiv_add_one :\n    a \u2261 b [PMOD p] \u2194 toIcoDiv hp a b = toIocDiv hp a b + 1", "start": [666, 1], "end": [669, 90], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_inj", "code": "@[simp]\ntheorem toIcoMod_inj {c : \u03b1} : toIcoMod hp c a = toIcoMod hp c b \u2194 a \u2261 b [PMOD p]", "start": [676, 1], "end": [679, 77], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.ModEq.toIcoMod_eq_toIcoMod", "code": "alias \u27e8_, AddCommGroup.ModEq.toIcoMod_eq_toIcoMod\u27e9 := toIcoMod_inj", "start": [682, 1], "end": [682, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ico_eq_locus_Ioc_eq_iUnion_Ioo", "code": "theorem Ico_eq_locus_Ioc_eq_iUnion_Ioo :\n    { b | toIcoMod hp a b = toIocMod hp a b } = \u22c3 z : \u2124, Set.Ioo (a + z \u2022 p) (a + p + z \u2022 p)", "start": [685, 1], "end": [690, 23], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_wcovby_toIcoDiv", "code": "theorem toIocDiv_wcovby_toIcoDiv (a b : \u03b1) : toIocDiv hp a b \u2a7f toIcoDiv hp a b", "start": [693, 1], "end": [698, 14], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_le_toIocMod", "code": "theorem toIcoMod_le_toIocMod (a b : \u03b1) : toIcoMod hp a b \u2264 toIocMod hp a b", "start": [701, 1], "end": [703, 66], "kind": "commanddeclaration"}, {"full_name": "toIocMod_le_toIcoMod_add", "code": "theorem toIocMod_le_toIcoMod_add (a b : \u03b1) : toIocMod hp a b \u2264 toIcoMod hp a b + p", "start": [706, 1], "end": [709, 49], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_self", "code": "theorem toIcoMod_eq_self : toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)", "start": [716, 1], "end": [718, 21], "kind": "commanddeclaration"}, {"full_name": "toIocMod_eq_self", "code": "theorem toIocMod_eq_self : toIocMod hp a b = b \u2194 b \u2208 Set.Ioc a (a + p)", "start": [721, 1], "end": [723, 21], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_toIcoMod", "code": "@[simp]\ntheorem toIcoMod_toIcoMod (a\u2081 a\u2082 b : \u03b1) : toIcoMod hp a\u2081 (toIcoMod hp a\u2082 b) = toIcoMod hp a\u2081 b", "start": [726, 1], "end": [728, 75], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_toIocMod", "code": "@[simp]\ntheorem toIcoMod_toIocMod (a\u2081 a\u2082 b : \u03b1) : toIcoMod hp a\u2081 (toIocMod hp a\u2082 b) = toIcoMod hp a\u2081 b", "start": [731, 1], "end": [733, 75], "kind": "commanddeclaration"}, {"full_name": "toIocMod_toIocMod", "code": "@[simp]\ntheorem toIocMod_toIocMod (a\u2081 a\u2082 b : \u03b1) : toIocMod hp a\u2081 (toIocMod hp a\u2082 b) = toIocMod hp a\u2081 b", "start": [736, 1], "end": [738, 75], "kind": "commanddeclaration"}, {"full_name": "toIocMod_toIcoMod", "code": "@[simp]\ntheorem toIocMod_toIcoMod (a\u2081 a\u2082 b : \u03b1) : toIocMod hp a\u2081 (toIcoMod hp a\u2082 b) = toIocMod hp a\u2081 b", "start": [741, 1], "end": [743, 75], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_periodic", "code": "theorem toIcoMod_periodic (a : \u03b1) : Function.Periodic (toIcoMod hp a) p", "start": [746, 1], "end": [747, 26], "kind": "commanddeclaration"}, {"full_name": "toIocMod_periodic", "code": "theorem toIocMod_periodic (a : \u03b1) : Function.Periodic (toIocMod hp a) p", "start": [750, 1], "end": [751, 26], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_zero_sub_comm", "code": "theorem toIcoMod_zero_sub_comm (a b : \u03b1) : toIcoMod hp 0 (a - b) = p - toIocMod hp 0 (b - a)", "start": [757, 1], "end": [758, 41], "kind": "commanddeclaration"}, {"full_name": "toIocMod_zero_sub_comm", "code": "theorem toIocMod_zero_sub_comm (a b : \u03b1) : toIocMod hp 0 (a - b) = p - toIcoMod hp 0 (b - a)", "start": [761, 1], "end": [762, 41], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_eq_sub", "code": "theorem toIcoDiv_eq_sub (a b : \u03b1) : toIcoDiv hp a b = toIcoDiv hp 0 (b - a)", "start": [765, 1], "end": [766, 46], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_eq_sub", "code": "theorem toIocDiv_eq_sub (a b : \u03b1) : toIocDiv hp a b = toIocDiv hp 0 (b - a)", "start": [769, 1], "end": [770, 46], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_sub", "code": "theorem toIcoMod_eq_sub (a b : \u03b1) : toIcoMod hp a b = toIcoMod hp 0 (b - a) + a", "start": [773, 1], "end": [774, 53], "kind": "commanddeclaration"}, {"full_name": "toIocMod_eq_sub", "code": "theorem toIocMod_eq_sub (a b : \u03b1) : toIocMod hp a b = toIocMod hp 0 (b - a) + a", "start": [777, 1], "end": [778, 53], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_add_toIocMod_zero", "code": "theorem toIcoMod_add_toIocMod_zero (a b : \u03b1) : toIcoMod hp 0 (a - b) + toIocMod hp 0 (b - a) = p", "start": [781, 1], "end": [782, 49], "kind": "commanddeclaration"}, {"full_name": "toIocMod_add_toIcoMod_zero", "code": "theorem toIocMod_add_toIcoMod_zero (a b : \u03b1) : toIocMod hp 0 (a - b) + toIcoMod hp 0 (b - a) = p", "start": [785, 1], "end": [786, 54], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIcoMod", "code": "@[simps symm_apply]\ndef QuotientAddGroup.equivIcoMod (a : \u03b1) : \u03b1 \u29f8 AddSubgroup.zmultiples p \u2243 Set.Ico a (a + p) where\n  toFun b :=\n    \u27e8(toIcoMod_periodic hp a).lift b, QuotientAddGroup.induction_on' b <| toIcoMod_mem_Ico hp a\u27e9\n  invFun := (\u2191)\n  right_inv b := Subtype.ext <| (toIcoMod_eq_self hp).mpr b.prop\n  left_inv b := by\n    induction b using QuotientAddGroup.induction_on'\n    dsimp\n    rw [QuotientAddGroup.eq_iff_sub_mem, toIcoMod_sub_self]\n    apply AddSubgroup.zsmul_mem_zmultiples", "start": [791, 1], "end": [802, 43], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIcoMod_coe", "code": "@[simp]\ntheorem QuotientAddGroup.equivIcoMod_coe (a b : \u03b1) :\n    QuotientAddGroup.equivIcoMod hp a \u2191b = \u27e8toIcoMod hp a b, toIcoMod_mem_Ico hp a _\u27e9", "start": [805, 1], "end": [808, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIcoMod_zero", "code": "@[simp]\ntheorem QuotientAddGroup.equivIcoMod_zero (a : \u03b1) :\n    QuotientAddGroup.equivIcoMod hp a 0 = \u27e8toIcoMod hp a 0, toIcoMod_mem_Ico hp a _\u27e9", "start": [811, 1], "end": [814, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIocMod", "code": "@[simps symm_apply]\ndef QuotientAddGroup.equivIocMod (a : \u03b1) : \u03b1 \u29f8 AddSubgroup.zmultiples p \u2243 Set.Ioc a (a + p) where\n  toFun b :=\n    \u27e8(toIocMod_periodic hp a).lift b, QuotientAddGroup.induction_on' b <| toIocMod_mem_Ioc hp a\u27e9\n  invFun := (\u2191)\n  right_inv b := Subtype.ext <| (toIocMod_eq_self hp).mpr b.prop\n  left_inv b := by\n    induction b using QuotientAddGroup.induction_on'\n    dsimp\n    rw [QuotientAddGroup.eq_iff_sub_mem, toIocMod_sub_self]\n    apply AddSubgroup.zsmul_mem_zmultiples", "start": [817, 1], "end": [828, 43], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIocMod_coe", "code": "@[simp]\ntheorem QuotientAddGroup.equivIocMod_coe (a b : \u03b1) :\n    QuotientAddGroup.equivIocMod hp a \u2191b = \u27e8toIocMod hp a b, toIocMod_mem_Ioc hp a _\u27e9", "start": [831, 1], "end": [834, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.equivIocMod_zero", "code": "@[simp]\ntheorem QuotientAddGroup.equivIocMod_zero (a : \u03b1) :\n    QuotientAddGroup.equivIocMod hp a 0 = \u27e8toIocMod hp a 0, toIocMod_mem_Ioc hp a _\u27e9", "start": [837, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_iff", "code": "private theorem toIxxMod_iff (x\u2081 x\u2082 x\u2083 : \u03b1) : toIcoMod hp x\u2081 x\u2082 \u2264 toIocMod hp x\u2081 x\u2083 \u2194\n    toIcoMod hp 0 (x\u2082 - x\u2081) + toIcoMod hp 0 (x\u2081 - x\u2083) \u2264 p", "start": [850, 1], "end": [853, 33], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_cyclic_left", "code": "private theorem toIxxMod_cyclic_left {x\u2081 x\u2082 x\u2083 : \u03b1} (h : toIcoMod hp x\u2081 x\u2082 \u2264 toIocMod hp x\u2081 x\u2083) :\n    toIcoMod hp x\u2082 x\u2083 \u2264 toIocMod hp x\u2082 x\u2081", "start": [855, 1], "end": [875, 16], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_antisymm", "code": "private theorem toIxxMod_antisymm (h\u2081\u2082\u2083 : toIcoMod hp a b \u2264 toIocMod hp a c)\n    (h\u2081\u2083\u2082 : toIcoMod hp a c \u2264 toIocMod hp a b) :\n    b \u2261 a [PMOD p] \u2228 c \u2261 b [PMOD p] \u2228 a \u2261 c [PMOD p]", "start": [877, 1], "end": [884, 57], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_total'", "code": "private theorem toIxxMod_total' (a b c : \u03b1) :\n    toIcoMod hp b a \u2264 toIocMod hp b c \u2228 toIcoMod hp b c \u2264 toIocMod hp b a", "start": [886, 1], "end": [899, 31], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_total", "code": "private theorem toIxxMod_total (a b c : \u03b1) :\n    toIcoMod hp a b \u2264 toIocMod hp a c \u2228 toIcoMod hp c b \u2264 toIocMod hp c a", "start": [901, 1], "end": [903, 64], "kind": "commanddeclaration"}, {"full_name": "toIxxMod_trans", "code": "private theorem toIxxMod_trans {x\u2081 x\u2082 x\u2083 x\u2084 : \u03b1}\n    (h\u2081\u2082\u2083 : toIcoMod hp x\u2081 x\u2082 \u2264 toIocMod hp x\u2081 x\u2083 \u2227 \u00actoIcoMod hp x\u2083 x\u2082 \u2264 toIocMod hp x\u2083 x\u2081)\n    (h\u2082\u2083\u2084 : toIcoMod hp x\u2082 x\u2084 \u2264 toIocMod hp x\u2082 x\u2083 \u2227 \u00actoIcoMod hp x\u2083 x\u2084 \u2264 toIocMod hp x\u2083 x\u2082) :\n    toIcoMod hp x\u2081 x\u2084 \u2264 toIocMod hp x\u2081 x\u2083 \u2227 \u00actoIcoMod hp x\u2083 x\u2084 \u2264 toIocMod hp x\u2083 x\u2081", "start": [905, 1], "end": [919, 72], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.btw_coe_iff'", "code": "theorem btw_coe_iff' {x\u2081 x\u2082 x\u2083 : \u03b1} :\n    Btw.btw (x\u2081 : \u03b1 \u29f8 AddSubgroup.zmultiples p) x\u2082 x\u2083 \u2194\n      toIcoMod hp'.out 0 (x\u2082 - x\u2081) \u2264 toIocMod hp'.out 0 (x\u2083 - x\u2081)", "start": [928, 1], "end": [931, 10], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.btw_coe_iff", "code": "theorem btw_coe_iff {x\u2081 x\u2082 x\u2083 : \u03b1} :\n    Btw.btw (x\u2081 : \u03b1 \u29f8 AddSubgroup.zmultiples p) x\u2082 x\u2083 \u2194\n      toIcoMod hp'.out x\u2081 x\u2082 \u2264 toIocMod hp'.out x\u2081 x\u2083", "start": [935, 1], "end": [938, 97], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.circularPreorder", "code": "instance circularPreorder : CircularPreorder (\u03b1 \u29f8 AddSubgroup.zmultiples p) where\n  btw_refl x := show _ \u2264 _ by simp [sub_self, hp'.out.le]\n  btw_cyclic_left {x\u2081 x\u2082 x\u2083} h := by\n    induction x\u2081 using QuotientAddGroup.induction_on'\n    induction x\u2082 using QuotientAddGroup.induction_on'\n    induction x\u2083 using QuotientAddGroup.induction_on'\n    simp_rw [btw_coe_iff] at h \u22a2\n    apply toIxxMod_cyclic_left _ h\n  sbtw := _\n  sbtw_iff_btw_not_btw := Iff.rfl\n  sbtw_trans_left {x\u2081 x\u2082 x\u2083 x\u2084} (h\u2081\u2082\u2083 : _ \u2227 _) (h\u2082\u2083\u2084 : _ \u2227 _) :=\n    show _ \u2227 _ by\n      induction x\u2081 using QuotientAddGroup.induction_on'\n      induction x\u2082 using QuotientAddGroup.induction_on'\n      induction x\u2083 using QuotientAddGroup.induction_on'\n      induction x\u2084 using QuotientAddGroup.induction_on'\n      simp_rw [btw_coe_iff] at h\u2081\u2082\u2083 h\u2082\u2083\u2084 \u22a2\n      apply toIxxMod_trans _ h\u2081\u2082\u2083 h\u2082\u2083\u2084", "start": [941, 1], "end": [958, 39], "kind": "commanddeclaration"}, {"full_name": "QuotientAddGroup.circularOrder", "code": "instance circularOrder : CircularOrder (\u03b1 \u29f8 AddSubgroup.zmultiples p) :=\n  { QuotientAddGroup.circularPreorder with\n    btw_antisymm := fun {x\u2081 x\u2082 x\u2083} h\u2081\u2082\u2083 h\u2083\u2082\u2081 => by\n      induction x\u2081 using QuotientAddGroup.induction_on'\n      induction x\u2082 using QuotientAddGroup.induction_on'\n      induction x\u2083 using QuotientAddGroup.induction_on'\n      rw [btw_cyclic] at h\u2083\u2082\u2081\n      simp_rw [btw_coe_iff] at h\u2081\u2082\u2083 h\u2083\u2082\u2081\n      simp_rw [\u2190 modEq_iff_eq_mod_zmultiples]\n      exact toIxxMod_antisymm _ h\u2081\u2082\u2083 h\u2083\u2082\u2081\n    btw_total := fun x\u2081 x\u2082 x\u2083 => by\n      induction x\u2081 using QuotientAddGroup.induction_on'\n      induction x\u2082 using QuotientAddGroup.induction_on'\n      induction x\u2083 using QuotientAddGroup.induction_on'\n      simp_rw [btw_coe_iff]\n      apply toIxxMod_total }", "start": [961, 1], "end": [976, 29], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_eq_floor", "code": "theorem toIcoDiv_eq_floor (a b : \u03b1) : toIcoDiv hp a b = \u230a(b - a) / p\u230b", "start": [994, 1], "end": [998, 75], "kind": "commanddeclaration"}, {"full_name": "toIocDiv_eq_neg_floor", "code": "theorem toIocDiv_eq_neg_floor (a b : \u03b1) : toIocDiv hp a b = -\u230a(a + p - b) / p\u230b", "start": [1001, 1], "end": [1008, 38], "kind": "commanddeclaration"}, {"full_name": "toIcoDiv_zero_one", "code": "theorem toIcoDiv_zero_one (b : \u03b1) : toIcoDiv (zero_lt_one' \u03b1) 0 b = \u230ab\u230b", "start": [1011, 1], "end": [1012, 27], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_add_fract_mul", "code": "theorem toIcoMod_eq_add_fract_mul (a b : \u03b1) :\n    toIcoMod hp a b = a + Int.fract ((b - a) / p) * p", "start": [1015, 1], "end": [1019, 7], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_eq_fract_mul", "code": "theorem toIcoMod_eq_fract_mul (b : \u03b1) : toIcoMod hp 0 b = Int.fract (b / p) * p", "start": [1022, 1], "end": [1023, 35], "kind": "commanddeclaration"}, {"full_name": "toIocMod_eq_sub_fract_mul", "code": "theorem toIocMod_eq_sub_fract_mul (a b : \u03b1) :\n    toIocMod hp a b = a + p - Int.fract ((a + p - b) / p) * p", "start": [1026, 1], "end": [1030, 7], "kind": "commanddeclaration"}, {"full_name": "toIcoMod_zero_one", "code": "theorem toIcoMod_zero_one (b : \u03b1) : toIcoMod (zero_lt_one' \u03b1) 0 b = Int.fract b", "start": [1033, 1], "end": [1034, 35], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ioc_add_zsmul", "code": "theorem iUnion_Ioc_add_zsmul : \u22c3 n : \u2124, Ioc (a + n \u2022 p) (a + (n + 1) \u2022 p) = univ", "start": [1050, 1], "end": [1055, 48], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ico_add_zsmul", "code": "theorem iUnion_Ico_add_zsmul : \u22c3 n : \u2124, Ico (a + n \u2022 p) (a + (n + 1) \u2022 p) = univ", "start": [1058, 1], "end": [1063, 48], "kind": "commanddeclaration"}, {"full_name": "iUnion_Icc_add_zsmul", "code": "theorem iUnion_Icc_add_zsmul : \u22c3 n : \u2124, Icc (a + n \u2022 p) (a + (n + 1) \u2022 p) = univ", "start": [1066, 1], "end": [1068, 97], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ioc_zsmul", "code": "theorem iUnion_Ioc_zsmul : \u22c3 n : \u2124, Ioc (n \u2022 p) ((n + 1) \u2022 p) = univ", "start": [1071, 1], "end": [1072, 56], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ico_zsmul", "code": "theorem iUnion_Ico_zsmul : \u22c3 n : \u2124, Ico (n \u2022 p) ((n + 1) \u2022 p) = univ", "start": [1075, 1], "end": [1076, 56], "kind": "commanddeclaration"}, {"full_name": "iUnion_Icc_zsmul", "code": "theorem iUnion_Icc_zsmul : \u22c3 n : \u2124, Icc (n \u2022 p) ((n + 1) \u2022 p) = univ", "start": [1079, 1], "end": [1080, 56], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ioc_add_int_cast", "code": "theorem iUnion_Ioc_add_int_cast : \u22c3 n : \u2124, Ioc (a + n) (a + n + 1) = Set.univ", "start": [1089, 1], "end": [1091, 39], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ico_add_int_cast", "code": "theorem iUnion_Ico_add_int_cast : \u22c3 n : \u2124, Ico (a + n) (a + n + 1) = Set.univ", "start": [1094, 1], "end": [1096, 39], "kind": "commanddeclaration"}, {"full_name": "iUnion_Icc_add_int_cast", "code": "theorem iUnion_Icc_add_int_cast : \u22c3 n : \u2124, Icc (a + n) (a + n + 1) = Set.univ", "start": [1099, 1], "end": [1101, 39], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ioc_int_cast", "code": "theorem iUnion_Ioc_int_cast : \u22c3 n : \u2124, Ioc (n : \u03b1) (n + 1) = Set.univ", "start": [1106, 1], "end": [1107, 62], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ico_int_cast", "code": "theorem iUnion_Ico_int_cast : \u22c3 n : \u2124, Ico (n : \u03b1) (n + 1) = Set.univ", "start": [1110, 1], "end": [1111, 62], "kind": "commanddeclaration"}, {"full_name": "iUnion_Icc_int_cast", "code": "theorem iUnion_Icc_int_cast : \u22c3 n : \u2124, Icc (n : \u03b1) (n + 1) = Set.univ", "start": [1114, 1], "end": [1115, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Divisible.lean", "imports": ["Mathlib/Algebra/Group/ULift.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "DivisibleBy", "code": "class DivisibleBy where\n  div : A \u2192 \u03b1 \u2192 A\n  div_zero : \u2200 a, div a 0 = 0\n  div_cancel : \u2200 {n : \u03b1} (a : A), n \u2260 0 \u2192 n \u2022 div a n = a", "start": [78, 1], "end": [87, 58], "kind": "commanddeclaration"}, {"full_name": "RootableBy", "code": "@[to_additive]\nclass RootableBy where\n  root : A \u2192 \u03b1 \u2192 A\n  root_zero : \u2200 a, root a 0 = 1\n  root_cancel : \u2200 {n : \u03b1} (a : A), n \u2260 0 \u2192 root a n ^ n = a", "start": [96, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "pow_left_surj_of_rootableBy", "code": "@[to_additive smul_right_surj_of_divisibleBy]\ntheorem pow_left_surj_of_rootableBy [RootableBy A \u03b1] {n : \u03b1} (hn : n \u2260 0) :\n    Function.Surjective (fun a => a ^ n : A \u2192 A)", "start": [108, 1], "end": [111, 53], "kind": "commanddeclaration"}, {"full_name": "rootableByOfPowLeftSurj", "code": "@[to_additive divisibleByOfSMulRightSurj\n      \"An `AddMonoid A` is `\u03b1`-divisible iff `n \u2022 _` is a surjective function, i.e. the constructive\n      version implies the textbook approach.\"]\nnoncomputable def rootableByOfPowLeftSurj\n    (H : \u2200 {n : \u03b1}, n \u2260 0 \u2192 Function.Surjective (fun a => a ^ n : A \u2192 A)) : RootableBy A \u03b1 where\n  root a n := @dite _ (n = 0) (Classical.dec _) (fun _ => (1 : A)) fun hn => (H hn a).choose\n  root_zero _ := by classical exact dif_pos rfl\n  root_cancel a hn := by\n    dsimp only\n    rw [dif_neg hn]\n    exact (H hn a).choose_spec", "start": [115, 1], "end": [129, 31], "kind": "commanddeclaration"}, {"full_name": "Pi.rootableBy", "code": "@[to_additive]\ninstance Pi.rootableBy : RootableBy (\u2200 i, B i) \u03b2 where\n  root x n i := RootableBy.root (x i) n\n  root_zero _x := funext fun _i => RootableBy.root_zero _\n  root_cancel _x hn := funext fun _i => RootableBy.root_cancel _ hn", "start": [139, 1], "end": [143, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.rootableBy", "code": "@[to_additive]\ninstance Prod.rootableBy : RootableBy (B \u00d7 B') \u03b2 where\n  root p n := (RootableBy.root p.1 n, RootableBy.root p.2 n)\n  root_zero _p := Prod.ext (RootableBy.root_zero _) (RootableBy.root_zero _)\n  root_cancel _p hn := Prod.ext (RootableBy.root_cancel _ hn) (RootableBy.root_cancel _ hn)", "start": [155, 1], "end": [159, 92], "kind": "commanddeclaration"}, {"full_name": "ULift.instRootableBy", "code": "@[to_additive]\ninstance ULift.instRootableBy [RootableBy A \u03b1] : RootableBy (ULift A) \u03b1 where\n  root x a := ULift.up <| RootableBy.root x.down a\n  root_zero x := ULift.ext _ _ <| RootableBy.root_zero x.down\n  root_cancel _ h := ULift.ext _ _ <| RootableBy.root_cancel _ h", "start": [167, 1], "end": [171, 65], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.smul_top_eq_top_of_divisibleBy_int", "code": "theorem smul_top_eq_top_of_divisibleBy_int [DivisibleBy A \u2124] {n : \u2124} (hn : n \u2260 0) :\n    n \u2022 (\u22a4 : AddSubgroup A) = \u22a4", "start": [181, 1], "end": [183, 98], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.divisibleByIntOfSmulTopEqTop", "code": "noncomputable def divisibleByIntOfSmulTopEqTop\n    (H : \u2200 {n : \u2124} (_hn : n \u2260 0), n \u2022 (\u22a4 : AddSubgroup A) = \u22a4) : DivisibleBy A \u2124 where\n  div a n :=\n    if hn : n = 0 then 0 else (show a \u2208 n \u2022 (\u22a4 : AddSubgroup A) by rw [H hn]; trivial).choose\n  div_zero a := dif_pos rfl\n  div_cancel a hn := by\n    simp_rw [dif_neg hn]\n    generalize_proofs h1\n    exact h1.choose_spec.2", "start": [186, 1], "end": [196, 27], "kind": "commanddeclaration"}, {"full_name": "divisibleByIntOfCharZero", "code": "instance (priority := 100) divisibleByIntOfCharZero {\ud835\udd5c} [DivisionRing \ud835\udd5c] [CharZero \ud835\udd5c] :\n    DivisibleBy \ud835\udd5c \u2124 where\n  div q n := q / n\n  div_zero q := by norm_num\n  div_cancel {n} q hn := by\n    rw [zsmul_eq_mul, (Int.cast_commute n _).eq, div_mul_cancel q (Int.cast_ne_zero.mpr hn)]", "start": [201, 1], "end": [206, 93], "kind": "commanddeclaration"}, {"full_name": "Group.rootableByIntOfRootableByNat", "code": "@[to_additive \"An additive group is `\u2124`-divisible if it is `\u2115`-divisible.\"]\ndef rootableByIntOfRootableByNat [RootableBy A \u2115] : RootableBy A \u2124 where\n  root a z :=\n    match z with\n    | (n : \u2115) => RootableBy.root a n\n    | -[n+1] => (RootableBy.root a (n + 1))\u207b\u00b9\n  root_zero a := RootableBy.root_zero a\n  root_cancel {n} a hn := by\n    induction n\n    \u00b7 change RootableBy.root a _ ^ _ = a\n      norm_num\n      rw [RootableBy.root_cancel]\n      rw [Int.ofNat_eq_coe] at hn\n      exact_mod_cast hn\n    \u00b7 change (RootableBy.root a _)\u207b\u00b9 ^ _ = a\n      norm_num\n      rw [RootableBy.root_cancel]\n      norm_num", "start": [214, 1], "end": [233, 15], "kind": "commanddeclaration"}, {"full_name": "Group.rootableByNatOfRootableByInt", "code": "@[to_additive \"An additive group is `\u2115`-divisible if it `\u2124`-divisible.\"]\ndef rootableByNatOfRootableByInt [RootableBy A \u2124] : RootableBy A \u2115 where\n  root a n := RootableBy.root a (n : \u2124)\n  root_zero a := RootableBy.root_zero a\n  root_cancel {n} a hn := by\n    simpa only [zpow_coe_nat] using RootableBy.root_cancel a (show (n : \u2124) \u2260 0 by exact_mod_cast hn)", "start": [237, 1], "end": [245, 101], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.rootableBy", "code": "@[to_additive\n      \"If `f : A \u2192 B` is a surjective homomorphism and `A` is `\u03b1`-divisible, then `B` is also\n      `\u03b1`-divisible.\"]\nnoncomputable def Function.Surjective.rootableBy (hf : Function.Surjective f)\n    (hpow : \u2200 (a : A) (n : \u03b1), f (a ^ n) = f a ^ n) : RootableBy B \u03b1 :=\n  rootableByOfPowLeftSurj _ _ fun {n} hn x =>\n    let \u27e8y, hy\u27e9 := hf x\n    \u27e8f <| RootableBy.root y n,\n      (by rw [\u2190 hpow (RootableBy.root y n) n, RootableBy.root_cancel _ hn, hy] : _ ^ n = x)\u27e9", "start": [260, 1], "end": [271, 93], "kind": "commanddeclaration"}, {"full_name": "RootableBy.surjective_pow", "code": "@[to_additive DivisibleBy.surjective_smul]\ntheorem RootableBy.surjective_pow (A \u03b1 : Type*) [Monoid A] [Pow A \u03b1] [Zero \u03b1] [RootableBy A \u03b1]\n    {n : \u03b1} (hn : n \u2260 0) : Function.Surjective fun a : A => a ^ n", "start": [275, 1], "end": [278, 53], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rootableBy", "code": "@[to_additive \"Any quotient group of a divisible group is divisible\"]\nnoncomputable instance QuotientGroup.rootableBy [RootableBy A \u2115] : RootableBy (A \u29f8 B) \u2115 :=\n  QuotientGroup.mk_surjective.rootableBy _ fun _ _ => rfl", "start": [288, 1], "end": [291, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Connected/PathConnected.lean", "imports": ["Mathlib/Topology/CompactOpen.lean", "Mathlib/Topology/Algebra/Order/ProjIcc.lean", "Mathlib/Topology/UnitInterval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Path", "code": "structure Path (x y : X) extends C(I, X) where\n  \n  source' : toFun 0 = x\n  \n  target' : toFun 1 = y", "start": [72, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Path.continuousMapClass", "code": "instance Path.continuousMapClass : ContinuousMapClass (Path x y) I X where\n  coe := fun \u03b3 \u21a6 \u21d1\u03b3.toContinuousMap\n  coe_injective' := fun \u03b3\u2081 \u03b3\u2082 h => by\n    simp only [FunLike.coe_fn_eq] at h\n    cases \u03b3\u2081; cases \u03b3\u2082; congr\n  map_continuous := fun \u03b3 => by continuity", "start": [83, 1], "end": [88, 43], "kind": "commanddeclaration"}, {"full_name": "Path.ext", "code": "@[ext]\nprotected theorem Path.ext : \u2200 {\u03b3\u2081 \u03b3\u2082 : Path x y}, (\u03b3\u2081 : I \u2192 X) = \u03b3\u2082 \u2192 \u03b3\u2081 = \u03b3\u2082", "start": [96, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Path.coe_mk_mk", "code": "@[simp]\ntheorem coe_mk_mk (f : I \u2192 X) (h\u2081) (h\u2082 : f 0 = x) (h\u2083 : f 1 = y) :\n    \u21d1(mk \u27e8f, h\u2081\u27e9 h\u2082 h\u2083 : Path x y) = f", "start": [104, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Path.continuous", "code": "@[continuity]\nprotected theorem continuous : Continuous \u03b3", "start": [113, 1], "end": [115, 21], "kind": "commanddeclaration"}, {"full_name": "Path.source", "code": "@[simp]\nprotected theorem source : \u03b3 0 = x", "start": [118, 1], "end": [120, 12], "kind": "commanddeclaration"}, {"full_name": "Path.target", "code": "@[simp]\nprotected theorem target : \u03b3 1 = y", "start": [123, 1], "end": [125, 12], "kind": "commanddeclaration"}, {"full_name": "Path.simps.apply", "code": "def simps.apply : I \u2192 X :=\n  \u03b3", "start": [128, 1], "end": [131, 4], "kind": "commanddeclaration"}, {"full_name": "Path.coe_toContinuousMap", "code": "@[simp]\ntheorem coe_toContinuousMap : \u21d1\u03b3.toContinuousMap = \u03b3", "start": [136, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "Path.coe_mk", "code": "@[simp]\ntheorem coe_mk : \u21d1(\u03b3 : C(I, X)) = \u03b3", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "Path.hasUncurryPath", "code": "instance hasUncurryPath {X \u03b1 : Type*} [TopologicalSpace X] {x y : \u03b1 \u2192 X} :\n    HasUncurry (\u2200 a : \u03b1, Path (x a) (y a)) (\u03b1 \u00d7 I) X :=\n  \u27e8fun \u03c6 p => \u03c6 p.1 p.2\u27e9", "start": [146, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "Path.refl", "code": "@[refl, simps]\ndef refl (x : X) : Path x x where\n  toFun _t := x\n  continuous_toFun := continuous_const\n  source' := rfl\n  target' := rfl", "start": [152, 1], "end": [158, 17], "kind": "commanddeclaration"}, {"full_name": "Path.refl_range", "code": "@[simp]\ntheorem refl_range {a : X} : range (Path.refl a) = {a}", "start": [161, 1], "end": [162, 90], "kind": "commanddeclaration"}, {"full_name": "Path.symm", "code": "@[symm, simps]\ndef symm (\u03b3 : Path x y) : Path y x where\n  toFun := \u03b3 \u2218 \u03c3\n  continuous_toFun := by continuity\n  source' := by simpa [-Path.target] using \u03b3.target\n  target' := by simpa [-Path.source] using \u03b3.source", "start": [165, 1], "end": [171, 52], "kind": "commanddeclaration"}, {"full_name": "Path.symm_symm", "code": "@[simp]\ntheorem symm_symm {\u03b3 : Path x y} : \u03b3.symm.symm = \u03b3", "start": [174, 1], "end": [178, 30], "kind": "commanddeclaration"}, {"full_name": "Path.refl_symm", "code": "@[simp]\ntheorem refl_symm {a : X} : (Path.refl a).symm = Path.refl a", "start": [181, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "Path.symm_range", "code": "@[simp]\ntheorem symm_range {a b : X} (\u03b3 : Path a b) : range \u03b3.symm = range \u03b3", "start": [187, 1], "end": [194, 7], "kind": "commanddeclaration"}, {"full_name": "Path.topologicalSpace", "code": "instance topologicalSpace : TopologicalSpace (Path x y) :=\n  TopologicalSpace.induced ((\u2191) : _ \u2192 C(I, X)) ContinuousMap.compactOpen", "start": [208, 1], "end": [212, 73], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_eval", "code": "theorem continuous_eval : Continuous fun p : Path x y \u00d7 I => p.1 p.2", "start": [214, 1], "end": [215, 91], "kind": "commanddeclaration"}, {"full_name": "Continuous.path_eval", "code": "@[continuity]\ntheorem _root_.Continuous.path_eval {Y} [TopologicalSpace Y] {f : Y \u2192 Path x y} {g : Y \u2192 I}\n    (hf : Continuous f) (hg : Continuous g) : Continuous fun y => f y (g y)", "start": [218, 1], "end": [221, 50], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_uncurry_iff", "code": "theorem continuous_uncurry_iff {Y} [TopologicalSpace Y] {g : Y \u2192 Path x y} :\n    Continuous \u21bfg \u2194 Continuous g", "start": [224, 1], "end": [228, 77], "kind": "commanddeclaration"}, {"full_name": "Path.extend", "code": "def extend : \u211d \u2192 X :=\n  IccExtend zero_le_one \u03b3", "start": [231, 1], "end": [233, 26], "kind": "commanddeclaration"}, {"full_name": "Continuous.path_extend", "code": "theorem _root_.Continuous.path_extend {\u03b3 : Y \u2192 Path x y} {f : Y \u2192 \u211d} (h\u03b3 : Continuous \u21bf\u03b3)\n    (hf : Continuous f) : Continuous fun t => (\u03b3 t).extend (f t)", "start": [236, 1], "end": [239, 29], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_extend", "code": "@[continuity]\ntheorem continuous_extend : Continuous \u03b3.extend", "start": [242, 1], "end": [245, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.path_extend", "code": "theorem _root_.Filter.Tendsto.path_extend {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    {l r : Y \u2192 X} {y : Y} {l\u2081 : Filter \u211d} {l\u2082 : Filter X} {\u03b3 : \u2200 y, Path (l y) (r y)}\n    (h\u03b3 : Tendsto (\u21bf\u03b3) (\ud835\udcdd y \u00d7\u02e2 l\u2081.map (projIcc 0 1 zero_le_one)) l\u2082) :\n    Tendsto (\u21bffun x => (\u03b3 x).extend) (\ud835\udcdd y \u00d7\u02e2 l\u2081) l\u2082", "start": [248, 1], "end": [252, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.path_extend", "code": "theorem _root_.ContinuousAt.path_extend {g : Y \u2192 \u211d} {l r : Y \u2192 X} (\u03b3 : \u2200 y, Path (l y) (r y))\n    {y : Y} (h\u03b3 : ContinuousAt (\u21bf\u03b3) (y, projIcc 0 1 zero_le_one (g y))) (hg : ContinuousAt g y) :\n    ContinuousAt (fun i => (\u03b3 i).extend (g i)) y", "start": [255, 1], "end": [258, 33], "kind": "commanddeclaration"}, {"full_name": "Path.extend_extends", "code": "@[simp]\ntheorem extend_extends {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) {t : \u211d}\n    (ht : t \u2208 (Icc 0 1 : Set \u211d)) : \u03b3.extend t = \u03b3 \u27e8t, ht\u27e9", "start": [261, 1], "end": [264, 26], "kind": "commanddeclaration"}, {"full_name": "Path.extend_zero", "code": "theorem extend_zero : \u03b3.extend 0 = x", "start": [267, 1], "end": [267, 48], "kind": "commanddeclaration"}, {"full_name": "Path.extend_one", "code": "theorem extend_one : \u03b3.extend 1 = y", "start": [270, 1], "end": [270, 47], "kind": "commanddeclaration"}, {"full_name": "Path.extend_extends'", "code": "@[simp]\ntheorem extend_extends' {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b)\n    (t : (Icc 0 1 : Set \u211d)) : \u03b3.extend t = \u03b3 t", "start": [273, 1], "end": [276, 22], "kind": "commanddeclaration"}, {"full_name": "Path.extend_range", "code": "@[simp]\ntheorem extend_range {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) :\n    range \u03b3.extend = range \u03b3", "start": [279, 1], "end": [282, 22], "kind": "commanddeclaration"}, {"full_name": "Path.extend_of_le_zero", "code": "theorem extend_of_le_zero {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) {t : \u211d}\n    (ht : t \u2264 0) : \u03b3.extend t = a", "start": [285, 1], "end": [287, 47], "kind": "commanddeclaration"}, {"full_name": "Path.extend_of_one_le", "code": "theorem extend_of_one_le {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) {t : \u211d}\n    (ht : 1 \u2264 t) : \u03b3.extend t = b", "start": [290, 1], "end": [292, 48], "kind": "commanddeclaration"}, {"full_name": "Path.refl_extend", "code": "@[simp]\ntheorem refl_extend {X : Type*} [TopologicalSpace X] {a : X} : (Path.refl a).extend = fun _ => a", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "Path.ofLine", "code": "def ofLine {f : \u211d \u2192 X} (hf : ContinuousOn f I) (h\u2080 : f 0 = x) (h\u2081 : f 1 = y) : Path x y where\n  toFun := f \u2218 ((\u2191) : unitInterval \u2192 \u211d)\n  continuous_toFun := hf.comp_continuous continuous_subtype_val Subtype.prop\n  source' := h\u2080\n  target' := h\u2081", "start": [300, 1], "end": [305, 16], "kind": "commanddeclaration"}, {"full_name": "Path.ofLine_mem", "code": "theorem ofLine_mem {f : \u211d \u2192 X} (hf : ContinuousOn f I) (h\u2080 : f 0 = x) (h\u2081 : f 1 = y) :\n    \u2200 t, ofLine hf h\u2080 h\u2081 t \u2208 f '' I", "start": [308, 1], "end": [309, 71], "kind": "commanddeclaration"}, {"full_name": "Path.trans", "code": "@[trans]\ndef trans (\u03b3 : Path x y) (\u03b3' : Path y z) : Path x z where\n  toFun := (fun t : \u211d => if t \u2264 1 / 2 then \u03b3.extend (2 * t) else \u03b3'.extend (2 * t - 1)) \u2218 (\u2191)\n  continuous_toFun := by\n    refine'\n      (Continuous.if_le _ _ continuous_id continuous_const (by norm_num)).comp\n        continuous_subtype_val <;>\n    continuity\n  source' := by norm_num\n  target' := by norm_num", "start": [314, 1], "end": [325, 25], "kind": "commanddeclaration"}, {"full_name": "Path.trans_apply", "code": "theorem trans_apply (\u03b3 : Path x y) (\u03b3' : Path y z) (t : I) :\n    (\u03b3.trans \u03b3') t =\n      if h : (t : \u211d) \u2264 1 / 2 then \u03b3 \u27e82 * t, (mul_pos_mem_iff zero_lt_two).2 \u27e8t.2.1, h\u27e9\u27e9\n      else \u03b3' \u27e82 * t - 1, two_mul_sub_one_mem_iff.2 \u27e8(not_le.1 h).le, t.2.2\u27e9\u27e9", "start": [328, 1], "end": [332, 58], "kind": "commanddeclaration"}, {"full_name": "Path.trans_symm", "code": "@[simp]\ntheorem trans_symm (\u03b3 : Path x y) (\u03b3' : Path y z) : (\u03b3.trans \u03b3').symm = \u03b3'.symm.trans \u03b3.symm", "start": [335, 1], "end": [348, 13], "kind": "commanddeclaration"}, {"full_name": "Path.refl_trans_refl", "code": "@[simp]\ntheorem refl_trans_refl {X : Type*} [TopologicalSpace X] {a : X} :\n    (Path.refl a).trans (Path.refl a) = Path.refl a", "start": [351, 1], "end": [356, 6], "kind": "commanddeclaration"}, {"full_name": "Path.trans_range", "code": "theorem trans_range {X : Type*} [TopologicalSpace X] {a b c : X} (\u03b3\u2081 : Path a b) (\u03b3\u2082 : Path b c) :\n    range (\u03b3\u2081.trans \u03b3\u2082) = range \u03b3\u2081 \u222a range \u03b3\u2082", "start": [359, 1], "end": [393, 32], "kind": "commanddeclaration"}, {"full_name": "Path.map'", "code": "def map' (\u03b3 : Path x y) {Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}\n    (h : ContinuousOn f (range \u03b3)) : Path (f x) (f y) where\n  toFun := f \u2218 \u03b3\n  continuous_toFun := h.comp_continuous \u03b3.continuous (fun x \u21a6 mem_range_self x)\n  source' := by simp\n  target' := by simp", "start": [396, 1], "end": [402, 21], "kind": "commanddeclaration"}, {"full_name": "Path.map", "code": "def map (\u03b3 : Path x y) {Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y} (h : Continuous f) :\n    Path (f x) (f y) := \u03b3.map' h.continuousOn", "start": [404, 1], "end": [406, 46], "kind": "commanddeclaration"}, {"full_name": "Path.map_coe", "code": "@[simp]\ntheorem map_coe (\u03b3 : Path x y) {Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y} (h : Continuous f) :\n    (\u03b3.map h : I \u2192 Y) = f \u2218 \u03b3", "start": [409, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "Path.map_symm", "code": "@[simp]\ntheorem map_symm (\u03b3 : Path x y) {Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y} (h : Continuous f) :\n    (\u03b3.map h).symm = \u03b3.symm.map h", "start": [416, 1], "end": [419, 6], "kind": "commanddeclaration"}, {"full_name": "Path.map_trans", "code": "@[simp]\ntheorem map_trans (\u03b3 : Path x y) (\u03b3' : Path y z) {Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}\n    (h : Continuous f) : (\u03b3.trans \u03b3').map h = (\u03b3.map h).trans (\u03b3'.map h)", "start": [422, 1], "end": [427, 20], "kind": "commanddeclaration"}, {"full_name": "Path.map_id", "code": "@[simp]\ntheorem map_id (\u03b3 : Path x y) : \u03b3.map continuous_id = \u03b3", "start": [430, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "Path.map_map", "code": "@[simp]\ntheorem map_map (\u03b3 : Path x y) {Y : Type*} [TopologicalSpace Y] {Z : Type*} [TopologicalSpace Z]\n    {f : X \u2192 Y} (hf : Continuous f) {g : Y \u2192 Z} (hg : Continuous g) :\n    (\u03b3.map hf).map hg = \u03b3.map (hg.comp hf)", "start": [436, 1], "end": [441, 6], "kind": "commanddeclaration"}, {"full_name": "Path.cast", "code": "def cast (\u03b3 : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : Path x' y' where\n  toFun := \u03b3\n  continuous_toFun := \u03b3.continuous\n  source' := by simp [hx]\n  target' := by simp [hy]", "start": [444, 1], "end": [449, 26], "kind": "commanddeclaration"}, {"full_name": "Path.symm_cast", "code": "@[simp]\ntheorem symm_cast {X : Type*} [TopologicalSpace X] {a\u2081 a\u2082 b\u2081 b\u2082 : X} (\u03b3 : Path a\u2082 b\u2082)\n    (ha : a\u2081 = a\u2082) (hb : b\u2081 = b\u2082) : (\u03b3.cast ha hb).symm = \u03b3.symm.cast hb ha", "start": [452, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "Path.trans_cast", "code": "@[simp]\ntheorem trans_cast {X : Type*} [TopologicalSpace X] {a\u2081 a\u2082 b\u2081 b\u2082 c\u2081 c\u2082 : X} (\u03b3 : Path a\u2082 b\u2082)\n    (\u03b3' : Path b\u2082 c\u2082) (ha : a\u2081 = a\u2082) (hb : b\u2081 = b\u2082) (hc : c\u2081 = c\u2082) :\n    (\u03b3.cast ha hb).trans (\u03b3'.cast hb hc) = (\u03b3.trans \u03b3').cast ha hc", "start": [458, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "Path.cast_coe", "code": "@[simp]\ntheorem cast_coe (\u03b3 : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (\u03b3.cast hx hy : I \u2192 X) = \u03b3", "start": [465, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "Path.symm_continuous_family", "code": "@[continuity]\ntheorem symm_continuous_family {X \u03b9 : Type*} [TopologicalSpace X] [TopologicalSpace \u03b9]\n    {a b : \u03b9 \u2192 X} (\u03b3 : \u2200 t : \u03b9, Path (a t) (b t)) (h : Continuous \u21bf\u03b3) :\n    Continuous \u21bffun t => (\u03b3 t).symm", "start": [470, 1], "end": [474, 50], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_symm", "code": "@[continuity]\ntheorem continuous_symm : Continuous (symm : Path x y \u2192 Path y x)", "start": [477, 1], "end": [479, 98], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_uncurry_extend_of_continuous_family", "code": "@[continuity]\ntheorem continuous_uncurry_extend_of_continuous_family {X \u03b9 : Type*} [TopologicalSpace X]\n    [TopologicalSpace \u03b9] {a b : \u03b9 \u2192 X} (\u03b3 : \u2200 t : \u03b9, Path (a t) (b t)) (h : Continuous \u21bf\u03b3) :\n    Continuous \u21bffun t => (\u03b3 t).extend", "start": [482, 1], "end": [487, 20], "kind": "commanddeclaration"}, {"full_name": "Path.trans_continuous_family", "code": "@[continuity]\ntheorem trans_continuous_family {X \u03b9 : Type*} [TopologicalSpace X] [TopologicalSpace \u03b9]\n    {a b c : \u03b9 \u2192 X} (\u03b3\u2081 : \u2200 t : \u03b9, Path (a t) (b t)) (h\u2081 : Continuous \u21bf\u03b3\u2081)\n    (\u03b3\u2082 : \u2200 t : \u03b9, Path (b t) (c t)) (h\u2082 : Continuous \u21bf\u03b3\u2082) :\n    Continuous \u21bffun t => (\u03b3\u2081 t).trans (\u03b3\u2082 t)", "start": [490, 1], "end": [509, 48], "kind": "commanddeclaration"}, {"full_name": "Continuous.path_trans", "code": "@[continuity]\ntheorem _root_.Continuous.path_trans {f : Y \u2192 Path x y} {g : Y \u2192 Path y z} :\n    Continuous f \u2192 Continuous g \u2192 Continuous fun t => (f t).trans (g t)", "start": [512, 1], "end": [517, 100], "kind": "commanddeclaration"}, {"full_name": "Path.continuous_trans", "code": "@[continuity]\ntheorem continuous_trans {x y z : X} : Continuous fun \u03c1 : Path x y \u00d7 Path y z => \u03c1.1.trans \u03c1.2", "start": [520, 1], "end": [522, 43], "kind": "commanddeclaration"}, {"full_name": "Path.prod", "code": "protected def prod (\u03b3\u2081 : Path a\u2081 a\u2082) (\u03b3\u2082 : Path b\u2081 b\u2082) : Path (a\u2081, b\u2081) (a\u2082, b\u2082) where\n  toContinuousMap := ContinuousMap.prodMk \u03b3\u2081.toContinuousMap \u03b3\u2082.toContinuousMap\n  source' := by simp\n  target' := by simp", "start": [532, 1], "end": [537, 21], "kind": "commanddeclaration"}, {"full_name": "Path.prod_coe", "code": "@[simp]\ntheorem prod_coe (\u03b3\u2081 : Path a\u2081 a\u2082) (\u03b3\u2082 : Path b\u2081 b\u2082) :\n    \u21d1(\u03b3\u2081.prod \u03b3\u2082) = fun t => (\u03b3\u2081 t, \u03b3\u2082 t)", "start": [540, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "Path.trans_prod_eq_prod_trans", "code": "theorem trans_prod_eq_prod_trans (\u03b3\u2081 : Path a\u2081 a\u2082) (\u03b4\u2081 : Path a\u2082 a\u2083) (\u03b3\u2082 : Path b\u2081 b\u2082)\n    (\u03b4\u2082 : Path b\u2082 b\u2083) : (\u03b3\u2081.prod \u03b3\u2082).trans (\u03b4\u2081.prod \u03b4\u2082) = (\u03b3\u2081.trans \u03b4\u2081).prod (\u03b3\u2082.trans \u03b4\u2082)", "start": [546, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "Path.pi", "code": "protected def pi (\u03b3 : \u2200 i, Path (as i) (bs i)) : Path as bs where\n  toContinuousMap := ContinuousMap.pi fun i => (\u03b3 i).toContinuousMap\n  source' := by simp\n  target' := by simp", "start": [562, 1], "end": [567, 21], "kind": "commanddeclaration"}, {"full_name": "Path.pi_coe", "code": "@[simp]\ntheorem pi_coe (\u03b3 : \u2200 i, Path (as i) (bs i)) : \u21d1(Path.pi \u03b3) = fun t i => \u03b3 i t", "start": [570, 1], "end": [572, 6], "kind": "commanddeclaration"}, {"full_name": "Path.trans_pi_eq_pi_trans", "code": "theorem trans_pi_eq_pi_trans (\u03b3\u2080 : \u2200 i, Path (as i) (bs i)) (\u03b3\u2081 : \u2200 i, Path (bs i) (cs i)) :\n    (Path.pi \u03b3\u2080).trans (Path.pi \u03b3\u2081) = Path.pi fun i => (\u03b3\u2080 i).trans (\u03b3\u2081 i)", "start": [575, 1], "end": [581, 20], "kind": "commanddeclaration"}, {"full_name": "Path.mul", "code": "@[to_additive \"Pointwise addition of paths in a topological additive group.\"]\nprotected def mul [Mul X] [ContinuousMul X] {a\u2081 b\u2081 a\u2082 b\u2082 : X} (\u03b3\u2081 : Path a\u2081 b\u2081) (\u03b3\u2082 : Path a\u2082 b\u2082) :\n    Path (a\u2081 * a\u2082) (b\u2081 * b\u2082) :=\n  (\u03b3\u2081.prod \u03b3\u2082).map continuous_mul", "start": [589, 1], "end": [594, 34], "kind": "commanddeclaration"}, {"full_name": "Path.mul_apply", "code": "@[to_additive]\nprotected theorem mul_apply [Mul X] [ContinuousMul X] {a\u2081 b\u2081 a\u2082 b\u2082 : X} (\u03b3\u2081 : Path a\u2081 b\u2081)\n    (\u03b3\u2082 : Path a\u2082 b\u2082) (t : unitInterval) : (\u03b3\u2081.mul \u03b3\u2082) t = \u03b3\u2081 t * \u03b3\u2082 t", "start": [598, 1], "end": [601, 6], "kind": "commanddeclaration"}, {"full_name": "Path.truncate", "code": "def truncate {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) (t\u2080 t\u2081 : \u211d) :\n    Path (\u03b3.extend <| min t\u2080 t\u2081) (\u03b3.extend t\u2081) where\n  toFun s := \u03b3.extend (min (max s t\u2080) t\u2081)\n  continuous_toFun :=\n    \u03b3.continuous_extend.comp ((continuous_subtype_val.max continuous_const).min continuous_const)\n  source' := by\n    simp only [min_def, max_def']\n    norm_cast\n    split_ifs with h\u2081 h\u2082 h\u2083 h\u2084\n    \u00b7 simp [\u03b3.extend_of_le_zero h\u2081]\n    \u00b7 congr\n      linarith\n    \u00b7 have h\u2084 : t\u2081 \u2264 0 := le_of_lt (by simpa using h\u2082)\n      simp [\u03b3.extend_of_le_zero h\u2084, \u03b3.extend_of_le_zero h\u2081]\n    all_goals rfl\n  target' := by\n    simp only [min_def, max_def']\n    norm_cast\n    split_ifs with h\u2081 h\u2082 h\u2083\n    \u00b7 simp [\u03b3.extend_of_one_le h\u2082]\n    \u00b7 rfl\n    \u00b7 have h\u2084 : 1 \u2264 t\u2080 := le_of_lt (by simpa using h\u2081)\n      simp [\u03b3.extend_of_one_le h\u2084, \u03b3.extend_of_one_le (h\u2084.trans h\u2083)]\n    \u00b7 rfl", "start": [608, 1], "end": [633, 10], "kind": "commanddeclaration"}, {"full_name": "Path.truncateOfLE", "code": "def truncateOfLE {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) {t\u2080 t\u2081 : \u211d}\n    (h : t\u2080 \u2264 t\u2081) : Path (\u03b3.extend t\u2080) (\u03b3.extend t\u2081) :=\n  (\u03b3.truncate t\u2080 t\u2081).cast (by rw [min_eq_left h]) rfl", "start": [636, 1], "end": [640, 54], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_range", "code": "theorem truncate_range {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) {t\u2080 t\u2081 : \u211d} :\n    range (\u03b3.truncate t\u2080 t\u2081) \u2286 range \u03b3", "start": [643, 1], "end": [648, 57], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_continuous_family", "code": "@[continuity]\ntheorem truncate_continuous_family {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) :\n    Continuous (fun x => \u03b3.truncate x.1 x.2.1 x.2.2 : \u211d \u00d7 \u211d \u00d7 I \u2192 X)", "start": [651, 1], "end": [658, 44], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_const_continuous_family", "code": "@[continuity]\ntheorem truncate_const_continuous_family {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b)\n    (t : \u211d) : Continuous \u21bf(\u03b3.truncate t)", "start": [661, 1], "end": [665, 46], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_self", "code": "@[simp]\ntheorem truncate_self {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) (t : \u211d) :\n    \u03b3.truncate t t = (Path.refl <| \u03b3.extend t).cast (by rw [min_self]) rfl", "start": [668, 1], "end": [674, 33], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_zero_zero", "code": "@[simp 1001] theorem truncate_zero_zero {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) :\n    \u03b3.truncate 0 0 = (Path.refl a).cast (by rw [min_self, \u03b3.extend_zero]) \u03b3.extend_zero", "start": [677, 1], "end": [680, 28], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_one_one", "code": "@[simp 1001] theorem truncate_one_one {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) :\n    \u03b3.truncate 1 1 = (Path.refl b).cast (by rw [min_self, \u03b3.extend_one]) \u03b3.extend_one", "start": [683, 1], "end": [686, 28], "kind": "commanddeclaration"}, {"full_name": "Path.truncate_zero_one", "code": "@[simp]\ntheorem truncate_zero_one {X : Type*} [TopologicalSpace X] {a b : X} (\u03b3 : Path a b) :\n    \u03b3.truncate 0 1 = \u03b3.cast (by simp [zero_le_one, extend_zero]) (by simp)", "start": [689, 1], "end": [695, 84], "kind": "commanddeclaration"}, {"full_name": "Path.reparam", "code": "def reparam (\u03b3 : Path x y) (f : I \u2192 I) (hfcont : Continuous f) (hf\u2080 : f 0 = 0) (hf\u2081 : f 1 = 1) :\n    Path x y where\n  toFun := \u03b3 \u2218 f\n  continuous_toFun := by continuity\n  source' := by simp [hf\u2080]\n  target' := by simp [hf\u2081]", "start": [701, 1], "end": [709, 27], "kind": "commanddeclaration"}, {"full_name": "Path.coe_reparam", "code": "@[simp]\ntheorem coe_reparam (\u03b3 : Path x y) {f : I \u2192 I} (hfcont : Continuous f) (hf\u2080 : f 0 = 0)\n    (hf\u2081 : f 1 = 1) : \u21d1(\u03b3.reparam f hfcont hf\u2080 hf\u2081) = \u03b3 \u2218 f", "start": [712, 1], "end": [715, 6], "kind": "commanddeclaration"}, {"full_name": "Path.reparam_id", "code": "@[simp]\ntheorem reparam_id (\u03b3 : Path x y) : \u03b3.reparam id continuous_id rfl rfl = \u03b3", "start": [719, 1], "end": [722, 6], "kind": "commanddeclaration"}, {"full_name": "Path.range_reparam", "code": "theorem range_reparam (\u03b3 : Path x y) {f : I \u2192 I} (hfcont : Continuous f) (hf\u2080 : f 0 = 0)\n    (hf\u2081 : f 1 = 1) : range (\u03b3.reparam f hfcont hf\u2080 hf\u2081) = range \u03b3", "start": [725, 1], "end": [737, 36], "kind": "commanddeclaration"}, {"full_name": "Path.refl_reparam", "code": "theorem refl_reparam {f : I \u2192 I} (hfcont : Continuous f) (hf\u2080 : f 0 = 0) (hf\u2081 : f 1 = 1) :\n    (refl x).reparam f hfcont hf\u2080 hf\u2081 = refl x", "start": [740, 1], "end": [743, 7], "kind": "commanddeclaration"}, {"full_name": "Joined", "code": "def Joined (x y : X) : Prop :=\n  Nonempty (Path x y)", "start": [751, 1], "end": [753, 22], "kind": "commanddeclaration"}, {"full_name": "Joined.refl", "code": "@[refl]\ntheorem Joined.refl (x : X) : Joined x x", "start": [756, 1], "end": [758, 16], "kind": "commanddeclaration"}, {"full_name": "Joined.somePath", "code": "def Joined.somePath (h : Joined x y) : Path x y :=\n  Nonempty.some h", "start": [761, 1], "end": [763, 18], "kind": "commanddeclaration"}, {"full_name": "Joined.symm", "code": "@[symm]\ntheorem Joined.symm {x y : X} (h : Joined x y) : Joined y x", "start": [766, 1], "end": [768, 20], "kind": "commanddeclaration"}, {"full_name": "Joined.trans", "code": "@[trans]\ntheorem Joined.trans {x y z : X} (hxy : Joined x y) (hyz : Joined y z) : Joined x z", "start": [771, 1], "end": [773, 36], "kind": "commanddeclaration"}, {"full_name": "pathSetoid", "code": "def pathSetoid : Setoid X where\n  r := Joined\n  iseqv := Equivalence.mk Joined.refl Joined.symm Joined.trans", "start": [778, 1], "end": [781, 63], "kind": "commanddeclaration"}, {"full_name": "ZerothHomotopy", "code": "def ZerothHomotopy :=\n  Quotient (pathSetoid X)", "start": [784, 1], "end": [786, 26], "kind": "commanddeclaration"}, {"full_name": "ZerothHomotopy.inhabited", "code": "instance ZerothHomotopy.inhabited : Inhabited (ZerothHomotopy \u211d) :=\n  \u27e8@Quotient.mk' \u211d (pathSetoid \u211d) 0\u27e9", "start": [789, 1], "end": [790, 37], "kind": "commanddeclaration"}, {"full_name": "JoinedIn", "code": "def JoinedIn (F : Set X) (x y : X) : Prop :=\n  \u2203 \u03b3 : Path x y, \u2200 t, \u03b3 t \u2208 F", "start": [797, 1], "end": [800, 31], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.mem", "code": "theorem JoinedIn.mem (h : JoinedIn F x y) : x \u2208 F \u2227 y \u2208 F", "start": [805, 1], "end": [808, 19], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.source_mem", "code": "theorem JoinedIn.source_mem (h : JoinedIn F x y) : x \u2208 F", "start": [811, 1], "end": [812, 10], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.target_mem", "code": "theorem JoinedIn.target_mem (h : JoinedIn F x y) : y \u2208 F", "start": [815, 1], "end": [816, 10], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.somePath", "code": "def JoinedIn.somePath (h : JoinedIn F x y) : Path x y :=\n  Classical.choose h", "start": [819, 1], "end": [821, 21], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.somePath_mem", "code": "theorem JoinedIn.somePath_mem (h : JoinedIn F x y) (t : I) : h.somePath t \u2208 F", "start": [824, 1], "end": [825, 28], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.joined_subtype", "code": "theorem JoinedIn.joined_subtype (h : JoinedIn F x y) :\n    Joined (\u27e8x, h.source_mem\u27e9 : F) (\u27e8y, h.target_mem\u27e9 : F)", "start": [828, 1], "end": [834, 28], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.ofLine", "code": "theorem JoinedIn.ofLine {f : \u211d \u2192 X} (hf : ContinuousOn f I) (h\u2080 : f 0 = x) (h\u2081 : f 1 = y)\n    (hF : f '' I \u2286 F) : JoinedIn F x y", "start": [837, 1], "end": [839, 68], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.joined", "code": "theorem JoinedIn.joined (h : JoinedIn F x y) : Joined x y", "start": [842, 1], "end": [843, 15], "kind": "commanddeclaration"}, {"full_name": "joinedIn_iff_joined", "code": "theorem joinedIn_iff_joined (x_in : x \u2208 F) (y_in : y \u2208 F) :\n    JoinedIn F x y \u2194 Joined (\u27e8x, x_in\u27e9 : F) (\u27e8y, y_in\u27e9 : F)", "start": [846, 1], "end": [848, 89], "kind": "commanddeclaration"}, {"full_name": "joinedIn_univ", "code": "@[simp]\ntheorem joinedIn_univ : JoinedIn univ x y \u2194 Joined x y", "start": [851, 1], "end": [853, 52], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.mono", "code": "theorem JoinedIn.mono {U V : Set X} (h : JoinedIn U x y) (hUV : U \u2286 V) : JoinedIn V x y", "start": [856, 1], "end": [857, 48], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.refl", "code": "theorem JoinedIn.refl (h : x \u2208 F) : JoinedIn F x x", "start": [860, 1], "end": [861, 29], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.symm", "code": "@[symm]\ntheorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x", "start": [864, 1], "end": [868, 15], "kind": "commanddeclaration"}, {"full_name": "JoinedIn.trans", "code": "theorem JoinedIn.trans (hxy : JoinedIn F x y) (hyz : JoinedIn F y z) : JoinedIn F x z", "start": [871, 1], "end": [875, 22], "kind": "commanddeclaration"}, {"full_name": "pathComponent", "code": "def pathComponent (x : X) :=\n  { y | Joined x y }", "start": [881, 1], "end": [883, 21], "kind": "commanddeclaration"}, {"full_name": "mem_pathComponent_self", "code": "@[simp]\ntheorem mem_pathComponent_self (x : X) : x \u2208 pathComponent x", "start": [886, 1], "end": [888, 16], "kind": "commanddeclaration"}, {"full_name": "pathComponent.nonempty", "code": "@[simp]\ntheorem pathComponent.nonempty (x : X) : (pathComponent x).Nonempty", "start": [891, 1], "end": [893, 32], "kind": "commanddeclaration"}, {"full_name": "mem_pathComponent_of_mem", "code": "theorem mem_pathComponent_of_mem (h : x \u2208 pathComponent y) : y \u2208 pathComponent x", "start": [896, 1], "end": [897, 16], "kind": "commanddeclaration"}, {"full_name": "pathComponent_symm", "code": "theorem pathComponent_symm : x \u2208 pathComponent y \u2194 y \u2208 pathComponent x", "start": [900, 1], "end": [901, 77], "kind": "commanddeclaration"}, {"full_name": "pathComponent_congr", "code": "theorem pathComponent_congr (h : x \u2208 pathComponent y) : pathComponent x = pathComponent y", "start": [904, 1], "end": [912, 21], "kind": "commanddeclaration"}, {"full_name": "pathComponent_subset_component", "code": "theorem pathComponent_subset_component (x : X) : pathComponent x \u2286 connectedComponent x", "start": [915, 1], "end": [917, 96], "kind": "commanddeclaration"}, {"full_name": "pathComponentIn", "code": "def pathComponentIn (x : X) (F : Set X) :=\n  { y | JoinedIn F x y }", "start": [920, 1], "end": [922, 25], "kind": "commanddeclaration"}, {"full_name": "pathComponentIn_univ", "code": "@[simp]\ntheorem pathComponentIn_univ (x : X) : pathComponentIn x univ = pathComponent x", "start": [925, 1], "end": [927, 84], "kind": "commanddeclaration"}, {"full_name": "Joined.mem_pathComponent", "code": "theorem Joined.mem_pathComponent (hyz : Joined y z) (hxy : y \u2208 pathComponent x) :\n    z \u2208 pathComponent x", "start": [930, 1], "end": [932, 16], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected", "code": "def IsPathConnected (F : Set X) : Prop :=\n  \u2203 x \u2208 F, \u2200 {y}, y \u2208 F \u2192 JoinedIn F x y", "start": [938, 1], "end": [940, 41], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_iff_eq", "code": "theorem isPathConnected_iff_eq : IsPathConnected F \u2194 \u2203 x \u2208 F, pathComponentIn x F = F", "start": [943, 1], "end": [948, 22], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.joinedIn", "code": "theorem IsPathConnected.joinedIn (h : IsPathConnected F) :\n    \u2200 (x) (_ : x \u2208 F) (y) (_ : y \u2208 F), JoinedIn F x y", "start": [951, 1], "end": [954, 33], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_iff", "code": "theorem isPathConnected_iff :\n    IsPathConnected F \u2194 F.Nonempty \u2227 \u2200 (x) (_ : x \u2208 F) (y) (_ : y \u2208 F), JoinedIn F x y", "start": [957, 1], "end": [961, 66], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.image'", "code": "theorem IsPathConnected.image' {Y : Type*} [TopologicalSpace Y] (hF : IsPathConnected F)\n    {f : X \u2192 Y} (hf : ContinuousOn f F) : IsPathConnected (f '' F)", "start": [964, 1], "end": [970, 60], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.image", "code": "theorem IsPathConnected.image {Y : Type*} [TopologicalSpace Y] (hF : IsPathConnected F) {f : X \u2192 Y}\n    (hf : Continuous f) : IsPathConnected (f '' F)", "start": [972, 1], "end": [973, 80], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.mem_pathComponent", "code": "theorem IsPathConnected.mem_pathComponent (h : IsPathConnected F) (x_in : x \u2208 F) (y_in : y \u2208 F) :\n    y \u2208 pathComponent x", "start": [976, 1], "end": [978, 36], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.subset_pathComponent", "code": "theorem IsPathConnected.subset_pathComponent (h : IsPathConnected F) (x_in : x \u2208 F) :\n    F \u2286 pathComponent x", "start": [981, 1], "end": [982, 72], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_singleton", "code": "theorem isPathConnected_singleton (x : X) : IsPathConnected ({x} : Set X)", "start": [985, 1], "end": [988, 26], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.union", "code": "theorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V)\n    (hUV : (U \u2229 V).Nonempty) : IsPathConnected (U \u222a V)", "start": [990, 1], "end": [996, 64], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.preimage_coe", "code": "theorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W \u2286 U) :\n    IsPathConnected (((\u2191) : U \u2192 X) \u207b\u00b9' W)", "start": [999, 1], "end": [1006, 83], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.exists_path_through_family", "code": "theorem IsPathConnected.exists_path_through_family {X : Type*} [TopologicalSpace X] {n : \u2115}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) \u2192 X) (hp : \u2200 i, p i \u2208 s) :\n    \u2203 \u03b3 : Path (p 0) (p n), range \u03b3 \u2286 s \u2227 \u2200 i, p i \u2208 range \u03b3", "start": [1009, 1], "end": [1062, 27], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.exists_path_through_family'", "code": "theorem IsPathConnected.exists_path_through_family' {X : Type*} [TopologicalSpace X] {n : \u2115}\n    {s : Set X} (h : IsPathConnected s) (p : Fin (n + 1) \u2192 X) (hp : \u2200 i, p i \u2208 s) :\n    \u2203 (\u03b3 : Path (p 0) (p n)) (t : Fin (n + 1) \u2192 I), (\u2200 t, \u03b3 t \u2208 s) \u2227 \u2200 i, \u03b3 (t i) = p i", "start": [1065, 1], "end": [1073, 23], "kind": "commanddeclaration"}, {"full_name": "PathConnectedSpace", "code": "class PathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  \n  Nonempty : Nonempty X\n  \n  Joined : \u2200 x y : X, Joined x y", "start": [1079, 1], "end": [1085, 33], "kind": "commanddeclaration"}, {"full_name": "pathConnectedSpace_iff_zerothHomotopy", "code": "theorem pathConnectedSpace_iff_zerothHomotopy :\n    PathConnectedSpace X \u2194 Nonempty (ZerothHomotopy X) \u2227 Subsingleton (ZerothHomotopy X)", "start": [1088, 1], "end": [1099, 99], "kind": "commanddeclaration"}, {"full_name": "PathConnectedSpace.somePath", "code": "def somePath (x y : X) : Path x y :=\n  Nonempty.some (Joined x y)", "start": [1106, 1], "end": [1108, 29], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_iff_pathConnectedSpace", "code": "theorem isPathConnected_iff_pathConnectedSpace : IsPathConnected F \u2194 PathConnectedSpace F", "start": [1113, 1], "end": [1124, 12], "kind": "commanddeclaration"}, {"full_name": "pathConnectedSpace_iff_univ", "code": "theorem pathConnectedSpace_iff_univ : PathConnectedSpace X \u2194 IsPathConnected (univ : Set X)", "start": [1127, 1], "end": [1138, 35], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_univ", "code": "theorem isPathConnected_univ [PathConnectedSpace X] : IsPathConnected (univ : Set X)", "start": [1141, 1], "end": [1142, 47], "kind": "commanddeclaration"}, {"full_name": "isPathConnected_range", "code": "theorem isPathConnected_range [PathConnectedSpace X] {f : X \u2192 Y} (hf : Continuous f) :\n    IsPathConnected (range f)", "start": [1144, 1], "end": [1147, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.pathConnectedSpace", "code": "theorem Function.Surjective.pathConnectedSpace [PathConnectedSpace X]\n    {f : X \u2192 Y} (hf : Surjective f) (hf' : Continuous f) : PathConnectedSpace Y", "start": [1149, 1], "end": [1152, 34], "kind": "commanddeclaration"}, {"full_name": "Quotient.instPathConnectedSpace", "code": "instance Quotient.instPathConnectedSpace {s : Setoid X} [PathConnectedSpace X] :\n    PathConnectedSpace (Quotient s) :=\n  (surjective_quotient_mk' X).pathConnectedSpace continuous_coinduced_rng", "start": [1154, 1], "end": [1156, 74], "kind": "commanddeclaration"}, {"full_name": "Real.instPathConnectedSpace", "code": "instance Real.instPathConnectedSpace : PathConnectedSpace \u211d where\n  Nonempty := inferInstance\n  Joined := fun x y \u21a6 \u27e8\u27e8\u27e8fun (t : I) \u21a6 (1 - t) * x + t * y, by continuity\u27e9, by simp, by simp\u27e9\u27e9", "start": [1158, 1], "end": [1162, 95], "kind": "commanddeclaration"}, {"full_name": "pathConnectedSpace_iff_eq", "code": "theorem pathConnectedSpace_iff_eq : PathConnectedSpace X \u2194 \u2203 x : X, pathComponent x = univ", "start": [1164, 1], "end": [1165, 61], "kind": "commanddeclaration"}, {"full_name": "PathConnectedSpace.connectedSpace", "code": "instance (priority := 100) PathConnectedSpace.connectedSpace [PathConnectedSpace X] :\n    ConnectedSpace X := by\n  rw [connectedSpace_iff_connectedComponent]\n  rcases isPathConnected_iff_eq.mp (pathConnectedSpace_iff_univ.mp \u2039_\u203a) with \u27e8x, _x_in, hx\u27e9\n  use x\n  rw [\u2190 univ_subset_iff]\n  exact (by simpa using hx : pathComponent x = univ) \u25b8 pathComponent_subset_component x", "start": [1169, 1], "end": [1175, 88], "kind": "commanddeclaration"}, {"full_name": "IsPathConnected.isConnected", "code": "theorem IsPathConnected.isConnected (hF : IsPathConnected F) : IsConnected F", "start": [1178, 1], "end": [1181, 50], "kind": "commanddeclaration"}, {"full_name": "PathConnectedSpace.exists_path_through_family", "code": "theorem exists_path_through_family {n : \u2115} (p : Fin (n + 1) \u2192 X) :\n    \u2203 \u03b3 : Path (p 0) (p n), \u2200 i, p i \u2208 range \u03b3", "start": [1188, 1], "end": [1192, 15], "kind": "commanddeclaration"}, {"full_name": "PathConnectedSpace.exists_path_through_family'", "code": "theorem exists_path_through_family' {n : \u2115} (p : Fin (n + 1) \u2192 X) :\n    \u2203 (\u03b3 : Path (p 0) (p n)) (t : Fin (n + 1) \u2192 I), \u2200 i, \u03b3 (t i) = p i", "start": [1195, 1], "end": [1199, 18], "kind": "commanddeclaration"}, {"full_name": "LocPathConnectedSpace", "code": "class LocPathConnectedSpace (X : Type*) [TopologicalSpace X] : Prop where\n  \n  path_connected_basis : \u2200 x : X, (\ud835\udcdd x).HasBasis (fun s : Set X => s \u2208 \ud835\udcdd x \u2227 IsPathConnected s) id", "start": [1207, 1], "end": [1211, 99], "kind": "commanddeclaration"}, {"full_name": "locPathConnected_of_bases", "code": "theorem locPathConnected_of_bases {p : \u03b9 \u2192 Prop} {s : X \u2192 \u03b9 \u2192 Set X}\n    (h : \u2200 x, (\ud835\udcdd x).HasBasis p (s x)) (h' : \u2200 x i, p i \u2192 IsPathConnected (s x i)) :\n    LocPathConnectedSpace X", "start": [1216, 1], "end": [1226, 10], "kind": "commanddeclaration"}, {"full_name": "pathConnectedSpace_iff_connectedSpace", "code": "theorem pathConnectedSpace_iff_connectedSpace [LocPathConnectedSpace X] :\n    PathConnectedSpace X \u2194 ConnectedSpace X", "start": [1229, 1], "end": [1248, 86], "kind": "commanddeclaration"}, {"full_name": "pathConnected_subset_basis", "code": "theorem pathConnected_subset_basis [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U)\n    (hx : x \u2208 U) : (\ud835\udcdd x).HasBasis (fun s : Set X => s \u2208 \ud835\udcdd x \u2227 IsPathConnected s \u2227 s \u2286 U) id", "start": [1251, 1], "end": [1253, 71], "kind": "commanddeclaration"}, {"full_name": "locPathConnected_of_isOpen", "code": "theorem locPathConnected_of_isOpen [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U) :\n    LocPathConnectedSpace U", "start": [1256, 1], "end": [1275, 13], "kind": "commanddeclaration"}, {"full_name": "IsOpen.isConnected_iff_isPathConnected", "code": "theorem IsOpen.isConnected_iff_isPathConnected [LocPathConnectedSpace X] {U : Set X}\n    (U_op : IsOpen U) : IsPathConnected U \u2194 IsConnected U", "start": [1278, 1], "end": [1282, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Totient.lean", "imports": ["Mathlib/Tactic/Monotonicity.lean", "Mathlib/Data/Nat/Periodic.lean", "Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CharP/Two.lean"], "premises": [{"full_name": "Nat.totient", "code": "def totient (n : \u2115) : \u2115 :=\n  ((range n).filter n.Coprime).card", "start": [30, 1], "end": [33, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_zero", "code": "@[simp]\ntheorem totient_zero : \u03c6 0 = 0", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_one", "code": "@[simp]\ntheorem totient_one : \u03c6 1 = 1", "start": [44, 1], "end": [45, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_card_coprime", "code": "theorem totient_eq_card_coprime (n : \u2115) : \u03c6 n = ((range n).filter n.Coprime).card", "start": [48, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_card_lt_and_coprime", "code": "theorem totient_eq_card_lt_and_coprime (n : \u2115) : \u03c6 n = Nat.card { m | m < n \u2227 n.Coprime m }", "start": [52, 1], "end": [59, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_le", "code": "theorem totient_le (n : \u2115) : \u03c6 n \u2264 n", "start": [62, 1], "end": [63, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_lt", "code": "theorem totient_lt (n : \u2115) (hn : 1 < n) : \u03c6 n < n", "start": [66, 1], "end": [67, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_pos", "code": "theorem totient_pos : \u2200 {n : \u2115}, 0 < n \u2192 0 < \u03c6 n", "start": [70, 1], "end": [73, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_coprime_Ico_eq_totient", "code": "theorem filter_coprime_Ico_eq_totient (a n : \u2115) :\n    ((Ico n (n + a)).filter (Coprime a)).card = totient a", "start": [76, 1], "end": [79, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_filter_coprime_le", "code": "theorem Ico_filter_coprime_le {a : \u2115} (k n : \u2115) (a_pos : 0 < a) :\n    ((Ico k (k + n)).filter (Coprime a)).card \u2264 totient a * (n / a + 1)", "start": [82, 1], "end": [107, 81], "kind": "commanddeclaration"}, {"full_name": "ZMod.card_units_eq_totient", "code": "@[simp]\ntheorem _root_.ZMod.card_units_eq_totient (n : \u2115) [NeZero n] [Fintype (ZMod n)\u02e3] :\n    Fintype.card (ZMod n)\u02e3 = \u03c6 n", "start": [112, 1], "end": [124, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_even", "code": "theorem totient_even {n : \u2115} (hn : 2 < n) : Even n.totient", "start": [127, 1], "end": [133, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_mul", "code": "theorem totient_mul {m n : \u2115} (h : m.Coprime n) : \u03c6 (m * n) = \u03c6 m * \u03c6 n", "start": [136, 1], "end": [146, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_div_of_dvd", "code": "theorem totient_div_of_dvd {n d : \u2115} (hnd : d \u2223 n) :\n    \u03c6 (n / d) = (filter (fun k : \u2115 => n.gcd k = d) (range n)).card", "start": [149, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_totient", "code": "theorem sum_totient (n : \u2115) : n.divisors.sum \u03c6 = n", "start": [170, 1], "end": [179, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_totient'", "code": "theorem sum_totient' (n : \u2115) : (\u2211 m in (range n.succ).filter (\u00b7 \u2223 n), \u03c6 m) = n", "start": [182, 1], "end": [185, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_prime_pow_succ", "code": "theorem totient_prime_pow_succ {p : \u2115} (hp : p.Prime) (n : \u2115) : \u03c6 (p ^ (n + 1)) = p ^ n * (p - 1)", "start": [188, 1], "end": [215, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_prime_pow", "code": "theorem totient_prime_pow {p : \u2115} (hp : p.Prime) {n : \u2115} (hn : 0 < n) :\n    \u03c6 (p ^ n) = p ^ (n - 1) * (p - 1)", "start": [218, 1], "end": [222, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_prime", "code": "theorem totient_prime {p : \u2115} (hp : p.Prime) : \u03c6 p = p - 1", "start": [225, 1], "end": [226, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_iff_prime", "code": "theorem totient_eq_iff_prime {p : \u2115} (hp : 0 < p) : p.totient = p - 1 \u2194 p.Prime", "start": [229, 1], "end": [241, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.card_units_zmod_lt_sub_one", "code": "theorem card_units_zmod_lt_sub_one {p : \u2115} (hp : 1 < p) [Fintype (ZMod p)\u02e3] :\n    Fintype.card (ZMod p)\u02e3 \u2264 p - 1", "start": [244, 1], "end": [248, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_iff_card_units", "code": "theorem prime_iff_card_units (p : \u2115) [Fintype (ZMod p)\u02e3] :\n    p.Prime \u2194 Fintype.card (ZMod p)\u02e3 = p - 1", "start": [251, 1], "end": [259, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_two", "code": "@[simp]\ntheorem totient_two : \u03c6 2 = 1", "start": [262, 1], "end": [264, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_one_iff", "code": "theorem totient_eq_one_iff : \u2200 {n : \u2115}, n.totient = 1 \u2194 n = 1 \u2228 n = 2", "start": [267, 1], "end": [274, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_prod_factorization", "code": "theorem totient_eq_prod_factorization {n : \u2115} (hn : n \u2260 0) :\n    \u03c6 n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1)", "start": [282, 1], "end": [289, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_mul_prod_factors", "code": "theorem totient_mul_prod_factors (n : \u2115) :\n    (\u03c6 n * \u220f p in n.factors.toFinset, p) = n * \u220f p in n.factors.toFinset, (p - 1)", "start": [292, 1], "end": [301, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_div_factors_mul", "code": "theorem totient_eq_div_factors_mul (n : \u2115) :\n    \u03c6 n = (n / \u220f p in n.factors.toFinset, p) * \u220f p in n.factors.toFinset, (p - 1)", "start": [304, 1], "end": [310, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_eq_mul_prod_factors", "code": "theorem totient_eq_mul_prod_factors (n : \u2115) :\n    (\u03c6 n : \u211a) = n * \u220f p in n.factors.toFinset, (1 - (p : \u211a)\u207b\u00b9)", "start": [313, 1], "end": [327, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_gcd_mul_totient_mul", "code": "theorem totient_gcd_mul_totient_mul (a b : \u2115) : \u03c6 (a.gcd b) * \u03c6 (a * b) = \u03c6 a * \u03c6 b * a.gcd b", "start": [330, 1], "end": [346, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_super_multiplicative", "code": "theorem totient_super_multiplicative (a b : \u2115) : \u03c6 a * \u03c6 b \u2264 \u03c6 (a * b)", "start": [349, 1], "end": [356, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_dvd_of_dvd", "code": "theorem totient_dvd_of_dvd {a b : \u2115} (h : a \u2223 b) : \u03c6 a \u2223 \u03c6 b", "start": [359, 1], "end": [370, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_mul_of_prime_of_dvd", "code": "theorem totient_mul_of_prime_of_dvd {p n : \u2115} (hp : p.Prime) (h : p \u2223 n) :\n    (p * n).totient = p * n.totient", "start": [373, 1], "end": [377, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.totient_mul_of_prime_of_not_dvd", "code": "theorem totient_mul_of_prime_of_not_dvd {p n : \u2115} (hp : p.Prime) (h : \u00acp \u2223 n) :\n    (p * n).totient = (p - 1) * n.totient", "start": [380, 1], "end": [383, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/AddAut.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddAut.mulLeft", "code": "@[simps! (config := { simpRhs := true })]\ndef mulLeft : R\u02e3 \u2192* AddAut R :=\n  DistribMulAction.toAddAut _ _", "start": [26, 1], "end": [29, 32], "kind": "commanddeclaration"}, {"full_name": "AddAut.mulRight", "code": "def mulRight (u : R\u02e3) : AddAut R :=\n  DistribMulAction.toAddAut R\u1d50\u1d52\u1d56\u02e3 R (Units.opEquiv.symm <| MulOpposite.op u)", "start": [34, 1], "end": [36, 77], "kind": "commanddeclaration"}, {"full_name": "AddAut.mulRight_apply", "code": "@[simp]\ntheorem mulRight_apply (u : R\u02e3) (x : R) : mulRight u x = x * u", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.mulRight_symm_apply", "code": "@[simp]\ntheorem mulRight_symm_apply (u : R\u02e3) (x : R) : (mulRight u).symm x = x * u\u207b\u00b9", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "imports": ["Mathlib/RingTheory/Ideal/Operations.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHom.kerLift", "code": "def kerLift (f : R \u2192+* S) : R \u29f8 ker f \u2192+* S :=\n  Ideal.Quotient.lift _ f fun _ => f.mem_ker.mp", "start": [28, 1], "end": [34, 48], "kind": "commanddeclaration"}, {"full_name": "RingHom.kerLift_mk", "code": "@[simp]\ntheorem kerLift_mk (f : R \u2192+* S) (r : R) : kerLift f (Ideal.Quotient.mk (ker f) r) = f r", "start": [37, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "RingHom.kerLift_injective", "code": "theorem kerLift_injective (f : R \u2192+* S) : Function.Injective (kerLift f)", "start": [42, 1], "end": [45, 84], "kind": "commanddeclaration"}, {"full_name": "RingHom.lift_injective_of_ker_le_ideal", "code": "theorem lift_injective_of_ker_le_ideal (I : Ideal R) {f : R \u2192+* S} (H : \u2200 a : R, a \u2208 I \u2192 f a = 0)\n    (hI : ker f \u2264 I) : Function.Injective (Ideal.Quotient.lift I f H)", "start": [48, 1], "end": [55, 40], "kind": "commanddeclaration"}, {"full_name": "RingHom.quotientKerEquivOfRightInverse", "code": "def quotientKerEquivOfRightInverse {g : S \u2192 R} (hf : Function.RightInverse g f) :\n    R \u29f8 ker f \u2243+* S :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := Ideal.Quotient.mk (ker f) \u2218 g\n    left_inv := by\n      rintro \u27e8x\u27e9\n      apply kerLift_injective\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Ideal.Quotient.mk_eq_mk, kerLift_mk,\n        Function.comp_apply, hf (f x)]\n    right_inv := hf }", "start": [60, 1], "end": [71, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.quotientKerEquivOfRightInverse.apply", "code": "@[simp]\ntheorem quotientKerEquivOfRightInverse.apply {g : S \u2192 R} (hf : Function.RightInverse g f)\n    (x : R \u29f8 ker f) : quotientKerEquivOfRightInverse hf x = kerLift f x", "start": [74, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.quotientKerEquivOfRightInverse.Symm.apply", "code": "@[simp]\ntheorem quotientKerEquivOfRightInverse.Symm.apply {g : S \u2192 R} (hf : Function.RightInverse g f)\n    (x : S) : (quotientKerEquivOfRightInverse hf).symm x = Ideal.Quotient.mk (ker f) (g x)", "start": [80, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.quotientKerEquivOfSurjective", "code": "noncomputable def quotientKerEquivOfSurjective (hf : Function.Surjective f) : R \u29f8 (ker f) \u2243+* S :=\n  quotientKerEquivOfRightInverse (Classical.choose_spec hf.hasRightInverse)", "start": [86, 1], "end": [88, 76], "kind": "commanddeclaration"}, {"full_name": "RingHom.quotientKerEquivRange", "code": "noncomputable def quotientKerEquivRange (f : R \u2192+* S) : R \u29f8 ker f \u2243+* f.range :=\n  (Ideal.quotEquivOfEq f.ker_rangeRestrict.symm).trans <|\n    quotientKerEquivOfSurjective f.rangeRestrict_surjective", "start": [91, 1], "end": [94, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_quotient_self", "code": "@[simp]\ntheorem map_quotient_self (I : Ideal R) : map (Quotient.mk I) I = \u22a5", "start": [103, 1], "end": [109, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.mk_ker", "code": "@[simp]\ntheorem mk_ker {I : Ideal R} : ker (Quotient.mk I) = I", "start": [112, 1], "end": [116, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_mk_eq_bot_of_le", "code": "theorem map_mk_eq_bot_of_le {I J : Ideal R} (h : I \u2264 J) : I.map (Quotient.mk J) = \u22a5", "start": [119, 1], "end": [121, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.ker_quotient_lift", "code": "theorem ker_quotient_lift {S : Type v} [CommRing S] {I : Ideal R} (f : R \u2192+* S)\n    (H : I \u2264 ker f) :\n    ker (Ideal.Quotient.lift I f H) = f.ker.map (Quotient.mk I)", "start": [124, 1], "end": [139, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.injective_lift_iff", "code": "lemma injective_lift_iff {I : Ideal R} {f : R \u2192+* S} (H : \u2200 (a : R), a \u2208 I \u2192 f a = 0) :\n    Injective (Quotient.lift I f H) \u2194 ker f = I := by\n  rw [injective_iff_ker_eq_bot, ker_quotient_lift, map_eq_bot_iff_le_ker, mk_ker]\n  constructor\n  \u00b7 exact fun h \u21a6 le_antisymm h H\n  \u00b7 rintro rfl; rfl", "start": [142, 1], "end": [147, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.ker_Pi_Quotient_mk", "code": "lemma ker_Pi_Quotient_mk {\u03b9 : Type*} (I : \u03b9 \u2192 Ideal R) :\n    ker (Pi.ringHom fun i : \u03b9 \u21a6 Quotient.mk (I i)) = \u2a05 i, I i := by\n  simp [Pi.ker_ringHom, mk_ker]", "start": [149, 1], "end": [151, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.bot_quotient_isMaximal_iff", "code": "@[simp]\ntheorem bot_quotient_isMaximal_iff (I : Ideal R) : (\u22a5 : Ideal (R \u29f8 I)).IsMaximal \u2194 I.IsMaximal", "start": [153, 1], "end": [161, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_quotient_iff_mem_sup", "code": "@[simp]\ntheorem mem_quotient_iff_mem_sup {I J : Ideal R} {x : R} :\n    Quotient.mk I x \u2208 J.map (Quotient.mk I) \u2194 x \u2208 J \u2294 I", "start": [164, 1], "end": [169, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_quotient_iff_mem", "code": "theorem mem_quotient_iff_mem {I J : Ideal R} (hIJ : I \u2264 J) {x : R} :\n    Quotient.mk I x \u2208 J.map (Quotient.mk I) \u2194 x \u2208 J", "start": [172, 1], "end": [175, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientInfToPiQuotient", "code": "def quotientInfToPiQuotient (I : \u03b9 \u2192 Ideal R) : (R \u29f8 \u2a05 i, I i) \u2192+* \u2200 i, R \u29f8 I i :=\n  Quotient.lift (\u2a05 i, I i) (Pi.ringHom fun i : \u03b9 \u21a6 Quotient.mk (I i))\n    (by simp [\u2190 RingHom.mem_ker, ker_Pi_Quotient_mk])", "start": [183, 1], "end": [187, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientInfToPiQuotient_mk", "code": "lemma quotientInfToPiQuotient_mk (I : \u03b9 \u2192 Ideal R) (x : R) :\n    quotientInfToPiQuotient I (Quotient.mk _ x) = fun i : \u03b9 \u21a6 Quotient.mk (I i) x :=\nrfl", "start": [189, 1], "end": [191, 4], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.quotientInfToPiQuotient_mk'", "code": "lemma quotientInfToPiQuotient_mk' (I : \u03b9 \u2192 Ideal R) (x : R) (i : \u03b9) :\n    quotientInfToPiQuotient I (Quotient.mk _ x) i = Quotient.mk (I i) x :=\nrfl", "start": [193, 1], "end": [195, 4], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.quotientInfToPiQuotient_inj", "code": "lemma quotientInfToPiQuotient_inj (I : \u03b9 \u2192 Ideal R) : Injective (quotientInfToPiQuotient I) := by\n  rw [quotientInfToPiQuotient, injective_lift_iff, ker_Pi_Quotient_mk]", "start": [197, 1], "end": [198, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.quotientInfToPiQuotient_surj", "code": "lemma quotientInfToPiQuotient_surj [Fintype \u03b9] {I : \u03b9 \u2192 Ideal R}\n    (hI : \u2200 i j, i \u2260 j \u2192 IsCoprime (I i) (I j)) : Surjective (quotientInfToPiQuotient I) := by\n  classical\n  intro g\n  choose f hf using fun i \u21a6 mk_surjective (g i)\n  have key : \u2200 i, \u2203 e : R, mk (I i) e = 1 \u2227 \u2200 j, j \u2260 i \u2192 mk (I j) e = 0 := by\n    intro i\n    have hI' : \u2200 j \u2208 ({i} : Finset \u03b9)\u1d9c, IsCoprime (I i) (I j) := by\n      intros j hj\n      exact hI _ _ (by simpa [ne_comm, isCoprime_iff_add] using hj)\n    rcases isCoprime_iff_exists.mp (isCoprime_biInf hI') with \u27e8u, hu, e, he, hue\u27e9\n    replace he : \u2200 j, j \u2260 i \u2192 e \u2208 I j := by simpa using he\n    refine \u27e8e, ?_, ?_\u27e9\n    \u00b7 simp [eq_sub_of_add_eq' hue, map_sub, eq_zero_iff_mem.mpr hu]\n      rfl\n    \u00b7 exact fun j hj \u21a6 eq_zero_iff_mem.mpr (he j hj)\n  choose e he using key\n  use mk _ (\u2211 i, f i*e i)\n  ext i\n  rw [quotientInfToPiQuotient_mk', map_sum, Fintype.sum_eq_single i]\n  \u00b7 simp [(he i).1, hf]\n  \u00b7 intros j hj\n    simp [(he j).2 i hj.symm]", "start": [200, 1], "end": [222, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.quotientInfRingEquivPiQuotient", "code": "noncomputable def quotientInfRingEquivPiQuotient [Fintype \u03b9] (f : \u03b9 \u2192 Ideal R)\n    (hf : \u2200 i j, i \u2260 j \u2192 IsCoprime (f i) (f j)) : (R \u29f8 \u2a05 i, f i) \u2243+* \u2200 i, R \u29f8 f i :=\n  { Equiv.ofBijective _ \u27e8quotientInfToPiQuotient_inj f, quotientInfToPiQuotient_surj hf\u27e9,\n    quotientInfToPiQuotient f with }", "start": [224, 1], "end": [228, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientInfEquivQuotientProd", "code": "noncomputable def quotientInfEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    R \u29f8 I \u2293 J \u2243+* (R \u29f8 I) \u00d7 R \u29f8 J :=\n  let f : Fin 2 \u2192 Ideal R := ![I, J]\n  have hf : \u2200 i j : Fin 2, i \u2260 j \u2192 IsCoprime (f i) (f j) := by\n    intro i j h\n    fin_cases i <;> fin_cases j <;> try contradiction\n    \u00b7 assumption\n    \u00b7 exact coprime.symm\n  (Ideal.quotEquivOfEq (by simp [iInf, inf_comm])).trans <|\n            (Ideal.quotientInfRingEquivPiQuotient f hf).trans <| RingEquiv.piFinTwo fun i => R \u29f8 f i", "start": [231, 1], "end": [241, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientInfEquivQuotientProd_fst", "code": "@[simp]\ntheorem quotientInfEquivQuotientProd_fst (I J : Ideal R) (coprime : IsCoprime I J) (x : R \u29f8 I \u2293 J) :\n    (quotientInfEquivQuotientProd I J coprime x).fst =\n      Ideal.Quotient.factor (I \u2293 J) I inf_le_left x", "start": [244, 1], "end": [248, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientInfEquivQuotientProd_snd", "code": "@[simp]\ntheorem quotientInfEquivQuotientProd_snd (I J : Ideal R) (coprime : IsCoprime I J) (x : R \u29f8 I \u2293 J) :\n    (quotientInfEquivQuotientProd I J coprime x).snd =\n      Ideal.Quotient.factor (I \u2293 J) J inf_le_right x", "start": [251, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.fst_comp_quotientInfEquivQuotientProd", "code": "@[simp]\ntheorem fst_comp_quotientInfEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.fst _ _).comp\n        (quotientInfEquivQuotientProd I J coprime : R \u29f8 I \u2293 J \u2192+* (R \u29f8 I) \u00d7 R \u29f8 J) =\n      Ideal.Quotient.factor (I \u2293 J) I inf_le_left", "start": [258, 1], "end": [263, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.snd_comp_quotientInfEquivQuotientProd", "code": "@[simp]\ntheorem snd_comp_quotientInfEquivQuotientProd (I J : Ideal R) (coprime : IsCoprime I J) :\n    (RingHom.snd _ _).comp\n        (quotientInfEquivQuotientProd I J coprime : R \u29f8 I \u2293 J \u2192+* (R \u29f8 I) \u00d7 R \u29f8 J) =\n      Ideal.Quotient.factor (I \u2293 J) J inf_le_right", "start": [266, 1], "end": [271, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebra", "code": "instance Quotient.algebra {I : Ideal A} : Algebra R\u2081 (A \u29f8 I) :=\n  { toRingHom :=  (Ideal.Quotient.mk I).comp (algebraMap R\u2081 A)\n    smul_def' := fun _ x =>\n      Quotient.inductionOn' x fun _ =>\n        ((Quotient.mk I).congr_arg <| Algebra.smul_def _ _).trans (RingHom.map_mul _ _ _)\n    commutes' := fun _ _ => mul_comm _ _ }", "start": [283, 1], "end": [289, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.isScalarTower", "code": "instance Quotient.isScalarTower [SMul R\u2081 R\u2082] [IsScalarTower R\u2081 R\u2082 A] (I : Ideal A) :\n    IsScalarTower R\u2081 R\u2082 (A \u29f8 I) := by infer_instance", "start": [295, 1], "end": [296, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk\u2090", "code": "def Quotient.mk\u2090 (I : Ideal A) : A \u2192\u2090[R\u2081] A \u29f8 I :=\n  \u27e8\u27e8\u27e8\u27e8fun a => Submodule.Quotient.mk a, rfl\u27e9, fun _ _ => rfl\u27e9, rfl, fun _ _ => rfl\u27e9, fun _ => rfl\u27e9", "start": [299, 1], "end": [302, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algHom_ext", "code": "theorem Quotient.algHom_ext {I : Ideal A} {S} [Semiring S] [Algebra R\u2081 S] \u2983f g : A \u29f8 I \u2192\u2090[R\u2081] S\u2984\n    (h : f.comp (Quotient.mk\u2090 R\u2081 I) = g.comp (Quotient.mk\u2090 R\u2081 I)) : f = g", "start": [305, 1], "end": [307, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.alg_map_eq", "code": "theorem Quotient.alg_map_eq (I : Ideal A) :\n    algebraMap R\u2081 (A \u29f8 I) = (algebraMap A (A \u29f8 I)).comp (algebraMap R\u2081 A)", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk\u2090_toRingHom", "code": "theorem Quotient.mk\u2090_toRingHom (I : Ideal A) :\n    (Quotient.mk\u2090 R\u2081 I).toRingHom = Ideal.Quotient.mk I", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk\u2090_eq_mk", "code": "@[simp]\ntheorem Quotient.mk\u2090_eq_mk (I : Ideal A) : \u21d1(Quotient.mk\u2090 R\u2081 I) = Quotient.mk I", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.algebraMap_eq", "code": "@[simp]\ntheorem Quotient.algebraMap_eq (I : Ideal R) : algebraMap R (R \u29f8 I) = Quotient.mk I", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk_comp_algebraMap", "code": "@[simp]\ntheorem Quotient.mk_comp_algebraMap (I : Ideal A) :\n    (Quotient.mk I).comp (algebraMap R\u2081 A) = algebraMap R\u2081 (A \u29f8 I)", "start": [330, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk_algebraMap", "code": "@[simp]\ntheorem Quotient.mk_algebraMap (I : Ideal A) (x : R\u2081) :\n    Quotient.mk I (algebraMap R\u2081 A x) = algebraMap R\u2081 (A \u29f8 I) x", "start": [336, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk\u2090_surjective", "code": "theorem Quotient.mk\u2090_surjective (I : Ideal A) : Function.Surjective (Quotient.mk\u2090 R\u2081 I)", "start": [342, 1], "end": [344, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk\u2090_ker", "code": "@[simp]\ntheorem Quotient.mk\u2090_ker (I : Ideal A) : RingHom.ker (Quotient.mk\u2090 R\u2081 I : A \u2192+* A \u29f8 I) = I", "start": [347, 1], "end": [350, 15], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift\u2090", "code": "def Quotient.lift\u2090 (I : Ideal A) (f : A \u2192\u2090[R\u2081] B) (hI : \u2200 a : A, a \u2208 I \u2192 f a = 0) :\n    A \u29f8 I \u2192\u2090[R\u2081] B :=\n  {Ideal.Quotient.lift\n      I (f : A \u2192+* B) hI with\n    commutes' := fun r => by\n      have : algebraMap R\u2081 (A \u29f8 I) r = algebraMap A (A \u29f8 I) (algebraMap R\u2081 A r) := by\n        simp_rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n      rw [this, Ideal.Quotient.algebraMap_eq, RingHom.toFun_eq_coe, Ideal.Quotient.lift_mk,\n        AlgHom.coe_toRingHom, Algebra.algebraMap_eq_smul_one, Algebra.algebraMap_eq_smul_one,\n        map_smul, map_one] }", "start": [355, 1], "end": [367, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift\u2090_apply", "code": "@[simp]\ntheorem Quotient.lift\u2090_apply (I : Ideal A) (f : A \u2192\u2090[R\u2081] B) (hI : \u2200 a : A, a \u2208 I \u2192 f a = 0) (x) :\n    Ideal.Quotient.lift\u2090 I f hI x = Ideal.Quotient.lift I (f : A \u2192+* B) hI x", "start": [370, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift\u2090_comp", "code": "theorem Quotient.lift\u2090_comp (I : Ideal A) (f : A \u2192\u2090[R\u2081] B) (hI : \u2200 a : A, a \u2208 I \u2192 f a = 0) :\n    (Ideal.Quotient.lift\u2090 I f hI).comp (Ideal.Quotient.mk\u2090 R\u2081 I) = f", "start": [376, 1], "end": [378, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.KerLift.map_smul", "code": "theorem KerLift.map_smul (f : A \u2192\u2090[R\u2081] B) (r : R\u2081) (x : A \u29f8 (RingHom.ker f.toRingHom)) :\n    f.toRingHom.kerLift (r \u2022 x) = r \u2022 f.toRingHom.kerLift x", "start": [381, 1], "end": [384, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.kerLiftAlg", "code": "def kerLiftAlg (f : A \u2192\u2090[R\u2081] B) : A \u29f8 (RingHom.ker f.toRingHom) \u2192\u2090[R\u2081] B :=\n  AlgHom.mk' f.toRingHom.kerLift fun _ _ => KerLift.map_smul f _ _", "start": [387, 1], "end": [393, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.kerLiftAlg_mk", "code": "@[simp, nolint simpNF]\ntheorem kerLiftAlg_mk (f : A \u2192\u2090[R\u2081] B) (a : A) :\n    kerLiftAlg f (Quotient.mk (RingHom.ker f) a) = f a", "start": [398, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.kerLiftAlg_toRingHom", "code": "@[simp, nolint simpNF]\ntheorem kerLiftAlg_toRingHom (f : A \u2192\u2090[R\u2081] B) :\n    (kerLiftAlg f).toRingHom = RingHom.kerLift (f : A \u2192+* B)", "start": [412, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.kerLiftAlg_injective", "code": "theorem kerLiftAlg_injective (f : A \u2192\u2090[R\u2081] B) : Function.Injective (kerLiftAlg f)", "start": [419, 1], "end": [421, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientKerAlgEquivOfRightInverse", "code": "def quotientKerAlgEquivOfRightInverse {f : A \u2192\u2090[R\u2081] B} {g : B \u2192 A}\n    (hf : Function.RightInverse g f) : (A \u29f8 (RingHom.ker f.toRingHom)) \u2243\u2090[R\u2081] B :=\n  { RingHom.quotientKerEquivOfRightInverse fun x => show f.toRingHom (g x) = x from hf x,\n    kerLiftAlg f with }", "start": [424, 1], "end": [428, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientKerAlgEquivOfRightInverse.apply", "code": "@[simp, nolint simpNF]\ntheorem quotientKerAlgEquivOfRightInverse.apply {f : A \u2192\u2090[R\u2081] B} {g : B \u2192 A}\n    (hf : Function.RightInverse g f) (x : A \u29f8 (RingHom.ker f.toRingHom)) :\n    quotientKerAlgEquivOfRightInverse hf x = kerLiftAlg f x", "start": [432, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.QuotientKerAlgEquivOfRightInverseSymm.apply", "code": "@[simp, nolint simpNF]\ntheorem QuotientKerAlgEquivOfRightInverseSymm.apply {f : A \u2192\u2090[R\u2081] B} {g : B \u2192 A}\n    (hf : Function.RightInverse g f) (x : B) : (quotientKerAlgEquivOfRightInverse hf).symm x =\n    Quotient.mk\u2090 R\u2081 (RingHom.ker f.toRingHom) (g x)", "start": [440, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientKerAlgEquivOfSurjective", "code": "noncomputable def quotientKerAlgEquivOfSurjective {f : A \u2192\u2090[R\u2081] B} (hf : Function.Surjective f) :\n    (A \u29f8 (RingHom.ker f.toRingHom)) \u2243\u2090[R\u2081] B :=\n  quotientKerAlgEquivOfRightInverse (Classical.choose_spec hf.hasRightInverse)", "start": [447, 1], "end": [450, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap", "code": "def quotientMap {I : Ideal R} (J : Ideal S) (f : R \u2192+* S) (hIJ : I \u2264 J.comap f) : R \u29f8 I \u2192+* S \u29f8 J :=\n  Quotient.lift I ((Quotient.mk J).comp f) fun _ ha => by\n    simpa [Function.comp_apply, RingHom.coe_comp, Quotient.eq_zero_iff_mem] using hIJ ha", "start": [453, 1], "end": [456, 89], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_mk", "code": "@[simp]\ntheorem quotientMap_mk {J : Ideal R} {I : Ideal S} {f : R \u2192+* S} {H : J \u2264 I.comap f} {x : R} :\n    quotientMap I f H (Quotient.mk J x) = Quotient.mk I (f x)", "start": [459, 1], "end": [462, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_algebraMap", "code": "@[simp]\ntheorem quotientMap_algebraMap {J : Ideal A} {I : Ideal S} {f : A \u2192+* S} {H : J \u2264 I.comap f}\n    {x : R\u2081} : quotientMap I f H (algebraMap R\u2081 (A \u29f8 J) x) = Quotient.mk I (f (algebraMap _ _ x))", "start": [465, 1], "end": [468, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_comp_mk", "code": "theorem quotientMap_comp_mk {J : Ideal R} {I : Ideal S} {f : R \u2192+* S} (H : J \u2264 I.comap f) :\n    (quotientMap I f H).comp (Quotient.mk J) = (Quotient.mk I).comp f", "start": [471, 1], "end": [473, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquiv", "code": "@[simps]\ndef quotientEquiv (I : Ideal R) (J : Ideal S) (f : R \u2243+* S) (hIJ : J = I.map (f : R \u2192+* S)) :\n    R \u29f8 I \u2243+* S \u29f8 J :=\n  {\n    quotientMap J (\u2191f)\n      (by\n        rw [hIJ]\n        exact\n          @le_comap_map _ S _ _ _ _ _\n            _) with\n    invFun :=\n      quotientMap I (\u2191f.symm)\n        (by\n          rw [hIJ]\n          exact le_of_eq (map_comap_of_equiv I f))\n    left_inv := by\n      rintro \u27e8r\u27e9\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.symm_apply_apply]\n    right_inv := by\n      rintro \u27e8s\u27e9\n      simp only [Submodule.Quotient.quot_mk_eq_mk, Quotient.mk_eq_mk, RingHom.toFun_eq_coe,\n        quotientMap_mk, RingEquiv.coe_toRingHom, RingEquiv.apply_symm_apply] }", "start": [476, 1], "end": [499, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquiv_mk", "code": "theorem quotientEquiv_mk (I : Ideal R) (J : Ideal S) (f : R \u2243+* S) (hIJ : J = I.map (f : R \u2192+* S))\n    (x : R) : quotientEquiv I J f hIJ (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J (f x)", "start": [504, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquiv_symm_mk", "code": "@[simp]\ntheorem quotientEquiv_symm_mk (I : Ideal R) (J : Ideal S) (f : R \u2243+* S)\n    (hIJ : J = I.map (f : R \u2192+* S)) (x : S) :\n    (quotientEquiv I J f hIJ).symm (Ideal.Quotient.mk J x) = Ideal.Quotient.mk I (f.symm x)", "start": [509, 1], "end": [513, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_injective'", "code": "theorem quotientMap_injective' {J : Ideal R} {I : Ideal S} {f : R \u2192+* S} {H : J \u2264 I.comap f}\n    (h : I.comap f \u2264 J) : Function.Injective (quotientMap I f H)", "start": [516, 1], "end": [522, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_injective", "code": "theorem quotientMap_injective {I : Ideal S} {f : R \u2192+* S} :\n    Function.Injective (quotientMap I f le_rfl)", "start": [525, 1], "end": [528, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap_surjective", "code": "theorem quotientMap_surjective {J : Ideal R} {I : Ideal S} {f : R \u2192+* S} {H : J \u2264 I.comap f}\n    (hf : Function.Surjective f) : Function.Surjective (quotientMap I f H)", "start": [531, 1], "end": [535, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.comp_quotientMap_eq_of_comp_eq", "code": "theorem comp_quotientMap_eq_of_comp_eq {R' S' : Type*} [CommRing R'] [CommRing S'] {f : R \u2192+* S}\n    {f' : R' \u2192+* S'} {g : R \u2192+* R'} {g' : S \u2192+* S'} (hfg : f'.comp g = g'.comp f) (I : Ideal S') :\n    let leq := le_of_eq (_root_.trans (comap_comap (I := I) f g') (hfg \u25b8 comap_comap (I := I) g f'))\n    (quotientMap I g' le_rfl).comp (quotientMap (I.comap g') f le_rfl) =\n    (quotientMap I f' le_rfl).comp (quotientMap (I.comap f') g leq)", "start": [538, 1], "end": [549, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientMap\u2090", "code": "def quotientMap\u2090 {I : Ideal A} (J : Ideal B) (f : A \u2192\u2090[R\u2081] B) (hIJ : I \u2264 J.comap f) :\n    A \u29f8 I \u2192\u2090[R\u2081] B \u29f8 J :=\n  { quotientMap J (f : A \u2192+* B) hIJ with commutes' := fun r => by simp only [RingHom.toFun_eq_coe,\n    quotientMap_algebraMap, AlgHom.coe_toRingHom, AlgHom.commutes, Quotient.mk_algebraMap] }", "start": [552, 1], "end": [556, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotient_map_mk\u2090", "code": "@[simp]\ntheorem quotient_map_mk\u2090 {I : Ideal A} (J : Ideal B) (f : A \u2192\u2090[R\u2081] B) (H : I \u2264 J.comap f) {x : A} :\n    quotientMap\u2090 J f H (Quotient.mk I x) = Quotient.mk\u2090 R\u2081 J (f x)", "start": [559, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotient_map_comp_mk\u2090", "code": "theorem quotient_map_comp_mk\u2090 {I : Ideal A} (J : Ideal B) (f : A \u2192\u2090[R\u2081] B) (H : I \u2264 J.comap f) :\n    (quotientMap\u2090 J f H).comp (Quotient.mk\u2090 R\u2081 I) = (Quotient.mk\u2090 R\u2081 J).comp f", "start": [565, 1], "end": [567, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivAlg", "code": "def quotientEquivAlg (I : Ideal A) (J : Ideal B) (f : A \u2243\u2090[R\u2081] B) (hIJ : J = I.map (f : A \u2192+* B)) :\n    (A \u29f8 I) \u2243\u2090[R\u2081] B \u29f8 J :=\n  { quotientEquiv I J (f : A \u2243+* B) hIJ with\n    commutes' := fun r => by\n      have : \u2200 (e : RingEquiv (A \u29f8 I) (B \u29f8 J)), Equiv.toFun e.toEquiv = FunLike.coe e := fun _ \u21a6 rfl\n      rw [this]\n      simp only [quotientEquiv_apply, RingHom.toFun_eq_coe, quotientMap_algebraMap,\n      RingEquiv.coe_toRingHom, AlgEquiv.coe_ringEquiv, AlgEquiv.commutes, Quotient.mk_algebraMap]}", "start": [570, 1], "end": [580, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientAlgebra", "code": "instance (priority := 100) quotientAlgebra {I : Ideal A} [Algebra R A] :\n    Algebra (R \u29f8 I.comap (algebraMap R A)) (A \u29f8 I) :=\n  (quotientMap I (algebraMap R A) (le_of_eq rfl)).toAlgebra", "start": [583, 1], "end": [585, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.algebraMap_quotient_injective", "code": "theorem algebraMap_quotient_injective {I : Ideal A} [Algebra R A] :\n    Function.Injective (algebraMap (R \u29f8 I.comap (algebraMap R A)) (A \u29f8 I))", "start": [588, 1], "end": [593, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivAlgOfEq", "code": "def quotientEquivAlgOfEq {I J : Ideal A} (h : I = J) : (A \u29f8 I) \u2243\u2090[R\u2081] A \u29f8 J :=\n  quotientEquivAlg I J AlgEquiv.refl <| h \u25b8 (map_id I).symm", "start": [598, 1], "end": [600, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivAlgOfEq_mk", "code": "@[simp]\ntheorem quotientEquivAlgOfEq_mk {I J : Ideal A} (h : I = J) (x : A) :\n    quotientEquivAlgOfEq R\u2081 h (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J x", "start": [603, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivAlgOfEq_symm", "code": "@[simp]\ntheorem quotientEquivAlgOfEq_symm {I J : Ideal A} (h : I = J) :\n    (quotientEquivAlgOfEq R\u2081 h).symm = quotientEquivAlgOfEq R\u2081 h.symm", "start": [609, 1], "end": [613, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_map_mk", "code": "lemma comap_map_mk {I J : Ideal R} (h : I \u2264 J) :\n    Ideal.comap (Ideal.Quotient.mk I) (Ideal.map (Ideal.Quotient.mk I) J) = J :=\n  by ext; rw [\u2190 Ideal.mem_quotient_iff_mem h, Ideal.mem_comap]", "start": [616, 1], "end": [618, 63], "kind": "mathlibtacticlemma"}, {"full_name": "DoubleQuot.quotLeftToQuotSup", "code": "def quotLeftToQuotSup : R \u29f8 I \u2192+* R \u29f8 I \u2294 J :=\n  Ideal.Quotient.factor I (I \u2294 J) le_sup_left", "start": [634, 1], "end": [636, 46], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.ker_quotLeftToQuotSup", "code": "theorem ker_quotLeftToQuotSup : RingHom.ker (quotLeftToQuotSup I J) =\n    J.map (Ideal.Quotient.mk I)", "start": [639, 1], "end": [643, 99], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotToQuotSup", "code": "def quotQuotToQuotSup : (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) \u2192+* R \u29f8 I \u2294 J :=\n  Ideal.Quotient.lift (J.map (Ideal.Quotient.mk I)) (quotLeftToQuotSup I J)\n    (ker_quotLeftToQuotSup I J).symm.le", "start": [646, 1], "end": [650, 40], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotMk", "code": "def quotQuotMk : R \u2192+* (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) :=\n  (Ideal.Quotient.mk (J.map (Ideal.Quotient.mk I))).comp (Ideal.Quotient.mk I)", "start": [653, 1], "end": [655, 79], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.ker_quotQuotMk", "code": "theorem ker_quotQuotMk : RingHom.ker (quotQuotMk I J) = I \u2294 J", "start": [659, 1], "end": [663, 14], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.liftSupQuotQuotMk", "code": "def liftSupQuotQuotMk (I J : Ideal R) : R \u29f8 I \u2294 J \u2192+* (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) :=\n  Ideal.Quotient.lift (I \u2294 J) (quotQuotMk I J) (ker_quotQuotMk I J).symm.le", "start": [666, 1], "end": [668, 76], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup", "code": "def quotQuotEquivQuotSup : (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) \u2243+* R \u29f8 I \u2294 J :=\n  RingEquiv.ofHomInv (quotQuotToQuotSup I J) (liftSupQuotQuotMk I J)\n    (by\n      repeat apply Ideal.Quotient.ringHom_ext\n      rfl)\n    (by\n      repeat apply Ideal.Quotient.ringHom_ext\n      rfl)", "start": [671, 1], "end": [680, 11], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup_quotQuotMk", "code": "@[simp]\ntheorem quotQuotEquivQuotSup_quotQuotMk (x : R) :\n    quotQuotEquivQuotSup I J (quotQuotMk I J x) = Ideal.Quotient.mk (I \u2294 J) x", "start": [683, 1], "end": [686, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup_symm_quotQuotMk", "code": "@[simp]\ntheorem quotQuotEquivQuotSup_symm_quotQuotMk (x : R) :\n    (quotQuotEquivQuotSup I J).symm (Ideal.Quotient.mk (I \u2294 J) x) = quotQuotMk I J x", "start": [689, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm", "code": "def quotQuotEquivComm : (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) \u2243+*\n    (R \u29f8 J) \u29f8 I.map (Ideal.Quotient.mk J) :=\n  ((quotQuotEquivQuotSup I J).trans (quotEquivOfEq (sup_comm))).trans\n    (quotQuotEquivQuotSup J I).symm", "start": [695, 1], "end": [699, 36], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_quotQuotMk", "code": "@[simp]\ntheorem quotQuotEquivComm_quotQuotMk (x : R) :\n    quotQuotEquivComm I J (quotQuotMk I J x) = quotQuotMk J I x", "start": [703, 1], "end": [706, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_comp_quotQuotMk", "code": "@[simp]\ntheorem quotQuotEquivComm_comp_quotQuotMk :\n    RingHom.comp (\u2191(quotQuotEquivComm I J)) (quotQuotMk I J) = quotQuotMk J I", "start": [710, 1], "end": [713, 50], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_symm", "code": "@[simp]\ntheorem quotQuotEquivComm_symm : (quotQuotEquivComm I J).symm = quotQuotEquivComm J I", "start": [716, 1], "end": [727, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE", "code": "def quotQuotEquivQuotOfLE (h : I \u2264 J) : (R \u29f8 I) \u29f8 J.map (Ideal.Quotient.mk I) \u2243+* R \u29f8 J :=\n  (quotQuotEquivQuotSup I J).trans (Ideal.quotEquivOfEq <| sup_eq_right.mpr h)", "start": [732, 1], "end": [735, 79], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_quotQuotMk", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE_quotQuotMk (x : R) (h : I \u2264 J) :\n    quotQuotEquivQuotOfLE h (quotQuotMk I J x) = (Ideal.Quotient.mk J) x", "start": [738, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_symm_mk", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE_symm_mk (x : R) (h : I \u2264 J) :\n    (quotQuotEquivQuotOfLE h).symm ((Ideal.Quotient.mk J) x) = quotQuotMk I J x", "start": [744, 1], "end": [747, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_comp_quotQuotMk", "code": "theorem quotQuotEquivQuotOfLE_comp_quotQuotMk (h : I \u2264 J) :\n    RingHom.comp (\u2191(quotQuotEquivQuotOfLE h)) (quotQuotMk I J) = (Ideal.Quotient.mk J)", "start": [750, 1], "end": [753, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_symm_comp_mk", "code": "theorem quotQuotEquivQuotOfLE_symm_comp_mk (h : I \u2264 J) :\n    RingHom.comp (\u2191(quotQuotEquivQuotOfLE h).symm) (Ideal.Quotient.mk J) = quotQuotMk I J", "start": [756, 1], "end": [759, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_mk_mk", "code": "@[simp]\ntheorem quotQuotEquivComm_mk_mk [CommRing R] (I J : Ideal R) (x : R) :\n    quotQuotEquivComm I J (Ideal.Quotient.mk _ (Ideal.Quotient.mk _ x)) = algebraMap R _ x", "start": [766, 1], "end": [769, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup_quot_quot_algebraMap", "code": "@[simp]\ntheorem quotQuotEquivQuotSup_quot_quot_algebraMap (x : R) :\n    DoubleQuot.quotQuotEquivQuotSup I J (algebraMap R _ x) = algebraMap _ _ x", "start": [774, 1], "end": [777, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_algebraMap", "code": "@[simp]\ntheorem quotQuotEquivComm_algebraMap (x : R) :\n    quotQuotEquivComm I J (algebraMap R _ x) = algebraMap _ _ x", "start": [780, 1], "end": [783, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotLeftToQuotSup\u2090", "code": "def quotLeftToQuotSup\u2090 : A \u29f8 I \u2192\u2090[R] A \u29f8 I \u2294 J :=\n  AlgHom.mk (quotLeftToQuotSup I J) fun _ => rfl", "start": [792, 1], "end": [794, 49], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotLeftToQuotSup\u2090_toRingHom", "code": "@[simp]\ntheorem quotLeftToQuotSup\u2090_toRingHom :\n    (quotLeftToQuotSup\u2090 R I J : _ \u2192+* _) = quotLeftToQuotSup I J", "start": [797, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotLeftToQuotSup\u2090", "code": "@[simp]\ntheorem coe_quotLeftToQuotSup\u2090 : \u21d1(quotLeftToQuotSup\u2090 R I J) = quotLeftToQuotSup I J", "start": [803, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotToQuotSup\u2090", "code": "def quotQuotToQuotSup\u2090 : (A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I) \u2192\u2090[R] A \u29f8 I \u2294 J :=\n  AlgHom.mk (quotQuotToQuotSup I J) fun _ => rfl", "start": [808, 1], "end": [811, 49], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotToQuotSup\u2090_toRingHom", "code": "@[simp]\ntheorem quotQuotToQuotSup\u2090_toRingHom :\n    ((quotQuotToQuotSup\u2090 R I J) : _ \u29f8 map (Ideal.Quotient.mk\u2090 R I) J \u2192+* _) =\n      quotQuotToQuotSup I J", "start": [814, 1], "end": [818, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotToQuotSup\u2090", "code": "@[simp]\ntheorem coe_quotQuotToQuotSup\u2090 : \u21d1(quotQuotToQuotSup\u2090 R I J) = quotQuotToQuotSup I J", "start": [821, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotMk\u2090", "code": "def quotQuotMk\u2090 : A \u2192\u2090[R] (A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I) :=\n  AlgHom.mk (quotQuotMk I J) fun _ => rfl", "start": [826, 1], "end": [829, 42], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotMk\u2090_toRingHom", "code": "@[simp]\ntheorem quotQuotMk\u2090_toRingHom :\n    (quotQuotMk\u2090 R I J : _ \u2192+* _ \u29f8 J.map (Quotient.mk\u2090 R I)) = quotQuotMk I J", "start": [832, 1], "end": [835, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotMk\u2090", "code": "@[simp]\ntheorem coe_quotQuotMk\u2090 : \u21d1(quotQuotMk\u2090 R I J) = quotQuotMk I J", "start": [838, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.liftSupQuotQuotMk\u2090", "code": "def liftSupQuotQuotMk\u2090 (I J : Ideal A) : A \u29f8 I \u2294 J \u2192\u2090[R] (A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I) :=\n  AlgHom.mk (liftSupQuotQuotMk I J) fun _ => rfl", "start": [843, 1], "end": [846, 49], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.liftSupQuotQuotMk\u2090_toRingHom", "code": "@[simp]\ntheorem liftSupQuotQuotMk\u2090_toRingHom :\n    (liftSupQuotQuotMk\u2090 R I J : _ \u2192+* _ \u29f8 J.map (Quotient.mk\u2090 R I)) = liftSupQuotQuotMk I J", "start": [849, 1], "end": [852, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_liftSupQuotQuotMk\u2090", "code": "@[simp]\ntheorem coe_liftSupQuotQuotMk\u2090 : \u21d1(liftSupQuotQuotMk\u2090 R I J) = liftSupQuotQuotMk I J", "start": [855, 1], "end": [857, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup\u2090", "code": "def quotQuotEquivQuotSup\u2090 : ((A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I)) \u2243\u2090[R] A \u29f8 I \u2294 J :=\n  @AlgEquiv.ofRingEquiv R _ _ _ _ _ _ _ (quotQuotEquivQuotSup I J) fun _ => rfl", "start": [860, 1], "end": [863, 80], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup\u2090_toRingEquiv", "code": "@[simp]\ntheorem quotQuotEquivQuotSup\u2090_toRingEquiv :\n    (quotQuotEquivQuotSup\u2090 R I J : _ \u29f8 J.map (Quotient.mk\u2090 R I) \u2243+* _) = quotQuotEquivQuotSup I J", "start": [866, 1], "end": [869, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotEquivQuotSup\u2090", "code": "@[simp]\ntheorem coe_quotQuotEquivQuotSup\u2090 : \u21d1(quotQuotEquivQuotSup\u2090 R I J) = \u21d1(quotQuotEquivQuotSup I J)", "start": [872, 1], "end": [875, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotSup\u2090_symm_toRingEquiv", "code": "@[simp]\ntheorem quotQuotEquivQuotSup\u2090_symm_toRingEquiv :\n    ((quotQuotEquivQuotSup\u2090 R I J).symm : _ \u2243+* _ \u29f8 J.map (Quotient.mk\u2090 R I)) =\n      (quotQuotEquivQuotSup I J).symm", "start": [878, 1], "end": [882, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotEquivQuotSup\u2090_symm", "code": "@[simp]\ntheorem coe_quotQuotEquivQuotSup\u2090_symm :\n    \u21d1(quotQuotEquivQuotSup\u2090 R I J).symm = \u21d1(quotQuotEquivQuotSup I J).symm", "start": [885, 1], "end": [889, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm\u2090", "code": "def quotQuotEquivComm\u2090 :\n    ((A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I)) \u2243\u2090[R] (A \u29f8 J) \u29f8 I.map (Quotient.mk\u2090 R J) :=\n  @AlgEquiv.ofRingEquiv R _ _ _ _ _ _ _ (quotQuotEquivComm I J) fun _ => rfl", "start": [892, 1], "end": [896, 77], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm\u2090_toRingEquiv", "code": "@[simp]\ntheorem quotQuotEquivComm\u2090_toRingEquiv :\n    (quotQuotEquivComm\u2090 R I J : _ \u29f8 J.map (Quotient.mk\u2090 R I) \u2243+* _ \u29f8 I.map (Quotient.mk\u2090 R J)) =\n      quotQuotEquivComm I J", "start": [899, 1], "end": [906, 29], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotEquivComm\u2090", "code": "@[simp]\ntheorem coe_quotQuotEquivComm\u2090 : \u21d1(quotQuotEquivComm\u2090 R I J) = \u21d1(quotQuotEquivComm I J)", "start": [909, 1], "end": [911, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_symm\u2090", "code": "@[simp]\ntheorem quotQuotEquivComm_symm\u2090 : (quotQuotEquivComm\u2090 R I J).symm = quotQuotEquivComm\u2090 R J I", "start": [914, 1], "end": [921, 8], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivComm_comp_quotQuotMk\u2090", "code": "@[simp]\ntheorem quotQuotEquivComm_comp_quotQuotMk\u2090 :\n    AlgHom.comp (\u2191(quotQuotEquivComm\u2090 R I J)) (quotQuotMk\u2090 R I J) = quotQuotMk\u2090 R J I", "start": [924, 1], "end": [927, 49], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE\u2090", "code": "def quotQuotEquivQuotOfLE\u2090 (h : I \u2264 J) : ((A \u29f8 I) \u29f8 J.map (Quotient.mk\u2090 R I)) \u2243\u2090[R] A \u29f8 J :=\n  @AlgEquiv.ofRingEquiv R _ _ _ _ _ _ _ (quotQuotEquivQuotOfLE h) fun _ => rfl", "start": [932, 1], "end": [935, 79], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE\u2090_toRingEquiv", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE\u2090_toRingEquiv (h : I \u2264 J) :\n    (quotQuotEquivQuotOfLE\u2090 R h : _ \u29f8 J.map (Quotient.mk\u2090 R I) \u2243+* _) = quotQuotEquivQuotOfLE h", "start": [938, 1], "end": [941, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotEquivQuotOfLE\u2090", "code": "@[simp]\ntheorem coe_quotQuotEquivQuotOfLE\u2090 (h : I \u2264 J) :\n    \u21d1(quotQuotEquivQuotOfLE\u2090 R h) = \u21d1(quotQuotEquivQuotOfLE h)", "start": [944, 1], "end": [948, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE\u2090_symm_toRingEquiv", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE\u2090_symm_toRingEquiv (h : I \u2264 J) :\n    ((quotQuotEquivQuotOfLE\u2090 R h).symm : _ \u2243+* _ \u29f8 J.map (Quotient.mk\u2090 R I)) =\n      (quotQuotEquivQuotOfLE h).symm", "start": [951, 1], "end": [955, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.coe_quotQuotEquivQuotOfLE\u2090_symm", "code": "@[simp]\ntheorem coe_quotQuotEquivQuotOfLE\u2090_symm (h : I \u2264 J) :\n    \u21d1(quotQuotEquivQuotOfLE\u2090 R h).symm = \u21d1(quotQuotEquivQuotOfLE h).symm", "start": [958, 1], "end": [962, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_comp_quotQuotMk\u2090", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE_comp_quotQuotMk\u2090 (h : I \u2264 J) :\n    AlgHom.comp (\u2191(quotQuotEquivQuotOfLE\u2090 R h)) (quotQuotMk\u2090 R I J) = Quotient.mk\u2090 R J", "start": [965, 1], "end": [968, 6], "kind": "commanddeclaration"}, {"full_name": "DoubleQuot.quotQuotEquivQuotOfLE_symm_comp_mk\u2090", "code": "@[simp]\ntheorem quotQuotEquivQuotOfLE_symm_comp_mk\u2090 (h : I \u2264 J) :\n    AlgHom.comp (\u2191(quotQuotEquivQuotOfLE\u2090 R h).symm) (Quotient.mk\u2090 R J) = quotQuotMk\u2090 R I J", "start": [971, 1], "end": [974, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/HausdorffDistance.lean", "imports": ["Mathlib/Topology/Instances/ENNReal.lean", "Mathlib/Topology/MetricSpace/IsometricSMul.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EMetric.infEdist", "code": "def infEdist (x : \u03b1) (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a05 y \u2208 s, edist x y", "start": [51, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_empty", "code": "@[simp]\ntheorem infEdist_empty : infEdist x \u2205 = \u221e", "start": [56, 1], "end": [58, 16], "kind": "commanddeclaration"}, {"full_name": "EMetric.le_infEdist", "code": "theorem le_infEdist {d} : d \u2264 infEdist x s \u2194 \u2200 y \u2208 s, d \u2264 edist x y", "start": [61, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_union", "code": "@[simp]\ntheorem infEdist_union : infEdist x (s \u222a t) = infEdist x s \u2293 infEdist x t", "start": [65, 1], "end": [68, 13], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_iUnion", "code": "@[simp]\ntheorem infEdist_iUnion (f : \u03b9 \u2192 Set \u03b1) (x : \u03b1) : infEdist x (\u22c3 i, f i) = \u2a05 i, infEdist x (f i)", "start": [71, 1], "end": [73, 18], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_singleton", "code": "@[simp]\ntheorem infEdist_singleton : infEdist x {y} = edist x y", "start": [76, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_le_edist_of_mem", "code": "theorem infEdist_le_edist_of_mem (h : y \u2208 s) : infEdist x s \u2264 edist x y", "start": [82, 1], "end": [84, 15], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_zero_of_mem", "code": "theorem infEdist_zero_of_mem (h : x \u2208 s) : infEdist x s = 0", "start": [87, 1], "end": [89, 73], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_anti", "code": "theorem infEdist_anti (h : s \u2286 t) : infEdist x t \u2264 infEdist x s", "start": [92, 1], "end": [94, 27], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_lt_iff", "code": "theorem infEdist_lt_iff {r : \u211d\u22650\u221e} : infEdist x s < r \u2194 \u2203 y \u2208 s, edist x y < r", "start": [97, 1], "end": [99, 47], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_le_infEdist_add_edist", "code": "theorem infEdist_le_infEdist_add_edist : infEdist x s \u2264 infEdist y s + edist x y", "start": [102, 1], "end": [108, 76], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_le_edist_add_infEdist", "code": "theorem infEdist_le_edist_add_infEdist : infEdist x s \u2264 edist x y + infEdist y s", "start": [111, 1], "end": [113, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.edist_le_infEdist_add_ediam", "code": "theorem edist_le_infEdist_add_ediam (hy : y \u2208 s) : edist x y \u2264 infEdist x s + diam s", "start": [116, 1], "end": [121, 77], "kind": "commanddeclaration"}, {"full_name": "EMetric.continuous_infEdist", "code": "@[continuity]\ntheorem continuous_infEdist : Continuous fun x => infEdist x s", "start": [124, 1], "end": [128, 74], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_closure", "code": "theorem infEdist_closure : infEdist x (closure s) = infEdist x s", "start": [131, 1], "end": [146, 77], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closure_iff_infEdist_zero", "code": "theorem mem_closure_iff_infEdist_zero : x \u2208 closure s \u2194 infEdist x s = 0", "start": [149, 1], "end": [155, 78], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_iff_infEdist_zero_of_closed", "code": "theorem mem_iff_infEdist_zero_of_closed (h : IsClosed s) : x \u2208 s \u2194 infEdist x s = 0", "start": [158, 1], "end": [160, 53], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_pos_iff_not_mem_closure", "code": "theorem infEdist_pos_iff_not_mem_closure {x : \u03b1} {E : Set \u03b1} : 0 < infEdist x E \u2194 x \u2209 closure E", "start": [163, 1], "end": [166, 57], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_closure_pos_iff_not_mem_closure", "code": "theorem infEdist_closure_pos_iff_not_mem_closure {x : \u03b1} {E : Set \u03b1} :\n    0 < infEdist x (closure E) \u2194 x \u2209 closure E", "start": [169, 1], "end": [171, 58], "kind": "commanddeclaration"}, {"full_name": "EMetric.exists_real_pos_lt_infEdist_of_not_mem_closure", "code": "theorem exists_real_pos_lt_infEdist_of_not_mem_closure {x : \u03b1} {E : Set \u03b1} (h : x \u2209 closure E) :\n    \u2203 \u03b5 : \u211d, 0 < \u03b5 \u2227 ENNReal.ofReal \u03b5 < infEdist x E", "start": [174, 1], "end": [178, 49], "kind": "commanddeclaration"}, {"full_name": "EMetric.disjoint_closedBall_of_lt_infEdist", "code": "theorem disjoint_closedBall_of_lt_infEdist {r : \u211d\u22650\u221e} (h : r < infEdist x s) :\n    Disjoint (closedBall x r) s", "start": [181, 1], "end": [189, 26], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_image", "code": "theorem infEdist_image (h\u03a6 : Isometry \u03a6) : infEdist (\u03a6 x) (\u03a6 '' t) = infEdist x t", "start": [192, 1], "end": [194, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_smul", "code": "@[to_additive (attr := simp)]\ntheorem infEdist_smul {M} [SMul M \u03b1] [IsometricSMul M \u03b1] (c : M) (x : \u03b1) (s : Set \u03b1) :\n    infEdist (c \u2022 x) (c \u2022 s) = infEdist x s", "start": [197, 1], "end": [200, 37], "kind": "commanddeclaration"}, {"full_name": "IsOpen.exists_iUnion_isClosed", "code": "theorem _root_.IsOpen.exists_iUnion_isClosed {U : Set \u03b1} (hU : IsOpen U) :\n    \u2203 F : \u2115 \u2192 Set \u03b1, (\u2200 n, IsClosed (F n)) \u2227 (\u2200 n, F n \u2286 U) \u2227 \u22c3 n, F n = U \u2227 Monotone F", "start": [204, 1], "end": [226, 62], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_infEdist_eq_edist", "code": "theorem _root_.IsCompact.exists_infEdist_eq_edist (hs : IsCompact s) (hne : s.Nonempty) (x : \u03b1) :\n    \u2203 y \u2208 s, infEdist x s = edist x y", "start": [229, 1], "end": [234, 82], "kind": "commanddeclaration"}, {"full_name": "EMetric.exists_pos_forall_lt_edist", "code": "theorem exists_pos_forall_lt_edist (hs : IsCompact s) (ht : IsClosed t) (hst : Disjoint s t) :\n    \u2203 r : \u211d\u22650, 0 < r \u2227 \u2200 x \u2208 s, \u2200 y \u2208 t, (r : \u211d\u22650\u221e) < edist x y", "start": [237, 1], "end": [247, 96], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist", "code": "irreducible_def hausdorffEdist {\u03b1 : Type u} [PseudoEMetricSpace \u03b1] (s t : Set \u03b1) : \u211d\u22650\u221e :=\n  (\u2a06 x \u2208 s, infEdist x t) \u2294 \u2a06 y \u2208 t, infEdist y s", "start": [254, 1], "end": [257, 50], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "EMetric.hausdorffEdist_self", "code": "@[simp]\ntheorem hausdorffEdist_self : hausdorffEdist s s = 0", "start": [265, 1], "end": [269, 44], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_comm", "code": "theorem hausdorffEdist_comm : hausdorffEdist s t = hausdorffEdist t s", "start": [272, 1], "end": [274, 49], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_le_of_infEdist", "code": "theorem hausdorffEdist_le_of_infEdist {r : \u211d\u22650\u221e} (H1 : \u2200 x \u2208 s, infEdist x t \u2264 r)\n    (H2 : \u2200 x \u2208 t, infEdist x s \u2264 r) : hausdorffEdist s t \u2264 r", "start": [278, 1], "end": [283, 17], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_le_of_mem_edist", "code": "theorem hausdorffEdist_le_of_mem_edist {r : \u211d\u22650\u221e} (H1 : \u2200 x \u2208 s, \u2203 y \u2208 t, edist x y \u2264 r)\n    (H2 : \u2200 x \u2208 t, \u2203 y \u2208 s, edist x y \u2264 r) : hausdorffEdist s t \u2264 r", "start": [286, 1], "end": [294, 52], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_le_hausdorffEdist_of_mem", "code": "theorem infEdist_le_hausdorffEdist_of_mem (h : x \u2208 s) : infEdist x t \u2264 hausdorffEdist s t", "start": [297, 1], "end": [301, 33], "kind": "commanddeclaration"}, {"full_name": "EMetric.exists_edist_lt_of_hausdorffEdist_lt", "code": "theorem exists_edist_lt_of_hausdorffEdist_lt {r : \u211d\u22650\u221e} (h : x \u2208 s) (H : hausdorffEdist s t < r) :\n    \u2203 y \u2208 t, edist x y < r", "start": [304, 1], "end": [311, 17], "kind": "commanddeclaration"}, {"full_name": "EMetric.infEdist_le_infEdist_add_hausdorffEdist", "code": "theorem infEdist_le_infEdist_add_hausdorffEdist :\n    infEdist x t \u2264 infEdist x s + hausdorffEdist s t", "start": [314, 1], "end": [333, 59], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_image", "code": "theorem hausdorffEdist_image (h : Isometry \u03a6) :\n    hausdorffEdist (\u03a6 '' s) (\u03a6 '' t) = hausdorffEdist s t", "start": [336, 1], "end": [339, 63], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_le_ediam", "code": "theorem hausdorffEdist_le_ediam (hs : s.Nonempty) (ht : t.Nonempty) :\n    hausdorffEdist s t \u2264 diam (s \u222a t)", "start": [342, 1], "end": [351, 95], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_triangle", "code": "theorem hausdorffEdist_triangle : hausdorffEdist s u \u2264 hausdorffEdist s t + hausdorffEdist t u", "start": [354, 1], "end": [373, 95], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_zero_iff_closure_eq_closure", "code": "theorem hausdorffEdist_zero_iff_closure_eq_closure :\n    hausdorffEdist s t = 0 \u2194 closure s = closure t", "start": [376, 1], "end": [380, 95], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_self_closure", "code": "@[simp]\ntheorem hausdorffEdist_self_closure : hausdorffEdist s (closure s) = 0", "start": [383, 1], "end": [386, 67], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_closure\u2081", "code": "@[simp]\ntheorem hausdorffEdist_closure\u2081 : hausdorffEdist (closure s) t = hausdorffEdist s t", "start": [389, 1], "end": [398, 50], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_closure\u2082", "code": "@[simp]\ntheorem hausdorffEdist_closure\u2082 : hausdorffEdist s (closure t) = hausdorffEdist s t", "start": [401, 1], "end": [404, 38], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_closure", "code": "theorem hausdorffEdist_closure : hausdorffEdist (closure s) (closure t) = hausdorffEdist s t", "start": [407, 1], "end": [410, 7], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_zero_iff_eq_of_closed", "code": "theorem hausdorffEdist_zero_iff_eq_of_closed (hs : IsClosed s) (ht : IsClosed t) :\n    hausdorffEdist s t = 0 \u2194 s = t", "start": [413, 1], "end": [416, 80], "kind": "commanddeclaration"}, {"full_name": "EMetric.hausdorffEdist_empty", "code": "theorem hausdorffEdist_empty (ne : s.Nonempty) : hausdorffEdist s \u2205 = \u221e", "start": [419, 1], "end": [423, 19], "kind": "commanddeclaration"}, {"full_name": "EMetric.nonempty_of_hausdorffEdist_ne_top", "code": "theorem nonempty_of_hausdorffEdist_ne_top (hs : s.Nonempty) (fin : hausdorffEdist s t \u2260 \u22a4) :\n    t.Nonempty", "start": [426, 1], "end": [429, 87], "kind": "commanddeclaration"}, {"full_name": "EMetric.empty_or_nonempty_of_hausdorffEdist_ne_top", "code": "theorem empty_or_nonempty_of_hausdorffEdist_ne_top (fin : hausdorffEdist s t \u2260 \u22a4) :\n    (s = \u2205 \u2227 t = \u2205) \u2228 (s.Nonempty \u2227 t.Nonempty)", "start": [432, 1], "end": [439, 64], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist", "code": "def infDist (x : \u03b1) (s : Set \u03b1) : \u211d :=\n  ENNReal.toReal (infEdist x s)", "start": [464, 1], "end": [466, 32], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_eq_iInf", "code": "theorem infDist_eq_iInf : infDist x s = \u2a05 y : s, dist x y", "start": [469, 1], "end": [472, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_nonneg", "code": "theorem infDist_nonneg : 0 \u2264 infDist x s", "start": [475, 1], "end": [476, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_empty", "code": "@[simp]\ntheorem infDist_empty : infDist x \u2205 = 0", "start": [479, 1], "end": [482, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.infEdist_ne_top", "code": "theorem infEdist_ne_top (h : s.Nonempty) : infEdist x s \u2260 \u22a4", "start": [485, 1], "end": [488, 77], "kind": "commanddeclaration"}, {"full_name": "Metric.infEdist_eq_top_iff", "code": "theorem infEdist_eq_top_iff : infEdist x s = \u221e \u2194 s = \u2205", "start": [492, 1], "end": [493, 95], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_zero_of_mem", "code": "theorem infDist_zero_of_mem (h : x \u2208 s) : infDist x s = 0", "start": [495, 1], "end": [497, 41], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_singleton", "code": "@[simp]\ntheorem infDist_singleton : infDist x {y} = dist x y", "start": [500, 1], "end": [502, 86], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_le_dist_of_mem", "code": "theorem infDist_le_dist_of_mem (h : y \u2208 s) : infDist x s \u2264 dist x y", "start": [505, 1], "end": [508, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_le_infDist_of_subset", "code": "theorem infDist_le_infDist_of_subset (h : s \u2286 t) (hs : s.Nonempty) : infDist x t \u2264 infDist x s", "start": [511, 1], "end": [513, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_lt_iff", "code": "theorem infDist_lt_iff {r : \u211d} (hs : s.Nonempty) : infDist x s < r \u2194 \u2203 y \u2208 s, dist x y < r", "start": [516, 1], "end": [519, 70], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_le_infDist_add_dist", "code": "theorem infDist_le_infDist_add_dist : infDist x s \u2264 infDist y s + dist x y", "start": [522, 1], "end": [527, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.not_mem_of_dist_lt_infDist", "code": "theorem not_mem_of_dist_lt_infDist (h : dist x y < infDist x s) : y \u2209 s", "start": [530, 1], "end": [531, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_ball_infDist", "code": "theorem disjoint_ball_infDist : Disjoint (ball x (infDist x s)) s", "start": [534, 1], "end": [535, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_infDist_subset_compl", "code": "theorem ball_infDist_subset_compl : ball x (infDist x s) \u2286 s\u1d9c", "start": [538, 1], "end": [539, 54], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_infDist_compl_subset", "code": "theorem ball_infDist_compl_subset : ball x (infDist x s\u1d9c) \u2286 s", "start": [542, 1], "end": [543, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_closedBall_of_lt_infDist", "code": "theorem disjoint_closedBall_of_lt_infDist {r : \u211d} (h : r < infDist x s) :\n    Disjoint (closedBall x r) s", "start": [546, 1], "end": [548, 62], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_le_infDist_add_diam", "code": "theorem dist_le_infDist_add_diam (hs : IsBounded s) (hy : y \u2208 s) :\n    dist x y \u2264 infDist x s + diam s", "start": [551, 1], "end": [554, 97], "kind": "commanddeclaration"}, {"full_name": "Metric.lipschitz_infDist_pt", "code": "theorem lipschitz_infDist_pt : LipschitzWith 1 (infDist \u00b7 s)", "start": [559, 1], "end": [561, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuous_infDist_pt", "code": "theorem uniformContinuous_infDist_pt : UniformContinuous (infDist \u00b7 s)", "start": [564, 1], "end": [566, 45], "kind": "commanddeclaration"}, {"full_name": "Metric.continuous_infDist_pt", "code": "@[continuity]\ntheorem continuous_infDist_pt : Continuous (infDist \u00b7 s)", "start": [569, 1], "end": [572, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_closure", "code": "theorem infDist_closure : infDist x (closure s) = infDist x s", "start": [577, 1], "end": [579, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_zero_of_mem_closure", "code": "theorem infDist_zero_of_mem_closure (hx : x \u2208 closure s) : infDist x s = 0", "start": [582, 1], "end": [586, 31], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closure_iff_infDist_zero", "code": "theorem mem_closure_iff_infDist_zero (h : s.Nonempty) : x \u2208 closure s \u2194 infDist x s = 0", "start": [589, 1], "end": [591, 95], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_iff_infDist_zero", "code": "theorem _root_.IsClosed.mem_iff_infDist_zero (h : IsClosed s) (hs : s.Nonempty) :\n    x \u2208 s \u2194 infDist x s = 0", "start": [594, 1], "end": [596, 87], "kind": "commanddeclaration"}, {"full_name": "IsClosed.not_mem_iff_infDist_pos", "code": "theorem _root_.IsClosed.not_mem_iff_infDist_pos (h : IsClosed s) (hs : s.Nonempty) :\n    x \u2209 s \u2194 0 < infDist x s", "start": [599, 1], "end": [602, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousAt_inv_infDist_pt", "code": "theorem continuousAt_inv_infDist_pt (h : x \u2209 closure s) :\n    ContinuousAt (fun x \u21a6 (infDist x s)\u207b\u00b9) x", "start": [606, 1], "end": [611, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_image", "code": "theorem infDist_image (h\u03a6 : Isometry \u03a6) : infDist (\u03a6 x) (\u03a6 '' t) = infDist x t", "start": [613, 1], "end": [615, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_inter_closedBall_of_mem", "code": "theorem infDist_inter_closedBall_of_mem (h : y \u2208 s) :\n    infDist x (s \u2229 closedBall x (dist y x)) = infDist x s", "start": [618, 1], "end": [627, 59], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_infDist_eq_dist", "code": "theorem _root_.IsCompact.exists_infDist_eq_dist (h : IsCompact s) (hne : s.Nonempty) (x : \u03b1) :\n    \u2203 y \u2208 s, infDist x s = dist x y", "start": [630, 1], "end": [633, 44], "kind": "commanddeclaration"}, {"full_name": "IsClosed.exists_infDist_eq_dist", "code": "theorem _root_.IsClosed.exists_infDist_eq_dist [ProperSpace \u03b1] (h : IsClosed s) (hne : s.Nonempty)\n    (x : \u03b1) : \u2203 y \u2208 s, infDist x s = dist x y", "start": [636, 1], "end": [644, 22], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_mem_closure_infDist_eq_dist", "code": "theorem exists_mem_closure_infDist_eq_dist [ProperSpace \u03b1] (hne : s.Nonempty) (x : \u03b1) :\n    \u2203 y \u2208 closure s, infDist x s = dist x y", "start": [647, 1], "end": [649, 91], "kind": "commanddeclaration"}, {"full_name": "Metric.infNndist", "code": "def infNndist (x : \u03b1) (s : Set \u03b1) : \u211d\u22650 :=\n  ENNReal.toNNReal (infEdist x s)", "start": [654, 1], "end": [656, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.coe_infNndist", "code": "@[simp]\ntheorem coe_infNndist : (infNndist x s : \u211d) = infDist x s", "start": [659, 1], "end": [661, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.lipschitz_infNndist_pt", "code": "theorem lipschitz_infNndist_pt (s : Set \u03b1) : LipschitzWith 1 fun x => infNndist x s", "start": [664, 1], "end": [666, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuous_infNndist_pt", "code": "theorem uniformContinuous_infNndist_pt (s : Set \u03b1) : UniformContinuous fun x => infNndist x s", "start": [669, 1], "end": [671, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.continuous_infNndist_pt", "code": "theorem continuous_infNndist_pt (s : Set \u03b1) : Continuous fun x => infNndist x s", "start": [674, 1], "end": [676, 48], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist", "code": "def hausdorffDist (s t : Set \u03b1) : \u211d :=\n  ENNReal.toReal (hausdorffEdist s t)", "start": [681, 1], "end": [685, 38], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_nonneg", "code": "theorem hausdorffDist_nonneg : 0 \u2264 hausdorffDist s t", "start": [688, 1], "end": [689, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded", "code": "theorem hausdorffEdist_ne_top_of_nonempty_of_bounded (hs : s.Nonempty) (ht : t.Nonempty)\n    (bs : IsBounded s) (bt : IsBounded t) : hausdorffEdist s t \u2260 \u22a4", "start": [692, 1], "end": [712, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_self_zero", "code": "@[simp]\ntheorem hausdorffDist_self_zero : hausdorffDist s s = 0", "start": [715, 1], "end": [717, 83], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_comm", "code": "theorem hausdorffDist_comm : hausdorffDist s t = hausdorffDist t s", "start": [720, 1], "end": [722, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_empty", "code": "@[simp]\ntheorem hausdorffDist_empty : hausdorffDist s \u2205 = 0", "start": [725, 1], "end": [731, 49], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_empty'", "code": "@[simp]\ntheorem hausdorffDist_empty' : hausdorffDist \u2205 s = 0", "start": [734, 1], "end": [737, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_le_of_infDist", "code": "theorem hausdorffDist_le_of_infDist {r : \u211d} (hr : 0 \u2264 r) (H1 : \u2200 x \u2208 s, infDist x t \u2264 r)\n    (H2 : \u2200 x \u2208 t, infDist x s \u2264 r) : hausdorffDist s t \u2264 r", "start": [740, 1], "end": [761, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_le_of_mem_dist", "code": "theorem hausdorffDist_le_of_mem_dist {r : \u211d} (hr : 0 \u2264 r) (H1 : \u2200 x \u2208 s, \u2203 y \u2208 t, dist x y \u2264 r)\n    (H2 : \u2200 x \u2208 t, \u2203 y \u2208 s, dist x y \u2264 r) : hausdorffDist s t \u2264 r", "start": [764, 1], "end": [774, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_le_diam", "code": "theorem hausdorffDist_le_diam (hs : s.Nonempty) (bs : IsBounded s) (ht : t.Nonempty)\n    (bt : IsBounded t) : hausdorffDist s t \u2264 diam (s \u222a t)", "start": [777, 1], "end": [786, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_le_hausdorffDist_of_mem", "code": "theorem infDist_le_hausdorffDist_of_mem (hx : x \u2208 s) (fin : hausdorffEdist s t \u2260 \u22a4) :\n    infDist x t \u2264 hausdorffDist s t", "start": [789, 1], "end": [792, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_dist_lt_of_hausdorffDist_lt", "code": "theorem exists_dist_lt_of_hausdorffDist_lt {r : \u211d} (h : x \u2208 s) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t \u2260 \u22a4) : \u2203 y \u2208 t, dist x y < r", "start": [795, 1], "end": [805, 20], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_dist_lt_of_hausdorffDist_lt'", "code": "theorem exists_dist_lt_of_hausdorffDist_lt' {r : \u211d} (h : y \u2208 t) (H : hausdorffDist s t < r)\n    (fin : hausdorffEdist s t \u2260 \u22a4) : \u2203 x \u2208 s, dist x y < r", "start": [808, 1], "end": [814, 69], "kind": "commanddeclaration"}, {"full_name": "Metric.infDist_le_infDist_add_hausdorffDist", "code": "theorem infDist_le_infDist_add_hausdorffDist (fin : hausdorffEdist s t \u2260 \u22a4) :\n    infDist x t \u2264 infDist x s + hausdorffDist s t", "start": [817, 1], "end": [824, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_image", "code": "theorem hausdorffDist_image (h : Isometry \u03a6) :\n    hausdorffDist (\u03a6 '' s) (\u03a6 '' t) = hausdorffDist s t", "start": [827, 1], "end": [830, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_triangle", "code": "theorem hausdorffDist_triangle (fin : hausdorffEdist s t \u2260 \u22a4) :\n    hausdorffDist s u \u2264 hausdorffDist s t + hausdorffDist t u", "start": [833, 1], "end": [838, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_triangle'", "code": "theorem hausdorffDist_triangle' (fin : hausdorffEdist t u \u2260 \u22a4) :\n    hausdorffDist s u \u2264 hausdorffDist s t + hausdorffDist t u", "start": [841, 1], "end": [847, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_self_closure", "code": "@[simp]\ntheorem hausdorffDist_self_closure : hausdorffDist s (closure s) = 0", "start": [850, 1], "end": [852, 96], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_closure\u2081", "code": "@[simp]\ntheorem hausdorffDist_closure\u2081 : hausdorffDist (closure s) t = hausdorffDist s t", "start": [855, 1], "end": [858, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_closure\u2082", "code": "@[simp]\ntheorem hausdorffDist_closure\u2082 : hausdorffDist s (closure t) = hausdorffDist s t", "start": [861, 1], "end": [864, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_closure", "code": "theorem hausdorffDist_closure : hausdorffDist (closure s) (closure t) = hausdorffDist s t", "start": [867, 1], "end": [870, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.hausdorffDist_zero_iff_closure_eq_closure", "code": "theorem hausdorffDist_zero_iff_closure_eq_closure (fin : hausdorffEdist s t \u2260 \u22a4) :\n    hausdorffDist s t = 0 \u2194 closure s = closure t", "start": [873, 1], "end": [877, 37], "kind": "commanddeclaration"}, {"full_name": "IsClosed.hausdorffDist_zero_iff_eq", "code": "theorem _root_.IsClosed.hausdorffDist_zero_iff_eq (hs : IsClosed s) (ht : IsClosed t)\n    (fin : hausdorffEdist s t \u2260 \u22a4) : hausdorffDist s t = 0 \u2194 s = t", "start": [880, 1], "end": [884, 9], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening", "code": "def thickening (\u03b4 : \u211d) (E : Set \u03b1) : Set \u03b1 :=\n  { x : \u03b1 | infEdist x E < ENNReal.ofReal \u03b4 }", "start": [896, 1], "end": [899, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_thickening_iff_infEdist_lt", "code": "theorem mem_thickening_iff_infEdist_lt : x \u2208 thickening \u03b4 s \u2194 infEdist x s < ENNReal.ofReal \u03b4", "start": [902, 1], "end": [903, 10], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_not_mem_thickening_of_infEdist_pos", "code": "lemma eventually_not_mem_thickening_of_infEdist_pos {E : Set \u03b1} {x : \u03b1} (h : x \u2209 closure E) :\n    \u2200\u1da0 \u03b4 in \ud835\udcdd (0 : \u211d), x \u2209 Metric.thickening \u03b4 E := by\n  obtain \u27e8\u03b5, \u27e8\u03b5_pos, \u03b5_lt\u27e9\u27e9 := exists_real_pos_lt_infEdist_of_not_mem_closure h\n  filter_upwards [eventually_lt_nhds \u03b5_pos] with \u03b4 h\u03b4\n  simp only [thickening, mem_setOf_eq, not_lt]\n  exact (ENNReal.ofReal_le_ofReal h\u03b4.le).trans \u03b5_lt.le", "start": [906, 1], "end": [913, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Metric.thickening_eq_preimage_infEdist", "code": "theorem thickening_eq_preimage_infEdist (\u03b4 : \u211d) (E : Set \u03b1) :\n    thickening \u03b4 E = (infEdist \u00b7 E) \u207b\u00b9' Iio (ENNReal.ofReal \u03b4)", "start": [915, 1], "end": [918, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.isOpen_thickening", "code": "theorem isOpen_thickening {\u03b4 : \u211d} {E : Set \u03b1} : IsOpen (thickening \u03b4 E)", "start": [921, 1], "end": [923, 62], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_empty", "code": "@[simp]\ntheorem thickening_empty (\u03b4 : \u211d) : thickening \u03b4 (\u2205 : Set \u03b1) = \u2205", "start": [926, 1], "end": [929, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_of_nonpos", "code": "theorem thickening_of_nonpos (h\u03b4 : \u03b4 \u2264 0) (s : Set \u03b1) : thickening \u03b4 s = \u2205", "start": [932, 1], "end": [933, 93], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_mono", "code": "theorem thickening_mono {\u03b4\u2081 \u03b4\u2082 : \u211d} (hle : \u03b4\u2081 \u2264 \u03b4\u2082) (E : Set \u03b1) :\n    thickening \u03b4\u2081 E \u2286 thickening \u03b4\u2082 E", "start": [936, 1], "end": [940, 64], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_subset_of_subset", "code": "theorem thickening_subset_of_subset (\u03b4 : \u211d) {E\u2081 E\u2082 : Set \u03b1} (h : E\u2081 \u2286 E\u2082) :\n    thickening \u03b4 E\u2081 \u2286 thickening \u03b4 E\u2082", "start": [943, 1], "end": [946, 89], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_thickening_iff_exists_edist_lt", "code": "theorem mem_thickening_iff_exists_edist_lt {\u03b4 : \u211d} (E : Set \u03b1) (x : \u03b1) :\n    x \u2208 thickening \u03b4 E \u2194 \u2203 z \u2208 E, edist x z < ENNReal.ofReal \u03b4", "start": [949, 1], "end": [951, 18], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_thickening_subset", "code": "theorem frontier_thickening_subset (E : Set \u03b1) {\u03b4 : \u211d} :\n    frontier (thickening \u03b4 E) \u2286 { x : \u03b1 | infEdist x E = ENNReal.ofReal \u03b4 }", "start": [954, 1], "end": [958, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_thickening_disjoint", "code": "theorem frontier_thickening_disjoint (A : Set \u03b1) :\n    Pairwise (Disjoint on fun r : \u211d => frontier (thickening r A))", "start": [961, 1], "end": [969, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_thickening_iff_infDist_lt", "code": "theorem mem_thickening_iff_infDist_lt {E : Set X} {x : X} (h : E.Nonempty) :\n    x \u2208 thickening \u03b4 E \u2194 infDist x E < \u03b4", "start": [975, 1], "end": [977, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_thickening_iff", "code": "theorem mem_thickening_iff {E : Set X} {x : X} : x \u2208 thickening \u03b4 E \u2194 \u2203 z \u2208 E, dist x z < \u03b4", "start": [979, 1], "end": [984, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_singleton", "code": "@[simp]\ntheorem thickening_singleton (\u03b4 : \u211d) (x : X) : thickening \u03b4 ({x} : Set X) = ball x \u03b4", "start": [987, 1], "end": [990, 28], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset_thickening", "code": "theorem ball_subset_thickening {x : X} {E : Set X} (hx : x \u2208 E) (\u03b4 : \u211d) :\n    ball x \u03b4 \u2286 thickening \u03b4 E", "start": [993, 1], "end": [995, 101], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_eq_biUnion_ball", "code": "theorem thickening_eq_biUnion_ball {\u03b4 : \u211d} {E : Set X} : thickening \u03b4 E = \u22c3 x \u2208 E, ball x \u03b4", "start": [998, 1], "end": [1003, 27], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.thickening", "code": "protected theorem _root_.Bornology.IsBounded.thickening {\u03b4 : \u211d} {E : Set X} (h : IsBounded E) :\n    IsBounded (thickening \u03b4 E)", "start": [1006, 1], "end": [1013, 93], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening", "code": "def cthickening (\u03b4 : \u211d) (E : Set \u03b1) : Set \u03b1 :=\n  { x : \u03b1 | infEdist x E \u2264 ENNReal.ofReal \u03b4 }", "start": [1025, 1], "end": [1028, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_cthickening_iff", "code": "@[simp]\ntheorem mem_cthickening_iff : x \u2208 cthickening \u03b4 s \u2194 infEdist x s \u2264 ENNReal.ofReal \u03b4", "start": [1031, 1], "end": [1033, 10], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_not_mem_cthickening_of_infEdist_pos", "code": "lemma eventually_not_mem_cthickening_of_infEdist_pos {E : Set \u03b1} {x : \u03b1} (h : x \u2209 closure E) :\n    \u2200\u1da0 \u03b4 in \ud835\udcdd (0 : \u211d), x \u2209 Metric.cthickening \u03b4 E := by\n  obtain \u27e8\u03b5, \u27e8\u03b5_pos, \u03b5_lt\u27e9\u27e9 := exists_real_pos_lt_infEdist_of_not_mem_closure h\n  filter_upwards [eventually_lt_nhds \u03b5_pos] with \u03b4 h\u03b4\n  simp only [cthickening, mem_setOf_eq, not_le]\n  exact ((ofReal_lt_ofReal_iff \u03b5_pos).mpr h\u03b4).trans \u03b5_lt", "start": [1036, 1], "end": [1043, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Metric.mem_cthickening_of_edist_le", "code": "theorem mem_cthickening_of_edist_le (x y : \u03b1) (\u03b4 : \u211d) (E : Set \u03b1) (h : y \u2208 E)\n    (h' : edist x y \u2264 ENNReal.ofReal \u03b4) : x \u2208 cthickening \u03b4 E", "start": [1045, 1], "end": [1047, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_cthickening_of_dist_le", "code": "theorem mem_cthickening_of_dist_le {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x y : \u03b1) (\u03b4 : \u211d) (E : Set \u03b1)\n    (h : y \u2208 E) (h' : dist x y \u2264 \u03b4) : x \u2208 cthickening \u03b4 E", "start": [1050, 1], "end": [1054, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_preimage_infEdist", "code": "theorem cthickening_eq_preimage_infEdist (\u03b4 : \u211d) (E : Set \u03b1) :\n    cthickening \u03b4 E = (fun x => infEdist x E) \u207b\u00b9' Iic (ENNReal.ofReal \u03b4)", "start": [1057, 1], "end": [1059, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.isClosed_cthickening", "code": "theorem isClosed_cthickening {\u03b4 : \u211d} {E : Set \u03b1} : IsClosed (cthickening \u03b4 E)", "start": [1062, 1], "end": [1064, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_empty", "code": "@[simp]\ntheorem cthickening_empty (\u03b4 : \u211d) : cthickening \u03b4 (\u2205 : Set \u03b1) = \u2205", "start": [1067, 1], "end": [1070, 90], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_of_nonpos", "code": "theorem cthickening_of_nonpos {\u03b4 : \u211d} (h\u03b4 : \u03b4 \u2264 0) (E : Set \u03b1) : cthickening \u03b4 E = closure E", "start": [1073, 1], "end": [1075, 81], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_zero", "code": "@[simp]\ntheorem cthickening_zero (E : Set \u03b1) : cthickening 0 E = closure E", "start": [1078, 1], "end": [1081, 33], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_max_zero", "code": "theorem cthickening_max_zero (\u03b4 : \u211d) (E : Set \u03b1) : cthickening (max 0 \u03b4) E = cthickening \u03b4 E", "start": [1084, 1], "end": [1085, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_mono", "code": "theorem cthickening_mono {\u03b4\u2081 \u03b4\u2082 : \u211d} (hle : \u03b4\u2081 \u2264 \u03b4\u2082) (E : Set \u03b1) :\n    cthickening \u03b4\u2081 E \u2286 cthickening \u03b4\u2082 E", "start": [1088, 1], "end": [1092, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_singleton", "code": "@[simp]\ntheorem cthickening_singleton {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x : \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 \u2264 \u03b4) :\n    cthickening \u03b4 ({x} : Set \u03b1) = closedBall x \u03b4", "start": [1095, 1], "end": [1099, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_cthickening_singleton", "code": "theorem closedBall_subset_cthickening_singleton {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x : \u03b1) (\u03b4 : \u211d) :\n    closedBall x \u03b4 \u2286 cthickening \u03b4 ({x} : Set \u03b1)", "start": [1102, 1], "end": [1106, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_subset_of_subset", "code": "theorem cthickening_subset_of_subset (\u03b4 : \u211d) {E\u2081 E\u2082 : Set \u03b1} (h : E\u2081 \u2286 E\u2082) :\n    cthickening \u03b4 E\u2081 \u2286 cthickening \u03b4 E\u2082", "start": [1109, 1], "end": [1112, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_subset_thickening", "code": "theorem cthickening_subset_thickening {\u03b4\u2081 : \u211d\u22650} {\u03b4\u2082 : \u211d} (hlt : (\u03b4\u2081 : \u211d) < \u03b4\u2082) (E : Set \u03b1) :\n    cthickening \u03b4\u2081 E \u2286 thickening \u03b4\u2082 E", "start": [1115, 1], "end": [1117, 88], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_subset_thickening'", "code": "theorem cthickening_subset_thickening' {\u03b4\u2081 \u03b4\u2082 : \u211d} (\u03b4\u2082_pos : 0 < \u03b4\u2082) (hlt : \u03b4\u2081 < \u03b4\u2082) (E : Set \u03b1) :\n    cthickening \u03b4\u2081 E \u2286 thickening \u03b4\u2082 E", "start": [1120, 1], "end": [1124, 72], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_subset_cthickening", "code": "theorem thickening_subset_cthickening (\u03b4 : \u211d) (E : Set \u03b1) : thickening \u03b4 E \u2286 cthickening \u03b4 E", "start": [1127, 1], "end": [1132, 14], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_subset_cthickening_of_le", "code": "theorem thickening_subset_cthickening_of_le {\u03b4\u2081 \u03b4\u2082 : \u211d} (hle : \u03b4\u2081 \u2264 \u03b4\u2082) (E : Set \u03b1) :\n    thickening \u03b4\u2081 E \u2286 cthickening \u03b4\u2082 E", "start": [1135, 1], "end": [1137, 70], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.cthickening", "code": "theorem _root_.Bornology.IsBounded.cthickening {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {\u03b4 : \u211d} {E : Set \u03b1}\n    (h : IsBounded E) : IsBounded (cthickening \u03b4 E)", "start": [1140, 1], "end": [1145, 50], "kind": "commanddeclaration"}, {"full_name": "IsCompact.cthickening", "code": "protected theorem _root_.IsCompact.cthickening\n    {\u03b1 : Type*} [PseudoMetricSpace \u03b1] [ProperSpace \u03b1] {s : Set \u03b1}\n    (hs : IsCompact s) {r : \u211d} : IsCompact (cthickening r s)", "start": [1148, 1], "end": [1151, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_subset_interior_cthickening", "code": "theorem thickening_subset_interior_cthickening (\u03b4 : \u211d) (E : Set \u03b1) :\n    thickening \u03b4 E \u2286 interior (cthickening \u03b4 E)", "start": [1153, 1], "end": [1156, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_thickening_subset_cthickening", "code": "theorem closure_thickening_subset_cthickening (\u03b4 : \u211d) (E : Set \u03b1) :\n    closure (thickening \u03b4 E) \u2286 cthickening \u03b4 E", "start": [1159, 1], "end": [1161, 95], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_subset_cthickening", "code": "theorem closure_subset_cthickening (\u03b4 : \u211d) (E : Set \u03b1) : closure E \u2286 cthickening \u03b4 E", "start": [1164, 1], "end": [1167, 45], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_subset_thickening", "code": "theorem closure_subset_thickening {\u03b4 : \u211d} (\u03b4_pos : 0 < \u03b4) (E : Set \u03b1) :\n    closure E \u2286 thickening \u03b4 E", "start": [1170, 1], "end": [1174, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.self_subset_thickening", "code": "theorem self_subset_thickening {\u03b4 : \u211d} (\u03b4_pos : 0 < \u03b4) (E : Set \u03b1) : E \u2286 thickening \u03b4 E", "start": [1177, 1], "end": [1179, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.self_subset_cthickening", "code": "theorem self_subset_cthickening {\u03b4 : \u211d} (E : Set \u03b1) : E \u2286 cthickening \u03b4 E", "start": [1182, 1], "end": [1184, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_mem_nhdsSet", "code": "theorem thickening_mem_nhdsSet (E : Set \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 < \u03b4) : thickening \u03b4 E \u2208 \ud835\udcdd\u02e2 E", "start": [1187, 1], "end": [1188, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_mem_nhdsSet", "code": "theorem cthickening_mem_nhdsSet (E : Set \u03b1) {\u03b4 : \u211d} (h\u03b4 : 0 < \u03b4) : cthickening \u03b4 E \u2208 \ud835\udcdd\u02e2 E", "start": [1191, 1], "end": [1192, 84], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_union", "code": "@[simp]\ntheorem thickening_union (\u03b4 : \u211d) (s t : Set \u03b1) :\n    thickening \u03b4 (s \u222a t) = thickening \u03b4 s \u222a thickening \u03b4 t", "start": [1195, 1], "end": [1198, 73], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_union", "code": "@[simp]\ntheorem cthickening_union (\u03b4 : \u211d) (s t : Set \u03b1) :\n    cthickening \u03b4 (s \u222a t) = cthickening \u03b4 s \u222a cthickening \u03b4 t", "start": [1201, 1], "end": [1204, 74], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_iUnion", "code": "@[simp]\ntheorem thickening_iUnion (\u03b4 : \u211d) (f : \u03b9 \u2192 Set \u03b1) :\n    thickening \u03b4 (\u22c3 i, f i) = \u22c3 i, thickening \u03b4 (f i)", "start": [1207, 1], "end": [1210, 67], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_cthickening_le", "code": "theorem ediam_cthickening_le (\u03b5 : \u211d\u22650) :\n    EMetric.diam (cthickening \u03b5 s) \u2264 EMetric.diam s + 2 * \u03b5", "start": [1213, 1], "end": [1225, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_thickening_le", "code": "theorem ediam_thickening_le (\u03b5 : \u211d\u22650) : EMetric.diam (thickening \u03b5 s) \u2264 EMetric.diam s + 2 * \u03b5", "start": [1228, 1], "end": [1229, 91], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_cthickening_le", "code": "theorem diam_cthickening_le {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (s : Set \u03b1) (h\u03b5 : 0 \u2264 \u03b5) :\n    diam (cthickening \u03b5 s) \u2264 diam s + 2 * \u03b5", "start": [1232, 1], "end": [1238, 16], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_thickening_le", "code": "theorem diam_thickening_le {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (s : Set \u03b1) (h\u03b5 : 0 \u2264 \u03b5) :\n    diam (thickening \u03b5 s) \u2264 diam s + 2 * \u03b5", "start": [1241, 1], "end": [1249, 15], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_closure", "code": "@[simp]\ntheorem thickening_closure : thickening \u03b4 (closure s) = thickening \u03b4 s", "start": [1252, 1], "end": [1254, 41], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_closure", "code": "@[simp]\ntheorem cthickening_closure : cthickening \u03b4 (closure s) = cthickening \u03b4 s", "start": [1257, 1], "end": [1259, 42], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_thickenings", "code": "theorem _root_.Disjoint.exists_thickenings (hst : Disjoint s t) (hs : IsCompact s)\n    (ht : IsClosed t) :\n    \u2203 \u03b4, 0 < \u03b4 \u2227 Disjoint (thickening \u03b4 s) (thickening \u03b4 t)", "start": [1264, 1], "end": [1279, 51], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_cthickenings", "code": "theorem _root_.Disjoint.exists_cthickenings (hst : Disjoint s t) (hs : IsCompact s)\n    (ht : IsClosed t) :\n    \u2203 \u03b4, 0 < \u03b4 \u2227 Disjoint (cthickening \u03b4 s) (cthickening \u03b4 t)", "start": [1282, 1], "end": [1287, 64], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_cthickening_subset_open", "code": "theorem _root_.IsCompact.exists_cthickening_subset_open (hs : IsCompact s) (ht : IsOpen t)\n    (hst : s \u2286 t) :\n    \u2203 \u03b4, 0 < \u03b4 \u2227 cthickening \u03b4 s \u2286 t", "start": [1290, 1], "end": [1294, 92], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isCompact_cthickening", "code": "theorem _root_.IsCompact.exists_isCompact_cthickening [LocallyCompactSpace \u03b1] (hs : IsCompact s) :\n    \u2203 \u03b4, 0 < \u03b4 \u2227 IsCompact (cthickening \u03b4 s)", "start": [1297, 1], "end": [1302, 85], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_thickening_subset_open", "code": "theorem _root_.IsCompact.exists_thickening_subset_open (hs : IsCompact s) (ht : IsOpen t)\n    (hst : s \u2286 t) : \u2203 \u03b4, 0 < \u03b4 \u2227 thickening \u03b4 s \u2286 t", "start": [1304, 1], "end": [1307, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.hasBasis_nhdsSet_thickening", "code": "theorem hasBasis_nhdsSet_thickening {K : Set \u03b1} (hK : IsCompact K) :\n    (\ud835\udcdd\u02e2 K).HasBasis (fun \u03b4 : \u211d => 0 < \u03b4) fun \u03b4 => thickening \u03b4 K", "start": [1310, 1], "end": [1313, 38], "kind": "commanddeclaration"}, {"full_name": "Metric.hasBasis_nhdsSet_cthickening", "code": "theorem hasBasis_nhdsSet_cthickening {K : Set \u03b1} (hK : IsCompact K) :\n    (\ud835\udcdd\u02e2 K).HasBasis (fun \u03b4 : \u211d => 0 < \u03b4) fun \u03b4 => cthickening \u03b4 K", "start": [1316, 1], "end": [1319, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_iInter_cthickening'", "code": "theorem cthickening_eq_iInter_cthickening' {\u03b4 : \u211d} (s : Set \u211d) (hs\u03b4 : s \u2286 Ioi \u03b4)\n    (hs : \u2200 \u03b5, \u03b4 < \u03b5 \u2192 (s \u2229 Ioc \u03b4 \u03b5).Nonempty) (E : Set \u03b1) :\n    cthickening \u03b4 E = \u22c2 \u03b5 \u2208 s, cthickening \u03b5 E", "start": [1322, 1], "end": [1335, 32], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_iInter_cthickening", "code": "theorem cthickening_eq_iInter_cthickening {\u03b4 : \u211d} (E : Set \u03b1) :\n    cthickening \u03b4 E = \u22c2 (\u03b5 : \u211d) (_ : \u03b4 < \u03b5), cthickening \u03b5 E", "start": [1338, 1], "end": [1342, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_iInter_thickening'", "code": "theorem cthickening_eq_iInter_thickening' {\u03b4 : \u211d} (\u03b4_nn : 0 \u2264 \u03b4) (s : Set \u211d) (hs\u03b4 : s \u2286 Ioi \u03b4)\n    (hs : \u2200 \u03b5, \u03b4 < \u03b5 \u2192 (s \u2229 Ioc \u03b4 \u03b5).Nonempty) (E : Set \u03b1) :\n    cthickening \u03b4 E = \u22c2 \u03b5 \u2208 s, thickening \u03b5 E", "start": [1345, 1], "end": [1353, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_iInter_thickening", "code": "theorem cthickening_eq_iInter_thickening {\u03b4 : \u211d} (\u03b4_nn : 0 \u2264 \u03b4) (E : Set \u03b1) :\n    cthickening \u03b4 E = \u22c2 (\u03b5 : \u211d) (_ : \u03b4 < \u03b5), thickening \u03b5 E", "start": [1356, 1], "end": [1360, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_iInter_thickening''", "code": "theorem cthickening_eq_iInter_thickening'' (\u03b4 : \u211d) (E : Set \u03b1) :\n    cthickening \u03b4 E = \u22c2 (\u03b5 : \u211d) (_ : max 0 \u03b4 < \u03b5), thickening \u03b5 E", "start": [1363, 1], "end": [1366, 24], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_eq_iInter_cthickening'", "code": "theorem closure_eq_iInter_cthickening' (E : Set \u03b1) (s : Set \u211d)\n    (hs : \u2200 \u03b5, 0 < \u03b5 \u2192 (s \u2229 Ioc 0 \u03b5).Nonempty) : closure E = \u22c2 \u03b4 \u2208 s, cthickening \u03b4 E", "start": [1369, 1], "end": [1381, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_eq_iInter_cthickening", "code": "theorem closure_eq_iInter_cthickening (E : Set \u03b1) :\n    closure E = \u22c2 (\u03b4 : \u211d) (_ : 0 < \u03b4), cthickening \u03b4 E", "start": [1384, 1], "end": [1388, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_eq_iInter_thickening'", "code": "theorem closure_eq_iInter_thickening' (E : Set \u03b1) (s : Set \u211d) (hs\u2080 : s \u2286 Ioi 0)\n    (hs : \u2200 \u03b5, 0 < \u03b5 \u2192 (s \u2229 Ioc 0 \u03b5).Nonempty) : closure E = \u22c2 \u03b4 \u2208 s, thickening \u03b4 E", "start": [1391, 1], "end": [1396, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_eq_iInter_thickening", "code": "theorem closure_eq_iInter_thickening (E : Set \u03b1) :\n    closure E = \u22c2 (\u03b4 : \u211d) (_ : 0 < \u03b4), thickening \u03b4 E", "start": [1399, 1], "end": [1403, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_cthickening_subset", "code": "theorem frontier_cthickening_subset (E : Set \u03b1) {\u03b4 : \u211d} :\n    frontier (cthickening \u03b4 E) \u2286 { x : \u03b1 | infEdist x E = ENNReal.ofReal \u03b4 }", "start": [1406, 1], "end": [1410, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_cthickening", "code": "theorem closedBall_subset_cthickening {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {x : \u03b1} {E : Set \u03b1}\n    (hx : x \u2208 E) (\u03b4 : \u211d) : closedBall x \u03b4 \u2286 cthickening \u03b4 E", "start": [1413, 1], "end": [1418, 17], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_subset_iUnion_closedBall_of_lt", "code": "theorem cthickening_subset_iUnion_closedBall_of_lt {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (E : Set \u03b1)\n    {\u03b4 \u03b4' : \u211d} (h\u03b4\u2080 : 0 < \u03b4') (h\u03b4\u03b4' : \u03b4 < \u03b4') : cthickening \u03b4 E \u2286 \u22c3 x \u2208 E, closedBall x \u03b4'", "start": [1421, 1], "end": [1425, 41], "kind": "commanddeclaration"}, {"full_name": "IsCompact.cthickening_eq_biUnion_closedBall", "code": "theorem _root_.IsCompact.cthickening_eq_biUnion_closedBall {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    {\u03b4 : \u211d} {E : Set \u03b1} (hE : IsCompact E) (h\u03b4 : 0 \u2264 \u03b4) :\n    cthickening \u03b4 E = \u22c3 x \u2208 E, closedBall x \u03b4", "start": [1428, 1], "end": [1444, 26], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_eq_biUnion_closedBall", "code": "theorem cthickening_eq_biUnion_closedBall {\u03b1 : Type*} [PseudoMetricSpace \u03b1] [ProperSpace \u03b1]\n    (E : Set \u03b1) (h\u03b4 : 0 \u2264 \u03b4) : cthickening \u03b4 E = \u22c3 x \u2208 closure E, closedBall x \u03b4", "start": [1447, 1], "end": [1459, 26], "kind": "commanddeclaration"}, {"full_name": "IsClosed.cthickening_eq_biUnion_closedBall", "code": "nonrec theorem _root_.IsClosed.cthickening_eq_biUnion_closedBall {\u03b1 : Type*} [PseudoMetricSpace \u03b1]\n    [ProperSpace \u03b1] {E : Set \u03b1} (hE : IsClosed E) (h\u03b4 : 0 \u2264 \u03b4) :\n    cthickening \u03b4 E = \u22c3 x \u2208 E, closedBall x \u03b4", "start": [1462, 1], "end": [1465, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.infEdist_le_infEdist_cthickening_add", "code": "theorem infEdist_le_infEdist_cthickening_add :\n    infEdist x s \u2264 infEdist x (cthickening \u03b4 s) + ENNReal.ofReal \u03b4", "start": [1468, 1], "end": [1476, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.infEdist_le_infEdist_thickening_add", "code": "theorem infEdist_le_infEdist_thickening_add :\n    infEdist x s \u2264 infEdist x (thickening \u03b4 s) + ENNReal.ofReal \u03b4", "start": [1479, 1], "end": [1483, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_thickening_subset", "code": "@[simp]\ntheorem thickening_thickening_subset (\u03b5 \u03b4 : \u211d) (s : Set \u03b1) :\n    thickening \u03b5 (thickening \u03b4 s) \u2286 thickening (\u03b5 + \u03b4) s", "start": [1486, 1], "end": [1497, 73], "kind": "commanddeclaration"}, {"full_name": "Metric.thickening_cthickening_subset", "code": "@[simp]\ntheorem thickening_cthickening_subset (\u03b5 : \u211d) (h\u03b4 : 0 \u2264 \u03b4) (s : Set \u03b1) :\n    thickening \u03b5 (cthickening \u03b4 s) \u2286 thickening (\u03b5 + \u03b4) s", "start": [1500, 1], "end": [1511, 83], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_thickening_subset", "code": "@[simp]\ntheorem cthickening_thickening_subset (h\u03b5 : 0 \u2264 \u03b5) (\u03b4 : \u211d) (s : Set \u03b1) :\n    cthickening \u03b5 (thickening \u03b4 s) \u2286 cthickening (\u03b5 + \u03b4) s", "start": [1514, 1], "end": [1522, 84], "kind": "commanddeclaration"}, {"full_name": "Metric.cthickening_cthickening_subset", "code": "@[simp]\ntheorem cthickening_cthickening_subset (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (s : Set \u03b1) :\n    cthickening \u03b5 (cthickening \u03b4 s) \u2286 cthickening (\u03b5 + \u03b4) s", "start": [1525, 1], "end": [1531, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_cthickening_disjoint", "code": "theorem frontier_cthickening_disjoint (A : Set \u03b1) :\n    Pairwise (Disjoint on fun r : \u211d\u22650 => frontier (cthickening r A))", "start": [1534, 1], "end": [1537, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/ULift.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "Mathlib/Data/ULift.lean", "Mathlib/CategoryTheory/EqToHom.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ULift.upFunctor", "code": "@[simps]\ndef ULift.upFunctor : C \u2964 ULift.{u\u2082} C where\n  obj := ULift.up\n  map f := f", "start": [49, 1], "end": [53, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULift.downFunctor", "code": "@[simps]\ndef ULift.downFunctor : ULift.{u\u2082} C \u2964 C where\n  obj := ULift.down\n  map f := f", "start": [56, 1], "end": [60, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULift.equivalence", "code": "@[simps]\ndef ULift.equivalence : C \u224c ULift.{u\u2082} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := \ud835\udfd9 _\n      inv := \ud835\udfd9 _ }\n  counitIso :=\n    { hom :=\n        { app := fun X => \ud835\udfd9 _\n          naturality := fun X Y f => by\n            change f \u226b \ud835\udfd9 _ = \ud835\udfd9 _ \u226b f\n            simp }\n      inv :=\n        { app := fun X => \ud835\udfd9 _\n          naturality := fun X Y f => by\n            change f \u226b \ud835\udfd9 _ = \ud835\udfd9 _ \u226b f\n            simp }\n      hom_inv_id := by\n        ext\n        change \ud835\udfd9 _ \u226b \ud835\udfd9 _ = \ud835\udfd9 _\n        simp\n      inv_hom_id := by\n        ext\n        change \ud835\udfd9 _ \u226b \ud835\udfd9 _ = \ud835\udfd9 _\n        simp }\n  functor_unitIso_comp X := by\n    change \ud835\udfd9 X \u226b \ud835\udfd9 X = \ud835\udfd9 X\n    simp", "start": [63, 1], "end": [92, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom", "code": "def ULiftHom.{w,u} (C : Type u) : Type u :=\n  let _ := ULift.{w} C\n  C", "start": [98, 1], "end": [103, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.objDown", "code": "def ULiftHom.objDown {C} (A : ULiftHom C) : C :=\n  A", "start": [109, 1], "end": [111, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.objUp", "code": "def ULiftHom.objUp {C} (A : C) : ULiftHom C :=\n  A", "start": [114, 1], "end": [116, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.objDown_objUp", "code": "@[simp]\ntheorem objDown_objUp {C} (A : C) : (ULiftHom.objUp A).objDown = A", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.objUp_objDown", "code": "@[simp]\ntheorem objUp_objDown {C} (A : ULiftHom C) : ULiftHom.objUp A.objDown = A", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.category", "code": "instance ULiftHom.category : Category.{max v\u2082 v\u2081} (ULiftHom.{v\u2082} C) where\n  Hom A B := ULift.{v\u2082} <| A.objDown \u27f6 B.objDown\n  id A := \u27e8\ud835\udfd9 _\u27e9\n  comp f g := \u27e8f.down \u226b g.down\u27e9", "start": [129, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.up", "code": "@[simps]\ndef ULiftHom.up : C \u2964 ULiftHom C where\n  obj := ULiftHom.objUp\n  map f := \u27e8f\u27e9", "start": [134, 1], "end": [138, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.down", "code": "@[simps]\ndef ULiftHom.down : ULiftHom C \u2964 C where\n  obj := ULiftHom.objDown\n  map f := f.down", "start": [141, 1], "end": [145, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHom.equiv", "code": "def ULiftHom.equiv : C \u224c ULiftHom C where\n  functor := ULiftHom.up\n  inverse := ULiftHom.down\n  unitIso := NatIso.ofComponents fun A => eqToIso rfl\n  counitIso := NatIso.ofComponents fun A => eqToIso rfl", "start": [148, 1], "end": [153, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.AsSmall", "code": "@[nolint unusedArguments]\ndef AsSmall.{w, v, u} (D : Type u) [Category.{v} D] := ULift.{max w v} D", "start": [160, 1], "end": [171, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.AsSmall.up", "code": "@[simps]\ndef AsSmall.up : C \u2964 AsSmall C where\n  obj X := \u27e8X\u27e9\n  map f := \u27e8f\u27e9", "start": [179, 1], "end": [183, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.AsSmall.down", "code": "@[simps]\ndef AsSmall.down : AsSmall C \u2964 C where\n  obj X := ULift.down X\n  map f := f.down", "start": [186, 1], "end": [190, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.AsSmall.equiv", "code": "@[simps]\ndef AsSmall.equiv : C \u224c AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun X => eqToIso rfl\n  counitIso := NatIso.ofComponents fun X => eqToIso <| ULift.ext _ _ rfl", "start": [193, 1], "end": [199, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ULiftHomULiftCategory.equiv", "code": "def ULiftHomULiftCategory.equiv.{v', u', v, u} (C : Type u) [Category.{v} C] :\n    C \u224c ULiftHom.{v'} (ULift.{u'} C) :=\n  ULift.equivalence.trans ULiftHom.equiv", "start": [205, 1], "end": [208, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/IsLimit.lean", "imports": ["Mathlib/CategoryTheory/Limits/Cones.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.IsLimit", "code": "structure IsLimit (t : Cone F) where\n  \n  lift : \u2200 s : Cone F, s.pt \u27f6 t.pt\n  \n  fac : \u2200 (s : Cone F) (j : J), lift s \u226b t.\u03c0.app j = s.\u03c0.app j := by aesop_cat\n  \n  uniq : \u2200 (s : Cone F) (m : s.pt \u27f6 t.pt) (_ : \u2200 j : J, m \u226b t.\u03c0.app j = s.\u03c0.app j), m = lift s := by\n    aesop_cat", "start": [51, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.subsingleton", "code": "instance subsingleton {t : Cone F} : Subsingleton (IsLimit t) :=\n  \u27e8by intro P Q; cases P; cases Q; congr; aesop_cat\u27e9", "start": [76, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.map", "code": "def map {F G : J \u2964 C} (s : Cone F) {t : Cone G} (P : IsLimit t) (\u03b1 : F \u27f6 G) : s.pt \u27f6 t.pt :=\n  P.lift ((Cones.postcompose \u03b1).obj s)", "start": [80, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.map_\u03c0", "code": "@[reassoc (attr := simp)]\ntheorem map_\u03c0 {F G : J \u2964 C} (c : Cone F) {d : Cone G} (hd : IsLimit d) (\u03b1 : F \u27f6 G) (j : J) :\n    hd.map c \u03b1 \u226b d.\u03c0.app j = c.\u03c0.app j \u226b \u03b1.app j", "start": [86, 1], "end": [89, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.lift_self", "code": "theorem lift_self {c : Cone F} (t : IsLimit c) : t.lift c = \ud835\udfd9 c.pt", "start": [92, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.liftConeMorphism", "code": "@[simps]\ndef liftConeMorphism {t : Cone F} (h : IsLimit t) (s : Cone F) : s \u27f6 t where hom := h.lift s", "start": [97, 1], "end": [99, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.uniq_cone_morphism", "code": "theorem uniq_cone_morphism {s t : Cone F} (h : IsLimit t) {f f' : s \u27f6 t} : f = f'", "start": [102, 1], "end": [105, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.existsUnique", "code": "theorem existsUnique {t : Cone F} (h : IsLimit t) (s : Cone F) :\n    \u2203! l : s.pt \u27f6 t.pt, \u2200 j, l \u226b t.\u03c0.app j = s.\u03c0.app j", "start": [108, 1], "end": [111, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofExistsUnique", "code": "def ofExistsUnique {t : Cone F}\n    (ht : \u2200 s : Cone F, \u2203! l : s.pt \u27f6 t.pt, \u2200 j, l \u226b t.\u03c0.app j = s.\u03c0.app j) : IsLimit t := by\n  choose s hs hs' using ht\n  exact \u27e8s, hs, hs'\u27e9", "start": [114, 1], "end": [118, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.mkConeMorphism", "code": "@[simps]\ndef mkConeMorphism {t : Cone F} (lift : \u2200 s : Cone F, s \u27f6 t)\n    (uniq : \u2200 (s : Cone F) (m : s \u27f6 t), m = lift s) : IsLimit t\n    where\n  lift s := (lift s).hom\n  uniq s m w :=\n    have : ConeMorphism.mk m w = lift s := by apply uniq\n    congrArg ConeMorphism.hom this", "start": [121, 1], "end": [132, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.uniqueUpToIso", "code": "@[simps]\ndef uniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s \u2245 t\n    where\n  hom := Q.liftConeMorphism s\n  inv := P.liftConeMorphism t\n  hom_inv_id := P.uniq_cone_morphism\n  inv_hom_id := Q.uniq_cone_morphism", "start": [135, 1], "end": [142, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.hom_isIso", "code": "theorem hom_isIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (f : s \u27f6 t) : IsIso f", "start": [145, 1], "end": [147, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso", "code": "def conePointUniqueUpToIso {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) : s.pt \u2245 t.pt :=\n  (Cones.forget F).mapIso (uniqueUpToIso P Q)", "start": [150, 1], "end": [152, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_hom_comp", "code": "@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_hom_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).hom \u226b t.\u03c0.app j = s.\u03c0.app j", "start": [155, 1], "end": [158, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso_inv_comp", "code": "@[reassoc (attr := simp)]\ntheorem conePointUniqueUpToIso_inv_comp {s t : Cone F} (P : IsLimit s) (Q : IsLimit t) (j : J) :\n    (conePointUniqueUpToIso P Q).inv \u226b s.\u03c0.app j = t.\u03c0.app j", "start": [161, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_hom {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    P.lift r \u226b (conePointUniqueUpToIso P Q).hom = Q.lift r", "start": [167, 1], "end": [170, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.lift_comp_conePointUniqueUpToIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem lift_comp_conePointUniqueUpToIso_inv {r s t : Cone F} (P : IsLimit s) (Q : IsLimit t) :\n    Q.lift r \u226b (conePointUniqueUpToIso P Q).inv = P.lift r", "start": [173, 1], "end": [176, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofIsoLimit", "code": "def ofIsoLimit {r t : Cone F} (P : IsLimit r) (i : r \u2245 t) : IsLimit t :=\n  IsLimit.mkConeMorphism (fun s => P.liftConeMorphism s \u226b i.hom) fun s m => by\n    rw [\u2190 i.comp_inv_eq]; apply P.uniq_cone_morphism", "start": [179, 1], "end": [182, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofIsoLimit_lift", "code": "@[simp]\ntheorem ofIsoLimit_lift {r t : Cone F} (P : IsLimit r) (i : r \u2245 t) (s) :\n    (P.ofIsoLimit i).lift s = P.lift s \u226b i.hom.hom", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.equivIsoLimit", "code": "def equivIsoLimit {r t : Cone F} (i : r \u2245 t) : IsLimit r \u2243 IsLimit t where\n  toFun h := h.ofIsoLimit i\n  invFun h := h.ofIsoLimit i.symm\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [191, 1], "end": [196, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.equivIsoLimit_apply", "code": "@[simp]\ntheorem equivIsoLimit_apply {r t : Cone F} (i : r \u2245 t) (P : IsLimit r) :\n    equivIsoLimit i P = P.ofIsoLimit i", "start": [199, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.equivIsoLimit_symm_apply", "code": "@[simp]\ntheorem equivIsoLimit_symm_apply {r t : Cone F} (i : r \u2245 t) (P : IsLimit t) :\n    (equivIsoLimit i).symm P = P.ofIsoLimit i.symm", "start": [205, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofPointIso", "code": "def ofPointIso {r t : Cone F} (P : IsLimit r) [i : IsIso (P.lift t)] : IsLimit t :=\n  ofIsoLimit P (by\n    haveI : IsIso (P.liftConeMorphism t).hom := i\n    haveI : IsIso (P.liftConeMorphism t) := Cones.cone_iso_of_hom_iso _\n    symm\n    apply asIso (P.liftConeMorphism t))", "start": [211, 1], "end": [219, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.hom_lift", "code": "theorem hom_lift (h : IsLimit t) {W : C} (m : W \u27f6 t.pt) :\n    m = h.lift { pt := W, \u03c0 := { app := fun b => m \u226b t.\u03c0.app b } }", "start": [224, 1], "end": [226, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.hom_ext", "code": "theorem hom_ext (h : IsLimit t) {W : C} {f f' : W \u27f6 t.pt}\n    (w : \u2200 j, f \u226b t.\u03c0.app j = f' \u226b t.\u03c0.app j) :\n    f = f'", "start": [229, 1], "end": [234, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofRightAdjoint", "code": "def ofRightAdjoint {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D} (h : Cone G \u2964 Cone F)\n    [IsRightAdjoint h] {c : Cone G} (t : IsLimit c) : IsLimit (h.obj c) :=\n  mkConeMorphism (fun s => (Adjunction.ofRightAdjoint h).homEquiv s c (t.liftConeMorphism _))\n    fun _ _ => (Adjunction.eq_homEquiv_apply _ _ _).2 t.uniq_cone_morphism", "start": [237, 1], "end": [243, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofConeEquiv", "code": "def ofConeEquiv {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D} (h : Cone G \u224c Cone F) {c : Cone G} :\n    IsLimit (h.functor.obj c) \u2243 IsLimit c\n    where\n  toFun P := ofIsoLimit (ofRightAdjoint h.inverse P) (h.unitIso.symm.app c)\n  invFun := ofRightAdjoint h.functor\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [246, 1], "end": [255, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofConeEquiv_apply_desc", "code": "@[simp]\ntheorem ofConeEquiv_apply_desc {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D} (h : Cone G \u224c Cone F)\n    {c : Cone G} (P : IsLimit (h.functor.obj c)) (s) :\n    (ofConeEquiv h P).lift s =\n      ((h.unitIso.hom.app s).hom \u226b (h.functor.inv.map (P.liftConeMorphism (h.functor.obj s))).hom) \u226b\n        (h.unitIso.inv.app c).hom", "start": [258, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofConeEquiv_symm_apply_desc", "code": "@[simp]\ntheorem ofConeEquiv_symm_apply_desc {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D}\n    (h : Cone G \u224c Cone F) {c : Cone G} (P : IsLimit c) (s) :\n    ((ofConeEquiv h).symm P).lift s =\n      (h.counitIso.inv.app s).hom \u226b (h.functor.map (P.liftConeMorphism (h.inverse.obj s))).hom", "start": [267, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.postcomposeHomEquiv", "code": "def postcomposeHomEquiv {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cone F) :\n    IsLimit ((Cones.postcompose \u03b1.hom).obj c) \u2243 IsLimit c :=\n  ofConeEquiv (Cones.postcomposeEquivalence \u03b1)", "start": [275, 1], "end": [280, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.postcomposeInvEquiv", "code": "def postcomposeInvEquiv {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cone G) :\n    IsLimit ((Cones.postcompose \u03b1.inv).obj c) \u2243 IsLimit c :=\n  postcomposeHomEquiv \u03b1.symm c", "start": [283, 1], "end": [288, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.equivOfNatIsoOfIso", "code": "def equivOfNatIsoOfIso {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cone F) (d : Cone G)\n    (w : (Cones.postcompose \u03b1.hom).obj c \u2245 d) : IsLimit c \u2243 IsLimit d :=\n  (postcomposeHomEquiv \u03b1 _).symm.trans (equivIsoLimit w)", "start": [291, 1], "end": [296, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso", "code": "@[simps]\ndef conePointsIsoOfNatIso {F G : J \u2964 C} {s : Cone F} {t : Cone G} (P : IsLimit s) (Q : IsLimit t)\n    (w : F \u2245 G) : s.pt \u2245 t.pt where\n  hom := Q.map s w.hom\n  inv := P.map t w.inv\n  hom_inv_id := P.hom_ext (by aesop_cat)\n  inv_hom_id := Q.hom_ext (by aesop_cat)", "start": [299, 1], "end": [308, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_hom_comp", "code": "@[reassoc]\ntheorem conePointsIsoOfNatIso_hom_comp {F G : J \u2964 C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F \u2245 G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).hom \u226b t.\u03c0.app j = s.\u03c0.app j \u226b w.hom.app j", "start": [311, 1], "end": [314, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointsIsoOfNatIso_inv_comp", "code": "@[reassoc]\ntheorem conePointsIsoOfNatIso_inv_comp {F G : J \u2964 C} {s : Cone F} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (w : F \u2245 G) (j : J) :\n    (conePointsIsoOfNatIso P Q w).inv \u226b s.\u03c0.app j = t.\u03c0.app j \u226b w.inv.app j", "start": [317, 1], "end": [320, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_hom", "code": "@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_hom {F G : J \u2964 C} {r s : Cone F} {t : Cone G}\n    (P : IsLimit s) (Q : IsLimit t) (w : F \u2245 G) :\n    P.lift r \u226b (conePointsIsoOfNatIso P Q w).hom = Q.map r w.hom", "start": [323, 1], "end": [327, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.lift_comp_conePointsIsoOfNatIso_inv", "code": "@[reassoc]\ntheorem lift_comp_conePointsIsoOfNatIso_inv {F G : J \u2964 C} {r s : Cone G} {t : Cone F}\n    (P : IsLimit t) (Q : IsLimit s) (w : F \u2245 G) :\n    Q.lift r \u226b (conePointsIsoOfNatIso P Q w).inv = P.map r w.inv", "start": [330, 1], "end": [334, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.whiskerEquivalence", "code": "def whiskerEquivalence {s : Cone F} (P : IsLimit s) (e : K \u224c J) : IsLimit (s.whisker e.functor) :=\n  ofRightAdjoint (Cones.whiskeringEquivalence e).functor P", "start": [341, 1], "end": [344, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofWhiskerEquivalence", "code": "def ofWhiskerEquivalence {s : Cone F} (e : K \u224c J) (P : IsLimit (s.whisker e.functor)) : IsLimit s :=\n  equivIsoLimit ((Cones.whiskeringEquivalence e).unitIso.app s).symm\n    (ofRightAdjoint (Cones.whiskeringEquivalence e).inverse P : _)", "start": [347, 1], "end": [351, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.whiskerEquivalenceEquiv", "code": "def whiskerEquivalenceEquiv {s : Cone F} (e : K \u224c J) : IsLimit s \u2243 IsLimit (s.whisker e.functor) :=\n  \u27e8fun h => h.whiskerEquivalence e, ofWhiskerEquivalence e, by aesop_cat, by aesop_cat\u27e9", "start": [354, 1], "end": [357, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.conePointsIsoOfEquivalence", "code": "@[simps]\ndef conePointsIsoOfEquivalence {F : J \u2964 C} {s : Cone F} {G : K \u2964 C} {t : Cone G} (P : IsLimit s)\n    (Q : IsLimit t) (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) : s.pt \u2245 t.pt :=\n  let w' : e.inverse \u22d9 F \u2245 G := (isoWhiskerLeft e.inverse w).symm \u226a\u226b invFunIdAssoc e G\n  { hom := Q.lift ((Cones.equivalenceOfReindexing e.symm w').functor.obj s)\n    inv := P.lift ((Cones.equivalenceOfReindexing e w).functor.obj t)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp\n      simp only [Limits.Cone.whisker_\u03c0, Limits.Cones.postcompose_obj_\u03c0, fac, whiskerLeft_app,\n        assoc, id_comp, invFunIdAssoc_hom_app, fac_assoc, NatTrans.comp_app]\n      rw [counit_app_functor, \u2190Functor.comp_map]\n      have l :\n        NatTrans.app w.hom j = NatTrans.app w.hom (Prefunctor.obj (\ud835\udfed J).toPrefunctor j) := by dsimp\n      rw [l,w.hom.naturality]\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }", "start": [360, 1], "end": [387, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.homIso", "code": "@[pp_dot]\ndef homIso (h : IsLimit t) (W : C) : ULift.{u\u2081} (W \u27f6 t.pt : Type v\u2083) \u2245 (const J).obj W \u27f6 F where\n  hom f := (t.extend f.down).\u03c0\n  inv \u03c0 := \u27e8h.lift { pt := W, \u03c0 }\u27e9\n  hom_inv_id := by\n    funext f; apply ULift.ext\n    apply h.hom_ext; intro j; simp", "start": [392, 1], "end": [400, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.homIso_hom", "code": "@[simp]\ntheorem homIso_hom (h : IsLimit t) {W : C} (f : ULift.{u\u2081} (W \u27f6 t.pt)) :\n    (IsLimit.homIso h W).hom f = (t.extend f.down).\u03c0", "start": [403, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.natIso", "code": "def natIso (h : IsLimit t) : yoneda.obj t.pt \u22d9 uliftFunctor.{u\u2081} \u2245 F.cones :=\n  NatIso.ofComponents fun W => IsLimit.homIso h (unop W)", "start": [409, 1], "end": [412, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.homIso'", "code": "@[pp_dot]\ndef homIso' (h : IsLimit t) (W : C) :\n    ULift.{u\u2081} (W \u27f6 t.pt : Type v\u2083) \u2245\n      { p : \u2200 j, W \u27f6 F.obj j // \u2200 {j j'} (f : j \u27f6 j'), p j \u226b F.map f = p j' } :=\n  h.homIso W \u226a\u226b\n    { hom := fun \u03c0 =>\n        \u27e8fun j => \u03c0.app j, fun f => by convert \u2190 (\u03c0.naturality f).symm; apply id_comp\u27e9\n      inv := fun p =>\n        { app := fun j => p.1 j\n          naturality := fun j j' f => by dsimp; rw [id_comp]; exact (p.2 f).symm } }", "start": [415, 1], "end": [426, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofFaithful", "code": "def ofFaithful {t : Cone F} {D : Type u\u2084} [Category.{v\u2084} D] (G : C \u2964 D) [Faithful G]\n    (ht : IsLimit (mapCone G t)) (lift : \u2200 s : Cone F, s.pt \u27f6 t.pt)\n    (h : \u2200 s, G.map (lift s) = ht.lift (mapCone G s)) : IsLimit t :=\n  { lift\n    fac := fun s j => by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac\n    uniq := fun s m w => by\n      apply G.map_injective; rw [h]\n      refine' ht.uniq (mapCone G s) _ fun j => _\n      convert \u2190 congrArg (fun f => G.map f) (w j)\n      apply G.map_comp }", "start": [429, 1], "end": [441, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.mapConeEquiv", "code": "def mapConeEquiv {D : Type u\u2084} [Category.{v\u2084} D] {K : J \u2964 C} {F G : C \u2964 D} (h : F \u2245 G) {c : Cone K}\n    (t : IsLimit (mapCone F c)) : IsLimit (mapCone G c) := by\n  apply postcomposeInvEquiv (isoWhiskerLeft K h : _) (mapCone G c) _\n  apply t.ofIsoLimit (postcomposeWhiskerLeftMapCone h.symm c).symm", "start": [444, 1], "end": [450, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.isoUniqueConeMorphism", "code": "def isoUniqueConeMorphism {t : Cone F} : IsLimit t \u2245 \u2200 s, Unique (s \u27f6 t) where\n  hom h s :=\n    { default := h.liftConeMorphism s\n      uniq := fun _ => h.uniq_cone_morphism }\n  inv h :=\n    { lift := fun s => (h s).default.hom\n      uniq := fun s f w => congrArg ConeMorphism.hom ((h s).uniq \u27e8f, w\u27e9) }", "start": [453, 1], "end": [462, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom", "code": "def coneOfHom {Y : C} (f : Y \u27f6 X) : Cone F where\n  pt := Y\n  \u03c0 := h.hom.app (op Y) \u27e8f\u27e9", "start": [469, 1], "end": [473, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone", "code": "def homOfCone (s : Cone F) : s.pt \u27f6 X :=\n  (h.inv.app (op s.pt) s.\u03c0).down", "start": [476, 1], "end": [478, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_homOfCone", "code": "@[simp]\ntheorem coneOfHom_homOfCone (s : Cone F) : coneOfHom h (homOfCone h s) = s", "start": [481, 1], "end": [487, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone_coneOfHom", "code": "@[simp]\ntheorem homOfCone_coneOfHom {Y : C} (f : Y \u27f6 X) : homOfCone h (coneOfHom h f) = f", "start": [490, 1], "end": [492, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.limitCone", "code": "def limitCone : Cone F :=\n  coneOfHom h (\ud835\udfd9 X)", "start": [495, 1], "end": [498, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.coneOfHom_fac", "code": "theorem coneOfHom_fac {Y : C} (f : Y \u27f6 X) : coneOfHom h f = (limitCone h).extend f", "start": [501, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac", "code": "theorem cone_fac (s : Cone F) : (limitCone h).extend (homOfCone h s) = s", "start": [513, 1], "end": [518, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsLimit.ofNatIso", "code": "def ofNatIso {X : C} (h : yoneda.obj X \u22d9 uliftFunctor.{u\u2081} \u2245 F.cones) : IsLimit (limitCone h)\n    where\n  lift s := homOfCone h s\n  fac s j := by\n    have h := cone_fac h s\n    cases s\n    injection h with h\u2081 h\u2082\n    simp only [heq_iff_eq] at h\u2082\n    conv_rhs => rw [\u2190 h\u2082]; rfl\n  uniq s m w := by\n    rw [\u2190 homOfCone_coneOfHom h m]\n    congr\n    rw [coneOfHom_fac]\n    dsimp [Cone.extend]; cases s; congr with j; exact w j", "start": [527, 1], "end": [543, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit", "code": "structure IsColimit (t : Cocone F) where\n  \n  desc : \u2200 s : Cocone F, t.pt \u27f6 s.pt\n  \n  fac : \u2200 (s : Cocone F) (j : J), t.\u03b9.app j \u226b desc s = s.\u03b9.app j := by aesop_cat\n  \n  uniq :\n    \u2200 (s : Cocone F) (m : t.pt \u27f6 s.pt) (_ : \u2200 j : J, t.\u03b9.app j \u226b m = s.\u03b9.app j), m = desc s := by\n    aesop_cat", "start": [550, 1], "end": [564, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.subsingleton", "code": "instance subsingleton {t : Cocone F} : Subsingleton (IsColimit t) :=\n  \u27e8by intro P Q; cases P; cases Q; congr; aesop_cat\u27e9", "start": [576, 1], "end": [577, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.map", "code": "def map {F G : J \u2964 C} {s : Cocone F} (P : IsColimit s) (t : Cocone G) (\u03b1 : F \u27f6 G) : s.pt \u27f6 t.pt :=\n  P.desc ((Cocones.precompose \u03b1).obj t)", "start": [580, 1], "end": [583, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.\u03b9_map", "code": "@[reassoc (attr := simp)]\ntheorem \u03b9_map {F G : J \u2964 C} {c : Cocone F} (hc : IsColimit c) (d : Cocone G) (\u03b1 : F \u27f6 G) (j : J) :\n    c.\u03b9.app j \u226b IsColimit.map hc d \u03b1 = \u03b1.app j \u226b d.\u03b9.app j", "start": [586, 1], "end": [589, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.desc_self", "code": "@[simp]\ntheorem desc_self {t : Cocone F} (h : IsColimit t) : h.desc t = \ud835\udfd9 t.pt", "start": [592, 1], "end": [594, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.descCoconeMorphism", "code": "@[simps]\ndef descCoconeMorphism {t : Cocone F} (h : IsColimit t) (s : Cocone F) : t \u27f6 s where hom := h.desc s", "start": [598, 1], "end": [600, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.uniq_cocone_morphism", "code": "theorem uniq_cocone_morphism {s t : Cocone F} (h : IsColimit t) {f f' : t \u27f6 s} : f = f'", "start": [603, 1], "end": [606, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.existsUnique", "code": "theorem existsUnique {t : Cocone F} (h : IsColimit t) (s : Cocone F) :\n    \u2203! d : t.pt \u27f6 s.pt, \u2200 j, t.\u03b9.app j \u226b d = s.\u03b9.app j", "start": [609, 1], "end": [612, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofExistsUnique", "code": "def ofExistsUnique {t : Cocone F}\n    (ht : \u2200 s : Cocone F, \u2203! d : t.pt \u27f6 s.pt, \u2200 j, t.\u03b9.app j \u226b d = s.\u03b9.app j) : IsColimit t := by\n  choose s hs hs' using ht\n  exact \u27e8s, hs, hs'\u27e9", "start": [615, 1], "end": [619, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.mkCoconeMorphism", "code": "@[simps]\ndef mkCoconeMorphism {t : Cocone F} (desc : \u2200 s : Cocone F, t \u27f6 s)\n    (uniq' : \u2200 (s : Cocone F) (m : t \u27f6 s), m = desc s) : IsColimit t\n    where\n  desc s := (desc s).hom\n  uniq s m w :=\n    have : CoconeMorphism.mk m w = desc s := by apply uniq'\n    congrArg CoconeMorphism.hom this", "start": [622, 1], "end": [633, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.uniqueUpToIso", "code": "@[simps]\ndef uniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s \u2245 t\n    where\n  hom := P.descCoconeMorphism t\n  inv := Q.descCoconeMorphism s\n  hom_inv_id := P.uniq_cocone_morphism\n  inv_hom_id := Q.uniq_cocone_morphism", "start": [636, 1], "end": [643, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.hom_isIso", "code": "theorem hom_isIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) (f : s \u27f6 t) : IsIso f", "start": [646, 1], "end": [648, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso", "code": "def coconePointUniqueUpToIso {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) : s.pt \u2245 t.pt :=\n  (Cocones.forget F).mapIso (uniqueUpToIso P Q)", "start": [651, 1], "end": [653, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_hom", "code": "@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_hom {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : s.\u03b9.app j \u226b (coconePointUniqueUpToIso P Q).hom = t.\u03b9.app j", "start": [656, 1], "end": [659, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.comp_coconePointUniqueUpToIso_inv", "code": "@[reassoc (attr := simp)]\ntheorem comp_coconePointUniqueUpToIso_inv {s t : Cocone F} (P : IsColimit s) (Q : IsColimit t)\n    (j : J) : t.\u03b9.app j \u226b (coconePointUniqueUpToIso P Q).inv = s.\u03b9.app j", "start": [662, 1], "end": [665, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_hom_desc", "code": "@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_hom_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).hom \u226b Q.desc r = P.desc r", "start": [668, 1], "end": [671, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointUniqueUpToIso_inv_desc", "code": "@[reassoc (attr := simp)]\ntheorem coconePointUniqueUpToIso_inv_desc {r s t : Cocone F} (P : IsColimit s) (Q : IsColimit t) :\n    (coconePointUniqueUpToIso P Q).inv \u226b P.desc r = Q.desc r", "start": [674, 1], "end": [677, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofIsoColimit", "code": "def ofIsoColimit {r t : Cocone F} (P : IsColimit r) (i : r \u2245 t) : IsColimit t :=\n  IsColimit.mkCoconeMorphism (fun s => i.inv \u226b P.descCoconeMorphism s) fun s m => by\n    rw [i.eq_inv_comp]; apply P.uniq_cocone_morphism", "start": [680, 1], "end": [683, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofIsoColimit_desc", "code": "@[simp]\ntheorem ofIsoColimit_desc {r t : Cocone F} (P : IsColimit r) (i : r \u2245 t) (s) :\n    (P.ofIsoColimit i).desc s = i.inv.hom \u226b P.desc s", "start": [686, 1], "end": [689, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.equivIsoColimit", "code": "def equivIsoColimit {r t : Cocone F} (i : r \u2245 t) : IsColimit r \u2243 IsColimit t where\n  toFun h := h.ofIsoColimit i\n  invFun h := h.ofIsoColimit i.symm\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [692, 1], "end": [697, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.equivIsoColimit_apply", "code": "@[simp]\ntheorem equivIsoColimit_apply {r t : Cocone F} (i : r \u2245 t) (P : IsColimit r) :\n    equivIsoColimit i P = P.ofIsoColimit i", "start": [700, 1], "end": [703, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.equivIsoColimit_symm_apply", "code": "@[simp]\ntheorem equivIsoColimit_symm_apply {r t : Cocone F} (i : r \u2245 t) (P : IsColimit t) :\n    (equivIsoColimit i).symm P = P.ofIsoColimit i.symm", "start": [706, 1], "end": [709, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofPointIso", "code": "def ofPointIso {r t : Cocone F} (P : IsColimit r) [i : IsIso (P.desc t)] : IsColimit t :=\n  ofIsoColimit P (by\n    haveI : IsIso (P.descCoconeMorphism t).hom := i\n    haveI : IsIso (P.descCoconeMorphism t) := Cocones.cocone_iso_of_hom_iso _\n    apply asIso (P.descCoconeMorphism t))", "start": [712, 1], "end": [719, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.hom_desc", "code": "theorem hom_desc (h : IsColimit t) {W : C} (m : t.pt \u27f6 W) :\n    m =\n      h.desc\n        { pt := W\n          \u03b9 :=\n            { app := fun b => t.\u03b9.app b \u226b m\n              naturality := by intros; erw [\u2190 assoc, t.\u03b9.naturality, comp_id, comp_id] } }", "start": [724, 1], "end": [736, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.hom_ext", "code": "theorem hom_ext (h : IsColimit t) {W : C} {f f' : t.pt \u27f6 W}\n    (w : \u2200 j, t.\u03b9.app j \u226b f = t.\u03b9.app j \u226b f') : f = f'", "start": [739, 1], "end": [743, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofLeftAdjoint", "code": "def ofLeftAdjoint {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D} (h : Cocone G \u2964 Cocone F)\n    [IsLeftAdjoint h] {c : Cocone G} (t : IsColimit c) : IsColimit (h.obj c) :=\n  mkCoconeMorphism\n    (fun s => ((Adjunction.ofLeftAdjoint h).homEquiv c s).symm (t.descCoconeMorphism _)) fun _ _ =>\n    (Adjunction.homEquiv_apply_eq _ _ _).1 t.uniq_cocone_morphism", "start": [746, 1], "end": [753, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofCoconeEquiv", "code": "def ofCoconeEquiv {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D} (h : Cocone G \u224c Cocone F)\n    {c : Cocone G} : IsColimit (h.functor.obj c) \u2243 IsColimit c\n    where\n  toFun P := ofIsoColimit (ofLeftAdjoint h.inverse P) (h.unitIso.symm.app c)\n  invFun := ofLeftAdjoint h.functor\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [756, 1], "end": [765, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofCoconeEquiv_apply_desc", "code": "@[simp]\ntheorem ofCoconeEquiv_apply_desc {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D}\n    (h : Cocone G \u224c Cocone F) {c : Cocone G} (P : IsColimit (h.functor.obj c)) (s) :\n    (ofCoconeEquiv h P).desc s =\n      (h.unit.app c).hom \u226b\n        (h.inverse.map (P.descCoconeMorphism (h.functor.obj s))).hom \u226b (h.unitInv.app s).hom", "start": [768, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofCoconeEquiv_symm_apply_desc", "code": "@[simp]\ntheorem ofCoconeEquiv_symm_apply_desc {D : Type u\u2084} [Category.{v\u2084} D] {G : K \u2964 D}\n    (h : Cocone G \u224c Cocone F) {c : Cocone G} (P : IsColimit c) (s) :\n    ((ofCoconeEquiv h).symm P).desc s =\n      (h.functor.map (P.descCoconeMorphism (h.inverse.obj s))).hom \u226b (h.counit.app s).hom", "start": [777, 1], "end": [782, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.precomposeHomEquiv", "code": "def precomposeHomEquiv {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cocone G) :\n    IsColimit ((Cocones.precompose \u03b1.hom).obj c) \u2243 IsColimit c :=\n  ofCoconeEquiv (Cocones.precomposeEquivalence \u03b1)", "start": [785, 1], "end": [790, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.precomposeInvEquiv", "code": "def precomposeInvEquiv {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cocone F) :\n    IsColimit ((Cocones.precompose \u03b1.inv).obj c) \u2243 IsColimit c :=\n  precomposeHomEquiv \u03b1.symm c", "start": [793, 1], "end": [798, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.equivOfNatIsoOfIso", "code": "def equivOfNatIsoOfIso {F G : J \u2964 C} (\u03b1 : F \u2245 G) (c : Cocone F) (d : Cocone G)\n    (w : (Cocones.precompose \u03b1.inv).obj c \u2245 d) : IsColimit c \u2243 IsColimit d :=\n  (precomposeInvEquiv \u03b1 _).symm.trans (equivIsoColimit w)", "start": [801, 1], "end": [806, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso", "code": "@[simps]\ndef coconePointsIsoOfNatIso {F G : J \u2964 C} {s : Cocone F} {t : Cocone G} (P : IsColimit s)\n    (Q : IsColimit t) (w : F \u2245 G) : s.pt \u2245 t.pt\n    where\n  hom := P.map t w.hom\n  inv := Q.map s w.inv\n  hom_inv_id := P.hom_ext (by aesop_cat)\n  inv_hom_id := Q.hom_ext (by aesop_cat)", "start": [809, 1], "end": [819, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_hom", "code": "@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_hom {F G : J \u2964 C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F \u2245 G) (j : J) :\n    s.\u03b9.app j \u226b (coconePointsIsoOfNatIso P Q w).hom = w.hom.app j \u226b t.\u03b9.app j", "start": [822, 1], "end": [825, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.comp_coconePointsIsoOfNatIso_inv", "code": "@[reassoc]\ntheorem comp_coconePointsIsoOfNatIso_inv {F G : J \u2964 C} {s : Cocone F} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F \u2245 G) (j : J) :\n    t.\u03b9.app j \u226b (coconePointsIsoOfNatIso P Q w).inv = w.inv.app j \u226b s.\u03b9.app j", "start": [828, 1], "end": [831, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_hom_desc", "code": "@[reassoc]\ntheorem coconePointsIsoOfNatIso_hom_desc {F G : J \u2964 C} {s : Cocone F} {r t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (w : F \u2245 G) :\n    (coconePointsIsoOfNatIso P Q w).hom \u226b Q.desc r = P.map _ w.hom", "start": [834, 1], "end": [838, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointsIsoOfNatIso_inv_desc", "code": "@[reassoc]\ntheorem coconePointsIsoOfNatIso_inv_desc {F G : J \u2964 C} {s : Cocone G} {r t : Cocone F}\n    (P : IsColimit t) (Q : IsColimit s) (w : F \u2245 G) :\n    (coconePointsIsoOfNatIso P Q w).inv \u226b P.desc r = Q.map _ w.inv", "start": [841, 1], "end": [845, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.whiskerEquivalence", "code": "def whiskerEquivalence {s : Cocone F} (P : IsColimit s) (e : K \u224c J) :\n    IsColimit (s.whisker e.functor) :=\n  ofLeftAdjoint (Cocones.whiskeringEquivalence e).functor P", "start": [852, 1], "end": [856, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofWhiskerEquivalence", "code": "def ofWhiskerEquivalence {s : Cocone F} (e : K \u224c J) (P : IsColimit (s.whisker e.functor)) :\n    IsColimit s :=\n  equivIsoColimit ((Cocones.whiskeringEquivalence e).unitIso.app s).symm\n    (ofLeftAdjoint (Cocones.whiskeringEquivalence e).inverse P : _)", "start": [859, 1], "end": [864, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.whiskerEquivalenceEquiv", "code": "def whiskerEquivalenceEquiv {s : Cocone F} (e : K \u224c J) :\n    IsColimit s \u2243 IsColimit (s.whisker e.functor) :=\n  \u27e8fun h => h.whiskerEquivalence e, ofWhiskerEquivalence e, by aesop_cat, by aesop_cat\u27e9", "start": [867, 1], "end": [871, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.coconePointsIsoOfEquivalence", "code": "@[simps]\ndef coconePointsIsoOfEquivalence {F : J \u2964 C} {s : Cocone F} {G : K \u2964 C} {t : Cocone G}\n    (P : IsColimit s) (Q : IsColimit t) (e : J \u224c K) (w : e.functor \u22d9 G \u2245 F) : s.pt \u2245 t.pt :=\n  let w' : e.inverse \u22d9 F \u2245 G := (isoWhiskerLeft e.inverse w).symm \u226a\u226b invFunIdAssoc e G\n  { hom := P.desc ((Cocones.equivalenceOfReindexing e w).functor.obj t)\n    inv := Q.desc ((Cocones.equivalenceOfReindexing e.symm w').functor.obj s)\n    hom_inv_id := by\n      apply hom_ext P; intro j\n      dsimp\n      simp only [Limits.Cocone.whisker_\u03b9, fac, invFunIdAssoc_inv_app, whiskerLeft_app, assoc,\n        comp_id, Limits.Cocones.precompose_obj_\u03b9, fac_assoc, NatTrans.comp_app]\n      rw [counitInv_app_functor, \u2190 Functor.comp_map, \u2190 w.inv.naturality_assoc]\n      dsimp\n      simp\n    inv_hom_id := by\n      apply hom_ext Q\n      aesop_cat }", "start": [874, 1], "end": [899, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.homIso", "code": "@[pp_dot]\ndef homIso (h : IsColimit t) (W : C) : ULift.{u\u2081} (t.pt \u27f6 W : Type v\u2083) \u2245 F \u27f6 (const J).obj W where\n  hom f := (t.extend f.down).\u03b9\n  inv \u03b9 := \u27e8h.desc\n      { pt := W\n        \u03b9 }\u27e9\n  hom_inv_id := by\n    funext f; apply ULift.ext\n    apply h.hom_ext; intro j; simp", "start": [904, 1], "end": [914, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.homIso_hom", "code": "@[simp]\ntheorem homIso_hom (h : IsColimit t) {W : C} (f : ULift (t.pt \u27f6 W)) :\n    (IsColimit.homIso h W).hom f = (t.extend f.down).\u03b9", "start": [917, 1], "end": [920, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.natIso", "code": "def natIso (h : IsColimit t) : coyoneda.obj (op t.pt) \u22d9 uliftFunctor.{u\u2081} \u2245 F.cocones :=\n  NatIso.ofComponents (IsColimit.homIso h)", "start": [923, 1], "end": [926, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.homIso'", "code": "@[pp_dot]\ndef homIso' (h : IsColimit t) (W : C) :\n    ULift.{u\u2081} (t.pt \u27f6 W : Type v\u2083) \u2245\n      { p : \u2200 j, F.obj j \u27f6 W // \u2200 {j j' : J} (f : j \u27f6 j'), F.map f \u226b p j' = p j } :=\n  h.homIso W \u226a\u226b\n    { hom := fun \u03b9 =>\n        \u27e8fun j => \u03b9.app j, fun {j} {j'} f => by convert \u2190 \u03b9.naturality f; apply comp_id\u27e9\n      inv := fun p =>\n        { app := fun j => p.1 j\n          naturality := fun j j' f => by dsimp; rw [comp_id]; exact p.2 f } }", "start": [929, 1], "end": [940, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofFaithful", "code": "def ofFaithful {t : Cocone F} {D : Type u\u2084} [Category.{v\u2084} D] (G : C \u2964 D) [Faithful G]\n    (ht : IsColimit (mapCocone G t)) (desc : \u2200 s : Cocone F, t.pt \u27f6 s.pt)\n    (h : \u2200 s, G.map (desc s) = ht.desc (mapCocone G s)) : IsColimit t :=\n  { desc\n    fac := fun s j => by apply G.map_injective; rw [G.map_comp, h]; apply ht.fac\n    uniq := fun s m w => by\n      apply G.map_injective; rw [h]\n      refine' ht.uniq (mapCocone G s) _ fun j => _\n      convert \u2190 congrArg (fun f => G.map f) (w j)\n      apply G.map_comp }", "start": [943, 1], "end": [955, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.mapCoconeEquiv", "code": "def mapCoconeEquiv {D : Type u\u2084} [Category.{v\u2084} D] {K : J \u2964 C} {F G : C \u2964 D} (h : F \u2245 G)\n    {c : Cocone K} (t : IsColimit (mapCocone F c)) : IsColimit (mapCocone G c) := by\n  apply IsColimit.ofIsoColimit _ (precomposeWhiskerLeftMapCocone h c)\n  apply (precomposeInvEquiv (isoWhiskerLeft K h : _) _).symm t", "start": [958, 1], "end": [964, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.isoUniqueCoconeMorphism", "code": "def isoUniqueCoconeMorphism {t : Cocone F} : IsColimit t \u2245 \u2200 s, Unique (t \u27f6 s) where\n  hom h s :=\n    { default := h.descCoconeMorphism s\n      uniq := fun _ => h.uniq_cocone_morphism }\n  inv h :=\n    { desc := fun s => (h s).default.hom\n      uniq := fun s f w => congrArg CoconeMorphism.hom ((h s).uniq \u27e8f, w\u27e9) }", "start": [967, 1], "end": [976, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom", "code": "def coconeOfHom {Y : C} (f : X \u27f6 Y) : Cocone F where\n  pt := Y\n  \u03b9 := h.hom.app Y \u27e8f\u27e9", "start": [983, 1], "end": [987, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone", "code": "def homOfCocone (s : Cocone F) : X \u27f6 s.pt :=\n  (h.inv.app s.pt s.\u03b9).down", "start": [990, 1], "end": [992, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_homOfCocone", "code": "@[simp]\ntheorem coconeOfHom_homOfCocone (s : Cocone F) : coconeOfHom h (homOfCocone h s) = s", "start": [995, 1], "end": [1000, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.homOfCocone_cooneOfHom", "code": "@[simp]\ntheorem homOfCocone_cooneOfHom {Y : C} (f : X \u27f6 Y) : homOfCocone h (coconeOfHom h f) = f", "start": [1003, 1], "end": [1005, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.colimitCocone", "code": "def colimitCocone : Cocone F :=\n  coconeOfHom h (\ud835\udfd9 X)", "start": [1008, 1], "end": [1011, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.coconeOfHom_fac", "code": "theorem coconeOfHom_fac {Y : C} (f : X \u27f6 Y) : coconeOfHom h f = (colimitCocone h).extend f", "start": [1014, 1], "end": [1023, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.OfNatIso.cocone_fac", "code": "theorem cocone_fac (s : Cocone F) : (colimitCocone h).extend (homOfCocone h s) = s", "start": [1026, 1], "end": [1031, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.IsColimit.ofNatIso", "code": "def ofNatIso {X : C} (h : coyoneda.obj (op X) \u22d9 uliftFunctor.{u\u2081} \u2245 F.cocones) :\n    IsColimit (colimitCocone h) where\n  desc s := homOfCocone h s\n  fac s j := by\n    have h := cocone_fac h s\n    cases s\n    injection h with h\u2081 h\u2082\n    simp only [heq_iff_eq] at h\u2082\n    conv_rhs => rw [\u2190 h\u2082]; rfl\n  uniq s m w := by\n    rw [\u2190 homOfCocone_cooneOfHom h m]\n    congr\n    rw [coconeOfHom_fac]\n    dsimp [Cocone.extend]; cases s; congr with j; exact w j", "start": [1040, 1], "end": [1056, 60], "kind": "commanddeclaration"}]}
